{"sha": "9857048929c1adc90a19b2027931ac73a28f21dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NTcwNDg5MjljMWFkYzkwYTE5YjIwMjc5MzFhYzczYTI4ZjIxZGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T23:36:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T23:47:50Z"}, "message": "Convert rustc::driver::session to istrs. Issue #855", "tree": {"sha": "39fb70c640ae6ff062e7be7bc7831973a0a51afc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39fb70c640ae6ff062e7be7bc7831973a0a51afc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9857048929c1adc90a19b2027931ac73a28f21dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9857048929c1adc90a19b2027931ac73a28f21dc", "html_url": "https://github.com/rust-lang/rust/commit/9857048929c1adc90a19b2027931ac73a28f21dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9857048929c1adc90a19b2027931ac73a28f21dc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dc24194434ee918a2ee6e02065c1f11dfb10415", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dc24194434ee918a2ee6e02065c1f11dfb10415", "html_url": "https://github.com/rust-lang/rust/commit/3dc24194434ee918a2ee6e02065c1f11dfb10415"}], "stats": {"total": 739, "additions": 379, "deletions": 360}, "files": [{"sha": "1f249b0b158350b26462259b7fa2a1c033624907", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -35,16 +35,16 @@ tag output_type {\n fn llvm_err(sess: session::session, msg: &istr) {\n     let buf = llvm::LLVMRustGetLastError();\n     if buf == std::ptr::null() {\n-        sess.fatal(istr::to_estr(msg));\n+        sess.fatal(msg);\n     } else {\n         sess.fatal(\n-            istr::to_estr(msg + ~\": \" + istr::str_from_cstr(buf)));\n+            msg + ~\": \" + istr::str_from_cstr(buf));\n     }\n }\n \n fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n     let path =\n-        fs::connect(istr::from_estr(sess.get_opts().sysroot),\n+        fs::connect(sess.get_opts().sysroot,\n                     ~\"lib/intrinsics.bc\");\n     let membuf = istr::as_buf(path, { |buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n@@ -374,8 +374,9 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n \n     fn warn_missing(sess: &session::session, name: &istr, default: &istr) {\n         if !sess.get_opts().library { ret; }\n-        sess.warn(#fmt[\"missing crate link meta '%s', using '%s' as default\",\n-                       istr::to_estr(name), istr::to_estr(default)]);\n+        sess.warn(istr::from_estr(\n+            #fmt[\"missing crate link meta '%s', using '%s' as default\",\n+                       istr::to_estr(name), istr::to_estr(default)]));\n     }\n \n     fn crate_meta_name(sess: &session::session, _crate: &ast::crate,"}, {"sha": "22feacbb5988c540e15115bf6607ddcaf6654d95", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -416,8 +416,8 @@ fn build_session_options(binary: str, match: &getopts::match, binary_dir: str)\n           time_passes: time_passes,\n           time_llvm_passes: time_llvm_passes,\n           output_type: output_type,\n-          library_search_paths: library_search_paths,\n-          sysroot: sysroot,\n+          library_search_paths: istr::from_estrs(library_search_paths),\n+          sysroot: istr::from_estr(sysroot),\n           cfg: cfg,\n           test: test,\n           parse_only: parse_only,\n@@ -442,8 +442,8 @@ fn parse_pretty(sess: session::session, name: &istr) -> pp_mode {\n     } else if istr::eq(name, ~\"typed\") {\n         ret ppm_typed;\n     } else if istr::eq(name, ~\"identified\") { ret ppm_identified; }\n-    sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \"\n-               + \"`identified`\");\n+    sess.fatal(~\"argument to `pretty` must be one of `normal`, `typed`, or \"\n+               + ~\"`identified`\");\n }\n \n fn opts() -> [getopts::opt] {\n@@ -486,16 +486,16 @@ fn main(args: [str]) {\n     let glue = opt_present(match, ~\"glue\");\n     if glue {\n         if n_inputs > 0u {\n-            sess.fatal(\"No input files allowed with --glue.\");\n+            sess.fatal(~\"No input files allowed with --glue.\");\n         }\n         let out = option::from_maybe::<istr>(~\"glue.bc\", output_file);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n     if n_inputs == 0u {\n-        sess.fatal(\"No input filename given.\");\n+        sess.fatal(~\"No input filename given.\");\n     } else if n_inputs > 1u {\n-        sess.fatal(\"Multiple input filenames provided.\");\n+        sess.fatal(~\"Multiple input filenames provided.\");\n     }\n     let ifile = match.free[0];\n     let saved_out_filename: str = \"\";\n@@ -631,9 +631,11 @@ fn main(args: [str]) {\n \n     let err_code = run::run_program(prog, gcc_args);\n     if 0 != err_code {\n-        sess.err(#fmt[\"linking with gcc failed with code %d\", err_code]);\n-        sess.note(#fmt[\"gcc arguments: %s\",\n-                       istr::to_estr(istr::connect(gcc_args, ~\" \"))]);\n+        sess.err(istr::from_estr(\n+            #fmt[\"linking with gcc failed with code %d\", err_code]));\n+        sess.note(istr::from_estr(\n+            #fmt[\"gcc arguments: %s\",\n+                       istr::to_estr(istr::connect(gcc_args, ~\" \"))]));\n         sess.abort_if_errors();\n     }\n     // Clean up on Darwin"}, {"sha": "d3ccc6e68f94c404e551fd06cee5ecd85c6f22f3", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -38,15 +38,15 @@ type options =\n      time_passes: bool,\n      time_llvm_passes: bool,\n      output_type: back::link::output_type,\n-     library_search_paths: [str],\n-     sysroot: str,\n+     library_search_paths: [istr],\n+     sysroot: istr,\n      cfg: ast::crate_cfg,\n      test: bool,\n      parse_only: bool,\n      no_trans: bool,\n      do_gc: bool};\n \n-type crate_metadata = {name: str, data: [u8]};\n+type crate_metadata = {name: istr, data: [u8]};\n \n obj session(targ_cfg: @config,\n             opts: @options,\n@@ -59,50 +59,54 @@ obj session(targ_cfg: @config,\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n     fn get_cstore() -> metadata::cstore::cstore { cstore }\n-    fn span_fatal(sp: span, msg: str) -> ! {\n+    fn span_fatal(sp: span, msg: &istr) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_error(some(sp), istr::from_estr(msg), parse_sess.cm);\n+        codemap::emit_error(some(sp), msg, parse_sess.cm);\n         fail;\n     }\n-    fn fatal(msg: str) -> ! {\n-        codemap::emit_error(none, istr::from_estr(msg), parse_sess.cm);\n+    fn fatal(msg: &istr) -> ! {\n+        codemap::emit_error(none, msg, parse_sess.cm);\n         fail;\n     }\n-    fn span_err(sp: span, msg: str) {\n-        codemap::emit_error(some(sp), istr::from_estr(msg), parse_sess.cm);\n+    fn span_err(sp: span, msg: &istr) {\n+        codemap::emit_error(some(sp), msg, parse_sess.cm);\n         err_count += 1u;\n     }\n-    fn err(msg: str) {\n-        codemap::emit_error(none, istr::from_estr(msg), parse_sess.cm);\n+    fn err(msg: &istr) {\n+        codemap::emit_error(none, msg, parse_sess.cm);\n         err_count += 1u;\n     }\n     fn abort_if_errors() {\n-        if err_count > 0u { self.fatal(\"aborting due to previous errors\"); }\n+        if err_count > 0u { self.fatal(~\"aborting due to previous errors\"); }\n     }\n-    fn span_warn(sp: span, msg: str) {\n+    fn span_warn(sp: span, msg: &istr) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_warning(some(sp), istr::from_estr(msg), parse_sess.cm);\n+        codemap::emit_warning(some(sp), msg, parse_sess.cm);\n     }\n-    fn warn(msg: str) {\n-        codemap::emit_warning(none, istr::from_estr(msg), parse_sess.cm);\n+    fn warn(msg: &istr) {\n+        codemap::emit_warning(none, msg, parse_sess.cm);\n     }\n-    fn span_note(sp: span, msg: str) {\n+    fn span_note(sp: span, msg: &istr) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_note(some(sp), istr::from_estr(msg), parse_sess.cm);\n+        codemap::emit_note(some(sp), msg, parse_sess.cm);\n     }\n-    fn note(msg: str) {\n-        codemap::emit_note(none, istr::from_estr(msg), parse_sess.cm);\n+    fn note(msg: &istr) {\n+        codemap::emit_note(none, msg, parse_sess.cm);\n     }\n-    fn span_bug(sp: span, msg: str) -> ! {\n-        self.span_fatal(sp, #fmt[\"internal compiler error %s\", msg]);\n+    fn span_bug(sp: span, msg: &istr) -> ! {\n+        self.span_fatal(sp,\n+                        istr::from_estr(#fmt[\"internal compiler error %s\",\n+                                             istr::to_estr(msg)]));\n     }\n-    fn bug(msg: str) -> ! {\n-        self.fatal(#fmt[\"internal compiler error %s\", msg]);\n+    fn bug(msg: &istr) -> ! {\n+        self.fatal(istr::from_estr(\n+            #fmt[\"internal compiler error %s\",\n+                 istr::to_estr(msg)]));\n     }\n-    fn span_unimpl(sp: span, msg: str) -> ! {\n-        self.span_bug(sp, \"unimplemented \" + msg);\n+    fn span_unimpl(sp: span, msg: &istr) -> ! {\n+        self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    fn unimpl(msg: str) -> ! { self.bug(\"unimplemented \" + msg); }\n+    fn unimpl(msg: &istr) -> ! { self.bug(~\"unimplemented \" + msg); }\n     fn get_codemap() -> codemap::codemap { ret parse_sess.cm; }\n     fn lookup_pos(pos: uint) -> codemap::loc {\n         ret codemap::lookup_char_pos(parse_sess.cm, pos);\n@@ -111,8 +115,8 @@ obj session(targ_cfg: @config,\n     fn next_node_id() -> ast::node_id {\n         ret syntax::parse::parser::next_node_id(parse_sess);\n     }\n-    fn span_str(sp: span) -> str {\n-        ret istr::to_estr(codemap::span_to_str(sp, self.get_codemap()));\n+    fn span_str(sp: span) -> istr {\n+        ret codemap::span_to_str(sp, self.get_codemap());\n     }\n     fn set_main_id(d: node_id) { main_fn = some(d); }\n     fn get_main_id() -> option::t<node_id> { main_fn }"}, {"sha": "516da981af3faa78d13888d03204df62966fba74", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -185,9 +185,9 @@ fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n     for meta: @ast::meta_item in metas {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n-            sess.span_fatal(meta.span,\n+            sess.span_fatal(meta.span, istr::from_estr(\n                             #fmt[\"duplicate meta item `%s`\",\n-                                 istr::to_estr(name)]);\n+                                 istr::to_estr(name)]));\n         }\n         map.insert(name, ());\n     }"}, {"sha": "a91a0318f45645fbca0ef4c9c1a0ec718d272ef7", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -36,7 +36,7 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n         @{sess: sess,\n           crate_cache: @std::map::new_str_hash::<int>(),\n           library_search_paths:\n-          istr::from_estrs(sess.get_opts().library_search_paths),\n+          sess.get_opts().library_search_paths,\n           mutable next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n@@ -230,8 +230,9 @@ fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n     alt find_library_crate(sess, ident, metas, library_search_paths) {\n       some(t) { ret t; }\n       none. {\n-        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\",\n-                                   istr::to_estr(ident)]);\n+        sess.span_fatal(span, istr::from_estr(\n+                        #fmt[\"can't find crate for '%s'\",\n+                                   istr::to_estr(ident)]));\n       }\n     }\n }"}, {"sha": "a729c5963750b2b1ade065622e09530e7c52a481", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -63,7 +63,7 @@ fn translate_def_id(sess: &session::session, searched_crate: ast::crate_num,\n     let local_cnum =\n         alt cmeta.cnum_map.find(ext_cnum) {\n           option::some(n) { n }\n-          option::none. { sess.bug(\"didn't find a crate in the cnum_map\") }\n+          option::none. { sess.bug(~\"didn't find a crate in the cnum_map\") }\n         };\n \n     ret {crate: local_cnum, node: node_id};"}, {"sha": "6306370f37376450431a5ae81efb993bb27e94f9", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -129,8 +129,8 @@ fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n             let root = expr_root(*cx, ex, false);\n             if mut_field(root.ds) {\n                 cx.tcx.sess.span_err(ex.span,\n-                                     \"result of put must be\" +\n-                                         \" immutably rooted\");\n+                                     ~\"result of put must be\" +\n+                                         ~\" immutably rooted\");\n             }\n             visit_expr(cx, ex, sc, v);\n           }\n@@ -202,25 +202,25 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n                         if is_immutable_alias(cx, sc, dnum) {\n                             cx.tcx.sess.span_err(\n                                 arg.span,\n-                                \"passing an immutable alias \\\n+                                ~\"passing an immutable alias \\\n                                  by mutable alias\");\n                         } else if is_immutable_objfield(cx, dnum) {\n                             cx.tcx.sess.span_err(\n                                 arg.span,\n-                                \"passing an immutable object \\\n+                                ~\"passing an immutable object \\\n                                  field by mutable alias\");\n                         }\n                     } else {\n                         cx.tcx.sess.span_err(\n                             arg.span,\n-                            \"passing a static item by mutable alias\");\n+                            ~\"passing a static item by mutable alias\");\n                     }\n                     mut_roots += [{arg: i, node: dnum}];\n                   }\n                   _ {\n                     if !mut_field(root.ds) {\n                         let m =\n-                            \"passing a temporary value or \\\n+                            ~\"passing a temporary value or \\\n                                  immutable field by mutable alias\";\n                         cx.tcx.sess.span_err(arg.span, m);\n                     }\n@@ -242,10 +242,10 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n         alt f.node {\n           ast::expr_path(_) {\n             if def_is_local(cx.tcx.def_map.get(f.id), true) {\n-                cx.tcx.sess.span_err(f.span,\n+                cx.tcx.sess.span_err(f.span, istr::from_estr(\n                                      #fmt[\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n-                                          unsafe_t_offsets[0]]);\n+                                          unsafe_t_offsets[0]]));\n             }\n           }\n           _ { }\n@@ -260,10 +260,10 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n             let mut_alias = arg_t.mode == ty::mo_alias(true);\n             if i != offset &&\n                    ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias) {\n-                cx.tcx.sess.span_err(args[i].span,\n+                cx.tcx.sess.span_err(args[i].span, istr::from_estr(\n                                      #fmt[\"argument %u may alias with \\\n                      argument %u, which is not immutably rooted\",\n-                                          i, offset]);\n+                                          i, offset]));\n             }\n             i += 1u;\n         }\n@@ -286,7 +286,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n \n         if mut_alias_to_root {\n             cx.tcx.sess.span_err(args[root.arg].span,\n-                                 \"passing a mutable alias to a \\\n+                                 ~\"passing a mutable alias to a \\\n                  variable that roots another alias\");\n         }\n     }\n@@ -309,7 +309,7 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n                   some(arg(ast::alias(mut))) {\n                     if mut_a && !mut {\n                         cx.tcx.sess.span_err(args[i].span,\n-                                             \"passing an immutable \\\n+                                             ~\"passing an immutable \\\n                                      alias by mutable alias\");\n                     }\n                   }\n@@ -320,7 +320,7 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n             }\n             if !ok {\n                 cx.tcx.sess.span_err(args[i].span,\n-                                     \"can not pass a local value by \\\n+                                     ~\"can not pass a local value by \\\n                                      alias to a tail call\");\n             }\n         }\n@@ -392,8 +392,8 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n       _ {\n         cx.tcx.sess.span_unimpl(\n             seq.span,\n-            \"unknown seq type \" +\n-            istr::to_estr(util::ppaux::ty_to_str(cx.tcx, seq_t)));\n+            ~\"unknown seq type \" +\n+            util::ppaux::ty_to_str(cx.tcx, seq_t));\n       }\n     }\n     let bindings = ast_util::pat_binding_ids(local.node.pat);\n@@ -435,10 +435,10 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n         let dnum = ast_util::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n         cx.mut_map.insert(dnum, ());\n         if is_immutable_alias(*cx, sc, dnum) {\n-            cx.tcx.sess.span_err(dest.span, \"assigning to immutable alias\");\n+            cx.tcx.sess.span_err(dest.span, ~\"assigning to immutable alias\");\n         } else if is_immutable_objfield(*cx, dnum) {\n             cx.tcx.sess.span_err(dest.span,\n-                                 \"assigning to immutable obj field\");\n+                                 ~\"assigning to immutable obj field\");\n         }\n         for r: restrict in *sc {\n             if vec::member(dnum, r.root_vars) {\n@@ -449,16 +449,16 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n       _ {\n         let root = expr_root(*cx, dest, false);\n         if vec::len(*root.ds) == 0u {\n-            cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n+            cx.tcx.sess.span_err(dest.span, ~\"assignment to non-lvalue\");\n         } else if !root.ds[0].mut {\n             let name =\n                 alt root.ds[0].kind {\n-                  unbox. { \"box\" }\n-                  field. { \"field\" }\n-                  index. { \"vec content\" }\n+                  unbox. { ~\"box\" }\n+                  field. { ~\"field\" }\n+                  index. { ~\"vec content\" }\n                 };\n             cx.tcx.sess.span_err(dest.span,\n-                                 \"assignment to immutable \" + name);\n+                                 ~\"assignment to immutable \" + name);\n         }\n         visit_expr(cx, dest, sc, v);\n       }\n@@ -471,7 +471,7 @@ fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt<scope>) {\n         alt cx.tcx.def_map.get(src.id) {\n           ast::def_obj_field(_) {\n             cx.tcx.sess.span_err(src.span,\n-                                 \"may not move out of an obj field\");\n+                                 ~\"may not move out of an obj field\");\n           }\n           _ { }\n         }\n@@ -482,7 +482,7 @@ fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt<scope>) {\n \n         // Not a path and no-derefs means this is a temporary.\n         if vec::len(*root.ds) != 0u {\n-            cx.tcx.sess.span_err(src.span, \"moving out of a data structure\");\n+            cx.tcx.sess.span_err(src.span, ~\"moving out of a data structure\");\n         }\n       }\n     }\n@@ -518,19 +518,19 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n         let msg =\n             alt prob {\n               overwritten(sp, wpt) {\n-                {span: sp, msg: \"overwriting \" +\n-                    istr::to_estr(ast_util::path_name(wpt))}\n+                {span: sp, msg: ~\"overwriting \" +\n+                    ast_util::path_name(wpt)}\n               }\n               val_taken(sp, vpt) {\n                 {span: sp,\n-                 msg: \"taking the value of \" +\n-                     istr::to_estr(ast_util::path_name(vpt))}\n+                 msg: ~\"taking the value of \" +\n+                     ast_util::path_name(vpt)}\n               }\n             };\n         cx.tcx.sess.span_err(msg.span,\n-                             msg.msg + \" will invalidate alias \" +\n-                             istr::to_estr(ast_util::path_name(p)) +\n-                             \", which is still used\");\n+                             msg.msg + ~\" will invalidate alias \" +\n+                             ast_util::path_name(p) +\n+                             ~\", which is still used\");\n     }\n }\n "}, {"sha": "a764388fdf73c3a4e56a1a88d10727bc54ddde09", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -34,7 +34,7 @@ fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n                 j += 1;\n             }\n             if !reachable {\n-                tcx.sess.span_err(arm_pat.span, \"unreachable pattern\");\n+                tcx.sess.span_err(arm_pat.span, ~\"unreachable pattern\");\n             }\n         }\n         i += 1;\n@@ -106,7 +106,7 @@ fn check_local(tcx: &ty::ctxt, loc: &@local, s: &(), v: &visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(tcx, loc.node.pat) {\n         tcx.sess.span_err(loc.node.pat.span,\n-                          \"refutable pattern in local binding\");\n+                          ~\"refutable pattern in local binding\");\n     }\n }\n "}, {"sha": "32496ca7572506dbf672a98f005aa1a93a44b141", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -57,7 +57,7 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n               ast::expr_path(path) {\n                 if !def_map.contains_key(expr.id) {\n                     sess.span_fatal(expr.span,\n-                                    \"internal error in collect_freevars\");\n+                                    ~\"internal error in collect_freevars\");\n                 }\n                 alt def_map.get(expr.id) {\n                   ast::def_arg(did) { *refs += [expr.id]; }"}, {"sha": "5e6e428118c6193c30277cd6c647304fd0a48859", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -78,8 +78,8 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n         bld::Call(bcx, gcroot, [llvalptr, llsrcindex]);\n       }\n       tk_param. {\n-        bcx_tcx(cx).sess.bug(\"we should never be trying to root values \" +\n-                                 \"of a type parameter\");\n+        bcx_tcx(cx).sess.bug(~\"we should never be trying to root values \" +\n+                                 ~\"of a type parameter\");\n       }\n       tk_static. {\n         // Static type descriptor."}, {"sha": "3846620103c4f743fd4eadac7b33909bf759d725", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -123,7 +123,7 @@ fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n             #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n                  descr, kind_to_str(k_need), kind_to_str(tk.kind),\n                  istr::to_estr(util::ppaux::ty_to_str(tcx, tk.ty))];\n-        tcx.sess.span_err(e.span, s);\n+        tcx.sess.span_err(e.span, istr::from_estr(s));\n     }\n }\n \n@@ -172,7 +172,7 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n                                   needed %s type, got %s type %s\",\n                              i, kind_to_str(k_need), kind_to_str(k),\n                              istr::to_estr(util::ppaux::ty_to_str(tcx, t))];\n-                    tcx.sess.span_err(e.span, s);\n+                    tcx.sess.span_err(e.span, istr::from_estr(s));\n                 }\n                 i += 1;\n             }"}, {"sha": "5de1fa7baffcb8f2b0f475f11bea803e83d30f4d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -323,8 +323,8 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n               }\n               _ {\n                 e.sess.span_err(p.span,\n-                                \"not a tag variant: \" +\n-                                istr::to_estr(ast_util::path_name(p)));\n+                                ~\"not a tag variant: \" +\n+                                ast_util::path_name(p));\n               }\n             }\n           }\n@@ -432,8 +432,8 @@ fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n           ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n           _ {\n             e.sess.span_err(sp,\n-                            istr::to_estr(istr::connect(path, ~\"::\")) +\n-                                \" does not name a module.\");\n+                            istr::connect(path, ~\"::\") +\n+                                ~\" does not name a module.\");\n             ret none;\n           }\n         }\n@@ -450,8 +450,8 @@ fn resolve_constr(e: @env, c: &@ast::constr, sc: &scopes, _v: &vt<scopes>) {\n           }\n           _ {\n             e.sess.span_err(c.span,\n-                            \"Non-predicate in constraint: \" +\n-                            istr::to_estr(path_to_str(c.node.path)));\n+                            ~\"Non-predicate in constraint: \" +\n+                            path_to_str(c.node.path));\n           }\n         }\n     }\n@@ -566,11 +566,11 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span,\n             && err_scope == rs.sc { ret; }\n     }\n     e.reported += [{ident: name, sc: err_scope}];\n-    e.sess.span_err(sp, istr::to_estr(mk_unresolved_msg(name, kind)));\n+    e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &istr) -> ! {\n-    e.sess.span_fatal(sp, istr::to_estr(mk_unresolved_msg(id, kind)));\n+    e.sess.span_fatal(sp, mk_unresolved_msg(id, kind));\n }\n \n fn mk_unresolved_msg(id: &ident, kind: &istr) -> istr {\n@@ -712,11 +712,11 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n                     let msg =\n                         alt ns {\n                           ns_type. {\n-                            \"Attempt to use a type \\\n+                            ~\"Attempt to use a type \\\n                                 argument out of scope\"\n                           }\n                           _ {\n-                            \"attempted dynamic \\\n+                            ~\"attempted dynamic \\\n                                        environment-capture\"\n                           }\n                         };\n@@ -732,7 +732,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n           }\n         }\n     }\n-    e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n+    e.sess.bug(~\"reached unreachable code in lookup_in_scope\"); // sigh\n \n }\n \n@@ -943,7 +943,7 @@ fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t<def> {\n         resolve_import(e, local_def(node_id), name, path, span, scopes);\n         ret lookup_import(e, defid, ns);\n       }\n-      resolving(sp) { e.sess.span_err(sp, \"cyclic import\"); ret none; }\n+      resolving(sp) { e.sess.span_err(sp, ~\"cyclic import\"); ret none; }\n       resolved(val, typ, md) {\n         ret alt ns { ns_value. { val } ns_type. { typ } ns_module. { md } };\n       }\n@@ -1009,13 +1009,14 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n         } else {\n             for match: glob_imp_def in matches {\n                 let sp = match.item.span;\n-                e.sess.span_note(sp, #fmt[\"'%s' is imported here\",\n-                                          istr::to_estr(id)]);\n+                e.sess.span_note(\n+                    sp, istr::from_estr(#fmt[\"'%s' is imported here\",\n+                                             istr::to_estr(id)]));\n             }\n             e.sess.span_fatal(sp,\n-                              \"'\" + istr::to_estr(id)\n-                              + \"' is glob-imported from\" +\n-                                  \" multiple different modules.\");\n+                              ~\"'\" + id\n+                              + ~\"' is glob-imported from\" +\n+                                  ~\" multiple different modules.\");\n         }\n     }\n     // since we don't know what names we have in advance,\n@@ -1030,7 +1031,7 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n                                         resolved(val, typ, md));\n     }\n     alt info.glob_imported_names.get(id) {\n-      todo(_, _, _, _, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n+      todo(_, _, _, _, _) { e.sess.bug(~\"Shouldn't've put a todo in.\"); }\n       resolving(sp) {\n         ret none::<def>; //circularity is okay in import globs\n \n@@ -1221,8 +1222,8 @@ fn check_mod_name(e: &env, name: &ident, entries: list<mod_index_entry>) {\n     let saw_type = false;\n     let saw_value = false;\n     fn dup(e: &env, sp: &span, word: &istr, name: &ident) {\n-        e.sess.span_fatal(sp, \"duplicate definition of \" +\n-                          istr::to_estr(word + name));\n+        e.sess.span_fatal(sp, ~\"duplicate definition of \" +\n+                          word + name);\n     }\n     while true {\n         alt entries {\n@@ -1311,15 +1312,15 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n         // the first pattern.\n         if vec::len(ch.seen) != vec::len(seen0) {\n             e.sess.span_err(a.pats[i].span,\n-                            \"inconsistent number of bindings\");\n+                            ~\"inconsistent number of bindings\");\n         } else {\n             for name: ident in ch.seen {\n                 if is_none(vec::find(bind istr::eq(name, _), seen0)) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats[i].span,\n-                                    \"binding \" + istr::to_estr(name_) +\n-                                        \" does not occur in first pattern\");\n+                                    ~\"binding \" + name_ +\n+                                        ~\" does not occur in first pattern\");\n                 }\n             }\n         }\n@@ -1411,8 +1412,8 @@ fn checker(e: &env, kind: &istr) -> checker {\n fn check_name(ch: &checker, sp: &span, name: &ident) {\n     for s: ident in ch.seen {\n         if istr::eq(s, name) {\n-            ch.sess.span_fatal(sp, \"duplicate \" + istr::to_estr(ch.kind)\n-                               + \" name: \" + istr::to_estr(name));\n+            ch.sess.span_fatal(sp, ~\"duplicate \" + ch.kind\n+                               + ~\" name: \" + name);\n         }\n     }\n }"}, {"sha": "27f26d21220e72312653a5348bde90f09b1b5f7c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -83,8 +83,8 @@ import ivec = trans_ivec;\n fn type_of(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n     if ty::type_has_dynamic_size(cx.tcx, t) {\n         cx.sess.span_fatal(sp,\n-                           \"type_of() called on a type with dynamic size: \" +\n-                           istr::to_estr(ty_to_str(cx.tcx, t)));\n+                           ~\"type_of() called on a type with dynamic size: \" +\n+                           ty_to_str(cx.tcx, t));\n     }\n     ret type_of_inner(cx, sp, t);\n }\n@@ -235,7 +235,7 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n         ret T_struct([T_i32(), type_of_inner(cx, sp, sub1)]);\n       }\n       ty::ty_var(_) {\n-        cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n+        cx.tcx.sess.span_fatal(sp, ~\"trans::type_of called on ty_var\");\n       }\n       ty::ty_param(_, _) { llty = T_typaram(cx.tn); }\n       ty::ty_type. { llty = T_ptr(cx.tydesc_type); }\n@@ -532,7 +532,7 @@ fn simplify_type(ccx: &@crate_ctxt, typ: ty::t) -> ty::t {\n fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: ty::t) -> uint {\n     if ty::type_has_dynamic_size(cx.tcx, t) {\n         cx.tcx.sess.span_fatal(sp,\n-                               \"dynamically sized type passed to \\\n+                               ~\"dynamically sized type passed to \\\n                                static_size_of_tag()\");\n     }\n     if cx.tag_sizes.contains_key(t) { ret cx.tag_sizes.get(t); }\n@@ -556,7 +556,7 @@ fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: ty::t) -> uint {\n         ret max_size;\n       }\n       _ {\n-        cx.tcx.sess.span_fatal(sp, \"non-tag passed to static_size_of_tag()\");\n+        cx.tcx.sess.span_fatal(sp, ~\"non-tag passed to static_size_of_tag()\");\n       }\n     }\n }\n@@ -1062,11 +1062,11 @@ fn get_tydesc(cx: &@block_ctxt, orig_t: ty::t, escapes: bool,\n         } else {\n             bcx_tcx(cx).sess.span_bug(\n                 cx.sp,\n-                \"Unbound typaram in get_tydesc: \" +\n-                \"orig_t = \" +\n-                istr::to_estr(ty_to_str(bcx_tcx(cx), orig_t)) +\n-                \" ty_param = \" +\n-                istr::to_estr(std::uint::str(id)));\n+                ~\"Unbound typaram in get_tydesc: \" +\n+                ~\"orig_t = \" +\n+                ty_to_str(bcx_tcx(cx), orig_t) +\n+                ~\" ty_param = \" +\n+                std::uint::str(id));\n         }\n       }\n       none. {/* fall through */ }\n@@ -1634,7 +1634,7 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n       }\n       _ {\n         // Should never get here, because t is scalar.\n-        bcx_ccx(cx).sess.bug(\"non-scalar type passed to \\\n+        bcx_ccx(cx).sess.bug(~\"non-scalar type passed to \\\n                                  compare_scalar_types\");\n       }\n     }\n@@ -1918,7 +1918,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         let unit_ty = ty::mk_mach(bcx_tcx(cx), ast::ty_u8);\n         ret iter_ivec(cx, av, unit_ty, f);\n       }\n-      _ { bcx_ccx(cx).sess.unimpl(\"type in iter_structural_ty_full\"); }\n+      _ { bcx_ccx(cx).sess.unimpl(~\"type in iter_structural_ty_full\"); }\n     }\n     ret r;\n }\n@@ -2031,8 +2031,8 @@ fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n       }\n       _ {\n         bcx_ccx(cx).sess.bug(\n-            \"unexpected type in trans::iter_sequence: \"\n-            + istr::to_estr(ty_to_str(cx.fcx.lcx.ccx.tcx, t)));\n+            ~\"unexpected type in trans::iter_sequence: \"\n+            + ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n       }\n     }\n }\n@@ -2395,7 +2395,7 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n     // FIXME this is just a clunky stopgap. we should do proper checking in an\n     // earlier pass.\n     if !ty::type_is_copyable(ccx.tcx, t) {\n-        ccx.sess.span_fatal(cx.sp, \"Copying a non-copyable type.\");\n+        ccx.sess.span_fatal(cx.sp, ~\"Copying a non-copyable type.\");\n     }\n \n     if ty::type_is_scalar(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t) {\n@@ -2421,8 +2421,8 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n             ret take_ty(bcx, dst, t).bcx;\n         }\n     }\n-    ccx.sess.bug(\"unexpected type in trans::copy_val_no_check: \" +\n-                 istr::to_estr(ty_to_str(ccx.tcx, t)));\n+    ccx.sess.bug(~\"unexpected type in trans::copy_val_no_check: \" +\n+                 ty_to_str(ccx.tcx, t));\n }\n \n \n@@ -2468,8 +2468,8 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n             ret cx;\n         }\n     }\n-    bcx_ccx(cx).sess.bug(\"unexpected type in trans::move_val: \" +\n-                         istr::to_estr(ty_to_str(tcx, t)));\n+    bcx_ccx(cx).sess.bug(~\"unexpected type in trans::move_val: \" +\n+                         ty_to_str(tcx, t));\n }\n \n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n@@ -2537,7 +2537,7 @@ fn trans_crate_lit(cx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n       ast::lit_nil. { ret C_nil(); }\n       ast::lit_str(s, ast::sk_rc.) { ret C_str(cx, s); }\n       ast::lit_str(s, ast::sk_unique.) {\n-        cx.sess.span_unimpl(lit.span, \"unique string in this context\");\n+        cx.sess.span_unimpl(lit.span, ~\"unique string in this context\");\n       }\n     }\n }\n@@ -2593,7 +2593,7 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n         ret rslt(bcx, sub.box);\n       }\n       ast::deref. {\n-        bcx_ccx(cx).sess.bug(\"deref expressions should have been \\\n+        bcx_ccx(cx).sess.bug(~\"deref expressions should have been \\\n                                  translated using trans_lval(), not \\\n                                  trans_unary()\");\n       }\n@@ -3418,7 +3418,7 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) -> lval_result {\n         let tyt = ty::lookup_item_type(ccx.tcx, did);\n         ret lval_generic_fn(cx, tyt, did, id);\n       }\n-      _ { ccx.sess.span_unimpl(cx.sp, \"def variant in trans\"); }\n+      _ { ccx.sess.span_unimpl(cx.sp, ~\"def variant in trans\"); }\n     }\n }\n \n@@ -3458,7 +3458,7 @@ fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: ty::t,\n         ret {llobj: some::<ValueRef>(r.val), method_ty: some::<ty::t>(fn_ty)\n                 with lvo};\n       }\n-      _ { bcx_ccx(cx).sess.unimpl(\"field variant in trans_field\"); }\n+      _ { bcx_ccx(cx).sess.unimpl(~\"field variant in trans_field\"); }\n     }\n }\n \n@@ -3586,7 +3586,7 @@ fn trans_lval_gen(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n           }\n           _ {\n             // Shouldn't happen.\n-            bcx_ccx(cx).sess.bug(\"trans_lval called on \\\n+            bcx_ccx(cx).sess.bug(~\"trans_lval called on \\\n                                          expr_self_method in \\\n                                          a context without llself\");\n           }\n@@ -3689,7 +3689,7 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n           {in: native_., out: native_.} {\n             bld::PointerCast(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          _ { ccx.sess.bug(\"Translating unsupported cast.\") }\n+          _ { ccx.sess.bug(~\"Translating unsupported cast.\") }\n         };\n     ret rslt(e_res.bcx, newval);\n }\n@@ -4451,7 +4451,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       ast::expr_vec(args, _) { ret ivec::trans_ivec(cx, args, e.id); }\n       ast::expr_rec(args, base) { ret trans_rec(cx, args, base, e.id); }\n       ast::expr_tup(args) { ret trans_tup(cx, args, e.id); }\n-      ast::expr_mac(_) { ret bcx_ccx(cx).sess.bug(\"unexpanded macro\"); }\n+      ast::expr_mac(_) { ret bcx_ccx(cx).sess.bug(~\"unexpanded macro\"); }\n       ast::expr_fail(expr) { ret trans_fail_expr(cx, some(e.span), expr); }\n       ast::expr_log(lvl, a) { ret trans_log(lvl, cx, a); }\n       ast::expr_assert(a) { ret trans_check_expr(cx, a, ~\"Assertion\"); }\n@@ -4628,8 +4628,8 @@ fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t<span>,\n             ret trans_fail_value(bcx, sp_opt, elt);\n         } else {\n             bcx_ccx(cx).sess.span_bug(expr.span,\n-                                      \"fail called with unsupported type \"\n-                                      + istr::to_estr(ty_to_str(tcx, e_ty)));\n+                                      ~\"fail called with unsupported type \"\n+                                      + ty_to_str(tcx, e_ty));\n         }\n       }\n       _ { ret trans_fail(bcx, sp_opt, ~\"explicit failure\"); }\n@@ -4745,17 +4745,17 @@ fn trans_break_cont(sp: &span, cx: &@block_ctxt, to_end: bool) -> result {\n               parent_none. {\n                 bcx_ccx(cx).sess.span_fatal(sp,\n                                             if to_end {\n-                                                \"Break\"\n-                                            } else { \"Cont\" } +\n-                                                \" outside a loop\");\n+                                                ~\"Break\"\n+                                            } else { ~\"Cont\" } +\n+                                                ~\" outside a loop\");\n               }\n             }\n           }\n         }\n     }\n     // If we get here without returning, it's a bug\n \n-    bcx_ccx(cx).sess.bug(\"in trans::trans_break_cont()\");\n+    bcx_ccx(cx).sess.bug(~\"in trans::trans_break_cont()\");\n }\n \n fn trans_break(sp: &span, cx: &@block_ctxt) -> result {\n@@ -4921,7 +4921,7 @@ fn trans_stmt(cx: &@block_ctxt, s: &ast::stmt) -> result {\n           ast::decl_item(i) { trans_item(cx.fcx.lcx, *i); }\n         }\n       }\n-      _ { bcx_ccx(cx).sess.unimpl(\"stmt variant\"); }\n+      _ { bcx_ccx(cx).sess.unimpl(~\"stmt variant\"); }\n     }\n     ret rslt(bcx, C_nil());\n }\n@@ -5521,7 +5521,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n     let llctor_decl;\n     alt cx.ccx.item_ids.find(ctor_id) {\n       some(x) { llctor_decl = x; }\n-      _ { cx.ccx.sess.span_fatal(sp, \"unbound ctor_id in trans_res_ctor\"); }\n+      _ { cx.ccx.sess.span_fatal(sp, ~\"unbound ctor_id in trans_res_ctor\"); }\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n@@ -5534,7 +5534,8 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n     let arg;\n     alt fcx.llargs.find(dtor.decl.inputs[0].id) {\n       some(x) { arg = load_if_immediate(bcx, x, arg_t); }\n-      _ { cx.ccx.sess.span_fatal(sp, \"unbound dtor decl in trans_res_ctor\"); }\n+      _ { cx.ccx.sess.span_fatal(\n+          sp, ~\"unbound dtor decl in trans_res_ctor\"); }\n     }\n     let llretptr = fcx.llretptr;\n     if ty::type_has_dynamic_size(cx.ccx.tcx, ret_t) {\n@@ -5577,7 +5578,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n       some(x) { llfndecl = x; }\n       _ {\n         cx.ccx.sess.span_fatal(variant.span,\n-                               \"unbound variant id in trans_tag_variant\");\n+                               ~\"unbound variant id in trans_tag_variant\");\n       }\n     }\n     let fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n@@ -5623,7 +5624,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         alt fcx.llargs.find(va.id) {\n           some(x) { llargptr = bld::PointerCast(bcx, x, val_ty(lldestptr)); }\n           none. {\n-            bcx_ccx(bcx).sess.bug(\"unbound argptr in \\\n+            bcx_ccx(bcx).sess.bug(~\"unbound argptr in \\\n                                       trans_tag_variant\");\n           }\n         }\n@@ -5648,7 +5649,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n fn trans_const_expr(cx: &@crate_ctxt, e: @ast::expr) -> ValueRef {\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_crate_lit(cx, *lit); }\n-      _ { cx.sess.span_unimpl(e.span, \"consts that's not a plain literal\"); }\n+      _ { cx.sess.span_unimpl(e.span, ~\"consts that's not a plain literal\"); }\n     }\n }\n \n@@ -5663,7 +5664,7 @@ fn trans_const(cx: &@crate_ctxt, e: @ast::expr, id: ast::node_id) {\n         llvm::LLVMSetInitializer(g, v);\n         llvm::LLVMSetGlobalConstant(g, True);\n       }\n-      _ { cx.sess.span_fatal(e.span, \"Unbound const in trans_const\"); }\n+      _ { cx.sess.span_fatal(e.span, ~\"Unbound const in trans_const\"); }\n     }\n }\n \n@@ -5677,7 +5678,7 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n           }\n           _ {\n             cx.ccx.sess.span_fatal(item.span,\n-                                   \"unbound function item in trans_item\");\n+                                   ~\"unbound function item in trans_item\");\n           }\n         }\n       }\n@@ -5696,7 +5697,7 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n             trans_fn(cx, item.span, dtor, lldtor_decl, none, tps, dtor_id);\n           }\n           _ {\n-            cx.ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");\n+            cx.ccx.sess.span_fatal(item.span, ~\"unbound dtor in trans_item\");\n           }\n         }\n       }\n@@ -5755,7 +5756,8 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n             type_of_fn(ccx, sp, proto, inputs, output,\n                        std::vec::len::<ast::ty_param>(ty_params));\n       }\n-      _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n+      _ { ccx.sess.bug(\n+          ~\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n     }\n     let s: istr = mangle_internal_name_by_path(ccx, path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod,\n@@ -5775,7 +5777,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n                        main_node_type: ty::t) {\n \n     if ccx.main_fn != none::<ValueRef> {\n-        ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n+        ccx.sess.span_fatal(sp, ~\"multiple 'main' functions\");\n     }\n \n     let main_takes_ivec =\n@@ -5876,7 +5878,7 @@ fn native_fn_ty_param_count(cx: &@crate_ctxt, id: ast::node_id) -> uint {\n         alt cx.ast_map.find(id) { some(ast_map::node_native_item(i)) { i } };\n     alt native_item.node {\n       ast::native_item_ty. {\n-        cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \\\n+        cx.sess.bug(~\"decl_native_fn_and_pair(): native fn isn't \\\n                         actually a fn\");\n       }\n       ast::native_item_fn(_, _, tps) {\n@@ -6274,7 +6276,7 @@ fn trap(bcx: &@block_ctxt) {\n     let v: [ValueRef] = [];\n     alt bcx_ccx(bcx).intrinsics.find(~\"llvm.trap\") {\n       some(x) { bld::Call(bcx, x, v); }\n-      _ { bcx_ccx(bcx).sess.bug(\"unbound llvm.trap in trap\"); }\n+      _ { bcx_ccx(bcx).sess.bug(~\"unbound llvm.trap in trap\"); }\n     }\n }\n "}, {"sha": "0006db2f00025d902dbee80602ab5870bb938d53", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -344,7 +344,7 @@ fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n     if did.crate == ast::local_crate {\n         alt ccx.fn_pairs.find(did.node) {\n           some(x) { ret x; }\n-          _ { ccx.tcx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n+          _ { ccx.tcx.sess.bug(~\"get_res_dtor: can't find resource dtor!\"); }\n         }\n     }\n \n@@ -463,8 +463,8 @@ fn find_scope_cx(cx: &@block_ctxt) -> @block_ctxt {\n     alt cx.parent {\n       parent_some(b) { ret find_scope_cx(b); }\n       parent_none. {\n-        cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n-                                    \"called on parentless block_ctxt\");\n+        cx.fcx.lcx.ccx.sess.bug(~\"trans::find_scope_cx() \" +\n+                                ~\"called on parentless block_ctxt\");\n       }\n     }\n }"}, {"sha": "054c453ff9ef0e8e25760c8f12725f3273b20efc", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -22,7 +22,7 @@ fn alloc_with_heap(bcx: @block_ctxt, typ: &ty::t, vecsz: uint) ->\n     let unit_ty;\n     alt ty::struct(bcx_tcx(bcx), typ) {\n       ty::ty_vec(mt) { unit_ty = mt.ty; }\n-      _ { bcx_ccx(bcx).sess.bug(\"non-ivec type in trans_ivec\"); }\n+      _ { bcx_ccx(bcx).sess.bug(~\"non-ivec type in trans_ivec\"); }\n     }\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n \n@@ -376,7 +376,7 @@ fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n     let have_istrs = alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_istr. { true }\n       ty::ty_vec(_) { false }\n-      _ { bcx_tcx(cx).sess.bug(\"non-istr/ivec in trans_append\"); }\n+      _ { bcx_tcx(cx).sess.bug(~\"non-istr/ivec in trans_append\"); }\n     };\n \n     let extra_len = if have_istrs {\n@@ -532,7 +532,7 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n         bld::Sub(bcx, lhs_len, C_uint(1u))\n       }\n       ty::ty_vec(_) { lhs_len }\n-      _ { bcx_tcx(bcx).sess.bug(\"non-istr/ivec in trans_add\") }\n+      _ { bcx_tcx(bcx).sess.bug(~\"non-istr/ivec in trans_add\") }\n     };\n \n     let rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);"}, {"sha": "44b025c2e844d61cae9162c35af0620cd61494f1", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -38,7 +38,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     let llctor_decl;\n     alt ccx.item_ids.find(ctor_id) {\n       some(x) { llctor_decl = x; }\n-      _ { cx.ccx.sess.span_fatal(sp, \"unbound llctor_decl in trans_obj\"); }\n+      _ { cx.ccx.sess.span_fatal(sp, ~\"unbound llctor_decl in trans_obj\"); }\n     }\n \n     // Much like trans_fn, we must create an LLVM function, but since we're\n@@ -187,7 +187,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n               }\n               none. {\n                 bcx_ccx(bcx).sess.span_fatal(f.ty.span,\n-                                             \"internal error in trans_obj\");\n+                                             ~\"internal error in trans_obj\");\n               }\n             }\n         }\n@@ -436,7 +436,7 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd, addtl_meths: [@ast::method])\n         ret some(fwding_mthd(fm));\n       }\n       normal_mthd(_) {\n-        cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n+        cx.ccx.sess.bug(~\"create_vtbl(): shouldn't be any \\\n                         normal_mthds in meths here\");\n       }\n     }\n@@ -486,7 +486,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n             }\n           }\n           _ {\n-            cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \\\n+            cx.ccx.sess.bug(~\"create_vtbl(): trying to extend a \\\n                             non-object\");\n           }\n         }\n@@ -550,7 +550,7 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n       }\n       _ {\n         // Shouldn't happen.\n-        cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n+        cx.ccx.sess.bug(~\"create_backwarding_vtbl(): trying to extend a \\\n                             non-object\");\n       }\n     }\n@@ -657,7 +657,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n       }\n       _ {\n         // Shouldn't happen.\n-        cx.ccx.sess.bug(\"process_bkwding_mthd(): non-object type passed \\\n+        cx.ccx.sess.bug(~\"process_bkwding_mthd(): non-object type passed \\\n                         as outer_obj_ty\");\n       }\n     }\n@@ -823,7 +823,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n       }\n       _ {\n         // Shouldn't happen.\n-        cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \\\n+        cx.ccx.sess.bug(~\"process_fwding_mthd(): non-object type passed \\\n                         as target_obj_ty\");\n       }\n     }"}, {"sha": "f4cc34bc7a993f0e71f02295ab36335af10ad7e1", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -78,12 +78,12 @@ fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> istr {\n     alt c.node {\n       ninit(_, i) {\n         ret ~\"init(\" + i + ~\" [\" +\n-            istr::from_estr(tcx.sess.span_str(c.span)) + ~\"])\";\n+            tcx.sess.span_str(c.span) + ~\"])\";\n       }\n       npred(p, _, args) {\n         ret path_to_str(p) + ~\"(\" +\n             comma_str(args) + ~\")\" + ~\"[\" +\n-                istr::from_estr(tcx.sess.span_str(c.span)) + ~\"]\";\n+                tcx.sess.span_str(c.span) + ~\"]\";\n       }\n     }\n }\n@@ -602,17 +602,17 @@ fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n         fn eq(p: &inst, q: &inst) -> bool { ret p.node == q.node; }\n         if ty::args_eq(eq, pd.node.args, occ) { ret pd.node.bit_num; }\n     }\n-    fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n+    fcx.ccx.tcx.sess.bug(~\"match_args: no match for occurring args\");\n }\n \n fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n     alt tcx.def_map.find(t) {\n       none. {\n-        tcx.sess.bug(\"node_id_for_constr: bad node_id \"\n-                     + istr::to_estr(int::str(t)));\n+        tcx.sess.bug(~\"node_id_for_constr: bad node_id \"\n+                     + int::str(t));\n       }\n       some(def_fn(i, _)) { ret i; }\n-      _ { tcx.sess.bug(\"node_id_for_constr: pred is not a function\"); }\n+      _ { tcx.sess.bug(~\"node_id_for_constr: pred is not a function\"); }\n     }\n }\n \n@@ -636,21 +636,21 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n                                     node: b_id.node}));\n            }\n           some(_) {\n-            tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n-                             \"as pred arg\");\n+            tcx.sess.bug(~\"exprs_to_constr_args: non-local variable \" +\n+                             ~\"as pred arg\");\n           }\n           none {\n-            tcx.sess.bug(\"exprs_to_constr_args: NONE \" +\n-                             \"as pred arg\");\n+            tcx.sess.bug(~\"exprs_to_constr_args: NONE \" +\n+                             ~\"as pred arg\");\n \n           }\n         }\n       }\n       expr_lit(l) { ret @respan(e.span, carg_lit(l)); }\n       _ {\n         tcx.sess.span_fatal(e.span,\n-                            \"Arguments to constrained functions must be \" +\n-                                \"literals or local variables\");\n+                            ~\"Arguments to constrained functions must be \" +\n+                                ~\"literals or local variables\");\n       }\n     }\n }\n@@ -673,15 +673,15 @@ fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n           }\n           _ {\n             tcx.sess.span_fatal(operator.span,\n-                                \"Internal error: \" +\n-                                    \" ill-formed operator \\\n+                                ~\"Internal error: \" +\n+                                    ~\" ill-formed operator \\\n                                             in predicate\");\n           }\n         }\n       }\n       _ {\n         tcx.sess.span_fatal(e.span,\n-                            \"Internal error: \" + \" ill-formed predicate\");\n+                            ~\"Internal error: \" + ~\" ill-formed predicate\");\n       }\n     }\n }\n@@ -711,7 +711,7 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n         if i < num_actuals {\n             ret expr_to_constr_arg(cx, actuals[i]);\n         } else {\n-            cx.sess.span_fatal(a.span, \"Constraint argument out of bounds\");\n+            cx.sess.span_fatal(a.span, ~\"Constraint argument out of bounds\");\n         }\n       }\n       carg_base. { ret @respan(a.span, carg_base); }\n@@ -838,7 +838,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n \n fn path_to_ident(cx: &ty::ctxt, p: &path) -> ident {\n     alt vec::last(p.node.idents) {\n-      none. { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n+      none. { cx.sess.span_fatal(p.span, ~\"Malformed path\"); }\n       some(i) { ret i; }\n     }\n }\n@@ -852,13 +852,13 @@ fn local_node_id_to_def_id_strict(fcx: &fn_ctxt, sp: &span, i: &node_id) ->\n       some(def_arg(a_id)) { ret a_id; }\n       some(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"local_node_id_to_def_id: id \\\n+                                    ~\"local_node_id_to_def_id: id \\\n                isn't a local\");\n       }\n       none. {\n         // should really be bug. span_bug()?\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"local_node_id_to_def_id: id \\\n+                                    ~\"local_node_id_to_def_id: id \\\n                is unbound\");\n       }\n     }\n@@ -1120,8 +1120,8 @@ fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n       _ {\n         // Shouldn't happen; callee should be ty_fn.\n         fcx.ccx.tcx.sess.bug(\n-            \"non-fn callee type in callee_modes: \" +\n-            istr::to_estr(util::ppaux::ty_to_str(fcx.ccx.tcx, ty)));\n+            ~\"non-fn callee type in callee_modes: \" +\n+            util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n       }\n     }\n }"}, {"sha": "208f984660a6f5dec5fda7cf737036e7a9434822", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -36,17 +36,17 @@ fn bit_num(fcx: &fn_ctxt, c: &tsconstr) -> uint {\n         alt rslt {\n           cinit(n, _, _) { ret n; }\n           _ {\n-            fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\" +\n-                                     \" found a pred constraint\");\n+            fcx.ccx.tcx.sess.bug(~\"bit_num: asked for init constraint,\" +\n+                                     ~\" found a pred constraint\");\n           }\n         }\n       }\n       npred(_, _, args) {\n         alt rslt {\n           cpred(_, descs) { ret match_args(fcx, descs, args); }\n           _ {\n-            fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\" +\n-                                     \" found an init constraint\");\n+            fcx.ccx.tcx.sess.bug(~\"bit_num: asked for pred constraint,\" +\n+                                     ~\" found an init constraint\");\n           }\n         }\n       }\n@@ -205,12 +205,12 @@ fn clear_in_poststate_expr(fcx: &fn_ctxt, e: &@expr, t: &poststate) {\n               }\n               some(_) {/* ignore args (for now...) */ }\n               _ {\n-                fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: \\\n+                fcx.ccx.tcx.sess.bug(~\"clear_in_poststate_expr: \\\n                                    unbound var\");\n               }\n             }\n           }\n-          _ { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr\"); }\n+          _ { fcx.ccx.tcx.sess.bug(~\"clear_in_poststate_expr\"); }\n         }\n       }\n       _ {/* do nothing */ }"}, {"sha": "5f899b81f8805bfb0a9b9e3c1a0308a5d56f655f", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -56,8 +56,8 @@ fn check_unused_vars(fcx: &fn_ctxt) {\n             if !vec_contains(fcx.enclosing.used_vars, id) && v[0] != '_' as u8\n                {\n                 fcx.ccx.tcx.sess.span_warn(c.c.span,\n-                                           \"unused variable \"\n-                                           + istr::to_estr(v));\n+                                           ~\"unused variable \"\n+                                           + v);\n             }\n           }\n           _ {/* ignore pred constraints */ }\n@@ -92,7 +92,7 @@ fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n         s += tritv_to_str(fcx, prec);\n         s += ~\"\\nPrestate:\\n\";\n         s += tritv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(e.span, istr::to_estr(s));\n+        fcx.ccx.tcx.sess.span_fatal(e.span, s);\n     }\n }\n \n@@ -124,7 +124,7 @@ fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n         ss += tritv_to_str(fcx, prec);\n         ss += ~\"\\nPrestate: \\n\";\n         ss += tritv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(s.span, istr::to_estr(ss));\n+        fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n     }\n }\n \n@@ -150,14 +150,14 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n            !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n            f.decl.cf == return {\n         fcx.ccx.tcx.sess.span_err(f.body.span,\n-                                  \"In function \" +\n-                                  istr::to_estr(fcx.name) +\n-                                      \", not all control paths \\\n+                                  ~\"In function \" +\n+                                  fcx.name +\n+                                      ~\", not all control paths \\\n                                         return a value\");\n         fcx.ccx.tcx.sess.span_fatal(\n             f.decl.output.span,\n-            \"see declared return type of '\" +\n-            istr::to_estr(ty_to_str(f.decl.output)) + \"'\");\n+            ~\"see declared return type of '\" +\n+            ty_to_str(f.decl.output) + ~\"'\");\n     } else if f.decl.cf == noreturn {\n \n         // check that this really always fails\n@@ -166,9 +166,9 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n \n         if !promises(fcx, post, fcx.enclosing.i_diverge) {\n             fcx.ccx.tcx.sess.span_fatal(f.body.span,\n-                                        \"In non-returning function \" +\n-                                            istr::to_estr(fcx.name) +\n-                                            \", some control paths may \\\n+                                        ~\"In non-returning function \" +\n+                                            fcx.name +\n+                                            ~\", some control paths may \\\n                                            return to the caller\");\n         }\n     }"}, {"sha": "c2ff053c1a295af4a0573a9280197bf19e757ff5", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -70,8 +70,8 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n           some(ct) {\n             alt ct {\n               cinit(_, _, _) {\n-                tcx.sess.bug(\"add_constraint: same def_id used\" +\n-                                 \" as a variable and a pred\");\n+                tcx.sess.bug(~\"add_constraint: same def_id used\" +\n+                                 ~\" as a variable and a pred\");\n               }\n               cpred(_, pds) {\n                 *pds += [respan(c.span, {args: args, bit_num: next})];"}, {"sha": "f5014cbb313f4181592ce1cd4a692179cfa0572e", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -554,7 +554,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       }\n       expr_break. { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_cont. { clear_pp(expr_pp(fcx.ccx, e)); }\n-      expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n       expr_anon_obj(anon_obj) {\n         alt anon_obj.inner_obj {\n           some(ex) {\n@@ -605,7 +605,7 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n                               pat_bind(n) { n }\n                               _ {\n                                 fcx.ccx.tcx.sess.span_bug(pat.span,\n-                                                          \"Impossible LHS\");\n+                                                          ~\"Impossible LHS\");\n                               }\n                             };\n                         alt p {\n@@ -642,7 +642,7 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n                           }\n                           _ {\n                             fcx.ccx.tcx.sess.span_bug(pat.span,\n-                                                      \"Impossible LHS\");\n+                                                      ~\"Impossible LHS\");\n                           }\n                         }\n                     }"}, {"sha": "55cc9dc8ff6655d92860b4814cdf66a1b7b98232", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -1,6 +1,7 @@\n import syntax::print::pprust::path_to_str;\n import util::ppaux::ty_to_str;\n import std::vec;\n+import std::istr;\n import std::option;\n import std::option::get;\n import std::option::is_none;\n@@ -169,10 +170,10 @@ fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n     let changed = find_pre_post_state_expr(fcx, pres, a);\n     // FIXME: This could be a typestate constraint\n     if vec::len(bs) != vec::len(ops) {\n-        fcx.ccx.tcx.sess.span_bug(a.span,\n+        fcx.ccx.tcx.sess.span_bug(a.span, istr::from_estr(\n                                   #fmt[\"mismatched arg lengths: \\\n                                         %u exprs vs. %u ops\",\n-                                       vec::len(bs), vec::len(ops)]);\n+                                       vec::len(bs), vec::len(ops)]));\n     }\n     ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id, ops,\n                                   bs, cf) || changed;\n@@ -344,7 +345,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       expr_log(_, ex) {\n         ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n       }\n-      expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n       expr_put(maybe_e) {\n         alt maybe_e {\n           some(arg) {"}, {"sha": "67f5b62a12ea3e9f1dcaabd2bbd90bd28dc0c709", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -868,7 +868,7 @@ fn sequence_is_interior(cx: &ctxt, ty: t) -> bool {\n       }\n       ty::ty_vec(_) { ret true; }\n       ty::ty_istr. { ret true; }\n-      _ { cx.sess.bug(\"sequence_is_interior called on non-sequence type\"); }\n+      _ { cx.sess.bug(~\"sequence_is_interior called on non-sequence type\"); }\n     }\n }\n \n@@ -877,7 +877,8 @@ fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n       ty_str. { ret mk_mach(cx, ast::ty_u8); }\n       ty_istr. { ret mk_mach(cx, ast::ty_u8); }\n       ty_vec(mt) { ret mt.ty; }\n-      _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n+      _ { cx.sess.bug(\n+          ~\"sequence_element_type called on non-sequence value\"); }\n     }\n }\n \n@@ -896,9 +897,9 @@ fn get_element_type(cx: &ctxt, ty: t, i: uint) -> t {\n       ty_rec(flds) { ret flds[i].mt.ty; }\n       ty_tup(ts) { ret ts[i]; }\n       _ {\n-        cx.sess.bug(\"get_element_type called on type \" +\n-                    istr::to_estr(ty_to_str(cx, ty)) +\n-                        \" - expected a \\\n+        cx.sess.bug(~\"get_element_type called on type \" +\n+                    ty_to_str(cx, ty) +\n+                        ~\" - expected a \\\n             tuple or record\");\n       }\n     }\n@@ -1121,7 +1122,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n       _ {\n-        cx.sess.bug(\"missed case: \" + istr::to_estr(ty_to_str(cx, ty)));\n+        cx.sess.bug(~\"missed case: \" + ty_to_str(cx, ty));\n       }\n     }\n \n@@ -1629,10 +1630,10 @@ fn node_id_to_ty_param_substs_opt_and_ty(cx: &ctxt, id: &ast::node_id) ->\n     // Pull out the node type table.\n     alt smallintmap::find(*cx.node_types, id as uint) {\n       none. {\n-        cx.sess.bug(\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n-                    \"an untyped node (\" +\n-                    istr::to_estr(std::int::to_str(id, 10u)) +\n-                    \")\");\n+        cx.sess.bug(~\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n+                    ~\"an untyped node (\" +\n+                    std::int::to_str(id, 10u) +\n+                    ~\")\");\n       }\n       some(tpot) { ret tpot; }\n     }\n@@ -1707,29 +1708,29 @@ fn ty_fn_args(cx: &ctxt, fty: t) -> [arg] {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, a, _, _, _) { ret a; }\n       ty::ty_native_fn(_, a, _) { ret a; }\n-      _ { cx.sess.bug(\"ty_fn_args() called on non-fn type\"); }\n+      _ { cx.sess.bug(~\"ty_fn_args() called on non-fn type\"); }\n     }\n }\n \n fn ty_fn_proto(cx: &ctxt, fty: t) -> ast::proto {\n     alt struct(cx, fty) {\n       ty::ty_fn(p, _, _, _, _) { ret p; }\n-      _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n+      _ { cx.sess.bug(~\"ty_fn_proto() called on non-fn type\"); }\n     }\n }\n \n fn ty_fn_abi(cx: &ctxt, fty: t) -> ast::native_abi {\n     alt struct(cx, fty) {\n       ty::ty_native_fn(a, _, _) { ret a; }\n-      _ { cx.sess.bug(\"ty_fn_abi() called on non-native-fn type\"); }\n+      _ { cx.sess.bug(~\"ty_fn_abi() called on non-native-fn type\"); }\n     }\n }\n \n fn ty_fn_ret(cx: &ctxt, fty: t) -> t {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, r, _, _) { ret r; }\n       ty::ty_native_fn(_, _, r) { ret r; }\n-      _ { cx.sess.bug(\"ty_fn_ret() called on non-fn type\"); }\n+      _ { cx.sess.bug(~\"ty_fn_ret() called on non-fn type\"); }\n     }\n }\n \n@@ -1803,15 +1804,15 @@ fn field_idx(sess: &session::session, sp: &span, id: &ast::ident,\n              fields: &[field]) -> uint {\n     let i: uint = 0u;\n     for f: field in fields { if istr::eq(f.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown field '\" +\n-                    istr::to_estr(id) + \"' of record\");\n+    sess.span_fatal(sp, ~\"unknown field '\" +\n+                    id + ~\"' of record\");\n }\n \n fn method_idx(sess: &session::session, sp: &span, id: &ast::ident,\n               meths: &[method]) -> uint {\n     let i: uint = 0u;\n     for m: method in meths { if istr::eq(m.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown method '\" + istr::to_estr(id) + \"' of obj\");\n+    sess.span_fatal(sp, ~\"unknown method '\" + id + ~\"' of obj\");\n }\n \n fn sort_methods(meths: &[method]) -> [method] {\n@@ -1847,12 +1848,12 @@ fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: t) ->\n             // variables, so in this case we have to be sure to die.\n             tcx.sess.span_fatal(\n                 s,\n-                \"Type inference failed because I \\\n+                ~\"Type inference failed because I \\\n                  could not find a type\\n that's both of the form \"\n-                + istr::to_estr(ty_to_str(tcx, ty::mk_var(tcx, vid))) +\n-                \" and of the form \" +\n-                istr::to_estr(ty_to_str(tcx, rt)) +\n-                \". Such a type would have to be infinitely \\\n+                + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n+                ~\" and of the form \" +\n+                ty_to_str(tcx, rt) +\n+                ~\". Such a type would have to be infinitely \\\n                  large.\");\n           }\n           _ { ret true; }\n@@ -2667,7 +2668,8 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int, typ: t,\n         if index < vec::len(*param_var_ids) {\n             ret mk_var(cx, param_var_ids[index]);\n         } else {\n-            cx.sess.span_fatal(sp, \"Unbound type parameter in callee's type\");\n+            cx.sess.span_fatal(\n+                sp, ~\"Unbound type parameter in callee's type\");\n         }\n     }\n     let new_typ =\n@@ -2717,7 +2719,7 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n     let item =\n         alt cx.items.find(id.node) {\n           some(i) { i }\n-          none. { cx.sess.bug(\"expected to find cached node_item\") }\n+          none. { cx.sess.bug(~\"expected to find cached node_item\") }\n         };\n     alt item {\n       ast_map::node_item(item) {\n@@ -2756,7 +2758,7 @@ fn tag_variant_with_id(cx: &ctxt, tag_id: &ast::def_id,\n         if def_eq(variant.id, variant_id) { ret variant; }\n         i += 1u;\n     }\n-    cx.sess.bug(\"tag_variant_with_id(): no variant exists with that ID\");\n+    cx.sess.bug(~\"tag_variant_with_id(): no variant exists with that ID\");\n }\n \n \n@@ -2784,8 +2786,8 @@ fn ret_ty_of_fn_ty(cx: ctxt, a_ty: t) -> t {\n       ty::ty_fn(_, _, ret_ty, _, _) { ret ret_ty; }\n       ty::ty_native_fn(_, _, ret_ty) { ret ret_ty; }\n       _ {\n-        cx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type: \" +\n-                    istr::to_estr(ty_to_str(cx, a_ty)));\n+        cx.sess.bug(~\"ret_ty_of_fn_ty() called on non-function type: \" +\n+                    ty_to_str(cx, a_ty));\n       }\n     }\n }\n@@ -2900,9 +2902,9 @@ fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n       }\n       _ {\n         tcx.sess.span_fatal(c.span,\n-                            \"Predicate \" +\n-                            istr::to_estr(path_to_str(c.node.path)) +\n-                            \" is unbound or bound to a non-function or an \\\n+                            ~\"Predicate \" +\n+                            path_to_str(c.node.path) +\n+                            ~\" is unbound or bound to a non-function or an \\\n                              impure function\");\n       }\n     }"}, {"sha": "446d56182f02bb3a4c797e380bc8bf56f343891d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 109, "deletions": 107, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -89,7 +89,7 @@ fn lookup_local(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> int {\n       some(x) { x }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"internal error looking up a local var\")\n+                                    ~\"internal error looking up a local var\")\n       }\n     }\n }\n@@ -99,7 +99,7 @@ fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n       some(x) { x }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"internal error looking up a definition\")\n+                                    ~\"internal error looking up a definition\")\n       }\n     }\n }\n@@ -147,11 +147,11 @@ fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n         ret {kinds: no_kinds, ty: ty::mk_nil(fcx.ccx.tcx)};\n       }\n       ast::def_ty(_) {\n-        fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n+        fcx.ccx.tcx.sess.span_fatal(sp, ~\"expected value but found type\");\n       }\n       _ {\n         // FIXME: handle other names.\n-        fcx.ccx.tcx.sess.unimpl(\"definition variant\");\n+        fcx.ccx.tcx.sess.unimpl(~\"definition variant\");\n       }\n     }\n }\n@@ -174,15 +174,15 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n         if param_var_len == 0u {\n             fcx.ccx.tcx.sess.span_fatal(\n                 sp,\n-                \"this item does not take type parameters\");\n+                ~\"this item does not take type parameters\");\n         } else if ty_substs_len > param_var_len {\n             fcx.ccx.tcx.sess.span_fatal(\n                 sp,\n-                \"too many type parameter provided for this item\");\n+                ~\"too many type parameter provided for this item\");\n         } else if ty_substs_len < param_var_len {\n             fcx.ccx.tcx.sess.span_fatal(\n                 sp,\n-                \"not enough type parameters provided for this item\");\n+                ~\"not enough type parameters provided for this item\");\n         }\n         let ty_substs: [ty::t] = [];\n         let i = 0u;\n@@ -196,7 +196,7 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n         ty_substs_opt = some::<[ty::t]>(ty_substs);\n         if ty_param_count == 0u {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n-                                        \"this item does not take type \\\n+                                        ~\"this item does not take type \\\n                                       parameters\");\n         }\n     } else {\n@@ -228,7 +228,7 @@ fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, tp: ty::t) -> ty::t {\n       fix_err(_) {\n         fcx.ccx.tcx.sess.span_fatal(\n             sp,\n-            \"the type of this value must be known in this context\");\n+            ~\"the type of this value must be known in this context\");\n       }\n     }\n }\n@@ -271,7 +271,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       some(some(ty)) { ret ty; }\n       some(none.) {\n         tcx.sess.span_fatal(ast_ty.span,\n-                            \"illegal recursive type \\\n+                            ~\"illegal recursive type \\\n                               insert a tag in the cycle, \\\n                               if this is desired)\");\n       }\n@@ -306,7 +306,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         }\n         if vec::len(param_bindings) != vec::len(ty_param_kinds_and_ty.kinds) {\n             tcx.sess.span_fatal(sp,\n-                                \"Wrong number of type arguments for a \\\n+                                ~\"Wrong number of type arguments for a \\\n                                  polymorphic type\");\n         }\n         let typ =\n@@ -370,10 +370,11 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n           some(ast::def_ty_arg(id, k)) { typ = ty::mk_param(tcx, id, k); }\n           some(_) {\n             tcx.sess.span_fatal(ast_ty.span,\n-                                \"found type name used as a variable\");\n+                                ~\"found type name used as a variable\");\n           }\n           _ {\n-            tcx.sess.span_fatal(ast_ty.span, \"internal error in instantiate\");\n+            tcx.sess.span_fatal(\n+                ast_ty.span, ~\"internal error in instantiate\");\n           }\n         }\n         cname = some(path_to_str(path));\n@@ -410,7 +411,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, getter, t), out_cs);\n       }\n       ast::ty_infer. {\n-        tcx.sess.span_bug(ast_ty.span, \"found ty_infer in unexpected place\");\n+        tcx.sess.span_bug(ast_ty.span, ~\"found ty_infer in unexpected place\");\n       }\n     }\n     alt cname {\n@@ -591,7 +592,7 @@ mod collect {\n           }\n           _ {\n             cx.tcx.sess.fatal(\n-                \"internal error \" + istr::to_estr(std::int::str(id.node)));\n+                ~\"internal error \" + std::int::str(id.node));\n           }\n         }\n         ret tpt;\n@@ -1014,12 +1015,12 @@ mod demand {\n             let a_err = resolve_type_vars_if_possible(fcx, actual);\n             fcx.ccx.tcx.sess.span_err(\n                 sp,\n-                \"mismatched types: expected \" +\n-                istr::to_estr(ty_to_str(fcx.ccx.tcx, e_err)) +\n-                \" but found \" +\n-                istr::to_estr(ty_to_str(fcx.ccx.tcx, a_err)) + \" (\"\n-                + istr::to_estr(ty::type_err_to_str(err))\n-                + \")\");\n+                ~\"mismatched types: expected \" +\n+                ty_to_str(fcx.ccx.tcx, e_err) +\n+                ~\" but found \" +\n+                ty_to_str(fcx.ccx.tcx, a_err) + ~\" (\"\n+                + ty::type_err_to_str(err)\n+                + ~\")\");\n             ret mk_result(fcx, expected, ty_param_subst_var_ids);\n           }\n         }\n@@ -1082,7 +1083,7 @@ mod writeback {\n           fix_ok(new_type) { ret some(new_type); }\n           fix_err(vid) {\n             fcx.ccx.tcx.sess.span_err(sp,\n-                                      \"cannot determine a type \\\n+                                      ~\"cannot determine a type \\\n                                            for this expression\");\n             ret none;\n           }\n@@ -1150,7 +1151,7 @@ mod writeback {\n           fix_ok(lty) { write::ty_only(wbcx.fcx.ccx.tcx, l.node.id, lty); }\n           fix_err(_) {\n             wbcx.fcx.ccx.tcx.sess.span_err(l.span,\n-                                           \"cannot determine a type \\\n+                                           ~\"cannot determine a type \\\n                                                 for this local variable\");\n             wbcx.success = false;\n           }\n@@ -1375,7 +1376,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                              subpats_len,\n                              if subpats_len == 1u { \"\" } else { \"s\" },\n                              arg_len, if arg_len == 1u { \"\" } else { \"s\" }];\n-                    fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n+                    fcx.ccx.tcx.sess.span_fatal(\n+                        pat.span, istr::from_estr(s));\n                 }\n \n                 // TODO: vec::iter2\n@@ -1388,24 +1390,24 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             } else if subpats_len > 0u {\n                 // TODO: note definition of tag variant\n                 fcx.ccx.tcx.sess.span_fatal(\n-                    pat.span,\n+                    pat.span, istr::from_estr(\n                     #fmt[\"this pattern has %u field%s, \\\n                           but the corresponding \\\n                           variant has no fields\",\n                          subpats_len,\n                          if subpats_len == 1u {\n                              \"\"\n-                         } else { \"s\" }]);\n+                         } else { \"s\" }]));\n             }\n             write::ty_fixup(fcx, pat.id, path_tpot);\n           }\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n+                pat.span, istr::from_estr(\n                 #fmt[\"mismatched types: expected %s, found tag\",\n-                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]);\n+                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]));\n           }\n         }\n         write::ty_fixup(fcx, pat.id, path_tpot);\n@@ -1416,20 +1418,20 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n+                pat.span, istr::from_estr(\n                 #fmt[\"mismatched types: expected %s, found record\",\n-                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]);\n+                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]));\n           }\n         }\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n+                pat.span, istr::from_estr(\n                 #fmt[\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                     ex_f_count, f_count]);\n+                     ex_f_count, f_count]));\n         }\n         fn matches(name: &istr, f: &ty::field) -> bool {\n             ret istr::eq(name, f.ident);\n@@ -1438,10 +1440,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             alt vec::find(bind matches(f.ident, _), ex_fields) {\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none. {\n-                fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                fcx.ccx.tcx.sess.span_fatal(pat.span, istr::from_estr(\n                                             #fmt[\"mismatched types: did not \\\n                                              expect a record with a field %s\",\n-                                                 istr::to_estr(f.ident)]);\n+                                                 istr::to_estr(f.ident)]));\n               }\n             }\n         }\n@@ -1453,19 +1455,19 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n+                pat.span, istr::from_estr(\n                 #fmt[\"mismatched types: expected %s, found tuple\",\n-                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]);\n+                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]));\n           }\n         }\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n+                pat.span, istr::from_estr(\n                 #fmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                     vec::len(ex_elts), e_count]);\n+                     vec::len(ex_elts), e_count]));\n         }\n         let i = 0u;\n         for elt in elts { check_pat(fcx, map, elt, ex_elts[i]); i += 1u; }\n@@ -1480,9 +1482,9 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n-                \"mismatched types: expected \" +\n-                istr::to_estr(ty_to_str(fcx.ccx.tcx, expected)) +\n-                \" found box\");\n+                ~\"mismatched types: expected \" +\n+                ty_to_str(fcx.ccx.tcx, expected) +\n+                ~\" found box\");\n           }\n         }\n       }\n@@ -1494,7 +1496,7 @@ fn require_impure(sess: &session::session, f_purity: &ast::purity,\n     alt f_purity {\n       ast::impure_fn. { ret; }\n       ast::pure_fn. {\n-        sess.span_fatal(sp, \"Found impure expression in pure function decl\");\n+        sess.span_fatal(sp, ~\"Found impure expression in pure function decl\");\n       }\n     }\n }\n@@ -1509,7 +1511,7 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n           _ {\n             ccx.tcx.sess.span_fatal(\n                 sp,\n-                \"Pure function calls function not known to be pure\");\n+                ~\"Pure function calls function not known to be pure\");\n           }\n         }\n       }\n@@ -1560,14 +1562,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             if call_kind != kind_for_each {\n                 fcx.ccx.tcx.sess.span_err(\n                     sp,\n-                    \"calling iter outside of for each loop\");\n+                    ~\"calling iter outside of for each loop\");\n             }\n           }\n           _ {\n             if call_kind == kind_for_each {\n                 fcx.ccx.tcx.sess.span_err(\n                     sp,\n-                    \"calling non-iter as sequence of for each loop\");\n+                    ~\"calling non-iter as sequence of for each loop\");\n             }\n           }\n         }\n@@ -1582,18 +1584,18 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n               _ {\n                 fcx.ccx.tcx.sess.span_fatal(\n                     f.span,\n-                    \"mismatched types: \\\n+                    ~\"mismatched types: \\\n                      expected function or native \\\n                      function but found \"\n-                    + istr::to_estr(ty_to_str(fcx.ccx.tcx, fty)))\n+                    + ty_to_str(fcx.ccx.tcx, fty))\n               }\n             };\n \n         // Check that the correct number of arguments were supplied.\n         let expected_arg_count = vec::len(arg_tys);\n         let supplied_arg_count = vec::len(args);\n         if expected_arg_count != supplied_arg_count {\n-            fcx.ccx.tcx.sess.span_err(sp,\n+            fcx.ccx.tcx.sess.span_err(sp, istr::from_estr(\n                                       #fmt[\"this function takes %u \\\n                       parameter%s but %u parameter%s supplied\",\n                                            expected_arg_count,\n@@ -1602,7 +1604,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                                            } else { \"s\" }, supplied_arg_count,\n                                            if supplied_arg_count == 1u {\n                                                \" was\"\n-                                           } else { \"s were\" }]);\n+                                           } else { \"s were\" }]));\n             // HACK: extend the arguments list with dummy arguments to\n             // check against\n             let dummy = {mode: ty::mo_val, ty: ty::mk_nil(fcx.ccx.tcx)};\n@@ -1724,7 +1726,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           ast::expr_call(operator, operands) {\n             if !ty::is_pred_ty(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, operator)) {\n                     fcx.ccx.tcx.sess.span_fatal(operator.span,\n-                     \"Operator in constraint has non-boolean return type\");\n+                     ~\"Operator in constraint has non-boolean return type\");\n             }\n \n             alt operator.node {\n@@ -1735,28 +1737,29 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                   }\n                   _ {\n                     fcx.ccx.tcx.sess.span_fatal(operator.span,\n-                                           \"Impure function as operator \\\n+                                           ~\"Impure function as operator \\\n                                        in constraint\");\n                   }\n                 }\n                 for operand: @ast::expr in operands {\n                     if !ast_util::is_constraint_arg(operand) {\n                         let s =\n-                            \"Constraint args must be \\\n+                            ~\"Constraint args must be \\\n                                               slot variables or literals\";\n                         fcx.ccx.tcx.sess.span_fatal(e.span, s);\n                     }\n                 }\n               }\n               _ {\n                 let s =\n-                    \"In a constraint, expected the \\\n+                    ~\"In a constraint, expected the \\\n                                       constraint name to be an explicit name\";\n                 fcx.ccx.tcx.sess.span_fatal(e.span, s);\n               }\n             }\n           }\n-          _ { fcx.ccx.tcx.sess.span_fatal(e.span, \"check on non-predicate\"); }\n+          _ { fcx.ccx.tcx.sess.span_fatal(\n+              e.span, ~\"check on non-predicate\"); }\n         }\n         ret bot;\n     }\n@@ -1795,7 +1798,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 ~\"binary operation \" + binopstr +\n                 ~\" cannot be applied to type `\" +\n                 t_str + ~\"`\";\n-            fcx.ccx.tcx.sess.span_err(span, istr::to_estr(errmsg));\n+            fcx.ccx.tcx.sess.span_err(span, errmsg);\n         }\n     }\n \n@@ -1843,9 +1846,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                        vec::len(variants[0].args) != 1u {\n                     tcx.sess.span_fatal(\n                         expr.span,\n-                        \"can only dereference tags \" +\n-                        \"with a single variant which has a \"\n-                        + \"single argument\");\n+                        ~\"can only dereference tags \" +\n+                        ~\"with a single variant which has a \"\n+                        + ~\"single argument\");\n                 }\n                 oper_t =\n                     ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n@@ -1854,30 +1857,30 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n               _ {\n                 tcx.sess.span_fatal(\n                     expr.span,\n-                    \"dereferencing non-\" +\n-                    \"dereferenceable type: \" +\n-                    istr::to_estr(ty_to_str(tcx, oper_t)));\n+                    ~\"dereferencing non-\" +\n+                    ~\"dereferenceable type: \" +\n+                    ty_to_str(tcx, oper_t));\n               }\n             }\n           }\n           ast::not. {\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n                 tcx.sess.span_err(\n-                    expr.span,\n+                    expr.span, istr::from_estr(\n                     #fmt[\"mismatched types: expected bool \\\n                           or integer but found %s\",\n-                         istr::to_estr(ty_to_str(tcx, oper_t))]);\n+                         istr::to_estr(ty_to_str(tcx, oper_t))]));\n             }\n           }\n           ast::neg. {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(tcx, oper_t) ||\n                      ty::type_is_fp(tcx, oper_t)) {\n                 tcx.sess.span_err(expr.span,\n-                                  \"applying unary minus to \\\n+                                  ~\"applying unary minus to \\\n                    non-numeric type \"\n-                                  + istr::to_estr(ty_to_str(tcx, oper_t)));\n+                                  + ty_to_str(tcx, oper_t));\n             }\n           }\n         }\n@@ -1894,13 +1897,13 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             // supplied some, that's an error.\n             if vec::len::<@ast::ty>(pth.node.types) > 0u {\n                 tcx.sess.span_fatal(expr.span,\n-                                    \"this kind of value does not \\\n+                                    ~\"this kind of value does not \\\n                                      take type parameters\");\n             }\n             write::ty_only_fixup(fcx, id, tpt.ty);\n         }\n       }\n-      ast::expr_mac(_) { tcx.sess.bug(\"unexpanded macro\"); }\n+      ast::expr_mac(_) { tcx.sess.bug(~\"unexpanded macro\"); }\n       ast::expr_fail(expr_opt) {\n         bot = true;\n         alt expr_opt {\n@@ -1918,7 +1921,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n                 tcx.sess.span_err(expr.span,\n-                                  \"ret; in function returning non-nil\");\n+                                  ~\"ret; in function returning non-nil\");\n             }\n           }\n           some(e) { check_expr_with(fcx, e, fcx.ret_ty); }\n@@ -1928,14 +1931,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n       ast::expr_put(expr_opt) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n         if fcx.proto != ast::proto_iter {\n-            tcx.sess.span_err(expr.span, \"put in non-iterator\");\n+            tcx.sess.span_err(expr.span, ~\"put in non-iterator\");\n         }\n         alt expr_opt {\n           none. {\n             let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n                 tcx.sess.span_err(expr.span,\n-                                  \"put; in iterator yielding non-nil\");\n+                                  ~\"put; in iterator yielding non-nil\");\n             }\n           }\n           some(e) { bot = check_expr_with(fcx, e, fcx.ret_ty); }\n@@ -2009,8 +2012,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           _ {\n             tcx.sess.span_fatal(\n                 expr.span,\n-                \"mismatched types: expected vector or string but \"\n-                + \"found \" + istr::to_estr(ty_to_str(tcx, ety)));\n+                ~\"mismatched types: expected vector or string but \"\n+                + ~\"found \" + ty_to_str(tcx, ety));\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n@@ -2024,7 +2027,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           }\n           _ {\n             tcx.sess.span_fatal(expr.span,\n-                                \"sequence in for each loop not a call\");\n+                                ~\"sequence in for each loop not a call\");\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, expr_ty(tcx, seq), body, id);\n@@ -2162,9 +2165,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                     this_obj_sty = some(structure_of(fcx, expr.span, tpt.ty));\n                   }\n                   none. {\n-                    tcx.sess.bug(\"didn't find \" +\n-                                 istr::to_estr(int::str(did.node)) +\n-                                 \" in type cache\");\n+                    tcx.sess.bug(~\"didn't find \" +\n+                                 int::str(did.node) +\n+                                 ~\" in type cache\");\n                   }\n                 }\n               }\n@@ -2173,7 +2176,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           }\n           none. {\n             // Shouldn't happen.\n-            tcx.sess.span_err(expr.span, \"self-call in non-object context\");\n+            tcx.sess.span_err(expr.span, ~\"self-call in non-object context\");\n           }\n         }\n \n@@ -2204,10 +2207,10 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         if !(type_is_scalar(fcx, expr.span, expr_ty(tcx, e)) &&\n                  type_is_scalar(fcx, expr.span, t_1)) {\n             tcx.sess.span_err(expr.span,\n-                              \"non-scalar cast: \" +\n-                              istr::to_estr(ty_to_str(tcx, expr_ty(tcx, e)))\n-                              + \" as \" +\n-                              istr::to_estr(ty_to_str(tcx, t_1)));\n+                              ~\"non-scalar cast: \" +\n+                              ty_to_str(tcx, expr_ty(tcx, e))\n+                              + ~\" as \" +\n+                              ty_to_str(tcx, t_1));\n         }\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n@@ -2255,7 +2258,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n               ty::ty_rec(flds) { base_fields = flds; }\n               _ {\n                 tcx.sess.span_fatal(expr.span,\n-                                    \"record update has non-record base\");\n+                                    ~\"record update has non-record base\");\n               }\n             }\n             write::ty_only_fixup(fcx, id, bexpr_t);\n@@ -2269,8 +2272,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 }\n                 if !found {\n                     tcx.sess.span_fatal(f.span,\n-                                        \"unknown field in record update: \" +\n-                                        istr::to_estr(f.node.ident));\n+                                        ~\"unknown field in record update: \" +\n+                                        f.node.ident);\n                 }\n             }\n           }\n@@ -2284,15 +2287,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           ty::ty_rec(fields) {\n             let ix: uint = ty::field_idx(tcx.sess, expr.span, field, fields);\n             if ix >= vec::len::<ty::field>(fields) {\n-                tcx.sess.span_fatal(expr.span, \"bad index on record\");\n+                tcx.sess.span_fatal(expr.span, ~\"bad index on record\");\n             }\n             write::ty_only_fixup(fcx, id, fields[ix].mt.ty);\n           }\n           ty::ty_obj(methods) {\n             let ix: uint =\n                 ty::method_idx(tcx.sess, expr.span, field, methods);\n             if ix >= vec::len::<ty::method>(methods) {\n-                tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n+                tcx.sess.span_fatal(expr.span, ~\"bad index on obj\");\n             }\n             let meth = methods[ix];\n             let t =\n@@ -2305,7 +2308,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             let msg =\n                 #fmt[\"attempted field access on type %s\",\n                      istr::to_estr(ty_to_str(tcx, t_err))];\n-            tcx.sess.span_fatal(expr.span, msg);\n+            tcx.sess.span_fatal(expr.span, istr::from_estr(msg));\n           }\n         }\n       }\n@@ -2317,9 +2320,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         let idx_t = expr_ty(tcx, idx);\n         if !type_is_integral(fcx, idx.span, idx_t) {\n             tcx.sess.span_err(idx.span,\n-                              \"mismatched types: expected \\\n+                              ~\"mismatched types: expected \\\n                                integer but found \"\n-                              + istr::to_estr(ty_to_str(tcx, idx_t)));\n+                              + ty_to_str(tcx, idx_t));\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n@@ -2333,8 +2336,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           }\n           _ {\n             tcx.sess.span_fatal(expr.span,\n-                                \"vector-indexing bad type: \" +\n-                                istr::to_estr(ty_to_str(tcx, base_t)));\n+                                ~\"vector-indexing bad type: \" +\n+                                ty_to_str(tcx, base_t));\n           }\n         }\n       }\n@@ -2404,10 +2407,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                         // The user is trying to extend a non-object.\n                         tcx.sess.span_fatal(\n                             e.span,\n-                            istr::to_estr(\n-                                syntax::print::pprust::expr_to_str(e))\n+                                syntax::print::pprust::expr_to_str(e)\n                             +\n-                            \" does not have object type\");\n+                            ~\" does not have object type\");\n                       }\n                     }\n                   }\n@@ -2434,9 +2436,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                         if new_type != m {\n                             ccx.tcx.sess.span_fatal(\n                                 om.span,\n-                                \"Attempted to override method \"\n-                                + istr::to_estr(m.ident) +\n-                                \" with one of a different type\");\n+                                ~\"Attempted to override method \"\n+                                + m.ident +\n+                                ~\" with one of a different type\");\n                         }\n                         ret none;\n                     }\n@@ -2478,7 +2480,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         check_expr_with(fcx, x, t);\n         write::ty_only_fixup(fcx, id, ty::mk_uniq(tcx, t));\n       }\n-      _ { tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n+      _ { tcx.sess.unimpl(~\"expr type in typeck::check_expr\"); }\n     }\n     if bot { write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx)); }\n \n@@ -2511,8 +2513,8 @@ fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n \n     alt fcx.locals.find(local.node.id) {\n       none. {\n-        fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n-                             istr::to_estr(ident_for_local(local)));\n+        fcx.ccx.tcx.sess.bug(~\"check_decl_local: local id not found \" +\n+                             ident_for_local(local));\n       }\n       some(i) {\n         let t = ty::mk_var(fcx.ccx.tcx, i);\n@@ -2561,7 +2563,7 @@ fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n                  }\n                  _ { false }\n                } {\n-            fcx.ccx.tcx.sess.span_warn(s.span, \"unreachable statement\");\n+            fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n             warned = true;\n         }\n         bot |= check_stmt(fcx, s);\n@@ -2570,7 +2572,7 @@ fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n       none. { write::nil_ty(fcx.ccx.tcx, blk.node.id); }\n       some(e) {\n         if bot && !warned {\n-            fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n+            fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n         }\n         bot |= check_expr(fcx, e);\n         let ety = expr_ty(fcx.ccx.tcx, e);\n@@ -2699,15 +2701,15 @@ fn check_main_fn_ty(tcx: &ty::ctxt, main_id: &ast::node_id) {\n         if !ok {\n             let span = ast_map::node_span(tcx.items.get(main_id));\n             tcx.sess.span_err(span,\n-                              \"wrong type in main function: found \" +\n-                              istr::to_estr(ty_to_str(tcx, main_t)));\n+                              ~\"wrong type in main function: found \" +\n+                              ty_to_str(tcx, main_t));\n         }\n       }\n       _ {\n         let span = ast_map::node_span(tcx.items.get(main_id));\n         tcx.sess.span_bug(span,\n-                          \"main has a non-function type: found\" +\n-                          istr::to_estr(ty_to_str(tcx, main_t)));\n+                          ~\"main has a non-function type: found\" +\n+                          ty_to_str(tcx, main_t));\n       }\n     }\n }\n@@ -2716,7 +2718,7 @@ fn check_for_main_fn(tcx: &ty::ctxt, crate: &@ast::crate) {\n     if !tcx.sess.get_opts().library {\n         alt tcx.sess.get_main_id() {\n           some(id) { check_main_fn_ty(tcx, id); }\n-          none. { tcx.sess.span_err(crate.span, \"main function not found\"); }\n+          none. { tcx.sess.span_err(crate.span, ~\"main function not found\"); }\n         }\n     }\n }"}, {"sha": "7272185e0f345ab443c883b6f471a37e47990e47", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857048929c1adc90a19b2027931ac73a28f21dc/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=9857048929c1adc90a19b2027931ac73a28f21dc", "patch": "@@ -64,21 +64,24 @@ obj ext_ctxt(sess: @session,\n \n     fn span_fatal(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n-        sess.span_fatal(sp, msg);\n+        sess.span_fatal(sp, istr::from_estr(msg));\n     }\n     fn span_err(sp: span, msg: str) {\n         self.print_backtrace();\n-        sess.span_err(sp, msg);\n+        sess.span_err(sp, istr::from_estr(msg));\n     }\n     fn span_unimpl(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n-        sess.span_unimpl(sp, msg);\n+        sess.span_unimpl(sp, istr::from_estr(msg));\n     }\n     fn span_bug(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n-        sess.span_bug(sp, msg);\n+        sess.span_bug(sp, istr::from_estr(msg));\n+    }\n+    fn bug(msg: str) -> ! {\n+        self.print_backtrace();\n+        sess.bug(istr::from_estr(msg));\n     }\n-    fn bug(msg: str) -> ! { self.print_backtrace(); sess.bug(msg); }\n     fn next_id() -> ast::node_id { ret sess.next_node_id(); }\n \n }"}]}