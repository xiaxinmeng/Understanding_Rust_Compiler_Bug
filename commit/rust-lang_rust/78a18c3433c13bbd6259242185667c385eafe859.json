{"sha": "78a18c3433c13bbd6259242185667c385eafe859", "node_id": "C_kwDOAAsO6NoAKDc4YTE4YzM0MzNjMTNiYmQ2MjU5MjQyMTg1NjY3YzM4NWVhZmU4NTk", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2022-02-10T17:32:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-10T17:32:44Z"}, "message": "rust-lang/portable-simd#245: Explain unsafe contracts of core::simd\n\n* Explain unsafe contracts of core::simd\r\n\r\nThis permeates the module with remarks on safety for pub methods,\r\nlayout of the Simd type, correct use of intrinsics, et cetera.\r\nThis is mostly to help others curious about how core::simd works,\r\nincluding other Rust contributors, `unsafe` library authors,\r\nand eventually ourselves.", "tree": {"sha": "c3c42610f5aa0391f72fa32b7bfcb12872d9e09d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c42610f5aa0391f72fa32b7bfcb12872d9e09d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78a18c3433c13bbd6259242185667c385eafe859", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBUw8CRBK7hj4Ov3rIwAAxoYIADcBQdqn6I2zYqnCKUmZV4kj\nTGDgio8HdII5D+Y1Gavta4xIaq68yrRJfeCuJzTxOI7SHuKJoCrFL1GueWV06Gex\ns0pns+6eMeZDsqEr4iRfCSj9bBl8qUH4ga+TTwohbjv2pImllH/4VQ05l3jtNt7/\nuDy1J0zbHyL+E40L/sCL32pn78sEzg4qJJLCZkGHCEggFDVtceBSHgJvlUgDZAPS\nCUl1oycTOMQ/hY4yxVZ/Lg0VKeuLdYesm2b5Su9bmsaH1HfoZ8y3Vfb4R+d0wsph\nQCHRJCAivNh5uXlL8tXVQ3wvnnzwl6cA0ycIEryb0Drpa49u9Vfl9VxiB1CRO7Y=\n=cemj\n-----END PGP SIGNATURE-----\n", "payload": "tree c3c42610f5aa0391f72fa32b7bfcb12872d9e09d\nparent dddfffcfb3e49c752d6a28039735ada2552d0307\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1644514364 -0800\ncommitter GitHub <noreply@github.com> 1644514364 -0800\n\nrust-lang/portable-simd#245: Explain unsafe contracts of core::simd\n\n* Explain unsafe contracts of core::simd\r\n\r\nThis permeates the module with remarks on safety for pub methods,\r\nlayout of the Simd type, correct use of intrinsics, et cetera.\r\nThis is mostly to help others curious about how core::simd works,\r\nincluding other Rust contributors, `unsafe` library authors,\r\nand eventually ourselves."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78a18c3433c13bbd6259242185667c385eafe859", "html_url": "https://github.com/rust-lang/rust/commit/78a18c3433c13bbd6259242185667c385eafe859", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78a18c3433c13bbd6259242185667c385eafe859/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dddfffcfb3e49c752d6a28039735ada2552d0307", "url": "https://api.github.com/repos/rust-lang/rust/commits/dddfffcfb3e49c752d6a28039735ada2552d0307", "html_url": "https://github.com/rust-lang/rust/commit/dddfffcfb3e49c752d6a28039735ada2552d0307"}], "stats": {"total": 111, "additions": 100, "deletions": 11}, "files": [{"sha": "e150946c705c964b15ca5e718527833bbb4d7b05", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=78a18c3433c13bbd6259242185667c385eafe859", "patch": "@@ -2,16 +2,31 @@\n //! crate.\n //!\n //! The LLVM assembly language is documented here: <https://llvm.org/docs/LangRef.html>\n+//!\n+//! A quick glossary of jargon that may appear in this module, mostly paraphrasing LLVM's LangRef:\n+//! - poison: \"undefined behavior as a value\". specifically, it is like uninit memory (such as padding bytes). it is \"safe\" to create poison, BUT\n+//!   poison MUST NOT be observed from safe code, as operations on poison return poison, like NaN. unlike NaN, which has defined comparisons,\n+//!   poison is neither true nor false, and LLVM may also convert it to undef (at which point it is both). so, it can't be conditioned on, either.\n+//! - undef: \"a value that is every value\". functionally like poison, insofar as Rust is concerned. poison may become this. note:\n+//!   this means that division by poison or undef is like division by zero, which means it inflicts...\n+//! - \"UB\": poison and undef cover most of what people call \"UB\". \"UB\" means this operation immediately invalidates the program:\n+//!   LLVM is allowed to lower it to `ud2` or other opcodes that may cause an illegal instruction exception, and this is the \"good end\".\n+//!   The \"bad end\" is that LLVM may reverse time to the moment control flow diverged on a path towards undefined behavior,\n+//!   and destroy the other branch, potentially deleting safe code and violating Rust's `unsafe` contract.\n+//!\n+//! Note that according to LLVM, vectors are not arrays, but they are equivalent when stored to and loaded from memory.\n+//!\n+//! Unless stated otherwise, all intrinsics for binary operations require SIMD vectors of equal types and lengths.\n \n /// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n-/// simply lowered to the matching LLVM instructions by the compiler.  The associated instruction\n-/// is documented alongside each intrinsic.\n+/// mostly lowered to the matching LLVM instructions by the compiler in a fairly straightforward manner.\n+/// The associated LLVM instruction or intrinsic is documented alongside each Rust intrinsic function.\n extern \"platform-intrinsic\" {\n     /// add/fadd\n     pub(crate) fn simd_add<T>(x: T, y: T) -> T;\n \n     /// sub/fsub\n-    pub(crate) fn simd_sub<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_sub<T>(lhs: T, rhs: T) -> T;\n \n     /// mul/fmul\n     pub(crate) fn simd_mul<T>(x: T, y: T) -> T;\n@@ -20,19 +35,22 @@ extern \"platform-intrinsic\" {\n     /// ints and uints: {s,u}div incur UB if division by zero occurs.\n     /// ints: sdiv is UB for int::MIN / -1.\n     /// floats: fdiv is never UB, but may create NaNs or infinities.\n-    pub(crate) fn simd_div<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_div<T>(lhs: T, rhs: T) -> T;\n \n     /// urem/srem/frem\n     /// ints and uints: {s,u}rem incur UB if division by zero occurs.\n     /// ints: srem is UB for int::MIN / -1.\n     /// floats: frem is equivalent to libm::fmod in the \"default\" floating point environment, sans errno.\n-    pub(crate) fn simd_rem<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_rem<T>(lhs: T, rhs: T) -> T;\n \n     /// shl\n-    pub(crate) fn simd_shl<T>(x: T, y: T) -> T;\n+    /// for (u)ints. poison if rhs >= lhs::BITS\n+    pub(crate) fn simd_shl<T>(lhs: T, rhs: T) -> T;\n \n-    /// lshr/ashr\n-    pub(crate) fn simd_shr<T>(x: T, y: T) -> T;\n+    /// ints: ashr\n+    /// uints: lshr\n+    /// poison if rhs >= lhs::BITS\n+    pub(crate) fn simd_shr<T>(lhs: T, rhs: T) -> T;\n \n     /// and\n     pub(crate) fn simd_and<T>(x: T, y: T) -> T;\n@@ -44,6 +62,9 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n \n     /// fptoui/fptosi/uitofp/sitofp\n+    /// casting floats to integers is truncating, so it is safe to convert values like e.g. 1.5\n+    /// but the truncated value must fit in the target type or the result is poison.\n+    /// use `simd_as` instead for a cast that performs a saturating conversion.\n     pub(crate) fn simd_cast<T, U>(x: T) -> U;\n     /// follows Rust's `T as U` semantics, including saturating float casts\n     /// which amounts to the same as `simd_cast` for many cases\n@@ -63,6 +84,7 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_fmin<T>(x: T, y: T) -> T;\n     pub(crate) fn simd_fmax<T>(x: T, y: T) -> T;\n \n+    // these return Simd<int, N> with the same BITS size as the inputs\n     pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;\n@@ -71,19 +93,31 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;\n \n     // shufflevector\n+    // idx: LLVM calls it a \"shuffle mask vector constant\", a vector of i32s\n     pub(crate) fn simd_shuffle<T, U, V>(x: T, y: T, idx: U) -> V;\n \n+    /// llvm.masked.gather\n+    /// like a loop of pointer reads\n+    /// val: vector of values to select if a lane is masked\n+    /// ptr: vector of pointers to read from\n+    /// mask: a \"wide\" mask of integers, selects as if simd_select(mask, read(ptr), val)\n+    /// note, the LLVM intrinsic accepts a mask vector of <N x i1>\n+    /// FIXME: review this if/when we fix up our mask story in general?\n     pub(crate) fn simd_gather<T, U, V>(val: T, ptr: U, mask: V) -> T;\n+    /// llvm.masked.scatter\n+    /// like gather, but more spicy, as it writes instead of reads\n     pub(crate) fn simd_scatter<T, U, V>(val: T, ptr: U, mask: V);\n \n     // {s,u}add.sat\n     pub(crate) fn simd_saturating_add<T>(x: T, y: T) -> T;\n \n     // {s,u}sub.sat\n-    pub(crate) fn simd_saturating_sub<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_saturating_sub<T>(lhs: T, rhs: T) -> T;\n \n     // reductions\n+    // llvm.vector.reduce.{add,fadd}\n     pub(crate) fn simd_reduce_add_ordered<T, U>(x: T, y: U) -> U;\n+    // llvm.vector.reduce.{mul,fmul}\n     pub(crate) fn simd_reduce_mul_ordered<T, U>(x: T, y: U) -> U;\n     #[allow(unused)]\n     pub(crate) fn simd_reduce_all<T>(x: T) -> bool;\n@@ -100,7 +134,10 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n \n     // select\n-    pub(crate) fn simd_select<M, T>(m: M, a: T, b: T) -> T;\n+    // first argument is a vector of integers, -1 (all bits 1) is \"true\"\n+    // logically equivalent to (yes & m) | (no & (m^-1),\n+    // but you can use it on floats.\n+    pub(crate) fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     #[allow(unused)]\n-    pub(crate) fn simd_select_bitmask<M, T>(m: M, a: T, b: T) -> T;\n+    pub(crate) fn simd_select_bitmask<M, T>(m: M, yes: T, no: T) -> T;\n }"}, {"sha": "91ae34c05e095884169824f1f0b0ab461e1d6c7d", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=78a18c3433c13bbd6259242185667c385eafe859", "patch": "@@ -3,6 +3,7 @@\n     const_fn_trait_bound,\n     convert_float_to_int,\n     decl_macro,\n+    intra_doc_pointers,\n     platform_intrinsics,\n     repr_simd,\n     simd_ffi,"}, {"sha": "556bc2cc1feee8a114253cdb99d464a5438b3bba", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=78a18c3433c13bbd6259242185667c385eafe859", "patch": "@@ -19,6 +19,11 @@ macro_rules! implement {\n             /// * Not be NaN\n             /// * Not be infinite\n             /// * Be representable in the return type, after truncating off its fractional part\n+            ///\n+            /// If these requirements are infeasible or costly, consider using the safe function [cast],\n+            /// which saturates on conversion.\n+            ///\n+            /// [cast]: Simd::cast\n             #[inline]\n             pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n             where"}, {"sha": "3acf07260e12b058ec3bb1532c24d1d77cfac312", "filename": "crates/core_simd/src/select.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=78a18c3433c13bbd6259242185667c385eafe859", "patch": "@@ -11,6 +11,7 @@ where\n     /// For each lane in the mask, choose the corresponding lane from `true_values` if\n     /// that lane mask is true, and `false_values` if that lane mask is false.\n     ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n@@ -31,6 +32,8 @@ where\n     where\n         U: SimdElement<Mask = T>,\n     {\n+        // Safety: The mask has been cast to a vector of integers,\n+        // and the operands to select between are vectors of the same type and length.\n         unsafe { intrinsics::simd_select(self.to_int(), true_values, false_values) }\n     }\n \n@@ -39,6 +42,7 @@ where\n     /// For each lane in the mask, choose the corresponding lane from `true_values` if\n     /// that lane mask is true, and `false_values` if that lane mask is false.\n     ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::Mask;"}, {"sha": "ff1b2c756ad4025bb208502eb5f0db6bb2f5c0b0", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a18c3433c13bbd6259242185667c385eafe859/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=78a18c3433c13bbd6259242185667c385eafe859", "patch": "@@ -44,6 +44,47 @@ use crate::simd::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n ///\n /// [`Wrapping<T>`]: core::num::Wrapping\n ///\n+/// # Layout\n+/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), but with a greater alignment.\n+/// `[T; N]` is aligned to `T`, but `Simd<T, N>` will have an alignment based on both `T` and `N`.\n+/// It is thus sound to [`transmute`] `Simd<T, N>` to `[T; N]`, and will typically optimize to zero cost,\n+/// but the reverse transmutation is more likely to require a copy the compiler cannot simply elide.\n+///\n+/// # ABI \"Features\"\n+/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed to and from functions via memory, not SIMD registers,\n+/// except as an optimization. `#[inline]` hints are recommended on functions that accept `Simd<T, N>` or return it.\n+/// The need for this may be corrected in the future.\n+///\n+/// # Safe SIMD with Unsafe Rust\n+///\n+/// Operations with `Simd` are typically safe, but there are many reasons to want to combine SIMD with `unsafe` code.\n+/// Care must be taken to respect differences between `Simd` and other types it may be transformed into or derived from.\n+/// In particular, the layout of `Simd<T, N>` may be similar to `[T; N]`, and may allow some transmutations,\n+/// but references to `[T; N]` are not interchangeable with those to `Simd<T, N>`.\n+/// Thus, when using `unsafe` Rust to read and write `Simd<T, N>` through [raw pointers], it is a good idea to first try with\n+/// [`read_unaligned`] and [`write_unaligned`]. This is because:\n+/// - [`read`] and [`write`] require full alignment (in this case, `Simd<T, N>`'s alignment)\n+/// - the likely source for reading or destination for writing `Simd<T, N>` is [`[T]`](slice) and similar types, aligned to `T`\n+/// - combining these actions would violate the `unsafe` contract and explode the program into a puff of **undefined behavior**\n+/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned if it sees the optimization\n+/// - most contemporary processors suffer no performance penalty for \"unaligned\" reads and writes that are aligned at runtime\n+///\n+/// By imposing less obligations, unaligned functions are less likely to make the program unsound,\n+/// and may be just as fast as stricter alternatives.\n+/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for converting `[T]` to `[Simd<T, N>]`,\n+/// and allows soundly operating on an aligned SIMD body, but it may cost more time when handling the scalar head and tail.\n+/// If these are not sufficient, then it is most ideal to design data structures to be already aligned\n+/// to the `Simd<T, N>` you wish to use before using `unsafe` Rust to read or write.\n+/// More conventional ways to compensate for these facts, like materializing `Simd` to or from an array first,\n+/// are handled by safe methods like [`Simd::from_array`] and [`Simd::from_slice`].\n+///\n+/// [`transmute`]: core::mem::transmute\n+/// [raw pointers]: pointer\n+/// [`read_unaligned`]: pointer::read_unaligned\n+/// [`write_unaligned`]: pointer::write_unaligned\n+/// [`read`]: pointer::read\n+/// [`write`]: pointer::write\n+/// [as_simd]: slice::as_simd\n #[repr(simd)]\n pub struct Simd<T, const LANES: usize>([T; LANES])\n where\n@@ -133,6 +174,7 @@ where\n     #[inline]\n     #[cfg(not(bootstrap))]\n     pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n+        // Safety: The input argument is a vector of a known SIMD type.\n         unsafe { intrinsics::simd_as(self) }\n     }\n "}]}