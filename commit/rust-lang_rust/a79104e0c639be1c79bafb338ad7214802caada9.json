{"sha": "a79104e0c639be1c79bafb338ad7214802caada9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3OTEwNGUwYzYzOWJlMWM3OWJhZmIzMzhhZDcyMTQ4MDJjYWFkYTk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-27T17:18:02Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T16:21:33Z"}, "message": "serialize: extend with specialization-based encoding/decoding multi-dispatch.", "tree": {"sha": "5affff3a58a008cccc9724ca1aa5ba6d432ff38c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5affff3a58a008cccc9724ca1aa5ba6d432ff38c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a79104e0c639be1c79bafb338ad7214802caada9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a79104e0c639be1c79bafb338ad7214802caada9", "html_url": "https://github.com/rust-lang/rust/commit/a79104e0c639be1c79bafb338ad7214802caada9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a79104e0c639be1c79bafb338ad7214802caada9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c2552b712386dd01a9d620aff960b98cddb4098", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c2552b712386dd01a9d620aff960b98cddb4098", "html_url": "https://github.com/rust-lang/rust/commit/2c2552b712386dd01a9d620aff960b98cddb4098"}], "stats": {"total": 100, "additions": 100, "deletions": 0}, "files": [{"sha": "ebd939120973d59faa35f8bd0649da4a4334dd16", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a79104e0c639be1c79bafb338ad7214802caada9/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79104e0c639be1c79bafb338ad7214802caada9/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=a79104e0c639be1c79bafb338ad7214802caada9", "patch": "@@ -29,8 +29,10 @@ Core encoding and decoding interfaces.\n \n #![feature(box_syntax)]\n #![feature(collections)]\n+#![feature(core_intrinsics)]\n #![feature(enumset)]\n #![feature(rustc_private)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unicode)]\n #![feature(question_mark)]\n@@ -46,6 +48,9 @@ extern crate collections;\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n                           DecoderHelpers, EncoderHelpers};\n \n+pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};\n+pub use self::serialize::{UseSpecializedEncodable, UseSpecializedDecodable};\n+\n mod serialize;\n mod collection_impls;\n "}, {"sha": "4414fee78788e2d16b7898315a7b0e05c67a0649", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a79104e0c639be1c79bafb338ad7214802caada9/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79104e0c639be1c79bafb338ad7214802caada9/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=a79104e0c639be1c79bafb338ad7214802caada9", "patch": "@@ -14,6 +14,7 @@\n Core encoding and decoding interfaces.\n */\n \n+use std::intrinsics;\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n@@ -635,3 +636,97 @@ impl<D: Decoder> DecoderHelpers for D {\n         })\n     }\n }\n+\n+// ___________________________________________________________________________\n+// Specialization-based interface for multi-dispatch Encodable/Decodable.\n+\n+/// Implement this trait on your `{Encodable,Decodable}::Error` types\n+/// to override the default panic behavior for missing specializations.\n+pub trait SpecializationError {\n+    /// Create an error for a missing method specialization.\n+    /// Defaults to panicking with type, trait & method names.\n+    /// `S` is the encoder/decoder state type,\n+    /// `T` is the type being encoded/decoded, and\n+    /// the arguments are the names of the trait\n+    /// and method that should've been overriden.\n+    fn not_found<S, T: ?Sized>(trait_name: &'static str,\n+                               method_name: &'static str) -> Self;\n+}\n+\n+impl<E> SpecializationError for E {\n+    default fn not_found<S, T: ?Sized>(trait_name: &'static str,\n+                                       method_name: &'static str) -> E {\n+        panic!(\"missing specializaiton: `<{} as {}<{}>>::{}` not overriden\",\n+               unsafe { intrinsics::type_name::<S>() },\n+               trait_name,\n+               unsafe { intrinsics::type_name::<T>() },\n+               method_name);\n+    }\n+}\n+\n+/// Implement this trait on encoders, with `T` being the type\n+/// you want to encode (employing `UseSpecializedEncodable`),\n+/// using a strategy specific to the encoder.\n+/// Can also be implemented alongside `UseSpecializedEncodable`\n+/// to provide a default `specialized_encode` for encoders\n+/// which do not implement `SpecializedEncoder` themselves.\n+pub trait SpecializedEncoder<T: ?Sized>: Encoder {\n+    /// Encode the value in a manner specific to this encoder state.\n+    /// Defaults to returning an error (see `SpecializationError`).\n+    fn specialized_encode(&mut self, value: &T) -> Result<(), Self::Error>;\n+}\n+\n+impl<E: Encoder, T: ?Sized> SpecializedEncoder<T> for E {\n+    default fn specialized_encode(&mut self, _: &T) -> Result<(), E::Error> {\n+        Err(E::Error::not_found::<E, T>(\"SpecializedEncoder\", \"specialized_encode\"))\n+    }\n+}\n+\n+/// Implement this trait on decoders, with `T` being the type\n+/// you want to decode (employing `UseSpecializedDecodable`),\n+/// using a strategy specific to the decoder.\n+/// Can also be implemented alongside `UseSpecializedDecodable`\n+/// to provide a default `specialized_decode` for decoders\n+/// which do not implement `SpecializedDecoder` themselves.\n+pub trait SpecializedDecoder<T>: Decoder {\n+    /// Decode a value in a manner specific to this decoder state.\n+    /// Defaults to returning an error (see `SpecializationError`).\n+    fn specialized_decode(&mut self) -> Result<T, Self::Error>;\n+}\n+\n+impl<D: Decoder, T> SpecializedDecoder<T> for D {\n+    default fn specialized_decode(&mut self) -> Result<T, D::Error> {\n+        Err(D::Error::not_found::<D, T>(\"SpecializedDecoder\", \"specialized_decode\"))\n+    }\n+}\n+\n+/// Implement this trait on your type to get an `Encodable`\n+/// implementation which goes through `SpecializedEncoder`.\n+pub trait UseSpecializedEncodable {}\n+\n+impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n+    default fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        E::specialized_encode(e, self)\n+    }\n+}\n+\n+/// Implement this trait on your type to get an `Decodable`\n+/// implementation which goes through `SpecializedDecoder`.\n+pub trait UseSpecializedDecodable: Sized {}\n+\n+impl<T: UseSpecializedDecodable> Decodable for T {\n+    default fn decode<D: Decoder>(d: &mut D) -> Result<T, D::Error> {\n+        D::specialized_decode(d)\n+    }\n+}\n+\n+// Can't avoid specialization for &T and Box<T> impls,\n+// as proxy impls on them are blankets that conflict\n+// with the Encodable and Decodable impls above,\n+// which only have `default` on their methods\n+// for this exact reason.\n+// May be fixable in a simpler fashion via the\n+// more complex lattice model for specialization.\n+impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {}\n+impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {}\n+impl<T: Decodable> UseSpecializedDecodable for Box<T> {}"}]}