{"sha": "e033a389e1b375e45799398c2c58ece1e23bbb3b", "node_id": "C_kwDOAAsO6NoAKGUwMzNhMzg5ZTFiMzc1ZTQ1Nzk5Mzk4YzJjNThlY2UxZTIzYmJiM2I", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-16T14:39:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-16T14:39:46Z"}, "message": "Rollup merge of #104335 - Nilstrieb:macrowo, r=compiler-errors\n\nOnly do parser recovery on retried macro matching\n\nEager parser recovery can break macros, so we don't do it at first. But when we already know that the macro failed, we can retry it with recovery enabled to still emit useful diagnostics.\n\nHelps with #103534", "tree": {"sha": "c985e5f0eb9d4dfbce9765c7f207bbd0b63e9080", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c985e5f0eb9d4dfbce9765c7f207bbd0b63e9080"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e033a389e1b375e45799398c2c58ece1e23bbb3b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjdPYyCRBK7hj4Ov3rIwAAM1UIAALyg/iipjYzo+dc7Rl6vQgl\nUs9TUQx4YiZ8ZpsMLYYNjwKXSuHP2fJ2lSghzGguKqjg7yF9q7pSJjgvswoj6a6r\nwRsLuKmySiH+RgdUAhdNhvmFh4y15LebtLknRD7v0lmjMkjoLATiVq8NzLs2pS54\nPcUxoUwUChnjK63MSzdGyXtaDvLsddc4rMwaWubK1KjtRqkwFgl/eEk4P7GmcR+W\n/sGZMKpaNq36rS3eS4AIh/5Fq03bBTMDireAXeRCwsN1bJ2MUblsSDLh5kWxNiTf\nbHWMBfjN7Fcxwl82RakuYp94i779fmsqe3Ahy91pXj7zOsLPqWfnwrDwTKhUWJs=\n=IVgs\n-----END PGP SIGNATURE-----\n", "payload": "tree c985e5f0eb9d4dfbce9765c7f207bbd0b63e9080\nparent 353b915fecd7feb30127b3107ea091a1a28f5e4a\nparent b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668609586 +0100\ncommitter GitHub <noreply@github.com> 1668609586 +0100\n\nRollup merge of #104335 - Nilstrieb:macrowo, r=compiler-errors\n\nOnly do parser recovery on retried macro matching\n\nEager parser recovery can break macros, so we don't do it at first. But when we already know that the macro failed, we can retry it with recovery enabled to still emit useful diagnostics.\n\nHelps with #103534\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e033a389e1b375e45799398c2c58ece1e23bbb3b", "html_url": "https://github.com/rust-lang/rust/commit/e033a389e1b375e45799398c2c58ece1e23bbb3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e033a389e1b375e45799398c2c58ece1e23bbb3b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "353b915fecd7feb30127b3107ea091a1a28f5e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/353b915fecd7feb30127b3107ea091a1a28f5e4a", "html_url": "https://github.com/rust-lang/rust/commit/353b915fecd7feb30127b3107ea091a1a28f5e4a"}, {"sha": "b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7", "html_url": "https://github.com/rust-lang/rust/commit/b7b67228f9cd4fab4462ebe4d4d05ad10bf5a7d7"}], "stats": {"total": 70, "additions": 60, "deletions": 10}, "files": [{"sha": "c02680b77fb152e5cd6bc9f2c5d15be21e9ada66", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e033a389e1b375e45799398c2c58ece1e23bbb3b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e033a389e1b375e45799398c2c58ece1e23bbb3b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=e033a389e1b375e45799398c2c58ece1e23bbb3b", "patch": "@@ -22,7 +22,7 @@ use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n };\n use rustc_lint_defs::BuiltinLintDiagnostics;\n-use rustc_parse::parser::Parser;\n+use rustc_parse::parser::{Parser, Recovery};\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -219,6 +219,8 @@ pub(super) trait Tracker<'matcher> {\n \n     /// For tracing.\n     fn description() -> &'static str;\n+\n+    fn recovery() -> Recovery;\n }\n \n /// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n@@ -230,6 +232,9 @@ impl<'matcher> Tracker<'matcher> for NoopTracker {\n     fn description() -> &'static str {\n         \"none\"\n     }\n+    fn recovery() -> Recovery {\n+        Recovery::Forbidden\n+    }\n }\n \n /// Expands the rules based macro defined by `lhses` and `rhses` for a given\n@@ -330,15 +335,20 @@ fn expand_macro<'cx>(\n     let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n \n     let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n-    assert!(try_success_result.is_err(), \"Macro matching returned a success on the second try\");\n+\n+    if try_success_result.is_ok() {\n+        // Nonterminal parser recovery might turn failed matches into successful ones,\n+        // but for that it must have emitted an error already\n+        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n+    }\n \n     if let Some(result) = tracker.result {\n         // An irrecoverable error occurred and has been emitted.\n         return result;\n     }\n \n     let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n-        return tracker.result.expect(\"must have encountered Error or ErrorReported\");\n+        return DummyResult::any(sp);\n     };\n \n     let span = token.span.substitute_dummy(sp);\n@@ -360,7 +370,7 @@ fn expand_macro<'cx>(\n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone());\n+            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n             let mut tt_parser = TtParser::new(name);\n \n             if let Success(_) =\n@@ -406,7 +416,12 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n     fn after_arm(&mut self, result: &NamedParseResult) {\n         match result {\n             Success(_) => {\n-                unreachable!(\"should not collect detailed info for successful macro match\");\n+                // Nonterminal parser recovery might turn failed matches into successful ones,\n+                // but for that it must have emitted an error already\n+                self.cx.sess.delay_span_bug(\n+                    self.root_span,\n+                    \"should not collect detailed info for successful macro match\",\n+                );\n             }\n             Failure(token, msg) => match self.best_failure {\n                 Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n@@ -432,6 +447,10 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n     fn description() -> &'static str {\n         \"detailed\"\n     }\n+\n+    fn recovery() -> Recovery {\n+        Recovery::Allowed\n+    }\n }\n \n impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n@@ -477,7 +496,7 @@ fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n     // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n-    let parser = parser_from_cx(sess, arg.clone());\n+    let parser = parser_from_cx(sess, arg.clone(), T::recovery());\n     // Try each arm's matchers.\n     let mut tt_parser = TtParser::new(name);\n     for (i, lhs) in lhses.iter().enumerate() {\n@@ -1559,8 +1578,8 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn parser_from_cx(sess: &ParseSess, tts: TokenStream) -> Parser<'_> {\n-    Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS)\n+fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n+    Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS).recovery(recovery)\n }\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For"}, {"sha": "13a38a177350997163d239054901904eb73001b3", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e033a389e1b375e45799398c2c58ece1e23bbb3b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e033a389e1b375e45799398c2c58ece1e23bbb3b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=e033a389e1b375e45799398c2c58ece1e23bbb3b", "patch": "@@ -503,8 +503,8 @@ impl<'a> Parser<'a> {\n         parser\n     }\n \n-    pub fn forbid_recovery(mut self) -> Self {\n-        self.recovery = Recovery::Forbidden;\n+    pub fn recovery(mut self, recovery: Recovery) -> Self {\n+        self.recovery = recovery;\n         self\n     }\n "}, {"sha": "ebf65f1cc01e693a5bdad81efdc35da0aa24c6a1", "filename": "src/test/ui/macros/recovery-allowed.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e033a389e1b375e45799398c2c58ece1e23bbb3b/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e033a389e1b375e45799398c2c58ece1e23bbb3b/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.rs?ref=e033a389e1b375e45799398c2c58ece1e23bbb3b", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! please_recover {\n+    ($a:expr) => {};\n+}\n+\n+please_recover! { not 1 }\n+//~^ ERROR unexpected `1` after identifier\n+\n+fn main() {}"}, {"sha": "ec036e8b1e24bcfba928bc94c467c97a3b5d359f", "filename": "src/test/ui/macros/recovery-allowed.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e033a389e1b375e45799398c2c58ece1e23bbb3b/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e033a389e1b375e45799398c2c58ece1e23bbb3b/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frecovery-allowed.stderr?ref=e033a389e1b375e45799398c2c58ece1e23bbb3b", "patch": "@@ -0,0 +1,10 @@\n+error: unexpected `1` after identifier\n+  --> $DIR/recovery-allowed.rs:5:23\n+   |\n+LL | please_recover! { not 1 }\n+   |                   ----^\n+   |                   |\n+   |                   help: use `!` to perform bitwise not\n+\n+error: aborting due to previous error\n+"}, {"sha": "5dd2619330c4afb9e2d943a3f9ac6d2f6ac3200e", "filename": "src/test/ui/macros/recovery-forbidden.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e033a389e1b375e45799398c2c58ece1e23bbb3b/src%2Ftest%2Fui%2Fmacros%2Frecovery-forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e033a389e1b375e45799398c2c58ece1e23bbb3b/src%2Ftest%2Fui%2Fmacros%2Frecovery-forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frecovery-forbidden.rs?ref=e033a389e1b375e45799398c2c58ece1e23bbb3b", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+macro_rules! dont_recover_here {\n+    ($e:expr) => {\n+        compile_error!(\"Must not recover to single !1 expr\");\n+    };\n+\n+    (not $a:literal) => {};\n+}\n+\n+dont_recover_here! { not 1 }\n+\n+fn main() {}"}]}