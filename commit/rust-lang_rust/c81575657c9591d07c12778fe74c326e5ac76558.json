{"sha": "c81575657c9591d07c12778fe74c326e5ac76558", "node_id": "C_kwDOAAsO6NoAKGM4MTU3NTY1N2M5NTkxZDA3YzEyNzc4ZmU3NGMzMjZlNWFjNzY1NTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-13T06:41:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-13T06:41:37Z"}, "message": "Auto merge of #100640 - reitermarkus:socket-display-buffer, r=thomcc\n\nUse `DisplayBuffer` for socket addresses.\n\nContinuation of https://github.com/rust-lang/rust/pull/100625 for socket addresses.\n\nRenames `net::addr` to `net::addr::socket`, `net::ip` to `net::addr::ip` and `net::ip::display_buffer::IpDisplayBuffer` to `net::addr::display_buffer::DisplayBuffer`.", "tree": {"sha": "380f2177d1270d986cf421bb81b61f220506532b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/380f2177d1270d986cf421bb81b61f220506532b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c81575657c9591d07c12778fe74c326e5ac76558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c81575657c9591d07c12778fe74c326e5ac76558", "html_url": "https://github.com/rust-lang/rust/commit/c81575657c9591d07c12778fe74c326e5ac76558", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c81575657c9591d07c12778fe74c326e5ac76558/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9da4644d5685aa0c4daa4aea6ddc9eb834ae51cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da4644d5685aa0c4daa4aea6ddc9eb834ae51cc", "html_url": "https://github.com/rust-lang/rust/commit/9da4644d5685aa0c4daa4aea6ddc9eb834ae51cc"}, {"sha": "14230a7f8e117aa049d3ae661fa00ded7edefc68", "url": "https://api.github.com/repos/rust-lang/rust/commits/14230a7f8e117aa049d3ae661fa00ded7edefc68", "html_url": "https://github.com/rust-lang/rust/commit/14230a7f8e117aa049d3ae661fa00ded7edefc68"}], "stats": {"total": 243, "additions": 167, "deletions": 76}, "files": [{"sha": "81b0ebfb42c541a82597ad70732a204099ff6ac4", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -214,6 +214,7 @@ symbols! {\n         IntoIterator,\n         IoRead,\n         IoWrite,\n+        IpAddr,\n         IrTyKind,\n         Is,\n         ItemContext,"}, {"sha": "7aadf06e92fc6a5b80c04ea34f4256ee07295cee", "filename": "library/std/src/net/display_buffer.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fdisplay_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fdisplay_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fdisplay_buffer.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -3,12 +3,12 @@ use crate::mem::MaybeUninit;\n use crate::str;\n \n /// Used for slow path in `Display` implementations when alignment is required.\n-pub struct IpDisplayBuffer<const SIZE: usize> {\n+pub struct DisplayBuffer<const SIZE: usize> {\n     buf: [MaybeUninit<u8>; SIZE],\n     len: usize,\n }\n \n-impl<const SIZE: usize> IpDisplayBuffer<SIZE> {\n+impl<const SIZE: usize> DisplayBuffer<SIZE> {\n     #[inline]\n     pub const fn new() -> Self {\n         Self { buf: MaybeUninit::uninit_array(), len: 0 }\n@@ -25,7 +25,7 @@ impl<const SIZE: usize> IpDisplayBuffer<SIZE> {\n     }\n }\n \n-impl<const SIZE: usize> fmt::Write for IpDisplayBuffer<SIZE> {\n+impl<const SIZE: usize> fmt::Write for DisplayBuffer<SIZE> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         let bytes = s.as_bytes();\n ", "previous_filename": "library/std/src/net/ip/display_buffer.rs"}, {"sha": "4f14fc28038ad5c903559b4d3c3798f77f7476e9", "filename": "library/std/src/net/ip_addr.rs", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -8,8 +8,7 @@ use crate::mem::transmute;\n use crate::sys::net::netc as c;\n use crate::sys_common::{FromInner, IntoInner};\n \n-mod display_buffer;\n-use display_buffer::IpDisplayBuffer;\n+use super::display_buffer::DisplayBuffer;\n \n /// An IP address, either IPv4 or IPv6.\n ///\n@@ -30,6 +29,7 @@ use display_buffer::IpDisplayBuffer;\n /// assert_eq!(localhost_v4.is_ipv6(), false);\n /// assert_eq!(localhost_v4.is_ipv4(), true);\n /// ```\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"IpAddr\")]\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n #[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\n pub enum IpAddr {\n@@ -73,6 +73,7 @@ pub enum IpAddr {\n /// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n /// ```\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Ipv4Addr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv4Addr {\n     octets: [u8; 4],\n@@ -155,6 +156,7 @@ pub struct Ipv4Addr {\n /// assert_eq!(localhost.is_loopback(), true);\n /// ```\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Ipv6Addr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv6Addr {\n     octets: [u8; 16],\n@@ -997,7 +999,7 @@ impl fmt::Display for Ipv4Addr {\n         } else {\n             const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n \n-            let mut buf = IpDisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n             // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n             write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n \n@@ -1844,7 +1846,7 @@ impl fmt::Display for Ipv6Addr {\n         } else {\n             const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n \n-            let mut buf = IpDisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n             // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n             write!(buf, \"{}\", self).unwrap();\n ", "previous_filename": "library/std/src/net/ip.rs"}, {"sha": "7c3430b2b217c5b838e22a63bf3511e846bc0f56", "filename": "library/std/src/net/ip_addr/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "previous_filename": "library/std/src/net/ip/tests.rs"}, {"sha": "01e3db9de51c4e70eeb095da83f6c4fd1a5f96b1", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -24,21 +24,22 @@\n use crate::io::{self, ErrorKind};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n+pub use self::ip_addr::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::parser::AddrParseError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::socket_addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n #[unstable(feature = \"tcplistener_into_incoming\", issue = \"88339\")]\n pub use self::tcp::IntoIncoming;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::tcp::{Incoming, TcpListener, TcpStream};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::udp::UdpSocket;\n \n-mod addr;\n-mod ip;\n+mod display_buffer;\n+mod ip_addr;\n mod parser;\n+mod socket_addr;\n mod tcp;\n #[cfg(test)]\n pub(crate) mod test;"}, {"sha": "33b0dfa03e0ed3b029138814e459330962dbd1f5", "filename": "library/std/src/net/socket_addr.rs", "status": "renamed", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -2,9 +2,9 @@\n mod tests;\n \n use crate::cmp::Ordering;\n-use crate::fmt;\n+use crate::fmt::{self, Write};\n use crate::hash;\n-use crate::io::{self, Write};\n+use crate::io;\n use crate::iter;\n use crate::mem;\n use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n@@ -15,6 +15,8 @@ use crate::sys_common::net::LookupHost;\n use crate::sys_common::{FromInner, IntoInner};\n use crate::vec;\n \n+use super::display_buffer::DisplayBuffer;\n+\n /// An internet socket address, either IPv4 or IPv6.\n ///\n /// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n@@ -616,25 +618,18 @@ impl fmt::Debug for SocketAddr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddrV4 {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Fast path: if there's no alignment stuff, write to the output buffer\n-        // directly\n+        // If there are no alignment requirements, write the socket address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if f.precision().is_none() && f.width().is_none() {\n             write!(f, \"{}:{}\", self.ip(), self.port())\n         } else {\n-            const IPV4_SOCKET_BUF_LEN: usize = (3 * 4)  // the segments\n-                + 3  // the separators\n-                + 1 + 5; // the port\n-            let mut buf = [0; IPV4_SOCKET_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n-\n-            // Unwrap is fine because writing to a sufficiently-sized\n-            // buffer is infallible\n-            write!(buf_slice, \"{}:{}\", self.ip(), self.port()).unwrap();\n-            let len = IPV4_SOCKET_BUF_LEN - buf_slice.len();\n-\n-            // This unsafe is OK because we know what is being written to the buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            f.pad(buf)\n+            const LONGEST_IPV4_SOCKET_ADDR: &str = \"255.255.255.255:65536\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_SOCKET_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv4 socket address, so this should never fail.\n+            write!(buf, \"{}:{}\", self.ip(), self.port()).unwrap();\n+\n+            f.pad(buf.as_str())\n         }\n     }\n }\n@@ -649,35 +644,26 @@ impl fmt::Debug for SocketAddrV4 {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddrV6 {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Fast path: if there's no alignment stuff, write to the output\n-        // buffer directly\n+        // If there are no alignment requirements, write the socket address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if f.precision().is_none() && f.width().is_none() {\n             match self.scope_id() {\n                 0 => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n                 scope_id => write!(f, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n             }\n         } else {\n-            const IPV6_SOCKET_BUF_LEN: usize = (4 * 8)  // The address\n-            + 7  // The colon separators\n-            + 2  // The brackets\n-            + 1 + 10 // The scope id\n-            + 1 + 5; // The port\n-\n-            let mut buf = [0; IPV6_SOCKET_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n+            const LONGEST_IPV6_SOCKET_ADDR: &str =\n+                \"[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%4294967296]:65536\";\n \n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_SOCKET_ADDR.len() }>::new();\n             match self.scope_id() {\n-                0 => write!(buf_slice, \"[{}]:{}\", self.ip(), self.port()),\n-                scope_id => write!(buf_slice, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n+                0 => write!(buf, \"[{}]:{}\", self.ip(), self.port()),\n+                scope_id => write!(buf, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n             }\n-            // Unwrap is fine because writing to a sufficiently-sized\n-            // buffer is infallible\n+            // Buffer is long enough for the longest possible IPv6 socket address, so this should never fail.\n             .unwrap();\n-            let len = IPV6_SOCKET_BUF_LEN - buf_slice.len();\n \n-            // This unsafe is OK because we know what is being written to the buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            f.pad(buf)\n+            f.pad(buf.as_str())\n         }\n     }\n }", "previous_filename": "library/std/src/net/addr.rs"}, {"sha": "15211f81981ba1f6b5d1e24a06276c3a43eaa65e", "filename": "library/std/src/net/socket_addr/tests.rs", "status": "renamed", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr%2Ftests.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -51,6 +51,75 @@ fn to_socket_addr_string() {\n     // s has been moved into the tsa call\n }\n \n+#[test]\n+fn ipv4_socket_addr_to_string() {\n+    // Shortest possible IPv4 length.\n+    assert_eq!(SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0).to_string(), \"0.0.0.0:0\");\n+\n+    // Longest possible IPv4 length.\n+    assert_eq!(\n+        SocketAddrV4::new(Ipv4Addr::new(255, 255, 255, 255), u16::MAX).to_string(),\n+        \"255.255.255.255:65535\"\n+    );\n+\n+    // Test padding.\n+    assert_eq!(\n+        &format!(\"{:16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        \"1.1.1.1:53      \"\n+    );\n+    assert_eq!(\n+        &format!(\"{:>16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        \"      1.1.1.1:53\"\n+    );\n+}\n+\n+#[test]\n+fn ipv6_socket_addr_to_string() {\n+    // IPv4-mapped address.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280), 8080, 0, 0)\n+            .to_string(),\n+        \"[::ffff:192.0.2.128]:8080\"\n+    );\n+\n+    // IPv4-compatible address.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280), 8080, 0, 0).to_string(),\n+        \"[::192.0.2.128]:8080\"\n+    );\n+\n+    // IPv6 address with no zero segments.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15), 80, 0, 0).to_string(),\n+        \"[8:9:a:b:c:d:e:f]:80\"\n+    );\n+\n+    // Shortest possible IPv6 length.\n+    assert_eq!(SocketAddrV6::new(Ipv6Addr::UNSPECIFIED, 0, 0, 0).to_string(), \"[::]:0\");\n+\n+    // Longest possible IPv6 length.\n+    assert_eq!(\n+        SocketAddrV6::new(\n+            Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888),\n+            u16::MAX,\n+            u32::MAX,\n+            u32::MAX,\n+        )\n+        .to_string(),\n+        \"[1111:2222:3333:4444:5555:6666:7777:8888%4294967295]:65535\"\n+    );\n+\n+    // Test padding.\n+    assert_eq!(\n+        &format!(\"{:22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        \"[1:2:3:4:5:6:7:8]:9   \"\n+    );\n+    assert_eq!(\n+        &format!(\"{:>22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        \"   [1:2:3:4:5:6:7:8]:9\"\n+    );\n+}\n+\n #[test]\n fn bind_udp_socket_bad() {\n     // rust-lang/rust#53957: This is a regression test for a parsing problem", "previous_filename": "library/std/src/net/addr/tests.rs"}, {"sha": "c89784065b8be775d4ba7fc6fd967dc0b77d9f2d", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 60, "deletions": 26, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -2,17 +2,17 @@ use super::REDUNDANT_PATTERN_MATCHING;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::ty::{is_type_diagnostic_item, needs_ordered_drop};\n use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n-use clippy_utils::{higher, is_lang_ctor, is_trait_method, match_def_path, paths};\n+use clippy_utils::{higher, is_lang_ctor, is_trait_method};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, PollPending};\n+use rustc_hir::LangItem::{self, OptionSome, OptionNone, PollPending, PollReady, ResultOk, ResultErr};\n use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n-use rustc_span::sym;\n+use rustc_span::{sym, Symbol};\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n@@ -75,9 +75,9 @@ fn find_sugg_for_if_let<'tcx>(\n                     (\"is_some()\", op_ty)\n                 } else if Some(id) == lang_items.poll_ready_variant() {\n                     (\"is_ready()\", op_ty)\n-                } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n+                } else if is_pat_variant(cx, check_pat, qpath, Item::Diag(sym::IpAddr, sym!(V4))) {\n                     (\"is_ipv4()\", op_ty)\n-                } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n+                } else if is_pat_variant(cx, check_pat, qpath, Item::Diag(sym::IpAddr, sym!(V6))) {\n                     (\"is_ipv6()\", op_ty)\n                 } else {\n                     return;\n@@ -187,8 +187,8 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                         arms,\n                         path_left,\n                         path_right,\n-                        &paths::RESULT_OK,\n-                        &paths::RESULT_ERR,\n+                        Item::Lang(ResultOk),\n+                        Item::Lang(ResultErr),\n                         \"is_ok()\",\n                         \"is_err()\",\n                     )\n@@ -198,8 +198,8 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                             arms,\n                             path_left,\n                             path_right,\n-                            &paths::IPADDR_V4,\n-                            &paths::IPADDR_V6,\n+                            Item::Diag(sym::IpAddr, sym!(V4)),\n+                            Item::Diag(sym::IpAddr, sym!(V6)),\n                             \"is_ipv4()\",\n                             \"is_ipv6()\",\n                         )\n@@ -213,13 +213,14 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                 if patterns.len() == 1 =>\n             {\n                 if let PatKind::Wild = patterns[0].kind {\n+\n                     find_good_method_for_match(\n                         cx,\n                         arms,\n                         path_left,\n                         path_right,\n-                        &paths::OPTION_SOME,\n-                        &paths::OPTION_NONE,\n+                        Item::Lang(OptionSome),\n+                        Item::Lang(OptionNone),\n                         \"is_some()\",\n                         \"is_none()\",\n                     )\n@@ -229,8 +230,8 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                             arms,\n                             path_left,\n                             path_right,\n-                            &paths::POLL_READY,\n-                            &paths::POLL_PENDING,\n+                            Item::Lang(PollReady),\n+                            Item::Lang(PollPending),\n                             \"is_ready()\",\n                             \"is_pending()\",\n                         )\n@@ -266,28 +267,61 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n     }\n }\n \n+#[derive(Clone, Copy)]\n+enum Item {\n+  Lang(LangItem),\n+  Diag(Symbol, Symbol),\n+}\n+\n+fn is_pat_variant(cx: &LateContext<'_>, pat: &Pat<'_>, path: &QPath<'_>, expected_item: Item) -> bool {\n+    let Some(id) = cx.typeck_results().qpath_res(path, pat.hir_id).opt_def_id() else { return false };\n+\n+    match expected_item {\n+        Item::Lang(expected_lang_item) => {\n+            let expected_id = cx.tcx.lang_items().require(expected_lang_item).unwrap();\n+            cx.tcx.parent(id) == expected_id\n+        },\n+        Item::Diag(expected_ty, expected_variant) => {\n+            let ty = cx.typeck_results().pat_ty(pat);\n+\n+            if is_type_diagnostic_item(cx, ty, expected_ty) {\n+                let variant = ty.ty_adt_def()\n+                    .expect(\"struct pattern type is not an ADT\")\n+                    .variant_of_res(cx.qpath_res(path, pat.hir_id));\n+\n+                return variant.name == expected_variant\n+            }\n+\n+            false\n+        }\n+    }\n+}\n+\n #[expect(clippy::too_many_arguments)]\n fn find_good_method_for_match<'a>(\n     cx: &LateContext<'_>,\n     arms: &[Arm<'_>],\n     path_left: &QPath<'_>,\n     path_right: &QPath<'_>,\n-    expected_left: &[&str],\n-    expected_right: &[&str],\n+    expected_item_left: Item,\n+    expected_item_right: Item,\n     should_be_left: &'a str,\n     should_be_right: &'a str,\n ) -> Option<&'a str> {\n-    let left_id = cx\n-        .typeck_results()\n-        .qpath_res(path_left, arms[0].pat.hir_id)\n-        .opt_def_id()?;\n-    let right_id = cx\n-        .typeck_results()\n-        .qpath_res(path_right, arms[1].pat.hir_id)\n-        .opt_def_id()?;\n-    let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+    let pat_left = arms[0].pat;\n+    let pat_right = arms[1].pat;\n+\n+    let body_node_pair = if (\n+        is_pat_variant(cx, pat_left, path_left, expected_item_left)\n+    ) && (\n+        is_pat_variant(cx, pat_right, path_right, expected_item_right)\n+    ) {\n         (&arms[0].body.kind, &arms[1].body.kind)\n-    } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+    } else if (\n+        is_pat_variant(cx, pat_left, path_left, expected_item_right)\n+    ) && (\n+        is_pat_variant(cx, pat_right, path_right, expected_item_left)\n+    ) {\n         (&arms[1].body.kind, &arms[0].body.kind)\n     } else {\n         return None;"}, {"sha": "07170e2df12ab2be340c0d5affdc5d4a88641a66", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c81575657c9591d07c12778fe74c326e5ac76558/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81575657c9591d07c12778fe74c326e5ac76558/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=c81575657c9591d07c12778fe74c326e5ac76558", "patch": "@@ -66,8 +66,6 @@ pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n-pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n-pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];"}]}