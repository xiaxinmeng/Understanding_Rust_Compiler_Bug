{"sha": "1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjOTMwNDhiYzllM2VhMjc1YWY0NWQzZGU5Y2U1ZmM5ZDI4OGY1ZjI=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-03-28T19:17:42Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-03-28T19:17:42Z"}, "message": "Merge pull request #801 from mcarton/transmute\n\nLint transmute from ptr to ref", "tree": {"sha": "dfb27cf1cb90fb4ee848eb6d8289c40c9e831070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfb27cf1cb90fb4ee848eb6d8289c40c9e831070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "html_url": "https://github.com/rust-lang/rust/commit/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae24929cd65ab2ab50a6ae7bba2a03e93e573c84", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae24929cd65ab2ab50a6ae7bba2a03e93e573c84", "html_url": "https://github.com/rust-lang/rust/commit/ae24929cd65ab2ab50a6ae7bba2a03e93e573c84"}, {"sha": "e7158dc8f174126780ac6caa864bccede5dda262", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7158dc8f174126780ac6caa864bccede5dda262", "html_url": "https://github.com/rust-lang/rust/commit/e7158dc8f174126780ac6caa864bccede5dda262"}], "stats": {"total": 195, "additions": 137, "deletions": 58}, "files": [{"sha": "95ba6b08539a1306e444459b01a32a143f8e85a8", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "patch": "@@ -14,7 +14,7 @@ Table of contents:\n * [License](#license)\n \n ##Lints\n-There are 135 lints included in this crate:\n+There are 136 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -133,6 +133,7 @@ name\n [temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries\n [too_many_arguments](https://github.com/Manishearth/rust-clippy/wiki#too_many_arguments)                             | warn    | functions with too many arguments\n [toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n+[transmute_ptr_to_ref](https://github.com/Manishearth/rust-clippy/wiki#transmute_ptr_to_ref)                         | warn    | transmutes from a pointer to a reference type\n [trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                       | warn    | finds trivial regular expressions in `Regex::new(_)` invocations\n [type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                                   | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n [unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                                   | allow   | using a unicode literal not in NFC normal form (see http://www.unicode.org/reports/tr15/ for further information)"}, {"sha": "7d24b2c89248289d9fb39e860ef3cebe3b60cbdc", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "patch": "@@ -195,8 +195,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box no_effect::NoEffectPass);\n     reg.register_late_lint_pass(box map_clone::MapClonePass);\n     reg.register_late_lint_pass(box temporary_assignment::TemporaryAssignmentPass);\n-    reg.register_late_lint_pass(box transmute::CrosspointerTransmute);\n-    reg.register_late_lint_pass(box transmute::UselessTransmute);\n+    reg.register_late_lint_pass(box transmute::Transmute);\n     reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n     reg.register_late_lint_pass(box escape::EscapePass);\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n@@ -352,6 +351,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         swap::MANUAL_SWAP,\n         temporary_assignment::TEMPORARY_ASSIGNMENT,\n         transmute::CROSSPOINTER_TRANSMUTE,\n+        transmute::TRANSMUTE_PTR_TO_REF,\n         transmute::USELESS_TRANSMUTE,\n         types::ABSURD_EXTREME_COMPARISONS,\n         types::BOX_VEC,"}, {"sha": "5a787ba6dbaf1e08c14e604274f37b4c91056b9e", "filename": "src/misc.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "patch": "@@ -312,7 +312,7 @@ impl LateLintPass for ModuloOne {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n             if let Spanned {node: BinOp_::BiRem, ..} = *cmp {\n                 if is_integer_literal(right, 1) {\n-                    cx.span_lint(MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n             }\n         }\n@@ -347,11 +347,12 @@ impl LateLintPass for PatternPass {\n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n         if let PatKind::Ident(_, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n-                cx.span_lint(REDUNDANT_PATTERN,\n-                             pat.span,\n-                             &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                      ident.node.name,\n-                                      ident.node.name));\n+                span_lint(cx,\n+                          REDUNDANT_PATTERN,\n+                          pat.span,\n+                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n+                                   ident.node.name,\n+                                   ident.node.name));\n             }\n         }\n     }\n@@ -408,10 +409,11 @@ impl LateLintPass for UsedUnderscoreBinding {\n             _ => false,\n         };\n         if needs_lint {\n-            cx.span_lint(USED_UNDERSCORE_BINDING,\n-                         expr.span,\n-                         \"used binding which is prefixed with an underscore. A leading underscore signals that a \\\n-                          binding will not be used.\");\n+            span_lint(cx,\n+                      USED_UNDERSCORE_BINDING,\n+                      expr.span,\n+                      \"used binding which is prefixed with an underscore. A leading underscore signals that a \\\n+                       binding will not be used.\");\n         }\n     }\n }"}, {"sha": "23bd3d1103cef27bb60d9fc7a11c43dbff3ee1f6", "filename": "src/ranges.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, snippet, unsugar_range, UnsugaredRange};\n+use utils::{is_integer_literal, match_type, snippet, span_lint, unsugar_range, UnsugaredRange};\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -41,10 +41,11 @@ impl LateLintPass for StepByZero {\n             // Range with step_by(0).\n             if name.as_str() == \"step_by\" && args.len() == 2 && is_range(cx, &args[0]) &&\n                is_integer_literal(&args[1], 0) {\n-                cx.span_lint(RANGE_STEP_BY_ZERO,\n-                             expr.span,\n-                             \"Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` \\\n-                              instead\")\n+                span_lint(cx,\n+                          RANGE_STEP_BY_ZERO,\n+                          expr.span,\n+                          \"Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` \\\n+                           instead\");\n             } else if name.as_str() == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n@@ -64,9 +65,11 @@ impl LateLintPass for StepByZero {\n                         let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n                         iter_path == len_path\n                      ], {\n-                        cx.span_lint(RANGE_ZIP_WITH_LEN, expr.span,\n-                                     &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                              snippet(cx, iter_args[0].span, \"_\")));\n+                        span_lint(cx,\n+                                  RANGE_ZIP_WITH_LEN,\n+                                  expr.span,\n+                                  &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                           snippet(cx, iter_args[0].span, \"_\")));\n                     }\n                 }\n             }"}, {"sha": "ef049ba4a6dbd176abb5e215ea43a6d2f9c09e47", "filename": "src/transmute.rs", "status": "modified", "additions": 71, "deletions": 37, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/src%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftransmute.rs?ref=1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "patch": "@@ -1,9 +1,9 @@\n use rustc::lint::*;\n+use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n+use rustc::ty;\n use rustc_front::hir::*;\n-use rustc::ty::TyS;\n-use rustc::ty::TypeVariants::TyRawPtr;\n-use utils;\n use utils::TRANSMUTE_PATH;\n+use utils::{match_def_path, snippet_opt, span_lint, span_lint_and_then};\n \n /// **What it does:** This lint checks for transmutes to the original type of the object.\n ///\n@@ -31,72 +31,106 @@ declare_lint! {\n     \"transmutes that have to or from types that are a pointer to the other\"\n }\n \n-pub struct UselessTransmute;\n+/// **What it does:*** This lint checks for transmutes from a pointer to a reference.\n+///\n+/// **Why is this bad?** This can always be rewritten with `&` and `*`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let _: &T = std::mem::transmute(p); // where p: *const T\n+/// // can be written:\n+/// let _: &T = &*p;\n+/// ```\n+declare_lint! {\n+    pub TRANSMUTE_PTR_TO_REF,\n+    Warn,\n+    \"transmutes from a pointer to a reference type\"\n+}\n+\n+pub struct Transmute;\n \n-impl LintPass for UselessTransmute {\n+impl LintPass for Transmute {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(USELESS_TRANSMUTE)\n+        lint_array! [\n+            CROSSPOINTER_TRANSMUTE,\n+            TRANSMUTE_PTR_TO_REF,\n+            USELESS_TRANSMUTE\n+        ]\n     }\n }\n \n-impl LateLintPass for UselessTransmute {\n+impl LateLintPass for Transmute {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(None, _) = path_expr.node {\n                 let def_id = cx.tcx.def_map.borrow()[&path_expr.id].def_id();\n \n-                if utils::match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n+                if match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n                     let from_ty = cx.tcx.expr_ty(&args[0]);\n                     let to_ty = cx.tcx.expr_ty(e);\n \n                     if from_ty == to_ty {\n-                        cx.span_lint(USELESS_TRANSMUTE,\n-                                     e.span,\n-                                     &format!(\"transmute from a type (`{}`) to itself\", from_ty));\n+                        span_lint(cx,\n+                                  USELESS_TRANSMUTE,\n+                                  e.span,\n+                                  &format!(\"transmute from a type (`{}`) to itself\", from_ty));\n+                    } else if is_ptr_to(to_ty, from_ty) {\n+                        span_lint(cx,\n+                                  CROSSPOINTER_TRANSMUTE,\n+                                  e.span,\n+                                  &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty));\n+                    } else if is_ptr_to(from_ty, to_ty) {\n+                        span_lint(cx,\n+                                  CROSSPOINTER_TRANSMUTE,\n+                                  e.span,\n+                                  &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\", from_ty, to_ty));\n+                    } else {\n+                        check_ptr_to_ref(cx, from_ty, to_ty, e, &args[0]);\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-pub struct CrosspointerTransmute;\n-\n-impl LintPass for CrosspointerTransmute {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(CROSSPOINTER_TRANSMUTE)\n-    }\n-}\n-\n-fn is_ptr_to(from: &TyS, to: &TyS) -> bool {\n+fn is_ptr_to(from: ty::Ty, to: ty::Ty) -> bool {\n     if let TyRawPtr(from_ptr) = from.sty {\n         from_ptr.ty == to\n     } else {\n         false\n     }\n }\n \n-impl LateLintPass for CrosspointerTransmute {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, _) = path_expr.node {\n-                let def_id = cx.tcx.def_map.borrow()[&path_expr.id].def_id();\n+fn check_ptr_to_ref<'tcx>(cx: &LateContext,\n+                          from_ty: ty::Ty<'tcx>,\n+                          to_ty: ty::Ty<'tcx>,\n+                          e: &Expr, arg: &Expr) {\n+    if let TyRawPtr(ref from_pty) = from_ty.sty {\n+        if let TyRef(_, ref to_rty) = to_ty.sty {\n+            let mess = format!(\"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n+                               from_ty,\n+                               to_ty);\n+            span_lint_and_then(cx, TRANSMUTE_PTR_TO_REF, e.span, &mess, |db| {\n+                if let Some(arg) = snippet_opt(cx, arg.span) {\n+                    let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n+                        (\"&mut *\", \"*mut\")\n+                    } else {\n+                        (\"&*\", \"*const\")\n+                    };\n \n-                if utils::match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n-                    let from_ty = cx.tcx.expr_ty(&args[0]);\n-                    let to_ty = cx.tcx.expr_ty(e);\n \n-                    if is_ptr_to(to_ty, from_ty) {\n-                        cx.span_lint(CROSSPOINTER_TRANSMUTE,\n-                                     e.span,\n-                                     &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty));\n-                    } else if is_ptr_to(from_ty, to_ty) {\n-                        cx.span_lint(CROSSPOINTER_TRANSMUTE,\n-                                     e.span,\n-                                     &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\", from_ty, to_ty));\n+                    let sugg = if from_pty.ty == to_rty.ty {\n+                        format!(\"{}{}\", deref, arg)\n                     }\n+                    else {\n+                        format!(\"{}({} as {} {})\", deref, arg, cast, to_rty.ty)\n+                    };\n+\n+                    db.span_suggestion(e.span, \"try\", sugg);\n                 }\n-            }\n+            });\n         }\n     }\n }"}, {"sha": "5bae2c726438cd5a1d3dc9109c3edb4bd9eb2cd3", "filename": "tests/compile-fail/transmute.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/tests%2Fcompile-fail%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2/tests%2Fcompile-fail%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute.rs?ref=1c93048bc9e3ea275af45d3de9ce5fc9d288f5f2", "patch": "@@ -19,6 +19,45 @@ unsafe fn _generic<'a, T, U: 'a>(t: &'a T) {\n     let _: &'a U = core::intrinsics::transmute(t);\n }\n \n+#[deny(transmute_ptr_to_ref)]\n+unsafe fn _ptr_to_ref<T, U>(p: *const T, m: *mut T, o: *const U, om: *mut U) {\n+    let _: &T = std::mem::transmute(p);\n+    //~^ ERROR transmute from a pointer type (`*const T`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*p;\n+    let _: &T = &*p;\n+\n+    let _: &mut T = std::mem::transmute(m);\n+    //~^ ERROR transmute from a pointer type (`*mut T`) to a reference type (`&mut T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &mut *m;\n+    let _: &mut T = &mut *m;\n+\n+    let _: &T = std::mem::transmute(m);\n+    //~^ ERROR transmute from a pointer type (`*mut T`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*m;\n+    let _: &T = &*m;\n+\n+    let _: &T = std::mem::transmute(o);\n+    //~^ ERROR transmute from a pointer type (`*const U`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*(o as *const T);\n+    let _: &T = &*(o as *const T);\n+\n+    let _: &mut T = std::mem::transmute(om);\n+    //~^ ERROR transmute from a pointer type (`*mut U`) to a reference type (`&mut T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &mut *(om as *mut T);\n+    let _: &mut T = &mut *(om as *mut T);\n+\n+    let _: &T = std::mem::transmute(om);\n+    //~^ ERROR transmute from a pointer type (`*mut U`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*(om as *const T);\n+    let _: &T = &*(om as *const T);\n+}\n+\n #[deny(useless_transmute)]\n fn useless() {\n     unsafe {"}]}