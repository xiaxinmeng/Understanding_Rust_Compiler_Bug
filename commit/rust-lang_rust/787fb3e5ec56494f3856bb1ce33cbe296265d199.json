{"sha": "787fb3e5ec56494f3856bb1ce33cbe296265d199", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4N2ZiM2U1ZWM1NjQ5NGYzODU2YmIxY2UzM2NiZTI5NjI2NWQxOTk=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-21T12:21:58Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-21T13:01:17Z"}, "message": "Add HIR for where clauses & ignore impls with where clauses in trait resolution\n\nThis prevents any `impl<T> Trait for T where ...` from being treated as a\nblanket impl while we don't handle where clauses yet.", "tree": {"sha": "1fdbd68757a878026c560cc133ddd3cc2672295e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fdbd68757a878026c560cc133ddd3cc2672295e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/787fb3e5ec56494f3856bb1ce33cbe296265d199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/787fb3e5ec56494f3856bb1ce33cbe296265d199", "html_url": "https://github.com/rust-lang/rust/commit/787fb3e5ec56494f3856bb1ce33cbe296265d199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/787fb3e5ec56494f3856bb1ce33cbe296265d199/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f94119171658523bc854e8c8b4b6da28378b468", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f94119171658523bc854e8c8b4b6da28378b468", "html_url": "https://github.com/rust-lang/rust/commit/7f94119171658523bc854e8c8b4b6da28378b468"}], "stats": {"total": 68, "additions": 63, "deletions": 5}, "files": [{"sha": "1c71e21ea3c008311158d9b1b22802d88e208dd9", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/787fb3e5ec56494f3856bb1ce33cbe296265d199/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787fb3e5ec56494f3856bb1ce33cbe296265d199/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=787fb3e5ec56494f3856bb1ce33cbe296265d199", "patch": "@@ -5,11 +5,11 @@\n \n use std::sync::Arc;\n \n-use ra_syntax::ast::{self, NameOwner, TypeParamsOwner};\n+use ra_syntax::ast::{self, NameOwner, TypeParamsOwner, TypeBoundsOwner};\n \n use crate::{\n     db::DefDatabase,\n-    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container\n+    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n@@ -25,6 +25,15 @@ pub struct GenericParam {\n pub struct GenericParams {\n     pub(crate) parent_params: Option<Arc<GenericParams>>,\n     pub(crate) params: Vec<GenericParam>,\n+    pub(crate) where_predicates: Vec<WherePredicate>,\n+}\n+\n+/// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n+/// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct WherePredicate {\n+    type_ref: TypeRef,\n+    trait_ref: Path,\n }\n \n // FIXME: consts can have type parameters from their parents (i.e. associated consts of traits)\n@@ -73,6 +82,9 @@ impl GenericParams {\n         if let Some(params) = node.type_param_list() {\n             self.fill_params(params, start)\n         }\n+        if let Some(where_clause) = node.where_clause() {\n+            self.fill_where_predicates(where_clause);\n+        }\n     }\n \n     fn fill_params(&mut self, params: &ast::TypeParamList, start: u32) {\n@@ -83,6 +95,32 @@ impl GenericParams {\n         }\n     }\n \n+    fn fill_where_predicates(&mut self, where_clause: &ast::WhereClause) {\n+        for pred in where_clause.predicates() {\n+            let type_ref = match pred.type_ref() {\n+                Some(type_ref) => type_ref,\n+                None => continue,\n+            };\n+            for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n+                let path = bound\n+                    .type_ref()\n+                    .and_then(|tr| match tr.kind() {\n+                        ast::TypeRefKind::PathType(path) => path.path(),\n+                        _ => None,\n+                    })\n+                    .and_then(Path::from_ast);\n+                let path = match path {\n+                    Some(p) => p,\n+                    None => continue,\n+                };\n+                self.where_predicates.push(WherePredicate {\n+                    type_ref: TypeRef::from_ast(type_ref),\n+                    trait_ref: path,\n+                });\n+            }\n+        }\n+    }\n+\n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n         self.params.iter().find(|p| &p.name == name)\n     }"}, {"sha": "a4c99528d01fb613c9f604721745667269a1b13d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/787fb3e5ec56494f3856bb1ce33cbe296265d199/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787fb3e5ec56494f3856bb1ce33cbe296265d199/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=787fb3e5ec56494f3856bb1ce33cbe296265d199", "patch": "@@ -2477,6 +2477,23 @@ fn test() { (&S).foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn method_resolution_where_clause_not_met() {\n+    // The blanket impl shouldn't apply because we can't prove S: Clone\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(self) -> i8 { 0 } }\n+impl<T> Trait for T where T: Clone { fn foo(self) -> u128 { 0 } }\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id);\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "06f4838997072cd39bdd7c7f7db33833b13d2009", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/787fb3e5ec56494f3856bb1ce33cbe296265d199/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787fb3e5ec56494f3856bb1ce33cbe296265d199/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=787fb3e5ec56494f3856bb1ce33cbe296265d199", "patch": "@@ -1,8 +1,8 @@\n //! Stuff that will probably mostly replaced by Chalk.\n use std::collections::HashMap;\n \n-use crate::db::HirDatabase;\n-use super::{ TraitRef, Substs, infer::{ TypeVarId, InferTy}, Ty};\n+use crate::{db::HirDatabase, generics::HasGenericParams};\n+use super::{TraitRef, Substs, infer::{TypeVarId, InferTy}, Ty};\n \n // Copied (and simplified) from Chalk\n \n@@ -59,7 +59,10 @@ pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> Option<S\n         None => return None,\n     };\n     let crate_impl_blocks = db.impls_in_crate(krate);\n-    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    let mut impl_blocks = crate_impl_blocks\n+        .lookup_impl_blocks_for_trait(&trait_ref.trait_)\n+        // we don't handle where clauses at all, waiting for Chalk for that\n+        .filter(|impl_block| impl_block.generic_params(db).where_predicates.is_empty());\n     impl_blocks\n         .find_map(|impl_block| unify_trait_refs(&trait_ref, &impl_block.target_trait_ref(db)?))\n }"}]}