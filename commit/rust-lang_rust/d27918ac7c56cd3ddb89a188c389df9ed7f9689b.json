{"sha": "d27918ac7c56cd3ddb89a188c389df9ed7f9689b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNzkxOGFjN2M1NmNkM2RkYjg5YTE4OGMzODlkZjllZDdmOTY4OWI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-07-21T05:10:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-21T16:54:55Z"}, "message": "Restructure test harness\n\nWe now build up a set of modules that reexport everything the test\nframework needs, instead of turning off privacy.", "tree": {"sha": "06eb39da272d6de03cb2e1845497c1df2748a694", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06eb39da272d6de03cb2e1845497c1df2748a694"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d27918ac7c56cd3ddb89a188c389df9ed7f9689b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d27918ac7c56cd3ddb89a188c389df9ed7f9689b", "html_url": "https://github.com/rust-lang/rust/commit/d27918ac7c56cd3ddb89a188c389df9ed7f9689b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d27918ac7c56cd3ddb89a188c389df9ed7f9689b/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "456884b7a0eb90038d915d8bc251a725451d284b", "url": "https://api.github.com/repos/rust-lang/rust/commits/456884b7a0eb90038d915d8bc251a725451d284b", "html_url": "https://github.com/rust-lang/rust/commit/456884b7a0eb90038d915d8bc251a725451d284b"}], "stats": {"total": 85, "additions": 53, "deletions": 32}, "files": [{"sha": "3e6b8a92d2d63953949d20cd4107d33d48d7cef1", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 53, "deletions": 32, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d27918ac7c56cd3ddb89a188c389df9ed7f9689b/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27918ac7c56cd3ddb89a188c389df9ed7f9689b/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=d27918ac7c56cd3ddb89a188c389df9ed7f9689b", "patch": "@@ -18,13 +18,15 @@ use front::config;\n \n use std::gc::{Gc, GC};\n use std::slice;\n+use std::mem;\n use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n+use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::fold::Folder;\n use syntax::fold;\n@@ -46,8 +48,10 @@ struct Test {\n struct TestCtxt<'a> {\n     sess: &'a Session,\n     path: Vec<ast::Ident>,\n+    reexports: Vec<Vec<ast::Ident>>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n+    reexport_mod_ident: ast::Ident,\n     is_test_crate: bool,\n     config: ast::CrateConfig,\n }\n@@ -107,25 +111,35 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                         should_fail: should_fail(i)\n                     };\n                     self.cx.testfns.push(test);\n+                    self.cx.reexports.push(self.cx.path.clone());\n                     // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n             }\n         }\n \n-        let res = fold::noop_fold_item(&*i, self);\n+        // We don't want to recurse into anything other than mods, since\n+        // mods or tests inside of functions will break things\n+        let res = match i.node {\n+            ast::ItemMod(..) => fold::noop_fold_item(&*i, self),\n+            _ => SmallVector::one(i),\n+        };\n         self.cx.path.pop();\n         res\n     }\n \n     fn fold_mod(&mut self, m: &ast::Mod) -> ast::Mod {\n+        let reexports = mem::replace(&mut self.cx.reexports, Vec::new());\n+        let mut mod_folded = fold::noop_fold_mod(m, self);\n+        let reexports = mem::replace(&mut self.cx.reexports, reexports);\n+\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n         fn nomain(item: Gc<ast::Item>) -> Gc<ast::Item> {\n             box(GC) ast::Item {\n                 attrs: item.attrs.iter().filter_map(|attr| {\n-                    if !attr.name().equiv(&(\"main\")) {\n+                    if !attr.check_name(\"main\") {\n                         Some(*attr)\n                     } else {\n                         None\n@@ -135,18 +149,37 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             }\n         }\n \n-        let mod_nomain = ast::Mod {\n-            inner: m.inner,\n-            view_items: m.view_items.clone(),\n-            items: m.items.iter().map(|i| nomain(*i)).collect(),\n-        };\n+        for i in mod_folded.items.mut_iter() {\n+            *i = nomain(*i);\n+        }\n+        mod_folded.items.push(mk_reexport_mod(&mut self.cx, reexports));\n+        self.cx.reexports.push(self.cx.path.clone());\n+\n+        mod_folded\n+    }\n+}\n \n-        fold::noop_fold_mod(&mod_nomain, self)\n+fn mk_reexport_mod(cx: &mut TestCtxt, reexports: Vec<Vec<ast::Ident>>)\n+                   -> Gc<ast::Item> {\n+    let view_items = reexports.move_iter().map(|r| {\n+        cx.ext_cx.view_use_simple(DUMMY_SP, ast::Public, cx.ext_cx.path(DUMMY_SP, r))\n+    }).collect();\n+    let reexport_mod = ast::Mod {\n+        inner: DUMMY_SP,\n+        view_items: view_items,\n+        items: Vec::new(),\n+    };\n+    box(GC) ast::Item {\n+        ident: cx.reexport_mod_ident.clone(),\n+        attrs: Vec::new(),\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::ItemMod(reexport_mod),\n+        vis: ast::Public,\n+        span: DUMMY_SP,\n     }\n }\n \n-fn generate_test_harness(sess: &Session, krate: ast::Crate)\n-                         -> ast::Crate {\n+fn generate_test_harness(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n@@ -155,7 +188,9 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate)\n                                  crate_name: \"test\".to_string(),\n                              }),\n         path: Vec::new(),\n+        reexports: Vec::new(),\n         testfns: Vec::new(),\n+        reexport_mod_ident: token::str_to_ident(\"__test_reexports\"),\n         is_test_crate: is_test_crate(&krate),\n         config: krate.config.clone(),\n     };\n@@ -170,7 +205,7 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate)\n     });\n \n     let mut fold = TestHarnessGenerator {\n-        cx: cx\n+        cx: cx,\n     };\n     let res = fold.fold_crate(krate);\n     fold.cx.ext_cx.bt_pop();\n@@ -274,7 +309,6 @@ fn add_test_module(cx: &TestCtxt, m: &ast::Mod) -> ast::Mod {\n We're going to be building a module that looks more or less like:\n \n mod __test {\n-  #![!resolve_unexported]\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n     test::test_main_static(::os::args().as_slice(), tests)\n@@ -331,15 +365,9 @@ fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n     };\n     let item_ = ast::ItemMod(testmod);\n \n-    // This attribute tells resolve to let us call unexported functions\n-    let resolve_unexported_str = InternedString::new(\"!resolve_unexported\");\n-    let resolve_unexported_attr =\n-        attr::mk_attr_inner(attr::mk_attr_id(),\n-                            attr::mk_word_item(resolve_unexported_str));\n-\n     let item = ast::Item {\n         ident: token::str_to_ident(\"__test\"),\n-        attrs: vec!(resolve_unexported_attr),\n+        attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::Public,\n@@ -367,18 +395,6 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n-    ast::Path {\n-        span: DUMMY_SP,\n-        global: true,\n-        segments: ids.move_iter().map(|identifier| ast::PathSegment {\n-            identifier: identifier,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n-        }).collect()\n-    }\n-}\n-\n fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n@@ -430,7 +446,12 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n           span: span\n     };\n \n-    let fn_path = path_node_global(path);\n+    let mut visible_path = Vec::new();\n+    for ident in path.move_iter() {\n+        visible_path.push(cx.reexport_mod_ident.clone());\n+        visible_path.push(ident);\n+    }\n+    let fn_path = cx.ext_cx.path_global(DUMMY_SP, visible_path);\n \n     let fn_expr = box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}]}