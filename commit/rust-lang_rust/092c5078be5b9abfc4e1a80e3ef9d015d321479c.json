{"sha": "092c5078be5b9abfc4e1a80e3ef9d015d321479c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MmM1MDc4YmU1YjlhYmZjNGUxYTgwZTNlZjlkMDE1ZDMyMTQ3OWM=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-06T08:17:59Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-09T07:49:54Z"}, "message": "ast: make Name its own type", "tree": {"sha": "46b19fe160154e14c412e928e676daa809407913", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46b19fe160154e14c412e928e676daa809407913"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/092c5078be5b9abfc4e1a80e3ef9d015d321479c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/092c5078be5b9abfc4e1a80e3ef9d015d321479c", "html_url": "https://github.com/rust-lang/rust/commit/092c5078be5b9abfc4e1a80e3ef9d015d321479c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/092c5078be5b9abfc4e1a80e3ef9d015d321479c/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f512779554a436d11dd9ffde4c198da6241dfd58", "url": "https://api.github.com/repos/rust-lang/rust/commits/f512779554a436d11dd9ffde4c198da6241dfd58", "html_url": "https://github.com/rust-lang/rust/commit/f512779554a436d11dd9ffde4c198da6241dfd58"}], "stats": {"total": 255, "additions": 149, "deletions": 106}, "files": [{"sha": "ae401b9d6f15c969a0e748ba58d5b5e4b47aa2ee", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -1114,7 +1114,7 @@ impl UnusedMut {\n                 match mode {\n                     ast::BindByValue(ast::MutMutable) => {\n                         if !token::get_ident(ident).get().starts_with(\"_\") {\n-                            mutables.insert_or_update_with(ident.name as uint,\n+                            mutables.insert_or_update_with(ident.name.uint(),\n                                 vec!(id), |_, old| { old.push(id); });\n                         }\n                     }"}, {"sha": "cc41223688ee0b9eab8f8ff7f3c6caaff54d262d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -323,7 +323,7 @@ fn item_name(intr: &IdentInterner, item: ebml::Doc) -> ast::Ident {\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n         None => token::str_to_ident(string),\n-        Some(val) => ast::Ident::new(val as ast::Name),\n+        Some(val) => ast::Ident::new(val),\n     }\n }\n "}, {"sha": "ebfc45d22cee9da33124293ab4c0efb6c23197f5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -52,10 +52,7 @@ impl Ident {\n     pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: EMPTY_CTXT}}\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        unsafe {\n-            // FIXME #12938: can't use copy_lifetime since &str isn't a &T\n-            ::std::mem::transmute(token::get_ident(*self).get())\n-        }\n+        self.name.as_str()\n     }\n }\n \n@@ -109,7 +106,26 @@ pub static ILLEGAL_CTXT : SyntaxContext = 1;\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n-pub type Name = u32;\n+#[deriving(Eq, Ord, PartialEq, PartialOrd, Hash, Encodable, Decodable, Clone, Show)]\n+pub struct Name(pub u32);\n+\n+impl Name {\n+    pub fn as_str<'a>(&'a self) -> &'a str {\n+        unsafe {\n+            // FIXME #12938: can't use copy_lifetime since &str isn't a &T\n+            ::std::mem::transmute(token::get_name(*self).get())\n+        }\n+    }\n+\n+    pub fn uint(&self) -> uint {\n+        let Name(nm) = *self;\n+        nm as uint\n+    }\n+\n+    pub fn ident(&self) -> Ident {\n+        Ident { name: *self, ctxt: 0 }\n+    }\n+}\n \n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = u32;"}, {"sha": "9a5c7e86d21c6df035f0df0fa52f617eed43e8c8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -535,6 +535,9 @@ impl<'a> ExtCtxt<'a> {\n     pub fn ident_of(&self, st: &str) -> ast::Ident {\n         str_to_ident(st)\n     }\n+    pub fn name_of(&self, st: &str) -> ast::Name {\n+        token::intern(st)\n+    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,"}, {"sha": "7b29bbaef77eb2d4325b7a1b3e9f1ba3bff6db01", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -82,8 +82,8 @@ fn apply_rename_internal(id: Ident,\n                        to: Name,\n                        ctxt: SyntaxContext,\n                        table: &SCTable) -> SyntaxContext {\n-    let key = (ctxt,id,to);\n-    let new_ctxt = |_: &(SyntaxContext, Ident, Mrk)|\n+    let key = (ctxt, id, to);\n+    let new_ctxt = |_: &(SyntaxContext, Ident, Name)|\n                    idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt));\n \n     *table.rename_memo.borrow_mut().find_or_insert_with(key, new_ctxt)\n@@ -142,7 +142,7 @@ pub fn clear_tables() {\n }\n \n /// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut Vec<T> , val: T) -> u32 {\n+fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n     vec.push(val);\n     (vec.len() - 1) as u32\n }"}, {"sha": "696d62838ba799150a68a998929e8277099a9e8e", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -363,6 +363,15 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n                         vec!(e_str))\n }\n \n+// Lift a name to the expr that evaluates to that name\n+fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n+    let e_str = cx.expr_str(sp, token::get_ident(ident));\n+    cx.expr_method_call(sp,\n+                        cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+                        id_ext(\"name_of\"),\n+                        vec!(e_str))\n+}\n+\n fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n@@ -401,37 +410,37 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n         }\n \n         LIT_BYTE(i) => {\n-            let e_byte = mk_ident(cx, sp, i);\n+            let e_byte = mk_name(cx, sp, i.ident());\n \n             return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_BYTE\"), vec!(e_byte));\n         }\n \n         LIT_CHAR(i) => {\n-            let e_char = mk_ident(cx, sp, i);\n+            let e_char = mk_name(cx, sp, i.ident());\n \n             return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_CHAR\"), vec!(e_char));\n         }\n \n         LIT_INTEGER(i) => {\n-            let e_int = mk_ident(cx, sp, i);\n+            let e_int = mk_name(cx, sp, i.ident());\n             return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_INTEGER\"), vec!(e_int));\n         }\n \n         LIT_FLOAT(fident) => {\n-            let e_fident = mk_ident(cx, sp, fident);\n+            let e_fident = mk_name(cx, sp, fident.ident());\n             return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_FLOAT\"), vec!(e_fident));\n         }\n \n         LIT_STR(ident) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"LIT_STR\"),\n-                                vec!(mk_ident(cx, sp, ident)));\n+                                vec!(mk_name(cx, sp, ident.ident())));\n         }\n \n         LIT_STR_RAW(ident, n) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"LIT_STR_RAW\"),\n-                                vec!(mk_ident(cx, sp, ident), cx.expr_uint(sp, n)));\n+                                vec!(mk_name(cx, sp, ident.ident()), cx.expr_uint(sp, n)));\n         }\n \n         IDENT(ident, b) => {\n@@ -449,7 +458,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n         DOC_COMMENT(ident) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"DOC_COMMENT\"),\n-                                vec!(mk_ident(cx, sp, ident)));\n+                                vec!(mk_name(cx, sp, ident.ident())));\n         }\n \n         INTERPOLATED(_) => fail!(\"quote! with interpolated token\"),"}, {"sha": "55ad1b771231011d9c1168103af456be83fffcdb", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -43,7 +43,7 @@ impl<'a> ParserAttr for Parser<'a> {\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                     attr::mk_attr_id(),\n-                    self.id_to_interned_str(s),\n+                    self.id_to_interned_str(s.ident()),\n                     self.span.lo,\n                     self.span.hi\n                 );\n@@ -139,7 +139,7 @@ impl<'a> ParserAttr for Parser<'a> {\n                     let Span { lo, hi, .. } = self.span;\n                     self.bump();\n                     attr::mk_sugared_doc_attr(attr::mk_attr_id(),\n-                                              self.id_to_interned_str(s),\n+                                              self.id_to_interned_str(s.ident()),\n                                               lo,\n                                               hi)\n                 }"}, {"sha": "f462ab92383accac1ef413e1d7b7e32aebf9e668", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -216,18 +216,18 @@ impl<'a> StringReader<'a> {\n         self.with_str_from_to(start, self.last_pos, f)\n     }\n \n-    /// Create an Ident from a given offset to the current offset, each\n+    /// Create a Name from a given offset to the current offset, each\n     /// adjusted 1 towards each other (assumes that on either side there is a\n     /// single-byte delimiter).\n-    pub fn ident_from(&self, start: BytePos) -> ast::Ident {\n+    pub fn name_from(&self, start: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {} to {}\", start, self.last_pos);\n-        self.with_str_from(start, str_to_ident)\n+        self.with_str_from(start, token::intern)\n     }\n \n-    /// As ident_from, with an explicit endpoint.\n-    pub fn ident_from_to(&self, start: BytePos, end: BytePos) -> ast::Ident {\n+    /// As name_from, with an explicit endpoint.\n+    pub fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {} to {}\", start, end);\n-        self.with_str_from_to(start, end, str_to_ident)\n+        self.with_str_from_to(start, end, token::intern)\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -377,7 +377,7 @@ impl<'a> StringReader<'a> {\n                         return self.with_str_from(start_bpos, |string| {\n                             // but comments with only more \"/\"s are not\n                             let tok = if is_doc_comment(string) {\n-                                token::DOC_COMMENT(str_to_ident(string))\n+                                token::DOC_COMMENT(token::intern(string))\n                             } else {\n                                 token::COMMENT\n                             };\n@@ -421,7 +421,7 @@ impl<'a> StringReader<'a> {\n                     let start = self.last_pos;\n                     while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n                     return Some(TokenAndSpan {\n-                        tok: token::SHEBANG(self.ident_from(start)),\n+                        tok: token::SHEBANG(self.name_from(start)),\n                         sp: codemap::mk_sp(start, self.last_pos)\n                     });\n                 }\n@@ -500,7 +500,7 @@ impl<'a> StringReader<'a> {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n                 } else { string.into_maybe_owned() };\n-                token::DOC_COMMENT(str_to_ident(string.as_slice()))\n+                token::DOC_COMMENT(token::intern(string.as_slice()))\n             } else {\n                 token::COMMENT\n             };\n@@ -548,17 +548,17 @@ impl<'a> StringReader<'a> {\n                 }\n                 'u' | 'i' => {\n                     self.scan_int_suffix();\n-                    return token::LIT_INTEGER(self.ident_from(start_bpos));\n+                    return token::LIT_INTEGER(self.name_from(start_bpos));\n                 },\n                 'f' => {\n                     let last_pos = self.last_pos;\n                     self.scan_float_suffix();\n                     self.check_float_base(start_bpos, last_pos, base);\n-                    return token::LIT_FLOAT(self.ident_from(start_bpos));\n+                    return token::LIT_FLOAT(self.name_from(start_bpos));\n                 }\n                 _ => {\n                     // just a 0\n-                    return token::LIT_INTEGER(self.ident_from(start_bpos));\n+                    return token::LIT_INTEGER(self.name_from(start_bpos));\n                 }\n             }\n         } else if c.is_digit_radix(10) {\n@@ -571,7 +571,7 @@ impl<'a> StringReader<'a> {\n             self.err_span_(start_bpos, self.last_pos, \"no valid digits found for number\");\n             // eat any suffix\n             self.scan_int_suffix();\n-            return token::LIT_INTEGER(str_to_ident(\"0\"));\n+            return token::LIT_INTEGER(token::intern(\"0\"));\n         }\n \n         // might be a float, but don't be greedy if this is actually an\n@@ -589,25 +589,25 @@ impl<'a> StringReader<'a> {\n             }\n             let last_pos = self.last_pos;\n             self.check_float_base(start_bpos, last_pos, base);\n-            return token::LIT_FLOAT(self.ident_from(start_bpos));\n+            return token::LIT_FLOAT(self.name_from(start_bpos));\n         } else if self.curr_is('f') {\n             // or it might be an integer literal suffixed as a float\n             self.scan_float_suffix();\n             let last_pos = self.last_pos;\n             self.check_float_base(start_bpos, last_pos, base);\n-            return token::LIT_FLOAT(self.ident_from(start_bpos));\n+            return token::LIT_FLOAT(self.name_from(start_bpos));\n         } else {\n             // it might be a float if it has an exponent\n             if self.curr_is('e') || self.curr_is('E') {\n                 self.scan_float_exponent();\n                 self.scan_float_suffix();\n                 let last_pos = self.last_pos;\n                 self.check_float_base(start_bpos, last_pos, base);\n-                return token::LIT_FLOAT(self.ident_from(start_bpos));\n+                return token::LIT_FLOAT(self.name_from(start_bpos));\n             }\n             // but we certainly have an integer!\n             self.scan_int_suffix();\n-            return token::LIT_INTEGER(self.ident_from(start_bpos));\n+            return token::LIT_INTEGER(self.name_from(start_bpos));\n         }\n     }\n \n@@ -980,7 +980,7 @@ impl<'a> StringReader<'a> {\n                                    start - BytePos(1), last_bpos,\n                                    \"unterminated character constant\".to_string());\n             }\n-            let id = if valid { self.ident_from(start) } else { str_to_ident(\"0\") };\n+            let id = if valid { self.name_from(start) } else { token::intern(\"0\") };\n             self.bump(); // advance curr past token\n             return token::LIT_CHAR(id);\n           }\n@@ -1010,8 +1010,8 @@ impl<'a> StringReader<'a> {\n                 valid &= self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ false, '\"');\n             }\n             // adjust for the ACSII \" at the start of the literal\n-            let id = if valid { self.ident_from(start_bpos + BytePos(1)) }\n-                     else { str_to_ident(\"??\") };\n+            let id = if valid { self.name_from(start_bpos + BytePos(1)) }\n+                     else { token::intern(\"??\") };\n             self.bump();\n             return token::LIT_STR(id);\n           }\n@@ -1076,9 +1076,9 @@ impl<'a> StringReader<'a> {\n             }\n             self.bump();\n             let id = if valid {\n-                self.ident_from_to(content_start_bpos, content_end_bpos)\n+                self.name_from_to(content_start_bpos, content_end_bpos)\n             } else {\n-                str_to_ident(\"??\")\n+                token::intern(\"??\")\n             };\n             return token::LIT_STR_RAW(id, hash_count);\n           }\n@@ -1168,7 +1168,7 @@ impl<'a> StringReader<'a> {\n                 \"unterminated byte constant\".to_string());\n         }\n \n-        let id = if valid { self.ident_from(start) } else { str_to_ident(\"??\") };\n+        let id = if valid { self.name_from(start) } else { token::intern(\"??\") };\n         self.bump(); // advance curr past token\n         return token::LIT_BYTE(id);\n     }\n@@ -1190,7 +1190,7 @@ impl<'a> StringReader<'a> {\n             self.bump();\n             valid &= self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ true, '\"');\n         }\n-        let id = if valid { self.ident_from(start) } else { str_to_ident(\"??\") };\n+        let id = if valid { self.name_from(start) } else { token::intern(\"??\") };\n         self.bump();\n         return token::LIT_BINARY(id);\n     }\n@@ -1243,7 +1243,7 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n         self.bump();\n-        return token::LIT_BINARY_RAW(self.ident_from_to(content_start_bpos, content_end_bpos),\n+        return token::LIT_BINARY_RAW(self.name_from_to(content_start_bpos, content_end_bpos),\n                                      hash_count);\n     }\n }"}, {"sha": "743eeed9da5e247c4dc8fe77a6e0f94e8b993180", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -1560,8 +1560,8 @@ impl<'a> Parser<'a> {\n         match *tok {\n             token::LIT_BYTE(i) => LitByte(parse::byte_lit(i.as_str()).val0()),\n             token::LIT_CHAR(i) => LitChar(parse::char_lit(i.as_str()).val0()),\n-            token::LIT_INTEGER(s) => parse::integer_lit(self.id_to_interned_str(s).get(),\n-                                                       &self.sess.span_diagnostic, self.span),\n+            token::LIT_INTEGER(s) => parse::integer_lit(s.as_str(),\n+                                                        &self.sess.span_diagnostic, self.span),\n             token::LIT_FLOAT(s) => parse::float_lit(s.as_str()),\n             token::LIT_STR(s) => {\n                 LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n@@ -1572,7 +1572,7 @@ impl<'a> Parser<'a> {\n                        ast::RawStr(n))\n             }\n             token::LIT_BINARY(i) =>\n-                LitBinary(parse::binary_lit(self.id_to_interned_str(i).get())),\n+                LitBinary(parse::binary_lit(i.as_str())),\n             token::LIT_BINARY_RAW(i, _) =>\n                 LitBinary(Rc::new(i.as_str().as_bytes().iter().map(|&x| x).collect())),\n             token::LPAREN => { self.expect(&token::RPAREN); LitNil },\n@@ -1948,7 +1948,12 @@ impl<'a> Parser<'a> {\n                     });\n                 return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n             },\n-            token::IDENT(id @ ast::Ident{name:token::SELF_KEYWORD_NAME,ctxt:_},false) => {\n+            // FIXME #13626: Should be able to stick in\n+            // token::SELF_KEYWORD_NAME\n+            token::IDENT(id @ ast::Ident{\n+                        name: ast::Name(token::SELF_KEYWORD_NAME_NUM),\n+                        ctxt: _\n+                    } ,false) => {\n                 self.bump();\n                 let path = ast_util::ident_to_path(mk_sp(lo, hi), id);\n                 ex = ExprPath(path);\n@@ -4770,8 +4775,7 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::LIT_STR(s) | token::LIT_STR_RAW(s, _) => {\n                 self.bump();\n-                let identifier_string = token::get_ident(s);\n-                let the_string = identifier_string.get();\n+                let the_string = s.as_str();\n                 match abi::lookup(the_string) {\n                     Some(abi) => Some(abi),\n                     None => {\n@@ -5389,9 +5393,9 @@ impl<'a> Parser<'a> {\n     pub fn parse_optional_str(&mut self)\n                               -> Option<(InternedString, ast::StrStyle)> {\n         let (s, style) = match self.token {\n-            token::LIT_STR(s) => (self.id_to_interned_str(s), ast::CookedStr),\n+            token::LIT_STR(s) => (self.id_to_interned_str(s.ident()), ast::CookedStr),\n             token::LIT_STR_RAW(s, n) => {\n-                (self.id_to_interned_str(s), ast::RawStr(n))\n+                (self.id_to_interned_str(s.ident()), ast::RawStr(n))\n             }\n             _ => return None\n         };"}, {"sha": "076db789f063a66bfd7ad52fda31fe5d8f5693d0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -78,14 +78,14 @@ pub enum Token {\n     QUESTION,\n \n     /* Literals */\n-    LIT_BYTE(Ident),\n-    LIT_CHAR(Ident),\n-    LIT_INTEGER(Ident),\n-    LIT_FLOAT(Ident),\n-    LIT_STR(Ident),\n-    LIT_STR_RAW(Ident, uint), /* raw str delimited by n hash symbols */\n-    LIT_BINARY(Ident),\n-    LIT_BINARY_RAW(Ident, uint), /* raw binary str delimited by n hash symbols */\n+    LIT_BYTE(Name),\n+    LIT_CHAR(Name),\n+    LIT_INTEGER(Name),\n+    LIT_FLOAT(Name),\n+    LIT_STR(Name),\n+    LIT_STR_RAW(Name, uint), /* raw str delimited by n hash symbols */\n+    LIT_BINARY(Name),\n+    LIT_BINARY_RAW(Name, uint), /* raw binary str delimited by n hash symbols */\n \n     /* Name components */\n     /// An identifier contains an \"is_mod_name\" boolean,\n@@ -97,7 +97,7 @@ pub enum Token {\n \n     /* For interpolation */\n     INTERPOLATED(Nonterminal),\n-    DOC_COMMENT(Ident),\n+    DOC_COMMENT(Name),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for\n@@ -107,7 +107,7 @@ pub enum Token {\n     WS,\n     /// Comment\n     COMMENT,\n-    SHEBANG(Ident),\n+    SHEBANG(Name),\n \n     EOF,\n }\n@@ -207,28 +207,28 @@ pub fn to_string(t: &Token) -> String {\n \n       /* Literals */\n       LIT_BYTE(b) => {\n-          format!(\"b'{}'\", get_ident(b).get())\n+          format!(\"b'{}'\", b.as_str())\n       }\n       LIT_CHAR(c) => {\n-          format!(\"'{}'\", get_ident(c).get())\n+          format!(\"'{}'\", c.as_str())\n       }\n       LIT_INTEGER(c) | LIT_FLOAT(c) => {\n-          get_ident(c).get().to_string()\n+          c.as_str().to_string()\n       }\n \n       LIT_STR(s) => {\n-          format!(\"\\\"{}\\\"\", get_ident(s).get())\n+          format!(\"\\\"{}\\\"\", s.as_str())\n       }\n       LIT_STR_RAW(s, n) => {\n         format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                 delim=\"#\".repeat(n), string=get_ident(s))\n+                 delim=\"#\".repeat(n), string=s.as_str())\n       }\n       LIT_BINARY(v) => {\n-          format!(\"b\\\"{}\\\"\", get_ident(v).get())\n+          format!(\"b\\\"{}\\\"\", v.as_str())\n       }\n       LIT_BINARY_RAW(s, n) => {\n         format!(\"br{delim}\\\"{string}\\\"{delim}\",\n-                 delim=\"#\".repeat(n), string=get_ident(s).get())\n+                 delim=\"#\".repeat(n), string=s.as_str())\n       }\n \n       /* Name components */\n@@ -239,7 +239,7 @@ pub fn to_string(t: &Token) -> String {\n       UNDERSCORE => \"_\".to_string(),\n \n       /* Other */\n-      DOC_COMMENT(s) => get_ident(s).get().to_string(),\n+      DOC_COMMENT(s) => s.as_str().to_string(),\n       EOF => \"<eof>\".to_string(),\n       WS => \" \".to_string(),\n       COMMENT => \"/* */\".to_string(),\n@@ -374,19 +374,19 @@ macro_rules! declare_special_idents_and_keywords {(\n         $( ($rk_name:expr, $rk_variant:ident, $rk_str:expr); )*\n     }\n ) => {\n-    static STRICT_KEYWORD_START: Name = first!($( $sk_name, )*);\n-    static STRICT_KEYWORD_FINAL: Name = last!($( $sk_name, )*);\n-    static RESERVED_KEYWORD_START: Name = first!($( $rk_name, )*);\n-    static RESERVED_KEYWORD_FINAL: Name = last!($( $rk_name, )*);\n+    static STRICT_KEYWORD_START: Name = first!($( Name($sk_name), )*);\n+    static STRICT_KEYWORD_FINAL: Name = last!($( Name($sk_name), )*);\n+    static RESERVED_KEYWORD_START: Name = first!($( Name($rk_name), )*);\n+    static RESERVED_KEYWORD_FINAL: Name = last!($( Name($rk_name), )*);\n \n     pub mod special_idents {\n-        use ast::Ident;\n-        $( pub static $si_static: Ident = Ident { name: $si_name, ctxt: 0 }; )*\n+        use ast::{Ident, Name};\n+        $( pub static $si_static: Ident = Ident { name: Name($si_name), ctxt: 0 }; )*\n     }\n \n     pub mod special_names {\n         use ast::Name;\n-        $( pub static $si_static: Name =  $si_name; )*\n+        $( pub static $si_static: Name =  Name($si_name); )*\n     }\n \n     /**\n@@ -407,8 +407,8 @@ macro_rules! declare_special_idents_and_keywords {(\n         impl Keyword {\n             pub fn to_name(&self) -> Name {\n                 match *self {\n-                    $( $sk_variant => $sk_name, )*\n-                    $( $rk_variant => $rk_name, )*\n+                    $( $sk_variant => Name($sk_name), )*\n+                    $( $rk_variant => Name($rk_name), )*\n                 }\n             }\n         }\n@@ -427,8 +427,11 @@ macro_rules! declare_special_idents_and_keywords {(\n }}\n \n // If the special idents get renumbered, remember to modify these two as appropriate\n-pub static SELF_KEYWORD_NAME: Name = 1;\n-static STATIC_KEYWORD_NAME: Name = 2;\n+pub static SELF_KEYWORD_NAME: Name = Name(SELF_KEYWORD_NAME_NUM);\n+static STATIC_KEYWORD_NAME: Name = Name(STATIC_KEYWORD_NAME_NUM);\n+\n+pub static SELF_KEYWORD_NAME_NUM: u32 = 1;\n+static STATIC_KEYWORD_NAME_NUM: u32 = 2;\n \n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n@@ -438,8 +441,8 @@ declare_special_idents_and_keywords! {\n     pub mod special_idents {\n         // These ones are statics\n         (0,                          invalid,                \"\");\n-        (super::SELF_KEYWORD_NAME,   self_,                  \"self\");\n-        (super::STATIC_KEYWORD_NAME, statik,                 \"static\");\n+        (super::SELF_KEYWORD_NAME_NUM,   self_,                  \"self\");\n+        (super::STATIC_KEYWORD_NAME_NUM, statik,                 \"static\");\n         (3,                          static_lifetime,        \"'static\");\n \n         // for matcher NTs\n@@ -479,8 +482,8 @@ declare_special_idents_and_keywords! {\n         (29,                         Ref,        \"ref\");\n         (30,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n-        (super::STATIC_KEYWORD_NAME, Static,     \"static\");\n-        (super::SELF_KEYWORD_NAME,   Self,       \"self\");\n+        (super::STATIC_KEYWORD_NAME_NUM, Static,     \"static\");\n+        (super::SELF_KEYWORD_NAME_NUM,   Self,       \"self\");\n         (31,                         Struct,     \"struct\");\n         (32,                         Super,      \"super\");\n         (33,                         True,       \"true\");\n@@ -687,7 +690,7 @@ pub fn fresh_name(src: &Ident) -> Name {\n \n // create a fresh mark.\n pub fn fresh_mark() -> Mrk {\n-    gensym(\"mark\")\n+    gensym(\"mark\").uint() as u32\n }\n \n // See the macro above about the types of keywords\n@@ -701,31 +704,39 @@ pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n \n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => match sid.name {\n-            SELF_KEYWORD_NAME | STATIC_KEYWORD_NAME |\n-            STRICT_KEYWORD_START .. RESERVED_KEYWORD_FINAL => true,\n-            _ => false,\n+        token::IDENT(sid, false) => {\n+            let n = sid.name;\n+\n+               n == SELF_KEYWORD_NAME\n+            || n == STATIC_KEYWORD_NAME\n+            || STRICT_KEYWORD_START <= n\n+            && n <= RESERVED_KEYWORD_FINAL\n         },\n         _ => false\n     }\n }\n \n pub fn is_strict_keyword(tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => match sid.name {\n-            SELF_KEYWORD_NAME | STATIC_KEYWORD_NAME |\n-            STRICT_KEYWORD_START .. STRICT_KEYWORD_FINAL => true,\n-            _ => false,\n+        token::IDENT(sid, false) => {\n+            let n = sid.name;\n+\n+               n == SELF_KEYWORD_NAME\n+            || n == STATIC_KEYWORD_NAME\n+            || STRICT_KEYWORD_START <= n\n+            && n <= STRICT_KEYWORD_FINAL\n         },\n         _ => false,\n     }\n }\n \n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => match sid.name {\n-            RESERVED_KEYWORD_START .. RESERVED_KEYWORD_FINAL => true,\n-            _ => false,\n+        token::IDENT(sid, false) => {\n+            let n = sid.name;\n+\n+               RESERVED_KEYWORD_START <= n\n+            && n <= RESERVED_KEYWORD_FINAL\n         },\n         _ => false,\n     }"}, {"sha": "b370678c6df21747fe036a7b18b53b7abc96b03f", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092c5078be5b9abfc4e1a80e3ef9d015d321479c/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=092c5078be5b9abfc4e1a80e3ef9d015d321479c", "patch": "@@ -52,23 +52,23 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n         }\n \n         let mut vect = self.vect.borrow_mut();\n-        let new_idx = (*vect).len() as Name;\n+        let new_idx = Name((*vect).len() as u32);\n         (*map).insert(val.clone(), new_idx);\n         (*vect).push(val);\n         new_idx\n     }\n \n     pub fn gensym(&self, val: T) -> Name {\n         let mut vect = self.vect.borrow_mut();\n-        let new_idx = (*vect).len() as Name;\n+        let new_idx = Name((*vect).len() as u32);\n         // leave out of .map to avoid colliding\n         (*vect).push(val);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> T {\n         let vect = self.vect.borrow();\n-        (*(*vect).get(idx as uint)).clone()\n+        (*(*vect).get(idx.uint())).clone()\n     }\n \n     pub fn len(&self) -> uint {\n@@ -155,15 +155,15 @@ impl StrInterner {\n             None => (),\n         }\n \n-        let new_idx = self.len() as Name;\n+        let new_idx = Name(self.len() as u32);\n         let val = RcStr::new(val);\n         map.insert(val.clone(), new_idx);\n         self.vect.borrow_mut().push(val);\n         new_idx\n     }\n \n     pub fn gensym(&self, val: &str) -> Name {\n-        let new_idx = self.len() as Name;\n+        let new_idx = Name(self.len() as u32);\n         // leave out of .map to avoid colliding\n         self.vect.borrow_mut().push(RcStr::new(val));\n         new_idx\n@@ -180,23 +180,23 @@ impl StrInterner {\n     /// Create a gensym with the same name as an existing\n     /// entry.\n     pub fn gensym_copy(&self, idx : Name) -> Name {\n-        let new_idx = self.len() as Name;\n+        let new_idx = Name(self.len() as u32);\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect.get(idx as uint)).clone();\n+        let existing = (*vect.get(idx.uint())).clone();\n         vect.push(existing);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> RcStr {\n-        (*self.vect.borrow().get(idx as uint)).clone()\n+        (*self.vect.borrow().get(idx.uint())).clone()\n     }\n \n     /// Returns this string with lifetime tied to the interner. Since\n     /// strings may never be removed from the interner, this is safe.\n     pub fn get_ref<'a>(&'a self, idx: Name) -> &'a str {\n         let vect = self.vect.borrow();\n-        let s: &str = vect.get(idx as uint).as_slice();\n+        let s: &str = vect.get(idx.uint()).as_slice();\n         unsafe {\n             mem::transmute(s)\n         }"}]}