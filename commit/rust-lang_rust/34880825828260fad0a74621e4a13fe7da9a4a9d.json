{"sha": "34880825828260fad0a74621e4a13fe7da9a4a9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ODgwODI1ODI4MjYwZmFkMGE3NDYyMWU0YTEzZmU3ZGE5YTRhOWQ=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-02T08:03:56Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-01-29T20:37:40Z"}, "message": "Compute mutability of closure captures\n\nWhen `capture_disjoint_fields` is not enabled, checking if the root variable\nbinding is mutable would suffice.\n\nHowever with the feature enabled, the captured place might be mutable\nbecause it dereferences a mutable reference.\n\nThis PR computes the mutability of each capture after capture analysis\nin rustc_typeck. We store this in `ty::CapturedPlace` and then use\n`ty::CapturedPlace::mutability` in mir_build and borrow_check.", "tree": {"sha": "ac1c2f07868ee4edf9374193fb29d0bd905fc1f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac1c2f07868ee4edf9374193fb29d0bd905fc1f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34880825828260fad0a74621e4a13fe7da9a4a9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34880825828260fad0a74621e4a13fe7da9a4a9d", "html_url": "https://github.com/rust-lang/rust/commit/34880825828260fad0a74621e4a13fe7da9a4a9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34880825828260fad0a74621e4a13fe7da9a4a9d/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b421cd56d945743defe3b2a32e2901648ac8dd2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b421cd56d945743defe3b2a32e2901648ac8dd2d", "html_url": "https://github.com/rust-lang/rust/commit/b421cd56d945743defe3b2a32e2901648ac8dd2d"}], "stats": {"total": 82, "additions": 60, "deletions": 22}, "files": [{"sha": "ddb78d91759f94e4f2bcf23128194f3002f8279b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=34880825828260fad0a74621e4a13fe7da9a4a9d", "patch": "@@ -661,11 +661,17 @@ pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureLis\n /// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n \n-/// A `Place` and the corresponding `CaptureInfo`.\n+/// A composite describing a `Place` that is captured by a closure.\n #[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CapturedPlace<'tcx> {\n+    /// The `Place` that is captured.\n     pub place: HirPlace<'tcx>,\n+\n+    /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n     pub info: CaptureInfo<'tcx>,\n+\n+    /// Represents if `place` can be mutated or not.\n+    pub mutability: hir::Mutability,\n }\n \n pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {"}, {"sha": "1a771157e288a1d5eb17ba3bf6e1d8f139757609", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=34880825828260fad0a74621e4a13fe7da9a4a9d", "patch": "@@ -170,17 +170,12 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 ty::UpvarCapture::ByValue(_) => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n-            let mut upvar = Upvar {\n+            Upvar {\n                 name: tcx.hir().name(var_hir_id),\n                 var_hir_id,\n                 by_ref,\n-                mutability: Mutability::Not,\n-            };\n-            let bm = *tables.pat_binding_modes().get(var_hir_id).expect(\"missing binding mode\");\n-            if bm == ty::BindByValue(hir::Mutability::Mut) {\n-                upvar.mutability = Mutability::Mut;\n+                mutability: captured_place.mutability,\n             }\n-            upvar\n         })\n         .collect();\n "}, {"sha": "e4891eb5a3c0cc1305fbd1203bc41a8cc154632b", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=34880825828260fad0a74621e4a13fe7da9a4a9d", "patch": "@@ -851,22 +851,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         _ => bug!(\"Expected an upvar\")\n                     };\n \n-                    let mut mutability = Mutability::Not;\n+                    let mutability = captured_place.mutability;\n \n                     // FIXME(project-rfc-2229#8): Store more precise information\n                     let mut name = kw::Empty;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                             name = ident.name;\n-                            match hir_typeck_results\n-                                .extract_binding_mode(tcx.sess, pat.hir_id, pat.span)\n-                            {\n-                                Some(ty::BindByValue(hir::Mutability::Mut)) => {\n-                                    mutability = Mutability::Mut;\n-                                }\n-                                Some(_) => mutability = Mutability::Not,\n-                                _ => {}\n-                            }\n                         }\n                     }\n "}, {"sha": "38330d5a49a94d4953de53b5c37d068bcf9b848d", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34880825828260fad0a74621e4a13fe7da9a4a9d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=34880825828260fad0a74621e4a13fe7da9a4a9d", "patch": "@@ -252,8 +252,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let capture = captured_place.info.capture_kind;\n \n                 debug!(\n-                    \"place={:?} upvar_ty={:?} capture={:?}\",\n-                    captured_place.place, upvar_ty, capture\n+                    \"final_upvar_tys: place={:?} upvar_ty={:?} capture={:?}, mutability={:?}\",\n+                    captured_place.place, upvar_ty, capture, captured_place.mutability,\n                 );\n \n                 match capture {\n@@ -423,7 +423,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n-                    let min_cap_list = vec![ty::CapturedPlace { place, info: capture_info }];\n+                    let mutability = self.determine_capture_mutability(&place);\n+                    let min_cap_list =\n+                        vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n                     continue;\n                 }\n@@ -486,8 +488,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n+                let mutability = self.determine_capture_mutability(&place);\n                 let captured_place =\n-                    ty::CapturedPlace { place: place.clone(), info: updated_capture_info };\n+                    ty::CapturedPlace { place, info: updated_capture_info, mutability };\n                 min_cap_list.push(captured_place);\n             }\n         }\n@@ -607,6 +610,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// A captured place is mutable if\n+    /// 1. Projections don't include a Deref of an immut-borrow, **and**\n+    /// 2. PlaceBase is mut or projections include a Deref of a mut-borrow.\n+    fn determine_capture_mutability(&self, place: &Place<'tcx>) -> hir::Mutability {\n+        let var_hir_id = match place.base {\n+            PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            _ => unreachable!(),\n+        };\n+\n+        let bm = *self\n+            .typeck_results\n+            .borrow()\n+            .pat_binding_modes()\n+            .get(var_hir_id)\n+            .expect(\"missing binding mode\");\n+\n+        let mut is_mutbl = match bm {\n+            ty::BindByValue(mutability) => mutability,\n+            ty::BindByReference(_) => hir::Mutability::Not,\n+        };\n+\n+        for pointer_ty in place.deref_tys() {\n+            match pointer_ty.kind() {\n+                // We don't capture derefs of raw ptrs\n+                ty::RawPtr(_) => unreachable!(),\n+\n+                // Derefencing a mut-ref allows us to mut the Place if we don't deref\n+                // an immut-ref after on top of this.\n+                ty::Ref(.., hir::Mutability::Mut) => is_mutbl = hir::Mutability::Mut,\n+\n+                // The place isn't mutable once we dereference a immutable reference.\n+                ty::Ref(.., hir::Mutability::Not) => return hir::Mutability::Not,\n+\n+                // Dereferencing a box doesn't change mutability\n+                ty::Adt(def, ..) if def.is_box() => {}\n+\n+                unexpected_ty => bug!(\"deref of unexpected pointer type {:?}\", unexpected_ty),\n+            }\n+        }\n+\n+        is_mutbl\n+    }\n }\n \n struct InferBorrowKind<'a, 'tcx> {"}]}