{"sha": "c7172a9935771601a67cdcbedcd2a8cda87367e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MTcyYTk5MzU3NzE2MDFhNjdjZGNiZWRjZDJhOGNkYTg3MzY3ZTk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-25T17:08:10Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:51Z"}, "message": "rustc_llvm: An AttrBuilder that's not completely wasteful.", "tree": {"sha": "59735545e31f71315877d87f7dd843e3875824fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59735545e31f71315877d87f7dd843e3875824fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7172a9935771601a67cdcbedcd2a8cda87367e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7172a9935771601a67cdcbedcd2a8cda87367e9", "html_url": "https://github.com/rust-lang/rust/commit/c7172a9935771601a67cdcbedcd2a8cda87367e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7172a9935771601a67cdcbedcd2a8cda87367e9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "763b6cba37438d16156f7b3c372e2f34f2def623", "url": "https://api.github.com/repos/rust-lang/rust/commits/763b6cba37438d16156f7b3c372e2f34f2def623", "html_url": "https://github.com/rust-lang/rust/commit/763b6cba37438d16156f7b3c372e2f34f2def623"}], "stats": {"total": 201, "additions": 106, "deletions": 95}, "files": [{"sha": "10865df3a4d79c0feb3c22cbcd8416f8771d1075", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 74, "deletions": 61, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c7172a9935771601a67cdcbedcd2a8cda87367e9/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7172a9935771601a67cdcbedcd2a8cda87367e9/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=c7172a9935771601a67cdcbedcd2a8cda87367e9", "patch": "@@ -33,8 +33,6 @@\n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-pub use self::OtherAttribute::*;\n-pub use self::SpecialAttribute::*;\n pub use self::AttributeSet::*;\n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n@@ -133,7 +131,7 @@ pub enum DLLStorageClassTypes {\n }\n \n bitflags! {\n-    #[derive(Debug)]\n+    #[derive(Default, Debug)]\n     flags Attribute : u64 {\n         const ZExt            = 1 << 0,\n         const SExt            = 1 << 1,\n@@ -165,79 +163,85 @@ bitflags! {\n         // FIXME: These attributes are currently not included in the C API as\n         // a temporary measure until the API/ABI impact to the C API is understood\n         // and the path forward agreed upon.\n-        const SanitizeAddress = 1 << 32;\n-        const MinSize         = 1 << 33;\n-        const NoDuplicate     = 1 << 34;\n-        const StackProtectStrong = 1 << 35;\n-        const SanitizeThread  = 1 << 36;\n-        const SanitizeMemory  = 1 << 37;\n-        const NoBuiltin       = 1 << 38;\n-        const Returned        = 1 << 39;\n-        const Cold            = 1 << 40;\n-        const Builtin         = 1 << 41;\n-        const OptimizeNone    = 1 << 42;\n-        const InAlloca        = 1 << 43;\n-        const NonNull         = 1 << 44;\n-        const JumpTable       = 1 << 45;\n-        const Convergent      = 1 << 46;\n-        const SafeStack       = 1 << 47;\n-        const NoRecurse       = 1 << 48;\n-        const InaccessibleMemOnly         = 1 << 49;\n-        const InaccessibleMemOrArgMemOnly = 1 << 50;\n+        const SanitizeAddress = 1 << 32,\n+        const MinSize         = 1 << 33,\n+        const NoDuplicate     = 1 << 34,\n+        const StackProtectStrong = 1 << 35,\n+        const SanitizeThread  = 1 << 36,\n+        const SanitizeMemory  = 1 << 37,\n+        const NoBuiltin       = 1 << 38,\n+        const Returned        = 1 << 39,\n+        const Cold            = 1 << 40,\n+        const Builtin         = 1 << 41,\n+        const OptimizeNone    = 1 << 42,\n+        const InAlloca        = 1 << 43,\n+        const NonNull         = 1 << 44,\n+        const JumpTable       = 1 << 45,\n+        const Convergent      = 1 << 46,\n+        const SafeStack       = 1 << 47,\n+        const NoRecurse       = 1 << 48,\n+        const InaccessibleMemOnly         = 1 << 49,\n+        const InaccessibleMemOrArgMemOnly = 1 << 50,\n     }\n }\n \n-#[derive(Copy, Clone)]\n-pub enum SpecialAttribute {\n-    DereferenceableAttribute(u64)\n+#[derive(Copy, Clone, Default)]\n+pub struct Attributes {\n+    regular: Attribute,\n+    dereferenceable_bytes: u64\n }\n \n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AttributeSet {\n-    ReturnIndex = 0,\n-    FunctionIndex = !0\n-}\n+impl Attributes {\n+    pub fn set(&mut self, attr: Attribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n+        self\n+    }\n \n-pub trait AttrHelper {\n-    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef);\n-    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef);\n-}\n+    pub fn unset(&mut self, attr: Attribute) -> &mut Self {\n+        self.regular = self.regular - attr;\n+        self\n+    }\n \n-impl AttrHelper for Attribute {\n-    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n-        unsafe {\n-            LLVMAddFunctionAttribute(llfn, idx, self.bits() as uint64_t);\n-        }\n+    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n+        self.dereferenceable_bytes = bytes;\n+        self\n     }\n \n-    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n-        unsafe {\n-            LLVMAddCallSiteAttribute(callsite, idx, self.bits() as uint64_t);\n-        }\n+    pub fn unset_dereferenceable(&mut self) -> &mut Self {\n+        self.dereferenceable_bytes = 0;\n+        self\n     }\n-}\n \n-impl AttrHelper for SpecialAttribute {\n-    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n-        match *self {\n-            DereferenceableAttribute(bytes) => unsafe {\n-                LLVMAddDereferenceableAttr(llfn, idx, bytes as uint64_t);\n+    pub fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n+        unsafe {\n+            LLVMAddFunctionAttribute(llfn, idx, self.regular.bits());\n+            if self.dereferenceable_bytes != 0 {\n+                LLVMAddDereferenceableAttr(llfn, idx,\n+                                           self.dereferenceable_bytes);\n             }\n         }\n     }\n \n-    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n-        match *self {\n-            DereferenceableAttribute(bytes) => unsafe {\n-                LLVMAddDereferenceableCallSiteAttr(callsite, idx, bytes as uint64_t);\n+    pub fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n+        unsafe {\n+            LLVMAddCallSiteAttribute(callsite, idx, self.regular.bits());\n+            if self.dereferenceable_bytes != 0 {\n+                LLVMAddDereferenceableCallSiteAttr(callsite, idx,\n+                                                   self.dereferenceable_bytes);\n             }\n         }\n     }\n }\n \n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum AttributeSet {\n+    ReturnIndex = 0,\n+    FunctionIndex = !0\n+}\n+\n pub struct AttrBuilder {\n-    attrs: Vec<(usize, Box<AttrHelper+'static>)>\n+    attrs: Vec<(usize, Attributes)>\n }\n \n impl AttrBuilder {\n@@ -247,14 +251,23 @@ impl AttrBuilder {\n         }\n     }\n \n-    pub fn arg<T: AttrHelper + 'static>(&mut self, idx: usize, a: T) -> &mut AttrBuilder {\n-        self.attrs.push((idx, box a as Box<AttrHelper+'static>));\n-        self\n+    pub fn arg(&mut self, idx: usize) -> &mut Attributes {\n+        let mut found = None;\n+        for (i, &(idx2, _)) in self.attrs.iter().enumerate() {\n+            if idx == idx2 {\n+                found = Some(i);\n+                break;\n+            }\n+        }\n+        let i = found.unwrap_or_else(|| {\n+            self.attrs.push((idx, Attributes::default()));\n+            self.attrs.len() - 1\n+        });\n+        &mut self.attrs[i].1\n     }\n \n-    pub fn ret<T: AttrHelper + 'static>(&mut self, a: T) -> &mut AttrBuilder {\n-        self.attrs.push((ReturnIndex as usize, box a as Box<AttrHelper+'static>));\n-        self\n+    pub fn ret(&mut self) -> &mut Attributes {\n+        self.arg(ReturnIndex as usize)\n     }\n \n     pub fn apply_llfn(&self, llfn: ValueRef) {"}, {"sha": "7a639d5c89e693175b5b24270ee10d9518643f90", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7172a9935771601a67cdcbedcd2a8cda87367e9/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7172a9935771601a67cdcbedcd2a8cda87367e9/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=c7172a9935771601a67cdcbedcd2a8cda87367e9", "patch": "@@ -313,15 +313,15 @@ impl FnType {\n             // The outptr can be noalias and nocapture because it's entirely\n             // invisible to the program. We also know it's nonnull as well\n             // as how many bytes we can dereference\n-            attrs.arg(i, llvm::Attribute::StructRet)\n-                 .arg(i, llvm::Attribute::NoAlias)\n-                 .arg(i, llvm::Attribute::NoCapture)\n-                 .arg(i, llvm::DereferenceableAttribute(llret_sz));\n+            attrs.arg(i).set(llvm::Attribute::StructRet)\n+                        .set(llvm::Attribute::NoAlias)\n+                        .set(llvm::Attribute::NoCapture)\n+                        .set_dereferenceable(llret_sz);\n         };\n \n         // Add attributes that depend on the concrete foreign ABI\n         if let Some(attr) = self.ret.attr {\n-            attrs.arg(i, attr);\n+            attrs.arg(i).set(attr);\n         }\n \n         i += 1;\n@@ -333,7 +333,7 @@ impl FnType {\n             if arg.pad.is_some() { i += 1; }\n \n             if let Some(attr) = arg.attr {\n-                attrs.arg(i, attr);\n+                attrs.arg(i).set(attr);\n             }\n \n             i += 1;"}, {"sha": "5eb9560a43a1eb1abd4329d35e97a171ca509947", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c7172a9935771601a67cdcbedcd2a8cda87367e9/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7172a9935771601a67cdcbedcd2a8cda87367e9/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=c7172a9935771601a67cdcbedcd2a8cda87367e9", "patch": "@@ -10,7 +10,7 @@\n //! Set and unset common attributes on LLVM values.\n \n use libc::{c_uint, c_ulonglong};\n-use llvm::{self, ValueRef, AttrHelper};\n+use llvm::{self, ValueRef};\n use middle::ty;\n use middle::infer;\n use session::config::NoDebugInfo;\n@@ -110,13 +110,11 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n \n     for attr in attrs {\n         if attr.check_name(\"cold\") {\n-            unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn,\n-                                               llvm::FunctionIndex as c_uint,\n-                                               llvm::ColdAttribute as u64)\n-            }\n+            llvm::Attributes::default().set(llvm::Attribute::Cold)\n+                .apply_llfn(llvm::FunctionIndex as c_uint, llfn)\n         } else if attr.check_name(\"allocator\") {\n-            llvm::Attribute::NoAlias.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+            llvm::Attributes::default().set(llvm::Attribute::NoAlias)\n+                .apply_llfn(llvm::ReturnIndex as c_uint, llfn)\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         }\n@@ -168,10 +166,10 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The outptr can be noalias and nocapture because it's entirely\n             // invisible to the program. We also know it's nonnull as well\n             // as how many bytes we can dereference\n-            attrs.arg(1, llvm::Attribute::StructRet)\n-                 .arg(1, llvm::Attribute::NoAlias)\n-                 .arg(1, llvm::Attribute::NoCapture)\n-                 .arg(1, llvm::DereferenceableAttribute(llret_sz));\n+            attrs.arg(1).set(llvm::Attribute::StructRet)\n+                        .set(llvm::Attribute::NoAlias)\n+                        .set(llvm::Attribute::NoCapture)\n+                        .set_dereferenceable(llret_sz);\n \n             // Add one more since there's an outptr\n             idx += 1;\n@@ -182,7 +180,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `Box` pointer return values never alias because ownership\n                 // is transferred\n                 ty::TyBox(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret(llvm::Attribute::NoAlias);\n+                    attrs.ret().set(llvm::Attribute::NoAlias);\n                 }\n                 _ => {}\n             }\n@@ -193,13 +191,13 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 ty::TyRef(_, ty::TypeAndMut { ty: inner, .. })\n                 | ty::TyBox(inner) if common::type_is_sized(ccx.tcx(), inner) => {\n                     let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n+                    attrs.ret().set_dereferenceable(llret_sz);\n                 }\n                 _ => {}\n             }\n \n             if let ty::TyBool = ret_ty.sty {\n-                attrs.ret(llvm::Attribute::ZExt);\n+                attrs.ret().set(llvm::Attribute::ZExt);\n             }\n         }\n     }\n@@ -212,26 +210,26 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::Attribute::NoAlias)\n-                     .arg(idx, llvm::Attribute::NoCapture)\n-                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n+                attrs.arg(idx).set(llvm::Attribute::NoAlias)\n+                              .set(llvm::Attribute::NoCapture)\n+                              .set_dereferenceable(llarg_sz);\n             }\n \n             ty::TyBool => {\n-                attrs.arg(idx, llvm::Attribute::ZExt);\n+                attrs.arg(idx).set(llvm::Attribute::ZExt);\n             }\n \n             // `Box` pointer parameters never alias because ownership is transferred\n             ty::TyBox(inner) => {\n-                attrs.arg(idx, llvm::Attribute::NoAlias);\n+                attrs.arg(idx).set(llvm::Attribute::NoAlias);\n \n                 if common::type_is_sized(ccx.tcx(), inner) {\n                     let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n+                    attrs.arg(idx).set_dereferenceable(llsz);\n                 } else {\n-                    attrs.arg(idx, llvm::NonNullAttribute);\n+                    attrs.arg(idx).set(llvm::Attribute::NonNull);\n                     if inner.is_trait() {\n-                        attrs.arg(idx + 1, llvm::NonNullAttribute);\n+                        attrs.arg(idx + 1).set(llvm::Attribute::NonNull);\n                     }\n                 }\n             }\n@@ -245,30 +243,30 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n \n                 if mt.mutbl != hir::MutMutable && !interior_unsafe {\n-                    attrs.arg(idx, llvm::Attribute::NoAlias);\n+                    attrs.arg(idx).set(llvm::Attribute::NoAlias);\n                 }\n \n                 if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n-                    attrs.arg(idx, llvm::Attribute::ReadOnly);\n+                    attrs.arg(idx).set(llvm::Attribute::ReadOnly);\n                 }\n \n                 // & pointer parameters are also never null and for sized types we also know\n                 // exactly how many bytes we can dereference\n                 if common::type_is_sized(ccx.tcx(), mt.ty) {\n                     let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                    attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n+                    attrs.arg(idx).set_dereferenceable(llsz);\n                 } else {\n-                    attrs.arg(idx, llvm::NonNullAttribute);\n+                    attrs.arg(idx).set(llvm::Attribute::NonNull);\n                     if mt.ty.is_trait() {\n-                        attrs.arg(idx + 1, llvm::NonNullAttribute);\n+                        attrs.arg(idx + 1).set(llvm::Attribute::NonNull);\n                     }\n                 }\n \n                 // When a reference in an argument has no named lifetime, it's\n                 // impossible for that reference to escape this function\n                 // (returned or stored beyond the call by a closure).\n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::Attribute::NoCapture);\n+                    attrs.arg(idx).set(llvm::Attribute::NoCapture);\n                 }\n             }\n "}]}