{"sha": "90357a9090a88b2f7bc5db5d05cb576680ce2960", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMzU3YTkwOTBhODhiMmY3YmM1ZGI1ZDA1Y2I1NzY2ODBjZTI5NjA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-14T15:08:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-14T15:10:01Z"}, "message": "internal: merge hir::BinaryOp and ast::BinOp", "tree": {"sha": "30c333b4f8dac8333755ca9c77cb0965eca8c3d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30c333b4f8dac8333755ca9c77cb0965eca8c3d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90357a9090a88b2f7bc5db5d05cb576680ce2960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90357a9090a88b2f7bc5db5d05cb576680ce2960", "html_url": "https://github.com/rust-lang/rust/commit/90357a9090a88b2f7bc5db5d05cb576680ce2960", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90357a9090a88b2f7bc5db5d05cb576680ce2960/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe4f059450dd3f69dc5c0b6801d4c8a414673cab", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4f059450dd3f69dc5c0b6801d4c8a414673cab", "html_url": "https://github.com/rust-lang/rust/commit/fe4f059450dd3f69dc5c0b6801d4c8a414673cab"}], "stats": {"total": 393, "additions": 160, "deletions": 233}, "files": [{"sha": "d8dac66556b0fb890054d0cfc9e0599ed624ccce", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -27,8 +27,8 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, Array, BinaryOp, BindingAnnotation, Expr, ExprId, Label, LabelId, Literal,\n-        MatchArm, MatchGuard, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+        dummy_expr_id, Array, BindingAnnotation, Expr, ExprId, Label, LabelId, Literal, MatchArm,\n+        MatchGuard, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     intern::Interned,\n     item_scope::BuiltinShadowMode,\n@@ -508,7 +508,7 @@ impl ExprCollector<'_> {\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n-                let op = e.op_kind().map(BinaryOp::from);\n+                let op = e.op_kind();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {"}, {"sha": "9c888e2d4e31a11b7fac92d1626ba2997330e42e", "filename": "crates/ide_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -26,7 +26,13 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n-    let opposite_op = opposite_logic_op(op)?;\n+\n+    let opposite_op = match op {\n+        ast::BinaryOp::LogicOp(ast::LogicOp::And) => \"||\",\n+        ast::BinaryOp::LogicOp(ast::LogicOp::Or) => \"&&\",\n+        _ => return None,\n+    };\n+\n     let cursor_in_range = op_range.contains_range(ctx.frange.range);\n     if !cursor_in_range {\n         return None;\n@@ -136,15 +142,6 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     )\n }\n \n-// Return the opposite text for a given logical operator, if it makes sense\n-fn opposite_logic_op(kind: ast::BinOp) -> Option<&'static str> {\n-    match kind {\n-        ast::BinOp::BooleanOr => Some(\"&&\"),\n-        ast::BinOp::BooleanAnd => Some(\"||\"),\n-        _ => None,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};"}, {"sha": "5e96cec511ccc7a29f36d2065c3e9707bf55b11d", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -892,7 +892,7 @@ fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Optio\n     let parent = expr.syntax().parent()?;\n \n     if let Some(bin_expr) = ast::BinExpr::cast(parent.clone()) {\n-        if bin_expr.op_kind()?.is_assignment() {\n+        if matches!(bin_expr.op_kind()?, ast::BinaryOp::Assignment { .. }) {\n             return Some(bin_expr.lhs()?.syntax() == expr.syntax());\n         }\n         return Some(false);"}, {"sha": "0117b8a84b8744cf131b50aaa928774c2ed0488f", "filename": "crates/ide_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -1,4 +1,4 @@\n-use syntax::ast::{AstNode, BinExpr, BinOp};\n+use syntax::ast::{self, AstNode, BinExpr};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -56,14 +56,19 @@ enum FlipAction {\n     DontFlip,\n }\n \n-impl From<BinOp> for FlipAction {\n-    fn from(op_kind: BinOp) -> Self {\n+impl From<ast::BinaryOp> for FlipAction {\n+    fn from(op_kind: ast::BinaryOp) -> Self {\n         match op_kind {\n-            kind if kind.is_assignment() => FlipAction::DontFlip,\n-            BinOp::GreaterTest => FlipAction::FlipAndReplaceOp(\"<\"),\n-            BinOp::GreaterEqualTest => FlipAction::FlipAndReplaceOp(\"<=\"),\n-            BinOp::LesserTest => FlipAction::FlipAndReplaceOp(\">\"),\n-            BinOp::LesserEqualTest => FlipAction::FlipAndReplaceOp(\">=\"),\n+            ast::BinaryOp::Assignment { .. } => FlipAction::DontFlip,\n+            ast::BinaryOp::CmpOp(ast::CmpOp::Ord { ordering, strict }) => {\n+                let rev_op = match (ordering, strict) {\n+                    (ast::Ordering::Less, true) => \">\",\n+                    (ast::Ordering::Less, false) => \">=\",\n+                    (ast::Ordering::Greater, true) => \"<\",\n+                    (ast::Ordering::Greater, false) => \"<=\",\n+                };\n+                FlipAction::FlipAndReplaceOp(rev_op)\n+            }\n             _ => FlipAction::Flip,\n         }\n     }"}, {"sha": "8946ecfac7c7f04eb165a4e1eed8a8ded2de0c03", "filename": "crates/ide_assists/src/handlers/pull_assignment_up.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -39,7 +39,7 @@ pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext) -> Opti\n     let assign_expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n \n     let op_kind = assign_expr.op_kind()?;\n-    if op_kind != ast::BinOp::Assignment {\n+    if op_kind != (ast::BinaryOp::Assignment { op: None }) {\n         cov_mark::hit!(test_cant_pull_non_assignments);\n         return None;\n     }\n@@ -143,7 +143,7 @@ impl<'a> AssignmentsCollector<'a> {\n     }\n \n     fn collect_expr(&mut self, expr: &ast::BinExpr) -> Option<()> {\n-        if expr.op_kind()? == ast::BinOp::Assignment\n+        if expr.op_kind()? == (ast::BinaryOp::Assignment { op: None })\n             && is_equivalent(self.sema, &expr.lhs()?, &self.common_lhs)\n         {\n             self.assignments.push((expr.clone(), expr.rhs()?));"}, {"sha": "ee81e5048a3e880737b80ddd809247c94cc59e81", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -210,12 +210,17 @@ pub(crate) fn invert_boolean_expression(expr: ast::Expr) -> ast::Expr {\n fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n     match expr {\n         ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n-            ast::BinOp::NegatedEqualityTest => bin.replace_op(T![==]).map(|it| it.into()),\n-            ast::BinOp::EqualityTest => bin.replace_op(T![!=]).map(|it| it.into()),\n-            ast::BinOp::LesserTest => bin.replace_op(T![>=]).map(|it| it.into()),\n-            ast::BinOp::LesserEqualTest => bin.replace_op(T![>]).map(|it| it.into()),\n-            ast::BinOp::GreaterTest => bin.replace_op(T![<=]).map(|it| it.into()),\n-            ast::BinOp::GreaterEqualTest => bin.replace_op(T![<]).map(|it| it.into()),\n+            ast::BinaryOp::CmpOp(op) => {\n+                let rev_op = match op {\n+                    ast::CmpOp::Eq { negated: false } => T![!=],\n+                    ast::CmpOp::Eq { negated: true } => T![==],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Less, strict: true } => T![>=],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Less, strict: false } => T![>],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Greater, strict: true } => T![<=],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Greater, strict: false } => T![<],\n+                };\n+                bin.replace_op(rev_op).map(ast::Expr::from)\n+            }\n             // Parenthesize other expressions before prefixing `!`\n             _ => Some(make::expr_prefix(T![!], make::expr_paren(expr.clone()))),\n         },"}, {"sha": "5a8914b3316ea454c2341bb3bdeefc9f9c0d4b2b", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -1,7 +1,7 @@\n //! This module contains functions to generate default trait impl function bodies where possible.\n \n use syntax::{\n-    ast::{self, edit::AstNodeEdit, make, AstNode, NameOwner},\n+    ast::{self, edit::AstNodeEdit, make, AstNode, BinaryOp, CmpOp, LogicOp, NameOwner},\n     ted,\n };\n \n@@ -325,7 +325,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n         match expr {\n-            Some(expr) => Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp)),\n+            Some(expr) => Some(make::expr_bin_op(expr, BinaryOp::LogicOp(LogicOp::And), cmp)),\n             None => Some(cmp),\n         }\n     }\n@@ -362,7 +362,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let lhs = make::expr_call(make_discriminant()?, make::arg_list(Some(lhs_name.clone())));\n             let rhs_name = make::expr_path(make::ext::ident_path(\"other\"));\n             let rhs = make::expr_call(make_discriminant()?, make::arg_list(Some(rhs_name.clone())));\n-            let eq_check = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+            let eq_check =\n+                make::expr_bin_op(lhs, BinaryOp::CmpOp(CmpOp::Eq { negated: false }), rhs);\n \n             let mut case_count = 0;\n             let mut arms = vec![];\n@@ -386,7 +387,11 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n                             let lhs = make::expr_path(make::ext::ident_path(l_name));\n                             let rhs = make::expr_path(make::ext::ident_path(r_name));\n-                            let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                            let cmp = make::expr_bin_op(\n+                                lhs,\n+                                BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+                                rhs,\n+                            );\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n@@ -415,7 +420,11 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n                             let lhs = make::expr_path(make::ext::ident_path(&l_name));\n                             let rhs = make::expr_path(make::ext::ident_path(&r_name));\n-                            let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                            let cmp = make::expr_bin_op(\n+                                lhs,\n+                                BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+                                rhs,\n+                            );\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n@@ -455,7 +464,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let lhs = make::expr_field(lhs, &field.name()?.to_string());\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n                     let rhs = make::expr_field(rhs, &field.name()?.to_string());\n-                    let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                    let cmp =\n+                        make::expr_bin_op(lhs, BinaryOp::CmpOp(CmpOp::Eq { negated: false }), rhs);\n                     expr = gen_eq_chain(expr, cmp);\n                 }\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n@@ -469,7 +479,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n                     let rhs = make::expr_field(rhs, &idx);\n-                    let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                    let cmp =\n+                        make::expr_bin_op(lhs, BinaryOp::CmpOp(CmpOp::Eq { negated: false }), rhs);\n                     expr = gen_eq_chain(expr, cmp);\n                 }\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))"}, {"sha": "627f5e97fa734a5292e74b6b89db26ac37b87293", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -655,7 +655,7 @@ fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<Referen\n         match_ast! {\n             match (node) {\n                 ast::BinExpr(expr) => {\n-                    if expr.op_kind()?.is_assignment() {\n+                    if matches!(expr.op_kind()?, ast::BinaryOp::Assignment { .. }) {\n                         // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n                         // FIXME: This is not terribly accurate.\n                         if let Some(lhs) = expr.lhs() {"}, {"sha": "e26c5b7ad90f8de78c9847528b3ebe8753db4319", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -18,13 +18,13 @@ use crate::{\n };\n \n pub use self::{\n-    expr_ext::{ArrayExprKind, BinOp, Effect, ElseBranch, LiteralKind},\n+    expr_ext::{ArrayExprKind, Effect, ElseBranch, LiteralKind},\n     generated::{nodes::*, tokens::*},\n     node_ext::{\n         AttrKind, AttrsOwnerNode, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind,\n         SelfParamKind, SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n     },\n-    operators::{ArithOp, BinaryOp, CmpOp, LogicOp, RangeOp, UnaryOp, Ordering},\n+    operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n     token_ext::{\n         CommentKind, CommentPlacement, CommentShape, FormatSpecifier, HasFormatSpecifier, IsString,\n         QuoteOffsets, Radix,"}, {"sha": "4598066bc93a907fa9e41cf239de09dca874d026", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 37, "deletions": 149, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -5,7 +5,7 @@ use rowan::WalkEvent;\n use crate::{\n     ast::{\n         self,\n-        operators::{RangeOp, UnaryOp},\n+        operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n         support, AstChildren, AstNode,\n     },\n     AstToken,\n@@ -213,127 +213,51 @@ impl ast::PrefixExpr {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum BinOp {\n-    /// The `||` operator for boolean OR\n-    BooleanOr,\n-    /// The `&&` operator for boolean AND\n-    BooleanAnd,\n-    /// The `==` operator for equality testing\n-    EqualityTest,\n-    /// The `!=` operator for equality testing\n-    NegatedEqualityTest,\n-    /// The `<=` operator for lesser-equal testing\n-    LesserEqualTest,\n-    /// The `>=` operator for greater-equal testing\n-    GreaterEqualTest,\n-    /// The `<` operator for comparison\n-    LesserTest,\n-    /// The `>` operator for comparison\n-    GreaterTest,\n-    /// The `+` operator for addition\n-    Addition,\n-    /// The `*` operator for multiplication\n-    Multiplication,\n-    /// The `-` operator for subtraction\n-    Subtraction,\n-    /// The `/` operator for division\n-    Division,\n-    /// The `%` operator for remainder after division\n-    Remainder,\n-    /// The `<<` operator for left shift\n-    LeftShift,\n-    /// The `>>` operator for right shift\n-    RightShift,\n-    /// The `^` operator for bitwise XOR\n-    BitwiseXor,\n-    /// The `|` operator for bitwise OR\n-    BitwiseOr,\n-    /// The `&` operator for bitwise AND\n-    BitwiseAnd,\n-    /// The `=` operator for assignment\n-    Assignment,\n-    /// The `+=` operator for assignment after addition\n-    AddAssign,\n-    /// The `/=` operator for assignment after division\n-    DivAssign,\n-    /// The `*=` operator for assignment after multiplication\n-    MulAssign,\n-    /// The `%=` operator for assignment after remainders\n-    RemAssign,\n-    /// The `>>=` operator for assignment after shifting right\n-    ShrAssign,\n-    /// The `<<=` operator for assignment after shifting left\n-    ShlAssign,\n-    /// The `-=` operator for assignment after subtraction\n-    SubAssign,\n-    /// The `|=` operator for assignment after bitwise OR\n-    BitOrAssign,\n-    /// The `&=` operator for assignment after bitwise AND\n-    BitAndAssign,\n-    /// The `^=` operator for assignment after bitwise XOR\n-    BitXorAssign,\n-}\n-\n-impl BinOp {\n-    pub fn is_assignment(self) -> bool {\n-        matches!(\n-            self,\n-            BinOp::Assignment\n-                | BinOp::AddAssign\n-                | BinOp::DivAssign\n-                | BinOp::MulAssign\n-                | BinOp::RemAssign\n-                | BinOp::ShrAssign\n-                | BinOp::ShlAssign\n-                | BinOp::SubAssign\n-                | BinOp::BitOrAssign\n-                | BinOp::BitAndAssign\n-                | BinOp::BitXorAssign\n-        )\n-    }\n-}\n-\n impl ast::BinExpr {\n-    pub fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n+    pub fn op_details(&self) -> Option<(SyntaxToken, BinaryOp)> {\n         self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find_map(|c| {\n+            #[rustfmt::skip]\n             let bin_op = match c.kind() {\n-                T![||] => BinOp::BooleanOr,\n-                T![&&] => BinOp::BooleanAnd,\n-                T![==] => BinOp::EqualityTest,\n-                T![!=] => BinOp::NegatedEqualityTest,\n-                T![<=] => BinOp::LesserEqualTest,\n-                T![>=] => BinOp::GreaterEqualTest,\n-                T![<] => BinOp::LesserTest,\n-                T![>] => BinOp::GreaterTest,\n-                T![+] => BinOp::Addition,\n-                T![*] => BinOp::Multiplication,\n-                T![-] => BinOp::Subtraction,\n-                T![/] => BinOp::Division,\n-                T![%] => BinOp::Remainder,\n-                T![<<] => BinOp::LeftShift,\n-                T![>>] => BinOp::RightShift,\n-                T![^] => BinOp::BitwiseXor,\n-                T![|] => BinOp::BitwiseOr,\n-                T![&] => BinOp::BitwiseAnd,\n-                T![=] => BinOp::Assignment,\n-                T![+=] => BinOp::AddAssign,\n-                T![/=] => BinOp::DivAssign,\n-                T![*=] => BinOp::MulAssign,\n-                T![%=] => BinOp::RemAssign,\n-                T![>>=] => BinOp::ShrAssign,\n-                T![<<=] => BinOp::ShlAssign,\n-                T![-=] => BinOp::SubAssign,\n-                T![|=] => BinOp::BitOrAssign,\n-                T![&=] => BinOp::BitAndAssign,\n-                T![^=] => BinOp::BitXorAssign,\n+                T![||] => BinaryOp::LogicOp(LogicOp::Or),\n+                T![&&] => BinaryOp::LogicOp(LogicOp::And),\n+\n+                T![==] => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+                T![!=] => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n+                T![<=] => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less,    strict: false }),\n+                T![>=] => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false }),\n+                T![<]  => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less,    strict: true }),\n+                T![>]  => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true }),\n+\n+                T![+]  => BinaryOp::ArithOp(ArithOp::Add),\n+                T![*]  => BinaryOp::ArithOp(ArithOp::Mul),\n+                T![-]  => BinaryOp::ArithOp(ArithOp::Sub),\n+                T![/]  => BinaryOp::ArithOp(ArithOp::Div),\n+                T![%]  => BinaryOp::ArithOp(ArithOp::Rem),\n+                T![<<] => BinaryOp::ArithOp(ArithOp::Shl),\n+                T![>>] => BinaryOp::ArithOp(ArithOp::Shr),\n+                T![^]  => BinaryOp::ArithOp(ArithOp::BitXor),\n+                T![|]  => BinaryOp::ArithOp(ArithOp::BitOr),\n+                T![&]  => BinaryOp::ArithOp(ArithOp::BitAnd),\n+\n+                T![=]   => BinaryOp::Assignment { op: None },\n+                T![+=]  => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n+                T![*=]  => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n+                T![-=]  => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n+                T![/=]  => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n+                T![%=]  => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n+                T![<<=] => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n+                T![>>=] => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n+                T![^=]  => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n+                T![|=]  => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n+                T![&=]  => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n+\n                 _ => return None,\n             };\n             Some((c, bin_op))\n         })\n     }\n \n-    pub fn op_kind(&self) -> Option<BinOp> {\n+    pub fn op_kind(&self) -> Option<BinaryOp> {\n         self.op_details().map(|t| t.1)\n     }\n \n@@ -357,42 +281,6 @@ impl ast::BinExpr {\n     }\n }\n \n-impl std::fmt::Display for BinOp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            BinOp::BooleanOr => write!(f, \"||\"),\n-            BinOp::BooleanAnd => write!(f, \"&&\"),\n-            BinOp::EqualityTest => write!(f, \"==\"),\n-            BinOp::NegatedEqualityTest => write!(f, \"!=\"),\n-            BinOp::LesserEqualTest => write!(f, \"<=\"),\n-            BinOp::GreaterEqualTest => write!(f, \">=\"),\n-            BinOp::LesserTest => write!(f, \"<\"),\n-            BinOp::GreaterTest => write!(f, \">\"),\n-            BinOp::Addition => write!(f, \"+\"),\n-            BinOp::Multiplication => write!(f, \"*\"),\n-            BinOp::Subtraction => write!(f, \"-\"),\n-            BinOp::Division => write!(f, \"/\"),\n-            BinOp::Remainder => write!(f, \"%\"),\n-            BinOp::LeftShift => write!(f, \"<<\"),\n-            BinOp::RightShift => write!(f, \">>\"),\n-            BinOp::BitwiseXor => write!(f, \"^\"),\n-            BinOp::BitwiseOr => write!(f, \"|\"),\n-            BinOp::BitwiseAnd => write!(f, \"&\"),\n-            BinOp::Assignment => write!(f, \"=\"),\n-            BinOp::AddAssign => write!(f, \"+=\"),\n-            BinOp::DivAssign => write!(f, \"/=\"),\n-            BinOp::MulAssign => write!(f, \"*=\"),\n-            BinOp::RemAssign => write!(f, \"%=\"),\n-            BinOp::ShrAssign => write!(f, \">>=\"),\n-            BinOp::ShlAssign => write!(f, \"<<=\"),\n-            BinOp::SubAssign => write!(f, \"-\"),\n-            BinOp::BitOrAssign => write!(f, \"|=\"),\n-            BinOp::BitAndAssign => write!(f, \"&=\"),\n-            BinOp::BitXorAssign => write!(f, \"^=\"),\n-        }\n-    }\n-}\n-\n impl ast::RangeExpr {\n     fn op_details(&self) -> Option<(usize, SyntaxToken, RangeOp)> {\n         self.syntax().children_with_tokens().enumerate().find_map(|(ix, child)| {"}, {"sha": "5494dd1d3e8685c50e85e31498534ffb2ad7cf3b", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -276,7 +276,8 @@ pub fn expr_path(path: ast::Path) -> ast::Expr {\n pub fn expr_continue() -> ast::Expr {\n     expr_from_text(\"continue\")\n }\n-pub fn expr_op(op: ast::BinOp, lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n+// Consider `op: SyntaxKind` instead for nicer syntax at the call-site?\n+pub fn expr_bin_op(lhs: ast::Expr, op: ast::BinaryOp, rhs: ast::Expr) -> ast::Expr {\n     expr_from_text(&format!(\"{} {} {}\", lhs, op, rhs))\n }\n pub fn expr_break(expr: Option<ast::Expr>) -> ast::Expr {"}, {"sha": "a687ba0b77a56760a6a9dcb4f51b102b9be75535", "filename": "crates/syntax/src/ast/operators.rs", "status": "modified", "additions": 63, "deletions": 43, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90357a9090a88b2f7bc5db5d05cb576680ce2960/crates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs?ref=90357a9090a88b2f7bc5db5d05cb576680ce2960", "patch": "@@ -1,3 +1,9 @@\n+//! Defines a bunch of data-less enums for unary and binary operators.\n+//!\n+//! Types here don't know about AST, this allows re-using them for both AST and\n+//! HIR.\n+use std::fmt;\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum RangeOp {\n     /// `..`\n@@ -8,11 +14,11 @@ pub enum RangeOp {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum UnaryOp {\n-    /// The `*` operator for dereferencing\n+    /// `*`\n     Deref,\n-    /// The `!` operator for logical inversion\n+    /// `!`\n     Not,\n-    /// The `-` operator for negation\n+    /// `-`\n     Neg,\n }\n \n@@ -56,47 +62,61 @@ pub enum ArithOp {\n     BitAnd,\n }\n \n-use crate::ast;\n-impl From<ast::BinOp> for BinaryOp {\n-    fn from(ast_op: ast::BinOp) -> Self {\n-        match ast_op {\n-            ast::BinOp::BooleanOr => BinaryOp::LogicOp(LogicOp::Or),\n-            ast::BinOp::BooleanAnd => BinaryOp::LogicOp(LogicOp::And),\n-            ast::BinOp::EqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n-            ast::BinOp::NegatedEqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n-            ast::BinOp::LesserEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: false })\n-            }\n-            ast::BinOp::GreaterEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false })\n-            }\n-            ast::BinOp::LesserTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: true })\n-            }\n-            ast::BinOp::GreaterTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true })\n+impl fmt::Display for LogicOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let res = match self {\n+            LogicOp::And => \"&&\",\n+            LogicOp::Or => \"||\",\n+        };\n+        f.write_str(res)\n+    }\n+}\n+\n+impl fmt::Display for ArithOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let res = match self {\n+            ArithOp::Add => \"+\",\n+            ArithOp::Mul => \"*\",\n+            ArithOp::Sub => \"-\",\n+            ArithOp::Div => \"/\",\n+            ArithOp::Rem => \"%\",\n+            ArithOp::Shl => \"<<\",\n+            ArithOp::Shr => \">>\",\n+            ArithOp::BitXor => \"^\",\n+            ArithOp::BitOr => \"|\",\n+            ArithOp::BitAnd => \"&\",\n+        };\n+        f.write_str(res)\n+    }\n+}\n+\n+impl fmt::Display for CmpOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let res = match self {\n+            CmpOp::Eq { negated: false } => \"==\",\n+            CmpOp::Eq { negated: true } => \"!=\",\n+            CmpOp::Ord { ordering: Ordering::Less, strict: false } => \"<=\",\n+            CmpOp::Ord { ordering: Ordering::Less, strict: true } => \"<\",\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: false } => \">=\",\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: true } => \">\",\n+        };\n+        f.write_str(res)\n+    }\n+}\n+\n+impl fmt::Display for BinaryOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            BinaryOp::LogicOp(op) => fmt::Display::fmt(op, f),\n+            BinaryOp::ArithOp(op) => fmt::Display::fmt(op, f),\n+            BinaryOp::CmpOp(op) => fmt::Display::fmt(op, f),\n+            BinaryOp::Assignment { op } => {\n+                f.write_str(\"=\")?;\n+                if let Some(op) = op {\n+                    fmt::Display::fmt(op, f)?;\n+                }\n+                Ok(())\n             }\n-            ast::BinOp::Addition => BinaryOp::ArithOp(ArithOp::Add),\n-            ast::BinOp::Multiplication => BinaryOp::ArithOp(ArithOp::Mul),\n-            ast::BinOp::Subtraction => BinaryOp::ArithOp(ArithOp::Sub),\n-            ast::BinOp::Division => BinaryOp::ArithOp(ArithOp::Div),\n-            ast::BinOp::Remainder => BinaryOp::ArithOp(ArithOp::Rem),\n-            ast::BinOp::LeftShift => BinaryOp::ArithOp(ArithOp::Shl),\n-            ast::BinOp::RightShift => BinaryOp::ArithOp(ArithOp::Shr),\n-            ast::BinOp::BitwiseXor => BinaryOp::ArithOp(ArithOp::BitXor),\n-            ast::BinOp::BitwiseOr => BinaryOp::ArithOp(ArithOp::BitOr),\n-            ast::BinOp::BitwiseAnd => BinaryOp::ArithOp(ArithOp::BitAnd),\n-            ast::BinOp::Assignment => BinaryOp::Assignment { op: None },\n-            ast::BinOp::AddAssign => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n-            ast::BinOp::DivAssign => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n-            ast::BinOp::MulAssign => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n-            ast::BinOp::RemAssign => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n-            ast::BinOp::ShlAssign => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n-            ast::BinOp::ShrAssign => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n-            ast::BinOp::SubAssign => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n-            ast::BinOp::BitOrAssign => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n-            ast::BinOp::BitAndAssign => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n-            ast::BinOp::BitXorAssign => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n         }\n     }\n }"}]}