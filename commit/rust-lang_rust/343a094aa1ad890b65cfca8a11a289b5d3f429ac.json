{"sha": "343a094aa1ad890b65cfca8a11a289b5d3f429ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0M2EwOTRhYTFhZDg5MGI2NWNmY2E4YTExYTI4OWI1ZDNmNDI5YWM=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-05-07T06:20:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-07T06:20:26Z"}, "message": "Rollup merge of #84897 - richkadel:cover-closure-macros, r=tmandry\n\nCoverage instruments closure bodies in macros (not the macro body)\n\nFixes: #84884\n\nThis solution might be considered a compromise, but I think it is the\nbetter choice.\n\nThe results in the `closure.rs` test correctly resolve all test cases\nbroken as described in #84884.\n\nOne test pattern (in both `closure_macro.rs` and\n`closure_macro_async.rs`) was also affected, and removes coverage\nstatistics for the lines inside the closure, because the closure\nincludes a macro. (The coverage remains at the callsite of the macro, so\nwe lose some detail, but there isn't a perfect choice with macros.\n\nOften macro implementations are split across the macro and the callsite,\nand there doesn't appear to be a single \"right choice\" for which body\nshould be covered. For the current implementation, we can't do both.\n\nThe callsite is most likely to be the preferred site for coverage.\n\nr? `@tmandry`\ncc: `@wesleywiser`", "tree": {"sha": "4d59fb231323b3ada5fbf81d20a1839d445f844f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d59fb231323b3ada5fbf81d20a1839d445f844f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/343a094aa1ad890b65cfca8a11a289b5d3f429ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJglNwrCRBK7hj4Ov3rIwAAzGwIADWIyZ8JbsDPo+v/MSnQVir4\nWBKi4wnZaBb4GeNVBh7kLC2AlJiphEjIH1N5zBvmdf4LE53lwNOog6Mzp/PSIb6V\npzzf/DeKya0hbkggCzE95U9+cIP5UmLLncIRPIm4aClVeqwE3USv/CXYqKxmMkvF\nze9NvLe92nmjkxKXBg5DjqA7Pf9I4BSgbaHBFSkUl91l/aQlRb/xkSYXWubxlfvt\nZ4jAbLJmbsz0w2qYMtyGCYo20B0kvno/W1GbzXhtzYw2xAHpZZ328qdRlLFBICdY\nPRx/e7U4/mcRPb00KGFL6Qiz6Bn96HE3UCIXPIGyUm7eY9+nhZxIGBoyVjLF7pc=\n=wJyH\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d59fb231323b3ada5fbf81d20a1839d445f844f\nparent b088318985499c14630bdcf1629f3988da6432a7\nparent cb70221857d7a44bf4625f1a2d5af189f6a12495\nauthor Yuki Okushi <jtitor@2k36.org> 1620368426 +0900\ncommitter GitHub <noreply@github.com> 1620368426 +0900\n\nRollup merge of #84897 - richkadel:cover-closure-macros, r=tmandry\n\nCoverage instruments closure bodies in macros (not the macro body)\n\nFixes: #84884\n\nThis solution might be considered a compromise, but I think it is the\nbetter choice.\n\nThe results in the `closure.rs` test correctly resolve all test cases\nbroken as described in #84884.\n\nOne test pattern (in both `closure_macro.rs` and\n`closure_macro_async.rs`) was also affected, and removes coverage\nstatistics for the lines inside the closure, because the closure\nincludes a macro. (The coverage remains at the callsite of the macro, so\nwe lose some detail, but there isn't a perfect choice with macros.\n\nOften macro implementations are split across the macro and the callsite,\nand there doesn't appear to be a single \"right choice\" for which body\nshould be covered. For the current implementation, we can't do both.\n\nThe callsite is most likely to be the preferred site for coverage.\n\nr? `@tmandry`\ncc: `@wesleywiser`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/343a094aa1ad890b65cfca8a11a289b5d3f429ac", "html_url": "https://github.com/rust-lang/rust/commit/343a094aa1ad890b65cfca8a11a289b5d3f429ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/343a094aa1ad890b65cfca8a11a289b5d3f429ac/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b088318985499c14630bdcf1629f3988da6432a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b088318985499c14630bdcf1629f3988da6432a7", "html_url": "https://github.com/rust-lang/rust/commit/b088318985499c14630bdcf1629f3988da6432a7"}, {"sha": "cb70221857d7a44bf4625f1a2d5af189f6a12495", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb70221857d7a44bf4625f1a2d5af189f6a12495", "html_url": "https://github.com/rust-lang/rust/commit/cb70221857d7a44bf4625f1a2d5af189f6a12495"}], "stats": {"total": 241, "additions": 192, "deletions": 49}, "files": [{"sha": "c1e8f620b30c1dda7283b18eacc412256731bf79", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/343a094aa1ad890b65cfca8a11a289b5d3f429ac/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343a094aa1ad890b65cfca8a11a289b5d3f429ac/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=343a094aa1ad890b65cfca8a11a289b5d3f429ac", "patch": "@@ -32,7 +32,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::DefId;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{CharPos, Pos, SourceFile, Span, Symbol};\n+use rustc_span::{CharPos, ExpnKind, Pos, SourceFile, Span, Symbol};\n \n /// A simple error message wrapper for `coverage::Error`s.\n #[derive(Debug)]\n@@ -113,8 +113,29 @@ struct Instrumentor<'a, 'tcx> {\n impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     fn new(pass_name: &'a str, tcx: TyCtxt<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n         let source_map = tcx.sess.source_map();\n-        let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, mir_body.source.def_id());\n-        let body_span = hir_body.value.span;\n+        let def_id = mir_body.source.def_id();\n+        let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, def_id);\n+\n+        let mut body_span = hir_body.value.span;\n+\n+        if tcx.is_closure(def_id) {\n+            // If the MIR function is a closure, and if the closure body span\n+            // starts from a macro, but it's content is not in that macro, try\n+            // to find a non-macro callsite, and instrument the spans there\n+            // instead.\n+            loop {\n+                let expn_data = body_span.ctxt().outer_expn_data();\n+                if expn_data.is_root() {\n+                    break;\n+                }\n+                if let ExpnKind::Macro(..) = expn_data.kind {\n+                    body_span = expn_data.call_site;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n         let source_file = source_map.lookup_source_file(body_span.lo());\n         let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n             fn_sig.span.ctxt() == body_span.ctxt()"}, {"sha": "5715e0cc269f4f80eb0d06be405fbff921075527", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure.txt", "status": "modified", "additions": 84, "deletions": 22, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "raw_url": "https://github.com/rust-lang/rust/raw/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt?ref=343a094aa1ad890b65cfca8a11a289b5d3f429ac", "patch": "@@ -37,7 +37,7 @@\n    37|      0|            countdown = 10;\n    38|      0|        }\n    39|      0|        \"alt string 2\".to_owned()\n-   40|      1|    };\n+   40|      0|    };\n    41|      1|    println!(\n    42|      1|        \"The string or alt: {}\"\n    43|      1|        ,\n@@ -125,36 +125,98 @@\n   125|      0|            countdown = 10;\n   126|      0|        }\n   127|      0|        \"closure should be unused\".to_owned()\n-  128|      1|    };\n-  129|      1|\n+  128|      0|    };\n+  129|       |\n   130|      1|    let mut countdown = 10;\n   131|      1|    let _short_unused_closure = | _unused_arg: u8 | countdown += 1;\n                                                                   ^0\n-  132|      1|\n-  133|      1|    // Macros can sometimes confuse the coverage results. Compare this next assignment, with an\n-  134|      1|    // unused closure that invokes the `println!()` macro, with the closure assignment above, that\n-  135|      1|    // does not use a macro. The closure above correctly shows `0` executions.\n-  136|      1|    let _short_unused_closure = | _unused_arg: u8 | println!(\"not called\");\n-  137|      1|    // The closure assignment above is executed, with a line count of `1`, but the `println!()`\n-  138|      1|    // could not have been called, and yet, there is no indication that it wasn't...\n-  139|      1|\n-  140|      1|    // ...but adding block braces gives the expected result, showing the block was not executed.\n+  132|       |\n+  133|       |\n+  134|      1|    let short_used_covered_closure_macro = | used_arg: u8 | println!(\"called\");\n+  135|      1|    let short_used_not_covered_closure_macro = | used_arg: u8 | println!(\"not called\");\n+                                                                              ^0\n+  136|      1|    let _short_unused_closure_macro = | _unused_arg: u8 | println!(\"not called\");\n+                                                                        ^0\n+  137|       |\n+  138|       |\n+  139|       |\n+  140|       |\n   141|      1|    let _short_unused_closure_block = | _unused_arg: u8 | { println!(\"not called\") };\n                                                                         ^0\n-  142|      1|\n+  142|       |\n   143|      1|    let _shortish_unused_closure = | _unused_arg: u8 | {\n   144|      0|        println!(\"not called\")\n-  145|      1|    };\n-  146|      1|\n+  145|      0|    };\n+  146|       |\n   147|      1|    let _as_short_unused_closure = |\n   148|       |        _unused_arg: u8\n-  149|      1|    | { println!(\"not called\") };\n-                    ^0\n-  150|      1|\n+  149|      0|    | { println!(\"not called\") };\n+  150|       |\n   151|      1|    let _almost_as_short_unused_closure = |\n   152|       |        _unused_arg: u8\n-  153|      1|    | { println!(\"not called\") }\n-                    ^0\n-  154|      1|    ;\n-  155|      1|}\n+  153|      0|    | { println!(\"not called\") }\n+  154|       |    ;\n+  155|       |\n+  156|       |\n+  157|       |\n+  158|       |\n+  159|       |\n+  160|      1|    let _short_unused_closure_line_break_no_block = | _unused_arg: u8 |\n+  161|      0|println!(\"not called\")\n+  162|       |    ;\n+  163|       |\n+  164|      1|    let _short_unused_closure_line_break_no_block2 =\n+  165|       |        | _unused_arg: u8 |\n+  166|      0|            println!(\n+  167|      0|                \"not called\"\n+  168|      0|            )\n+  169|       |    ;\n+  170|       |\n+  171|      1|    let short_used_not_covered_closure_line_break_no_block_embedded_branch =\n+  172|      1|        | _unused_arg: u8 |\n+  173|      0|            println!(\n+  174|      0|                \"not called: {}\",\n+  175|      0|                if is_true { \"check\" } else { \"me\" }\n+  176|      0|            )\n+  177|       |    ;\n+  178|       |\n+  179|      1|    let short_used_not_covered_closure_line_break_block_embedded_branch =\n+  180|      1|        | _unused_arg: u8 |\n+  181|      0|        {\n+  182|      0|            println!(\n+  183|      0|                \"not called: {}\",\n+  184|      0|                if is_true { \"check\" } else { \"me\" }\n+  185|       |            )\n+  186|      0|        }\n+  187|       |    ;\n+  188|       |\n+  189|      1|    let short_used_covered_closure_line_break_no_block_embedded_branch =\n+  190|      1|        | _unused_arg: u8 |\n+  191|      1|            println!(\n+  192|      1|                \"not called: {}\",\n+  193|      1|                if is_true { \"check\" } else { \"me\" }\n+                                                            ^0\n+  194|      1|            )\n+  195|       |    ;\n+  196|       |\n+  197|      1|    let short_used_covered_closure_line_break_block_embedded_branch =\n+  198|      1|        | _unused_arg: u8 |\n+  199|      1|        {\n+  200|      1|            println!(\n+  201|      1|                \"not called: {}\",\n+  202|      1|                if is_true { \"check\" } else { \"me\" }\n+                                                            ^0\n+  203|       |            )\n+  204|      1|        }\n+  205|       |    ;\n+  206|       |\n+  207|      1|    if is_false {\n+  208|      0|        short_used_not_covered_closure_macro(0);\n+  209|      0|        short_used_not_covered_closure_line_break_no_block_embedded_branch(0);\n+  210|      0|        short_used_not_covered_closure_line_break_block_embedded_branch(0);\n+  211|      1|    }\n+  212|      1|    short_used_covered_closure_macro(0);\n+  213|      1|    short_used_covered_closure_line_break_no_block_embedded_branch(0);\n+  214|      1|    short_used_covered_closure_line_break_block_embedded_branch(0);\n+  215|      1|}\n "}, {"sha": "87f7014760edf345a5e262dae753eaf7b8bf3ba9", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt?ref=343a094aa1ad890b65cfca8a11a289b5d3f429ac", "patch": "@@ -14,15 +14,15 @@\n    14|       |\n    15|       |macro_rules! on_error {\n    16|       |    ($value:expr, $error_message:expr) => {\n-   17|      0|        $value.or_else(|e| {\n-   18|      0|            let message = format!($error_message, e);\n-   19|      0|            if message.len() > 0 {\n-   20|      0|                println!(\"{}\", message);\n-   21|      0|                Ok(String::from(\"ok\"))\n+   17|       |        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n+   18|       |            let message = format!($error_message, e);\n+   19|       |            if message.len() > 0 {\n+   20|       |                println!(\"{}\", message);\n+   21|       |                Ok(String::from(\"ok\"))\n    22|       |            } else {\n-   23|      0|                bail!(\"error\");\n+   23|       |                bail!(\"error\");\n    24|       |            }\n-   25|      0|        })\n+   25|       |        })\n    26|       |    };\n    27|       |}\n    28|       |"}, {"sha": "2b5418132c307227f6cd2686b886a5b8c0082032", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro_async.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt?ref=343a094aa1ad890b65cfca8a11a289b5d3f429ac", "patch": "@@ -14,15 +14,15 @@\n    14|       |\n    15|       |macro_rules! on_error {\n    16|       |    ($value:expr, $error_message:expr) => {\n-   17|      0|        $value.or_else(|e| {\n-   18|      0|            let message = format!($error_message, e);\n-   19|      0|            if message.len() > 0 {\n-   20|      0|                println!(\"{}\", message);\n-   21|      0|                Ok(String::from(\"ok\"))\n+   17|       |        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n+   18|       |            let message = format!($error_message, e);\n+   19|       |            if message.len() > 0 {\n+   20|       |                println!(\"{}\", message);\n+   21|       |                Ok(String::from(\"ok\"))\n    22|       |            } else {\n-   23|      0|                bail!(\"error\");\n+   23|       |                bail!(\"error\");\n    24|       |            }\n-   25|      0|        })\n+   25|       |        })\n    26|       |    };\n    27|       |}\n    28|       |"}, {"sha": "32ec0bcdf8c99d4467a713b5a619884f978ca648", "filename": "src/test/run-make-fulldeps/coverage/closure.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure.rs?ref=343a094aa1ad890b65cfca8a11a289b5d3f429ac", "patch": "@@ -130,14 +130,14 @@ fn main() {\n     let mut countdown = 10;\n     let _short_unused_closure = | _unused_arg: u8 | countdown += 1;\n \n-    // Macros can sometimes confuse the coverage results. Compare this next assignment, with an\n-    // unused closure that invokes the `println!()` macro, with the closure assignment above, that\n-    // does not use a macro. The closure above correctly shows `0` executions.\n-    let _short_unused_closure = | _unused_arg: u8 | println!(\"not called\");\n-    // The closure assignment above is executed, with a line count of `1`, but the `println!()`\n-    // could not have been called, and yet, there is no indication that it wasn't...\n-\n-    // ...but adding block braces gives the expected result, showing the block was not executed.\n+\n+    let short_used_covered_closure_macro = | used_arg: u8 | println!(\"called\");\n+    let short_used_not_covered_closure_macro = | used_arg: u8 | println!(\"not called\");\n+    let _short_unused_closure_macro = | _unused_arg: u8 | println!(\"not called\");\n+\n+\n+\n+\n     let _short_unused_closure_block = | _unused_arg: u8 | { println!(\"not called\") };\n \n     let _shortish_unused_closure = | _unused_arg: u8 | {\n@@ -152,4 +152,64 @@ fn main() {\n         _unused_arg: u8\n     | { println!(\"not called\") }\n     ;\n+\n+\n+\n+\n+\n+    let _short_unused_closure_line_break_no_block = | _unused_arg: u8 |\n+println!(\"not called\")\n+    ;\n+\n+    let _short_unused_closure_line_break_no_block2 =\n+        | _unused_arg: u8 |\n+            println!(\n+                \"not called\"\n+            )\n+    ;\n+\n+    let short_used_not_covered_closure_line_break_no_block_embedded_branch =\n+        | _unused_arg: u8 |\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+    ;\n+\n+    let short_used_not_covered_closure_line_break_block_embedded_branch =\n+        | _unused_arg: u8 |\n+        {\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+        }\n+    ;\n+\n+    let short_used_covered_closure_line_break_no_block_embedded_branch =\n+        | _unused_arg: u8 |\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+    ;\n+\n+    let short_used_covered_closure_line_break_block_embedded_branch =\n+        | _unused_arg: u8 |\n+        {\n+            println!(\n+                \"not called: {}\",\n+                if is_true { \"check\" } else { \"me\" }\n+            )\n+        }\n+    ;\n+\n+    if is_false {\n+        short_used_not_covered_closure_macro(0);\n+        short_used_not_covered_closure_line_break_no_block_embedded_branch(0);\n+        short_used_not_covered_closure_line_break_block_embedded_branch(0);\n+    }\n+    short_used_covered_closure_macro(0);\n+    short_used_covered_closure_line_break_no_block_embedded_branch(0);\n+    short_used_covered_closure_line_break_block_embedded_branch(0);\n }"}, {"sha": "5e3b00d1ef54b4c34a1121f6929a8cf8ef9fe7b1", "filename": "src/test/run-make-fulldeps/coverage/closure_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs?ref=343a094aa1ad890b65cfca8a11a289b5d3f429ac", "patch": "@@ -14,7 +14,7 @@ macro_rules! bail {\n \n macro_rules! on_error {\n     ($value:expr, $error_message:expr) => {\n-        $value.or_else(|e| {\n+        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n             let message = format!($error_message, e);\n             if message.len() > 0 {\n                 println!(\"{}\", message);"}, {"sha": "e3e89e9c8b3c987e675d463c4b4ad9c5de4b209b", "filename": "src/test/run-make-fulldeps/coverage/closure_macro_async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343a094aa1ad890b65cfca8a11a289b5d3f429ac/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs?ref=343a094aa1ad890b65cfca8a11a289b5d3f429ac", "patch": "@@ -14,7 +14,7 @@ macro_rules! bail {\n \n macro_rules! on_error {\n     ($value:expr, $error_message:expr) => {\n-        $value.or_else(|e| {\n+        $value.or_else(|e| { // FIXME(85000): no coverage in closure macros\n             let message = format!($error_message, e);\n             if message.len() > 0 {\n                 println!(\"{}\", message);"}]}