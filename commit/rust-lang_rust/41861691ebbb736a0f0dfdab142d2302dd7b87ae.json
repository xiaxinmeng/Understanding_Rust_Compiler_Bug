{"sha": "41861691ebbb736a0f0dfdab142d2302dd7b87ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxODYxNjkxZWJiYjczNmEwZjBkZmRhYjE0MmQyMzAyZGQ3Yjg3YWU=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2016-05-01T10:22:05Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2016-05-01T10:26:34Z"}, "message": "libsyntax/pp: replace manual ring buffer with a VecDeque", "tree": {"sha": "fb91230a07cea4e32eea37ee6895e0f3ceb70d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb91230a07cea4e32eea37ee6895e0f3ceb70d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41861691ebbb736a0f0dfdab142d2302dd7b87ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41861691ebbb736a0f0dfdab142d2302dd7b87ae", "html_url": "https://github.com/rust-lang/rust/commit/41861691ebbb736a0f0dfdab142d2302dd7b87ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41861691ebbb736a0f0dfdab142d2302dd7b87ae/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eef0831cbb930157d117d5ca5478962ea883373", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eef0831cbb930157d117d5ca5478962ea883373", "html_url": "https://github.com/rust-lang/rust/commit/3eef0831cbb930157d117d5ca5478962ea883373"}], "stats": {"total": 71, "additions": 19, "deletions": 52}, "files": [{"sha": "4a92ad8ddb26d8c20f55fe45dbfa9ae9de17f475", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/41861691ebbb736a0f0dfdab142d2302dd7b87ae/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41861691ebbb736a0f0dfdab142d2302dd7b87ae/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=41861691ebbb736a0f0dfdab142d2302dd7b87ae", "patch": "@@ -61,6 +61,7 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n+use std::collections::VecDeque;\n use std::fmt;\n use std::io;\n \n@@ -164,7 +165,7 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     debug!(\"mk_printer {}\", linewidth);\n     let token = vec![Token::Eof; n];\n     let size = vec![0; n];\n-    let scan_stack = vec![0; n];\n+    let scan_stack = VecDeque::with_capacity(n);\n     Printer {\n         out: out,\n         buf_len: n,\n@@ -177,9 +178,6 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n         left_total: 0,\n         right_total: 0,\n         scan_stack: scan_stack,\n-        scan_stack_empty: true,\n-        top: 0,\n-        bottom: 0,\n         print_stack: Vec::new(),\n         pending_indentation: 0\n     }\n@@ -241,9 +239,8 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n /// approximation for purposes of line breaking).\n ///\n /// The \"input side\" of the printer is managed as an abstract process called\n-/// SCAN, which uses 'scan_stack', 'scan_stack_empty', 'top' and 'bottom', to\n-/// manage calculating 'size'. SCAN is, in other words, the process of\n-/// calculating 'size' entries.\n+/// SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n+/// other words, the process of calculating 'size' entries.\n ///\n /// The \"output side\" of the printer is managed by an abstract process called\n /// PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n@@ -286,13 +283,7 @@ pub struct Printer<'a> {\n     /// Begin (if there is any) on top of it. Stuff is flushed off the\n     /// bottom as it becomes irrelevant due to the primary ring-buffer\n     /// advancing.\n-    scan_stack: Vec<usize> ,\n-    /// Top==bottom disambiguator\n-    scan_stack_empty: bool,\n-    /// Index of top of scan_stack\n-    top: usize,\n-    /// Index of bottom of scan_stack\n-    bottom: usize,\n+    scan_stack: VecDeque<usize> ,\n     /// Stack of blocks-in-progress being flushed by print\n     print_stack: Vec<PrintStackElem> ,\n     /// Buffered indentation to avoid writing trailing whitespace\n@@ -311,15 +302,15 @@ impl<'a> Printer<'a> {\n         debug!(\"pp Vec<{},{}>\", self.left, self.right);\n         match token {\n           Token::Eof => {\n-            if !self.scan_stack_empty {\n+            if !self.scan_stack.is_empty() {\n                 self.check_stack(0);\n                 self.advance_left()?;\n             }\n             self.indent(0);\n             Ok(())\n           }\n           Token::Begin(b) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 self.left_total = 1;\n                 self.right_total = 1;\n                 self.left = 0;\n@@ -334,7 +325,7 @@ impl<'a> Printer<'a> {\n             Ok(())\n           }\n           Token::End => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n                 self.print(token, 0)\n             } else {\n@@ -348,7 +339,7 @@ impl<'a> Printer<'a> {\n             }\n           }\n           Token::Break(b) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 self.left_total = 1;\n                 self.right_total = 1;\n                 self.left = 0;\n@@ -365,7 +356,7 @@ impl<'a> Printer<'a> {\n             Ok(())\n           }\n           Token::String(s, len) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 debug!(\"pp String('{}')/print Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.print(Token::String(s, len), len)\n@@ -387,12 +378,10 @@ impl<'a> Printer<'a> {\n         if self.right_total - self.left_total > self.space {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n-            if !self.scan_stack_empty {\n-                if self.left == self.scan_stack[self.bottom] {\n-                    debug!(\"setting {} to infinity and popping\", self.left);\n-                    let scanned = self.scan_pop_bottom();\n-                    self.size[scanned] = SIZE_INFINITY;\n-                }\n+            if Some(&self.left) == self.scan_stack.back() {\n+                debug!(\"setting {} to infinity and popping\", self.left);\n+                let scanned = self.scan_pop_bottom();\n+                self.size[scanned] = SIZE_INFINITY;\n             }\n             self.advance_left()?;\n             if self.left != self.right {\n@@ -403,38 +392,16 @@ impl<'a> Printer<'a> {\n     }\n     pub fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n-        if self.scan_stack_empty {\n-            self.scan_stack_empty = false;\n-        } else {\n-            self.top += 1;\n-            self.top %= self.buf_len;\n-            assert!(self.top != self.bottom);\n-        }\n-        self.scan_stack[self.top] = x;\n+        self.scan_stack.push_front(x);\n     }\n     pub fn scan_pop(&mut self) -> usize {\n-        assert!(!self.scan_stack_empty);\n-        let x = self.scan_stack[self.top];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.top += self.buf_len - 1; self.top %= self.buf_len;\n-        }\n-        x\n+        self.scan_stack.pop_front().unwrap()\n     }\n     pub fn scan_top(&mut self) -> usize {\n-        assert!(!self.scan_stack_empty);\n-        self.scan_stack[self.top]\n+        *self.scan_stack.front().unwrap()\n     }\n     pub fn scan_pop_bottom(&mut self) -> usize {\n-        assert!(!self.scan_stack_empty);\n-        let x = self.scan_stack[self.bottom];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.bottom += 1; self.bottom %= self.buf_len;\n-        }\n-        x\n+        self.scan_stack.pop_back().unwrap()\n     }\n     pub fn advance_right(&mut self) {\n         self.right += 1;\n@@ -476,7 +443,7 @@ impl<'a> Printer<'a> {\n         Ok(())\n     }\n     pub fn check_stack(&mut self, k: isize) {\n-        if !self.scan_stack_empty {\n+        if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n             match self.token[x] {\n                 Token::Begin(_) => {"}]}