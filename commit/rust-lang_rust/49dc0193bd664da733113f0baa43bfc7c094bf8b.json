{"sha": "49dc0193bd664da733113f0baa43bfc7c094bf8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZGMwMTkzYmQ2NjRkYTczMzExM2YwYmFhNDNiZmM3YzA5NGJmOGI=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-04-01T14:27:40Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-04-02T15:17:21Z"}, "message": "middle: trans: base: remove dead code", "tree": {"sha": "4d6c845c4a4ea7844e948e3f2066fc58fd7e6646", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d6c845c4a4ea7844e948e3f2066fc58fd7e6646"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49dc0193bd664da733113f0baa43bfc7c094bf8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49dc0193bd664da733113f0baa43bfc7c094bf8b", "html_url": "https://github.com/rust-lang/rust/commit/49dc0193bd664da733113f0baa43bfc7c094bf8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49dc0193bd664da733113f0baa43bfc7c094bf8b/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9bf0990003d5d27bc30a9018bb5cdc0666be916", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bf0990003d5d27bc30a9018bb5cdc0666be916", "html_url": "https://github.com/rust-lang/rust/commit/a9bf0990003d5d27bc30a9018bb5cdc0666be916"}], "stats": {"total": 79, "additions": 2, "deletions": 77}, "files": [{"sha": "133634a9e791cf94dfb36144d1cfb9bb48fff279", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/49dc0193bd664da733113f0baa43bfc7c094bf8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dc0193bd664da733113f0baa43bfc7c094bf8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=49dc0193bd664da733113f0baa43bfc7c094bf8b", "patch": "@@ -77,13 +77,11 @@ use std::cell::{Cell, RefCell};\n use std::libc::c_uint;\n use std::local_data;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n-use syntax::ast_map::PathName;\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};\n@@ -447,10 +445,6 @@ pub fn malloc_general<'a>(bcx: &'a Block<'a>, t: ty::t, heap: heap)\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc_simple(ccx: &CrateContext, t: ty::t) -> ValueRef {\n-    get_tydesc(ccx, t).tydesc\n-}\n-\n pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     match ccx.tydescs.borrow().find(&t) {\n         Some(&inf) => return inf,\n@@ -464,6 +458,7 @@ pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     return inf;\n }\n \n+#[allow(dead_code)] // useful\n pub fn set_optimize_for_size(f: ValueRef) {\n     lib::llvm::SetFunctionAttribute(f, lib::llvm::OptimizeForSizeAttribute)\n }\n@@ -472,6 +467,7 @@ pub fn set_no_inline(f: ValueRef) {\n     lib::llvm::SetFunctionAttribute(f, lib::llvm::NoInlineAttribute)\n }\n \n+#[allow(dead_code)] // useful\n pub fn set_no_unwind(f: ValueRef) {\n     lib::llvm::SetFunctionAttribute(f, lib::llvm::NoUnwindAttribute)\n }\n@@ -667,19 +663,6 @@ pub fn compare_scalar_values<'a>(\n pub type val_and_ty_fn<'r,'b> =\n     'r |&'b Block<'b>, ValueRef, ty::t| -> &'b Block<'b>;\n \n-pub fn load_inbounds<'a>(cx: &'a Block<'a>, p: ValueRef, idxs: &[uint])\n-                     -> ValueRef {\n-    return Load(cx, GEPi(cx, p, idxs));\n-}\n-\n-pub fn store_inbounds<'a>(\n-                      cx: &'a Block<'a>,\n-                      v: ValueRef,\n-                      p: ValueRef,\n-                      idxs: &[uint]) {\n-    Store(cx, v, GEPi(cx, p, idxs));\n-}\n-\n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty<'r,\n                           'b>(\n@@ -975,29 +958,6 @@ pub fn need_invoke(bcx: &Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn do_spill(bcx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n-    if ty::type_is_bot(t) {\n-        return C_null(Type::i8p(bcx.ccx()));\n-    }\n-    let llptr = alloc_ty(bcx, t, \"\");\n-    Store(bcx, v, llptr);\n-    return llptr;\n-}\n-\n-// Since this function does *not* root, it is the caller's responsibility to\n-// ensure that the referent is pointed to by a root.\n-pub fn do_spill_noroot(cx: &Block, v: ValueRef) -> ValueRef {\n-    let llptr = alloca(cx, val_ty(v), \"\");\n-    Store(cx, v, llptr);\n-    return llptr;\n-}\n-\n-pub fn spill_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = push_ctxt(\"spill_if_immediate\");\n-    if type_is_immediate(cx.ccx(), t) { return do_spill(cx, v, t); }\n-    return v;\n-}\n-\n pub fn load_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n@@ -1040,20 +1000,6 @@ pub fn raw_block<'a>(\n     Block::new(llbb, is_lpad, None, fcx)\n }\n \n-pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n-    for s in b.stmts.iter() {\n-        match s.node {\n-          ast::StmtDecl(d, _) => {\n-            match d.node {\n-              ast::DeclLocal(ref local) => it(*local),\n-              _ => {} /* fall through */\n-            }\n-          }\n-          _ => {} /* fall through */\n-        }\n-    }\n-}\n-\n pub fn with_cond<'a>(\n                  bcx: &'a Block<'a>,\n                  val: ValueRef,\n@@ -1173,10 +1119,6 @@ pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n     return ArrayAlloca(cx, ty, v);\n }\n \n-pub struct BasicBlocks {\n-    sa: BasicBlockRef,\n-}\n-\n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n@@ -2142,11 +2084,6 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n     llfn\n }\n \n-pub fn vp2i(cx: &Block, v: ValueRef) -> ValueRef {\n-    let ccx = cx.ccx();\n-    return PtrToInt(cx, v, ccx.int_type);\n-}\n-\n pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstPtrToInt(v, ccx.int_type.to_ref());\n@@ -2315,18 +2252,6 @@ pub fn declare_intrinsics(ccx: &mut CrateContext) {\n     }\n }\n \n-pub fn trap(bcx: &Block) {\n-    match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n-      Some(&x) => { Call(bcx, x, [], []); },\n-      _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n-    }\n-}\n-\n-pub fn symname(name: &str, hash: &str, vers: &str) -> ~str {\n-    let path = [PathName(token::intern(name))];\n-    link::exported_name(ast_map::Values(path.iter()).chain(None), hash, vers)\n-}\n-\n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n "}]}