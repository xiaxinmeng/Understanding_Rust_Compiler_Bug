{"sha": "d6bf04a22e78afbe62e9d81e3578418f420123bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YmYwNGEyMmU3OGFmYmU2MmU5ZDgxZTM1Nzg0MThmNDIwMTIzYmM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-01-26T11:48:19Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-01-27T09:26:52Z"}, "message": "Add `CodeExtent::Remainder` variant; pre-req for new scoping/drop rules.\n\nThis new variant introduces finer-grain code extents, i.e. we now\ntrack that a binding lives only for a suffix of a block, and\n(importantly) will be dropped when it goes out of scope *before* the\nbindings that occurred earlier in the block.\n\nBoth of these notions are neatly captured by marking the block (and\neach suffix) as an enclosing scope of the next suffix beneath it.\n\nThis is work that is part of the foundation for issue #8861.\n\n(It actually has been seen in earlier posted pull requests; I have\njust factored it out into its own PR to ease my own rebasing.)\n\n----\n\nThese finer grained scopes do mean that some code is newly rejected by\n`rustc`; for example:\n\n```rust\nlet mut map : HashMap<u8, &u8> = HashMap::new();\nlet tmp = Box::new(2);\nmap.insert(43, &*tmp);\n```\n\nThis will now fail to compile with a message that `*tmp` does not live\nlong enough, because the scope of `tmp` is now strictly smaller than\nthat of `map`, and the use of `&u8` in map's type requires that the\nborrowed references are all to data that live at least as long as the\nmap.\n\nThe usual fix for a case like this is to move the binding for `tmp`\nup above that of `map`; note that you can still leave the initialization\nin the original spot, like so:\n\n```rust\nlet tmp;\nlet mut map : HashMap<u8, &u8> = HashMap::new();\ntmp = box 2;\nmap.insert(43, &*tmp);\n```\n\nSimilarly, one can encounter an analogous situation with `Vec`: one\nwould need to rewrite:\n\n```rust\nlet mut vec = Vec::new();\nlet tmp = 'c';\nvec.push(&tmp);\n```\n\nas:\n\n```\nlet tmp;\nlet mut vec = Vec::new();\ntmp = 'c';\nvec.push(&tmp);\n```\n\n----\n\nIn some corner cases, it does not suffice to reorder the bindings; in\nparticular, when the types for both bindings need to reflect exactly\nthe *same* code extent, and a parent/child relationship between them\ndoes not work.\n\nIn pnkfelix's experience this has arisen most often when mixing uses\nof cyclic data structures while also allowing a lifetime parameter\n`'a` to flow into a type parameter context where the type is\n*invariant* with respect to the type parameter. An important instance\nof this is `arena::TypedArena<T>`, which is invariant with respect\nto `T`.\n\n(The reason that variance is relevant is this: *if* `TypedArena` were\ncovariant with respect to its type parameter, then we could assign it\nthe longer lifetime when it is initialized, and then convert it to a\nsubtype (via covariance) with a shorter lifetime when necessary.  But\n`TypedArena` is invariant with respect to its type parameter, and thus\nif `S` is a subtype of `T` (in particular, if `S` has a lifetime\nparameter that is shorter than that of `T`), then a `TypedArena<S>` is\nunrelated to `TypedArena<T>`.)\n\nConcretely, consider code like this:\n\n```rust\nstruct Node<'a> { sibling: Option<&'a Node<'a>> }\nstruct Context<'a> {\n    // because of this field, `Context<'a>` is invariant with respect to `'a`.\n    arena: &'a TypedArena<Node<'a>>,\n    ...\n}\nfn new_ctxt<'a>(arena: &'a TypedArena<Node<'a>>) -> Context<'a> { ... }\nfn use_ctxt<'a>(fcx: &'a Context<'a>) { ... }\n\nlet arena = TypedArena::new();\nlet ctxt = new_ctxt(&arena);\n\nuse_ctxt(&ctxt);\n```\n\nIn these situations, if you try to introduce two bindings via two\ndistinct `let` statements, each is (with this commit) assigned a\ndistinct extent, and the region inference system cannot find a single\nregion to assign to the lifetime `'a` that works for both of the\nbindings. So you get an error that `ctxt` does not live long enough;\nbut moving its binding up above that of `arena` just shifts the error\nso now the compiler complains that `arena` does not live long enough.\n\nSO: What to do? The easiest fix in this case is to ensure that the two\nbindings *do* get assigned the same static extent, by stuffing both\nbindings into the same let statement, like so:\n\n```rust\nlet (arena, ctxt): (TypedArena, Context);\narena = TypedArena::new();\nctxt = new_ctxt(&arena);\n\nuse_ctxt(&ctxt);\n```\n\nDue to the new code rejections outlined above, this is a ...\n\n[breaking-change]", "tree": {"sha": "caa3d0bd07262b015b59ef062090d3fe7cfc926b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caa3d0bd07262b015b59ef062090d3fe7cfc926b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6bf04a22e78afbe62e9d81e3578418f420123bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bf04a22e78afbe62e9d81e3578418f420123bc", "html_url": "https://github.com/rust-lang/rust/commit/d6bf04a22e78afbe62e9d81e3578418f420123bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6bf04a22e78afbe62e9d81e3578418f420123bc/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43d08f861a3cca10f385e8f7ec34f85d7b9f54dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/43d08f861a3cca10f385e8f7ec34f85d7b9f54dc", "html_url": "https://github.com/rust-lang/rust/commit/43d08f861a3cca10f385e8f7ec34f85d7b9f54dc"}], "stats": {"total": 432, "additions": 351, "deletions": 81}, "files": [{"sha": "2ee4b6fbbd4ad676134f65d678c56a6ac8b38f32", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d6bf04a22e78afbe62e9d81e3578418f420123bc", "patch": "@@ -377,6 +377,14 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n             let node_id = parse_uint(st) as ast::NodeId;\n             region::CodeExtent::Misc(node_id)\n         }\n+        'B' => {\n+            let node_id = parse_uint(st) as ast::NodeId;\n+            let first_stmt_index = parse_uint(st);\n+            let block_remainder = region::BlockRemainder {\n+                block: node_id, first_statement_index: first_stmt_index,\n+            };\n+            region::CodeExtent::Remainder(block_remainder)\n+        }\n         _ => panic!(\"parse_scope: bad input\")\n     }\n }"}, {"sha": "2dc334bfe95fceb039557116d9f3b79c03a30717", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=d6bf04a22e78afbe62e9d81e3578418f420123bc", "patch": "@@ -276,7 +276,9 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n \n fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n     match scope {\n-        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id)\n+        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n+        region::CodeExtent::Remainder(region::BlockRemainder {\n+            block: b, first_statement_index: i }) => mywrite!(w, \"B{}{}\", b, i),\n     }\n }\n "}, {"sha": "9bba01f8af771b904b9dfe500072b9bb363da4b9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 238, "deletions": 51, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d6bf04a22e78afbe62e9d81e3578418f420123bc", "patch": "@@ -26,6 +26,7 @@ use syntax::codemap::{self, Span};\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n+use syntax::ast_map;\n use syntax::visit::{Visitor, FnKind};\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -38,7 +39,32 @@ use syntax::visit::{Visitor, FnKind};\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n            RustcDecodable, Show, Copy)]\n pub enum CodeExtent {\n-    Misc(ast::NodeId)\n+    Misc(ast::NodeId),\n+    Remainder(BlockRemainder),\n+}\n+\n+/// Represents a subscope of `block` for a binding that is introduced\n+/// by `block.stmts[first_statement_index]`. Such subscopes represent\n+/// a suffix of the block. Note that each subscope does not include\n+/// the initializer expression, if any, for the statement indexed by\n+/// `first_statement_index`.\n+///\n+/// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n+///\n+/// * the subscope with `first_statement_index == 0` is scope of both\n+///   `a` and `b`; it does not include EXPR_1, but does include\n+///   everything after that first `let`. (If you want a scope that\n+///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n+///   but instead another `CodeExtent` that encompasses the whole block,\n+///   e.g. `CodeExtent::Misc`.\n+///\n+/// * the subscope with `first_statement_index == 1` is scope of `c`,\n+///   and thus does not include EXPR_2, but covers the `...`.\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+         RustcDecodable, Show, Copy)]\n+pub struct BlockRemainder {\n+    pub block: ast::NodeId,\n+    pub first_statement_index: uint,\n }\n \n impl CodeExtent {\n@@ -55,6 +81,7 @@ impl CodeExtent {\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n             CodeExtent::Misc(node_id) => node_id,\n+            CodeExtent::Remainder(br) => br.block,\n         }\n     }\n \n@@ -65,16 +92,50 @@ impl CodeExtent {\n     {\n         match *self {\n             CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n+            CodeExtent::Remainder(br) =>\n+                CodeExtent::Remainder(BlockRemainder {\n+                    block: f_id(br.block), first_statement_index: br.first_statement_index }),\n         }\n     }\n+\n+    /// Returns the span of this CodeExtent.  Note that in general the\n+    /// returned span may not correspond to the span of any node id in\n+    /// the AST.\n+    pub fn span(&self, ast_map: &ast_map::Map) -> Option<Span> {\n+        match ast_map.find(self.node_id()) {\n+            Some(ast_map::NodeBlock(ref blk)) => {\n+                match *self {\n+                    CodeExtent::Misc(_) => Some(blk.span),\n+\n+                    CodeExtent::Remainder(r) => {\n+                        assert_eq!(r.block, blk.id);\n+                        // Want span for extent starting after the\n+                        // indexed statement and ending at end of\n+                        // `blk`; reuse span of `blk` and shift `lo`\n+                        // forward to end of indexed statement.\n+                        //\n+                        // (This is the special case aluded to in the\n+                        // doc-comment for this method)\n+                        let stmt_span = blk.stmts[r.first_statement_index].span;\n+                        Some(Span { lo: stmt_span.hi, ..blk.span })\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeExpr(ref expr)) => Some(expr.span),\n+            Some(ast_map::NodeStmt(ref stmt)) => Some(stmt.span),\n+            Some(ast_map::NodeItem(ref item)) => Some(item.span),\n+            Some(_) | None => None,\n+         }\n+    }\n }\n \n /// The region maps encode information about region relationships.\n ///\n /// - `scope_map` maps from a scope id to the enclosing scope id; this is\n ///   usually corresponding to the lexical nesting, though in the case of\n ///   closures the parent scope is the innermost conditional expression or repeating\n-///   block\n+///   block. (Note that the enclosing scope id for the block\n+///   associated with a closure is the closure itself.)\n ///\n /// - `var_map` maps from a variable or binding id to the block in which\n ///   that variable is declared.\n@@ -115,12 +176,77 @@ pub struct RegionMaps {\n     terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n }\n \n-#[derive(Copy)]\n+/// Carries the node id for the innermost block or match expression,\n+/// for building up the `var_map` which maps ids to the blocks in\n+/// which they were declared.\n+#[derive(PartialEq, Eq, Show, Copy)]\n+enum InnermostDeclaringBlock {\n+    None,\n+    Block(ast::NodeId),\n+    Statement(DeclaringStatementContext),\n+    Match(ast::NodeId),\n+}\n+\n+impl InnermostDeclaringBlock {\n+    fn to_code_extent(&self) -> Option<CodeExtent> {\n+        let extent = match *self {\n+            InnermostDeclaringBlock::None => {\n+                return Option::None;\n+            }\n+            InnermostDeclaringBlock::Block(id) |\n+            InnermostDeclaringBlock::Match(id) => CodeExtent::from_node_id(id),\n+            InnermostDeclaringBlock::Statement(s) =>  s.to_code_extent(),\n+        };\n+        Option::Some(extent)\n+    }\n+}\n+\n+/// Contextual information for declarations introduced by a statement\n+/// (i.e. `let`). It carries node-id's for statement and enclosing\n+/// block both, as well as the statement's index within the block.\n+#[derive(PartialEq, Eq, Show, Copy)]\n+struct DeclaringStatementContext {\n+    stmt_id: ast::NodeId,\n+    block_id: ast::NodeId,\n+    stmt_index: uint,\n+}\n+\n+impl DeclaringStatementContext {\n+    fn to_code_extent(&self) -> CodeExtent {\n+        CodeExtent::Remainder(BlockRemainder {\n+            block: self.block_id,\n+            first_statement_index: self.stmt_index,\n+        })\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Show, Copy)]\n+enum InnermostEnclosingExpr {\n+    None,\n+    Some(ast::NodeId),\n+    Statement(DeclaringStatementContext),\n+}\n+\n+impl InnermostEnclosingExpr {\n+    fn to_code_extent(&self) -> Option<CodeExtent> {\n+        let extent = match *self {\n+            InnermostEnclosingExpr::None => {\n+                return Option::None;\n+            }\n+            InnermostEnclosingExpr::Statement(s) =>\n+                s.to_code_extent(),\n+            InnermostEnclosingExpr::Some(parent_id) =>\n+                CodeExtent::from_node_id(parent_id),\n+        };\n+        Some(extent)\n+    }\n+}\n+\n+#[derive(Show, Copy)]\n pub struct Context {\n-    var_parent: Option<ast::NodeId>,\n+    var_parent: InnermostDeclaringBlock,\n \n-    // Innermost enclosing expression\n-    parent: Option<ast::NodeId>,\n+    parent: InnermostEnclosingExpr,\n }\n \n struct RegionResolutionVisitor<'a> {\n@@ -381,16 +507,13 @@ impl RegionMaps {\n     }\n }\n \n-/// Records the current parent (if any) as the parent of `child_id`.\n+/// Records the current parent (if any) as the parent of `child_scope`.\n fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n-                        child_id: ast::NodeId,\n+                        child_scope: CodeExtent,\n                         _sp: Span) {\n-    match visitor.cx.parent {\n-        Some(parent_id) => {\n-            let child_scope = CodeExtent::from_node_id(child_id);\n-            let parent_scope = CodeExtent::from_node_id(parent_id);\n-            visitor.region_maps.record_encl_scope(child_scope, parent_scope);\n-        }\n+    match visitor.cx.parent.to_code_extent() {\n+        Some(parent_scope) =>\n+            visitor.region_maps.record_encl_scope(child_scope, parent_scope),\n         None => {}\n     }\n }\n@@ -399,11 +522,9 @@ fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n-    match visitor.cx.var_parent {\n-        Some(parent_id) => {\n-            let parent_scope = CodeExtent::from_node_id(parent_id);\n-            visitor.region_maps.record_var_scope(var_id, parent_scope);\n-        }\n+    match visitor.cx.var_parent.to_code_extent() {\n+        Some(parent_scope) =>\n+            visitor.region_maps.record_var_scope(var_id, parent_scope),\n         None => {\n             // this can happen in extern fn declarations like\n             //\n@@ -415,21 +536,72 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n-    // Record the parent of this block.\n-    record_superlifetime(visitor, blk.id, blk.span);\n+    let prev_cx = visitor.cx;\n+\n+    let blk_scope = CodeExtent::Misc(blk.id);\n+    record_superlifetime(visitor, blk_scope, blk.span);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n-    // temporary lifetimes. If the user writes:\n+    // temporary lifetimes. Consider the following:\n     //\n-    //   {\n-    //     ... (&foo()) ...\n-    //   }\n+    //    quux({\n+    //        let inner = ... (&bar()) ...;\n     //\n+    //        (... (&foo()) ...) // (the tail expression)\n+    //    }, other_argument());\n+    //\n+    // Each of the statements within the block is a terminating\n+    // scope, and thus a temporary (e.g. the result of calling\n+    // `bar()` in the initalizer expression for `let inner = ...;`)\n+    // will be cleaned up immediately after its corresponding\n+    // statement (i.e. `let inner = ...;`) executes.\n+    //\n+    // On the other hand, temporaries associated with evaluating the\n+    // tail expression for the block are assigned lifetimes so that\n+    // they will be cleaned up as part of the terminating scope\n+    // *surrounding* the block expression. Here, the terminating\n+    // scope for the block expression is the `quux(..)` call; so\n+    // those temporaries will only be cleaned up *after* both\n+    // `other_argument()` has run and also the call to `quux(..)`\n+    // itself has returned.\n+\n+    visitor.cx = Context {\n+        var_parent: InnermostDeclaringBlock::Block(blk.id),\n+        parent: InnermostEnclosingExpr::Some(blk.id),\n+    };\n+\n+    {\n+        // This block should be kept approximately in sync with\n+        // `visit::walk_block`. (We manually walk the block, rather\n+        // than call `walk_block`, in order to maintain precise\n+        // `InnermostDeclaringBlock` information.)\n+\n+        for (i, statement) in blk.stmts.iter().enumerate() {\n+            if let ast::StmtDecl(_, stmt_id) = statement.node {\n+                // Each StmtDecl introduces a subscope for bindings\n+                // introduced by the declaration; this subscope covers\n+                // a suffix of the block . Each subscope in a block\n+                // has the previous subscope in the block as a parent,\n+                // except for the first such subscope, which has the\n+                // block itself as a parent.\n+                let declaring = DeclaringStatementContext {\n+                    stmt_id: stmt_id,\n+                    block_id: blk.id,\n+                    stmt_index: i,\n+                };\n+                record_superlifetime(\n+                    visitor, declaring.to_code_extent(), statement.span);\n+                visitor.cx = Context {\n+                    var_parent: InnermostDeclaringBlock::Statement(declaring),\n+                    parent: InnermostEnclosingExpr::Statement(declaring),\n+                };\n+            }\n+            visitor.visit_stmt(&**statement)\n+        }\n+        visit::walk_expr_opt(visitor, &blk.expr)\n+    }\n \n-    let prev_cx = visitor.cx;\n-    visitor.cx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};\n-    visit::walk_block(visitor, blk);\n     visitor.cx = prev_cx;\n }\n \n@@ -449,7 +621,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n-    record_superlifetime(visitor, pat.id, pat.span);\n+    record_superlifetime(visitor, CodeExtent::from_node_id(pat.id), pat.span);\n \n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n@@ -468,22 +640,29 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     let stmt_scope = CodeExtent::from_node_id(stmt_id);\n+\n+    // Every statement will clean up the temporaries created during\n+    // execution of that statement. Therefore each statement has an\n+    // associated destruction scope that represents the extent of the\n+    // statement plus its destructors, and thus the extent for which\n+    // regions referenced by the destructors need to survive.\n     visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n-    record_superlifetime(visitor, stmt_id, stmt.span);\n+    record_superlifetime(visitor, stmt_scope, stmt.span);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = Some(stmt_id);\n+    visitor.cx.parent = InnermostEnclosingExpr::Some(stmt_id);\n     visit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    record_superlifetime(visitor, expr.id, expr.span);\n+    let expr_scope = CodeExtent::Misc(expr.id);\n+    record_superlifetime(visitor, expr_scope, expr.span);\n \n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = Some(expr.id);\n+    visitor.cx.parent = InnermostEnclosingExpr::Some(expr.id);\n \n     {\n         let region_maps = &mut visitor.region_maps;\n@@ -527,11 +706,11 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n \n                 // The variable parent of everything inside (most importantly, the\n                 // pattern) is the body.\n-                visitor.cx.var_parent = Some(body.id);\n+                visitor.cx.var_parent = InnermostDeclaringBlock::Block(body.id);\n             }\n \n             ast::ExprMatch(..) => {\n-                visitor.cx.var_parent = Some(expr.id);\n+                visitor.cx.var_parent = InnermostDeclaringBlock::Match(expr.id);\n             }\n \n             ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n@@ -568,19 +747,13 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n-    let blk_id = match visitor.cx.var_parent {\n-        Some(id) => id,\n-        None => {\n-            visitor.sess.span_bug(\n-                local.span,\n-                \"local without enclosing block\");\n-        }\n-    };\n-\n     // For convenience in trans, associate with the local-id the var\n     // scope that will be used for any bindings declared in this\n     // pattern.\n-    let blk_scope = CodeExtent::from_node_id(blk_id);\n+    let blk_scope = visitor.cx.var_parent.to_code_extent()\n+        .unwrap_or_else(|| visitor.sess.span_bug(\n+            local.span, \"local without enclosing block\"));\n+\n     visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n@@ -803,7 +976,10 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n-    visitor.cx = Context {var_parent: None, parent: None};\n+    visitor.cx = Context {\n+        var_parent: InnermostDeclaringBlock::None,\n+        parent: InnermostEnclosingExpr::None\n+    };\n     visit::walk_item(visitor, item);\n     visitor.cx = prev_cx;\n }\n@@ -829,15 +1005,20 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     let outer_cx = visitor.cx;\n \n     // The arguments and `self` are parented to the body of the fn.\n-    visitor.cx = Context { parent: Some(body.id),\n-                           var_parent: Some(body.id) };\n+    visitor.cx = Context {\n+        parent: InnermostEnclosingExpr::Some(body.id),\n+        var_parent: InnermostDeclaringBlock::Block(body.id)\n+    };\n     visit::walk_fn_decl(visitor, decl);\n \n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n     match fk {\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            visitor.cx = Context { parent: None, var_parent: None };\n+            visitor.cx = Context {\n+                parent: InnermostEnclosingExpr::None,\n+                var_parent: InnermostDeclaringBlock::None\n+            };\n             visitor.visit_block(body);\n             visitor.cx = outer_cx;\n         }\n@@ -898,7 +1079,10 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n-            cx: Context { parent: None, var_parent: None }\n+            cx: Context {\n+                parent: InnermostEnclosingExpr::None,\n+                var_parent: InnermostDeclaringBlock::None,\n+            }\n         };\n         visit::walk_crate(&mut visitor, krate);\n     }\n@@ -911,7 +1095,10 @@ pub fn resolve_inlined_item(sess: &Session,\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n         region_maps: region_maps,\n-        cx: Context { parent: None, var_parent: None }\n+        cx: Context {\n+            parent: InnermostEnclosingExpr::None,\n+            var_parent: InnermostDeclaringBlock::None\n+        }\n     };\n     visit::walk_inlined_item(&mut visitor, item);\n }"}, {"sha": "5601898136c79d629773ed2c93d649322a3cd252", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d6bf04a22e78afbe62e9d81e3578418f420123bc", "patch": "@@ -10,6 +10,7 @@\n \n \n use middle::def;\n+use middle::region;\n use middle::subst::{VecPerParamSpace,Subst};\n use middle::subst;\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n@@ -84,37 +85,41 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (String, Option<Span>) {\n     return match region {\n       ReScope(scope) => {\n-        match cx.map.find(scope.node_id()) {\n-          Some(ast_map::NodeBlock(ref blk)) => {\n-            explain_span(cx, \"block\", blk.span)\n-          }\n-          Some(ast_map::NodeExpr(expr)) => {\n-            match expr.node {\n-              ast::ExprCall(..) => explain_span(cx, \"call\", expr.span),\n-              ast::ExprMethodCall(..) => {\n-                explain_span(cx, \"method call\", expr.span)\n-              },\n-              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) =>\n-                  explain_span(cx, \"if let\", expr.span),\n-              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) => {\n-                  explain_span(cx, \"while let\", expr.span)\n-              },\n-              ast::ExprMatch(..) => explain_span(cx, \"match\", expr.span),\n-              _ => explain_span(cx, \"expression\", expr.span)\n-            }\n-          }\n-          Some(ast_map::NodeStmt(stmt)) => {\n-              explain_span(cx, \"statement\", stmt.span)\n-          }\n-          Some(ast_map::NodeItem(it)) => {\n-              let tag = item_scope_tag(&*it);\n-              explain_span(cx, tag, it.span)\n-          }\n+        let new_string;\n+        let on_unknown_scope = |&:| {\n+          (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n+        };\n+        let span = match scope.span(&cx.map) {\n+          Some(s) => s,\n+          None => return on_unknown_scope(),\n+        };\n+        let tag = match cx.map.find(scope.node_id()) {\n+          Some(ast_map::NodeBlock(_)) => \"block\",\n+          Some(ast_map::NodeExpr(expr)) => match expr.node {\n+              ast::ExprCall(..) => \"call\",\n+              ast::ExprMethodCall(..) => \"method call\",\n+              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+              ast::ExprMatch(..) => \"match\",\n+              _ => \"expression\",\n+          },\n+          Some(ast_map::NodeStmt(_)) => \"statement\",\n+          Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n+            return on_unknown_scope();\n           }\n-        }\n+        };\n+        let scope_decorated_tag = match scope {\n+            region::CodeExtent::Misc(_) => tag,\n+            region::CodeExtent::Remainder(r) => {\n+                new_string = format!(\"block suffix following statement {}\",\n+                                     r.first_statement_index);\n+                new_string.as_slice()\n+            }\n+        };\n+        explain_span(cx, scope_decorated_tag, span)\n+\n       }\n \n       ReFree(ref fr) => {\n@@ -867,6 +872,17 @@ impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for region::CodeExtent {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        match *self {\n+            region::CodeExtent::Misc(node_id) =>\n+                format!(\"Misc({})\", node_id),\n+            region::CodeExtent::Remainder(rem) =>\n+                format!(\"Remainder({}, {})\", rem.block, rem.first_statement_index),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ast::DefId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print"}, {"sha": "f551a2aa81155702af8fd7b698ad81ad21affb25", "filename": "src/test/compile-fail/borrowck-let-suggestion-suffixes.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs?ref=d6bf04a22e78afbe62e9d81e3578418f420123bc", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    let old = ['o'];         // statement 0\n+    let mut v1 = Vec::new(); // statement 1\n+\n+    let mut v2 = Vec::new(); // statement 2\n+    //~^ NOTE reference must be valid for the block suffix following statement 2\n+\n+    let young = ['y'];       // statement 3\n+    //~^ NOTE ...but borrowed value is only valid for the block suffix following statement 3\n+\n+    v2.push(&young[0]);      // statement 4\n+    //~^ ERROR `young[..]` does not live long enough\n+\n+    let mut v3 = Vec::new(); // statement 5\n+    //~^ NOTE reference must be valid for the block suffix following statement 5\n+\n+    v3.push(&'x');           // statement 6\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    {\n+\n+        let mut v4 = Vec::new(); // (sub) statement 0\n+        //~^ NOTE reference must be valid for the block suffix following statement 0\n+\n+        v4.push(&'y');\n+        //~^ ERROR borrowed value does not live long enough\n+        //~| NOTE ...but borrowed value is only valid for the statement\n+        //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    }                       // (statement 7)\n+\n+    let mut v5 = Vec::new(); // statement 8\n+    //~^ NOTE reference must be valid for the block suffix following statement 8\n+\n+    v5.push(&'z');\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    v1.push(&old[0]);\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "a08021919df8540d473f149e8c422c0820e38ef0", "filename": "src/test/compile-fail/borrowck-let-suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bf04a22e78afbe62e9d81e3578418f420123bc/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs?ref=d6bf04a22e78afbe62e9d81e3578418f420123bc", "patch": "@@ -10,7 +10,7 @@\n \n fn f() {\n     let x = [1is].iter(); //~ ERROR borrowed value does not live long enough\n-                         //~^^ NOTE reference must be valid for the block\n+                         //~^ NOTE reference must be valid for the block suffix following statement\n                          //~^^ HELP consider using a `let` binding to increase its lifetime\n }\n "}]}