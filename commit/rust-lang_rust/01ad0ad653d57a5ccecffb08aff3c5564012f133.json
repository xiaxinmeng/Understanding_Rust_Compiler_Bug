{"sha": "01ad0ad653d57a5ccecffb08aff3c5564012f133", "node_id": "C_kwDOAAsO6NoAKDAxYWQwYWQ2NTNkNTdhNWNjZWNmZmIwOGFmZjNjNTU2NDAxMmYxMzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-10T02:38:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-10T02:38:43Z"}, "message": "Auto merge of #94787 - matthiaskrgr:rollup-yyou15f, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #91804 (Make some `Clone` impls `const`)\n - #92541 (Mention intent of `From` trait in its docs)\n - #93057 (Add Iterator::collect_into)\n - #94739 (Suggest `if let`/`let_else` for refutable pat in `let`)\n - #94754 (Warn users about `||` in let chain expressions)\n - #94763 (Add documentation about lifetimes to thread::scope.)\n - #94768 (Ignore `close_read_wakes_up` test on SGX platform)\n - #94772 (Add miri to the well known conditional compilation names and values)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6fa567cc2a26ca518a1d7eabe7a2da3394f87387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fa567cc2a26ca518a1d7eabe7a2da3394f87387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ad0ad653d57a5ccecffb08aff3c5564012f133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ad0ad653d57a5ccecffb08aff3c5564012f133", "html_url": "https://github.com/rust-lang/rust/commit/01ad0ad653d57a5ccecffb08aff3c5564012f133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ad0ad653d57a5ccecffb08aff3c5564012f133/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ce7fdfa2f4af87516aac0b3878dc8c144015be", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ce7fdfa2f4af87516aac0b3878dc8c144015be", "html_url": "https://github.com/rust-lang/rust/commit/85ce7fdfa2f4af87516aac0b3878dc8c144015be"}, {"sha": "94f5f1f3bf36399e678cf38e813e92751436ed9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/94f5f1f3bf36399e678cf38e813e92751436ed9c", "html_url": "https://github.com/rust-lang/rust/commit/94f5f1f3bf36399e678cf38e813e92751436ed9c"}], "stats": {"total": 700, "additions": 527, "deletions": 173}, "files": [{"sha": "8f0b12cb4feef17d86420aa2181b40a9b63c2746", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 65, "deletions": 39, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -64,8 +64,8 @@ struct AstValidator<'a> {\n     /// certain positions.\n     is_assoc_ty_bound_banned: bool,\n \n-    /// Used to allow `let` expressions in certain syntactic locations.\n-    is_let_allowed: bool,\n+    /// See [ForbiddenLetReason]\n+    forbidden_let_reason: Option<ForbiddenLetReason>,\n \n     lint_buffer: &'a mut LintBuffer,\n }\n@@ -103,20 +103,28 @@ impl<'a> AstValidator<'a> {\n         self.is_tilde_const_allowed = old;\n     }\n \n-    fn with_let_allowed(&mut self, allowed: bool, f: impl FnOnce(&mut Self, bool)) {\n-        let old = mem::replace(&mut self.is_let_allowed, allowed);\n+    fn with_let_management(\n+        &mut self,\n+        forbidden_let_reason: Option<ForbiddenLetReason>,\n+        f: impl FnOnce(&mut Self, Option<ForbiddenLetReason>),\n+    ) {\n+        let old = mem::replace(&mut self.forbidden_let_reason, forbidden_let_reason);\n         f(self, old);\n-        self.is_let_allowed = old;\n+        self.forbidden_let_reason = old;\n     }\n \n     /// Emits an error banning the `let` expression provided in the given location.\n-    fn ban_let_expr(&self, expr: &'a Expr) {\n+    fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n         let sess = &self.session;\n         if sess.opts.unstable_features.is_nightly_build() {\n-            sess.struct_span_err(expr.span, \"`let` expressions are not supported here\")\n-                .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n-                .note(\"as well as when nested within `&&` and parentheses in those conditions\")\n-                .emit();\n+            let err = \"`let` expressions are not supported here\";\n+            let mut diag = sess.struct_span_err(expr.span, err);\n+            diag.note(\"only supported directly in conditions of `if` and `while` expressions\");\n+            diag.note(\"as well as when nested within `&&` and parentheses in those conditions\");\n+            if let ForbiddenLetReason::ForbiddenWithOr(span) = forbidden_let_reason {\n+                diag.span_note(span, \"`||` operators are not allowed in let chain expressions\");\n+            }\n+            diag.emit();\n         } else {\n             sess.struct_span_err(expr.span, \"expected expression, found statement (`let`)\")\n                 .note(\"variable declaration using `let` is a statement\")\n@@ -988,39 +996,48 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        self.with_let_allowed(false, |this, let_allowed| match &expr.kind {\n-            ExprKind::If(cond, then, opt_else) => {\n-                this.visit_block(then);\n-                walk_list!(this, visit_expr, opt_else);\n-                this.with_let_allowed(true, |this, _| this.visit_expr(cond));\n-                return;\n-            }\n-            ExprKind::Let(..) if !let_allowed => this.ban_let_expr(expr),\n-            ExprKind::Match(expr, arms) => {\n-                this.visit_expr(expr);\n-                for arm in arms {\n-                    this.visit_expr(&arm.body);\n-                    this.visit_pat(&arm.pat);\n-                    walk_list!(this, visit_attribute, &arm.attrs);\n-                    if let Some(ref guard) = arm.guard {\n-                        if let ExprKind::Let(_, ref expr, _) = guard.kind {\n-                            this.with_let_allowed(true, |this, _| this.visit_expr(expr));\n+        self.with_let_management(Some(ForbiddenLetReason::GenericForbidden), |this, forbidden_let_reason| {\n+            match &expr.kind {\n+                ExprKind::Binary(Spanned { node: BinOpKind::Or, span }, lhs, rhs) => {\n+                    let forbidden_let_reason = Some(ForbiddenLetReason::ForbiddenWithOr(*span));\n+                    this.with_let_management(forbidden_let_reason, |this, _| this.visit_expr(lhs));\n+                    this.with_let_management(forbidden_let_reason, |this, _| this.visit_expr(rhs));\n+                }\n+                ExprKind::If(cond, then, opt_else) => {\n+                    this.visit_block(then);\n+                    walk_list!(this, visit_expr, opt_else);\n+                    this.with_let_management(None, |this, _| this.visit_expr(cond));\n+                    return;\n+                }\n+                ExprKind::Let(..) if let Some(elem) = forbidden_let_reason => {\n+                    this.ban_let_expr(expr, elem);\n+                },\n+                ExprKind::Match(scrutinee, arms) => {\n+                    this.visit_expr(scrutinee);\n+                    for arm in arms {\n+                        this.visit_expr(&arm.body);\n+                        this.visit_pat(&arm.pat);\n+                        walk_list!(this, visit_attribute, &arm.attrs);\n+                        if let Some(guard) = &arm.guard && let ExprKind::Let(_, guard_expr, _) = &guard.kind {\n+                            this.with_let_management(None, |this, _| {\n+                                this.visit_expr(guard_expr)\n+                            });\n                             return;\n                         }\n                     }\n                 }\n+                ExprKind::Paren(_) | ExprKind::Binary(Spanned { node: BinOpKind::And, .. }, ..) => {\n+                    this.with_let_management(forbidden_let_reason, |this, _| visit::walk_expr(this, expr));\n+                    return;\n+                }\n+                ExprKind::While(cond, then, opt_label) => {\n+                    walk_list!(this, visit_label, opt_label);\n+                    this.visit_block(then);\n+                    this.with_let_management(None, |this, _| this.visit_expr(cond));\n+                    return;\n+                }\n+                _ => visit::walk_expr(this, expr),\n             }\n-            ExprKind::Paren(_) | ExprKind::Binary(Spanned { node: BinOpKind::And, .. }, ..) => {\n-                this.with_let_allowed(let_allowed, |this, _| visit::walk_expr(this, expr));\n-                return;\n-            }\n-            ExprKind::While(cond, then, opt_label) => {\n-                walk_list!(this, visit_label, opt_label);\n-                this.visit_block(then);\n-                this.with_let_allowed(true, |this, _| this.visit_expr(cond));\n-                return;\n-            }\n-            _ => visit::walk_expr(this, expr),\n         });\n     }\n \n@@ -1772,10 +1789,19 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n         is_tilde_const_allowed: false,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n-        is_let_allowed: false,\n+        forbidden_let_reason: Some(ForbiddenLetReason::GenericForbidden),\n         lint_buffer: lints,\n     };\n     visit::walk_crate(&mut validator, krate);\n \n     validator.has_proc_macro_decls\n }\n+\n+/// Used to forbid `let` expressions in certain syntactic locations.\n+#[derive(Clone, Copy)]\n+enum ForbiddenLetReason {\n+    /// A let chain with the `||` operator\n+    ForbiddenWithOr(Span),\n+    /// `let` is not valid and the source environment is not important\n+    GenericForbidden,\n+}"}, {"sha": "9d52c32885db0232735272b69e08aa119763e6b4", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -4,11 +4,13 @@\n //!\n //! The crate also contains other misc AST visitors, e.g. `node_count` and `show_span`.\n \n-#![feature(iter_is_partitioned)]\n+#![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n+#![feature(if_let_guard)]\n+#![feature(iter_is_partitioned)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n pub mod ast_validation;\n pub mod feature_gate;"}, {"sha": "c94da838680e075cc4c2c049fe6bf3886b229ce4", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 79, "deletions": 7, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -7,7 +7,8 @@ use super::{PatCtxt, PatternError};\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    error_code, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    error_code, pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder,\n+    ErrorGuaranteed,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n@@ -20,7 +21,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::{DesugaringKind, ExpnKind, MultiSpan, Span};\n+use rustc_span::{BytePos, DesugaringKind, ExpnKind, MultiSpan, Span};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n@@ -241,6 +242,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         }\n \n         let joined_patterns = joined_uncovered_patterns(&cx, &witnesses);\n+\n+        let mut bindings = vec![];\n+\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             pat.span,\n@@ -257,6 +261,16 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 false\n             }\n             _ => {\n+                pat.walk(&mut |pat: &hir::Pat<'_>| {\n+                    match pat.kind {\n+                        hir::PatKind::Binding(_, _, ident, _) => {\n+                            bindings.push(ident);\n+                        }\n+                        _ => {}\n+                    }\n+                    true\n+                });\n+\n                 err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n                 true\n             }\n@@ -267,13 +281,71 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n                  an `enum` with only one variant\",\n             );\n-            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                err.span_suggestion(\n-                    span,\n-                    \"you might want to use `if let` to ignore the variant that isn't matched\",\n-                    format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n+            if self.tcx.sess.source_map().span_to_snippet(span).is_ok() {\n+                let semi_span = span.shrink_to_hi().with_lo(span.hi() - BytePos(1));\n+                let start_span = span.shrink_to_lo();\n+                let end_span = semi_span.shrink_to_lo();\n+                err.multipart_suggestion(\n+                    &format!(\n+                        \"you might want to use `if let` to ignore the variant{} that {} matched\",\n+                        pluralize!(witnesses.len()),\n+                        match witnesses.len() {\n+                            1 => \"isn't\",\n+                            _ => \"aren't\",\n+                        },\n+                    ),\n+                    vec![\n+                        match &bindings[..] {\n+                            [] => (start_span, \"if \".to_string()),\n+                            [binding] => (start_span, format!(\"let {} = if \", binding)),\n+                            bindings => (\n+                                start_span,\n+                                format!(\n+                                    \"let ({}) = if \",\n+                                    bindings\n+                                        .iter()\n+                                        .map(|ident| ident.to_string())\n+                                        .collect::<Vec<_>>()\n+                                        .join(\", \")\n+                                ),\n+                            ),\n+                        },\n+                        match &bindings[..] {\n+                            [] => (semi_span, \" { todo!() }\".to_string()),\n+                            [binding] => {\n+                                (end_span, format!(\" {{ {} }} else {{ todo!() }}\", binding))\n+                            }\n+                            bindings => (\n+                                end_span,\n+                                format!(\n+                                    \" {{ ({}) }} else {{ todo!() }}\",\n+                                    bindings\n+                                        .iter()\n+                                        .map(|ident| ident.to_string())\n+                                        .collect::<Vec<_>>()\n+                                        .join(\", \")\n+                                ),\n+                            ),\n+                        },\n+                    ],\n                     Applicability::HasPlaceholders,\n                 );\n+                if !bindings.is_empty() && cx.tcx.sess.is_nightly_build() {\n+                    err.span_suggestion_verbose(\n+                        semi_span.shrink_to_lo(),\n+                        &format!(\n+                            \"alternatively, on nightly, you might want to use \\\n+                             `#![feature(let_else)]` to handle the variant{} that {} matched\",\n+                            pluralize!(witnesses.len()),\n+                            match witnesses.len() {\n+                                1 => \"isn't\",\n+                                _ => \"aren't\",\n+                            },\n+                        ),\n+                        \" else { todo!() }\".to_string(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n             }\n             err.note(\n                 \"for more information, visit \\"}, {"sha": "1d36ff059de81eb89456660854facc29f1888a64", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -1072,6 +1072,7 @@ impl CrateCheckConfig {\n         // NOTE: This should be kept in sync with `default_configuration` and\n         // `fill_well_known_values`\n         const WELL_KNOWN_NAMES: &[Symbol] = &[\n+            // rustc\n             sym::unix,\n             sym::windows,\n             sym::target_os,\n@@ -1091,9 +1092,12 @@ impl CrateCheckConfig {\n             sym::debug_assertions,\n             sym::proc_macro,\n             sym::test,\n+            sym::feature,\n+            // rustdoc\n             sym::doc,\n             sym::doctest,\n-            sym::feature,\n+            // miri\n+            sym::miri,\n         ];\n \n         // We only insert well-known names if `names()` was activated\n@@ -1128,13 +1132,14 @@ impl CrateCheckConfig {\n \n         // No-values\n         for name in [\n+            sym::doc,\n+            sym::miri,\n             sym::unix,\n-            sym::windows,\n-            sym::debug_assertions,\n-            sym::proc_macro,\n             sym::test,\n-            sym::doc,\n             sym::doctest,\n+            sym::windows,\n+            sym::proc_macro,\n+            sym::debug_assertions,\n             sym::target_thread_local,\n         ] {\n             self.values_valid.entry(name).or_default();"}, {"sha": "3884578f5d46caf3e86357b6d6ec2557f6261dbe", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -891,6 +891,7 @@ symbols! {\n         minnumf32,\n         minnumf64,\n         mips_target_feature,\n+        miri,\n         misc,\n         mmx_reg,\n         modifiers,"}, {"sha": "1912694412b9874178aceb93db1234c9edbe78ae", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -127,7 +127,11 @@ pub trait Clone: Sized {\n     /// allocations.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn clone_from(&mut self, source: &Self) {\n+    #[default_method_body_is_const]\n+    fn clone_from(&mut self, source: &Self)\n+    where\n+        Self: ~const Drop,\n+    {\n         *self = source.clone()\n     }\n }\n@@ -178,7 +182,8 @@ mod impls {\n         ($($t:ty)*) => {\n             $(\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                impl Clone for $t {\n+                #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+                impl const Clone for $t {\n                     #[inline]\n                     fn clone(&self) -> Self {\n                         *self\n@@ -196,23 +201,26 @@ mod impls {\n     }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    impl Clone for ! {\n+    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+    impl const Clone for ! {\n         #[inline]\n         fn clone(&self) -> Self {\n             *self\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized> Clone for *const T {\n+    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+    impl<T: ?Sized> const Clone for *const T {\n         #[inline]\n         fn clone(&self) -> Self {\n             *self\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized> Clone for *mut T {\n+    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+    impl<T: ?Sized> const Clone for *mut T {\n         #[inline]\n         fn clone(&self) -> Self {\n             *self\n@@ -221,7 +229,8 @@ mod impls {\n \n     /// Shared references can be cloned, but mutable references *cannot*!\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized> Clone for &T {\n+    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+    impl<T: ?Sized> const Clone for &T {\n         #[inline]\n         #[rustc_diagnostic_item = \"noop_method_clone\"]\n         fn clone(&self) -> Self {"}, {"sha": "f5ea5f5ba50c0515df316aebc14376289edc3ae7", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -300,7 +300,8 @@ pub trait Into<T>: Sized {\n /// that encapsulate multiple error types. See the \"Examples\" section and [the book][book] for more\n /// details.\n ///\n-/// **Note: This trait must not fail**. If the conversion can fail, use [`TryFrom`].\n+/// **Note: This trait must not fail**. The `From` trait is intended for perfect conversions.\n+/// If the conversion can fail or is not perfect, use [`TryFrom`].\n ///\n /// # Generic Implementations\n ///\n@@ -690,7 +691,8 @@ impl AsMut<str> for str {\n pub enum Infallible {}\n \n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-impl Clone for Infallible {\n+#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+impl const Clone for Infallible {\n     fn clone(&self) -> Infallible {\n         match *self {}\n     }"}, {"sha": "b38df1c2d022816355738ac142932b3fac8ad0de", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -1859,6 +1859,77 @@ pub trait Iterator {\n         try_process(self, |i| i.collect())\n     }\n \n+    /// Collects all the items from an iterator into a collection.\n+    ///\n+    /// This method consumes the iterator and adds all its items to the\n+    /// passed collection. The collection is then returned, so the call chain\n+    /// can be continued.\n+    ///\n+    /// This is useful when you already have a collection and wants to add\n+    /// the iterator items to it.\n+    ///\n+    /// This method is a convenience method to call [Extend::extend](trait.Extend.html),\n+    /// but instead of being called on a collection, it's called on an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_collect_into)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let mut vec: Vec::<i32> = vec![0, 1];\n+    ///\n+    /// a.iter().map(|&x| x * 2).collect_into(&mut vec);\n+    /// a.iter().map(|&x| x * 10).collect_into(&mut vec);\n+    ///\n+    /// assert_eq!(vec![0, 1, 2, 4, 6, 10, 20, 30], vec);\n+    /// ```\n+    ///\n+    /// `Vec` can have a manual set capacity to avoid reallocating it:\n+    ///\n+    /// ```\n+    /// #![feature(iter_collect_into)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let mut vec: Vec::<i32> = Vec::with_capacity(6);\n+    ///\n+    /// a.iter().map(|&x| x * 2).collect_into(&mut vec);\n+    /// a.iter().map(|&x| x * 10).collect_into(&mut vec);\n+    ///\n+    /// assert_eq!(6, vec.capacity());\n+    /// println!(\"{:?}\", vec);\n+    /// ```\n+    ///\n+    /// The returned mutable reference can be used to continue the call chain:\n+    ///\n+    /// ```\n+    /// #![feature(iter_collect_into)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let mut vec: Vec::<i32> = Vec::with_capacity(6);\n+    ///\n+    /// let count = a.iter().collect_into(&mut vec).iter().count();\n+    ///\n+    /// assert_eq!(count, vec.len());\n+    /// println!(\"Vec len is {}\", count);\n+    ///\n+    /// let count = a.iter().collect_into(&mut vec).iter().count();\n+    ///\n+    /// assert_eq!(count, vec.len());\n+    /// println!(\"Vec len now is {}\", count);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_collect_into\", reason = \"new API\", issue = \"94780\")]\n+    fn collect_into<E: Extend<Self::Item>>(self, collection: &mut E) -> &mut E\n+    where\n+        Self: Sized,\n+    {\n+        collection.extend(self);\n+        collection\n+    }\n+\n     /// Consumes an iterator, creating two collections from it.\n     ///\n     /// The predicate passed to `partition()` can return `true`, or `false`."}, {"sha": "ddd8ae0c02ca5fb1198826fc16fbab34801492b8", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -104,6 +104,7 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_char_convert)]\n+#![feature(const_clone)]\n #![feature(const_discriminant)]\n #![feature(const_eval_select)]\n #![feature(const_float_bits_conv)]"}, {"sha": "a6286f8d8d103495f1978b21cb1deb8fcb82319c", "filename": "library/core/src/option.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -1857,7 +1857,11 @@ const fn expect_failed(msg: &str) -> ! {\n /////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for Option<T> {\n+#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+impl<T> const Clone for Option<T>\n+where\n+    T: ~const Clone + ~const Drop,\n+{\n     #[inline]\n     fn clone(&self) -> Self {\n         match self {"}, {"sha": "77b93e0c24cc9827d3e4c8f7b9d0ed066946c0dc", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -642,7 +642,8 @@ impl<T> NonNull<[T]> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Clone for NonNull<T> {\n+#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+impl<T: ?Sized> const Clone for NonNull<T> {\n     #[inline]\n     fn clone(&self) -> Self {\n         *self"}, {"sha": "cff68f64f78e08c3d793ee051aec959c8369920b", "filename": "library/core/src/ptr/unique.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Funique.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -146,7 +146,8 @@ impl<T: ?Sized> Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: ?Sized> Clone for Unique<T> {\n+#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+impl<T: ?Sized> const Clone for Unique<T> {\n     #[inline]\n     fn clone(&self) -> Self {\n         *self"}, {"sha": "5a189f2b0981108b4ce2947ddc84a9eff2663985", "filename": "library/core/src/result.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -1801,7 +1801,12 @@ fn unwrap_failed<T>(_msg: &str, _error: &T) -> ! {\n /////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone, E: Clone> Clone for Result<T, E> {\n+#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n+impl<T, E> const Clone for Result<T, E>\n+where\n+    T: ~const Clone + ~const Drop,\n+    E: ~const Clone + ~const Drop,\n+{\n     #[inline]\n     fn clone(&self) -> Self {\n         match self {"}, {"sha": "32bd68e3d2554a2c717d428c8635cff70ac1eaf8", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -543,6 +543,14 @@ fn test_try_collect() {\n     assert_eq!(v, Continue(vec![4, 5]));\n }\n \n+#[test]\n+fn test_collect_into() {\n+    let a = vec![1, 2, 3, 4, 5];\n+    let mut b = Vec::new();\n+    a.iter().cloned().collect_into(&mut b);\n+    assert!(a == b);\n+}\n+\n // just tests by whether or not this compiles\n fn _empty_impl_all_auto_traits<T>() {\n     use std::panic::{RefUnwindSafe, UnwindSafe};"}, {"sha": "dc3740228274bcbfc7525e86e13cad8b65f75c91", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -62,6 +62,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_log)]\n #![feature(iter_advance_by)]\n+#![feature(iter_collect_into)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_intersperse)]\n #![feature(iter_is_partitioned)]"}, {"sha": "4d5cf658def0d79a3b9da02fe88220cc246ecabe", "filename": "library/std/src/net/tcp/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -508,6 +508,7 @@ fn close_readwrite_smoke() {\n }\n \n #[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)]\n fn close_read_wakes_up() {\n     each_ip(&mut |addr| {\n         let a = t!(TcpListener::bind(&addr));"}, {"sha": "c4847b529a3613c8c52402a34d1d4787c1112823", "filename": "library/std/src/thread/scoped.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -107,6 +107,24 @@ impl ScopeData {\n /// a.push(4);\n /// assert_eq!(x, a.len());\n /// ```\n+///\n+/// # Lifetimes\n+///\n+/// Scoped threads involve two lifetimes: `'scope` and `'env`.\n+///\n+/// The `'scope` lifetime represents the lifetime of the scope itself.\n+/// That is: the time during which new scoped threads may be spawned,\n+/// and also the time during which they might still be running.\n+/// Once this lifetime ends, all scoped threads are joined.\n+/// This lifetime starts within the `scope` function, before `f` (the argument to `scope`) starts.\n+/// It ends after `f` returns and all scoped threads have been joined, but before `scope` returns.\n+///\n+/// The `'env` lifetime represents the lifetime of whatever is borrowed by the scoped threads.\n+/// This lifetime must outlast the call to `scope`, and thus cannot be smaller than `'scope`.\n+/// It can be as small as the call to `scope`, meaning that anything that outlives this call,\n+/// such as local variables defined right before the scope, can be borrowed by the scoped threads.\n+///\n+/// The `'env: 'scope` bound is part of the definition of the `Scope` type.\n #[track_caller]\n pub fn scope<'env, F, T>(f: F) -> T\n where"}, {"sha": "2ee67d623eec90f191eacf17ee075116553620c2", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -193,7 +193,6 @@ const EXTRA_CHECK_CFGS: &[(Option<Mode>, &'static str, Option<&[&'static str]>)]\n     (None, \"bootstrap\", None),\n     (Some(Mode::Rustc), \"parallel_compiler\", None),\n     (Some(Mode::ToolRustc), \"parallel_compiler\", None),\n-    (Some(Mode::Std), \"miri\", None),\n     (Some(Mode::Std), \"stdarch_intel_sde\", None),\n     (Some(Mode::Std), \"no_fp_fmt_parse\", None),\n     (Some(Mode::Std), \"no_global_oom_handling\", None),"}, {"sha": "e57fb69a1e05f2d94a7982ee39af6fa2b4fb03fd", "filename": "src/test/ui/check-cfg/well-known-names.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-names.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -24,4 +24,10 @@ fn unix_misspell() {}\n #[cfg(unix)]\n fn unix() {}\n \n+#[cfg(miri)]\n+fn miri() {}\n+\n+#[cfg(doc)]\n+fn doc() {}\n+\n fn main() {}"}, {"sha": "96375dc8d3130e0518ddaa49d1df7974b3232898", "filename": "src/test/ui/check-cfg/well-known-values.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-values.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -25,4 +25,18 @@ fn unix_with_value() {}\n #[cfg(unix)]\n fn unix() {}\n \n+#[cfg(miri = \"miri\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn miri_with_value() {}\n+\n+#[cfg(miri)]\n+fn miri() {}\n+\n+#[cfg(doc = \"linux\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn doc_with_value() {}\n+\n+#[cfg(doc)]\n+fn doc() {}\n+\n fn main() {}"}, {"sha": "8b04c770fb505f99c805aabaf8a938b56ceabf9d", "filename": "src/test/ui/check-cfg/well-known-values.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fwell-known-values.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -29,5 +29,25 @@ LL | #[cfg(unix = \"aa\")]\n    |\n    = note: no expected value for `unix`\n \n-warning: 3 warnings emitted\n+warning: unexpected `cfg` condition value\n+  --> $DIR/well-known-values.rs:28:7\n+   |\n+LL | #[cfg(miri = \"miri\")]\n+   |       ^^^^---------\n+   |           |\n+   |           help: remove the value\n+   |\n+   = note: no expected value for `miri`\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/well-known-values.rs:35:7\n+   |\n+LL | #[cfg(doc = \"linux\")]\n+   |       ^^^----------\n+   |          |\n+   |          help: remove the value\n+   |\n+   = note: no expected value for `doc`\n+\n+warning: 5 warnings emitted\n "}, {"sha": "6e61dbbd8eee3906a3bb8b50131dff54d2f410b2", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -7,10 +7,10 @@ LL |     A = { let 0 = 0; 0 },\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     A = { if let 0 = 0 { /* */ } 0 },\n-   |           ~~~~~~~~~~~~~~~~~~~~~~\n+LL |     A = { if let 0 = 0 { todo!() } 0 },\n+   |           ++           ~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "1b3b6e06c3df611e98de7a42ec2d342ac19fb1b6", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -7,10 +7,10 @@ LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     let x: [i32; { if let 0 = 0 { /* */ } 0 }] = [];\n-   |                    ~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let x: [i32; { if let 0 = 0 { todo!() } 0 }] = [];\n+   |                    ++           ~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "bc8edfa7af9f488dacfabc9dffe769609f0ce517", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -7,10 +7,10 @@ LL | const X: i32 = { let 0 = 0; 0 };\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL | const X: i32 = { if let 0 = 0 { /* */ } 0 };\n-   |                  ~~~~~~~~~~~~~~~~~~~~~~\n+LL | const X: i32 = { if let 0 = 0 { todo!() } 0 };\n+   |                  ++           ~~~~~~~~~~~\n \n error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:8:23\n@@ -21,10 +21,10 @@ LL | static Y: i32 = { let 0 = 0; 0 };\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL | static Y: i32 = { if let 0 = 0 { /* */ } 0 };\n-   |                   ~~~~~~~~~~~~~~~~~~~~~~\n+LL | static Y: i32 = { if let 0 = 0 { todo!() } 0 };\n+   |                   ++           ~~~~~~~~~~~\n \n error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:13:26\n@@ -35,10 +35,10 @@ LL |     const X: i32 = { let 0 = 0; 0 };\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n-   |                      ~~~~~~~~~~~~~~~~~~~~~~\n+LL |     const X: i32 = { if let 0 = 0 { todo!() } 0 };\n+   |                      ++           ~~~~~~~~~~~\n \n error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:19:26\n@@ -49,10 +49,10 @@ LL |     const X: i32 = { let 0 = 0; 0 };\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n-   |                      ~~~~~~~~~~~~~~~~~~~~~~\n+LL |     const X: i32 = { if let 0 = 0 { todo!() } 0 };\n+   |                      ++           ~~~~~~~~~~~\n \n error: aborting due to 4 previous errors\n "}, {"sha": "909aa73a74a38fb2a9b8313de32527f95ad9c9ce", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -16,8 +16,12 @@ LL |     T(T, [!; 0]),\n    = note: the matched value is of type `Helper<T, U>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Helper::U(u) = Helper::T(t, []) { /* */ }\n+LL |     let u = if let Helper::U(u) = Helper::T(t, []) { u } else { todo!() };\n+   |     ++++++++++                                     ++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variant that isn't matched\n    |\n+LL |     let Helper::U(u) = Helper::T(t, []) else { todo!() };\n+   |                                         ++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "55b1112b5f8ecb4e0f1993894fb6241c3f1f65e6", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -22,8 +22,12 @@ LL | | }\n    = note: the matched value is of type `Option<i32>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Some(y) = x { /* */ }\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let y = if let Some(y) = x { y } else { todo!() };\n+   |     ++++++++++                 ++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variant that isn't matched\n+   |\n+LL |     let Some(y) = x else { todo!() };\n+   |                     ++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "21180f31bbd26a11a59631f1f1966072ee34cbab", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -21,8 +21,12 @@ LL | | }\n    = note: the matched value is of type `Result<u32, !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Ok(_x) = foo() { /* */ }\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let _x = if let Ok(_x) = foo() { _x } else { todo!() };\n+   |     +++++++++++                    +++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variant that isn't matched\n+   |\n+LL |     let Ok(_x) = foo() else { todo!() };\n+   |                        ++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "95b22ac059482fa52a97051b5ca6050321410f74", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -7,10 +7,10 @@ LL |     let (0 | (1 | 2)) = 0;\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let (0 | (1 | 2)) = 0 { /* */ }\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     if let (0 | (1 | 2)) = 0 { todo!() }\n+   |     ++                       ~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:3:11"}, {"sha": "9da6b5eeead235a575107bbde68c86eda7eb0204", "filename": "src/test/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -17,10 +17,14 @@ LL |     Bar,\n LL |     Baz\n    |     ^^^ not covered\n    = note: the matched value is of type `Thing`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let Thing::Foo(y) = Thing::Foo(1) { /* */ }\n+LL |     let y = if let Thing::Foo(y) = Thing::Foo(1) { y } else { todo!() };\n+   |     ++++++++++                                   ++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variants that aren't matched\n    |\n+LL |     let Thing::Foo(y) = Thing::Foo(1) else { todo!() };\n+   |                                       ++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "0f06c31c468b148035cb1d88313079cd27b00bba", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -42,10 +42,10 @@ LL |     B,\n LL |     C\n    |     ^ not covered\n    = note: the matched value is of type `E`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let E::A = e { /* */ }\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     if let E::A = e { todo!() }\n+   |     ++              ~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:52:11\n@@ -91,10 +91,10 @@ LL |     B,\n LL |     C\n    |     ^ not covered\n    = note: the matched value is of type `&E`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let E::A = e { /* */ }\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     if let E::A = e { todo!() }\n+   |     ++              ~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:66:11\n@@ -140,10 +140,10 @@ LL |     B,\n LL |     C\n    |     ^ not covered\n    = note: the matched value is of type `&&mut &E`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     if let E::A = e { /* */ }\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n+LL |     if let E::A = e { todo!() }\n+   |     ++              ~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `None` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:92:11\n@@ -185,8 +185,12 @@ LL |     None,\n    = note: the matched value is of type `Opt`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Opt::Some(ref _x) = e { /* */ }\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let _x = if let Opt::Some(ref _x) = e { _x } else { todo!() };\n+   |     +++++++++++                           +++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variant that isn't matched\n+   |\n+LL |     let Opt::Some(ref _x) = e else { todo!() };\n+   |                               ++++++++++++++++\n \n error: aborting due to 8 previous errors\n "}, {"sha": "d1dacc822e942e49856d95c4bad4d01e48c3a99e", "filename": "src/test/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -15,10 +15,10 @@ LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `(i32, (Option<i32>, i32))`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     if let (1, (Some(1), 2..=3)) = (1, (None, 2)) { /* */ }\n+help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n+LL |     if let (1, (Some(1), 2..=3)) = (1, (None, 2)) { todo!() }\n+   |     ++                                            ~~~~~~~~~~~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a9159562d9d512858354816138493869f75349e5", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -21,8 +21,12 @@ LL | | }\n    = note: the matched value is of type `Result<u32, &R>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Ok(x) = res { /* */ }\n+LL |     let x = if let Ok(x) = res { x } else { todo!() };\n+   |     ++++++++++                 ++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variant that isn't matched\n    |\n+LL |     let Ok(x) = res else { todo!() };\n+   |                     ++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "dd090a3a5483df430da3edf6161f092f0353c6c1", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 110, "deletions": 55, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -15,7 +15,7 @@ error: `let` expressions are not supported here\n LL |     if &let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -24,7 +24,7 @@ error: `let` expressions are not supported here\n LL |     if !let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -33,7 +33,7 @@ error: `let` expressions are not supported here\n LL |     if *let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -42,7 +42,7 @@ error: `let` expressions are not supported here\n LL |     if -let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -51,7 +51,7 @@ error: `let` expressions are not supported here\n LL |     if (let 0 = 0)? {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -60,43 +60,63 @@ error: `let` expressions are not supported here\n LL |     if true || let 0 = 0 {}\n    |                ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:47:13\n+   |\n+LL |     if true || let 0 = 0 {}\n+   |             ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:48:17\n    |\n LL |     if (true || let 0 = 0) {}\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:48:14\n+   |\n+LL |     if (true || let 0 = 0) {}\n+   |              ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:49:25\n    |\n LL |     if true && (true || let 0 = 0) {}\n    |                         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:49:22\n+   |\n+LL |     if true && (true || let 0 = 0) {}\n+   |                      ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:50:25\n    |\n LL |     if true || (true && let 0 = 0) {}\n    |                         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:50:13\n+   |\n+LL |     if true || (true && let 0 = 0) {}\n+   |             ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:53:12\n    |\n LL |     if x = let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -105,7 +125,7 @@ error: `let` expressions are not supported here\n LL |     if true..(let 0 = 0) {}\n    |               ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -114,7 +134,7 @@ error: `let` expressions are not supported here\n LL |     if ..(let 0 = 0) {}\n    |           ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -123,7 +143,7 @@ error: `let` expressions are not supported here\n LL |     if (let 0 = 0).. {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -132,7 +152,7 @@ error: `let` expressions are not supported here\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -141,7 +161,7 @@ error: `let` expressions are not supported here\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -150,7 +170,7 @@ error: `let` expressions are not supported here\n LL |     if let Range { start: F, end } = F..|| true {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -159,7 +179,7 @@ error: `let` expressions are not supported here\n LL |     if let Range { start: true, end } = t..&&false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -168,7 +188,7 @@ error: `let` expressions are not supported here\n LL |     if let true = let true = true {}\n    |                   ^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -177,7 +197,7 @@ error: `let` expressions are not supported here\n LL |     while &let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -186,7 +206,7 @@ error: `let` expressions are not supported here\n LL |     while !let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -195,7 +215,7 @@ error: `let` expressions are not supported here\n LL |     while *let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -204,7 +224,7 @@ error: `let` expressions are not supported here\n LL |     while -let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -213,7 +233,7 @@ error: `let` expressions are not supported here\n LL |     while (let 0 = 0)? {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -222,43 +242,63 @@ error: `let` expressions are not supported here\n LL |     while true || let 0 = 0 {}\n    |                   ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:111:16\n+   |\n+LL |     while true || let 0 = 0 {}\n+   |                ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:112:20\n    |\n LL |     while (true || let 0 = 0) {}\n    |                    ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:112:17\n+   |\n+LL |     while (true || let 0 = 0) {}\n+   |                 ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:113:28\n    |\n LL |     while true && (true || let 0 = 0) {}\n    |                            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:113:25\n+   |\n+LL |     while true && (true || let 0 = 0) {}\n+   |                         ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:114:28\n    |\n LL |     while true || (true && let 0 = 0) {}\n    |                            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:114:16\n+   |\n+LL |     while true || (true && let 0 = 0) {}\n+   |                ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:117:15\n    |\n LL |     while x = let 0 = 0 {}\n    |               ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -267,7 +307,7 @@ error: `let` expressions are not supported here\n LL |     while true..(let 0 = 0) {}\n    |                  ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -276,7 +316,7 @@ error: `let` expressions are not supported here\n LL |     while ..(let 0 = 0) {}\n    |              ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -285,7 +325,7 @@ error: `let` expressions are not supported here\n LL |     while (let 0 = 0).. {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -294,7 +334,7 @@ error: `let` expressions are not supported here\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -303,7 +343,7 @@ error: `let` expressions are not supported here\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -312,7 +352,7 @@ error: `let` expressions are not supported here\n LL |     while let Range { start: F, end } = F..|| true {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -321,7 +361,7 @@ error: `let` expressions are not supported here\n LL |     while let Range { start: true, end } = t..&&false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -330,7 +370,7 @@ error: `let` expressions are not supported here\n LL |     while let true = let true = true {}\n    |                      ^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -339,7 +379,7 @@ error: `let` expressions are not supported here\n LL |     &let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -348,7 +388,7 @@ error: `let` expressions are not supported here\n LL |     !let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -357,7 +397,7 @@ error: `let` expressions are not supported here\n LL |     *let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -366,7 +406,7 @@ error: `let` expressions are not supported here\n LL |     -let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -375,7 +415,7 @@ error: `let` expressions are not supported here\n LL |     (let 0 = 0)?;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -384,34 +424,49 @@ error: `let` expressions are not supported here\n LL |     true || let 0 = 0;\n    |             ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:184:10\n+   |\n+LL |     true || let 0 = 0;\n+   |          ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:185:14\n    |\n LL |     (true || let 0 = 0);\n    |              ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:185:11\n+   |\n+LL |     (true || let 0 = 0);\n+   |           ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:186:22\n    |\n LL |     true && (true || let 0 = 0);\n    |                      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `||` operators are not allowed in let chain expressions\n+  --> $DIR/disallowed-positions.rs:186:19\n+   |\n+LL |     true && (true || let 0 = 0);\n+   |                   ^^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:189:9\n    |\n LL |     x = let 0 = 0;\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -420,7 +475,7 @@ error: `let` expressions are not supported here\n LL |     true..(let 0 = 0);\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -429,7 +484,7 @@ error: `let` expressions are not supported here\n LL |     ..(let 0 = 0);\n    |        ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -438,7 +493,7 @@ error: `let` expressions are not supported here\n LL |     (let 0 = 0)..;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -447,7 +502,7 @@ error: `let` expressions are not supported here\n LL |     (let Range { start: _, end: _ } = true..true || false);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -456,7 +511,7 @@ error: `let` expressions are not supported here\n LL |     (let true = let true = true);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -465,7 +520,7 @@ error: `let` expressions are not supported here\n LL |     &let 0 = 0\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -474,7 +529,7 @@ error: `let` expressions are not supported here\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -483,7 +538,7 @@ error: `let` expressions are not supported here\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -492,7 +547,7 @@ error: `let` expressions are not supported here\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n@@ -501,7 +556,7 @@ error: `let` expressions are not supported here\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: only supported directly in conditions of `if` and `while` expressions\n    = note: as well as when nested within `&&` and parentheses in those conditions\n \n error[E0308]: mismatched types"}, {"sha": "661b5486adc122ca9cfe4f19d17ee0625f654304", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -19,10 +19,10 @@ enum Foo {\n     A(foo::SecretlyEmpty),\n     B(foo::NotSoSecretlyEmpty),\n     C(NotSoSecretlyEmpty),\n-    D(u32),\n+    D(u32, u32),\n }\n \n fn main() {\n-    let x: Foo = Foo::D(123);\n-    let Foo::D(_y) = x; //~ ERROR refutable pattern in local binding: `A(_)` not covered\n+    let x: Foo = Foo::D(123, 456);\n+    let Foo::D(_y, _z) = x; //~ ERROR refutable pattern in local binding: `A(_)` not covered\n }"}, {"sha": "c571e17a7b372516a801b64476dec81bfae86fde", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -1,8 +1,8 @@\n error[E0005]: refutable pattern in local binding: `A(_)` not covered\n   --> $DIR/uninhabited-irrefutable.rs:27:9\n    |\n-LL |     let Foo::D(_y) = x;\n-   |         ^^^^^^^^^^ pattern `A(_)` not covered\n+LL |     let Foo::D(_y, _z) = x;\n+   |         ^^^^^^^^^^^^^^ pattern `A(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -16,8 +16,12 @@ LL |     A(foo::SecretlyEmpty),\n    = note: the matched value is of type `Foo`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Foo::D(_y) = x { /* */ }\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let (_y, _z) = if let Foo::D(_y, _z) = x { (_y, _z) } else { todo!() };\n+   |     +++++++++++++++++                        +++++++++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variant that isn't matched\n+   |\n+LL |     let Foo::D(_y, _z) = x else { todo!() };\n+   |                            ++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "74216d265d03416e218903443c3a6c5d46a9ef0c", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01ad0ad653d57a5ccecffb08aff3c5564012f133/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=01ad0ad653d57a5ccecffb08aff3c5564012f133", "patch": "@@ -132,8 +132,12 @@ LL | | }\n    = note: the matched value is of type `Result<u32, Void>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Ok(x) = x { /* */ }\n+LL |     let x = if let Ok(x) = x { x } else { todo!() };\n+   |     ++++++++++               ++++++++++++++++++++++\n+help: alternatively, on nightly, you might want to use `#![feature(let_else)]` to handle the variant that isn't matched\n    |\n+LL |     let Ok(x) = x else { todo!() };\n+   |                   ++++++++++++++++\n \n error: aborting due to 7 previous errors\n "}]}