{"sha": "74cdf933078d9a936ab5103b6c29148d61fe4b16", "node_id": "C_kwDOAAsO6NoAKDc0Y2RmOTMzMDc4ZDlhOTM2YWI1MTAzYjZjMjkxNDhkNjFmZTRiMTY", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-12-15T11:21:39Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-01-02T01:14:15Z"}, "message": "code refactor report_method_error", "tree": {"sha": "3bd3d0ae203e3369bd035a5e24f5e0356b86874a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bd3d0ae203e3369bd035a5e24f5e0356b86874a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74cdf933078d9a936ab5103b6c29148d61fe4b16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74cdf933078d9a936ab5103b6c29148d61fe4b16", "html_url": "https://github.com/rust-lang/rust/commit/74cdf933078d9a936ab5103b6c29148d61fe4b16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74cdf933078d9a936ab5103b6c29148d61fe4b16/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67d16171d7eebc08057a46aeed887252e7cc286b", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d16171d7eebc08057a46aeed887252e7cc286b", "html_url": "https://github.com/rust-lang/rust/commit/67d16171d7eebc08057a46aeed887252e7cc286b"}], "stats": {"total": 1799, "additions": 894, "deletions": 905}, "files": [{"sha": "d391e3182072aea70c2a38a33a8d458d2982c8e3", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 894, "deletions": 905, "changes": 1799, "blob_url": "https://github.com/rust-lang/rust/blob/74cdf933078d9a936ab5103b6c29148d61fe4b16/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74cdf933078d9a936ab5103b6c29148d61fe4b16/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=74cdf933078d9a936ab5103b6c29148d61fe4b16", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn report_method_error(\n         &self,\n-        mut span: Span,\n+        span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n         source: SelfSource<'tcx>,\n@@ -114,144 +114,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        let report_candidates = |span: Span,\n-                                 err: &mut Diagnostic,\n-                                 sources: &mut Vec<CandidateSource>,\n-                                 sugg_span: Option<Span>| {\n-            sources.sort();\n-            sources.dedup();\n-            // Dynamic limit to avoid hiding just one candidate, which is silly.\n-            let limit = if sources.len() == 5 { 5 } else { 4 };\n-\n-            for (idx, source) in sources.iter().take(limit).enumerate() {\n-                match *source {\n-                    CandidateSource::Impl(impl_did) => {\n-                        // Provide the best span we can. Use the item, if local to crate, else\n-                        // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n-                            let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n-                            self.associated_value(impl_trait_ref.def_id, item_name)\n-                        }) else {\n-                            continue;\n-                        };\n-\n-                        let note_span = if item.def_id.is_local() {\n-                            Some(self.tcx.def_span(item.def_id))\n-                        } else if impl_did.is_local() {\n-                            Some(self.tcx.def_span(impl_did))\n-                        } else {\n-                            None\n-                        };\n-\n-                        let impl_ty = self.tcx.at(span).type_of(impl_did);\n-\n-                        let insertion = match self.tcx.impl_trait_ref(impl_did) {\n-                            None => String::new(),\n-                            Some(trait_ref) => format!(\n-                                \" of the trait `{}`\",\n-                                self.tcx.def_path_str(trait_ref.def_id)\n-                            ),\n-                        };\n-\n-                        let (note_str, idx) = if sources.len() > 1 {\n-                            (\n-                                format!(\n-                                    \"candidate #{} is defined in an impl{} for the type `{}`\",\n-                                    idx + 1,\n-                                    insertion,\n-                                    impl_ty,\n-                                ),\n-                                Some(idx + 1),\n-                            )\n-                        } else {\n-                            (\n-                                format!(\n-                                    \"the candidate is defined in an impl{} for the type `{}`\",\n-                                    insertion, impl_ty,\n-                                ),\n-                                None,\n-                            )\n-                        };\n-                        if let Some(note_span) = note_span {\n-                            // We have a span pointing to the method. Show note with snippet.\n-                            err.span_note(note_span, &note_str);\n-                        } else {\n-                            err.note(&note_str);\n-                        }\n-                        if let Some(sugg_span) = sugg_span\n-                            && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-                            let path = self.tcx.def_path_str(trait_ref.def_id);\n-\n-                            let ty = match item.kind {\n-                                ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n-                                ty::AssocKind::Fn => self\n-                                    .tcx\n-                                    .fn_sig(item.def_id)\n-                                    .inputs()\n-                                    .skip_binder()\n-                                    .get(0)\n-                                    .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n-                                    .copied()\n-                                    .unwrap_or(rcvr_ty),\n-                            };\n-                            print_disambiguation_help(\n-                                item_name,\n-                                args,\n-                                err,\n-                                path,\n-                                ty,\n-                                item.kind,\n-                                item.def_id,\n-                                sugg_span,\n-                                idx,\n-                                self.tcx.sess.source_map(),\n-                                item.fn_has_self_parameter,\n-                            );\n-                        }\n-                    }\n-                    CandidateSource::Trait(trait_did) => {\n-                        let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n-                        let item_span = self.tcx.def_span(item.def_id);\n-                        let idx = if sources.len() > 1 {\n-                            let msg = &format!(\n-                                \"candidate #{} is defined in the trait `{}`\",\n-                                idx + 1,\n-                                self.tcx.def_path_str(trait_did)\n-                            );\n-                            err.span_note(item_span, msg);\n-                            Some(idx + 1)\n-                        } else {\n-                            let msg = &format!(\n-                                \"the candidate is defined in the trait `{}`\",\n-                                self.tcx.def_path_str(trait_did)\n-                            );\n-                            err.span_note(item_span, msg);\n-                            None\n-                        };\n-                        if let Some(sugg_span) = sugg_span {\n-                            let path = self.tcx.def_path_str(trait_did);\n-                            print_disambiguation_help(\n-                                item_name,\n-                                args,\n-                                err,\n-                                path,\n-                                rcvr_ty,\n-                                item.kind,\n-                                item.def_id,\n-                                sugg_span,\n-                                idx,\n-                                self.tcx.sess.source_map(),\n-                                item.fn_has_self_parameter,\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-            if sources.len() > limit {\n-                err.note(&format!(\"and {} others\", sources.len() - limit));\n-            }\n-        };\n-\n         let sugg_span = if let SelfSource::MethodCall(expr) = source {\n             // Given `foo.bar(baz)`, `expr` is `bar`, but we want to point to the whole thing.\n             self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id)).span\n@@ -260,843 +122,970 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         match error {\n-            MethodError::NoMatch(NoMatchData {\n-                mut static_candidates,\n-                unsatisfied_predicates,\n-                out_of_scope_traits,\n-                lev_candidate,\n-                mode,\n-            }) => {\n-                let tcx = self.tcx;\n-\n-                let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n-                let is_method = mode == Mode::MethodCall;\n-                let item_kind = if is_method {\n-                    \"method\"\n-                } else if rcvr_ty.is_enum() {\n-                    \"variant or associated item\"\n-                } else {\n-                    match (item_name.as_str().chars().next(), rcvr_ty.is_fresh_ty()) {\n-                        (Some(name), false) if name.is_lowercase() => \"function or associated item\",\n-                        (Some(_), false) => \"associated item\",\n-                        (Some(_), true) | (None, false) => \"variant or associated item\",\n-                        (None, true) => \"variant\",\n-                    }\n-                };\n-\n-                if self.suggest_wrapping_range_with_parens(\n-                    tcx, rcvr_ty, source, span, item_name, &ty_str,\n-                ) || self.suggest_constraining_numerical_ty(\n-                    tcx, rcvr_ty, source, span, item_kind, item_name, &ty_str,\n-                ) {\n-                    return None;\n-                }\n-                span = item_name.span;\n-\n-                // Don't show generic arguments when the method can't be found in any implementation (#81576).\n-                let mut ty_str_reported = ty_str.clone();\n-                if let ty::Adt(_, generics) = rcvr_ty.kind() {\n-                    if generics.len() > 0 {\n-                        let mut autoderef = self.autoderef(span, rcvr_ty);\n-                        let candidate_found = autoderef.any(|(ty, _)| {\n-                            if let ty::Adt(adt_def, _) = ty.kind() {\n-                                self.tcx\n-                                    .inherent_impls(adt_def.did())\n-                                    .iter()\n-                                    .filter_map(|def_id| self.associated_value(*def_id, item_name))\n-                                    .count()\n-                                    >= 1\n-                            } else {\n-                                false\n-                            }\n-                        });\n-                        let has_deref = autoderef.step_count() > 0;\n-                        if !candidate_found && !has_deref && unsatisfied_predicates.is_empty() {\n-                            if let Some((path_string, _)) = ty_str.split_once('<') {\n-                                ty_str_reported = path_string.to_string();\n-                            }\n-                        }\n-                    }\n-                }\n+            MethodError::NoMatch(mut no_match_data) => {\n+                return self.report_no_match_method_error(\n+                    span,\n+                    rcvr_ty,\n+                    item_name,\n+                    source,\n+                    args,\n+                    sugg_span,\n+                    &mut no_match_data,\n+                );\n+            }\n \n+            MethodError::Ambiguity(mut sources) => {\n                 let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0599,\n-                    \"no {} named `{}` found for {} `{}` in the current scope\",\n-                    item_kind,\n+                    self.sess(),\n+                    item_name.span,\n+                    E0034,\n+                    \"multiple applicable items in scope\"\n+                );\n+                err.span_label(item_name.span, format!(\"multiple `{}` found\", item_name));\n+\n+                self.note_candidates_on_method_error(\n+                    rcvr_ty,\n                     item_name,\n-                    rcvr_ty.prefix_string(self.tcx),\n-                    ty_str_reported,\n+                    args,\n+                    span,\n+                    &mut err,\n+                    &mut sources,\n+                    Some(sugg_span),\n                 );\n-                if rcvr_ty.references_error() {\n-                    err.downgrade_to_delayed_bug();\n-                }\n+                err.emit();\n+            }\n \n-                if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n-                    self.suggest_await_before_method(\n-                        &mut err, item_name, rcvr_ty, cal, span,\n-                    );\n-                }\n-                if let Some(span) =\n-                    tcx.resolutions(()).confused_type_with_std_module.get(&span.with_parent(None))\n-                {\n-                    err.span_suggestion(\n-                        span.shrink_to_lo(),\n-                        \"you are looking for the module in `std`, not the primitive type\",\n-                        \"std::\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if let ty::RawPtr(_) = &rcvr_ty.kind() {\n-                    err.note(\n-                        \"try using `<*const T>::as_ref()` to get a reference to the \\\n-                         type behind the pointer: https://doc.rust-lang.org/std/\\\n-                         primitive.pointer.html#method.as_ref\",\n-                    );\n-                    err.note(\n-                        \"using `<*const T>::as_ref()` on a pointer which is unaligned or points \\\n-                         to invalid or uninitialized memory is undefined behavior\",\n-                    );\n-                }\n+            MethodError::PrivateMatch(kind, def_id, out_of_scope_traits) => {\n+                let kind = kind.descr(def_id);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    item_name.span,\n+                    E0624,\n+                    \"{} `{}` is private\",\n+                    kind,\n+                    item_name\n+                );\n+                err.span_label(item_name.span, &format!(\"private {}\", kind));\n+                let sp = self\n+                    .tcx\n+                    .hir()\n+                    .span_if_local(def_id)\n+                    .unwrap_or_else(|| self.tcx.def_span(def_id));\n+                err.span_label(sp, &format!(\"private {} defined here\", kind));\n+                self.suggest_valid_traits(&mut err, out_of_scope_traits);\n+                err.emit();\n+            }\n \n-                let ty_span = match rcvr_ty.kind() {\n-                    ty::Param(param_type) => Some(\n-                        param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n-                    ),\n-                    ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n-                    _ => None,\n-                };\n-                if let Some(span) = ty_span {\n-                    err.span_label(\n-                        span,\n-                        format!(\n-                            \"{item_kind} `{item_name}` not found for this {}\",\n-                            rcvr_ty.prefix_string(self.tcx)\n-                        ),\n+            MethodError::IllegalSizedBound(candidates, needs_mut, bound_span) => {\n+                let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n+                let mut err = self.sess().struct_span_err(span, &msg);\n+                err.span_label(bound_span, \"this has a `Sized` requirement\");\n+                if !candidates.is_empty() {\n+                    let help = format!(\n+                        \"{an}other candidate{s} {were} found in the following trait{s}, perhaps \\\n+                         add a `use` for {one_of_them}:\",\n+                        an = if candidates.len() == 1 { \"an\" } else { \"\" },\n+                        s = pluralize!(candidates.len()),\n+                        were = pluralize!(\"was\", candidates.len()),\n+                        one_of_them = if candidates.len() == 1 { \"it\" } else { \"one_of_them\" },\n                     );\n+                    self.suggest_use_candidates(&mut err, help, candidates);\n                 }\n-\n-                if let SelfSource::MethodCall(rcvr_expr) = source {\n-                    self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n-                        let call_expr = self\n-                            .tcx\n-                            .hir()\n-                            .expect_expr(self.tcx.hir().get_parent_node(rcvr_expr.hir_id));\n-                        let probe = self.lookup_probe(\n-                            item_name,\n-                            output_ty,\n-                            call_expr,\n-                            ProbeScope::AllTraits,\n+                if let ty::Ref(region, t_type, mutability) = rcvr_ty.kind() {\n+                    if needs_mut {\n+                        let trait_type = self.tcx.mk_ref(\n+                            *region,\n+                            ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() },\n                         );\n-                        probe.is_ok()\n-                    });\n+                        err.note(&format!(\"you need `{}` instead of `{}`\", trait_type, rcvr_ty));\n+                    }\n                 }\n+                err.emit();\n+            }\n \n-                let mut custom_span_label = false;\n-\n-                if !static_candidates.is_empty() {\n-                    err.note(\n-                        \"found the following associated functions; to be used as methods, \\\n-                         functions must have a `self` parameter\",\n-                    );\n-                    err.span_label(span, \"this is an associated function, not a method\");\n-                    custom_span_label = true;\n-                }\n-                if static_candidates.len() == 1 {\n-                    self.suggest_associated_call_syntax(\n-                        &mut err,\n-                        &static_candidates,\n-                        rcvr_ty,\n-                        source,\n-                        item_name,\n-                        args,\n-                        sugg_span,\n-                    );\n+            MethodError::BadReturnType => bug!(\"no return type expectations but got BadReturnType\"),\n+        }\n+        None\n+    }\n \n-                    report_candidates(span, &mut err, &mut static_candidates, None);\n-                } else if static_candidates.len() > 1 {\n-                    report_candidates(span, &mut err, &mut static_candidates, Some(sugg_span));\n-                }\n+    pub fn report_no_match_method_error(\n+        &self,\n+        mut span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        item_name: Ident,\n+        source: SelfSource<'tcx>,\n+        args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n+        sugg_span: Span,\n+        no_match_data: &mut NoMatchData<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n+        let mode = no_match_data.mode;\n+        let tcx = self.tcx;\n+        let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n+        let ty_str = self.ty_to_string(rcvr_ty);\n+        let is_method = mode == Mode::MethodCall;\n+        let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n+        let lev_candidate = no_match_data.lev_candidate;\n+        let item_kind = if is_method {\n+            \"method\"\n+        } else if rcvr_ty.is_enum() {\n+            \"variant or associated item\"\n+        } else {\n+            match (item_name.as_str().chars().next(), rcvr_ty.is_fresh_ty()) {\n+                (Some(name), false) if name.is_lowercase() => \"function or associated item\",\n+                (Some(_), false) => \"associated item\",\n+                (Some(_), true) | (None, false) => \"variant or associated item\",\n+                (None, true) => \"variant\",\n+            }\n+        };\n \n-                let mut bound_spans = vec![];\n-                let mut restrict_type_params = false;\n-                let mut unsatisfied_bounds = false;\n-                if item_name.name == sym::count && self.is_slice_ty(rcvr_ty, span) {\n-                    let msg = \"consider using `len` instead\";\n-                    if let SelfSource::MethodCall(_expr) = source {\n-                        err.span_suggestion_short(\n-                            span,\n-                            msg,\n-                            \"len\",\n-                            Applicability::MachineApplicable,\n-                        );\n+        if self.suggest_wrapping_range_with_parens(tcx, rcvr_ty, source, span, item_name, &ty_str)\n+            || self.suggest_constraining_numerical_ty(\n+                tcx, rcvr_ty, source, span, item_kind, item_name, &ty_str,\n+            )\n+        {\n+            return None;\n+        }\n+        span = item_name.span;\n+\n+        // Don't show generic arguments when the method can't be found in any implementation (#81576).\n+        let mut ty_str_reported = ty_str.clone();\n+        if let ty::Adt(_, generics) = rcvr_ty.kind() {\n+            if generics.len() > 0 {\n+                let mut autoderef = self.autoderef(span, rcvr_ty);\n+                let candidate_found = autoderef.any(|(ty, _)| {\n+                    if let ty::Adt(adt_def, _) = ty.kind() {\n+                        self.tcx\n+                            .inherent_impls(adt_def.did())\n+                            .iter()\n+                            .filter_map(|def_id| self.associated_value(*def_id, item_name))\n+                            .count()\n+                            >= 1\n                     } else {\n-                        err.span_label(span, msg);\n-                    }\n-                    if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n-                        let iterator_trait = self.tcx.def_path_str(iterator_trait);\n-                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"));\n+                        false\n                     }\n-                } else if !unsatisfied_predicates.is_empty() {\n-                    let mut type_params = FxHashMap::default();\n-\n-                    // Pick out the list of unimplemented traits on the receiver.\n-                    // This is used for custom error messages with the `#[rustc_on_unimplemented]` attribute.\n-                    let mut unimplemented_traits = FxHashMap::default();\n-                    let mut unimplemented_traits_only = true;\n-                    for (predicate, _parent_pred, cause) in &unsatisfied_predicates {\n-                        if let (ty::PredicateKind::Clause(ty::Clause::Trait(p)), Some(cause)) =\n-                            (predicate.kind().skip_binder(), cause.as_ref())\n-                        {\n-                            if p.trait_ref.self_ty() != rcvr_ty {\n-                                // This is necessary, not just to keep the errors clean, but also\n-                                // because our derived obligations can wind up with a trait ref that\n-                                // requires a different param_env to be correctly compared.\n-                                continue;\n-                            }\n-                            unimplemented_traits.entry(p.trait_ref.def_id).or_insert((\n-                                predicate.kind().rebind(p.trait_ref),\n-                                Obligation {\n-                                    cause: cause.clone(),\n-                                    param_env: self.param_env,\n-                                    predicate: *predicate,\n-                                    recursion_depth: 0,\n-                                },\n-                            ));\n-                        }\n+                });\n+                let has_deref = autoderef.step_count() > 0;\n+                if !candidate_found && !has_deref && unsatisfied_predicates.is_empty() {\n+                    if let Some((path_string, _)) = ty_str.split_once('<') {\n+                        ty_str_reported = path_string.to_string();\n                     }\n+                }\n+            }\n+        }\n \n-                    // Make sure that, if any traits other than the found ones were involved,\n-                    // we don't don't report an unimplemented trait.\n-                    // We don't want to say that `iter::Cloned` is not an iterator, just\n-                    // because of some non-Clone item being iterated over.\n-                    for (predicate, _parent_pred, _cause) in &unsatisfied_predicates {\n-                        match predicate.kind().skip_binder() {\n-                            ty::PredicateKind::Clause(ty::Clause::Trait(p))\n-                                if unimplemented_traits.contains_key(&p.trait_ref.def_id) => {}\n-                            _ => {\n-                                unimplemented_traits_only = false;\n-                                break;\n-                            }\n-                        }\n-                    }\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0599,\n+            \"no {} named `{}` found for {} `{}` in the current scope\",\n+            item_kind,\n+            item_name,\n+            rcvr_ty.prefix_string(self.tcx),\n+            ty_str_reported,\n+        );\n+        if rcvr_ty.references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n \n-                    let mut collect_type_param_suggestions =\n-                        |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n-                            // We don't care about regions here, so it's fine to skip the binder here.\n-                            if let (ty::Param(_), ty::PredicateKind::Clause(ty::Clause::Trait(p))) =\n-                                (self_ty.kind(), parent_pred.kind().skip_binder())\n-                            {\n-                                let hir = self.tcx.hir();\n-                                let node = match p.trait_ref.self_ty().kind() {\n-                                    ty::Param(_) => {\n-                                        // Account for `fn` items like in `issue-35677.rs` to\n-                                        // suggest restricting its type params.\n-                                        let parent_body =\n-                                            hir.body_owner(hir::BodyId { hir_id: self.body_id });\n-                                        Some(hir.get(parent_body))\n-                                    }\n-                                    ty::Adt(def, _) => {\n-                                        def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n-                                    }\n-                                    _ => None,\n-                                };\n-                                if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n-                                    if let Some(g) = kind.generics() {\n-                                        let key = (\n-                                            g.tail_span_for_predicate_suggestion(),\n-                                            g.add_where_or_trailing_comma(),\n-                                        );\n-                                        type_params\n-                                            .entry(key)\n-                                            .or_insert_with(FxHashSet::default)\n-                                            .insert(obligation.to_owned());\n-                                    }\n-                                }\n-                            }\n-                        };\n-                    let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n-                        let msg = format!(\n-                            \"doesn't satisfy `{}`\",\n-                            if obligation.len() > 50 { quiet } else { obligation }\n-                        );\n-                        match &self_ty.kind() {\n-                            // Point at the type that couldn't satisfy the bound.\n-                            ty::Adt(def, _) => {\n-                                bound_spans.push((self.tcx.def_span(def.did()), msg))\n-                            }\n-                            // Point at the trait object that couldn't satisfy the bound.\n-                            ty::Dynamic(preds, _, _) => {\n-                                for pred in preds.iter() {\n-                                    match pred.skip_binder() {\n-                                        ty::ExistentialPredicate::Trait(tr) => bound_spans\n-                                            .push((self.tcx.def_span(tr.def_id), msg.clone())),\n-                                        ty::ExistentialPredicate::Projection(_)\n-                                        | ty::ExistentialPredicate::AutoTrait(_) => {}\n-                                    }\n-                                }\n-                            }\n-                            // Point at the closure that couldn't satisfy the bound.\n-                            ty::Closure(def_id, _) => bound_spans.push((\n-                                tcx.def_span(*def_id),\n-                                format!(\"doesn't satisfy `{}`\", quiet),\n-                            )),\n-                            _ => {}\n-                        }\n-                    };\n-                    let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        let bound_predicate = pred.kind();\n-                        match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n-                                let pred = bound_predicate.rebind(pred);\n-                                // `<Foo as Iterator>::Item = String`.\n-                                let projection_ty = pred.skip_binder().projection_ty;\n-\n-                                let substs_with_infer_self = tcx.mk_substs(\n-                                    iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n-                                        .chain(projection_ty.substs.iter().skip(1)),\n-                                );\n+        if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n+            self.suggest_await_before_method(\n+                &mut err, item_name, rcvr_ty, cal, span,\n+            );\n+        }\n+        if let Some(span) =\n+            tcx.resolutions(()).confused_type_with_std_module.get(&span.with_parent(None))\n+        {\n+            err.span_suggestion(\n+                span.shrink_to_lo(),\n+                \"you are looking for the module in `std`, not the primitive type\",\n+                \"std::\",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        if let ty::RawPtr(_) = &rcvr_ty.kind() {\n+            err.note(\n+                \"try using `<*const T>::as_ref()` to get a reference to the \\\n+                 type behind the pointer: https://doc.rust-lang.org/std/\\\n+                 primitive.pointer.html#method.as_ref\",\n+            );\n+            err.note(\n+                \"using `<*const T>::as_ref()` on a pointer which is unaligned or points \\\n+                 to invalid or uninitialized memory is undefined behavior\",\n+            );\n+        }\n \n-                                let quiet_projection_ty =\n-                                    tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n+        let ty_span = match rcvr_ty.kind() {\n+            ty::Param(param_type) => {\n+                Some(param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()))\n+            }\n+            ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n+            _ => None,\n+        };\n+        if let Some(span) = ty_span {\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"{item_kind} `{item_name}` not found for this {}\",\n+                    rcvr_ty.prefix_string(self.tcx)\n+                ),\n+            );\n+        }\n \n-                                let term = pred.skip_binder().term;\n+        if let SelfSource::MethodCall(rcvr_expr) = source {\n+            self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n+                let call_expr =\n+                    self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(rcvr_expr.hir_id));\n+                let probe =\n+                    self.lookup_probe(item_name, output_ty, call_expr, ProbeScope::AllTraits);\n+                probe.is_ok()\n+            });\n+        }\n \n-                                let obligation = format!(\"{} = {}\", projection_ty, term);\n-                                let quiet = with_forced_trimmed_paths!(format!(\n-                                    \"{} = {}\",\n-                                    quiet_projection_ty, term\n-                                ));\n+        let mut custom_span_label = false;\n \n-                                bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n-                                Some((obligation, projection_ty.self_ty()))\n-                            }\n-                            ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n-                                let p = poly_trait_ref.trait_ref;\n-                                let self_ty = p.self_ty();\n-                                let path = p.print_only_trait_path();\n-                                let obligation = format!(\"{}: {}\", self_ty, path);\n-                                let quiet = with_forced_trimmed_paths!(format!(\"_: {}\", path));\n-                                bound_span_label(self_ty, &obligation, &quiet);\n-                                Some((obligation, self_ty))\n-                            }\n-                            _ => None,\n-                        }\n-                    };\n+        let static_candidates = &mut no_match_data.static_candidates;\n+        if !static_candidates.is_empty() {\n+            err.note(\n+                \"found the following associated functions; to be used as methods, \\\n+                 functions must have a `self` parameter\",\n+            );\n+            err.span_label(span, \"this is an associated function, not a method\");\n+            custom_span_label = true;\n+        }\n+        if static_candidates.len() == 1 {\n+            self.suggest_associated_call_syntax(\n+                &mut err,\n+                &static_candidates,\n+                rcvr_ty,\n+                source,\n+                item_name,\n+                args,\n+                sugg_span,\n+            );\n \n-                    // Find all the requirements that come from a local `impl` block.\n-                    let mut skip_list: FxHashSet<_> = Default::default();\n-                    let mut spanned_predicates: FxHashMap<MultiSpan, _> = Default::default();\n-                    for (data, p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n-                        .iter()\n-                        .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n-                        .filter_map(|(p, parent, c)| match c.code() {\n-                            ObligationCauseCode::ImplDerivedObligation(data) => {\n-                                Some((&data.derived, p, parent, data.impl_def_id, data))\n-                            }\n-                            _ => None,\n-                        })\n-                    {\n-                        let parent_trait_ref = data.parent_trait_pred;\n-                        let path = parent_trait_ref.print_modifiers_and_trait_path();\n-                        let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n-                        let unsatisfied_msg = \"unsatisfied trait bound introduced here\";\n-                        let derive_msg =\n-                            \"unsatisfied trait bound introduced in this `derive` macro\";\n-                        match self.tcx.hir().get_if_local(impl_def_id) {\n-                            // Unmet obligation comes from a `derive` macro, point at it once to\n-                            // avoid multiple span labels pointing at the same place.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n-                                ..\n-                            })) if matches!(\n-                                self_ty.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) || matches!(\n-                                of_trait.as_ref().map(|t| t\n-                                    .path\n-                                    .span\n-                                    .ctxt()\n-                                    .outer_expn_data()\n-                                    .kind),\n-                                Some(ExpnKind::Macro(MacroKind::Derive, _))\n-                            ) =>\n-                            {\n-                                let span = self_ty.span.ctxt().outer_expn_data().call_site;\n-                                let mut spans: MultiSpan = span.into();\n-                                spans.push_span_label(span, derive_msg);\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n+            self.note_candidates_on_method_error(\n+                rcvr_ty,\n+                item_name,\n+                args,\n+                span,\n+                &mut err,\n+                static_candidates,\n+                None,\n+            );\n+        } else if static_candidates.len() > 1 {\n+            self.note_candidates_on_method_error(\n+                rcvr_ty,\n+                item_name,\n+                args,\n+                span,\n+                &mut err,\n+                static_candidates,\n+                Some(sugg_span),\n+            );\n+        }\n \n-                            // Unmet obligation coming from an `impl`.\n-                            Some(Node::Item(hir::Item {\n-                                kind:\n-                                    hir::ItemKind::Impl(hir::Impl {\n-                                        of_trait, self_ty, generics, ..\n-                                    }),\n-                                span: item_span,\n-                                ..\n-                            })) => {\n-                                let sized_pred =\n-                                    unsatisfied_predicates.iter().any(|(pred, _, _)| {\n-                                        match pred.kind().skip_binder() {\n-                                            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n-                                                Some(pred.def_id())\n-                                                    == self.tcx.lang_items().sized_trait()\n-                                                    && pred.polarity == ty::ImplPolarity::Positive\n-                                            }\n-                                            _ => false,\n-                                        }\n-                                    });\n-                                for param in generics.params {\n-                                    if param.span == cause.span && sized_pred {\n-                                        let (sp, sugg) = match param.colon_span {\n-                                            Some(sp) => (sp.shrink_to_hi(), \" ?Sized +\"),\n-                                            None => (param.span.shrink_to_hi(), \": ?Sized\"),\n-                                        };\n-                                        err.span_suggestion_verbose(\n-                                            sp,\n-                                            \"consider relaxing the type parameter's implicit \\\n-                                             `Sized` bound\",\n-                                            sugg,\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                }\n-                                if let Some(pred) = parent_p {\n-                                    // Done to add the \"doesn't satisfy\" `span_label`.\n-                                    let _ = format_pred(*pred);\n-                                }\n-                                skip_list.insert(p);\n-                                let mut spans = if cause.span != *item_span {\n-                                    let mut spans: MultiSpan = cause.span.into();\n-                                    spans.push_span_label(cause.span, unsatisfied_msg);\n-                                    spans\n-                                } else {\n-                                    let mut spans = Vec::with_capacity(2);\n-                                    if let Some(trait_ref) = of_trait {\n-                                        spans.push(trait_ref.path.span);\n-                                    }\n-                                    spans.push(self_ty.span);\n-                                    spans.into()\n-                                };\n-                                if let Some(trait_ref) = of_trait {\n-                                    spans.push_span_label(trait_ref.path.span, \"\");\n-                                }\n-                                spans.push_span_label(self_ty.span, \"\");\n+        let mut bound_spans = vec![];\n+        let mut restrict_type_params = false;\n+        let mut unsatisfied_bounds = false;\n+        if item_name.name == sym::count && self.is_slice_ty(rcvr_ty, span) {\n+            let msg = \"consider using `len` instead\";\n+            if let SelfSource::MethodCall(_expr) = source {\n+                err.span_suggestion_short(span, msg, \"len\", Applicability::MachineApplicable);\n+            } else {\n+                err.span_label(span, msg);\n+            }\n+            if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n+                let iterator_trait = self.tcx.def_path_str(iterator_trait);\n+                err.note(&format!(\n+                    \"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"\n+                ));\n+            }\n+        } else if !unsatisfied_predicates.is_empty() {\n+            let mut type_params = FxHashMap::default();\n+\n+            // Pick out the list of unimplemented traits on the receiver.\n+            // This is used for custom error messages with the `#[rustc_on_unimplemented]` attribute.\n+            let mut unimplemented_traits = FxHashMap::default();\n+            let mut unimplemented_traits_only = true;\n+            for (predicate, _parent_pred, cause) in unsatisfied_predicates {\n+                if let (ty::PredicateKind::Clause(ty::Clause::Trait(p)), Some(cause)) =\n+                    (predicate.kind().skip_binder(), cause.as_ref())\n+                {\n+                    if p.trait_ref.self_ty() != rcvr_ty {\n+                        // This is necessary, not just to keep the errors clean, but also\n+                        // because our derived obligations can wind up with a trait ref that\n+                        // requires a different param_env to be correctly compared.\n+                        continue;\n+                    }\n+                    unimplemented_traits.entry(p.trait_ref.def_id).or_insert((\n+                        predicate.kind().rebind(p.trait_ref),\n+                        Obligation {\n+                            cause: cause.clone(),\n+                            param_env: self.param_env,\n+                            predicate: *predicate,\n+                            recursion_depth: 0,\n+                        },\n+                    ));\n+                }\n+            }\n \n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+            // Make sure that, if any traits other than the found ones were involved,\n+            // we don't don't report an unimplemented trait.\n+            // We don't want to say that `iter::Cloned` is not an iterator, just\n+            // because of some non-Clone item being iterated over.\n+            for (predicate, _parent_pred, _cause) in unsatisfied_predicates {\n+                match predicate.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(p))\n+                        if unimplemented_traits.contains_key(&p.trait_ref.def_id) => {}\n+                    _ => {\n+                        unimplemented_traits_only = false;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            let mut collect_type_param_suggestions =\n+                |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n+                    // We don't care about regions here, so it's fine to skip the binder here.\n+                    if let (ty::Param(_), ty::PredicateKind::Clause(ty::Clause::Trait(p))) =\n+                        (self_ty.kind(), parent_pred.kind().skip_binder())\n+                    {\n+                        let hir = self.tcx.hir();\n+                        let node = match p.trait_ref.self_ty().kind() {\n+                            ty::Param(_) => {\n+                                // Account for `fn` items like in `issue-35677.rs` to\n+                                // suggest restricting its type params.\n+                                let parent_body =\n+                                    hir.body_owner(hir::BodyId { hir_id: self.body_id });\n+                                Some(hir.get(parent_body))\n                             }\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(rustc_ast::ast::IsAuto::Yes, ..),\n-                                span: item_span,\n-                                ..\n-                            })) => {\n-                                tcx.sess.delay_span_bug(\n-                                        *item_span,\n-                                        \"auto trait is invoked with no method error, but no error reported?\",\n-                                    );\n+                            ty::Adt(def, _) => {\n+                                def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n+                            }\n+                            _ => None,\n+                        };\n+                        if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n+                            if let Some(g) = kind.generics() {\n+                                let key = (\n+                                    g.tail_span_for_predicate_suggestion(),\n+                                    g.add_where_or_trailing_comma(),\n+                                );\n+                                type_params\n+                                    .entry(key)\n+                                    .or_insert_with(FxHashSet::default)\n+                                    .insert(obligation.to_owned());\n                             }\n-                            Some(_) => unreachable!(),\n-                            None => (),\n                         }\n                     }\n-                    let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n-                    spanned_predicates.sort_by_key(|(span, (_, _, _))| span.primary_span());\n-                    for (span, (_path, _self_ty, preds)) in spanned_predicates {\n-                        let mut preds: Vec<_> = preds\n-                            .into_iter()\n-                            .filter_map(|pred| format_pred(*pred))\n-                            .map(|(p, _)| format!(\"`{}`\", p))\n-                            .collect();\n-                        preds.sort();\n-                        preds.dedup();\n-                        let msg = if let [pred] = &preds[..] {\n-                            format!(\"trait bound {} was not satisfied\", pred)\n-                        } else {\n-                            format!(\n-                                \"the following trait bounds were not satisfied:\\n{}\",\n-                                preds.join(\"\\n\"),\n-                            )\n-                        };\n-                        err.span_note(span, &msg);\n-                        unsatisfied_bounds = true;\n+                };\n+            let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n+                let msg = format!(\n+                    \"doesn't satisfy `{}`\",\n+                    if obligation.len() > 50 { quiet } else { obligation }\n+                );\n+                match &self_ty.kind() {\n+                    // Point at the type that couldn't satisfy the bound.\n+                    ty::Adt(def, _) => bound_spans.push((self.tcx.def_span(def.did()), msg)),\n+                    // Point at the trait object that couldn't satisfy the bound.\n+                    ty::Dynamic(preds, _, _) => {\n+                        for pred in preds.iter() {\n+                            match pred.skip_binder() {\n+                                ty::ExistentialPredicate::Trait(tr) => {\n+                                    bound_spans.push((self.tcx.def_span(tr.def_id), msg.clone()))\n+                                }\n+                                ty::ExistentialPredicate::Projection(_)\n+                                | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                            }\n+                        }\n                     }\n-\n-                    // The requirements that didn't have an `impl` span to show.\n-                    let mut bound_list = unsatisfied_predicates\n-                        .iter()\n-                        .filter_map(|(pred, parent_pred, _cause)| {\n-                            format_pred(*pred).map(|(p, self_ty)| {\n-                                collect_type_param_suggestions(self_ty, *pred, &p);\n-                                (\n-                                    match parent_pred {\n-                                        None => format!(\"`{}`\", &p),\n-                                        Some(parent_pred) => match format_pred(*parent_pred) {\n-                                            None => format!(\"`{}`\", &p),\n-                                            Some((parent_p, _)) => {\n-                                                collect_type_param_suggestions(\n-                                                    self_ty,\n-                                                    *parent_pred,\n-                                                    &p,\n-                                                );\n-                                                format!(\n-                                                    \"`{}`\\nwhich is required by `{}`\",\n-                                                    p, parent_p\n-                                                )\n-                                            }\n-                                        },\n-                                    },\n-                                    *pred,\n-                                )\n-                            })\n-                        })\n-                        .filter(|(_, pred)| !skip_list.contains(&pred))\n-                        .map(|(t, _)| t)\n-                        .enumerate()\n-                        .collect::<Vec<(usize, String)>>();\n-\n-                    for ((span, add_where_or_comma), obligations) in type_params.into_iter() {\n-                        restrict_type_params = true;\n-                        // #74886: Sort here so that the output is always the same.\n-                        let mut obligations = obligations.into_iter().collect::<Vec<_>>();\n-                        obligations.sort();\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            &format!(\n-                                \"consider restricting the type parameter{s} to satisfy the \\\n-                                 trait bound{s}\",\n-                                s = pluralize!(obligations.len())\n-                            ),\n-                            format!(\"{} {}\", add_where_or_comma, obligations.join(\", \")),\n-                            Applicability::MaybeIncorrect,\n+                    // Point at the closure that couldn't satisfy the bound.\n+                    ty::Closure(def_id, _) => bound_spans\n+                        .push((tcx.def_span(*def_id), format!(\"doesn't satisfy `{}`\", quiet))),\n+                    _ => {}\n+                }\n+            };\n+            let mut format_pred = |pred: ty::Predicate<'tcx>| {\n+                let bound_predicate = pred.kind();\n+                match bound_predicate.skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n+                        let pred = bound_predicate.rebind(pred);\n+                        // `<Foo as Iterator>::Item = String`.\n+                        let projection_ty = pred.skip_binder().projection_ty;\n+\n+                        let substs_with_infer_self = tcx.mk_substs(\n+                            iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n+                                .chain(projection_ty.substs.iter().skip(1)),\n                         );\n-                    }\n \n-                    bound_list.sort_by(|(_, a), (_, b)| a.cmp(b)); // Sort alphabetically.\n-                    bound_list.dedup_by(|(_, a), (_, b)| a == b); // #35677\n-                    bound_list.sort_by_key(|(pos, _)| *pos); // Keep the original predicate order.\n+                        let quiet_projection_ty =\n+                            tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n \n-                    if !bound_list.is_empty() || !skip_list.is_empty() {\n-                        let bound_list = bound_list\n-                            .into_iter()\n-                            .map(|(_, path)| path)\n-                            .collect::<Vec<_>>()\n-                            .join(\"\\n\");\n-                        let actual_prefix = rcvr_ty.prefix_string(self.tcx);\n-                        info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n-                        let (primary_message, label) =\n-                            if unimplemented_traits.len() == 1 && unimplemented_traits_only {\n-                                unimplemented_traits\n-                                    .into_iter()\n-                                    .next()\n-                                    .map(|(_, (trait_ref, obligation))| {\n-                                        if trait_ref.self_ty().references_error()\n-                                            || rcvr_ty.references_error()\n-                                        {\n-                                            // Avoid crashing.\n-                                            return (None, None);\n-                                        }\n-                                        let OnUnimplementedNote { message, label, .. } = self\n-                                            .err_ctxt()\n-                                            .on_unimplemented_note(trait_ref, &obligation);\n-                                        (message, label)\n-                                    })\n-                                    .unwrap()\n-                            } else {\n-                                (None, None)\n-                            };\n-                        let primary_message = primary_message.unwrap_or_else(|| format!(\n-                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, \\\n-                             but its trait bounds were not satisfied\"\n-                        ));\n-                        err.set_primary_message(&primary_message);\n-                        if let Some(label) = label {\n-                            custom_span_label = true;\n-                            err.span_label(span, label);\n-                        }\n-                        if !bound_list.is_empty() {\n-                            err.note(&format!(\n-                                \"the following trait bounds were not satisfied:\\n{bound_list}\"\n-                            ));\n-                        }\n-                        self.suggest_derive(&mut err, &unsatisfied_predicates);\n+                        let term = pred.skip_binder().term;\n+\n+                        let obligation = format!(\"{} = {}\", projection_ty, term);\n+                        let quiet = format!(\"{} = {}\", quiet_projection_ty, term);\n \n-                        unsatisfied_bounds = true;\n+                        bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                        Some((obligation, projection_ty.self_ty()))\n                     }\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n+                        let p = poly_trait_ref.trait_ref;\n+                        let self_ty = p.self_ty();\n+                        let path = p.print_only_trait_path();\n+                        let obligation = format!(\"{}: {}\", self_ty, path);\n+                        let quiet = format!(\"_: {}\", path);\n+                        bound_span_label(self_ty, &obligation, &quiet);\n+                        Some((obligation, self_ty))\n+                    }\n+                    _ => None,\n                 }\n+            };\n \n-                let label_span_not_found = |err: &mut Diagnostic| {\n-                    if unsatisfied_predicates.is_empty() {\n-                        err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n-                        let is_string_or_ref_str = match rcvr_ty.kind() {\n-                            ty::Ref(_, ty, _) => {\n-                                ty.is_str()\n-                                    || matches!(\n-                                        ty.kind(),\n-                                        ty::Adt(adt, _) if Some(adt.did()) == self.tcx.lang_items().string()\n-                                    )\n-                            }\n-                            ty::Adt(adt, _) => Some(adt.did()) == self.tcx.lang_items().string(),\n-                            _ => false,\n-                        };\n-                        if is_string_or_ref_str && item_name.name == sym::iter {\n-                            err.span_suggestion_verbose(\n-                                item_name.span,\n-                                \"because of the in-memory representation of `&str`, to obtain \\\n-                                 an `Iterator` over each of its codepoint use method `chars`\",\n-                                \"chars\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        if let ty::Adt(adt, _) = rcvr_ty.kind() {\n-                            let mut inherent_impls_candidate = self\n-                                .tcx\n-                                .inherent_impls(adt.did())\n-                                .iter()\n-                                .copied()\n-                                .filter(|def_id| {\n-                                    if let Some(assoc) = self.associated_value(*def_id, item_name) {\n-                                        // Check for both mode is the same so we avoid suggesting\n-                                        // incorrect associated item.\n-                                        match (mode, assoc.fn_has_self_parameter, source) {\n-                                            (Mode::MethodCall, true, SelfSource::MethodCall(_)) => {\n-                                                // We check that the suggest type is actually\n-                                                // different from the received one\n-                                                // So we avoid suggestion method with Box<Self>\n-                                                // for instance\n-                                                self.tcx.at(span).type_of(*def_id) != rcvr_ty\n-                                                    && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n-                                            }\n-                                            (Mode::Path, false, _) => true,\n-                                            _ => false,\n-                                        }\n-                                    } else {\n-                                        false\n+            // Find all the requirements that come from a local `impl` block.\n+            let mut skip_list: FxHashSet<_> = Default::default();\n+            let mut spanned_predicates: FxHashMap<MultiSpan, _> = Default::default();\n+            for (data, p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n+                .iter()\n+                .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n+                .filter_map(|(p, parent, c)| match c.code() {\n+                    ObligationCauseCode::ImplDerivedObligation(data) => {\n+                        Some((&data.derived, p, parent, data.impl_def_id, data))\n+                    }\n+                    _ => None,\n+                })\n+            {\n+                let parent_trait_ref = data.parent_trait_pred;\n+                let path = parent_trait_ref.print_modifiers_and_trait_path();\n+                let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n+                let unsatisfied_msg = \"unsatisfied trait bound introduced here\";\n+                let derive_msg = \"unsatisfied trait bound introduced in this `derive` macro\";\n+                match self.tcx.hir().get_if_local(impl_def_id) {\n+                    // Unmet obligation comes from a `derive` macro, point at it once to\n+                    // avoid multiple span labels pointing at the same place.\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n+                        ..\n+                    })) if matches!(\n+                        self_ty.span.ctxt().outer_expn_data().kind,\n+                        ExpnKind::Macro(MacroKind::Derive, _)\n+                    ) || matches!(\n+                        of_trait.as_ref().map(|t| t.path.span.ctxt().outer_expn_data().kind),\n+                        Some(ExpnKind::Macro(MacroKind::Derive, _))\n+                    ) =>\n+                    {\n+                        let span = self_ty.span.ctxt().outer_expn_data().call_site;\n+                        let mut spans: MultiSpan = span.into();\n+                        spans.push_span_label(span, derive_msg);\n+                        let entry = spanned_predicates.entry(spans);\n+                        entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                    }\n+\n+                    // Unmet obligation coming from an `impl`.\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, generics, .. }),\n+                        span: item_span,\n+                        ..\n+                    })) => {\n+                        let sized_pred =\n+                            unsatisfied_predicates.iter().any(|(pred, _, _)| {\n+                                match pred.kind().skip_binder() {\n+                                    ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n+                                        Some(pred.def_id()) == self.tcx.lang_items().sized_trait()\n+                                            && pred.polarity == ty::ImplPolarity::Positive\n                                     }\n-                                })\n-                                .collect::<Vec<_>>();\n-                            if !inherent_impls_candidate.is_empty() {\n-                                inherent_impls_candidate.sort();\n-                                inherent_impls_candidate.dedup();\n-\n-                                // number of type to shows at most.\n-                                let limit = if inherent_impls_candidate.len() == 5 { 5 } else { 4 };\n-                                let type_candidates = inherent_impls_candidate\n-                                    .iter()\n-                                    .take(limit)\n-                                    .map(|impl_item| {\n-                                        format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n-                                    })\n-                                    .collect::<Vec<_>>()\n-                                    .join(\"\\n\");\n-                                let additional_types = if inherent_impls_candidate.len() > limit {\n-                                    format!(\n-                                        \"\\nand {} more types\",\n-                                        inherent_impls_candidate.len() - limit\n-                                    )\n-                                } else {\n-                                    \"\".to_string()\n+                                    _ => false,\n+                                }\n+                            });\n+                        for param in generics.params {\n+                            if param.span == cause.span && sized_pred {\n+                                let (sp, sugg) = match param.colon_span {\n+                                    Some(sp) => (sp.shrink_to_hi(), \" ?Sized +\"),\n+                                    None => (param.span.shrink_to_hi(), \": ?Sized\"),\n                                 };\n-                                err.note(&format!(\n-                                    \"the {item_kind} was found for\\n{}{}\",\n-                                    type_candidates, additional_types\n-                                ));\n+                                err.span_suggestion_verbose(\n+                                    sp,\n+                                    \"consider relaxing the type parameter's implicit \\\n+                                     `Sized` bound\",\n+                                    sugg,\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n                         }\n-                    } else {\n-                        let ty_str = if ty_str.len() > 50 {\n-                            String::new()\n+                        if let Some(pred) = parent_p {\n+                            // Done to add the \"doesn't satisfy\" `span_label`.\n+                            let _ = format_pred(*pred);\n+                        }\n+                        skip_list.insert(p);\n+                        let mut spans = if cause.span != *item_span {\n+                            let mut spans: MultiSpan = cause.span.into();\n+                            spans.push_span_label(cause.span, unsatisfied_msg);\n+                            spans\n                         } else {\n-                            format!(\"on `{ty_str}` \")\n+                            let mut spans = Vec::with_capacity(2);\n+                            if let Some(trait_ref) = of_trait {\n+                                spans.push(trait_ref.path.span);\n+                            }\n+                            spans.push(self_ty.span);\n+                            spans.into()\n                         };\n-                        err.span_label(span, format!(\n-                            \"{item_kind} cannot be called {ty_str}due to unsatisfied trait bounds\"\n-                        ));\n-                    }\n-                };\n+                        if let Some(trait_ref) = of_trait {\n+                            spans.push_span_label(trait_ref.path.span, \"\");\n+                        }\n+                        spans.push_span_label(self_ty.span, \"\");\n \n-                // If the method name is the name of a field with a function or closure type,\n-                // give a helping note that it has to be called as `(x.f)(...)`.\n-                if let SelfSource::MethodCall(expr) = source {\n-                    if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n-                        && lev_candidate.is_none()\n-                        && !custom_span_label\n-                    {\n-                        label_span_not_found(&mut err);\n+                        let entry = spanned_predicates.entry(spans);\n+                        entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                     }\n-                } else if !custom_span_label {\n-                    label_span_not_found(&mut err);\n-                }\n-\n-                // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n-                // can't be called due to `typeof(expr): Clone` not holding.\n-                if unsatisfied_predicates.is_empty() {\n-                    self.suggest_calling_method_on_field(\n-                        &mut err, source, span, rcvr_ty, item_name,\n-                    );\n+                    Some(_) => unreachable!(),\n+                    None => (),\n                 }\n+            }\n+            let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n+            spanned_predicates.sort_by_key(|(span, (_, _, _))| span.primary_span());\n+            for (span, (_path, _self_ty, preds)) in spanned_predicates {\n+                let mut preds: Vec<_> = preds\n+                    .into_iter()\n+                    .filter_map(|pred| format_pred(*pred))\n+                    .map(|(p, _)| format!(\"`{}`\", p))\n+                    .collect();\n+                preds.sort();\n+                preds.dedup();\n+                let msg = if let [pred] = &preds[..] {\n+                    format!(\"trait bound {} was not satisfied\", pred)\n+                } else {\n+                    format!(\"the following trait bounds were not satisfied:\\n{}\", preds.join(\"\\n\"),)\n+                };\n+                err.span_note(span, &msg);\n+                unsatisfied_bounds = true;\n+            }\n \n-                self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n-\n-                bound_spans.sort();\n-                bound_spans.dedup();\n-                for (span, msg) in bound_spans.into_iter() {\n-                    err.span_label(span, &msg);\n-                }\n+            // The requirements that didn't have an `impl` span to show.\n+            let mut bound_list = unsatisfied_predicates\n+                .iter()\n+                .filter_map(|(pred, parent_pred, _cause)| {\n+                    format_pred(*pred).map(|(p, self_ty)| {\n+                        collect_type_param_suggestions(self_ty, *pred, &p);\n+                        (\n+                            match parent_pred {\n+                                None => format!(\"`{}`\", &p),\n+                                Some(parent_pred) => match format_pred(*parent_pred) {\n+                                    None => format!(\"`{}`\", &p),\n+                                    Some((parent_p, _)) => {\n+                                        collect_type_param_suggestions(self_ty, *parent_pred, &p);\n+                                        format!(\"`{}`\\nwhich is required by `{}`\", p, parent_p)\n+                                    }\n+                                },\n+                            },\n+                            *pred,\n+                        )\n+                    })\n+                })\n+                .filter(|(_, pred)| !skip_list.contains(&pred))\n+                .map(|(t, _)| t)\n+                .enumerate()\n+                .collect::<Vec<(usize, String)>>();\n+\n+            for ((span, add_where_or_comma), obligations) in type_params.into_iter() {\n+                restrict_type_params = true;\n+                // #74886: Sort here so that the output is always the same.\n+                let mut obligations = obligations.into_iter().collect::<Vec<_>>();\n+                obligations.sort();\n+                err.span_suggestion_verbose(\n+                    span,\n+                    &format!(\n+                        \"consider restricting the type parameter{s} to satisfy the \\\n+                         trait bound{s}\",\n+                        s = pluralize!(obligations.len())\n+                    ),\n+                    format!(\"{} {}\", add_where_or_comma, obligations.join(\", \")),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n \n-                if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n+            bound_list.sort_by(|(_, a), (_, b)| a.cmp(b)); // Sort alphabetically.\n+            bound_list.dedup_by(|(_, a), (_, b)| a == b); // #35677\n+            bound_list.sort_by_key(|(pos, _)| *pos); // Keep the original predicate order.\n+\n+            if !bound_list.is_empty() || !skip_list.is_empty() {\n+                let bound_list =\n+                    bound_list.into_iter().map(|(_, path)| path).collect::<Vec<_>>().join(\"\\n\");\n+                let actual_prefix = rcvr_ty.prefix_string(self.tcx);\n+                info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n+                let (primary_message, label) = if unimplemented_traits.len() == 1\n+                    && unimplemented_traits_only\n+                {\n+                    unimplemented_traits\n+                        .into_iter()\n+                        .next()\n+                        .map(|(_, (trait_ref, obligation))| {\n+                            if trait_ref.self_ty().references_error() || rcvr_ty.references_error()\n+                            {\n+                                // Avoid crashing.\n+                                return (None, None);\n+                            }\n+                            let OnUnimplementedNote { message, label, .. } =\n+                                self.err_ctxt().on_unimplemented_note(trait_ref, &obligation);\n+                            (message, label)\n+                        })\n+                        .unwrap()\n                 } else {\n-                    self.suggest_traits_to_import(\n-                        &mut err,\n-                        span,\n-                        rcvr_ty,\n-                        item_name,\n-                        args.map(|(_, args)| args.len() + 1),\n-                        source,\n-                        out_of_scope_traits,\n-                        &unsatisfied_predicates,\n-                        &static_candidates,\n-                        unsatisfied_bounds,\n-                    );\n+                    (None, None)\n+                };\n+                let primary_message = primary_message.unwrap_or_else(|| format!(\n+                    \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n+                ));\n+                err.set_primary_message(&primary_message);\n+                if let Some(label) = label {\n+                    custom_span_label = true;\n+                    err.span_label(span, label);\n                 }\n-\n-                // Don't emit a suggestion if we found an actual method\n-                // that had unsatisfied trait bounds\n-                if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n-                    let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n-                    if let Some(suggestion) = lev_distance::find_best_match_for_name(\n-                        &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n-                        item_name.name,\n-                        None,\n-                    ) {\n-                        err.span_suggestion(\n-                            span,\n-                            \"there is a variant with a similar name\",\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                if !bound_list.is_empty() {\n+                    err.note(&format!(\n+                        \"the following trait bounds were not satisfied:\\n{bound_list}\"\n+                    ));\n                 }\n+                self.suggest_derive(&mut err, &unsatisfied_predicates);\n \n-                if item_name.name == sym::as_str && rcvr_ty.peel_refs().is_str() {\n-                    let msg = \"remove this method call\";\n-                    let mut fallback_span = true;\n-                    if let SelfSource::MethodCall(expr) = source {\n-                        let call_expr =\n-                            self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-                        if let Some(span) = call_expr.span.trim_start(expr.span) {\n-                            err.span_suggestion(span, msg, \"\", Applicability::MachineApplicable);\n-                            fallback_span = false;\n-                        }\n-                    }\n-                    if fallback_span {\n-                        err.span_label(span, msg);\n+                unsatisfied_bounds = true;\n+            }\n+        }\n+\n+        let label_span_not_found = |err: &mut Diagnostic| {\n+            if unsatisfied_predicates.is_empty() {\n+                err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n+                let is_string_or_ref_str = match rcvr_ty.kind() {\n+                    ty::Ref(_, ty, _) => {\n+                        ty.is_str()\n+                            || matches!(\n+                                ty.kind(),\n+                                ty::Adt(adt, _) if Some(adt.did()) == self.tcx.lang_items().string()\n+                            )\n                     }\n-                } else if let Some(lev_candidate) = lev_candidate {\n-                    // Don't emit a suggestion if we found an actual method\n-                    // that had unsatisfied trait bounds\n-                    if unsatisfied_predicates.is_empty() {\n-                        let def_kind = lev_candidate.kind.as_def_kind();\n-                        // Methods are defined within the context of a struct and their first parameter is always self,\n-                        // which represents the instance of the struct the method is being called on\n-                        // Associated functions don\u2019t take self as a parameter and\n-                        // they are not methods because they don\u2019t have an instance of the struct to work with.\n-                        if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n-                            err.span_suggestion(\n-                                span,\n-                                \"there is a method with a similar name\",\n-                                lev_candidate.name,\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                    ty::Adt(adt, _) => Some(adt.did()) == self.tcx.lang_items().string(),\n+                    _ => false,\n+                };\n+                if is_string_or_ref_str && item_name.name == sym::iter {\n+                    err.span_suggestion_verbose(\n+                        item_name.span,\n+                        \"because of the in-memory representation of `&str`, to obtain \\\n+                         an `Iterator` over each of its codepoint use method `chars`\",\n+                        \"chars\",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if let ty::Adt(adt, _) = rcvr_ty.kind() {\n+                    let mut inherent_impls_candidate = self\n+                        .tcx\n+                        .inherent_impls(adt.did())\n+                        .iter()\n+                        .copied()\n+                        .filter(|def_id| {\n+                            if let Some(assoc) = self.associated_value(*def_id, item_name) {\n+                                // Check for both mode is the same so we avoid suggesting\n+                                // incorrect associated item.\n+                                match (mode, assoc.fn_has_self_parameter, source) {\n+                                    (Mode::MethodCall, true, SelfSource::MethodCall(_)) => {\n+                                        // We check that the suggest type is actually\n+                                        // different from the received one\n+                                        // So we avoid suggestion method with Box<Self>\n+                                        // for instance\n+                                        self.tcx.at(span).type_of(*def_id) != rcvr_ty\n+                                            && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n+                                    }\n+                                    (Mode::Path, false, _) => true,\n+                                    _ => false,\n+                                }\n+                            } else {\n+                                false\n+                            }\n+                        })\n+                        .collect::<Vec<_>>();\n+                    if !inherent_impls_candidate.is_empty() {\n+                        inherent_impls_candidate.sort();\n+                        inherent_impls_candidate.dedup();\n+\n+                        // number of type to shows at most.\n+                        let limit = if inherent_impls_candidate.len() == 5 { 5 } else { 4 };\n+                        let type_candidates = inherent_impls_candidate\n+                            .iter()\n+                            .take(limit)\n+                            .map(|impl_item| {\n+                                format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n+                            })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\");\n+                        let additional_types = if inherent_impls_candidate.len() > limit {\n+                            format!(\"\\nand {} more types\", inherent_impls_candidate.len() - limit)\n                         } else {\n-                            err.span_suggestion(\n-                                span,\n-                                &format!(\n-                                    \"there is {} {} with a similar name\",\n-                                    def_kind.article(),\n-                                    def_kind.descr(lev_candidate.def_id),\n-                                ),\n-                                lev_candidate.name,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n+                            \"\".to_string()\n+                        };\n+                        err.note(&format!(\n+                            \"the {item_kind} was found for\\n{}{}\",\n+                            type_candidates, additional_types\n+                        ));\n                     }\n                 }\n+            } else {\n+                err.span_label(\n+                    span,\n+                    format!(\n+                        \"{item_kind} cannot be called on `{ty_str}` due to unsatisfied trait bounds\"\n+                    ),\n+                );\n+            }\n+        };\n \n-                self.check_for_deref_method(&mut err, source, rcvr_ty, item_name);\n-\n-                return Some(err);\n+        // If the method name is the name of a field with a function or closure type,\n+        // give a helping note that it has to be called as `(x.f)(...)`.\n+        if let SelfSource::MethodCall(expr) = source {\n+            if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n+                && lev_candidate.is_none()\n+                && !custom_span_label\n+            {\n+                label_span_not_found(&mut err);\n             }\n+        } else if !custom_span_label {\n+            label_span_not_found(&mut err);\n+        }\n \n-            MethodError::Ambiguity(mut sources) => {\n-                let mut err = struct_span_err!(\n-                    self.sess(),\n-                    item_name.span,\n-                    E0034,\n-                    \"multiple applicable items in scope\"\n-                );\n-                err.span_label(item_name.span, format!(\"multiple `{}` found\", item_name));\n+        // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n+        // can't be called due to `typeof(expr): Clone` not holding.\n+        if unsatisfied_predicates.is_empty() {\n+            self.suggest_calling_method_on_field(&mut err, source, span, rcvr_ty, item_name);\n+        }\n \n-                report_candidates(span, &mut err, &mut sources, Some(sugg_span));\n-                err.emit();\n-            }\n+        self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n \n-            MethodError::PrivateMatch(kind, def_id, out_of_scope_traits) => {\n-                let kind = kind.descr(def_id);\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    item_name.span,\n-                    E0624,\n-                    \"{} `{}` is private\",\n-                    kind,\n-                    item_name\n+        bound_spans.sort();\n+        bound_spans.dedup();\n+        for (span, msg) in bound_spans.into_iter() {\n+            err.span_label(span, &msg);\n+        }\n+\n+        if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n+        } else {\n+            self.suggest_traits_to_import(\n+                &mut err,\n+                span,\n+                rcvr_ty,\n+                item_name,\n+                args.map(|(_, args)| args.len() + 1),\n+                source,\n+                no_match_data.out_of_scope_traits.clone(),\n+                &unsatisfied_predicates,\n+                &static_candidates,\n+                unsatisfied_bounds,\n+            );\n+        }\n+\n+        // Don't emit a suggestion if we found an actual method\n+        // that had unsatisfied trait bounds\n+        if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n+            let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n+            if let Some(suggestion) = lev_distance::find_best_match_for_name(\n+                &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n+                item_name.name,\n+                None,\n+            ) {\n+                err.span_suggestion(\n+                    span,\n+                    \"there is a variant with a similar name\",\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n                 );\n-                err.span_label(item_name.span, &format!(\"private {}\", kind));\n-                let sp = self\n-                    .tcx\n-                    .hir()\n-                    .span_if_local(def_id)\n-                    .unwrap_or_else(|| self.tcx.def_span(def_id));\n-                err.span_label(sp, &format!(\"private {} defined here\", kind));\n-                self.suggest_valid_traits(&mut err, out_of_scope_traits);\n-                err.emit();\n             }\n+        }\n \n-            MethodError::IllegalSizedBound(candidates, needs_mut, bound_span) => {\n-                let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n-                let mut err = self.sess().struct_span_err(span, &msg);\n-                err.span_label(bound_span, \"this has a `Sized` requirement\");\n-                if !candidates.is_empty() {\n-                    let help = format!(\n-                        \"{an}other candidate{s} {were} found in the following trait{s}, perhaps \\\n-                         add a `use` for {one_of_them}:\",\n-                        an = if candidates.len() == 1 { \"an\" } else { \"\" },\n-                        s = pluralize!(candidates.len()),\n-                        were = pluralize!(\"was\", candidates.len()),\n-                        one_of_them = if candidates.len() == 1 { \"it\" } else { \"one_of_them\" },\n+        if item_name.name == sym::as_str && rcvr_ty.peel_refs().is_str() {\n+            let msg = \"remove this method call\";\n+            let mut fallback_span = true;\n+            if let SelfSource::MethodCall(expr) = source {\n+                let call_expr =\n+                    self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+                if let Some(span) = call_expr.span.trim_start(expr.span) {\n+                    err.span_suggestion(span, msg, \"\", Applicability::MachineApplicable);\n+                    fallback_span = false;\n+                }\n+            }\n+            if fallback_span {\n+                err.span_label(span, msg);\n+            }\n+        } else if let Some(lev_candidate) = lev_candidate {\n+            // Don't emit a suggestion if we found an actual method\n+            // that had unsatisfied trait bounds\n+            if unsatisfied_predicates.is_empty() {\n+                let def_kind = lev_candidate.kind.as_def_kind();\n+                // Methods are defined within the context of a struct and their first parameter is always self,\n+                // which represents the instance of the struct the method is being called on\n+                // Associated functions don\u2019t take self as a parameter and\n+                // they are not methods because they don\u2019t have an instance of the struct to work with.\n+                if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n+                    err.span_suggestion(\n+                        span,\n+                        &format!(\"there is a method with a similar name\",),\n+                        lev_candidate.name,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    err.span_suggestion(\n+                        span,\n+                        &format!(\n+                            \"there is {} {} with a similar name\",\n+                            def_kind.article(),\n+                            def_kind.descr(lev_candidate.def_id),\n+                        ),\n+                        lev_candidate.name,\n+                        Applicability::MaybeIncorrect,\n                     );\n-                    self.suggest_use_candidates(&mut err, help, candidates);\n                 }\n-                if let ty::Ref(region, t_type, mutability) = rcvr_ty.kind() {\n-                    if needs_mut {\n-                        let trait_type = self.tcx.mk_ref(\n-                            *region,\n-                            ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() },\n+            }\n+        }\n+\n+        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name);\n+        return Some(err);\n+    }\n+\n+    fn note_candidates_on_method_error(\n+        &self,\n+        rcvr_ty: Ty<'tcx>,\n+        item_name: Ident,\n+        args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n+        span: Span,\n+        err: &mut Diagnostic,\n+        sources: &mut Vec<CandidateSource>,\n+        sugg_span: Option<Span>,\n+    ) {\n+        sources.sort();\n+        sources.dedup();\n+        // Dynamic limit to avoid hiding just one candidate, which is silly.\n+        let limit = if sources.len() == 5 { 5 } else { 4 };\n+\n+        for (idx, source) in sources.iter().take(limit).enumerate() {\n+            match *source {\n+                CandidateSource::Impl(impl_did) => {\n+                    // Provide the best span we can. Use the item, if local to crate, else\n+                    // the impl, if local to crate (item may be defaulted), else nothing.\n+                    let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n+                            let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n+                            self.associated_value(impl_trait_ref.def_id, item_name)\n+                        }) else {\n+                            continue;\n+                        };\n+\n+                    let note_span = if item.def_id.is_local() {\n+                        Some(self.tcx.def_span(item.def_id))\n+                    } else if impl_did.is_local() {\n+                        Some(self.tcx.def_span(impl_did))\n+                    } else {\n+                        None\n+                    };\n+\n+                    let impl_ty = self.tcx.at(span).type_of(impl_did);\n+\n+                    let insertion = match self.tcx.impl_trait_ref(impl_did) {\n+                        None => String::new(),\n+                        Some(trait_ref) => {\n+                            format!(\" of the trait `{}`\", self.tcx.def_path_str(trait_ref.def_id))\n+                        }\n+                    };\n+\n+                    let (note_str, idx) = if sources.len() > 1 {\n+                        (\n+                            format!(\n+                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                                idx + 1,\n+                                insertion,\n+                                impl_ty,\n+                            ),\n+                            Some(idx + 1),\n+                        )\n+                    } else {\n+                        (\n+                            format!(\n+                                \"the candidate is defined in an impl{} for the type `{}`\",\n+                                insertion, impl_ty,\n+                            ),\n+                            None,\n+                        )\n+                    };\n+                    if let Some(note_span) = note_span {\n+                        // We have a span pointing to the method. Show note with snippet.\n+                        err.span_note(note_span, &note_str);\n+                    } else {\n+                        err.note(&note_str);\n+                    }\n+                    if let Some(sugg_span) = sugg_span\n+                            && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n+                            let path = self.tcx.def_path_str(trait_ref.def_id);\n+\n+                            let ty = match item.kind {\n+                                ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n+                                ty::AssocKind::Fn => self\n+                                    .tcx\n+                                    .fn_sig(item.def_id)\n+                                    .inputs()\n+                                    .skip_binder()\n+                                    .get(0)\n+                                    .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n+                                    .copied()\n+                                    .unwrap_or(rcvr_ty),\n+                            };\n+                            print_disambiguation_help(\n+                                item_name,\n+                                args,\n+                                err,\n+                                path,\n+                                ty,\n+                                item.kind,\n+                                item.def_id,\n+                                sugg_span,\n+                                idx,\n+                                self.tcx.sess.source_map(),\n+                                item.fn_has_self_parameter,\n+                            );\n+                        }\n+                }\n+                CandidateSource::Trait(trait_did) => {\n+                    let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n+                    let item_span = self.tcx.def_span(item.def_id);\n+                    let idx = if sources.len() > 1 {\n+                        let msg = &format!(\n+                            \"candidate #{} is defined in the trait `{}`\",\n+                            idx + 1,\n+                            self.tcx.def_path_str(trait_did)\n+                        );\n+                        err.span_note(item_span, msg);\n+                        Some(idx + 1)\n+                    } else {\n+                        let msg = &format!(\n+                            \"the candidate is defined in the trait `{}`\",\n+                            self.tcx.def_path_str(trait_did)\n+                        );\n+                        err.span_note(item_span, msg);\n+                        None\n+                    };\n+                    if let Some(sugg_span) = sugg_span {\n+                        let path = self.tcx.def_path_str(trait_did);\n+                        print_disambiguation_help(\n+                            item_name,\n+                            args,\n+                            err,\n+                            path,\n+                            rcvr_ty,\n+                            item.kind,\n+                            item.def_id,\n+                            sugg_span,\n+                            idx,\n+                            self.tcx.sess.source_map(),\n+                            item.fn_has_self_parameter,\n                         );\n-                        err.note(&format!(\"you need `{}` instead of `{}`\", trait_type, rcvr_ty));\n                     }\n                 }\n-                err.emit();\n             }\n-\n-            MethodError::BadReturnType => bug!(\"no return type expectations but got BadReturnType\"),\n         }\n-        None\n+        if sources.len() > limit {\n+            err.note(&format!(\"and {} others\", sources.len() - limit));\n+        }\n     }\n \n     /// Suggest calling `Ty::method` if `.method()` isn't found because the method"}]}