{"sha": "27f1c2b74299a2a26d89d4986620d38fc31798e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZjFjMmI3NDI5OWEyYTI2ZDg5ZDQ5ODY2MjBkMzhmYzMxNzk4ZTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-13T04:59:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-13T17:41:46Z"}, "message": "first stab at type checking for borrow: not integrated into trans", "tree": {"sha": "df20de27bc9e80f1874c67145547b2621636cd48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df20de27bc9e80f1874c67145547b2621636cd48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27f1c2b74299a2a26d89d4986620d38fc31798e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27f1c2b74299a2a26d89d4986620d38fc31798e3", "html_url": "https://github.com/rust-lang/rust/commit/27f1c2b74299a2a26d89d4986620d38fc31798e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27f1c2b74299a2a26d89d4986620d38fc31798e3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2fe28890023ab1a94049b8d0c00207cd235e425", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2fe28890023ab1a94049b8d0c00207cd235e425", "html_url": "https://github.com/rust-lang/rust/commit/c2fe28890023ab1a94049b8d0c00207cd235e425"}], "stats": {"total": 745, "additions": 394, "deletions": 351}, "files": [{"sha": "131088a43e7587127d0c2c549fddbb414dbf4677", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 117, "deletions": 35, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=27f1c2b74299a2a26d89d4986620d38fc31798e3", "patch": "@@ -15,6 +15,7 @@ export infer_ctxt;\n export new_infer_ctxt;\n export mk_subty;\n export mk_eqty;\n+export mk_assignty;\n export resolve_type_structure;\n export fixup_vars;\n export resolve_var;\n@@ -76,6 +77,14 @@ fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     indent {|| cx.commit {|| cx.eq_tys(a, b) } }.to_ures()\n }\n \n+fn mk_assignty(cx: infer_ctxt, encl_node_id: ast::node_id,\n+             a: ty::t, b: ty::t) -> ures {\n+    #debug[\"mk_assignty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    indent {|| cx.commit {||\n+        cx.assign_tys(encl_node_id, a, b)\n+    } }.to_ures()\n+}\n+\n fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     let infcx = new_infer_ctxt(tcx);\n     mk_eqty(infcx, a, b)\n@@ -677,12 +686,67 @@ impl resolve_methods for infer_ctxt {\n // Type assignment\n //\n // True if rvalues of type `a` can be assigned to lvalues of type `b`.\n+// This may cause borrowing to the region scope for `encl_node_id`.\n+//\n+// The strategy here is somewhat non-obvious.  The problem is\n+// that the constraint we wish to contend with is not a subtyping\n+// constraint.  Currently, for variables, we only track what it\n+// must be a subtype of, not what types it must be assignable to\n+// (or from).  Possibly, we should track that, but I leave that\n+// refactoring for another day.\n+//\n+// Instead, we look at each variable involved and try to extract\n+// *some* sort of bound.  Typically, the type a is the argument\n+// supplied to a call; it typically has a *lower bound* (which\n+// comes from having been assigned a value).  What we'd actually\n+// *like* here is an upper-bound, but we generally don't have\n+// one.  The type b is the expected type and it typically has a\n+// lower-bound too, which is good.\n+//\n+// The way we deal with the fact that we often don't have the\n+// bounds we need is to be a bit careful.  We try to get *some*\n+// bound from each side, preferring the upper from a and the\n+// lower from b.  If we fail to get a bound from both sides, then\n+// we just fall back to requiring that a <: b.\n+//\n+// Assuming we have a bound from both sides, we will then examine\n+// these bounds and see if they have the form (@MT_a, &rb.MT_b)\n+// (resp. ~MT_a).  If they do not, we fall back to subtyping.\n+//\n+// If they *do*, then we know that the two types could never be\n+// subtypes of one another.  We will then construct a type @MT_b and\n+// ensure that type a is a subtype of that.  This allows for the\n+// possibility of assigning from a type like (say) @[mut T1] to a type\n+// &[const T2] where T1 <: T2.  Basically we would require that @[mut\n+// T1] <: @[const T2].  Next we require that the region for the\n+// enclosing scope be a superregion of the region r.  These two checks\n+// together guarantee that the type A would be a subtype of the type B\n+// if the @ were converted to a region r.\n+//\n+// You might wonder why we don't just make the type &e.MT_a where e is\n+// the enclosing region and check that &e.MT_a <: B.  The reason is\n+// that the type @MT_a is (generally) just a *lower-bound*, so this\n+// would be imposing @MT_a also as the upper-bound on type A.  But\n+// this upper-bound might be stricter than what is truly needed.\n \n impl assignment for infer_ctxt {\n-    fn assign_tys(a: ty::t, b: ty::t,\n-                  encl_blk_id: ast::node_id) -> ures {\n+    fn assign_tys(encl_node_id: ast::node_id,\n+                  a: ty::t, b: ty::t) -> ures {\n+\n+        fn select(fst: option<ty::t>, snd: option<ty::t>) -> option<ty::t> {\n+            alt fst {\n+              some(t) { some(t) }\n+              none {\n+                alt snd {\n+                  some(t) { some(t) }\n+                  none { none }\n+                }\n+              }\n+            }\n+        }\n \n-        #debug[\"assign_tys(%s, %s)\", a.to_str(self), b.to_str(self)];\n+        #debug[\"assign_tys(encl_node_id=%?, %s -> %s)\",\n+               encl_node_id, a.to_str(self), b.to_str(self)];\n         let _r = indenter();\n \n         alt (ty::get(a).struct, ty::get(b).struct) {\n@@ -691,59 +755,77 @@ impl assignment for infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-            let {root:_, bounds:a_bounds} = self.get(self.vb, a_id);\n-            let {root:_, bounds:b_bounds} = self.get(self.vb, b_id);\n-            self.assign_vars_or_sub(a, b, a_bounds, b_bounds, encl_blk_id)\n+            let {root:_, bounds: a_bounds} = self.get(self.vb, a_id);\n+            let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n+            let a_bnd = select(a_bounds.ub, a_bounds.lb);\n+            let b_bnd = select(b_bounds.lb, b_bounds.ub);\n+            self.assign_tys_or_sub(encl_node_id, a, b, a_bnd, b_bnd)\n           }\n \n           (ty::ty_var(a_id), _) {\n             let {root:_, bounds:a_bounds} = self.get(self.vb, a_id);\n-            let b_bounds = {lb: some(b), ub: none};\n-            self.assign_vars_or_sub(a, b, a_bounds, b_bounds, encl_blk_id)\n+            let a_bnd = select(a_bounds.ub, a_bounds.lb);\n+            self.assign_tys_or_sub(encl_node_id, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) {\n-            let a_bounds = {lb: none, ub: some(a)};\n             let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n-            self.assign_vars_or_sub(a, b, a_bounds, b_bounds, encl_blk_id)\n+            let b_bnd = select(b_bounds.lb, b_bounds.ub);\n+            self.assign_tys_or_sub(encl_node_id, a, b, some(a), b_bnd)\n           }\n \n-          (ty::ty_box(a_mt), ty::ty_rptr(_, _)) |\n-          (ty::ty_uniq(a_mt), ty::ty_rptr(_, _)) {\n-            let a_r = ty::re_scope(encl_blk_id);\n-            let a_ty = ty::mk_rptr(self.tcx, a_r, a_mt);\n-            self.sub_tys(a_ty, b).to_ures()\n-          }\n-\n-          _ {\n-            self.sub_tys(a, b).to_ures()\n+          (_, _) {\n+            self.assign_tys_or_sub(encl_node_id, a, b, some(a), some(b))\n           }\n         }\n     }\n \n-    fn assign_tys_or_sub(a: ty::t, b: ty::t,\n-                         a_b: ty::t, b_b: ty::t,\n-                         encl_blk_id: ast::node_id) -> ures {\n-        self.try {||\n-            self.assign_tys(a_b, b_b, encl_blk_id)\n-        }.chain_err {|_e|\n-            self.sub_tys(a, b)\n-        }\n-    }\n+    fn assign_tys_or_sub(\n+        encl_node_id: ast::node_id,\n+        a: ty::t, b: ty::t,\n+        a_bnd: option<ty::t>, b_bnd: option<ty::t>) -> ures {\n \n-    fn assign_vars_or_sub(a: ty::t, b: ty::t,\n-                          a_bounds: bounds<ty::t>, b_bounds: bounds<ty::t>,\n-                          encl_blk_id: ast::node_id) -> ures {\n+        #debug[\"assign_tys_or_sub(encl_node_id=%?, %s -> %s, %s -> %s)\",\n+               encl_node_id, a.to_str(self), b.to_str(self),\n+               a_bnd.to_str(self), b_bnd.to_str(self)];\n+        let _r = indenter();\n \n-        alt (a_bounds.ub, b_bounds.lb) {\n-          (some(a_ub), some(b_lb)) {\n-            self.assign_tys_or_sub(a, b, a_ub, b_lb, encl_blk_id)\n+        alt (a_bnd, b_bnd) {\n+          (some(a_bnd), some(b_bnd)) {\n+            alt (ty::get(a_bnd).struct, ty::get(b_bnd).struct) {\n+              (ty::ty_box(mt_a), ty::ty_rptr(r_b, mt_b)) {\n+                let nr_b = ty::mk_box(self.tcx, mt_b);\n+                self.crosspolinate(encl_node_id, a, nr_b, r_b)\n+              }\n+              (ty::ty_uniq(mt_a), ty::ty_rptr(r_b, mt_b)) {\n+                let nr_b = ty::mk_uniq(self.tcx, mt_b);\n+                self.crosspolinate(encl_node_id, a, nr_b, r_b)\n+              }\n+              _ {\n+                self.sub_tys(a, b)\n+              }\n+            }\n           }\n           _ {\n-            self.sub_tys(a, b).to_ures()\n+            self.sub_tys(a, b)\n           }\n         }\n     }\n+\n+    fn crosspolinate(encl_node_id: ast::node_id,\n+                     a: ty::t, nr_b: ty::t, r_b: ty::region) -> ures {\n+\n+        #debug[\"crosspolinate(encl_node_id=%?, a=%s, nr_b=%s, r_b=%s)\",\n+               encl_node_id, a.to_str(self), nr_b.to_str(self),\n+               r_b.to_str(self)];\n+\n+        indent {||\n+            self.sub_tys(a, nr_b).then {||\n+                let r_a = ty::re_scope(encl_node_id);\n+                sub(self).contraregions(r_a, r_b).to_ures()\n+            }\n+        }\n+    }\n }\n \n // ______________________________________________________________________"}, {"sha": "b26b7cf503da2ce18f65f897c01f674a11f2c0fd", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 81, "deletions": 109, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=27f1c2b74299a2a26d89d4986620d38fc31798e3", "patch": "@@ -149,6 +149,8 @@ enum parent {\n     pa_block(ast::node_id),\n     pa_nested_fn(ast::node_id),\n     pa_item(ast::node_id),\n+    pa_call(ast::node_id),\n+    pa_alt(ast::node_id),\n     pa_crate\n }\n \n@@ -166,12 +168,6 @@ type region_map = {\n     local_blocks: hashmap<ast::node_id,ast::node_id>,\n     /* Mapping from an AST type node to the region that `&` resolves to. */\n     ast_type_to_inferred_region: hashmap<ast::node_id,ty::region>,\n-    /*\n-     * Mapping from an address-of operator or alt expression to its containing\n-     * region (usually ty::region_scope(block). This is used as the region if\n-     * the operand is an rvalue.\n-     */\n-    rvalue_to_region: hashmap<ast::node_id,ty::region>\n };\n \n type region_scope = @{\n@@ -274,21 +270,7 @@ type ctxt = {\n \n     scope: region_scope,\n \n-    /*\n-     * A list of local IDs that will be parented to the next block we\n-     * traverse. This is used when resolving `alt` statements. Since we see\n-     * the pattern before the associated block, upon seeing a pattern we must\n-     * parent all the bindings in that pattern to the next block we see.\n-     */\n-    mut queued_locals: [ast::node_id],\n-\n-    parent: parent,\n-\n-    /* True if we're within the pattern part of an alt, false otherwise. */\n-    in_alt: bool,\n-\n-    /* The next parameter ID. */\n-    mut next_param_id: uint\n+    parent: parent\n };\n \n // Returns true if `subscope` is equal to or is lexically nested inside\n@@ -361,7 +343,9 @@ fn get_inferred_region(cx: ctxt, sp: syntax::codemap::span) -> ty::region {\n \n     ret alt cx.parent {\n       pa_fn_item(_) | pa_nested_fn(_) { ty::re_bound(ty::br_anon) }\n-      pa_block(block_id) { ty::re_scope(block_id) }\n+      pa_block(node_id) | pa_call(node_id) | pa_alt(node_id) {\n+        ty::re_scope(node_id)\n+      }\n       pa_item(_) { ty::re_bound(ty::br_anon) }\n       pa_crate { cx.sess.span_bug(sp, \"inferred region at crate level?!\"); }\n     }\n@@ -411,114 +395,108 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_ty(ty, cx, visitor);\n }\n \n-fn record_parent(cx: ctxt, child_id: ast::node_id) {\n+fn opt_parent_id(cx: ctxt) -> option<ast::node_id> {\n     alt cx.parent {\n-        pa_fn_item(parent_id) |\n-        pa_item(parent_id) |\n-        pa_block(parent_id) |\n-        pa_nested_fn(parent_id) {\n-            cx.region_map.parents.insert(child_id, parent_id);\n-        }\n-        pa_crate { /* no-op */ }\n+      pa_fn_item(parent_id) |\n+      pa_item(parent_id) |\n+      pa_block(parent_id) |\n+      pa_alt(parent_id) |\n+      pa_call(parent_id) |\n+      pa_nested_fn(parent_id) {\n+        some(parent_id)\n+      }\n+      pa_crate {\n+        none\n+      }\n+    }\n+}\n+\n+fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n+    alt opt_parent_id(cx) {\n+      none {\n+        cx.sess.span_bug(span, \"crate should not be parent here\");\n+      }\n+      some(parent_id) {\n+        parent_id\n+      }\n+    }\n+}\n+\n+fn record_parent(cx: ctxt, child_id: ast::node_id) {\n+    alt opt_parent_id(cx) {\n+      none { /* no-op */ }\n+      some(parent_id) {\n+        cx.region_map.parents.insert(child_id, parent_id);\n+      }\n     }\n }\n \n fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Record the parent of this block.\n     record_parent(cx, blk.node.id);\n \n-    // Resolve queued locals to this block.\n-    for cx.queued_locals.each {|local_id|\n-        cx.region_map.local_blocks.insert(local_id, blk.node.id);\n-    }\n-\n     // Descend.\n     let new_cx: ctxt = {parent: pa_block(blk.node.id),\n-                        scope: cx.scope.body_subscope(blk.node.id),\n-                        mut queued_locals: [],\n-                        in_alt: false with cx};\n+                        scope: cx.scope.body_subscope(blk.node.id)\n+                        with cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    let new_cx: ctxt = {mut queued_locals: [], in_alt: true with cx};\n-    visit::visit_arm(arm, new_cx, visitor);\n+    visit::visit_arm(arm, cx, visitor);\n }\n \n fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n     alt pat.node {\n-        ast::pat_ident(path, _) {\n-            let defn_opt = cx.def_map.find(pat.id);\n-            alt defn_opt {\n-                some(ast::def_variant(_,_)) {\n-                    /* Nothing to do; this names a variant. */\n-                }\n-                _ {\n-                    /*\n-                     * This names a local. Enqueue it or bind it to the\n-                     * containing block, depending on whether we're in an alt\n-                     * or not.\n-                     */\n-                    if cx.in_alt {\n-                        vec::push(cx.queued_locals, pat.id);\n-                    } else {\n-                        alt cx.parent {\n-                            pa_block(block_id) {\n-                                let local_blocks = cx.region_map.local_blocks;\n-                                local_blocks.insert(pat.id, block_id);\n-                            }\n-                            _ {\n-                                cx.sess.span_bug(pat.span,\n-                                                 \"unexpected parent\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+      ast::pat_ident(path, _) {\n+        let defn_opt = cx.def_map.find(pat.id);\n+        alt defn_opt {\n+          some(ast::def_variant(_,_)) {\n+            /* Nothing to do; this names a variant. */\n+          }\n+          _ {\n+            /* This names a local. Bind it to the containing scope. */\n+            let local_blocks = cx.region_map.local_blocks;\n+            local_blocks.insert(pat.id, parent_id(cx, pat.span));\n+          }\n         }\n-        _ { /* no-op */ }\n+      }\n+      _ { /* no-op */ }\n     }\n \n     visit::visit_pat(pat, cx, visitor);\n }\n \n fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n+    record_parent(cx, expr.id);\n     alt expr.node {\n-        ast::expr_fn(_, _, _, _) | ast::expr_fn_block(_, _) {\n-            record_parent(cx, expr.id);\n-            let new_cx = {parent: pa_nested_fn(expr.id),\n-                          scope: cx.scope.binding_subscope(expr.id),\n-                          in_alt: false with cx};\n-            visit::visit_expr(expr, new_cx, visitor);\n-        }\n-        ast::expr_vstore(e, ast::vstore_slice(r)) {\n-          let region = resolve_region_binding(cx, e.span, r);\n-          cx.region_map.rvalue_to_region.insert(e.id, region);\n-        }\n-        ast::expr_addr_of(_, subexpr) | ast::expr_alt(subexpr, _, _) {\n-            // Record the block that this expression appears in, in case the\n-            // operand is an rvalue.\n-            alt cx.parent {\n-                pa_block(blk_id) {\n-                  let region = ty::re_scope(blk_id);\n-                  cx.region_map.rvalue_to_region.insert(subexpr.id, region);\n-                }\n-                _ { cx.sess.span_bug(expr.span, \"expr outside of block?!\"); }\n-            }\n-            visit::visit_expr(expr, cx, visitor);\n-        }\n-        _ { visit::visit_expr(expr, cx, visitor); }\n+      ast::expr_fn(_, _, _, _) | ast::expr_fn_block(_, _) {\n+        let new_cx = {parent: pa_nested_fn(expr.id),\n+                      scope: cx.scope.binding_subscope(expr.id)\n+                      with cx};\n+        visit::visit_expr(expr, new_cx, visitor);\n+      }\n+      ast::expr_call(_, _, _) {\n+        let new_cx = {parent: pa_call(expr.id),\n+                      scope: cx.scope.binding_subscope(expr.id)\n+                      with cx};\n+        visit::visit_expr(expr, new_cx, visitor);\n+      }\n+      ast::expr_alt(subexpr, _, _) {\n+        let new_cx = {parent: pa_alt(expr.id),\n+                      scope: cx.scope.binding_subscope(expr.id)\n+                      with cx};\n+        visit::visit_expr(expr, new_cx, visitor);\n+      }\n+      _ {\n+        visit::visit_expr(expr, cx, visitor);\n+      }\n     }\n }\n \n fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    alt cx.parent {\n-        pa_block(blk_id) {\n-          let region = ty::re_scope(blk_id);\n-          cx.region_map.rvalue_to_region.insert(local.node.id, region);\n-        }\n-        _ { cx.sess.span_bug(local.span, \"local outside of block?!\"); }\n-    }\n+    cx.region_map.local_blocks.insert(\n+        local.node.id, parent_id(cx, local.span));\n     visit::visit_local(local, cx, visitor);\n }\n \n@@ -542,9 +520,7 @@ fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     };\n \n     let new_cx: ctxt = {parent: parent,\n-                        scope: scope,\n-                        in_alt: false,\n-                        mut next_param_id: 0u\n+                        scope: scope\n                         with cx};\n \n     visit::visit_item(item, new_cx, visitor);\n@@ -558,13 +534,9 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n                                   ast_type_to_region: map::int_hash(),\n                                   local_blocks: map::int_hash(),\n                                   ast_type_to_inferred_region:\n-                                    map::int_hash(),\n-                                  rvalue_to_region: map::int_hash()},\n+                                    map::int_hash()},\n                     scope: root_scope(0),\n-                    mut queued_locals: [],\n-                    parent: pa_crate,\n-                    in_alt: false,\n-                    mut next_param_id: 0u};\n+                    parent: pa_crate};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,"}, {"sha": "9af9e89e57b6c9b739b69ae60cef5074540bccff", "filename": "src/rustc/middle/regionck.rs", "status": "modified", "additions": 30, "deletions": 61, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=27f1c2b74299a2a26d89d4986620d38fc31798e3", "patch": "@@ -7,76 +7,45 @@ import driver::session::session;\n import middle::ty;\n import std::map::hashmap;\n import syntax::{ast, visit};\n-\n-// An \"extended region\", which includes the ordinarily-unnamed reference-\n-// counted heap and exchange heap regions. This is used to detect borrowing.\n-enum region_ext {\n-    re_rc,\n-    re_exheap,\n-    re_region(ty::region)\n-}\n-\n-type ctxt = {\n-    tcx: ty::ctxt,\n-    enclosing_block: option<ast::node_id>\n-};\n-\n-fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    let t = ty::expr_ty(cx.tcx, expr);\n-    if ty::type_has_rptrs(t) {\n-        ty::walk_ty(t) { |t|\n-            alt ty::get(t).struct {\n-              ty::ty_rptr(region, _) {\n-                alt region {\n-                  ty::re_bound(_) | ty::re_free(_, _) | ty::re_static {\n-                    /* ok */\n-                  }\n-                  ty::re_scope(rbi) {\n-                    let referent_block_id = rbi;\n-                    let enclosing_block_id = alt cx.enclosing_block {\n-                      none {\n-                        cx.tcx.sess.span_bug(expr.span,\n-                                             \"block region \" +\n-                                             \"type outside a \" +\n-                                             \"block?!\");\n-                      }\n-                      some(eb) { eb }\n-                    };\n-\n-                    if !region::scope_contains(cx.tcx.region_map,\n-                                               referent_block_id,\n-                                               enclosing_block_id) {\n-\n-                        cx.tcx.sess.span_err(expr.span, \"reference \" +\n-                                             \"escapes its block\");\n-                    }\n-                  }\n-                  ty::re_default | ty::re_var(_) {\n-                    cx.tcx.sess.span_bug(expr.span,\n-                                         \"unresolved region\");\n-                  }\n+import util::ppaux;\n+\n+fn check_expr(expr: @ast::expr,\n+              &&tcx: ty::ctxt,\n+              visitor: visit::vt<ty::ctxt>) {\n+    visit::visit_expr(expr, tcx, visitor);\n+\n+    let t = ty::expr_ty(tcx, expr);\n+    if !ty::type_has_rptrs(t) { ret; }\n+    ty::walk_ty(t) { |t|\n+        alt ty::get(t).struct {\n+          ty::ty_rptr(region, _) {\n+            alt region {\n+              ty::re_bound(_) | ty::re_free(_, _) | ty::re_static {\n+                /* ok */\n+              }\n+              ty::re_scope(id) {\n+                if !region::scope_contains(tcx.region_map, id, expr.id) {\n+                    tcx.sess.span_err(\n+                        expr.span,\n+                        #fmt[\"reference is not valid outside of %s\",\n+                             ppaux::re_scope_id_to_str(tcx, id)]);\n                 }\n               }\n-              _ { /* no-op */ }\n+              ty::re_default | ty::re_var(_) {\n+                tcx.sess.span_bug(expr.span, \"unresolved region\");\n+              }\n             }\n+          }\n+          _ { /* no-op */ }\n         }\n     }\n-\n-    visit::visit_expr(expr, cx, visitor);\n-}\n-\n-fn check_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    let new_cx: ctxt = { enclosing_block: some(blk.node.id) with cx };\n-    visit::visit_block(blk, new_cx, visitor);\n }\n \n-fn check_crate(ty_cx: ty::ctxt, crate: @ast::crate) {\n-    let cx: ctxt = {tcx: ty_cx, enclosing_block: none};\n+fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     let visitor = visit::mk_vt(@{\n-        visit_expr: check_expr,\n-        visit_block: check_block\n+        visit_expr: check_expr\n         with *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, cx, visitor);\n+    visit::visit_crate(*crate, tcx, visitor);\n }\n "}, {"sha": "992006f4a3ff7074f0cbdaca8cb0439f3732f96c", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 131, "deletions": 128, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=27f1c2b74299a2a26d89d4986620d38fc31798e3", "patch": "@@ -873,6 +873,15 @@ impl methods for @fn_ctxt {\n     fn next_ty_vars(n: uint) -> [ty::t] {\n         vec::from_fn(n) {|_i| self.next_ty_var() }\n     }\n+    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+                               err: ty::type_err) {\n+        self.ccx.tcx.sess.span_err(\n+            sp,\n+            #fmt[\"mismatched types: expected `%s` but found `%s` (%s)\",\n+                 self.ty_to_str(e),\n+                 self.ty_to_str(a),\n+                 ty::type_err_to_str(self.ccx.tcx, err)]);\n+    }\n }\n \n fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n@@ -996,7 +1005,7 @@ fn fixup_self_param(fcx: @fn_ctxt, mty: ty::t, m_substs: [ty::t],\n             // Simply ensure that the type parameters for the self\n             // type match the context.\n             vec::iter2(substs, m_substs) {|s, ms|\n-                demand::simple(fcx, sp, s, ms);\n+                demand::suptype(fcx, sp, s, ms);\n             }\n             selfty\n           }\n@@ -1406,21 +1415,26 @@ fn require_same_types(\n mod demand {\n     // Requires that the two types unify, and prints an error message if they\n     // don't.\n-    fn simple(fcx: @fn_ctxt, sp: span,\n+    fn suptype(fcx: @fn_ctxt, sp: span,\n               expected: ty::t, actual: ty::t) {\n \n         alt infer::mk_subty(fcx.infcx, actual, expected) {\n           result::ok(()) { /* ok */ }\n           result::err(err) {\n-            fcx.ccx.tcx.sess.span_err(sp,\n-                                      \"mismatched types: expected `\" +\n-                                      fcx.ty_to_str(expected) +\n-                                      \"` but found `\" +\n-                                      fcx.ty_to_str(actual) +\n-                                      \"` (\" +\n-                                      ty::type_err_to_str(\n-                                          fcx.ccx.tcx, err) +\n-                                      \")\");\n+            fcx.report_mismatched_types(sp, expected, actual, err);\n+          }\n+        }\n+    }\n+\n+    // Checks that the type `actual` can be assigned to `expected`, borrowing\n+    // to `encl_node_id` if necessary.\n+    fn assign(fcx: @fn_ctxt, sp: span, encl_node_id: ast::node_id,\n+              expected: ty::t, actual: ty::t) {\n+\n+        alt infer::mk_assignty(fcx.infcx, encl_node_id, actual, expected) {\n+          result::ok(()) { /* ok */ }\n+          result::err(err) {\n+            fcx.report_mismatched_types(sp, expected, actual, err);\n           }\n         }\n     }\n@@ -1912,7 +1926,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         // check that the type of the value being matched is a subtype\n         // of the type of the pattern:\n         let pat_ty = fcx.node_ty(pat.id);\n-        demand::simple(fcx, pat.span, pat_ty, expected);\n+        demand::suptype(fcx, pat.span, pat_ty, expected);\n \n         // Get the number of arguments in this enum variant.\n         let arg_types = variant_arg_types(pcx.fcx.ccx, pat.span,\n@@ -1991,12 +2005,12 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       if !pat_util::pat_is_variant(tcx.def_map, pat) {\n         let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n         let mut typ = ty::mk_var(tcx, vid);\n-        demand::simple(pcx.fcx, pat.span, expected, typ);\n+        demand::suptype(pcx.fcx, pat.span, expected, typ);\n         let canon_id = pcx.map.get(path_to_ident(name));\n         if canon_id != pat.id {\n             let tv_id = lookup_local(pcx.fcx, pat.span, canon_id);\n             let ct = ty::mk_var(tcx, tv_id);\n-            demand::simple(pcx.fcx, pat.span, ct, typ);\n+            demand::suptype(pcx.fcx, pat.span, ct, typ);\n         }\n         fcx.write_ty(pat.id, typ);\n         alt sub {\n@@ -2165,17 +2179,17 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n     }\n }\n \n-type unifier = fn@(@fn_ctxt, span, ty::t, ty::t);\n+type unifier = fn(@fn_ctxt, span, ty::t, ty::t);\n \n fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n-    fn dummy_unify(_fcx: @fn_ctxt, _sp: span,\n-                   _expected: ty::t, _actual: ty::t) {\n-    }\n-    ret check_expr_with_unifier(fcx, expr, dummy_unify,\n-                                ty::mk_nil(fcx.ccx.tcx));\n+    ret check_expr_with_unifier(fcx, expr, ty::mk_nil(fcx.ccx.tcx)) {\n+        |_fcx, _span, _t1, _t2|\n+        /* unify is a no-op */\n+    };\n }\n+\n fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n-    ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n+    ret check_expr_with_unifier(fcx, expr, expected, demand::suptype);\n }\n \n // determine the `self` type, using fresh variables for all variables declared\n@@ -2486,55 +2500,46 @@ fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n                 {|f| ty::lookup_field_type(tcx, class_id, f.id, substs) })\n }\n \n-/*\n- * Returns the region that the value named by the given expression lives in.\n- * The expression must have been typechecked. If the expression is not an\n- * lvalue, returns the block region.\n- *\n- * Note that borrowing is not detected here, because we would have to\n- * immediately structurally resolve too many types otherwise. Thus the\n- * reference-counted heap and exchange heap regions will be reported as block\n- * regions instead. This is cleaned up in the region checking pass.\n+/* Returns the region that &expr should be placed into.  If expr is an\n+ * lvalue, this will be the region of the lvalue.  Otherwise, if region is\n+ * an rvalue, the semantics are that the result is stored into a temporary\n+ * stack position and so the resulting region will be the enclosing block.\n  */\n fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n-    alt expr.node {\n-        ast::expr_path(path) {\n-            let defn = lookup_def(fcx, path.span, expr.id);\n-            alt defn {\n-                ast::def_local(local_id, _) |\n-                ast::def_upvar(local_id, _, _) {\n-                    let local_blocks = fcx.ccx.tcx.region_map.local_blocks;\n-                    let local_block_id = local_blocks.get(local_id);\n-                    ret ty::re_scope(local_block_id);\n-                }\n-                _ {\n-                    fcx.ccx.tcx.sess.span_unimpl(expr.span,\n-                                                 \"immortal region\");\n-                }\n-            }\n-        }\n-        ast::expr_field(base, _, _) {\n-            // FIXME: Insert borrowing!\n-            ret region_of(fcx, base);\n-        }\n-        ast::expr_index(base, _) {\n-            fcx.ccx.tcx.sess.span_unimpl(expr.span,\n-                                         \"regions of index operations\");\n-        }\n-        ast::expr_unary(ast::deref, base) {\n-            let expr_ty = fcx.expr_ty(base);\n-            let expr_ty = structurally_resolved_type(fcx, expr.span, expr_ty);\n-            alt ty::get(expr_ty).struct {\n-                ty::ty_rptr(region, _) { region }\n-                ty::ty_box(_) | ty::ty_uniq(_) {\n-                    fcx.ccx.tcx.sess.span_unimpl(expr.span, \"borrowing\");\n-                }\n-                _ { ret region_of(fcx, base); }\n-            }\n+    fn borrow(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n+        let parent_id = fcx.ccx.tcx.region_map.parents.get(expr.id);\n+        ret ty::re_scope(parent_id);\n+    }\n+\n+    fn deref(fcx: @fn_ctxt, base: @ast::expr) -> ty::region {\n+        let base_ty = fcx.expr_ty(base);\n+        let base_ty = structurally_resolved_type(fcx, base.span, base_ty);\n+        alt ty::get(base_ty).struct {\n+          ty::ty_rptr(region, _) { region }\n+          ty::ty_box(_) | ty::ty_uniq(_) { borrow(fcx, base) }\n+          _ { region_of(fcx, base) }\n         }\n-        _ {\n-            ret fcx.ccx.tcx.region_map.rvalue_to_region.get(expr.id);\n+    }\n+\n+    alt expr.node {\n+      ast::expr_path(path) {\n+        let defn = lookup_def(fcx, path.span, expr.id);\n+        alt defn {\n+          ast::def_local(local_id, _) |\n+          ast::def_upvar(local_id, _, _) {\n+            let local_blocks = fcx.ccx.tcx.region_map.local_blocks;\n+            let local_block_id = local_blocks.get(local_id);\n+            ty::re_scope(local_block_id)\n+          }\n+          _ {\n+            ty::re_static\n+          }\n         }\n+      }\n+      ast::expr_field(base, _, _) { deref(fcx, base) }\n+      ast::expr_index(base, _) { deref(fcx, base) }\n+      ast::expr_unary(ast::deref, base) { deref(fcx, base) }\n+      _ { borrow(fcx, expr) }\n     }\n }\n \n@@ -2543,7 +2548,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               proto: ast::proto,\n                               decl: ast::fn_decl,\n                               body: ast::blk,\n-                              unify: unifier,\n+                              unifier: unifier,\n                               expected: ty::t,\n                               is_loop_body: bool) {\n     let tcx = fcx.ccx.tcx;\n@@ -2559,7 +2564,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     // typecheck the body so that we have more information about the\n     // argument types in the body. This is needed to make binops and\n     // record projection work on type inferred arguments.\n-    unify(fcx, expr.span, expected, fty);\n+    unifier(fcx, expr.span, expected, fty);\n \n     let ret_ty = ty::ty_fn_ret(fty);\n     let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n@@ -2569,16 +2574,16 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n              fcx.self_ty);\n }\n \n-fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n-                           expected: ty::t) -> bool {\n+fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n+                           expected: ty::t, unifier: unifier) -> bool {\n \n     #debug(\">> typechecking expr %d (%s)\",\n            expr.id, syntax::print::pprust::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(\n-        fcx: @fn_ctxt, sp: span, fty: ty::t,\n+        fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id, fty: ty::t,\n         args: [option<@ast::expr>]) -> {fty: ty::t, bot: bool} {\n \n         let fty = universally_quantify_before_call(fcx, region_env(), fty);\n@@ -2640,9 +2645,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                       _ { false }\n                     };\n                     if is_block == check_blocks {\n-                        let t = arg_tys[i].ty;\n-                        bot |= check_expr_with_unifier(fcx, a, demand::simple,\n-                                                       t);\n+                        let arg_ty = arg_tys[i].ty;\n+                        bot |= check_expr_with_unifier(fcx, a, arg_ty) {\n+                            |fcx, span, expected, actual|\n+                            demand::assign(fcx, span, call_expr_id,\n+                                           expected, actual);\n+                        };\n                     }\n                   }\n                   none { }\n@@ -2666,49 +2674,43 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         ret bot;\n     }\n \n-    // A generic function for checking call expressions\n-    fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n-        -> {fty: ty::t, bot: bool} {\n-        let mut args_opt_0: [option<@ast::expr>] = [];\n-        for args.each {|arg|\n-            args_opt_0 += [some::<@ast::expr>(arg)];\n-        }\n-\n-        let bot = check_expr(fcx, f);\n+    // A generic function for doing all of the checking for call expressions\n+    fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n+                  f: @ast::expr, args: [@ast::expr]) -> bool {\n \n-        // Call the generic checker.\n+        let mut bot = check_expr(fcx, f);\n         let fn_ty = fcx.expr_ty(f);\n-        let {fty, bot: bot1} = check_call_or_bind(fcx, sp, fn_ty, args_opt_0);\n-        ret {fty: fty, bot: bot | bot1};\n-    }\n \n-    // A generic function for doing all of the checking for call expressions\n-    fn check_call_full(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n-                       f: @ast::expr, args: [@ast::expr]) -> bool {\n-        let {fty, bot} = check_call(fcx, sp, f, args);\n+        // Call the generic checker.\n+        let fty = {\n+            let args_opt = args.map { |arg| some(arg) };\n+            let r = check_call_or_bind(fcx, sp, call_expr_id,\n+                                       fn_ty, args_opt);\n+            bot |= r.bot;\n+            r.fty\n+        };\n \n-        /* need to restrict oper to being an explicit expr_path if we're\n-        inside a pure function */\n+        // Need to restrict oper to being an explicit expr_path if we're\n+        // inside a pure function\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n \n         // Pull the return type out of the type of the function.\n-        let {rt, bot} = alt structure_of(fcx, sp, fty) {\n+        alt structure_of(fcx, sp, fty) {\n           ty::ty_fn(f) {\n-            {rt: f.output,\n-             bot: bot | (f.ret_style == ast::noreturn)}\n+            bot |= (f.ret_style == ast::noreturn);\n+            fcx.write_ty(call_expr_id, f.output);\n+            ret bot;\n           }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n-        };\n-        fcx.write_ty(id, rt);\n-        ret bot;\n+        }\n     }\n \n     // A generic function for checking for or for-each loops\n     fn check_for(fcx: @fn_ctxt, local: @ast::local,\n                  element_ty: ty::t, body: ast::blk,\n                  node_id: ast::node_id) -> bool {\n         let locid = lookup_local(fcx, local.span, local.node.id);\n-        demand::simple(fcx, local.span,\n+        demand::suptype(fcx, local.span,\n                        ty::mk_var(fcx.ccx.tcx, locid),\n                        element_ty);\n         let bot = check_decl_local(fcx, local);\n@@ -2728,7 +2730,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 let if_t = fcx.next_ty_var();\n                 let thn_bot = check_block(fcx, thn);\n                 let thn_t = fcx.node_ty(thn.node.id);\n-                demand::simple(fcx, thn.span, if_t, thn_t);\n+                demand::suptype(fcx, thn.span, if_t, thn_t);\n                 let els_bot = check_expr_with(fcx, els, if_t);\n                 (if_t, thn_bot & els_bot)\n               }\n@@ -2764,7 +2766,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           some(origin) {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(callee_id);\n-                check_call_or_bind(fcx, op_ex.span, method_ty, args)\n+                check_call_or_bind(fcx, op_ex.span, op_ex.id,\n+                                   method_ty, args)\n             };\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some((ty::ty_fn_ret(method_ty), bot))\n@@ -2790,7 +2793,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             let t_var = fcx.next_ty_var();\n             let const_vec_t = ty::mk_vec(tcx, {ty: t_var,\n                                                mutbl: ast::m_const});\n-            demand::simple(fcx, lhs.span, const_vec_t, lhs_t);\n+            demand::suptype(fcx, lhs.span, const_vec_t, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, const_vec_t);\n             let result_vec_t = ty::mk_vec(tcx, {ty: t_var,\n                                                 mutbl: lhs_mt.mutbl});\n@@ -2810,7 +2813,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n           (_, _) if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.next_ty_var();\n-            demand::simple(fcx, expr.span, tvar, lhs_t);\n+            demand::suptype(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n             let rhs_t = alt op {\n               ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n@@ -2895,8 +2898,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         };\n         alt vst {\n           ast::vstore_slice(_) {\n-            let region = fcx.ccx.tcx.region_map.rvalue_to_region.get(ev.id);\n-            typ = replace_default_region(tcx, region, typ);\n+            let r = ty::re_scope(fcx.ccx.tcx.region_map.parents.get(ev.id));\n+            typ = replace_default_region(tcx, r, typ);\n           }\n           _ { }\n         }\n@@ -2935,7 +2938,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n-        demand::simple(fcx, expr.span, result_t, lhs_t);\n+        demand::suptype(fcx, expr.span, result_t, lhs_t);\n \n         // Overwrite result of check_binop...this preserves existing behavior\n         // but seems quite dubious with regard to user-defined methods\n@@ -3068,7 +3071,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         fcx.write_nil(id);\n       }\n       ast::expr_copy(a) {\n-        bot = check_expr_with_unifier(fcx, a, unify, expected);\n+        bot = check_expr_with_unifier(fcx, a, expected, unifier);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_move(lhs, rhs) {\n@@ -3107,18 +3110,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let pattern_ty = fcx.next_ty_var();\n         bot = check_expr_with(fcx, discrim, pattern_ty);\n \n-        let parent_region = tcx.region_map.rvalue_to_region.get(discrim.id);\n-\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n         //let pattern_ty = fcx.expr_ty(discrim);\n         for arms.each {|arm|\n             let pcx = {\n                 fcx: fcx,\n                 map: pat_util::pat_id_map(tcx.def_map, arm.pats[0]),\n-                alt_region: parent_region,\n+                alt_region: ty::re_scope(expr.id),\n                 block_region: ty::re_scope(arm.body.node.id),\n-                pat_region: parent_region\n+                pat_region: ty::re_scope(expr.id)\n             };\n \n             for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n@@ -3133,15 +3134,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n             if !check_block(fcx, arm.body) { arm_non_bot = true; }\n             let bty = fcx.node_ty(arm.body.node.id);\n-            demand::simple(fcx, arm.body.span, result_ty, bty);\n+            demand::suptype(fcx, arm.body.span, result_ty, bty);\n         }\n         bot |= !arm_non_bot;\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n         fcx.write_ty(id, result_ty);\n       }\n       ast::expr_fn(proto, decl, body, captures) {\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   unify, expected, false);\n+                                   unifier, expected, false);\n         capture::check_capture_clause(tcx, expr.id, proto, *captures);\n       }\n       ast::expr_fn_block(decl, body) {\n@@ -3154,21 +3155,21 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                expr_to_str(expr),\n                ty_to_str(tcx, expected));\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   unify, expected, false);\n+                                   unifier, expected, false);\n       }\n       ast::expr_loop_body(b) {\n         let rty = structurally_resolved_type(fcx, expr.span, expected);\n         let (inner_ty, proto) = alt check ty::get(rty).struct {\n           ty::ty_fn(fty) {\n-            demand::simple(fcx, expr.span, fty.output, ty::mk_bool(tcx));\n+            demand::suptype(fcx, expr.span, fty.output, ty::mk_bool(tcx));\n             (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}),\n              fty.proto)\n           }\n         };\n         alt check b.node {\n           ast::expr_fn_block(decl, body) {\n             check_expr_fn_with_unifier(fcx, b, proto, decl, body,\n-                                       unify, inner_ty, true);\n+                                       unifier, inner_ty, true);\n           }\n         }\n         let block_ty = structurally_resolved_type(\n@@ -3196,7 +3197,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let {fty, bot: ccob_bot} = {\n             let fn_ty = fcx.expr_ty(f);\n-            check_call_or_bind(fcx, expr.span, fn_ty, args)\n+            check_call_or_bind(fcx, expr.span, expr.id, fn_ty, args)\n         };\n         bot |= ccob_bot;\n \n@@ -3248,7 +3249,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         fcx.write_ty(id, ft);\n       }\n       ast::expr_call(f, args, _) {\n-        bot = check_call_full(fcx, expr.span, expr.id, f, args);\n+        bot = check_call(fcx, expr.span, expr.id, f, args);\n       }\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n@@ -3332,7 +3333,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 let mut found = false;\n                 for base_fields.each {|bf|\n                     if str::eq(f.node.ident, bf.ident) {\n-                        demand::simple(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n+                        demand::suptype(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n                     }\n                 }\n@@ -3488,7 +3489,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                 constraints: []})\n             };\n \n-            demand::simple(fcx, expr.span,\n+            demand::suptype(fcx, expr.span,\n                            expected_ty, fcx.node_ty(alloc_id));\n           }\n \n@@ -3516,7 +3517,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n            ty_to_str(tcx, fcx.expr_ty(expr)),\n            ty_to_str(tcx, expected));\n \n-    unify(fcx, expr.span, expected, fcx.expr_ty(expr));\n+    unifier(fcx, expr.span, expected, fcx.expr_ty(expr));\n \n     #debug(\"<< bot=%b\", bot);\n     ret bot;\n@@ -3559,7 +3560,9 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n       _ {/* fall through */ }\n     }\n \n-    let region = fcx.ccx.tcx.region_map.rvalue_to_region.get(local.node.id);\n+    let region =\n+        ty::re_scope(\n+            fcx.ccx.tcx.region_map.local_blocks.get(local.node.id));\n     let pcx = {\n         fcx: fcx,\n         map: pat_util::pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),\n@@ -3603,7 +3606,7 @@ fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n     if !bot {\n         let blkty = fcx.node_ty(blk.node.id);\n         let nilty = ty::mk_nil(fcx.ccx.tcx);\n-        demand::simple(fcx, blk.span, nilty, blkty);\n+        demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n     ret bot;\n }\n@@ -3667,7 +3670,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     check_expr(fcx, e);\n     let cty = fcx.expr_ty(e);\n     let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n-    demand::simple(fcx, e.span, declty, cty);\n+    demand::suptype(fcx, e.span, declty, cty);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n \n@@ -3709,7 +3712,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n             check_expr(fcx, e);\n             let cty = fcx.expr_ty(e);\n             let declty = ty::mk_int(ccx.tcx);\n-            demand::simple(fcx, e.span, declty, cty);\n+            demand::suptype(fcx, e.span, declty, cty);\n             // FIXME: issue #1417\n             // Also, check_expr (from check_const pass) doesn't guarantee that\n             // the expression in an form that eval_const_expr can handle, so\n@@ -3945,7 +3948,7 @@ fn check_fn(ccx: @crate_ctxt,\n     alt body.node.expr {\n       some(tail_expr) {\n         let tail_expr_ty = fcx.expr_ty(tail_expr);\n-        demand::simple(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n+        demand::suptype(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n       }\n       none { }\n     }\n@@ -4241,7 +4244,7 @@ mod vtable {\n         alt check ty::get(iface_ty).struct {\n           ty::ty_iface(_, tps) {\n             vec::iter2(tps, iface_tys,\n-                       {|a, b| demand::simple(fcx, sp, a, b);});\n+                       {|a, b| demand::suptype(fcx, sp, a, b);});\n           }\n         }\n     }"}, {"sha": "4246ecaa11649c29a754e02e19ede8c9bd9910fd", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=27f1c2b74299a2a26d89d4986620d38fc31798e3", "patch": "@@ -18,18 +18,36 @@ fn bound_region_to_str(_cx: ctxt, br: bound_region) -> str {\n     }\n }\n \n-fn region_to_str(cx: ctxt, region: region) -> str {\n-    alt region {\n-      re_scope(node_id) {\n-        alt cx.items.get(node_id) {\n-            ast_map::node_block(blk) {\n-                #fmt(\"&<block at %s>.\", codemap::span_to_str(blk.span,\n-                                                           cx.sess.codemap))\n-            }\n-            _ { cx.sess.bug(\"re_block refers to non-block\") }\n+fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> str {\n+    alt cx.items.get(node_id) {\n+      ast_map::node_block(blk) {\n+        #fmt(\"<block at %s>\",\n+             codemap::span_to_str(blk.span, cx.sess.codemap))\n+      }\n+      ast_map::node_expr(expr) {\n+        alt expr.node {\n+          ast::expr_call(_, _, _) {\n+            #fmt(\"<call at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+          }\n+          ast::expr_alt(_, _, _) {\n+            #fmt(\"<alt at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+          }\n+          _ { cx.sess.bug(\n+              #fmt[\"re_scope refers to %s\",\n+                   ast_map::node_id_to_str(cx.items, node_id)]) }\n         }\n       }\n+      _ { cx.sess.bug(\n+          #fmt[\"re_scope refers to %s\",\n+               ast_map::node_id_to_str(cx.items, node_id)]) }\n+    }\n+}\n \n+fn region_to_str(cx: ctxt, region: region) -> str {\n+    alt region {\n+      re_scope(node_id) { #fmt[\"&%s.\", re_scope_id_to_str(cx, node_id)] }\n       re_bound(br) { bound_region_to_str(cx, br) }\n       re_free(id, br) { #fmt[\"{%d} %s\", id, bound_region_to_str(cx, br)] }\n "}, {"sha": "6a9228030d736232506e08270c54a4fa6c256574", "filename": "src/test/compile-fail/regions-borrow.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs?ref=27f1c2b74299a2a26d89d4986620d38fc31798e3", "patch": "@@ -1,9 +1,8 @@\n-// xfail-test\n-\n fn foo(x: &uint) -> &uint { x }\n \n fn main() {\n     let p = @3u;\n     let r = foo(p);\n     assert *p == *r;\n-}\n\\ No newline at end of file\n+    //!^ ERROR reference is not valid\n+}", "previous_filename": "src/test/run-pass/regions-borrow.rs"}, {"sha": "33f1c1b4ab91461b9663b63fc17a5c21f7bcf541", "filename": "src/test/compile-fail/regions-leaking-ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f1c2b74299a2a26d89d4986620d38fc31798e3/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs?ref=27f1c2b74299a2a26d89d4986620d38fc31798e3", "patch": "@@ -2,18 +2,18 @@\n // This generates a ton of error msgs at the moment.\n fn broken() -> int {\n     let mut x = 3;\n-    let mut y = [&x]; //! ERROR reference escapes its block\n+    let mut y = [&x]; //! ERROR reference is not valid\n     while x < 10 {\n         let z = x;\n         y += [&z];\n         x += 1;\n     }\n     vec::foldl(0, y) {|v, p| v + *p }\n-    //!^ ERROR reference escapes its block\n-    //!^^ ERROR reference escapes its block\n-    //!^^^ ERROR reference escapes its block\n-    //!^^^^ ERROR reference escapes its block\n-    //!^^^^^ ERROR reference escapes its block\n+    //!^ ERROR reference is not valid\n+    //!^^ ERROR reference is not valid\n+    //!^^^ ERROR reference is not valid\n+    //!^^^^ ERROR reference is not valid\n+    //!^^^^^ ERROR reference is not valid\n }\n \n fn main() { }\n\\ No newline at end of file"}]}