{"sha": "08f8faedd0e30f45762afbb8d4873f7041e7462c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZjhmYWVkZDBlMzBmNDU3NjJhZmJiOGQ0ODczZjcwNDFlNzQ2MmM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-12-02T00:35:55Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-12-03T21:30:27Z"}, "message": "syntax: Rename some keywords\n\n`CrateRoot` -> `PathRoot`, `::` doesn't necessarily mean crate root now\n`SelfValue` -> `SelfLower`, `SelfType` -> `SelfUpper`, both `self` and `Self` can be used in type and value namespaces now", "tree": {"sha": "fc4db862a94e674e17e1bf1e203f838fa0c680fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc4db862a94e674e17e1bf1e203f838fa0c680fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f8faedd0e30f45762afbb8d4873f7041e7462c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f8faedd0e30f45762afbb8d4873f7041e7462c", "html_url": "https://github.com/rust-lang/rust/commit/08f8faedd0e30f45762afbb8d4873f7041e7462c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f8faedd0e30f45762afbb8d4873f7041e7462c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "101467c152b26c44079401a712291c29cff0c9ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/101467c152b26c44079401a712291c29cff0c9ac", "html_url": "https://github.com/rust-lang/rust/commit/101467c152b26c44079401a712291c29cff0c9ac"}], "stats": {"total": 166, "additions": 83, "deletions": 83}, "files": [{"sha": "8ea1cb26dc0c7f0239dac52fa1f67ef48165042d", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -741,14 +741,14 @@ fn_anon_params\n ;\n \n fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n ;\n \n fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }"}, {"sha": "a485af0a5eef9fa1a989f0d614660c81b4ba0868", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -1201,7 +1201,7 @@ impl<'a> LoweringContext<'a> {\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfType.ident())],\n+                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfUpper.ident())],\n                     span: t.span,\n                 }),\n             )),\n@@ -2425,7 +2425,7 @@ impl<'a> LoweringContext<'a> {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n                 // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-                let ident = if param.ident.name == keywords::SelfType.name() {\n+                let ident = if param.ident.name == keywords::SelfUpper.name() {\n                     param.ident.gensym()\n                 } else {\n                     param.ident\n@@ -2981,7 +2981,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // Correctly resolve `self` imports\n                 if path.segments.len() > 1\n-                    && path.segments.last().unwrap().ident.name == keywords::SelfValue.name()\n+                    && path.segments.last().unwrap().ident.name == keywords::SelfLower.name()\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {"}, {"sha": "4ac07d78a26137f0d4003a639bdfefa5a8ce1d7d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -475,7 +475,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfType.name(),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }"}, {"sha": "85bf257df237fa3052614cb9431e990ea726adbf", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -311,7 +311,7 @@ pub struct Path {\n \n impl Path {\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n     }\n }\n "}, {"sha": "eb11d40440b19de34719b26a9a510e6d3bbe6427", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -1622,7 +1622,7 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.ident.name != keywords::CrateRoot.name() &&\n+            if segment.ident.name != keywords::PathRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name() {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n@@ -1636,7 +1636,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n@@ -1664,7 +1664,7 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.ident.name != keywords::CrateRoot.name() &&\n+                    if segment.ident.name != keywords::PathRoot.name() &&\n                        segment.ident.name != keywords::DollarCrate.name() {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {"}, {"sha": "b846a1c4930fbf4675537e55f4d7ce6c2db45a48", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self.\n-                if ident.name != keywords::SelfValue.name() {\n+                if ident.name != keywords::SelfLower.name() {\n                     if !self.warn_about_unused(sp, hir_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(hir_id, sp, var, true);"}, {"sha": "7862a72433ae18f841dd1ed73ab5aef14bd38bd3", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -2710,7 +2710,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, keywords::SelfType.name().as_interned_str())\n+        self.mk_ty_param(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {"}, {"sha": "1a52717ef058891cda94d9e8b97945c1f82cd72b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -1020,7 +1020,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, keywords::SelfType.name().as_interned_str())\n+        ParamTy::new(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n@@ -1035,7 +1035,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         // FIXME(#50125): Ignoring `Self` with `idx != 0` might lead to weird behavior elsewhere,\n         // but this should only be possible when using `-Z continue-parse-after-error` like\n         // `compile-fail/issue-36638.rs`.\n-        self.name == keywords::SelfType.name().as_str() && self.idx == 0\n+        self.name == keywords::SelfUpper.name().as_str() && self.idx == 0\n     }\n }\n "}, {"sha": "c7eb06cbe00535eebc180e7b58d97743a5d5f8ff", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -473,7 +473,7 @@ impl UnusedImportBraces {\n             match items[0].0.kind {\n                 ast::UseTreeKind::Simple(rename, ..) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n-                    if orig_ident.name == keywords::SelfValue.name() {\n+                    if orig_ident.name == keywords::SelfLower.name() {\n                         return;\n                     }\n                     node_ident = rename.unwrap_or(orig_ident);"}, {"sha": "4bcabfef4fd7f41c59e06e26d0d961ec73ff5132", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             // Deliberately fall into this case for all implicit self types,\n                             // so that we don't fall in to the next case with them.\n                             *kind == mir::ImplicitSelfKind::MutRef\n-                        } else if Some(keywords::SelfValue.name()) == local_decl.name {\n+                        } else if Some(keywords::SelfLower.name()) == local_decl.name {\n                             // Otherwise, check if the name is the self kewyord - in which case\n                             // we have an explicit self. Do the same thing in this case and check\n                             // for a `self: &mut Self` to suggest removing the `&mut`."}, {"sha": "68e98320f6f4a6ce9ae8ec2fc30a8840e9fd1c61", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -145,15 +145,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n             _ => None,\n         }.map(|ctxt| Segment::from_ident(Ident::new(\n-            keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n+            keywords::PathRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n         )));\n \n         let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n \n         let empty_for_self = |prefix: &[Segment]| {\n             prefix.is_empty() ||\n-            prefix.len() == 1 && prefix[0].ident.name == keywords::CrateRoot.name()\n+            prefix.len() == 1 && prefix[0].ident.name == keywords::PathRoot.name()\n         };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n@@ -164,7 +164,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 if nested {\n                     // Correctly handle `self`\n-                    if source.ident.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfLower.name() {\n                         type_ns_only = true;\n \n                         if empty_for_self(&module_path) {\n@@ -185,7 +185,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 } else {\n                     // Disallow `self`\n-                    if source.ident.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfLower.name() {\n                         resolve_error(self,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n@@ -205,7 +205,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             // `crate_name` should not be interpreted as relative.\n                             module_path.push(Segment {\n                                 ident: Ident {\n-                                    name: keywords::CrateRoot.name(),\n+                                    name: keywords::PathRoot.name(),\n                                     span: source.ident.span,\n                                 },\n                                 id: Some(self.session.next_node_id()),\n@@ -270,7 +270,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items.iter().filter_map(|&(ref use_tree, _)| {\n                     if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n-                        if use_tree.ident().name == keywords::SelfValue.name() {\n+                        if use_tree.ident().name == keywords::SelfLower.name() {\n                             return Some(use_tree.span);\n                         }\n                     }\n@@ -305,7 +305,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     let new_span = prefix[prefix.len() - 1].ident.span;\n                     let tree = ast::UseTree {\n                         prefix: ast::Path::from_ident(\n-                            Ident::new(keywords::SelfValue.name(), new_span)\n+                            Ident::new(keywords::SelfLower.name(), new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n                             Some(Ident::new(keywords::Underscore.name().gensymed(), new_span)),\n@@ -344,13 +344,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n \n             ItemKind::ExternCrate(orig_name) => {\n-                let module = if orig_name.is_none() && ident.name == keywords::SelfValue.name() {\n+                let module = if orig_name.is_none() && ident.name == keywords::SelfLower.name() {\n                     self.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                         .span_suggestion(item.span, \"try\", \"extern crate self as name;\".into())\n                         .emit();\n                     return;\n-                } else if orig_name == Some(keywords::SelfValue.name()) {\n+                } else if orig_name == Some(keywords::SelfLower.name()) {\n                     if !self.session.features_untracked().extern_crate_self {\n                         emit_feature_err(&self.session.parse_sess, \"extern_crate_self\", item.span,\n                                          GateIssue::Language, \"`extern crate self` is unstable\");\n@@ -783,7 +783,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n-                    if orig_name == keywords::SelfValue.name() {\n+                    if orig_name == keywords::SelfLower.name() {\n                         self.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n                     }"}, {"sha": "23edaf12438121fd682389ae45f9ff7c741ca0f0", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         match (path.get(0), path.get(1)) {\n             // `{{root}}::ident::...` on both editions.\n             // On 2015 `{{root}}` is usually added implicitly.\n-            (Some(fst), Some(snd)) if fst.ident.name == keywords::CrateRoot.name() &&\n+            (Some(fst), Some(snd)) if fst.ident.name == keywords::PathRoot.name() &&\n                                       !snd.ident.is_path_segment_keyword() => {}\n             // `ident::...` on 2018\n             (Some(fst), _) if fst.ident.span.rust_2018() &&\n@@ -61,7 +61,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n-        path[0].ident.name = keywords::SelfValue.name();\n+        path[0].ident.name = keywords::SelfLower.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {"}, {"sha": "9ea39aea86867ea99455a352c1df7192f9492210", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -769,7 +769,7 @@ impl<'a, 'tcx, 'cl> Visitor<'tcx> for Resolver<'a, 'cl> {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n             TyKind::ImplicitSelf => {\n-                let self_ty = keywords::SelfType.ident();\n+                let self_ty = keywords::SelfUpper.ident();\n                 let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Def::Err, |d| d.def());\n                 self.record_def(ty.id, PathResolution::new(def));\n@@ -1679,7 +1679,7 @@ impl<'a, 'cl> hir::lowering::Resolver for Resolver<'a, 'cl> {\n         components: &[&str],\n         is_value: bool\n     ) -> hir::Path {\n-        let segments = iter::once(keywords::CrateRoot.ident())\n+        let segments = iter::once(keywords::PathRoot.ident())\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n@@ -1721,7 +1721,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n-                segments: iter::once(keywords::CrateRoot.ident())\n+                segments: iter::once(keywords::PathRoot.ident())\n                     .chain({\n                         path_str.split(\"::\").skip(1).map(Ident::from_str)\n                     })\n@@ -2036,7 +2036,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let record_used = record_used_id.is_some();\n         assert!(ns == TypeNS  || ns == ValueNS);\n         if ns == TypeNS {\n-            ident.span = if ident.name == keywords::SelfType.name() {\n+            ident.span = if ident.name == keywords::SelfUpper.name() {\n                 // FIXME(jseyfried) improve `Self` hygiene\n                 ident.span.with_ctxt(SyntaxContext::empty())\n             } else {\n@@ -2649,7 +2649,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -2660,7 +2660,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     {\n         let self_def = Def::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -3146,7 +3146,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 let item_span = path.last().unwrap().ident.span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n-                } else if path.len() == 2 && path[0].ident.name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -3515,13 +3515,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n+        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfUpper.ident(),\n                                                           TypeNS, None, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n-        let ident = Ident::new(keywords::SelfValue.name(), self_span);\n+        let ident = Ident::new(keywords::SelfLower.name(), self_span);\n         let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n@@ -3673,7 +3673,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].ident.name != keywords::CrateRoot.name() &&\n+           path[0].ident.name != keywords::PathRoot.name() &&\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path_without_parent_scope(\n@@ -3755,7 +3755,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let name = ident.name;\n \n             allow_super &= ns == TypeNS &&\n-                (name == keywords::SelfValue.name() ||\n+                (name == keywords::SelfLower.name() ||\n                  name == keywords::Super.name());\n \n             if ns == TypeNS {\n@@ -3779,24 +3779,24 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     return PathResult::Failed(ident.span, msg, false);\n                 }\n                 if i == 0 {\n-                    if name == keywords::SelfValue.name() {\n+                    if name == keywords::SelfLower.name() {\n                         let mut ctxt = ident.span.ctxt().modern();\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_self(&mut ctxt, self.current_module)));\n                         continue;\n                     }\n                     if name == keywords::Extern.name() ||\n-                       name == keywords::CrateRoot.name() && ident.span.rust_2018() {\n+                       name == keywords::PathRoot.name() && ident.span.rust_2018() {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::CrateRoot.name() &&\n+                    if name == keywords::PathRoot.name() &&\n                        ident.span.rust_2015() && self.session.rust_2018() {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::CrateRoot.name() ||\n+                    if name == keywords::PathRoot.name() ||\n                        name == keywords::Crate.name() ||\n                        name == keywords::DollarCrate.name() {\n                         // `::a::b`, `crate::a::b` or `$crate::a::b`\n@@ -3809,12 +3809,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             // Report special messages for path segment keywords in wrong positions.\n             if ident.is_path_segment_keyword() && i != 0 {\n-                let name_str = if name == keywords::CrateRoot.name() {\n+                let name_str = if name == keywords::PathRoot.name() {\n                     \"crate root\".to_string()\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].ident.name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].ident.name == keywords::PathRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n@@ -3944,7 +3944,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         // We're only interested in `use` paths which should start with\n         // `{{root}}` or `extern` currently.\n-        if first_name != keywords::Extern.name() && first_name != keywords::CrateRoot.name() {\n+        if first_name != keywords::Extern.name() && first_name != keywords::PathRoot.name() {\n             return\n         }\n \n@@ -3953,7 +3953,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             Some(Segment { ident, .. }) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n-            // If the path has length one (and it's `CrateRoot` most likely)\n+            // If the path has length one (and it's `PathRoot` most likely)\n             // then we don't know whether we're gonna be importing a crate or an\n             // item in our crate. Defer this lint to elsewhere\n             None => return,\n@@ -4740,7 +4740,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     let ctxt = ident.span.ctxt();\n                     Some(Segment::from_ident(Ident::new(\n-                        keywords::CrateRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n+                        keywords::PathRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n                     )))\n                 };\n \n@@ -5090,17 +5090,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n }\n \n fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfType.name()\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfUpper.name()\n }\n \n fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfValue.name()\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfLower.name()\n }\n \n fn names_to_string(idents: &[Ident]) -> String {\n     let mut result = String::new();\n     for (i, ident) in idents.iter()\n-                            .filter(|ident| ident.name != keywords::CrateRoot.name())\n+                            .filter(|ident| ident.name != keywords::PathRoot.name())\n                             .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");"}, {"sha": "65a9652cd237cb0675157f070899b78184b6ba3f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n                 if path.segments[0].ident.name == keywords::DollarCrate.name() {\n                     let module = self.0.resolve_crate_root(path.segments[0].ident);\n-                    path.segments[0].ident.name = keywords::CrateRoot.name();\n+                    path.segments[0].ident.name = keywords::PathRoot.name();\n                     if !module.is_local() {\n                         let span = path.segments[0].ident.span;\n                         path.segments.insert(1, match module.kind {\n@@ -674,7 +674,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     _ => Err(Determinacy::Determined),\n                 }\n                 WhereToResolve::CrateRoot => {\n-                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_ident = Ident::new(keywords::PathRoot.name(), orig_ident.span);\n                     let root_module = self.resolve_crate_root(root_ident);\n                     let binding = self.resolve_ident_in_module_ext(\n                         ModuleOrUniformRoot::Module(root_module),\n@@ -960,7 +960,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     break 'ok;\n                 }\n                 if rust_2015 {\n-                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_ident = Ident::new(keywords::PathRoot.name(), orig_ident.span);\n                     let root_module = self.resolve_crate_root(root_ident);\n                     if self.resolve_ident_in_module_ext(ModuleOrUniformRoot::Module(root_module),\n                                                         orig_ident, ns, None, false, path_span)"}, {"sha": "865aace8aabb51c66c6321c26e4b4439f466dde0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                         .to_name_binding(self.arenas);\n                         return Ok(binding);\n                     } else if ident.name == keywords::Super.name() ||\n-                                ident.name == keywords::SelfValue.name() {\n+                                ident.name == keywords::SelfLower.name() {\n                         // FIXME: Implement these with renaming requirements so that e.g.\n                         // `use super;` doesn't work, but `use super as name;` does.\n                         // Fall through here to get an error from `early_resolve_...`.\n@@ -1263,8 +1263,8 @@ fn import_path_to_string(names: &[Ident],\n                          subclass: &ImportDirectiveSubclass,\n                          span: Span) -> String {\n     let pos = names.iter()\n-        .position(|p| span == p.span && p.name != keywords::CrateRoot.name());\n-    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n+        .position(|p| span == p.span && p.name != keywords::PathRoot.name());\n+    let global = !names.is_empty() && names[0].name == keywords::PathRoot.name();\n     if let Some(pos) = pos {\n         let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n         names_to_string(names)"}, {"sha": "5682a73bed573ffd51f06bf3192a8a6921eac47b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -938,7 +938,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n-                        name: keywords::SelfType.name().as_interned_str(),\n+                        name: keywords::SelfUpper.name().as_interned_str(),\n                         def_id: tcx.hir.local_def_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n@@ -1007,7 +1007,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     synthetic,\n                     ..\n                 } => {\n-                    if param.name.ident().name == keywords::SelfType.name() {\n+                    if param.name.ident().name == keywords::SelfUpper.name() {\n                         span_bug!(\n                             param.span,\n                             \"`Self` should not be the name of a regular parameter\""}, {"sha": "c68ffbab05ad4fa623d47ac91932f1777a0dc71d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n             ty::GenericParamDefKind::Lifetime => None,\n             ty::GenericParamDefKind::Type { .. } => {\n-                if param.name == keywords::SelfType.name().as_str() {\n+                if param.name == keywords::SelfUpper.name().as_str() {\n                     assert_eq!(param.index, 0);\n                     return None;\n                 }\n@@ -3174,7 +3174,7 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n         if i > 0 {\n             s.push_str(\"::\");\n         }\n-        if seg.ident.name != keywords::CrateRoot.name() {\n+        if seg.ident.name != keywords::PathRoot.name() {\n             s.push_str(&*seg.ident.as_str());\n         }\n     }\n@@ -3726,7 +3726,7 @@ fn resolve_type(cx: &DocContext,\n             hir::Float(float_ty) => return Primitive(float_ty.into()),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(keywords::SelfType.name().to_string());\n+            return Generic(keywords::SelfUpper.name().to_string());\n         }\n         Def::TyParam(..) if path.segments.len() == 1 => {\n             return Generic(format!(\"{:#}\", path));"}, {"sha": "b681ed454e2c317a71eb34ed9523a5acaf4598b4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -73,7 +73,7 @@ impl fmt::Debug for Lifetime {\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n-    /// Global paths begin with `keywords::CrateRoot`.\n+    /// Global paths begin with `keywords::PathRoot`.\n     pub segments: Vec<PathSegment>,\n }\n \n@@ -117,7 +117,7 @@ impl Path {\n     }\n \n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n     }\n }\n \n@@ -145,7 +145,7 @@ impl PathSegment {\n         PathSegment { ident, id: DUMMY_NODE_ID, args: None }\n     }\n     pub fn crate_root(span: Span) -> Self {\n-        PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))\n+        PathSegment::from_ident(Ident::new(keywords::PathRoot.name(), span))\n     }\n }\n \n@@ -1688,7 +1688,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n-            if ident.name == keywords::SelfValue.name() {\n+            if ident.name == keywords::SelfLower.name() {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                     TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.node.is_implicit_self() => {\n@@ -1706,7 +1706,7 @@ impl Arg {\n \n     pub fn is_self(&self) -> bool {\n         if let PatKind::Ident(_, ident, _) = self.pat.node {\n-            ident.name == keywords::SelfValue.name()\n+            ident.name == keywords::SelfLower.name()\n         } else {\n             false\n         }"}, {"sha": "63e9744d770e1ca5c74003f80839add584acbcfa", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -625,7 +625,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, keywords::SelfValue.ident())\n+        self.expr_ident(span, keywords::SelfLower.ident())\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,"}, {"sha": "67f3dc1bb527226ed2dd4e3f0227f6b8025d8152", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -204,7 +204,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n             path_str.push_str(\"::\");\n         }\n \n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n             segment.ident.name != keywords::DollarCrate.name()\n         {\n             path_str.push_str(&segment.ident.as_str())"}, {"sha": "56d42e6e9646c02d0abd03f0322355a915c959b7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -5508,7 +5508,7 @@ impl<'a> Parser<'a> {\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n-            this.look_ahead(n, |t| t.is_keyword(keywords::SelfValue)) &&\n+            this.look_ahead(n, |t| t.is_keyword(keywords::SelfLower)) &&\n             this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n \n@@ -6330,7 +6330,7 @@ impl<'a> Parser<'a> {\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n                       self.look_ahead(1, |t| t.is_keyword(keywords::Super) ||\n-                                             t.is_keyword(keywords::SelfValue))\n+                                             t.is_keyword(keywords::SelfLower))\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n@@ -6782,7 +6782,7 @@ impl<'a> Parser<'a> {\n         let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n         let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n                               in the code\";\n-        let mut ident = if self.token.is_keyword(keywords::SelfValue) {\n+        let mut ident = if self.token.is_keyword(keywords::SelfLower) {\n             self.parse_path_segment_ident()\n         } else {\n             self.parse_ident()"}, {"sha": "e50f28897dd1287db983f5918bf184191bf17317", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -724,7 +724,7 @@ pub trait PrintState<'a> {\n             if i > 0 {\n                 self.writer().word(\"::\")?\n             }\n-            if segment.ident.name != keywords::CrateRoot.name() &&\n+            if segment.ident.name != keywords::PathRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name()\n             {\n                 self.writer().word(segment.ident.as_str().get())?;\n@@ -2463,7 +2463,7 @@ impl<'a> State<'a> {\n                           colons_before_params: bool)\n                           -> io::Result<()>\n     {\n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n             self.print_ident(segment.ident)?;\n             if let Some(ref args) = segment.args {"}, {"sha": "5c994558ab06feb3aafc0f72df4634bc04b683f6", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -112,7 +112,7 @@ pub fn maybe_inject_crates_ref(\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: iter::once(keywords::CrateRoot.ident())\n+                segments: iter::once(keywords::PathRoot.ident())\n                     .chain(\n                         [name, \"prelude\", \"v1\"].iter().cloned()\n                             .map(ast::Ident::from_str)"}, {"sha": "b9e0933331cb87814deb4a4177d9d454249eea14", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -140,7 +140,7 @@ fn cs_clone_shallow(name: &str,\n     let mut stmts = Vec::new();\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n-        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfType.ident()));\n+        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfUpper.ident()));\n         assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n     } else {\n         match *substr.fields {"}, {"sha": "c0c11f64bc3b88b722e65f96846e96fa15ed63c1", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -938,7 +938,7 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 ast::Arg::from_self(explicit_self,\n-                                    keywords::SelfValue.ident().with_span_pos(trait_.span))\n+                                    keywords::SelfLower.ident().with_span_pos(trait_.span))\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.arg(trait_.span, name, ty));"}, {"sha": "0b8ef60f363e39b0d7ed9b852f773fa0d1e2b0a7", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f8faedd0e30f45762afbb8d4873f7041e7462c/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=08f8faedd0e30f45762afbb8d4873f7041e7462c", "patch": "@@ -349,7 +349,7 @@ declare_keywords! {\n     // Special reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n     (0,  Invalid,            \"\")\n-    (1,  CrateRoot,          \"{{root}}\")\n+    (1,  PathRoot,           \"{{root}}\")\n     (2,  DollarCrate,        \"$crate\")\n     (3,  Underscore,         \"_\")\n \n@@ -378,8 +378,8 @@ declare_keywords! {\n     (25, Pub,                \"pub\")\n     (26, Ref,                \"ref\")\n     (27, Return,             \"return\")\n-    (28, SelfValue,          \"self\")\n-    (29, SelfType,           \"Self\")\n+    (28, SelfLower,          \"self\")\n+    (29, SelfUpper,          \"Self\")\n     (30, Static,             \"static\")\n     (31, Struct,             \"struct\")\n     (32, Super,              \"super\")\n@@ -462,11 +462,11 @@ impl Ident {\n     /// A keyword or reserved identifier that can be used as a path segment.\n     pub fn is_path_segment_keyword(self) -> bool {\n         self.name == keywords::Super.name() ||\n-        self.name == keywords::SelfValue.name() ||\n-        self.name == keywords::SelfType.name() ||\n+        self.name == keywords::SelfLower.name() ||\n+        self.name == keywords::SelfUpper.name() ||\n         self.name == keywords::Extern.name() ||\n         self.name == keywords::Crate.name() ||\n-        self.name == keywords::CrateRoot.name() ||\n+        self.name == keywords::PathRoot.name() ||\n         self.name == keywords::DollarCrate.name()\n     }\n "}]}