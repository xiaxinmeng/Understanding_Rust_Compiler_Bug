{"sha": "0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNmZjNDZjMDMwYWIwNTE1YTA1MmZhOTljOWUxMGM3NWNmYzgxODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-03T15:16:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-03T15:16:54Z"}, "message": "auto merge of #7566 : huonw/rust/vec-kill, r=cmr\n\nThe last remaining internal iterator in `vec` is `each_permutation`.", "tree": {"sha": "3840f27f53871ed20b17e82beac7ea9a402dce46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3840f27f53871ed20b17e82beac7ea9a402dce46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "html_url": "https://github.com/rust-lang/rust/commit/0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cee9d4c38c628914cc72277854bd97f4f017225", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cee9d4c38c628914cc72277854bd97f4f017225", "html_url": "https://github.com/rust-lang/rust/commit/1cee9d4c38c628914cc72277854bd97f4f017225"}, {"sha": "cdea73cf5b94784fdc910ab23d5d3455c868d247", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdea73cf5b94784fdc910ab23d5d3455c868d247", "html_url": "https://github.com/rust-lang/rust/commit/cdea73cf5b94784fdc910ab23d5d3455c868d247"}], "stats": {"total": 2014, "additions": 817, "deletions": 1197}, "files": [{"sha": "5ed61d6930143a2bdb3744bf4c11c2984bf76dd0", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -108,7 +108,7 @@ impl Iterator<int> for ZeroStream {\n ## Container iterators\n \n Containers implement iteration over the contained elements by returning an\n-iterator object. For example, vectors have four iterators available:\n+iterator object. For example, vector slices have four iterators available:\n \n * `vector.iter()`, for immutable references to the elements\n * `vector.mut_iter()`, for mutable references to the elements"}, {"sha": "8e493fd5396f90dd2716d7273eb5e9e3670d189d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -601,9 +601,8 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n    ProcArgs {\n     // If we've got another tool to run under (valgrind),\n     // then split apart its command\n-    let toolargs = split_maybe_args(&config.runtool);\n-\n-    let mut args = toolargs + [make_exe_name(config, testfile).to_str()];\n+    let mut args = split_maybe_args(&config.runtool);\n+    args.push(make_exe_name(config, testfile).to_str());\n     let prog = args.shift();\n     return ProcArgs {prog: prog, args: args};\n }"}, {"sha": "0f2d44f57e34c457762a38ec3160cded370aca3e", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -240,7 +240,6 @@ impl Digest for Sha1 {\n \n #[cfg(test)]\n mod tests {\n-    use std::vec;\n \n     use digest::{Digest, DigestUtil};\n     use sha1::Sha1;\n@@ -337,7 +336,7 @@ mod tests {\n         for tests.iter().advance |t| {\n             (*sh).input_str(t.input);\n             sh.result(out);\n-            assert!(vec::eq(t.output, out));\n+            assert!(t.output.as_slice() == out);\n \n             let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);\n@@ -357,7 +356,7 @@ mod tests {\n                 left = left - take;\n             }\n             sh.result(out);\n-            assert!(vec::eq(t.output, out));\n+            assert!(t.output.as_slice() == out);\n \n             let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);"}, {"sha": "88c61e60d86b4186cf8127ef3ae1494062640f56", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -45,7 +45,7 @@ static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static LZ_BEST : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n-    do vec::as_imm_buf(bytes) |b, len| {\n+    do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -63,7 +63,7 @@ pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n }\n \n pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n-    do vec::as_imm_buf(bytes) |b, len| {\n+    do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res ="}, {"sha": "de0a988f94c8ee68e02db4914787215e4b240cfd", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -55,7 +55,6 @@ use std::io;\n use std::comm::GenericChan;\n use std::comm::GenericPort;\n use std::sys::size_of;\n-use std::vec;\n \n /**\n A FlatPort, consisting of a `BytePort` that receives byte vectors,\n@@ -274,7 +273,7 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n             }\n         };\n \n-        if vec::eq(command, CONTINUE) {\n+        if CONTINUE.as_slice() == command {\n             let msg_len = match self.byte_port.try_recv(size_of::<u64>()) {\n                 Some(bytes) => {\n                     io::u64_from_be_bytes(bytes, 0, size_of::<u64>())\n@@ -931,7 +930,7 @@ mod test {\n         fn test_try_recv_none3<P:BytePort>(loader: PortLoader<P>) {\n             static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n-            let bytes = CONTINUE.to_owned() + [0];\n+            let bytes = CONTINUE.to_owned() + &[0u8];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert!(res.is_none());\n@@ -955,7 +954,7 @@ mod test {\n                     1, sys::size_of::<u64>()) |len_bytes| {\n                     len_bytes.to_owned()\n                 };\n-                let bytes = CONTINUE.to_owned() + len_bytes + [0, 0, 0, 0];\n+                let bytes = CONTINUE.to_owned() + len_bytes + &[0u8, 0, 0, 0];\n \n                 let port = loader(bytes);\n "}, {"sha": "71d99479693fa76e01adbc924e00faf6a7eab8e3", "filename": "src/libextra/json.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -24,7 +24,6 @@ use std::io::{WriterUtil, ReaderUtil};\n use std::io;\n use std::str;\n use std::to_str;\n-use std::vec;\n \n use serialize::Encodable;\n use serialize;\n@@ -941,7 +940,7 @@ impl serialize::Decoder for Decoder {\n         let name = match self.stack.pop() {\n             String(s) => s,\n             List(list) => {\n-                do vec::consume_reverse(list) |_i, v| {\n+                for list.consume_rev_iter().advance |v| {\n                     self.stack.push(v);\n                 }\n                 match self.stack.pop() {\n@@ -1059,7 +1058,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n-                do vec::consume_reverse(list) |_i, v| {\n+                for list.consume_rev_iter().advance |v| {\n                     self.stack.push(v);\n                 }\n                 len"}, {"sha": "a0b95924e09dc46009514365cc421ac36009feb6", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -207,7 +207,7 @@ impl Add<BigUint, BigUint> for BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n-        let sum = do vec::from_fn(new_len) |i| {\n+        let mut sum = do vec::from_fn(new_len) |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n@@ -216,8 +216,8 @@ impl Add<BigUint, BigUint> for BigUint {\n             carry = hi;\n             lo\n         };\n-        if carry == 0 { return BigUint::new(sum) };\n-        return BigUint::new(sum + [carry]);\n+        if carry != 0 { sum.push(carry); }\n+        return BigUint::new(sum);\n     }\n }\n \n@@ -284,15 +284,15 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return copy *a; }\n \n             let mut carry = 0;\n-            let prod = do a.data.iter().transform |ai| {\n+            let mut prod = do a.data.iter().transform |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n             }.collect::<~[BigDigit]>();\n-            if carry == 0 { return BigUint::new(prod) };\n-            return BigUint::new(prod + [carry]);\n+            if carry != 0 { prod.push(carry); }\n+            return BigUint::new(prod);\n         }\n \n \n@@ -520,10 +520,12 @@ impl ToStrRadix for BigUint {\n \n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n-            let s = vec::reversed(v).map(|n| {\n-                let s = uint::to_str_radix(*n as uint, radix);\n-                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n-            }).concat();\n+            let mut s = str::with_capacity(v.len() * l);\n+            for v.rev_iter().advance |n| {\n+                let ss = uint::to_str_radix(*n as uint, radix);\n+                s.push_str(\"0\".repeat(l - ss.len()));\n+                s.push_str(ss);\n+            }\n             s.trim_left_chars(&'0').to_owned()\n         }\n     }\n@@ -619,15 +621,15 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n-        let shifted = do self.data.iter().transform |elem| {\n+        let mut shifted = do self.data.iter().transform |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n         }.collect::<~[BigDigit]>();\n-        if carry == 0 { return BigUint::new(shifted); }\n-        return BigUint::new(shifted + [carry]);\n+        if carry != 0 { shifted.push(carry); }\n+        return BigUint::new(shifted);\n     }\n \n \n@@ -1629,7 +1631,6 @@ mod bigint_tests {\n     use std::int;\n     use std::num::{IntConvertible, Zero, One, FromStrRadix};\n     use std::uint;\n-    use std::vec;\n \n     #[test]\n     fn test_from_biguint() {\n@@ -1646,9 +1647,11 @@ mod bigint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let vs = [ &[2], &[1, 1], &[2, 1], &[1, 1, 1] ];\n-        let mut nums = vec::reversed(vs)\n-            .map(|s| BigInt::from_slice(Minus, *s));\n+        let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n+        let mut nums = ~[];\n+        for vs.rev_iter().advance |s| {\n+            nums.push(BigInt::from_slice(Minus, *s));\n+        }\n         nums.push(Zero::zero());\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n "}, {"sha": "d56f7b32ae7d86ab96e08c9d9ea8e2e67c346517", "filename": "src/libextra/par.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -53,7 +53,7 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n         info!(\"spawning tasks\");\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n-            do vec::as_imm_buf(xs) |p, _len| {\n+            do xs.as_imm_buf |p, _len| {\n                 let f = f();\n                 let base = base;\n                 let f = do future_spawn() || {\n@@ -78,11 +78,10 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n         info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n         assert_eq!(num_tasks, futures.len());\n \n-        let r = do vec::map_consume(futures) |ys| {\n+        do futures.consume_iter().transform |ys| {\n             let mut ys = ys;\n             ys.get()\n-        };\n-        r\n+        }.collect()\n     }\n }\n "}, {"sha": "97793ce440c2b477726145334de97c5e7d5369db", "filename": "src/libextra/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -477,7 +477,7 @@ fn run_tests(opts: &TestOpts,\n     }\n \n     // All benchmarks run at the end, in serial.\n-    do vec::consume(filtered_benchs) |_, b| {\n+    for filtered_benchs.consume_iter().advance |b| {\n         callback(TeWait(copy b.desc));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n@@ -523,7 +523,7 @@ pub fn filter_tests(\n             } else { return option::None; }\n         }\n \n-        vec::filter_map(filtered, |x| filter_fn(x, filter_str))\n+        filtered.consume_iter().filter_map(|x| filter_fn(x, filter_str)).collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -541,7 +541,7 @@ pub fn filter_tests(\n                 None\n             }\n         };\n-        vec::filter_map(filtered, |x| filter(x))\n+        filtered.consume_iter().filter_map(|x| filter(x)).collect()\n     };\n \n     // Sort the tests alphabetically\n@@ -720,9 +720,9 @@ impl BenchHarness {\n             // Eliminate outliers\n             let med = samples.median();\n             let mad = samples.median_abs_dev();\n-            let samples = do vec::filter(samples) |f| {\n+            let samples = do samples.consume_iter().filter |f| {\n                 num::abs(*f - med) <= 3.0 * mad\n-            };\n+            }.collect::<~[f64]>();\n \n             debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n                    n_samples, med as float, mad as float,"}, {"sha": "69ff100784077f93c323b9fb1ec16d3cd7659473", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -1046,7 +1046,7 @@ pub unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n     // ipv4 addr max size: 15 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                      0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n+    do dst.as_imm_buf |dst_buf, size| {\n         rust_uv_ip4_name(to_unsafe_ptr(src),\n                                  dst_buf, size as libc::size_t);\n         // seems that checking the result of uv_ip4_name\n@@ -1066,7 +1066,7 @@ pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n+    do dst.as_imm_buf |dst_buf, size| {\n         let src_unsafe_ptr = to_unsafe_ptr(src);\n         let result = rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);"}, {"sha": "a7abc619080385849c3bd66e7aef756ca0e7c058", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -893,7 +893,7 @@ pub fn link_args(sess: Session,\n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n         let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n-        do vec::consume(link_args) |_, link_arg| {\n+        for link_args.consume_iter().advance |link_arg| {\n             args.push(link_arg);\n         }\n     }"}, {"sha": "3c50754744886c820d55e6fd323f7211c07841d6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -123,10 +123,10 @@ pub fn build_configuration(sess: Session, argv0: @str, input: &input) ->\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::crate_cfg {\n-    do vec::map_consume(cfgspecs) |s| {\n+    do cfgspecs.consume_iter().transform |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n         parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n-    }\n+    }.collect()\n }\n \n pub enum input {"}, {"sha": "7d478afee41a1bf85b41be7b6f723cdf5319f453", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -10,7 +10,6 @@\n \n \n use std::option;\n-use std::vec;\n use syntax::{ast, fold, attr};\n \n type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n@@ -61,13 +60,15 @@ fn filter_view_item(cx: @Context, view_item: @ast::view_item\n }\n \n fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n-    let filtered_items =\n-        m.items.filter_mapped(|a| filter_item(cx, *a));\n-    let filtered_view_items =\n-        m.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_items = do  m.items.iter().filter_map |a| {\n+        filter_item(cx, *a).chain(|x| fld.fold_item(x))\n+    }.collect();\n+    let filtered_view_items = do m.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+    }.collect();\n     ast::_mod {\n-        view_items: filtered_view_items.map(|x| fld.fold_view_item(*x)),\n-        items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n+        view_items: filtered_view_items,\n+        items: filtered_items\n     }\n }\n \n@@ -83,14 +84,14 @@ fn fold_foreign_mod(\n     nm: &ast::foreign_mod,\n     fld: @fold::ast_fold\n ) -> ast::foreign_mod {\n-    let filtered_items =\n-        nm.items.filter_mapped(|a| filter_foreign_item(cx, *a));\n-    let filtered_view_items =\n-        nm.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_items = nm.items.iter().filter_map(|a| filter_foreign_item(cx, *a)).collect();\n+    let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+    }.collect();\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: filtered_view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        view_items: filtered_view_items,\n         items: filtered_items\n     }\n }\n@@ -99,11 +100,13 @@ fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: @fold::ast_fold) -> ast::item_ {\n     let item = match *item {\n         ast::item_impl(ref a, b, c, ref methods) => {\n-            let methods = methods.filtered(|m| method_in_cfg(cx, *m) );\n+            let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n+                .transform(|x| *x).collect();\n             ast::item_impl(/*bad*/ copy *a, b, c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n-            let methods = methods.filtered(|m| trait_method_in_cfg(cx, m) );\n+            let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )\n+                .transform(|x| /* bad */copy *x).collect();\n             ast::item_trait(/*bad*/copy *a, /*bad*/copy *b, methods)\n         }\n         ref item => /*bad*/ copy *item\n@@ -134,19 +137,12 @@ fn fold_block(\n     b: &ast::blk_,\n     fld: @fold::ast_fold\n ) -> ast::blk_ {\n-    let filtered_stmts =\n-        b.stmts.filter_mapped(|a| filter_stmt(cx, *a));\n-    let filtered_view_items =\n-        b.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n-    let filtered_view_items =\n-        filtered_view_items.map(|x| fld.fold_view_item(*x));\n-    let mut resulting_stmts = ~[];\n-    for filtered_stmts.iter().advance |stmt| {\n-        match fld.fold_stmt(*stmt) {\n-            None => {}\n-            Some(stmt) => resulting_stmts.push(stmt),\n-        }\n-    }\n+    let resulting_stmts = do b.stmts.iter().filter_map |a| {\n+        filter_stmt(cx, *a).chain(|stmt| fld.fold_stmt(stmt))\n+    }.collect();\n+    let filtered_view_items = do b.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+    }.collect();\n     ast::blk_ {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,\n@@ -193,7 +189,9 @@ pub fn metas_in_cfg(cfg: &[@ast::meta_item],\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let cfg_metas = vec::filter_map(cfg_metas, |i| attr::get_meta_item_list(i));\n+    let cfg_metas = cfg_metas.consume_iter()\n+        .filter_map(|i| attr::get_meta_item_list(i))\n+        .collect::<~[~[@ast::meta_item]]>();\n \n     if cfg_metas.iter().all(|c| c.is_empty()) { return true; }\n "}, {"sha": "91000d68aad09be29aca378f16efecca3346266f", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -109,9 +109,11 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n-            @ast::item{attrs: item.attrs.filtered(|attr| {\n-                               \"main\" != attr::get_attr_name(attr)\n-                           }),.. copy *item}\n+            @ast::item{\n+                attrs: do item.attrs.iter().filter_map |attr| {\n+                    if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+                }.collect(),\n+                .. copy *item}\n         } else { item }\n     }\n \n@@ -229,10 +231,10 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     return if !ignoreitems.is_empty() {\n-        let cfg_metas =\n-            vec::concat(\n-                vec::filter_map(ignoreitems,\n-                                |i| attr::get_meta_item_list(i)));\n+        let cfg_metas = ignoreitems.consume_iter()\n+            .filter_map(|i| attr::get_meta_item_list(i))\n+            .collect::<~[~[@ast::meta_item]]>()\n+            .concat_vec();\n         config::metas_in_cfg(/*bad*/copy cx.crate.node.config, cfg_metas)\n     } else {\n         false"}, {"sha": "72b6f8e1c805bd00e1e0ed6b67ca1936aa40b43d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -291,16 +291,16 @@ fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n // inlined items.\n fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: &ast::blk_, fld: @fold::ast_fold) -> ast::blk_ {\n-        let stmts_sans_items = do blk.stmts.filtered |stmt| {\n+        let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n-                                             span: _}, _) => true,\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_),\n-                                             span: _}, _) => false,\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_), span: _}, _)\n+                => Some(*stmt),\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_), span: _}, _)\n+                => None,\n               ast::stmt_mac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n-        };\n+        }.collect();\n         let blk_sans_items = ast::blk_ {\n             view_items: ~[], // I don't know if we need the view_items here,\n                              // but it doesn't break tests!"}, {"sha": "740499bbf25e6cd26f218dd24afb785a8672b678", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -95,7 +95,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n+       let arms = arms.iter().filter_map(unguarded_pat).collect::<~[~[@pat]]>().concat_vec();\n        if arms.is_empty() {\n            cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n@@ -265,7 +265,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n           }\n           Some(ref ctor) => {\n             match is_useful(cx,\n-                            &m.filter_mapped(|r| default(cx, *r)),\n+                            &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n                             v.tail()) {\n               useful_ => useful(left_ty, /*bad*/copy *ctor),\n               ref u => (/*bad*/copy *u)\n@@ -287,7 +287,7 @@ pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = m.filter_mapped(|r| specialize(cx, *r, &ctor, arity, lty));\n+    let ms = m.iter().filter_map(|r| specialize(cx, *r, &ctor, arity, lty)).collect::<matrix>();\n     let could_be_useful = is_useful(\n         cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n     match could_be_useful {\n@@ -397,14 +397,14 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and slices of all vector patterns.\n-        let vec_pat_lens = do m.filter_mapped |r| {\n+        let vec_pat_lens = do m.iter().filter_map |r| {\n             match r[0].node {\n                 pat_vec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n             }\n-        };\n+        }.collect::<~[(uint, bool)]>();\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first."}, {"sha": "ce9ab790b11b822a4f21bb61d170fc5ea0799923", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -24,7 +24,6 @@ use std::u16;\n use std::u32;\n use std::u64;\n use std::u8;\n-use std::vec;\n use extra::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n@@ -987,7 +986,7 @@ fn lint_session() -> visit::vt<@mut Context> {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},\n             Some(l) => {\n-                do vec::consume(l) |_, (lint, span, msg)| {\n+                for l.consume_iter().advance |(lint, span, msg)| {\n                     cx.span_lint(lint, span, msg)\n                 }\n             }"}, {"sha": "8e25f598f365ffc26ca277e3ed6295810e3e853c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -41,7 +41,6 @@ use syntax::opt_vec::OptVec;\n \n use std::str;\n use std::uint;\n-use std::vec;\n use std::hashmap::{HashMap, HashSet};\n use std::util;\n \n@@ -5362,7 +5361,7 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(vec::reversed(idents));\n+        return self.idents_to_str(idents.consume_rev_iter().collect::<~[ast::ident]>());\n     }\n \n     pub fn dump_module(@mut self, module_: @mut Module) {"}, {"sha": "4755f7629511e84d6eab8773f5c023b5cc1c8070", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -131,13 +131,13 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let ftys = do fields.map |field| {\n+            let mut ftys = do fields.map |field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n             };\n             let packed = ty::lookup_packed(cx.tcx, def_id);\n             let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n-            let ftys =\n-                if dtor { ftys + [ty::mk_bool()] } else { ftys };\n+            if dtor { ftys.push(ty::mk_bool()); }\n+\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n@@ -263,7 +263,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             let padding = largest_size - most_aligned.size;\n \n             struct_llfields(cx, most_aligned, sizing)\n-                + [Type::array(&Type::i8(), padding)]\n+                + &[Type::array(&Type::i8(), padding)]\n         }\n     }\n }\n@@ -512,7 +512,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n             let discr_ty = C_int(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n-            C_struct(contents + [padding(max_sz - case.size)])\n+            C_struct(contents + &[padding(max_sz - case.size)])\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr == nndiscr {"}, {"sha": "811138c6dbddfb0110213e4f3cc01d2cb2eac6fc", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -565,7 +565,7 @@ pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n         let min = llvm::LLVMConstInt(t, lo, signed);\n         let max = llvm::LLVMConstInt(t, hi, signed);\n \n-        do vec::as_imm_buf([min, max]) |ptr, len| {\n+        do [min, max].as_imm_buf |ptr, len| {\n             llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(cx.fcx.ccx.llcx,\n                                                             ptr, len as c_uint));\n@@ -942,7 +942,7 @@ pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n                cx.val_to_str(Fn),\n                Args.map(|arg| cx.val_to_str(*arg)));\n \n-        do vec::as_imm_buf(Args) |ptr, len| {\n+        do Args.as_imm_buf |ptr, len| {\n             llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())\n         }\n     }"}, {"sha": "865fb26b94558da93879e0e8596268170fc7dbfb", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -774,23 +774,23 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n \n pub fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, False)\n         }\n     }\n }\n \n pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, True)\n         }\n     }\n }\n \n pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n         }\n     }\n@@ -826,7 +826,7 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n-        let r = do vec::as_imm_buf(us) |p, len| {\n+        let r = do us.as_imm_buf |p, len| {\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n         };\n "}, {"sha": "75b1830778b1bd9d81c88c6a245baff744f82733", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -26,7 +26,6 @@ use util::ppaux;\n use middle::trans::type_::Type;\n \n use std::str;\n-use std::vec;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_map::path_mod;\n@@ -190,9 +189,13 @@ pub fn trans_log(log_ex: &ast::expr,\n \n     let (modpath, modname) = {\n         let path = &mut bcx.fcx.path;\n-        let modpath = vec::append(\n-            ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n-            path.filtered(|e| match *e { path_mod(_) => true, _ => false }));\n+        let mut modpath = ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))];\n+        for path.iter().advance |e| {\n+            match *e {\n+                path_mod(_) => { modpath.push(*e) }\n+                _ => {}\n+            }\n+        }\n         let modname = path_str(ccx.sess, modpath);\n         (modpath, modname)\n     };"}, {"sha": "0a3b6d881e47c6d0d4e0acc08caa9956caf53894", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -113,7 +113,7 @@ fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n-    let bundle_ty = Type::struct_(llsig.llarg_tys + [llsig.llret_ty.ptr_to()], false);\n+    let bundle_ty = Type::struct_(llsig.llarg_tys + &[llsig.llret_ty.ptr_to()], false);\n     let ret_def = !ty::type_is_bot(fn_sig.output) &&\n                   !ty::type_is_nil(fn_sig.output);\n     let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys, llsig.llret_ty, ret_def);"}, {"sha": "04133bfe79acb4eeab54ad9893e27f8aaaa4d741", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -278,7 +278,7 @@ impl Reflector {\n             let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n \n             let make_get_disr = || {\n-                let sub_path = bcx.fcx.path + [path_name(special_idents::anon)];\n+                let sub_path = bcx.fcx.path + &[path_name(special_idents::anon)];\n                 let sym = mangle_internal_name_by_path_and_seq(ccx,\n                                                                sub_path,\n                                                                \"get_disr\");"}, {"sha": "7878e17f7fc689f5d242ae6b81a468b4b39586b9", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -245,7 +245,7 @@ impl Type {\n     }\n \n     pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::struct_(Type::box_header_fields(ctx) + [*ty], false)\n+        Type::struct_(Type::box_header_fields(ctx) + &[*ty], false)\n     }\n \n     pub fn opaque_box(ctx: &CrateContext) -> Type {"}, {"sha": "0681cf867f13a322004ad03585cea727069353fd", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -45,9 +45,9 @@ pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n-    let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n-        attr::get_meta_item_value_str(*meta).map(|s| s.to_owned())\n-    };\n+    let doc_strs = do doc_metas(attrs).consume_iter().filter_map |meta| {\n+        attr::get_meta_item_value_str(meta).map(|s| s.to_owned())\n+    }.collect::<~[~str]>();\n     if doc_strs.is_empty() {\n         None\n     } else {"}, {"sha": "3fd6ad1699876346deb79da4c8d7530ae1956b71", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -141,7 +141,7 @@ fn first_sentence_(s: &str) -> ~str {\n pub fn paragraphs(s: &str) -> ~[~str] {\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do s.any_line_iter().fold(~[]) |paras, line| {\n+    let mut paras = do s.any_line_iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if line.is_whitespace() {\n@@ -166,11 +166,8 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n         res\n     };\n \n-    if !accum.is_empty() {\n-        paras + [accum]\n-    } else {\n-        paras\n-    }\n+    if !accum.is_empty() { paras.push(accum); }\n+    paras\n }\n \n #[cfg(test)]"}, {"sha": "ffb4642be8107dcd8509a25e0cfb9ba19eb1ded3", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 39, "deletions": 104, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -13,8 +13,6 @@\n \n use doc;\n \n-use std::vec;\n-\n pub type AstId = int;\n \n #[deriving(Eq)]\n@@ -186,87 +184,64 @@ impl Doc {\n     }\n }\n \n+macro_rules! filt_mapper {\n+    ($vec:expr, $pat:pat) => {\n+        do ($vec).iter().filter_map |thing| {\n+            match thing {\n+                &$pat => Some(copy *x),\n+                _ => None\n+            }\n+        }.collect()\n+    }\n+}\n+\n+macro_rules! md {\n+    ($id:ident) => {\n+        filt_mapper!(self.items, $id(ref x))\n+    }\n+}\n /// Some helper methods on ModDoc, mostly for testing\n impl ModDoc {\n     pub fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ModTag(ModDoc) => Some(ModDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ModTag)\n     }\n \n     pub fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              NmodTag(nModDoc) => Some(nModDoc),\n-              _ => None\n-            }\n-        }\n+        md!(NmodTag)\n     }\n \n     pub fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              FnTag(FnDoc) => Some(FnDoc),\n-              _ => None\n-            }\n-        }\n+        md!(FnTag)\n     }\n \n     pub fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ConstTag(ConstDoc) => Some(ConstDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ConstTag)\n     }\n \n     pub fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              EnumTag(EnumDoc) => Some(EnumDoc),\n-              _ => None\n-            }\n-        }\n+        md!(EnumTag)\n     }\n \n     pub fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              TraitTag(TraitDoc) => Some(TraitDoc),\n-              _ => None\n-            }\n-        }\n+        md!(TraitTag)\n     }\n \n     pub fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ImplTag(ImplDoc) => Some(ImplDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ImplTag)\n     }\n \n     pub fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              TyTag(TyDoc) => Some(TyDoc),\n-              _ => None\n-            }\n-        }\n+        md!(TyTag)\n     }\n \n     pub fn structs(&self) -> ~[StructDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-                StructTag(StructDoc) => Some(StructDoc),\n-                _ => None\n-            }\n-        }\n+        md!(StructTag)\n+    }\n+}\n+\n+macro_rules! pu {\n+    ($id:ident) => {\n+        filt_mapper!(*self, ItemPage($id(ref x)))\n     }\n }\n \n@@ -284,75 +259,35 @@ pub trait PageUtils {\n impl PageUtils for ~[Page] {\n \n     fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ModTag(ModDoc)) => Some(ModDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ModTag)\n     }\n \n     fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(NmodTag(nModDoc)) => Some(nModDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(NmodTag)\n     }\n \n     fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(FnTag(FnDoc)) => Some(FnDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(FnTag)\n     }\n \n     fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ConstTag(ConstDoc)) => Some(ConstDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ConstTag)\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(EnumTag(EnumDoc)) => Some(EnumDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(EnumTag)\n     }\n \n     fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(TraitTag(TraitDoc)) => Some(TraitDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(TraitTag)\n     }\n \n     fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ImplTag(ImplDoc)) => Some(ImplDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ImplTag)\n     }\n \n     fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(TyTag(TyDoc)) => Some(TyDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(TyTag)\n     }\n }\n "}, {"sha": "01b77a985fedb249a28d456f01dfe3a02ff6557f", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -15,7 +15,6 @@ use astsrv;\n use doc::ItemUtils;\n use doc;\n \n-use std::vec;\n use syntax::ast;\n use syntax::parse::token::{ident_interner, ident_to_str};\n use syntax::parse::token;\n@@ -83,7 +82,7 @@ fn moddoc_from_mod(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: itemdoc,\n-        items: do vec::filter_mapped(module_.items) |item| {\n+        items: do module_.items.iter().filter_map |item| {\n             let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n             match copy item.node {\n               ast::item_mod(m) => {\n@@ -133,7 +132,7 @@ fn moddoc_from_mod(\n               }\n               _ => None\n             }\n-        },\n+        }.collect(),\n         index: None\n     }\n }"}, {"sha": "f800a8ab946fe35e6e778b08c285f0a148f79740", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -172,7 +172,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n }\n \n pub fn header_name(doc: doc::ItemTag) -> ~str {\n-    let fullpath = (doc.path() + [doc.name()]).connect(\"::\");\n+    let fullpath = (doc.path() + &[doc.name()]).connect(\"::\");\n     match &doc {\n         &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n             fullpath"}, {"sha": "d757547d8f76f59332c1cf8464c388ec48f01dee", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -163,7 +163,7 @@ pub fn make_filename(\n             }\n           }\n           doc::ItemPage(doc) => {\n-            (doc.path() + [doc.name()]).connect(\"_\")\n+            (doc.path() + &[doc.name()]).connect(\"_\")\n           }\n         }\n     };"}, {"sha": "83a0d44978ec49c96b84dc3596edbcdb61686cae", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -128,13 +128,12 @@ fn fold_mod(\n \n fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n     doc::ModDoc {\n-        items: do doc.items.filtered |item| {\n-            match *item {\n-              doc::ModTag(_) => false,\n-              doc::NmodTag(_) => false,\n+        items: do doc.items.iter().filter |item| {\n+            match **item {\n+              doc::ModTag(_) | doc::NmodTag(_) => false,\n               _ => true\n             }\n-        },\n+        }.transform(|x| copy *x).collect::<~[doc::ItemTag]>(),\n         .. copy doc\n     }\n }"}, {"sha": "96c5df10680cc51ca8f214d68ec6f92f84f64056", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -41,9 +41,9 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     doc::ModDoc {\n-        items: do doc.items.filtered |ItemTag| {\n-            !is_hidden(fold.ctxt.clone(), ItemTag.item())\n-        },\n+        items: do doc.items.iter().filter |item_tag| {\n+            !is_hidden(fold.ctxt.clone(), item_tag.item())\n+        }.transform(|x| copy *x).collect(),\n         .. doc\n     }\n }"}, {"sha": "aeb6e02f244f175055f9f9516d4e1006bfcbc853", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -80,7 +80,7 @@ fn strip_priv_methods(\n     methods: &[@ast::method],\n     item_vis: ast::visibility\n ) -> doc::ImplDoc {\n-    let methods = do (&doc.methods).filtered |method| {\n+    let methods = do doc.methods.iter().filter |method| {\n         let ast_method = do methods.iter().find_ |m| {\n             extract::to_str(m.ident) == method.name\n         };\n@@ -91,7 +91,7 @@ fn strip_priv_methods(\n             ast::private => false,\n             ast::inherited => item_vis == ast::public\n         }\n-    };\n+    }.transform(|x| copy *x).collect();\n \n     doc::ImplDoc {\n         methods: methods,\n@@ -106,9 +106,9 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     doc::ModDoc {\n-        items: doc.items.filtered(|ItemTag| {\n-            match ItemTag {\n-                &doc::ImplTag(ref doc) => {\n+        items: doc.items.iter().filter(|item_tag| {\n+            match item_tag {\n+                & &doc::ImplTag(ref doc) => {\n                     if doc.trait_types.is_empty() {\n                         // This is an associated impl. We have already pruned the\n                         // non-visible methods. If there are any left then\n@@ -123,10 +123,10 @@ fn fold_mod(\n                     }\n                 }\n                 _ => {\n-                    is_visible(fold.ctxt.clone(), ItemTag.item())\n+                    is_visible(fold.ctxt.clone(), item_tag.item())\n                 }\n             }\n-        }),\n+        }).transform(|x| copy *x).collect(),\n         .. doc\n     }\n }"}, {"sha": "1e99a3fa4bcda2f68ae593a4607d55f18696ef93", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -77,9 +77,9 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n             fold: @fold::ast_fold) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n-            attrs: do item.attrs.filtered |attr| {\n-                \"main\" != attr::get_attr_name(attr)\n-            },\n+            attrs: do item.attrs.iter().filter_map |attr| {\n+                if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+            }.collect(),\n             .. copy *item\n         }\n     }"}, {"sha": "5876dbdc9dea13823124cef251901c6857375a72", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -34,6 +34,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n }\n \n pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n-    rust_path().filtered(|ws|\n-        workspace_contains_package_id(pkgid, ws))\n+    rust_path().consume_iter()\n+        .filter(|ws| workspace_contains_package_id(pkgid, ws))\n+        .collect()\n }"}, {"sha": "37a32d6b0f0081ba289b8e1aa0f6911a802e4af6", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -17,8 +17,7 @@ use kinds::Copy;\n use option::Option;\n use sys;\n use uint;\n-use vec;\n-use vec::ImmutableVector;\n+use vec::{ImmutableVector, OwnedVector};\n \n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n@@ -159,7 +158,7 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n     let mut av = @[];\n     unsafe {\n         raw::reserve(&mut av, v.len());\n-        do vec::consume(v) |_i, x| {\n+        for v.consume_iter().advance |x| {\n             raw::push(&mut av, x);\n         }\n         transmute(av)\n@@ -177,13 +176,14 @@ pub fn to_managed<T:Copy>(v: &[T]) -> @[T] {\n #[cfg(not(test))]\n pub mod traits {\n     use at_vec::append;\n+    use vec::Vector;\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<'self,T:Copy> Add<&'self [T],@[T]> for @[T] {\n+    impl<'self,T:Copy, V: Vector<T>> Add<V,@[T]> for @[T] {\n         #[inline]\n-        fn add(&self, rhs: & &'self [T]) -> @[T] {\n-            append(*self, (*rhs))\n+        fn add(&self, rhs: &V) -> @[T] {\n+            append(*self, rhs.as_slice())\n         }\n     }\n }\n@@ -313,7 +313,7 @@ mod test {\n \n     #[test]\n     fn append_test() {\n-        assert_eq!(@[1,2,3] + [4,5,6], @[1,2,3,4,5,6]);\n+        assert_eq!(@[1,2,3] + &[4,5,6], @[1,2,3,4,5,6]);\n     }\n \n     #[test]"}, {"sha": "8b9b3102831c6c55da53acb6851b126a1dbe17d3", "filename": "src/libstd/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -73,7 +73,7 @@ pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n-    do vec::consume(eithers) |_i, elt| {\n+    for eithers.consume_iter().advance |elt| {\n         match elt {\n             Left(l) => lefts.push(l),\n             Right(r) => rights.push(r)"}, {"sha": "2d80dc2be152d094fc56b3761bd1d09b613d78c9", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -24,7 +24,7 @@ use rand::RngUtil;\n use rand;\n use uint;\n use vec;\n-use vec::{ImmutableVector, MutableVector};\n+use vec::{ImmutableVector, MutableVector, OwnedVector};\n use kinds::Copy;\n use util::{replace, unreachable};\n \n@@ -175,7 +175,8 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                   vec::from_fn(new_capacity, |_| None));\n \n         self.size = 0;\n-        do vec::consume(old_buckets) |_, bucket| {\n+        // consume_rev_iter is more efficient\n+        for old_buckets.consume_rev_iter().advance |bucket| {\n             self.insert_opt_bucket(bucket);\n         }\n     }\n@@ -441,7 +442,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n                               vec::from_fn(INITIAL_CAPACITY, |_| None));\n         self.size = 0;\n \n-        do vec::consume(buckets) |_, bucket| {\n+        for buckets.consume_iter().advance |bucket| {\n             match bucket {\n                 None => {},\n                 Some(Bucket{key, value, _}) => {"}, {"sha": "38826dd411b681f7653c08321123051abd501297", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -917,7 +917,7 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n-            do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n+            do bytes.as_mut_buf |buf_p, buf_len| {\n                 assert!(buf_len >= len);\n \n                 let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n@@ -1152,7 +1152,7 @@ impl<W:Writer,C> Writer for Wrapper<W, C> {\n impl Writer for *libc::FILE {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n-            do vec::as_imm_buf(v) |vbuf, len| {\n+            do v.as_imm_buf |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n                                         1,\n                                         len as size_t,\n@@ -1203,7 +1203,7 @@ impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n             let mut count = 0u;\n-            do vec::as_imm_buf(v) |vbuf, len| {\n+            do v.as_imm_buf |vbuf, len| {\n                 while count < len {\n                     let vb = ptr::offset(vbuf, count) as *c_void;\n                     let nout = libc::write(*self, vb, len as size_t);"}, {"sha": "be0c504885b312906d377a5bc0ed7144abdfee40", "filename": "src/libstd/os.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -92,7 +92,7 @@ pub fn as_c_charp<T>(s: &str, f: &fn(*c_char) -> T) -> T {\n pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n     let mut buf = vec::from_elem(TMPBUF_SZ, 0u8 as c_char);\n-    do vec::as_mut_buf(buf) |b, sz| {\n+    do buf.as_mut_buf |b, sz| {\n         if f(b, sz as size_t) {\n             unsafe {\n                 Some(str::raw::from_buf(b as *u8))\n@@ -122,7 +122,7 @@ pub mod win32 {\n             while !done {\n                 let mut k: DWORD = 0;\n                 let mut buf = vec::from_elem(n as uint, 0u16);\n-                do vec::as_mut_buf(buf) |b, _sz| {\n+                do buf.as_mut_buf |b, _sz| {\n                     k = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n                         done = true;\n@@ -147,7 +147,7 @@ pub mod win32 {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t.push(0u16);\n-        vec::as_imm_buf(t, |buf, _len| f(buf))\n+        t.as_imm_buf(|buf, _len| f(buf))\n     }\n }\n \n@@ -777,9 +777,9 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 strings\n             }\n         }\n-        do get_list(p).filtered |filename| {\n-            *filename != ~\".\" && *filename != ~\"..\"\n-        }\n+        do get_list(p).consume_iter().filter |filename| {\n+            \".\" != *filename && \"..\" != *filename\n+        }.collect()\n     }\n }\n \n@@ -937,7 +937,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             let mut done = false;\n             let mut ok = true;\n             while !done {\n-                do vec::as_mut_buf(buf) |b, _sz| {\n+                do buf.as_mut_buf |b, _sz| {\n                   let nread = libc::fread(b as *mut c_void, 1u as size_t,\n                                           bufsize as size_t,\n                                           istream);\n@@ -1683,7 +1683,7 @@ mod tests {\n           let s = ~\"hello\";\n           let mut buf = s.as_bytes_with_null().to_owned();\n           let len = buf.len();\n-          do vec::as_mut_buf(buf) |b, _len| {\n+          do buf.as_mut_buf |b, _len| {\n               assert_eq!(libc::fwrite(b as *c_void, 1u as size_t,\n                                       (s.len() + 1u) as size_t, ostream),\n                          len as size_t)"}, {"sha": "db534cca971a58dc2a8ad867fff2de13b029f677", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -72,7 +72,7 @@ pub use tuple::{CloneableTuple10, CloneableTuple11, CloneableTuple12};\n pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTuple5};\n pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n-pub use vec::{VectorVector, CopyableVector, ImmutableVector};\n+pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};"}, {"sha": "aee6f1bd204e3a6070d06d5013ffac9b74943f21", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -406,7 +406,7 @@ pub mod ptr_tests {\n             do str::as_c_str(s1) |p1| {\n                 do str::as_c_str(s2) |p2| {\n                     let v = ~[p0, p1, p2, null()];\n-                    do vec::as_imm_buf(v) |vp, len| {\n+                    do v.as_imm_buf |vp, len| {\n                         assert_eq!(unsafe { buf_len(vp) }, 3u);\n                         assert_eq!(len, 4u);\n                     }"}, {"sha": "5054763d742b05cf3e1f7a66bc005ebd0660d336", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -830,7 +830,7 @@ pub fn seed() -> ~[u8] {\n     unsafe {\n         let n = rustrt::rand_seed_size() as uint;\n         let mut s = vec::from_elem(n, 0_u8);\n-        do vec::as_mut_buf(s) |p, sz| {\n+        do s.as_mut_buf |p, sz| {\n             rustrt::rand_gen_seed(p, sz as size_t)\n         }\n         s\n@@ -1087,7 +1087,7 @@ mod tests {\n         for 10.times {\n             unsafe {\n                 let seed = super::seed();\n-                let rt_rng = do vec::as_imm_buf(seed) |p, sz| {\n+                let rt_rng = do seed.as_imm_buf |p, sz| {\n                     rustrt::rand_new_seeded(p, sz as size_t)\n                 };\n                 let mut rng = IsaacRng::new_seeded(seed);"}, {"sha": "092d736620268db78c049814d6a297fc4d30a103", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -40,6 +40,7 @@ use str::raw::from_c_str;\n use to_str::ToStr;\n use ptr::RawPtr;\n use vec;\n+use vec::ImmutableVector;\n use ptr;\n use str;\n use libc::{c_void, c_int, size_t, malloc, free};\n@@ -300,7 +301,7 @@ pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n     unsafe {\n         let data = malloc(v.len() as size_t) as *u8;\n         assert!(data.is_not_null());\n-        do vec::as_imm_buf(v) |b, l| {\n+        do v.as_imm_buf |b, l| {\n             let data = data as *mut u8;\n             ptr::copy_memory(data, b, l)\n         }"}, {"sha": "df15111a91f4287940f2824dff39fcdf33ed9f4e", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -24,7 +24,7 @@ use prelude::*;\n use ptr;\n use str;\n use task;\n-use vec;\n+use vec::ImmutableVector;\n \n /**\n  * A value representing a child process.\n@@ -703,7 +703,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n         argptrs.push(str::as_c_str(*t, |b| b));\n     }\n     argptrs.push(ptr::null());\n-    vec::as_imm_buf(argptrs, |buf, _len| cb(buf))\n+    argptrs.as_imm_buf(|buf, _len| cb(buf))\n }\n \n #[cfg(unix)]\n@@ -722,7 +722,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n         }\n \n         ptrs.push(ptr::null());\n-        vec::as_imm_buf(ptrs, |p, _len|\n+        ptrs.as_imm_buf(|p, _len|\n             unsafe { cb(::cast::transmute(p)) }\n         )\n       }\n@@ -743,7 +743,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n             blk.push_all(kv.as_bytes_with_null_consume());\n         }\n         blk.push(0);\n-        vec::as_imm_buf(blk, |p, _len|\n+        blk.as_imm_buf(|p, _len|\n             unsafe { cb(::cast::transmute(p)) }\n         )\n       }"}, {"sha": "564c58f7097ee90080eaa8e7d605709c02591f76", "filename": "src/libstd/str.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -826,6 +826,7 @@ pub mod raw {\n     use str::raw;\n     use str::{as_buf, is_utf8};\n     use vec;\n+    use vec::MutableVector;\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n     pub unsafe fn from_buf(buf: *u8) -> ~str {\n@@ -841,7 +842,7 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n-        vec::as_mut_buf(v, |vbuf, _len| {\n+        v.as_mut_buf(|vbuf, _len| {\n             ptr::copy_memory(vbuf, buf as *u8, len)\n         });\n         vec::raw::set_len(&mut v, len);\n@@ -863,7 +864,7 @@ pub mod raw {\n \n     /// Converts a vector of bytes to a new owned string.\n     pub unsafe fn from_bytes(v: &[u8]) -> ~str {\n-        do vec::as_imm_buf(v) |buf, len| {\n+        do v.as_imm_buf |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }\n@@ -917,7 +918,7 @@ pub mod raw {\n             assert!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n-            do vec::as_imm_buf(v) |vbuf, _vlen| {\n+            do v.as_imm_buf |vbuf, _vlen| {\n                 let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n                 let src = ptr::offset(sbuf, begin);\n                 ptr::copy_memory(vbuf, src, end - begin);"}, {"sha": "fb9c47b43733b1db42bc766d7e87122638ae1853", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 575, "deletions": 878, "changes": 1453, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -16,14 +16,13 @@ use cast::transmute;\n use cast;\n use container::{Container, Mutable};\n use cmp;\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Eq, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n use kinds::Copy;\n use libc;\n use libc::c_void;\n use num::Zero;\n-use ops::Add;\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n@@ -40,8 +39,6 @@ use unstable::intrinsics::{get_tydesc, contains_managed};\n use vec;\n use util;\n \n-#[cfg(not(test))] use cmp::Equiv;\n-\n #[doc(hidden)]\n pub mod rustrt {\n     use libc;\n@@ -74,7 +71,7 @@ pub fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let mut i: uint = 0u;\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n@@ -99,7 +96,7 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     // vec::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let mut i = 0u;\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), copy t);\n@@ -176,165 +173,69 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n     build_sized(size.get_or_default(4), builder)\n }\n \n-// Accessors\n-\n-/// Copies\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function.\n+pub struct VecSplitIterator<'self, T> {\n+    priv v: &'self [T],\n+    priv n: uint,\n+    priv pred: &'self fn(t: &T) -> bool,\n+    priv finished: bool\n+}\n \n-/// Split the vector `v` by applying each element against the predicate `f`.\n-pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n+impl<'self, T> Iterator<&'self [T]> for VecSplitIterator<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.finished { return None; }\n \n-    let mut start = 0u;\n-    let mut result = ~[];\n-    while start < ln {\n-        match v.slice(start, ln).iter().position_(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(start, start + i).to_owned());\n-                start += i + 1u;\n-            }\n+        if self.n == 0 {\n+            self.finished = true;\n+            return Some(self.v);\n         }\n-    }\n-    result.push(v.slice(start, ln).to_owned());\n-    result\n-}\n \n-/**\n- * Split the vector `v` by applying each element against the predicate `f` up\n- * to `n` times.\n- */\n-pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n-\n-    let mut start = 0u;\n-    let mut count = n;\n-    let mut result = ~[];\n-    while start < ln && count > 0u {\n-        match v.slice(start, ln).iter().position_(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(start, start + i).to_owned());\n-                // Make sure to skip the separator.\n-                start += i + 1u;\n-                count -= 1u;\n+        match self.v.iter().position_(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n+                self.n -= 1;\n+                ret\n             }\n         }\n     }\n-    result.push(v.slice(start, ln).to_owned());\n-    result\n }\n \n-/**\n- * Reverse split the vector `v` by applying each element against the predicate\n- * `f`.\n- */\n-pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0) { return ~[] }\n-\n-    let mut end = ln;\n-    let mut result = ~[];\n-    while end > 0 {\n-        match v.slice(0, end).rposition(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(i + 1, end).to_owned());\n-                end = i;\n-            }\n-        }\n-    }\n-    result.push(v.slice(0u, end).to_owned());\n-    result.reverse();\n-    result\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, from back to front.\n+pub struct VecRSplitIterator<'self, T> {\n+    priv v: &'self [T],\n+    priv n: uint,\n+    priv pred: &'self fn(t: &T) -> bool,\n+    priv finished: bool\n }\n \n-/**\n- * Reverse split the vector `v` by applying each element against the predicate\n- * `f` up to `n times.\n- */\n-pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n+impl<'self, T> Iterator<&'self [T]> for VecRSplitIterator<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.finished { return None; }\n \n-    let mut end = ln;\n-    let mut count = n;\n-    let mut result = ~[];\n-    while end > 0u && count > 0u {\n-        match v.slice(0, end).rposition(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(i + 1u, end).to_owned());\n-                // Make sure to skip the separator.\n-                end = i;\n-                count -= 1u;\n-            }\n+        if self.n == 0 {\n+            self.finished = true;\n+            return Some(self.v);\n         }\n-    }\n-    result.push(v.slice(0u, end).to_owned());\n-    result.reverse();\n-    result\n-}\n \n-/// Consumes all elements, in a vector, moving them out into the / closure\n-/// provided. The vector is traversed from the start to the end.\n-///\n-/// This method does not impose any requirements on the type of the vector being\n-/// consumed, but it prevents any usage of the vector after this function is\n-/// called.\n-///\n-/// # Examples\n-///\n-/// ~~~ {.rust}\n-/// let v = ~[~\"a\", ~\"b\"];\n-/// do vec::consume(v) |i, s| {\n-///   // s has type ~str, not &~str\n-///   io::println(s + fmt!(\" %d\", i));\n-/// }\n-/// ~~~\n-pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n-    unsafe {\n-        do as_mut_buf(v) |p, ln| {\n-            for uint::range(0, ln) |i| {\n-                // NB: This unsafe operation counts on init writing 0s to the\n-                // holes we create in the vector. That ensures that, if the\n-                // iterator fails then we won't try to clean up the consumed\n-                // elements during unwinding\n-                let x = intrinsics::init();\n-                let p = ptr::mut_offset(p, i);\n-                f(i, ptr::replace_ptr(p, x));\n+        match self.v.rposition(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n             }\n-        }\n-\n-        raw::set_len(&mut v, 0);\n-    }\n-}\n-\n-/// Consumes all elements, in a vector, moving them out into the / closure\n-/// provided. The vectors is traversed in reverse order (from end to start).\n-///\n-/// This method does not impose any requirements on the type of the vector being\n-/// consumed, but it prevents any usage of the vector after this function is\n-/// called.\n-pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n-    unsafe {\n-        do as_mut_buf(v) |p, ln| {\n-            let mut i = ln;\n-            while i > 0 {\n-                i -= 1;\n-\n-                // NB: This unsafe operation counts on init writing 0s to the\n-                // holes we create in the vector. That ensures that, if the\n-                // iterator fails then we won't try to clean up the consumed\n-                // elements during unwinding\n-                let x = intrinsics::init();\n-                let p = ptr::mut_offset(p, i);\n-                f(i, ptr::replace_ptr(p, x));\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n+                self.n -= 1;\n+                ret\n             }\n         }\n-\n-        raw::set_len(&mut v, 0);\n     }\n }\n \n@@ -360,20 +261,6 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n \n // Functional utilities\n \n-/// Consumes a vector, mapping it into a different vector. This function takes\n-/// ownership of the supplied vector `v`, moving each element into the closure\n-/// provided to generate a new element. The vector of new elements is then\n-/// returned.\n-///\n-/// The original vector `v` cannot be used after this function call (it is moved\n-/// inside), but there are no restrictions on the type of the vector.\n-pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n-    let mut result = ~[];\n-    do consume(v) |_i, x| {\n-        result.push(f(x));\n-    }\n-    result\n-}\n /**\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n@@ -384,79 +271,6 @@ pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     result\n }\n \n-pub fn filter_map<T, U>(\n-    v: ~[T],\n-    f: &fn(t: T) -> Option<U>) -> ~[U]\n-{\n-    /*!\n-     *\n-     * Apply a function to each element of a vector and return the results.\n-     * Consumes the input vector.  If function `f` returns `None` then that\n-     * element is excluded from the resulting vector.\n-     */\n-\n-    let mut result = ~[];\n-    do consume(v) |_, elem| {\n-        match f(elem) {\n-            None => {}\n-            Some(result_elem) => { result.push(result_elem); }\n-        }\n-    }\n-    result\n-}\n-\n-pub fn filter_mapped<T, U: Copy>(\n-    v: &[T],\n-    f: &fn(t: &T) -> Option<U>) -> ~[U]\n-{\n-    /*!\n-     *\n-     * Like `filter_map()`, but operates on a borrowed slice\n-     * and does not consume the input.\n-     */\n-\n-    let mut result = ~[];\n-    for v.iter().advance |elem| {\n-        match f(elem) {\n-          None => {/* no-op */ }\n-          Some(result_elem) => { result.push(result_elem); }\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Construct a new vector from the elements of a vector for which some\n- * predicate holds.\n- *\n- * Apply function `f` to each element of `v` and return a vector containing\n- * only those elements for which `f` returned true.\n- */\n-pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n-    let mut result = ~[];\n-    // FIXME (#4355 maybe): using v.consume here crashes\n-    // do v.consume |_, elem| {\n-    do consume(v) |_, elem| {\n-        if f(&elem) { result.push(elem); }\n-    }\n-    result\n-}\n-\n-/**\n- * Construct a new vector from the elements of a vector for which some\n- * predicate holds.\n- *\n- * Apply function `f` to each element of `v` and return a vector containing\n- * only those elements for which `f` returned true.\n- */\n-pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n-    let mut result = ~[];\n-    for v.iter().advance |elem| {\n-        if f(elem) { result.push(copy *elem); }\n-    }\n-    result\n-}\n-\n /// Flattens a vector of vectors of T into a single vector of T.\n pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] { v.concat_vec() }\n \n@@ -542,7 +356,7 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n-    do consume(v) |_i, p| {\n+    for v.consume_iter().advance |p| {\n         let (t, u) = p;\n         ts.push(t);\n         us.push(u);\n@@ -584,16 +398,6 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     w\n }\n \n-/// Returns a vector with the order of elements reversed\n-pub fn reversed<T:Copy>(v: &[T]) -> ~[T] {\n-    let mut rs: ~[T] = ~[];\n-    let mut i = v.len();\n-    if i == 0 { return (rs); } else { i -= 1; }\n-    while i != 0 { rs.push(copy v[i]); i -= 1; }\n-    rs.push(copy v[0]);\n-    rs\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -648,265 +452,236 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n     }\n }\n \n-/**\n- * Iterate over all contiguous windows of length `n` of the vector `v`.\n- *\n- * # Example\n- *\n- * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`, `[3,4]`)\n- *\n- * ~~~ {.rust}\n- * for windowed(2, &[1,2,3,4]) |v| {\n- *     io::println(fmt!(\"%?\", v));\n- * }\n- * ~~~\n- *\n- */\n-pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) -> bool {\n-    assert!(1u <= n);\n-    if n > v.len() { return true; }\n-    for uint::range(0, v.len() - n + 1) |i| {\n-        if !it(v.slice(i, i + n)) { return false; }\n-    }\n-    return true;\n+/// An iterator over the (overlapping) slices of length `size` within\n+/// a vector.\n+pub struct VecWindowIter<'self, T> {\n+    priv v: &'self [T],\n+    priv size: uint\n }\n \n-/**\n- * Work with the buffer of a vector.\n- *\n- * Allows for unsafe manipulation of vector contents, which is useful for\n- * foreign interop.\n- */\n-#[inline]\n-pub fn as_imm_buf<T,U>(s: &[T],\n-                       /* NB---this CANNOT be const, see below */\n-                       f: &fn(*T, uint) -> U) -> U {\n-\n-    // NB---Do not change the type of s to `&const [T]`.  This is\n-    // unsound.  The reason is that we are going to create immutable pointers\n-    // into `s` and pass them to `f()`, but in fact they are potentially\n-    // pointing at *mutable memory*.  Use `as_const_buf` or `as_mut_buf`\n-    // instead!\n-\n-    unsafe {\n-        let v : *(*T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n+impl<'self, T> Iterator<&'self [T]> for VecWindowIter<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n+            ret\n+        }\n     }\n }\n \n-/// Similar to `as_imm_buf` but passing a `*mut T`\n-#[inline]\n-pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n-    unsafe {\n-        let v : *(*mut T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n+/// An iterator over a vector in (non-overlapping) chunks (`size`\n+/// elements at a time).\n+pub struct VecChunkIter<'self, T> {\n+    priv v: &'self [T],\n+    priv size: uint\n+}\n+\n+impl<'self, T> Iterator<&'self [T]> for VecChunkIter<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.size == 0 {\n+            None\n+        } else if self.size >= self.v.len() {\n+            // finished\n+            self.size = 0;\n+            Some(self.v)\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(self.size, self.v.len());\n+            ret\n+        }\n     }\n }\n \n // Equality\n \n-/// Tests whether two slices are equal to one another. This is only true if both\n-/// slices are of the same length, and each of the corresponding elements return\n-/// true when queried via the `eq` function.\n-fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    if a_len != b_len { return false; }\n+#[cfg(not(test))]\n+pub mod traits {\n+    use super::Vector;\n+    use kinds::Copy;\n+    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equal, Equiv};\n+    use ops::Add;\n \n-    let mut i = 0;\n-    while i < a_len {\n-        if a[i] != b[i] { return false; }\n-        i += 1;\n+    impl<'self,T:Eq> Eq for &'self [T] {\n+        fn eq(&self, other: & &'self [T]) -> bool {\n+            self.len() == other.len() &&\n+                self.iter().zip(other.iter()).all(|(s,o)| *s == *o)\n+        }\n+        #[inline]\n+        fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n     }\n-    true\n-}\n-\n-/// Similar to the `vec::eq` function, but this is defined for types which\n-/// implement `TotalEq` as opposed to types which implement `Eq`. Equality\n-/// comparisons are done via the `equals` function instead of `eq`.\n-fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    if a_len != b_len { return false; }\n \n-    let mut i = 0;\n-    while i < a_len {\n-        if !a[i].equals(&b[i]) { return false; }\n-        i += 1;\n+    impl<T:Eq> Eq for ~[T] {\n+        #[inline]\n+        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n     }\n-    true\n-}\n-\n-#[cfg(not(test))]\n-impl<'self,T:Eq> Eq for &'self [T] {\n-    #[inline]\n-    fn eq(&self, other: & &'self [T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n-}\n \n-#[cfg(not(test))]\n-impl<T:Eq> Eq for ~[T] {\n-    #[inline]\n-    fn eq(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T:Eq> Eq for @[T] {\n-    #[inline]\n-    fn eq(&self, other: &@[T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n-}\n+    impl<T:Eq> Eq for @[T] {\n+        #[inline]\n+        fn eq(&self, other: &@[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n+    }\n \n-#[cfg(not(test))]\n-impl<'self,T:TotalEq> TotalEq for &'self [T] {\n-    #[inline]\n-    fn equals(&self, other: & &'self [T]) -> bool { equals(*self, *other) }\n-}\n+    impl<'self,T:TotalEq> TotalEq for &'self [T] {\n+        fn equals(&self, other: & &'self [T]) -> bool {\n+            self.len() == other.len() &&\n+                self.iter().zip(other.iter()).all(|(s,o)| s.equals(o))\n+        }\n+    }\n \n-#[cfg(not(test))]\n-impl<T:TotalEq> TotalEq for ~[T] {\n-    #[inline]\n-    fn equals(&self, other: &~[T]) -> bool { equals(*self, *other) }\n-}\n+    impl<T:TotalEq> TotalEq for ~[T] {\n+        #[inline]\n+        fn equals(&self, other: &~[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T:TotalEq> TotalEq for @[T] {\n-    #[inline]\n-    fn equals(&self, other: &@[T]) -> bool { equals(*self, *other) }\n-}\n+    impl<T:TotalEq> TotalEq for @[T] {\n+        #[inline]\n+        fn equals(&self, other: &@[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<'self,T:Eq> Equiv<~[T]> for &'self [T] {\n-    #[inline]\n-    fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-}\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for &'self [T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-// Lexicographical comparison\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n-    let low = uint::min(a.len(), b.len());\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for @[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-    for uint::range(0, low) |idx| {\n-        match a[idx].cmp(&b[idx]) {\n-          Greater => return Greater,\n-          Less => return Less,\n-          Equal => ()\n+    impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n+        fn cmp(&self, other: & &'self [T]) -> Ordering {\n+            for self.iter().zip(other.iter()).advance |(s,o)| {\n+                match s.cmp(o) {\n+                    Equal => {},\n+                    non_eq => { return non_eq; }\n+                }\n+            }\n+            self.len().cmp(&other.len())\n         }\n     }\n \n-    a.len().cmp(&b.len())\n-}\n-\n-#[cfg(not(test))]\n-impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n-    #[inline]\n-    fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<T: TotalOrd> TotalOrd for ~[T] {\n+        #[inline]\n+        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for ~[T] {\n-    #[inline]\n-    fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<T: TotalOrd> TotalOrd for @[T] {\n+        #[inline]\n+        fn cmp(&self, other: &@[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for @[T] {\n-    #[inline]\n-    fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<'self,T:Ord> Ord for &'self [T] {\n+        fn lt(&self, other: & &'self [T]) -> bool {\n+            for self.iter().zip(other.iter()).advance |(s,o)| {\n+                if *s < *o { return true; }\n+                if *s > *o { return false; }\n+            }\n+            self.len() < other.len()\n+        }\n+        #[inline]\n+        fn le(&self, other: & &'self [T]) -> bool { !(*other < *self) }\n+        #[inline]\n+        fn ge(&self, other: & &'self [T]) -> bool { !(*self < *other) }\n+        #[inline]\n+        fn gt(&self, other: & &'self [T]) -> bool { *other < *self }\n+    }\n \n-fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    let end = uint::min(a_len, b_len);\n+    impl<T:Ord> Ord for ~[T] {\n+        #[inline]\n+        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n+    }\n \n-    let mut i = 0;\n-    while i < end {\n-        let (c_a, c_b) = (&a[i], &b[i]);\n-        if *c_a < *c_b { return true; }\n-        if *c_a > *c_b { return false; }\n-        i += 1;\n+    impl<T:Ord> Ord for @[T] {\n+        #[inline]\n+        fn lt(&self, other: &@[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &@[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &@[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &@[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    a_len < b_len\n+    impl<'self,T:Copy, V: Vector<T>> Add<V, ~[T]> for &'self [T] {\n+        #[inline]\n+        fn add(&self, rhs: &V) -> ~[T] {\n+            let mut res = self.to_owned();\n+            res.push_all(rhs.as_slice());\n+            res\n+        }\n+    }\n+    impl<T:Copy, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n+        #[inline]\n+        fn add(&self, rhs: &V) -> ~[T] {\n+            let mut res = self.to_owned();\n+            res.push_all(rhs.as_slice());\n+            res\n+        }\n+    }\n }\n \n-fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n-fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n-fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n+#[cfg(test)]\n+pub mod traits {}\n \n-#[cfg(not(test))]\n-impl<'self,T:Ord> Ord for &'self [T] {\n-    #[inline]\n-    fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n+/// Any vector that can be represented as a slice.\n+pub trait Vector<T> {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n }\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for ~[T] {\n-    #[inline]\n-    fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n+impl<'self,T> Vector<T> for &'self [T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for @[T] {\n-    #[inline]\n-    fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n+impl<T> Vector<T> for ~[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n-\n-#[cfg(not(test))]\n-impl<'self,T:Copy> Add<&'self [T], ~[T]> for ~[T] {\n-    #[inline]\n-    fn add(&self, rhs: & &'self [T]) -> ~[T] {\n-        append(copy *self, (*rhs))\n-    }\n+impl<T> Vector<T> for @[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n \n impl<'self, T> Container for &'self [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_imm_buf(*self, |_p, len| len == 0u)\n+        self.as_imm_buf(|_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_imm_buf(*self, |_p, len| len)\n+        self.as_imm_buf(|_p, len| len)\n     }\n }\n \n impl<T> Container for ~[T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_imm_buf(*self, |_p, len| len == 0u)\n+        self.as_imm_buf(|_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_imm_buf(*self, |_p, len| len)\n+        self.as_imm_buf(|_p, len| len)\n     }\n }\n \n@@ -933,6 +708,14 @@ pub trait ImmutableVector<'self, T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n     fn rev_iter(self) -> VecRevIterator<'self, T>;\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n+    fn rsplitn_iter(self,  n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n+\n+    fn window_iter(self, size: uint) -> VecWindowIter<'self, T>;\n+    fn chunk_iter(self, size: uint) -> VecChunkIter<'self, T>;\n+\n     fn head(&self) -> &'self T;\n     fn head_opt(&self) -> Option<&'self T>;\n     fn tail(&self) -> &'self [T];\n@@ -943,12 +726,13 @@ pub trait ImmutableVector<'self, T> {\n     fn last_opt(&self) -> Option<&'self T>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n \n     fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n \n     fn map<U>(&self, &fn(t: &T) -> U) -> ~[U];\n+\n+    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U;\n }\n \n /// Extension methods for vectors\n@@ -958,7 +742,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n     assert!(start <= end);\n     assert!(end <= self.len());\n-        do as_imm_buf(*self) |p, _len| {\n+        do self.as_imm_buf |p, _len| {\n             unsafe {\n                 transmute((ptr::offset(p, start),\n                            (end - start) * sys::nonzero_size_of::<T>()))\n@@ -984,6 +768,101 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         }\n     }\n \n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`.\n+    #[inline]\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n+        self.splitn_iter(uint::max_value, pred)\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`, limited to splitting\n+    /// at most `n` times.\n+    #[inline]\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n+        VecSplitIterator {\n+            v: self,\n+            n: n,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`. This starts at the\n+    /// end of the vector and works backwards.\n+    #[inline]\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n+        self.rsplitn_iter(uint::max_value, pred)\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred` limited to splitting\n+    /// at most `n` times. This starts at the end of the vector and\n+    /// works backwards.\n+    #[inline]\n+    fn rsplitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n+        VecRSplitIterator {\n+            v: self,\n+            n: n,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+\n+    /**\n+     * Returns an iterator over all contiguous windows of length\n+     * `size`. The windows overlap. If the vector is shorter than\n+     * `size`, the iterator returns no values.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n+     * `[3,4]`):\n+     *\n+     * ~~~ {.rust}\n+     * let v = &[1,2,3,4];\n+     * for v.window_iter().advance |win| {\n+     *     io::println(fmt!(\"%?\", win));\n+     * }\n+     * ~~~\n+     *\n+     */\n+    fn window_iter(self, size: uint) -> VecWindowIter<'self, T> {\n+        assert!(size != 0);\n+        VecWindowIter { v: self, size: size }\n+    }\n+\n+    /**\n+     *\n+     * Returns an iterator over `size` elements of the vector at a\n+     * time. The chunks do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the vector two elements at a time (i.e. `[1,2]`,\n+     * `[3,4]`, `[5]`):\n+     *\n+     * ~~~ {.rust}\n+     * let v = &[1,2,3,4,5];\n+     * for v.chunk_iter().advance |win| {\n+     *     io::println(fmt!(\"%?\", win));\n+     * }\n+     * ~~~\n+     *\n+     */\n+    fn chunk_iter(self, size: uint) -> VecChunkIter<'self, T> {\n+        assert!(size != 0);\n+        VecChunkIter { v: self, size: size }\n+    }\n+\n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n     fn head(&self) -> &'self T {\n@@ -1053,17 +932,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n-    /**\n-     * Apply a function to each element of a vector and return the results\n-     *\n-     * If function `f` returns `none` then that element is excluded from\n-     * the resulting vector.\n-     */\n-    #[inline]\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_mapped(*self, f)\n-    }\n-\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[inline]\n@@ -1107,14 +975,36 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n         self.iter().transform(f).collect()\n     }\n-}\n \n-#[allow(missing_doc)]\n-pub trait ImmutableEqVector<T:Eq> {\n-    fn position_elem(&self, t: &T) -> Option<uint>;\n-    fn rposition_elem(&self, t: &T) -> Option<uint>;\n-    fn contains(&self, x: &T) -> bool;\n-}\n+    /**\n+     * Work with the buffer of a vector.\n+     *\n+     * Allows for unsafe manipulation of vector contents, which is useful for\n+     * foreign interop.\n+     */\n+    #[inline]\n+    fn as_imm_buf<U>(&self,\n+                     /* NB---this CANNOT be const, see below */\n+                     f: &fn(*T, uint) -> U) -> U {\n+        // NB---Do not change the type of s to `&const [T]`.  This is\n+        // unsound.  The reason is that we are going to create immutable pointers\n+        // into `s` and pass them to `f()`, but in fact they are potentially\n+        // pointing at *mutable memory*.  Use `as_mut_buf` instead!\n+\n+        unsafe {\n+            let v : *(*T,uint) = transmute(self);\n+            let (buf,len) = *v;\n+            f(buf, len / sys::nonzero_size_of::<T>())\n+        }\n+    }\n+}\n+\n+#[allow(missing_doc)]\n+pub trait ImmutableEqVector<T:Eq> {\n+    fn position_elem(&self, t: &T) -> Option<uint>;\n+    fn rposition_elem(&self, t: &T) -> Option<uint>;\n+    fn contains(&self, x: &T) -> bool;\n+}\n \n impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     /// Find the first index containing a matching value\n@@ -1154,25 +1044,12 @@ impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait ImmutableCopyableVector<T> {\n-    fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n }\n \n /// Extension methods for vectors\n impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n-    /**\n-     * Construct a new vector from the elements of a vector for which some\n-     * predicate holds.\n-     *\n-     * Apply function `f` to each element of `v` and return a vector\n-     * containing only those elements for which `f` returned true.\n-     */\n-    #[inline]\n-    fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n-        filtered(*self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -1202,6 +1079,9 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait OwnedVector<T> {\n+    fn consume_iter(self) -> VecConsumeIterator<T>;\n+    fn consume_rev_iter(self) -> VecConsumeRevIterator<T>;\n+\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n@@ -1218,14 +1098,37 @@ pub trait OwnedVector<T> {\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n     fn retain(&mut self, f: &fn(t: &T) -> bool);\n-    fn consume(self, f: &fn(uint, v: T));\n-    fn consume_reverse(self, f: &fn(uint, v: T));\n-    fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n     fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n+    /// Creates a consuming iterator, that is, one that moves each\n+    /// value out of the vector (from start to end). The vector cannot\n+    /// be used after calling this.\n+    ///\n+    /// Note that this performs O(n) swaps, and so `consume_rev_iter`\n+    /// (which just calls `pop` repeatedly) is more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v = ~[~\"a\", ~\"b\"];\n+    /// for v.consume_iter().advance |s| {\n+    ///   // s has type ~str, not &~str\n+    ///   println(s);\n+    /// }\n+    /// ~~~\n+    fn consume_iter(self) -> VecConsumeIterator<T> {\n+        VecConsumeIterator { v: self, idx: 0 }\n+    }\n+    /// Creates a consuming iterator that moves out of the vector in\n+    /// reverse order. Also see `consume_iter`, however note that this\n+    /// is more efficient.\n+    fn consume_rev_iter(self) -> VecConsumeRevIterator<T> {\n+        VecConsumeRevIterator { v: self }\n+    }\n+\n     /**\n      * Reserves capacity for exactly `n` elements in the given vector.\n      *\n@@ -1367,7 +1270,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n         unsafe {\n-            do as_mut_buf(rhs) |p, len| {\n+            do rhs.as_mut_buf |p, len| {\n                 for uint::range(0, len) |i| {\n                     let x = ptr::replace_ptr(ptr::mut_offset(p, i),\n                                              intrinsics::uninit());\n@@ -1499,7 +1402,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     /// Shorten a vector, dropping excess elements.\n     fn truncate(&mut self, newlen: uint) {\n-        do as_mut_buf(*self) |p, oldlen| {\n+        do self.as_mut_buf |p, oldlen| {\n             assert!(newlen <= oldlen);\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n@@ -1532,21 +1435,6 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n-    #[inline]\n-    fn consume(self, f: &fn(uint, v: T)) {\n-        consume(self, f)\n-    }\n-\n-    #[inline]\n-    fn consume_reverse(self, f: &fn(uint, v: T)) {\n-        consume_reverse(self, f)\n-    }\n-\n-    #[inline]\n-    fn filter(self, f: &fn(&T) -> bool) -> ~[T] {\n-        filter(self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -1556,7 +1444,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n-        do self.consume |_, elt| {\n+        for self.consume_iter().advance |elt| {\n             if f(&elt) {\n                 lefts.push(elt);\n             } else {\n@@ -1672,7 +1560,7 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             if self.len() == 0 { return; }\n             let mut last_written = 0;\n             let mut next_to_read = 1;\n-            do as_mut_buf(*self) |p, ln| {\n+            do self.as_mut_buf |p, ln| {\n                 // last_written < next_to_read <= ln\n                 while next_to_read < ln {\n                     // last_written < next_to_read < ln\n@@ -1726,6 +1614,8 @@ pub trait MutableVector<'self, T> {\n \n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n     unsafe fn unsafe_set(&self, index: uint, val: T);\n+\n+    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U;\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n@@ -1734,7 +1624,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        do as_mut_buf(self) |p, _len| {\n+        do self.as_mut_buf |p, _len| {\n             unsafe {\n                 transmute((ptr::mut_offset(p, start),\n                            (end - start) * sys::nonzero_size_of::<T>()))\n@@ -1807,6 +1697,17 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     unsafe fn unsafe_set(&self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n     }\n+\n+    /// Similar to `as_imm_buf` but passing a `*mut T`\n+    #[inline]\n+    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U {\n+        unsafe {\n+            let v : *(*mut T,uint) = transmute(self);\n+            let (buf,len) = *v;\n+            f(buf, len / sys::nonzero_size_of::<T>())\n+        }\n+    }\n+\n }\n \n /// Trait for ~[T] where T is Cloneable\n@@ -1856,7 +1757,7 @@ pub mod raw {\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n-    use vec::{UnboxedVecRepr, as_imm_buf, as_mut_buf, with_capacity};\n+    use vec::{UnboxedVecRepr, with_capacity, ImmutableVector, MutableVector};\n     use util;\n \n     /// The internal representation of a (boxed) vector\n@@ -1944,7 +1845,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn get<T:Copy>(v: &[T], i: uint) -> T {\n-        as_imm_buf(v, |p, _len| copy *ptr::offset(p, i))\n+        v.as_imm_buf(|p, _len| copy *ptr::offset(p, i))\n     }\n \n     /**\n@@ -1955,7 +1856,7 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let box2 = util::replace(&mut box, None);\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n                                       box2.unwrap());\n@@ -1975,7 +1876,7 @@ pub mod raw {\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n-        as_mut_buf(dst, |p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n+        dst.as_mut_buf(|p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n         dst\n     }\n \n@@ -1991,8 +1892,8 @@ pub mod raw {\n         assert!(dst.len() >= count);\n         assert!(src.len() >= count);\n \n-        do as_mut_buf(dst) |p_dst, _len_dst| {\n-            do as_imm_buf(src) |p_src, _len_src| {\n+        do dst.as_mut_buf |p_dst, _len_dst| {\n+            do src.as_imm_buf |p_src, _len_src| {\n                 ptr::copy_memory(p_dst, p_src, count)\n             }\n         }\n@@ -2016,7 +1917,7 @@ pub mod bytes {\n     impl<'self> MutableByteVector for &'self mut [u8] {\n         #[inline]\n         fn set_memory(self, value: u8) {\n-            do vec::as_mut_buf(self) |p, len| {\n+            do self.as_mut_buf |p, len| {\n                 unsafe { ptr::set_memory(p, value, len) };\n             }\n         }\n@@ -2132,7 +2033,7 @@ macro_rules! iterator {\n }\n \n //iterator!{struct VecIterator -> *T, &'self T}\n-/// An iterator for iterating over a vector\n+/// An iterator for iterating over a vector.\n pub struct VecIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n@@ -2141,7 +2042,7 @@ pub struct VecIterator<'self, T> {\n iterator!{impl VecIterator -> &'self T, 1}\n \n //iterator!{struct VecRevIterator -> *T, &'self T}\n-/// An iterator for iterating over a vector in reverse\n+/// An iterator for iterating over a vector in reverse.\n pub struct VecRevIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n@@ -2150,7 +2051,7 @@ pub struct VecRevIterator<'self, T> {\n iterator!{impl VecRevIterator -> &'self T, -1}\n \n //iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n-/// An iterator for mutating the elements of a vector\n+/// An iterator for mutating the elements of a vector.\n pub struct VecMutIterator<'self, T> {\n     priv ptr: *mut T,\n     priv end: *mut T,\n@@ -2159,14 +2060,57 @@ pub struct VecMutIterator<'self, T> {\n iterator!{impl VecMutIterator -> &'self mut T, 1}\n \n //iterator!{struct VecMutRevIterator -> *mut T, &'self mut T}\n-/// An iterator for mutating the elements of a vector in reverse\n+/// An iterator for mutating the elements of a vector in reverse.\n pub struct VecMutRevIterator<'self, T> {\n     priv ptr: *mut T,\n     priv end: *mut T,\n     priv lifetime: &'self mut T // FIXME: #5922\n }\n iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n \n+/// An iterator that moves out of a vector.\n+pub struct VecConsumeIterator<T> {\n+    priv v: ~[T],\n+    priv idx: uint,\n+}\n+\n+impl<T> Iterator<T> for VecConsumeIterator<T> {\n+    fn next(&mut self) -> Option<T> {\n+        // this is peculiar, but is required for safety with respect\n+        // to dtors. It traverses the first half of the vec, and\n+        // removes them by swapping them with the last element (and\n+        // popping), which results in the second half in reverse\n+        // order, and so these can just be pop'd off. That is,\n+        //\n+        // [1,2,3,4,5] => 1, [5,2,3,4] => 2, [5,4,3] => 3, [5,4] => 4,\n+        // [5] -> 5, []\n+\n+        if self.v.is_empty() {\n+            None\n+        } else {\n+            let l = self.v.len();\n+            if self.idx < l {\n+                self.v.swap(self.idx, l - 1);\n+                self.idx += 1;\n+            }\n+\n+            Some(self.v.pop())\n+        }\n+    }\n+}\n+\n+/// An iterator that moves out of a vector in reverse order.\n+pub struct VecConsumeRevIterator<T> {\n+    priv v: ~[T]\n+}\n+\n+impl<T> Iterator<T> for VecConsumeRevIterator<T> {\n+    fn next(&mut self) -> Option<T> {\n+        if self.v.is_empty() { None }\n+        else { Some(self.v.pop()) }\n+    }\n+}\n+\n #[cfg(stage0)]\n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {\n@@ -2633,87 +2577,6 @@ mod tests {\n         assert_eq!(w[4], 25u);\n     }\n \n-    #[test]\n-    fn test_filter_mapped() {\n-        // Test on-stack filter-map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_mapped(v, square_if_odd_r);\n-        assert_eq!(w.len(), 2u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-\n-        // Test on-heap filter-map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_mapped(v, square_if_odd_r);\n-        assert_eq!(w.len(), 3u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-        assert_eq!(w[2], 25u);\n-\n-        fn halve(i: &int) -> Option<int> {\n-            if *i % 2 == 0 {\n-                Some::<int>(*i / 2)\n-            } else {\n-                None::<int>\n-            }\n-        }\n-        fn halve_for_sure(i: &int) -> int { *i / 2 }\n-        let all_even: ~[int] = ~[0, 2, 8, 6];\n-        let all_odd1: ~[int] = ~[1, 7, 3];\n-        let all_odd2: ~[int] = ~[];\n-        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n-        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert!(filter_mapped(all_even, halve) ==\n-                     all_even.map(halve_for_sure));\n-        assert_eq!(filter_mapped(all_odd1, halve), ~[]);\n-        assert_eq!(filter_mapped(all_odd2, halve), ~[]);\n-        assert_eq!(filter_mapped(mix, halve), mix_dest);\n-    }\n-\n-    #[test]\n-    fn test_filter_map() {\n-        // Test on-stack filter-map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_map(v, square_if_odd_v);\n-        assert_eq!(w.len(), 2u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-\n-        // Test on-heap filter-map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_map(v, square_if_odd_v);\n-        assert_eq!(w.len(), 3u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-        assert_eq!(w[2], 25u);\n-\n-        fn halve(i: int) -> Option<int> {\n-            if i % 2 == 0 {\n-                Some::<int>(i / 2)\n-            } else {\n-                None::<int>\n-            }\n-        }\n-        fn halve_for_sure(i: &int) -> int { *i / 2 }\n-        let all_even: ~[int] = ~[0, 2, 8, 6];\n-        let all_even0: ~[int] = copy all_even;\n-        let all_odd1: ~[int] = ~[1, 7, 3];\n-        let all_odd2: ~[int] = ~[];\n-        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n-        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert!(filter_map(all_even, halve) ==\n-                     all_even0.map(halve_for_sure));\n-        assert_eq!(filter_map(all_odd1, halve), ~[]);\n-        assert_eq!(filter_map(all_odd2, halve), ~[]);\n-        assert_eq!(filter_map(mix, halve), mix_dest);\n-    }\n-\n-    #[test]\n-    fn test_filter() {\n-        assert_eq!(filter(~[1u, 2u, 3u], is_odd), ~[1u, 3u]);\n-        assert_eq!(filter(~[1u, 2u, 4u, 8u, 16u], is_three), ~[]);\n-    }\n-\n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n@@ -2828,75 +2691,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn reverse_and_reversed() {\n+    fn test_reverse() {\n         let mut v: ~[int] = ~[10, 20];\n         assert_eq!(v[0], 10);\n         assert_eq!(v[1], 20);\n         v.reverse();\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 10);\n-        let v2 = reversed::<int>([10, 20]);\n-        assert_eq!(v2[0], 20);\n-        assert_eq!(v2[1], 10);\n-        v[0] = 30;\n-        assert_eq!(v2[0], 20);\n-        // Make sure they work with 0-length vectors too.\n-\n-        let v4 = reversed::<int>([]);\n-        assert_eq!(v4, ~[]);\n+\n         let mut v3: ~[int] = ~[];\n         v3.reverse();\n-    }\n-\n-    #[test]\n-    fn reversed_mut() {\n-        let v2 = reversed::<int>([10, 20]);\n-        assert_eq!(v2[0], 20);\n-        assert_eq!(v2[1], 10);\n-    }\n-\n-    #[test]\n-    fn test_split() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(split([], f), ~[]);\n-        assert_eq!(split([1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(split([3, 1, 2], f), ~[~[], ~[1, 2]]);\n-        assert_eq!(split([1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert_eq!(split([1, 2, 3, 4, 3, 5], f), ~[~[1, 2], ~[4], ~[5]]);\n-    }\n-\n-    #[test]\n-    fn test_splitn() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(splitn([], 1u, f), ~[]);\n-        assert_eq!(splitn([1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(splitn([3, 1, 2], 1u, f), ~[~[], ~[1, 2]]);\n-        assert_eq!(splitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert!(splitn([1, 2, 3, 4, 3, 5], 1u, f) ==\n-                      ~[~[1, 2], ~[4, 3, 5]]);\n-    }\n-\n-    #[test]\n-    fn test_rsplit() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(rsplit([], f), ~[]);\n-        assert_eq!(rsplit([1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(rsplit([1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert!(rsplit([1, 2, 3, 4, 3, 5], f) ==\n-            ~[~[1, 2], ~[4], ~[5]]);\n-    }\n-\n-    #[test]\n-    fn test_rsplitn() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(rsplitn([], 1u, f), ~[]);\n-        assert_eq!(rsplitn([1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(rsplitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert_eq!(rsplitn([1, 2, 3, 4, 3, 5], 1u, f), ~[~[1, 2, 3, 4], ~[5]]);\n+        assert!(v3.is_empty());\n     }\n \n     #[test]\n@@ -2939,31 +2744,6 @@ mod tests {\n         assert_eq!([&[1], &[2], &[3]].connect_vec(&0), ~[1, 0, 2, 0, 3]);\n     }\n \n-    #[test]\n-    fn test_windowed () {\n-        fn t(n: uint, expected: &[&[int]]) {\n-            let mut i = 0;\n-            for windowed(n, [1,2,3,4,5,6]) |v| {\n-                assert_eq!(v, expected[i]);\n-                i += 1;\n-            }\n-\n-            // check that we actually iterated the right number of times\n-            assert_eq!(i, expected.len());\n-        }\n-        t(3, &[&[1,2,3],&[2,3,4],&[3,4,5],&[4,5,6]]);\n-        t(4, &[&[1,2,3,4],&[2,3,4,5],&[3,4,5,6]]);\n-        t(7, &[]);\n-        t(8, &[]);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_windowed_() {\n-        for windowed (0u, [1u,2u,3u,4u,5u,6u]) |_v| {}\n-    }\n-\n     #[test]\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];\n@@ -3064,156 +2844,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_split_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_split_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_splitn_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do splitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_splitn_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplit_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplit(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplit_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplit(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplitn_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplitn_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_consume_fail() {\n-        let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do consume(v) |_i, _elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3243,21 +2873,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_map_consume_fail() {\n-        let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do map_consume(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            ~[(~0, @0)]\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3273,38 +2888,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_mapped_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do filter_mapped(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            Some((~0, @0))\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do v.filtered |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3340,7 +2923,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_imm_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_imm_buf(v) |_buf, _i| {\n+        do v.as_imm_buf |_buf, _i| {\n             fail!()\n         }\n     }\n@@ -3350,7 +2933,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_mut_buf_fail() {\n         let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_mut_buf(v) |_buf, _i| {\n+        do v.as_mut_buf |_buf, _i| {\n             fail!()\n         }\n     }\n@@ -3428,6 +3011,120 @@ mod tests {\n         assert_eq!(xs, [5, 5, 5, 5, 5])\n     }\n \n+    #[test]\n+    fn test_consume_iterator() {\n+        use iterator::*;\n+        let xs = ~[1u,2,3,4,5];\n+        assert_eq!(xs.consume_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n+    }\n+\n+    #[test]\n+    fn test_consume_rev_iterator() {\n+        use iterator::*;\n+        let xs = ~[1u,2,3,4,5];\n+        assert_eq!(xs.consume_rev_iter().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+    }\n+\n+    #[test]\n+    fn test_split_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.split_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1], &[3], &[5]]);\n+        assert_eq!(xs.split_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+                   ~[&[], &[2,3,4,5]]);\n+        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4], &[]]);\n+        assert_eq!(xs.split_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.split_iter(|_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[], &[], &[]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_splitn_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.splitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.splitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1], &[3,4,5]]);\n+        assert_eq!(xs.splitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[4,5]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.splitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_rsplit_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.rsplit_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[5], &[3], &[1]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+                   ~[&[2,3,4,5], &[]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+                   ~[&[], &[1,2,3,4]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_rsplitn_iterator() {\n+        let xs = &[1,2,3,4,5];\n+\n+        assert_eq!(xs.rsplitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.rsplitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[5], &[1,2,3]]);\n+        assert_eq!(xs.rsplitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[1,2]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.rsplitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_window_iterator() {\n+        let v = &[1i,2,3,4];\n+\n+        assert_eq!(v.window_iter(2).collect::<~[&[int]]>(), ~[&[1,2], &[2,3], &[3,4]]);\n+        assert_eq!(v.window_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[2,3,4]]);\n+        assert!(v.window_iter(6).next().is_none());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_window_iterator_0() {\n+        let v = &[1i,2,3,4];\n+        let _it = v.window_iter(0);\n+    }\n+\n+    #[test]\n+    fn test_chunk_iterator() {\n+        let v = &[1i,2,3,4,5];\n+\n+        assert_eq!(v.chunk_iter(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n+        assert_eq!(v.chunk_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n+        assert_eq!(v.chunk_iter(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_chunk_iterator_0() {\n+        let v = &[1i,2,3,4];\n+        let _it = v.chunk_iter(0);\n+    }\n+\n     #[test]\n     fn test_move_from() {\n         let mut a = [1,2,3,4,5];"}, {"sha": "ce8e24fd4445a912b24337e0bd6fb902dff6bead", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -238,12 +238,12 @@ pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n }\n \n pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n-    do ms.filtered |m| {\n+    do ms.consume_iter().filter |m| {\n         match m.vis {\n             public => true,\n             _   => false\n         }\n-    }\n+    }.collect()\n }\n \n // extract a ty_method from a trait_method. if the trait_method is"}, {"sha": "d04d96b2481d62127ba28f9b2323d7a2e9fbef29", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -143,13 +143,13 @@ pub fn get_name_value_str_pair(item: @ast::meta_item)\n /// Search a list of attributes and return only those with a specific name\n pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n-    do vec::filter_mapped(attrs) |a| {\n+    do attrs.iter().filter_map |a| {\n         if name == get_attr_name(a) {\n             Some(*a)\n         } else {\n             None\n         }\n-    }\n+    }.collect()\n }\n \n /// Search a list of meta items and return only those with a specific name\n@@ -277,14 +277,7 @@ pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n \n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n-\n-    return vec::filter_mapped(items, |item| {\n-        if name != get_meta_item_name(*item) {\n-            Some(*item)\n-        } else {\n-            None\n-        }\n-    });\n+    items.consume_iter().filter(|item| name != get_meta_item_name(*item)).collect()\n }\n \n /**"}, {"sha": "333570b6c9d7e5156cb7518d996c6b7b01054e3f", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -22,7 +22,6 @@ use ext::build::AstBuilder;\n \n use std::option;\n use std::unstable::extfmt::ct::*;\n-use std::vec;\n use parse::token::{str_to_ident};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n@@ -268,7 +267,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n        corresponding function in std::unstable::extfmt. Each function takes a\n        buffer to insert data into along with the data being formatted. */\n     let npieces = pieces.len();\n-    do vec::consume(pieces) |i, pc| {\n+    for pieces.consume_iter().enumerate().advance |(i, pc)| {\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {"}, {"sha": "96d7685353b2d7cb551a2203b585bfc350cd40df", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -14,8 +14,6 @@ use codemap::{span, spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n-use std::vec;\n-\n pub trait ast_fold {\n     fn fold_crate(@self, &crate) -> crate;\n     fn fold_view_item(@self, @view_item) -> @view_item;\n@@ -700,7 +698,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n         view_items: m.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n-        items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n+        items: m.items.iter().filter_map(|x| fld.fold_item(*x)).collect(),\n     }\n }\n "}, {"sha": "d327b73c625ec4dd95366dd892e37692a9444bcd", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -95,13 +95,13 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         }\n     }\n \n-    do vec::map_consume(graph) |mut v| {\n+    do graph.consume_iter().transform |mut v| {\n         let mut vec = ~[];\n         do v.consume |i| {\n             vec.push(i);\n         }\n         vec\n-    }\n+    }.collect()\n }\n \n fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {"}, {"sha": "abc44dfbc9bb71d9830338cf4b157bdda46ec34c", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -96,7 +96,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 fn_box: || @Cons((), fn_box()),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n-                vec: st.vec + [@Cons((), *st.vec.last())],\n+                vec: st.vec + &[@Cons((), *st.vec.last())],\n                 res: r(@Cons((), st.res._l))\n             }\n           }"}, {"sha": "1cd90962c5b796b851b721f4b88fddb04f8a2530", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -28,20 +28,21 @@ fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n         wait_port\n     };\n \n-    let child_start_chans: ~[Chan<Chan<int>>] = vec::map_consume(wait_ports, |port| port.recv());\n+    let child_start_chans: ~[Chan<Chan<int>>] =\n+        wait_ports.consume_iter().transform(|port| port.recv()).collect();\n \n     let (start_port, start_chan) = stream::<Chan<int>>();\n     parent_wait_chan.send(start_chan);\n     let parent_result_chan: Chan<int> = start_port.recv();\n \n-    let child_sum_ports: ~[Port<int>] = do vec::map_consume(child_start_chans) |child_start_chan| {\n-        let (child_sum_port, child_sum_chan) = stream::<int>();\n-        child_start_chan.send(child_sum_chan);\n-        child_sum_port\n-    };\n+    let child_sum_ports: ~[Port<int>] =\n+        do child_start_chans.consume_iter().transform |child_start_chan| {\n+            let (child_sum_port, child_sum_chan) = stream::<int>();\n+            child_start_chan.send(child_sum_chan);\n+            child_sum_port\n+    }.collect();\n \n-    let mut sum = 0;\n-    vec::consume(child_sum_ports, |_, sum_port| sum += sum_port.recv() );\n+    let sum = child_sum_ports.consume_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n \n     parent_result_chan.send(sum + 1);\n }"}, {"sha": "e7e01a40487214b4257a13326ca8f50fb7267888", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -30,7 +30,7 @@ use std::io::WriterUtil;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::vec::{filter, from_elem};   //~ ERROR unused import\n+use std::vec::{from_fn, from_elem};   //~ ERROR unused import\n \n mod foo {\n     pub struct Point{x: int, y: int}"}, {"sha": "0fdaf31c59361a13adb460e4a98878331cca8d0c", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -11,7 +11,6 @@\n // error-pattern:index out of bounds\n \n use std::sys;\n-use std::vec;\n \n fn main() {\n \n@@ -22,7 +21,7 @@ fn main() {\n     // huge).\n \n     let x = ~[1u,2u,3u];\n-    do vec::as_imm_buf(x) |p, _len| {\n+    do x.as_imm_buf |p, _len| {\n         let base = p as uint;\n         let idx = base / sys::size_of::<uint>();\n         error!(\"ov1 base = 0x%x\", base);"}, {"sha": "d09ef3bc25c3a45d3ecf1a4579f1a63dafafeff9", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6fc46c030ab0515a052fa99c9e10c75cfc8184/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=0c6fc46c030ab0515a052fa99c9e10c75cfc8184", "patch": "@@ -17,5 +17,5 @@ use std::vec::*;\n pub fn main() {\n     let mut v = from_elem(0u, 0);\n     v = append(v, ~[4, 2]);\n-    assert_eq!(reversed(v), ~[2, 4]);\n+    assert_eq!(from_fn(2, |i| 2*(i+1)), ~[2, 4]);\n }"}]}