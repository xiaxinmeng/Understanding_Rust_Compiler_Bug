{"sha": "c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZDU2NGQ4Yzk2YmY1MzhjYzY0YTNlZWNhMWZjYzNjOTk1Njk2MjU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-19T14:03:30Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-19T14:03:30Z"}, "message": "Check transmutes between types without statically known sizes.", "tree": {"sha": "dd94095c8c47b73a7a068078c613a300f907209f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd94095c8c47b73a7a068078c613a300f907209f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "html_url": "https://github.com/rust-lang/rust/commit/c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24ca1ec07da202f77ed70f96ec6bfb138eaf29be", "url": "https://api.github.com/repos/rust-lang/rust/commits/24ca1ec07da202f77ed70f96ec6bfb138eaf29be", "html_url": "https://github.com/rust-lang/rust/commit/24ca1ec07da202f77ed70f96ec6bfb138eaf29be"}], "stats": {"total": 692, "additions": 341, "deletions": 351}, "files": [{"sha": "536c739bf1615053f75cba0c7e9175518a529074", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -71,7 +71,6 @@ pub enum DepNode<D: Clone + Debug> {\n     DeadCheck,\n     StabilityCheck,\n     LateLintCheck,\n-    IntrinsicUseCheck,\n     TransCrate,\n     TransCrateItem(D),\n     TransInlinedItem(D),\n@@ -169,7 +168,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             DeadCheck => Some(DeadCheck),\n             StabilityCheck => Some(StabilityCheck),\n             LateLintCheck => Some(LateLintCheck),\n-            IntrinsicUseCheck => Some(IntrinsicUseCheck),\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n             Hir(ref d) => op(d).map(Hir),"}, {"sha": "e230836ef451510a3646119490524b31dee0f44b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -1410,6 +1410,32 @@ It is not possible to use stability attributes outside of the standard library.\n Also, for now, it is not possible to write deprecation messages either.\n \"##,\n \n+E0512: r##\"\n+Transmute with two differently sized types was attempted. Erroneous code\n+example:\n+\n+```compile_fail\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n+    // error: transmute called with differently sized types\n+}\n+```\n+\n+Please use types with same size or use the expected type directly. Example:\n+\n+```\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n+    // or:\n+    unsafe { takes_u8(0u8); } // ok!\n+}\n+```\n+\"##,\n+\n E0517: r##\"\n This error indicates that a `#[repr(..)]` attribute was placed on an\n unsupported item."}, {"sha": "e84be7e45606b0c77f0f7a55a2d4be4e713e619d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 103, "deletions": 186, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -11,11 +11,10 @@\n use dep_graph::DepNode;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use ty::subst::{Subst, Substs, EnumeratedItems};\n-use ty::{TransmuteRestriction, TyCtxt};\n-use ty::{self, Ty, TypeFoldable};\n-\n-use std::fmt;\n+use infer::{InferCtxt, new_infer_ctxt};\n+use traits::ProjectionMode;\n+use ty::{self, Ty, TyCtxt};\n+use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n \n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n@@ -24,219 +23,148 @@ use hir::intravisit::{self, Visitor, FnKind};\n use hir;\n \n pub fn check_crate(tcx: &TyCtxt) {\n-    let mut visitor = IntrinsicCheckingVisitor {\n-        tcx: tcx,\n-        param_envs: Vec::new(),\n-        dummy_sized_ty: tcx.types.isize,\n-        dummy_unsized_ty: tcx.mk_slice(tcx.types.isize),\n+    let mut visitor = ItemVisitor {\n+        tcx: tcx\n     };\n     tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n }\n \n-struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+struct ItemVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a TyCtxt<'tcx>\n+}\n \n-    // As we traverse the AST, we keep a stack of the parameter\n-    // environments for each function we encounter. When we find a\n-    // call to `transmute`, we can check it in the context of the top\n-    // of the stack (which ought not to be empty).\n-    param_envs: Vec<ty::ParameterEnvironment<'a,'tcx>>,\n+impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n+    fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n+        let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n+                                   Some(param_env),\n+                                   ProjectionMode::Any);\n+        let mut visitor = ExprVisitor {\n+            infcx: &infcx\n+        };\n+        visitor.visit_expr(expr);\n+    }\n+}\n \n-    // Dummy sized/unsized types that use to substitute for type\n-    // parameters in order to estimate how big a type will be for any\n-    // possible instantiation of the type parameters in scope.  See\n-    // `check_transmute` for more details.\n-    dummy_sized_ty: Ty<'tcx>,\n-    dummy_unsized_ty: Ty<'tcx>,\n+struct ExprVisitor<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.tcx.lookup_item_type(def_id).ty.sty {\n+        let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyFnDef(_, _, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.tcx.item_name(def_id).as_str() == \"transmute\"\n+        intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n-        // Find the parameter environment for the most recent function that\n-        // we entered.\n+        let sk_from = SizeSkeleton::compute(from, self.infcx);\n+        let sk_to = SizeSkeleton::compute(to, self.infcx);\n \n-        let param_env = match self.param_envs.last() {\n-            Some(p) => p,\n-            None => {\n-                span_bug!(\n-                    span,\n-                    \"transmute encountered outside of any fn\");\n+        // Check for same size using the skeletons.\n+        if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n+            if sk_from.same_size(sk_to) {\n+                return;\n             }\n-        };\n-\n-        // Simple case: no type parameters involved.\n-        if\n-            !from.has_param_types() && !from.has_self_ty() &&\n-            !to.has_param_types() && !to.has_self_ty()\n-        {\n-            let restriction = TransmuteRestriction {\n-                span: span,\n-                original_from: from,\n-                original_to: to,\n-                substituted_from: from,\n-                substituted_to: to,\n-                id: id,\n-            };\n-            self.push_transmute_restriction(restriction);\n-            return;\n-        }\n \n-        // The rules around type parameters are a bit subtle. We are\n-        // checking these rules before monomorphization, so there may\n-        // be unsubstituted type parameters present in the\n-        // types. Obviously we cannot create LLVM types for those.\n-        // However, if a type parameter appears only indirectly (i.e.,\n-        // through a pointer), it does not necessarily affect the\n-        // size, so that should be allowed. The only catch is that we\n-        // DO want to be careful around unsized type parameters, since\n-        // fat pointers have a different size than a thin pointer, and\n-        // hence `&T` and `&U` have different sizes if `T : Sized` but\n-        // `U : Sized` does not hold.\n-        //\n-        // However, it's not as simple as checking whether `T :\n-        // Sized`, because even if `T : Sized` does not hold, that\n-        // just means that `T` *may* not be sized.  After all, even a\n-        // type parameter `T: ?Sized` could be bound to a sized\n-        // type. (Issue #20116)\n-        //\n-        // To handle this, we first check for \"interior\" type\n-        // parameters, which are always illegal. If there are none of\n-        // those, then we know that the only way that all type\n-        // parameters `T` are referenced indirectly, e.g. via a\n-        // pointer type like `&T`. In that case, we only care whether\n-        // `T` is sized or not, because that influences whether `&T`\n-        // is a thin or fat pointer.\n-        //\n-        // One could imagine establishing a sophisticated constraint\n-        // system to ensure that the transmute is legal, but instead\n-        // we do something brutally dumb. We just substitute dummy\n-        // sized or unsized types for every type parameter in scope,\n-        // exhaustively checking all possible combinations. Here are some examples:\n-        //\n-        // ```\n-        // fn foo<T, U>() {\n-        //     // T=int, U=int\n-        // }\n-        //\n-        // fn bar<T: ?Sized, U>() {\n-        //     // T=int, U=int\n-        //     // T=[int], U=int\n-        // }\n-        //\n-        // fn baz<T: ?Sized, U: ?Sized>() {\n-        //     // T=int, U=int\n-        //     // T=[int], U=int\n-        //     // T=int, U=[int]\n-        //     // T=[int], U=[int]\n-        // }\n-        // ```\n-        //\n-        // In all cases, we keep the original unsubstituted types\n-        // around for error reporting.\n-\n-        let from_tc = from.type_contents(self.tcx);\n-        let to_tc = to.type_contents(self.tcx);\n-        if from_tc.interior_param() || to_tc.interior_param() {\n-            span_err!(self.tcx.sess, span, E0139,\n-                      \"cannot transmute to or from a type that contains \\\n-                       unsubstituted type parameters\");\n-            return;\n+            match (&from.sty, sk_to) {\n+                (&ty::TyFnDef(..), SizeSkeleton::Known(size_to))\n+                        if size_to == Pointer.size(&self.infcx.tcx.data_layout) => {\n+                    // FIXME #19925 Remove this warning after a release cycle.\n+                    let msg = format!(\"`{}` is now zero-sized and has to be cast \\\n+                                       to a pointer before transmuting to `{}`\",\n+                                      from, to);\n+                    self.infcx.tcx.sess.add_lint(\n+                        ::lint::builtin::TRANSMUTE_FROM_FN_ITEM_TYPES, id, span, msg);\n+                    return;\n+                }\n+                _ => {}\n+            }\n         }\n \n-        let mut substs = param_env.free_substs.clone();\n-        self.with_each_combination(\n-            span,\n-            param_env,\n-            param_env.free_substs.types.iter_enumerated(),\n-            &mut substs,\n-            &mut |substs| {\n-                let restriction = TransmuteRestriction {\n-                    span: span,\n-                    original_from: from,\n-                    original_to: to,\n-                    substituted_from: from.subst(self.tcx, substs),\n-                    substituted_to: to.subst(self.tcx, substs),\n-                    id: id,\n-                };\n-                self.push_transmute_restriction(restriction);\n-            });\n-    }\n-\n-    fn with_each_combination(&self,\n-                             span: Span,\n-                             param_env: &ty::ParameterEnvironment<'a,'tcx>,\n-                             mut types_in_scope: EnumeratedItems<Ty<'tcx>>,\n-                             substs: &mut Substs<'tcx>,\n-                             callback: &mut FnMut(&Substs<'tcx>))\n-    {\n-        // This parameter invokes `callback` many times with different\n-        // substitutions that replace all the parameters in scope with\n-        // either `int` or `[int]`, depending on whether the type\n-        // parameter is known to be sized. See big comment above for\n-        // an explanation of why this is a reasonable thing to do.\n-\n-        match types_in_scope.next() {\n-            None => {\n-                debug!(\"with_each_combination(substs={:?})\",\n-                       substs);\n-\n-                callback(substs);\n+        // Try to display a sensible error with as much information as possible.\n+        let skeleton_string = |ty: Ty<'tcx>, sk| {\n+            match sk {\n+                Ok(SizeSkeleton::Known(size)) => {\n+                    format!(\"{} bits\", size.bits())\n+                }\n+                Ok(SizeSkeleton::Pointer { tail, .. }) => {\n+                    format!(\"pointer to {}\", tail)\n+                }\n+                Err(LayoutError::Unknown(bad)) => {\n+                    if bad == ty {\n+                        format!(\"size can vary\")\n+                    } else {\n+                        format!(\"size can vary because of {}\", bad)\n+                    }\n+                }\n+                Err(err) => err.to_string()\n             }\n+        };\n \n-            Some((space, index, &param_ty)) => {\n-                debug!(\"with_each_combination: space={:?}, index={}, param_ty={:?}\",\n-                       space, index, param_ty);\n-\n-                if !param_ty.is_sized(param_env, span) {\n-                    debug!(\"with_each_combination: param_ty is not known to be sized\");\n+        span_err!(self.infcx.tcx.sess, span, E0512,\n+                  \"transmute called with differently sized types: \\\n+                   {} ({}) to {} ({})\",\n+                  from, skeleton_string(from, sk_from),\n+                  to, skeleton_string(to, sk_to));\n+    }\n+}\n \n-                    substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n-                    self.with_each_combination(span, param_env, types_in_scope.clone(),\n-                                               substs, callback);\n-                }\n+impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n+    // const, static and N in [T; N].\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n+        let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n+                                   None, ProjectionMode::Any);\n+        let mut visitor = ExprVisitor {\n+            infcx: &infcx\n+        };\n+        visitor.visit_expr(expr);\n+    }\n \n-                substs.types.get_mut_slice(space)[index] = self.dummy_sized_ty;\n-                self.with_each_combination(span, param_env, types_in_scope,\n-                                           substs, callback);\n-            }\n+    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+        if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n+            self.visit_const(item.id, expr);\n+        } else {\n+            intravisit::walk_trait_item(self, item);\n         }\n     }\n \n-    fn push_transmute_restriction(&self, restriction: TransmuteRestriction<'tcx>) {\n-        debug!(\"Pushing transmute restriction: {:?}\", restriction);\n-        self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n+    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n+            self.visit_const(item.id, expr);\n+        } else {\n+            intravisit::walk_impl_item(self, item);\n+        }\n     }\n-}\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-                self.param_envs.push(param_env);\n-                intravisit::walk_fn(self, fk, fd, b, s);\n-                self.param_envs.pop();\n+                let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n+                                           Some(param_env),\n+                                           ProjectionMode::Any);\n+                let mut visitor = ExprVisitor {\n+                    infcx: &infcx\n+                };\n+                visitor.visit_fn(fk, fd, b, s, id);\n             }\n             FnKind::Closure(..) => {\n-                intravisit::walk_fn(self, fk, fd, b, s);\n+                span_bug!(s, \"intrinsicck: closure outside of function\")\n             }\n         }\n     }\n+}\n \n+impl<'a, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n-            match self.tcx.resolve_expr(expr) {\n+            match self.infcx.tcx.resolve_expr(expr) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.tcx.node_id_to_type(expr.id);\n+                    let typ = self.infcx.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(_, _, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n@@ -256,14 +184,3 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n }\n-\n-impl<'tcx> fmt::Debug for TransmuteRestriction<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TransmuteRestriction(id={}, original=({:?},{:?}), substituted=({:?},{:?}))\",\n-               self.id,\n-               self.original_from,\n-               self.original_to,\n-               self.substituted_from,\n-               self.substituted_to)\n-    }\n-}"}, {"sha": "10000607b540907a2a1a5bb434b4161f56b219b7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -357,11 +357,6 @@ pub struct TyCtxt<'tcx> {\n     pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n \n-    /// The types that must be asserted to be the same size for `transmute`\n-    /// to be valid. We gather up these restrictions in the intrinsicck pass\n-    /// and check them in trans.\n-    pub transmute_restrictions: RefCell<Vec<ty::TransmuteRestriction<'tcx>>>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -605,7 +600,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             extern_const_statics: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n             node_lint_levels: RefCell::new(FnvHashMap()),\n-            transmute_restrictions: RefCell::new(Vec::new()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),"}, {"sha": "3ea691b4dc76649d0b7d0fa9c281507e6f924106", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -1199,3 +1199,138 @@ impl Layout {\n         }\n     }\n }\n+\n+/// Type size \"skeleton\", i.e. the only information determining a type's size.\n+/// While this is conservative, (aside from constant sizes, only pointers,\n+/// newtypes thereof and null pointer optimized enums are allowed), it is\n+/// enough to statically check common usecases of transmute.\n+#[derive(Copy, Clone, Debug)]\n+pub enum SizeSkeleton<'tcx> {\n+    /// Any statically computable Layout.\n+    Known(Size),\n+\n+    /// A potentially-fat pointer.\n+    Pointer {\n+        // If true, this pointer is never null.\n+        non_zero: bool,\n+        // The type which determines the unsized metadata, if any,\n+        // of this pointer. Either a type parameter or a projection\n+        // depending on one, with regions erased.\n+        tail: Ty<'tcx>\n+    }\n+}\n+\n+impl<'tcx> SizeSkeleton<'tcx> {\n+    pub fn compute<'a>(ty: Ty<'tcx>, infcx: &InferCtxt<'a, 'tcx>)\n+                       -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n+        let tcx = infcx.tcx;\n+        assert!(!ty.has_infer_types());\n+\n+        // First try computing a static layout.\n+        let err = match ty.layout(infcx) {\n+            Ok(layout) => {\n+                return Ok(SizeSkeleton::Known(layout.size(&tcx.data_layout)));\n+            }\n+            Err(err) => err\n+        };\n+\n+        match ty.sty {\n+            ty::TyBox(pointee) |\n+            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                let non_zero = !ty.is_unsafe_ptr();\n+                let tail = tcx.struct_tail(pointee);\n+                match tail.sty {\n+                    ty::TyParam(_) | ty::TyProjection(_) => {\n+                        assert!(tail.has_param_types() || tail.has_self_ty());\n+                        Ok(SizeSkeleton::Pointer {\n+                            non_zero: non_zero,\n+                            tail: tcx.erase_regions(&tail)\n+                        })\n+                    }\n+                    _ => {\n+                        bug!(\"SizeSkeleton::compute({}): layout errored ({}), yet \\\n+                              tail `{}` is not a type parameter or a projection\",\n+                             ty, err, tail)\n+                    }\n+                }\n+            }\n+\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                // Only newtypes and enums w/ nullable pointer optimization.\n+                if def.variants.is_empty() || def.variants.len() > 2 {\n+                    return Err(err);\n+                }\n+\n+                // If there's a drop flag, it can't be just a pointer.\n+                if def.dtor_kind().has_drop_flag() {\n+                    return Err(err);\n+                }\n+\n+                // Get a zero-sized variant or a pointer newtype.\n+                let zero_or_ptr_variant = |i: usize| {\n+                    let fields = def.variants[i].fields.iter().map(|field| {\n+                        let ty = normalize_associated_type(infcx, &field.ty(tcx, substs));\n+                        SizeSkeleton::compute(ty, infcx)\n+                    });\n+                    let mut ptr = None;\n+                    for field in fields {\n+                        let field = field?;\n+                        match field {\n+                            SizeSkeleton::Known(size) => {\n+                                if size.bytes() > 0 {\n+                                    return Err(err);\n+                                }\n+                            }\n+                            SizeSkeleton::Pointer {..} => {\n+                                if ptr.is_some() {\n+                                    return Err(err);\n+                                }\n+                                ptr = Some(field);\n+                            }\n+                        }\n+                    }\n+                    Ok(ptr)\n+                };\n+\n+                let v0 = zero_or_ptr_variant(0)?;\n+                // Newtype.\n+                if def.variants.len() == 1 {\n+                    if let Some(SizeSkeleton::Pointer { non_zero, tail }) = v0 {\n+                        return Ok(SizeSkeleton::Pointer {\n+                            non_zero: non_zero ||\n+                                Some(def.did) == tcx.lang_items.non_zero(),\n+                            tail: tail\n+                        });\n+                    } else {\n+                        return Err(err);\n+                    }\n+                }\n+\n+                let v1 = zero_or_ptr_variant(1)?;\n+                // Nullable pointer enum optimization.\n+                match (v0, v1) {\n+                    (Some(SizeSkeleton::Pointer { non_zero: true, tail }), None) |\n+                    (None, Some(SizeSkeleton::Pointer { non_zero: true, tail })) => {\n+                        Ok(SizeSkeleton::Pointer {\n+                            non_zero: false,\n+                            tail: tail\n+                        })\n+                    }\n+                    _ => Err(err)\n+                }\n+            }\n+\n+            _ => Err(err)\n+        }\n+    }\n+\n+    pub fn same_size(self, other: SizeSkeleton) -> bool {\n+        match (self, other) {\n+            (SizeSkeleton::Known(a), SizeSkeleton::Known(b)) => a == b,\n+            (SizeSkeleton::Pointer { tail: a, .. },\n+             SizeSkeleton::Pointer { tail: b, .. }) => a == b,\n+            _ => false\n+        }\n+    }\n+}"}, {"sha": "238856197feedf9b07e7f7c20091cc780cad9f8e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -480,37 +480,6 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// A restriction that certain types must be the same size. The use of\n-/// `transmute` gives rise to these restrictions. These generally\n-/// cannot be checked until trans; therefore, each call to `transmute`\n-/// will push one or more such restriction into the\n-/// `transmute_restrictions` vector during `intrinsicck`. They are\n-/// then checked during `trans` by the fn `check_intrinsics`.\n-#[derive(Copy, Clone)]\n-pub struct TransmuteRestriction<'tcx> {\n-    /// The span whence the restriction comes.\n-    pub span: Span,\n-\n-    /// The type being transmuted from.\n-    pub original_from: Ty<'tcx>,\n-\n-    /// The type being transmuted to.\n-    pub original_to: Ty<'tcx>,\n-\n-    /// The type being transmuted from, with all type parameters\n-    /// substituted for an arbitrary representative. Not to be shown\n-    /// to the end user.\n-    pub substituted_from: Ty<'tcx>,\n-\n-    /// The type being transmuted to, with all type parameters\n-    /// substituted for an arbitrary representative. Not to be shown\n-    /// to the end user.\n-    pub substituted_to: Ty<'tcx>,\n-\n-    /// NodeId of the transmute intrinsic.\n-    pub id: NodeId,\n-}\n-\n /// Describes the fragment-state associated with a NodeId.\n ///\n /// Currently only unfragmented paths have entries in the table,"}, {"sha": "8052fc21cc70506bea3e7bc5336e2c430e3aa848", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -78,7 +78,6 @@ use declare;\n use expr;\n use glue;\n use inline;\n-use intrinsic;\n use machine;\n use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n@@ -2750,13 +2749,9 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     {\n         let ccx = shared_ccx.get_ccx(0);\n-\n-        // First, verify intrinsics.\n-        intrinsic::check_intrinsics(&ccx);\n-\n         collect_translation_items(&ccx);\n \n-        // Next, translate all items. See `TransModVisitor` for\n+        // Translate all items. See `TransModVisitor` for\n         // details on why we walk in this particular way.\n         {\n             let _icx = push_ctxt(\"text\");"}, {"sha": "5e4902cf3caf24108ad1eed7c68b544dd4e4ab2f", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -83,32 +83,6 @@ unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!\n ```\n \"##,\n \n-E0512: r##\"\n-Transmute with two differently sized types was attempted. Erroneous code\n-example:\n-\n-```compile_fail\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n-    // error: transmute called with differently sized types\n-}\n-```\n-\n-Please use types with same size or use the expected type directly. Example:\n-\n-```\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n-    // or:\n-    unsafe { takes_u8(0u8); } // ok!\n-}\n-```\n-\"##,\n-\n E0515: r##\"\n A constant index expression was out of bounds. Erroneous code example:\n "}, {"sha": "1220fbafa29c9ddb6831538f0481affca251f4bb", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 73, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -36,16 +36,14 @@ use glue;\n use type_of;\n use machine;\n use type_::Type;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty};\n use Disr;\n use rustc::ty::subst::Substs;\n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::parse::token;\n \n-use rustc::lint;\n use rustc::session::Session;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -97,76 +95,6 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     Some(ccx.get_intrinsic(&llvm_name))\n }\n \n-pub fn span_transmute_size_error(a: &Session, b: Span, msg: &str) {\n-    span_err!(a, b, E0512, \"{}\", msg);\n-}\n-\n-/// Performs late verification that intrinsics are used correctly. At present,\n-/// the only intrinsic that needs such verification is `transmute`.\n-pub fn check_intrinsics(ccx: &CrateContext) {\n-    let _task = ccx.tcx().dep_graph.in_task(DepNode::IntrinsicUseCheck);\n-    let mut last_failing_id = None;\n-    for transmute_restriction in ccx.tcx().transmute_restrictions.borrow().iter() {\n-        // Sometimes, a single call to transmute will push multiple\n-        // type pairs to test in order to exhaustively test the\n-        // possibility around a type parameter. If one of those fails,\n-        // there is no sense reporting errors on the others.\n-        if last_failing_id == Some(transmute_restriction.id) {\n-            continue;\n-        }\n-\n-        debug!(\"transmute_restriction: {:?}\", transmute_restriction);\n-\n-        assert!(!transmute_restriction.substituted_from.has_param_types());\n-        assert!(!transmute_restriction.substituted_to.has_param_types());\n-\n-        let llfromtype = type_of::sizing_type_of(ccx,\n-                                                 transmute_restriction.substituted_from);\n-        let lltotype = type_of::sizing_type_of(ccx,\n-                                               transmute_restriction.substituted_to);\n-        let from_type_size = machine::llbitsize_of_real(ccx, llfromtype);\n-        let to_type_size = machine::llbitsize_of_real(ccx, lltotype);\n-\n-        if let ty::TyFnDef(..) = transmute_restriction.substituted_from.sty {\n-            if to_type_size == machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-                // FIXME #19925 Remove this warning after a release cycle.\n-                lint::raw_emit_lint(&ccx.tcx().sess,\n-                                    &ccx.tcx().sess.lint_store.borrow(),\n-                                    lint::builtin::TRANSMUTE_FROM_FN_ITEM_TYPES,\n-                                    (lint::Warn, lint::LintSource::Default),\n-                                    Some(transmute_restriction.span),\n-                                    &format!(\"`{}` is now zero-sized and has to be cast \\\n-                                              to a pointer before transmuting to `{}`\",\n-                                             transmute_restriction.substituted_from,\n-                                             transmute_restriction.substituted_to));\n-                continue;\n-            }\n-        }\n-        if from_type_size != to_type_size {\n-            last_failing_id = Some(transmute_restriction.id);\n-\n-            if transmute_restriction.original_from != transmute_restriction.substituted_from {\n-                span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n-                    &format!(\"transmute called with differently sized types: \\\n-                              {} (could be {} bits) to {} (could be {} bits)\",\n-                             transmute_restriction.original_from,\n-                             from_type_size,\n-                             transmute_restriction.original_to,\n-                             to_type_size));\n-            } else {\n-                span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n-                    &format!(\"transmute called with differently sized types: \\\n-                              {} ({} bits) to {} ({} bits)\",\n-                             transmute_restriction.original_from,\n-                             from_type_size,\n-                             transmute_restriction.original_to,\n-                             to_type_size));\n-            }\n-        }\n-    }\n-    ccx.sess().abort_if_errors();\n-}\n-\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs"}, {"sha": "c92a404b71a6fbf38ad9afc5af0a6402985d585b", "filename": "src/test/compile-fail/issue-21174.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -15,7 +15,7 @@ trait Trait<'a> {\n \n fn foo<'a, T: Trait<'a>>(value: T::A) {\n     let new: T::B = unsafe { std::mem::transmute(value) };\n-//~^ ERROR: cannot transmute to or from a type that contains unsubstituted type parameters [E0139]\n+//~^ ERROR: transmute called with differently sized types\n }\n \n fn main() { }"}, {"sha": "6e8126348da69c6a0e2fe2040b00ba9afeb448fa", "filename": "src/test/compile-fail/issue-32377.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Fissue-32377.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Fissue-32377.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32377.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+use std::marker::PhantomData;\n+\n+trait Foo {\n+    type Error;\n+}\n+\n+struct Bar<U: Foo> {\n+    stream: PhantomData<U::Error>,\n+}\n+\n+fn foo<U: Foo>(x: [usize; 2]) -> Bar<U> {\n+    unsafe { mem::transmute(x) }\n+    //~^ ERROR transmute called with differently sized types\n+}\n+\n+fn main() {}"}, {"sha": "50bcd53ecb82c55e6777dfc7471ddf535354848b", "filename": "src/test/compile-fail/transmute-from-fn-item-types-error.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+unsafe fn bar() {\n+    // Error, still, if the resulting type is not pointer-sized.\n+    mem::transmute::<_, u8>(main);\n+    //~^ ERROR transmute called with differently sized types\n+}\n+\n+fn main() {\n+    unsafe {\n+        bar();\n+    }\n+}"}, {"sha": "42c3cb7f181319b2badacdb429b49995f693ff09", "filename": "src/test/compile-fail/transmute-from-fn-item-types-lint.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -8,39 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(transmute_from_fn_item_types)]\n+\n use std::mem;\n \n unsafe fn foo() -> (isize, *const (), Option<fn()>) {\n     let i = mem::transmute(bar);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     let p = mem::transmute(foo);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     let of = mem::transmute(main);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     (i, p, of)\n }\n \n unsafe fn bar() {\n     mem::transmute::<_, *mut ()>(foo);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     mem::transmute::<_, fn()>(bar);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     // No error if a coercion would otherwise occur.\n     mem::transmute::<fn(), usize>(main);\n-\n-    // Error, still, if the resulting type is not pointer-sized.\n-    mem::transmute::<_, u8>(main);\n-    //~^ ERROR transmute called with differently sized types\n }\n \n fn main() {"}, {"sha": "b6e7e32663ec122669b3bd2e50cf257f9903afe7", "filename": "src/test/compile-fail/transmute-type-parameters.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d564d8c96bf538cc64a3eeca1fcc3c99569625/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs?ref=c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "patch": "@@ -13,23 +13,27 @@\n use std::mem::transmute;\n \n unsafe fn f<T>(x: T) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: T (size can vary) to isize\n }\n \n unsafe fn g<T>(x: (T, isize)) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: (T, isize) (size can vary because of T) to isize\n }\n \n unsafe fn h<T>(x: [T; 10]) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: [T; 10] (size can vary because of T) to isize\n }\n \n struct Bad<T> {\n     f: T,\n }\n \n unsafe fn i<T>(x: Bad<T>) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: Bad<T> (size can vary because of T) to isize\n }\n \n enum Worse<T> {\n@@ -38,11 +42,13 @@ enum Worse<T> {\n }\n \n unsafe fn j<T>(x: Worse<T>) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: Worse<T> (size can vary because of T) to isize\n }\n \n unsafe fn k<T>(x: Option<T>) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: std::option::Option<T> (size can vary because of T) to isize\n }\n \n fn main() {}"}]}