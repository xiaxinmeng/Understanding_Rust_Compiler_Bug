{"sha": "5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDJkNDBjMWY0OWVmODJlYmZmNGMzMGZkYWQ5ZjNiNmZkMzM5YzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-31T17:47:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-31T17:47:12Z"}, "message": "Auto merge of #51050 - symphorien:fstatat, r=kennytm\n\nstd::fs::DirEntry.metadata(): use fstatat instead of lstat when possible\n\nWhen reading a directory with `read_dir`, querying metadata for a resulting `DirEntry` is done by building the whole path and then `lstat`ing it, which requires the kernel to resolve the whole path. Instead, one\ncan use the file descriptor to the enumerated directory and use `fstatat`. This make the resolving step\nunnecessary.\nThis PR implements using `fstatat` on linux, android and emscripten.\n\n## Compatibility across targets\n`fstatat` is POSIX.\n* Linux >= 2.6.19 according to https://linux.die.net/man/2/fstatat\n* android according to https://android.googlesource.com/platform/bionic/+/master/libc/libc.map.txt#392\n* emscripten according to https://github.com/kripken/emscripten/blob/7f89560101843198787530731f40a65288f6f15f/system/include/libc/sys/stat.h#L76\n\nThe man page says \"A similar system call exists on Solaris.\" but I haven't found it.\n\n## Compatibility with old platforms\nThis was introduced with glibc 2.4 according to the man page. The only information I could find about the minimal version of glibc rust must support is this discussion https://internals.rust-lang.org/t/bumping-glibc-requirements-for-the-rust-toolchain/5111/10\nThe conclusion, if I understand correctly, is that currently rust supports glibc >= 2.3.4 but the \"real\" requirement is Centos 5 with glibc 2.5. This PR would make the minimal version 2.4, so this should be fine.\n\n## Benefit\nI did the following silly benchmark:\n```rust\nuse std::io;\nuse std::fs;\nuse std::os::linux::fs::MetadataExt;\nuse std::time::Instant;\n\nfn main() -> Result<(), io::Error> {\n    let mut n = 0;\n    let mut size = 0;\n    let start = Instant::now();\n    for entry in fs::read_dir(\"/nix/store/.links\")? {\n        let entry = entry?;\n        let stat = entry.metadata()?;\n        size += stat.st_size();\n        n+=1;\n    }\n    println!(\"{} files, size {}, time {:?}\", n, size, Instant::now().duration_since(start));\n    Ok(())\n}\n```\nOn warm cache, with current rust nightly:\n```\n1014099 files, size 76895290022, time Duration { secs: 2, nanos: 65832118 }\n```\n(between 2.1 and 2.9 seconds usually)\nWith this PR:\n```\n1014099 files, size 76895290022, time Duration { secs: 1, nanos: 581662953 }\n```\n(1.5 to 1.6 seconds usually).\n\napproximately 40% faster :)\n\nOn cold cache there is not much to gain because path lookup (which we spare) would have been a cache hit:\nBefore\n```\n1014099 files, size 76895290022, time Duration { secs: 391, nanos: 739874992 }\n```\nAfter\n```\n1014099 files, size 76895290022, time Duration { secs: 388, nanos: 431567396 }\n```\n## Testing\nThe tests were run on linux `x86_64`\n```\npython x.py test src/tools/tidy\n./x.py test src/libstd\n```\nand the above benchmark.\nI did not test any other target.", "tree": {"sha": "8515fd1199d67cc74b579cffe04c89276ea4791c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8515fd1199d67cc74b579cffe04c89276ea4791c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1", "html_url": "https://github.com/rust-lang/rust/commit/5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6de4ec679d7179251bef205427d52d093c40a787", "url": "https://api.github.com/repos/rust-lang/rust/commits/6de4ec679d7179251bef205427d52d093c40a787", "html_url": "https://github.com/rust-lang/rust/commit/6de4ec679d7179251bef205427d52d093c40a787"}, {"sha": "8dec03b71af22a160803c241b6812b8e54ee9671", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dec03b71af22a160803c241b6812b8e54ee9671", "html_url": "https://github.com/rust-lang/rust/commit/8dec03b71af22a160803c241b6812b8e54ee9671"}], "stats": {"total": 45, "additions": 33, "deletions": 12}, "files": [{"sha": "c4d94259bd6dba34d3d866d6d507c5a9927d2c24", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=5342d40c1f49ef82ebff4c30fdad9f3b6fd339c1", "patch": "@@ -25,6 +25,8 @@ use sys_common::{AsInner, FromInner};\n \n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"l4re\"))]\n use libc::{stat64, fstat64, lstat64, off64_t, ftruncate64, lseek64, dirent64, readdir64_r, open64};\n+#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n+use libc::{fstatat, dirfd};\n #[cfg(target_os = \"android\")]\n use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, lseek64,\n            dirent as dirent64, open as open64};\n@@ -48,20 +50,24 @@ pub struct FileAttr {\n     stat: stat64,\n }\n \n-pub struct ReadDir {\n+// all DirEntry's will have a reference to this struct\n+struct InnerReadDir {\n     dirp: Dir,\n-    root: Arc<PathBuf>,\n+    root: PathBuf,\n }\n \n+#[derive(Clone)]\n+pub struct ReadDir(Arc<InnerReadDir>);\n+\n struct Dir(*mut libc::DIR);\n \n unsafe impl Send for Dir {}\n unsafe impl Sync for Dir {}\n \n pub struct DirEntry {\n     entry: dirent64,\n-    root: Arc<PathBuf>,\n-    // We need to store an owned copy of the directory name\n+    dir: ReadDir,\n+    // We need to store an owned copy of the entry name\n     // on Solaris and Fuchsia because a) it uses a zero-length\n     // array to store the name, b) its lifetime between readdir\n     // calls is not guaranteed.\n@@ -207,7 +213,7 @@ impl fmt::Debug for ReadDir {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n         // Thus the result will be e g 'ReadDir(\"/home\")'\n-        fmt::Debug::fmt(&*self.root, f)\n+        fmt::Debug::fmt(&*self.0.root, f)\n     }\n }\n \n@@ -223,7 +229,7 @@ impl Iterator for ReadDir {\n                 // is safe to use in threaded applications and it is generally preferred\n                 // over the readdir_r(3C) function.\n                 super::os::set_errno(0);\n-                let entry_ptr = libc::readdir(self.dirp.0);\n+                let entry_ptr = libc::readdir(self.0.dirp.0);\n                 if entry_ptr.is_null() {\n                     // NULL can mean either the end is reached or an error occurred.\n                     // So we had to clear errno beforehand to check for an error now.\n@@ -240,7 +246,7 @@ impl Iterator for ReadDir {\n                     entry: *entry_ptr,\n                     name: ::slice::from_raw_parts(name as *const u8,\n                                                   namelen as usize).to_owned().into_boxed_slice(),\n-                    root: self.root.clone()\n+                    dir: self.clone()\n                 };\n                 if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n                     return Some(Ok(ret))\n@@ -254,11 +260,11 @@ impl Iterator for ReadDir {\n         unsafe {\n             let mut ret = DirEntry {\n                 entry: mem::zeroed(),\n-                root: self.root.clone()\n+                dir: self.clone(),\n             };\n             let mut entry_ptr = ptr::null_mut();\n             loop {\n-                if readdir64_r(self.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n+                if readdir64_r(self.0.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n                     return Some(Err(Error::last_os_error()))\n                 }\n                 if entry_ptr.is_null() {\n@@ -281,13 +287,27 @@ impl Drop for Dir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-        self.root.join(OsStr::from_bytes(self.name_bytes()))\n+        self.dir.0.root.join(OsStr::from_bytes(self.name_bytes()))\n     }\n \n     pub fn file_name(&self) -> OsString {\n         OsStr::from_bytes(self.name_bytes()).to_os_string()\n     }\n \n+    #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        let fd = cvt(unsafe {dirfd(self.dir.0.dirp.0)})?;\n+        let mut stat: stat64 = unsafe { mem::zeroed() };\n+        cvt(unsafe {\n+            fstatat(fd,\n+                    self.entry.d_name.as_ptr(),\n+                    &mut stat as *mut _ as *mut _,\n+                    libc::AT_SYMLINK_NOFOLLOW)\n+        })?;\n+        Ok(FileAttr { stat: stat })\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\")))]\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n         lstat(&self.path())\n     }\n@@ -664,14 +684,15 @@ impl fmt::Debug for File {\n }\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n-    let root = Arc::new(p.to_path_buf());\n+    let root = p.to_path_buf();\n     let p = cstr(p)?;\n     unsafe {\n         let ptr = libc::opendir(p.as_ptr());\n         if ptr.is_null() {\n             Err(Error::last_os_error())\n         } else {\n-            Ok(ReadDir { dirp: Dir(ptr), root: root })\n+            let inner = InnerReadDir { dirp: Dir(ptr), root };\n+            Ok(ReadDir(Arc::new(inner)))\n         }\n     }\n }"}]}