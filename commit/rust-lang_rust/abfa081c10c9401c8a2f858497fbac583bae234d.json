{"sha": "abfa081c10c9401c8a2f858497fbac583bae234d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZmEwODFjMTBjOTQwMWM4YTJmODU4NDk3ZmJhYzU4M2JhZTIzNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T20:09:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T20:09:15Z"}, "message": "Auto merge of #27999 - dotdash:lt, r=eddyb\n\nThe major change here is in the tiny commit at the end and makes it so that we no longer emit lifetime intrinsics for allocas for function arguments. They are live for the whole function anyway, so the intrinsics add no value. This makes the resulting IR more clear, and reduces the peak memory usage and LLVM times by about 1-4%, depending on the crate.\r\n\r\nThe remaining changes are just preparatory cleanups and fixes for missing lifetime intrinsics.", "tree": {"sha": "e637758d15335649838da2dd4dd5ff7f8e34ae87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e637758d15335649838da2dd4dd5ff7f8e34ae87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abfa081c10c9401c8a2f858497fbac583bae234d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abfa081c10c9401c8a2f858497fbac583bae234d", "html_url": "https://github.com/rust-lang/rust/commit/abfa081c10c9401c8a2f858497fbac583bae234d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abfa081c10c9401c8a2f858497fbac583bae234d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17b6fcd4589f678700c71bc88daabb5ba2d80bf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/17b6fcd4589f678700c71bc88daabb5ba2d80bf0", "html_url": "https://github.com/rust-lang/rust/commit/17b6fcd4589f678700c71bc88daabb5ba2d80bf0"}, {"sha": "9a15d664a67137028bb0d32eab56698b18356e6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a15d664a67137028bb0d32eab56698b18356e6d", "html_url": "https://github.com/rust-lang/rust/commit/9a15d664a67137028bb0d32eab56698b18356e6d"}], "stats": {"total": 140, "additions": 72, "deletions": 68}, "files": [{"sha": "e964afc7b699e76260b181ee4053beaf8a158766", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -875,19 +875,17 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               debug_loc: DebugLoc)\n                               -> Result<'blk, 'tcx> {\n     fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                               lhs: ValueRef,\n-                               rhs: ValueRef,\n+                               lhs_data: ValueRef,\n+                               lhs_len: ValueRef,\n+                               rhs_data: ValueRef,\n+                               rhs_len: ValueRef,\n                                rhs_t: Ty<'tcx>,\n                                debug_loc: DebugLoc)\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n-        let lhs_data = Load(cx, expr::get_dataptr(cx, lhs));\n-        let lhs_len = Load(cx, expr::get_meta(cx, lhs));\n-        let rhs_data = Load(cx, expr::get_dataptr(cx, rhs));\n-        let rhs_len = Load(cx, expr::get_meta(cx, rhs));\n         callee::trans_lang_call(cx, did, &[lhs_data, lhs_len, rhs_data, rhs_len], None, debug_loc)\n     }\n \n@@ -899,32 +897,38 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     match rhs_t.sty {\n         ty::TyRef(_, mt) => match mt.ty.sty {\n-            ty::TyStr => compare_str(cx, lhs, rhs, rhs_t, debug_loc),\n+            ty::TyStr => {\n+                let lhs_data = Load(cx, expr::get_dataptr(cx, lhs));\n+                let lhs_len = Load(cx, expr::get_meta(cx, lhs));\n+                let rhs_data = Load(cx, expr::get_dataptr(cx, rhs));\n+                let rhs_len = Load(cx, expr::get_meta(cx, rhs));\n+                compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n+            }\n             ty::TyArray(ty, _) | ty::TySlice(ty) => match ty.sty {\n                 ty::TyUint(ast::TyU8) => {\n                     // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n                     let pat_len = val_ty(rhs).element_type().array_length();\n                     let ty_str_slice = cx.tcx().mk_static_str();\n \n-                    let rhs_str = alloc_ty(cx, ty_str_slice, \"rhs_str\");\n-                    Store(cx, expr::get_dataptr(cx, rhs), expr::get_dataptr(cx, rhs_str));\n-                    Store(cx, C_uint(cx.ccx(), pat_len), expr::get_meta(cx, rhs_str));\n+                    let rhs_data = GEPi(cx, rhs, &[0, 0]);\n+                    let rhs_len = C_uint(cx.ccx(), pat_len);\n \n-                    let lhs_str;\n+                    let lhs_data;\n+                    let lhs_len;\n                     if val_ty(lhs) == val_ty(rhs) {\n                         // Both the discriminant and the pattern are thin pointers\n-                        lhs_str = alloc_ty(cx, ty_str_slice, \"lhs_str\");\n-                        Store(cx, expr::get_dataptr(cx, lhs), expr::get_dataptr(cx, lhs_str));\n-                        Store(cx, C_uint(cx.ccx(), pat_len), expr::get_meta(cx, lhs_str));\n-                    }\n-                    else {\n+                        lhs_data = GEPi(cx, lhs, &[0, 0]);\n+                        lhs_len = C_uint(cx.ccx(), pat_len);\n+                    } else {\n                         // The discriminant is a fat pointer\n                         let llty_str_slice = type_of::type_of(cx.ccx(), ty_str_slice).ptr_to();\n-                        lhs_str = PointerCast(cx, lhs, llty_str_slice);\n+                        let lhs_str = PointerCast(cx, lhs, llty_str_slice);\n+                        lhs_data = Load(cx, expr::get_dataptr(cx, lhs_str));\n+                        lhs_len = Load(cx, expr::get_meta(cx, lhs_str));\n                     }\n \n-                    compare_str(cx, lhs_str, rhs_str, rhs_t, debug_loc)\n+                    compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n                 },\n                 _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n             },\n@@ -1192,8 +1196,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let unsized_ty = def.struct_variant().fields.last().map(|field| {\n                     monomorphize::field_ty(bcx.tcx(), substs, field)\n                 }).unwrap();\n-                let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n-                let scratch = alloca_no_lifetime(bcx, llty, \"__struct_field_fat_ptr\");\n+                let scratch = alloc_ty(bcx, unsized_ty, \"__struct_field_fat_ptr\");\n                 let data = adt::trans_field_ptr(bcx, &*repr, struct_val, 0, arg_count);\n                 let len = Load(bcx, expr::get_meta(bcx, val.val));\n                 Store(bcx, data, expr::get_dataptr(bcx, scratch));\n@@ -1520,12 +1523,8 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n         match bm {\n             ast::BindByValue(_) if !moves_by_default || reassigned =>\n             {\n-                llmatch = alloca_no_lifetime(bcx,\n-                                             llvariable_ty.ptr_to(),\n-                                             \"__llmatch\");\n-                let llcopy = alloca_no_lifetime(bcx,\n-                                                llvariable_ty,\n-                                                &bcx.name(name));\n+                llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n+                let llcopy = alloca(bcx, llvariable_ty, &bcx.name(name));\n                 trmode = if moves_by_default {\n                     TrByMoveIntoCopy(llcopy)\n                 } else {\n@@ -1536,15 +1535,11 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n-                llmatch = alloca_no_lifetime(bcx,\n-                                             llvariable_ty.ptr_to(),\n-                                             &bcx.name(name));\n+                llmatch = alloca(bcx, llvariable_ty.ptr_to(), &bcx.name(name));\n                 trmode = TrByMoveRef;\n             }\n             ast::BindByRef(_) => {\n-                llmatch = alloca_no_lifetime(bcx,\n-                                 llvariable_ty,\n-                                 &bcx.name(name));\n+                llmatch = alloca(bcx, llvariable_ty, &bcx.name(name));\n                 trmode = TrByRef;\n             }\n         };\n@@ -1745,6 +1740,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n+    call_lifetime_start(bcx, llval);\n     let bcx = populate(arg, bcx, datum);\n     bcx.fcx.schedule_lifetime_end(cleanup_scope, llval);\n     bcx.fcx.schedule_drop_mem(cleanup_scope, llval, var_ty, lvalue.dropflag_hint(bcx));"}, {"sha": "28047ee5812e7b072ae9cff6f6bef6d7fe8cf6af", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -1020,17 +1020,10 @@ pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) ->\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n     assert!(!t.has_param_types());\n-    let val = alloca(bcx, ty, name);\n-    return val;\n+    alloca(bcx, ty, name)\n }\n \n pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n-    let p = alloca_no_lifetime(cx, ty, name);\n-    call_lifetime_start(cx, p);\n-    p\n-}\n-\n-pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1742,7 +1735,9 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         expr::SaveIn(d) => d,\n         expr::Ignore => {\n             if !type_is_zero_size(ccx, result_ty) {\n-                alloc_ty(bcx, result_ty, \"constructor_result\")\n+                let llresult = alloc_ty(bcx, result_ty, \"constructor_result\");\n+                call_lifetime_start(bcx, llresult);\n+                llresult\n             } else {\n                 C_undef(type_of::type_of(ccx, result_ty).ptr_to())\n             }"}, {"sha": "266038990ff139adde6b6313ca7c2563781b7fdf", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -725,7 +725,9 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                     let llty = type_of::type_of(ccx, ret_ty);\n                     Some(common::C_undef(llty.ptr_to()))\n                 } else {\n-                    Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n+                    let llresult = alloc_ty(bcx, ret_ty, \"__llret\");\n+                    call_lifetime_start(bcx, llresult);\n+                    Some(llresult)\n                 }\n             } else {\n                 None"}, {"sha": "d226bc3f155df10c8b33e18bcbe3a86bffa9422e", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -730,8 +730,9 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                         let prev_bcx = self.new_block(true, \"resume\", None);\n                         let personality = self.personality.get().expect(\n                             \"create_landing_pad() should have set this\");\n-                        build::Resume(prev_bcx,\n-                                      build::Load(prev_bcx, personality));\n+                        let lp = build::Load(prev_bcx, personality);\n+                        base::call_lifetime_end(prev_bcx, personality);\n+                        build::Resume(prev_bcx, lp);\n                         prev_llbb = prev_bcx.llbb;\n                         break;\n                     }\n@@ -883,6 +884,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n             }\n             None => {\n                 let addr = base::alloca(pad_bcx, common::val_ty(llretval), \"\");\n+                base::call_lifetime_start(pad_bcx, addr);\n                 self.personality.set(Some(addr));\n                 build::Store(pad_bcx, llretval, addr);\n             }"}, {"sha": "80e618861073e77b3dcba1411c3a80ee6dd3c621", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                         output: ty::FnOutput<'tcx>,\n                         name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n-            base::alloca_no_lifetime(bcx, match output {\n+            base::alloca(bcx, match output {\n                 ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n                 ty::FnDiverging => Type::void(bcx.ccx())\n             }, name)"}, {"sha": "a57b5d1bbde26d75fa593c251712e049c1451646", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -101,7 +101,6 @@ use trans::cleanup;\n use trans::cleanup::{CleanupMethods, DropHintDatum, DropHintMethods};\n use trans::expr;\n use trans::tvec;\n-use trans::type_of;\n use middle::ty::Ty;\n \n use std::fmt;\n@@ -302,12 +301,10 @@ pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                               -> DatumBlock<'blk, 'tcx, Lvalue> where\n     F: FnOnce(A, Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n {\n-    let llty = type_of::type_of(bcx.ccx(), ty);\n-    let scratch = alloca(bcx, llty, name);\n+    let scratch = alloc_ty(bcx, ty, name);\n \n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n-    bcx.fcx.schedule_lifetime_end(scope, scratch);\n     bcx.fcx.schedule_drop_mem(scope, scratch, ty, None);\n \n     DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue::new(\"datum::lvalue_scratch_datum\")))\n@@ -322,8 +319,8 @@ pub fn rvalue_scratch_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         ty: Ty<'tcx>,\n                                         name: &str)\n                                         -> Datum<'tcx, Rvalue> {\n-    let llty = type_of::type_of(bcx.ccx(), ty);\n-    let scratch = alloca(bcx, llty, name);\n+    let scratch = alloc_ty(bcx, ty, name);\n+    call_lifetime_start(bcx, scratch);\n     Datum::new(scratch, ty, Rvalue::new(ByRef))\n }\n \n@@ -500,7 +497,12 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n             ByValue => {\n                 lvalue_scratch_datum(\n                     bcx, self.ty, name, scope, self,\n-                    |this, bcx, llval| this.store_to(bcx, llval))\n+                    |this, bcx, llval| {\n+                        call_lifetime_start(bcx, llval);\n+                        let bcx = this.store_to(bcx, llval);\n+                        bcx.fcx.schedule_lifetime_end(scope, llval);\n+                        bcx\n+                    })\n             }\n         }\n     }"}, {"sha": "20d189a5cd75ed005a5b2f540d924f21144dd556", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -246,9 +246,8 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // Maybe just get the value directly, instead of loading it?\n             immediate_rvalue(load_ty(bcx, global, const_ty), const_ty)\n         } else {\n-            let llty = type_of::type_of(bcx.ccx(), const_ty);\n-            // HACK(eddyb) get around issues with lifetime intrinsics.\n-            let scratch = alloca_no_lifetime(bcx, llty, \"const\");\n+            let scratch = alloc_ty(bcx, const_ty, \"const\");\n+            call_lifetime_start(bcx, scratch);\n             let lldest = if !const_ty.is_structural() {\n                 // Cast pointer to slot, because constants have different types.\n                 PointerCast(bcx, scratch, val_ty(global))\n@@ -403,10 +402,9 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     datum.to_rvalue_datum(bcx, \"__coerce_source\"));\n \n                 let target = bcx.monomorphize(&target);\n-                let llty = type_of::type_of(bcx.ccx(), target);\n \n-                // HACK(eddyb) get around issues with lifetime intrinsics.\n-                let scratch = alloca_no_lifetime(bcx, llty, \"__coerce_target\");\n+                let scratch = alloc_ty(bcx, target, \"__coerce_target\");\n+                call_lifetime_start(bcx, scratch);\n                 let target_datum = Datum::new(scratch, target,\n                                               Rvalue::new(ByRef));\n                 bcx = coerce_unsized(bcx, expr.span, source_datum, target_datum);\n@@ -1440,7 +1438,11 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // temporary stack slot\n     let addr = match dest {\n         SaveIn(pos) => pos,\n-        Ignore => alloc_ty(bcx, ty, \"temp\"),\n+        Ignore => {\n+            let llresult = alloc_ty(bcx, ty, \"temp\");\n+            call_lifetime_start(bcx, llresult);\n+            llresult\n+        }\n     };\n \n     // This scope holds intermediates that must be cleaned should"}, {"sha": "4949539c136d0cf62930b669ffc6298c24339d3a", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -296,10 +296,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n         if !rust_indirect {\n-            let scratch =\n-                base::alloca(bcx,\n-                             type_of::type_of(ccx, passed_arg_tys[i]),\n-                             \"__arg\");\n+            let scratch = base::alloc_ty(bcx, passed_arg_tys[i], \"__arg\");\n             if type_is_fat_ptr(ccx.tcx(), passed_arg_tys[i]) {\n                 Store(bcx, llargs_rust[i + offset], expr::get_dataptr(bcx, scratch));\n                 Store(bcx, llargs_rust[i + offset + 1], expr::get_meta(bcx, scratch));\n@@ -432,6 +429,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // - Truncating foreign type to correct integral type and then\n             //   bitcasting to the struct type yields invalid cast errors.\n             let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n+            base::call_lifetime_start(bcx, llscratch);\n             Store(bcx, llforeign_retval, llscratch);\n             let llscratch_i8 = BitCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n             let llretptr_i8 = BitCast(bcx, llretptr, Type::i8(ccx).ptr_to());\n@@ -442,6 +440,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"llrust_size={}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n                               C_uint(ccx, llrust_size), llalign as u32);\n+            base::call_lifetime_end(bcx, llscratch);\n         }\n     }\n "}, {"sha": "40a290a27150e5214f85cd35a23df538a7bf39f9", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -184,9 +184,12 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      skip_dtor: bool)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n-    let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n+    let vp = alloc_ty(bcx, t, \"\");\n+    call_lifetime_start(bcx, vp);\n     store_ty(bcx, v, vp, t);\n-    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor, None)\n+    let bcx = drop_ty_core(bcx, vp, t, debug_loc, skip_dtor, None);\n+    call_lifetime_end(bcx, vp);\n+    bcx\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {"}, {"sha": "aab22290efed4f2ce50328edb0d1ff66fb745af9", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -393,7 +393,9 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         expr::SaveIn(d) => d,\n         expr::Ignore => {\n             if !type_is_zero_size(ccx, ret_ty) {\n-                alloc_ty(bcx, ret_ty, \"intrinsic_result\")\n+                let llresult = alloc_ty(bcx, ret_ty, \"intrinsic_result\");\n+                call_lifetime_start(bcx, llresult);\n+                llresult\n             } else {\n                 C_undef(llret_ty.ptr_to())\n             }\n@@ -964,6 +966,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match dest {\n         expr::Ignore => {\n             bcx = glue::drop_ty(bcx, llresult, ret_ty, call_debug_location);\n+            call_lifetime_end(bcx, llresult);\n         }\n         expr::SaveIn(_) => {}\n     }"}, {"sha": "019c38869b27d9231886836779603d8a4ea3886f", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfa081c10c9401c8a2f858497fbac583bae234d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=abfa081c10c9401c8a2f858497fbac583bae234d", "patch": "@@ -106,11 +106,11 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n \n     let fixed_ty = bcx.tcx().mk_array(vt.unit_ty, count);\n-    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty);\n \n     // Always create an alloca even if zero-sized, to preserve\n     // the non-null invariant of the inner slice ptr\n-    let llfixed = base::alloca(bcx, llfixed_ty, \"\");\n+    let llfixed = base::alloc_ty(bcx, fixed_ty, \"\");\n+    call_lifetime_start(bcx, llfixed);\n \n     if count > 0 {\n         // Arrange for the backing array to be cleaned up."}]}