{"sha": "b24929044877b0a3710f40b3cf27b61d79b5d5df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNDkyOTA0NDg3N2IwYTM3MTBmNDBiM2NmMjdiNjFkNzliNWQ1ZGY=", "commit": {"author": {"name": "Mateusz Gacek", "email": "96mateusz.gacek@gmail.com", "date": "2021-05-13T15:09:59Z"}, "committer": {"name": "Mateusz Gacek", "email": "96mateusz.gacek@gmail.com", "date": "2021-05-13T15:09:59Z"}, "message": "needless_collect: use snippet_with_applicability\n\n+ small code refactor - using early returns.", "tree": {"sha": "60790bcdad56b31df518f9ee191484bb4ff370e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60790bcdad56b31df518f9ee191484bb4ff370e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b24929044877b0a3710f40b3cf27b61d79b5d5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b24929044877b0a3710f40b3cf27b61d79b5d5df", "html_url": "https://github.com/rust-lang/rust/commit/b24929044877b0a3710f40b3cf27b61d79b5d5df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b24929044877b0a3710f40b3cf27b61d79b5d5df/comments", "author": {"login": "mgacek8", "id": 24357739, "node_id": "MDQ6VXNlcjI0MzU3NzM5", "avatar_url": "https://avatars.githubusercontent.com/u/24357739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgacek8", "html_url": "https://github.com/mgacek8", "followers_url": "https://api.github.com/users/mgacek8/followers", "following_url": "https://api.github.com/users/mgacek8/following{/other_user}", "gists_url": "https://api.github.com/users/mgacek8/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgacek8/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgacek8/subscriptions", "organizations_url": "https://api.github.com/users/mgacek8/orgs", "repos_url": "https://api.github.com/users/mgacek8/repos", "events_url": "https://api.github.com/users/mgacek8/events{/privacy}", "received_events_url": "https://api.github.com/users/mgacek8/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mgacek8", "id": 24357739, "node_id": "MDQ6VXNlcjI0MzU3NzM5", "avatar_url": "https://avatars.githubusercontent.com/u/24357739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgacek8", "html_url": "https://github.com/mgacek8", "followers_url": "https://api.github.com/users/mgacek8/followers", "following_url": "https://api.github.com/users/mgacek8/following{/other_user}", "gists_url": "https://api.github.com/users/mgacek8/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgacek8/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgacek8/subscriptions", "organizations_url": "https://api.github.com/users/mgacek8/orgs", "repos_url": "https://api.github.com/users/mgacek8/repos", "events_url": "https://api.github.com/users/mgacek8/events{/privacy}", "received_events_url": "https://api.github.com/users/mgacek8/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "171789eb4526fe4ef65514f26056ca4551915cca", "url": "https://api.github.com/repos/rust-lang/rust/commits/171789eb4526fe4ef65514f26056ca4551915cca", "html_url": "https://github.com/rust-lang/rust/commit/171789eb4526fe4ef65514f26056ca4551915cca"}], "stats": {"total": 37, "additions": 18, "deletions": 19}, "files": [{"sha": "d34067808889c567805bd9174d4aa4934f41773b", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b24929044877b0a3710f40b3cf27b61d79b5d5df/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24929044877b0a3710f40b3cf27b61d79b5d5df/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=b24929044877b0a3710f40b3cf27b61d79b5d5df", "patch": "@@ -1,6 +1,6 @@\n use super::NEEDLESS_COLLECT;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{is_trait_method, path_to_local_id};\n@@ -28,46 +28,45 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         if let Some(ty) = cx.typeck_results().node_type_opt(ty.hir_id);\n         then {\n-            let is_empty_sugg = Some(\"next().is_none()\".to_string());\n+            let mut applicability = Applicability::MachineApplicable;\n+            let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = &*method.ident.name.as_str();\n             let sugg = if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                         is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                         is_type_diagnostic_item(cx, ty, sym::LinkedList) ||\n                         is_type_diagnostic_item(cx, ty, sym::BinaryHeap) {\n                 match method_name {\n-                    \"len\" => Some(\"count()\".to_string()),\n+                    \"len\" => \"count()\".to_string(),\n                     \"is_empty\" => is_empty_sugg,\n                     \"contains\" => {\n-                        let contains_arg = snippet(cx, args[1].span, \"??\");\n+                        let contains_arg = snippet_with_applicability(cx, args[1].span, \"??\", &mut applicability);\n                         let (arg, pred) = contains_arg\n                             .strip_prefix('&')\n                             .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                        Some(format!(\"any(|{}| x == {})\", arg, pred))\n+                        format!(\"any(|{}| x == {})\", arg, pred)\n                     }\n-                    _ => None,\n+                    _ => return,\n                 }\n             }\n             else if is_type_diagnostic_item(cx, ty, sym::BTreeMap) ||\n                 is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n                 match method_name {\n                     \"is_empty\" => is_empty_sugg,\n-                    _ => None,\n+                    _ => return,\n                 }\n             }\n             else {\n-                None\n+                return;\n             };\n-            if let Some(sugg) = sugg {\n-                span_lint_and_sugg(\n-                    cx,\n-                    NEEDLESS_COLLECT,\n-                    method0_span.with_hi(expr.span.hi()),\n-                    NEEDLESS_COLLECT_MSG,\n-                    \"replace with\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_COLLECT,\n+                method0_span.with_hi(expr.span.hi()),\n+                NEEDLESS_COLLECT_MSG,\n+                \"replace with\",\n+                sugg,\n+                applicability,\n+            );\n         }\n     }\n }"}]}