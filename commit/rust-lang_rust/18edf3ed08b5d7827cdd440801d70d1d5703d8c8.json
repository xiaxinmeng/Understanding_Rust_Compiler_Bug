{"sha": "18edf3ed08b5d7827cdd440801d70d1d5703d8c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZWRmM2VkMDhiNWQ3ODI3Y2RkNDQwODAxZDcwZDFkNTcwM2Q4Yzg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:58:32Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T02:01:39Z"}, "message": "typeck/expr.rs: move some check_expr_*s here.", "tree": {"sha": "6b3d8d41fed0af728542a59ed5706c2a145af8ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b3d8d41fed0af728542a59ed5706c2a145af8ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18edf3ed08b5d7827cdd440801d70d1d5703d8c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18edf3ed08b5d7827cdd440801d70d1d5703d8c8", "html_url": "https://github.com/rust-lang/rust/commit/18edf3ed08b5d7827cdd440801d70d1d5703d8c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18edf3ed08b5d7827cdd440801d70d1d5703d8c8/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a551fe08ef404ec0944aa91e3a368dc14e97153a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a551fe08ef404ec0944aa91e3a368dc14e97153a", "html_url": "https://github.com/rust-lang/rust/commit/a551fe08ef404ec0944aa91e3a368dc14e97153a"}], "stats": {"total": 162, "additions": 85, "deletions": 77}, "files": [{"sha": "da90988814ba2c2ff228ed5ff808b01a179a70bc", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/18edf3ed08b5d7827cdd440801d70d1d5703d8c8/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18edf3ed08b5d7827cdd440801d70d1d5703d8c8/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=18edf3ed08b5d7827cdd440801d70d1d5703d8c8", "patch": "@@ -34,6 +34,90 @@ use rustc::ty::subst::InternalSubsts;\n use rustc::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        self.demand_eqtype(expr.span, expected, ty);\n+    }\n+\n+    pub fn check_expr_has_type_or_error(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n+        self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n+    }\n+\n+    fn check_expr_meets_expectation_or_error(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n+        let mut ty = self.check_expr_with_expectation(expr, expected);\n+\n+        // While we don't allow *arbitrary* coercions here, we *do* allow\n+        // coercions from ! to `expected`.\n+        if ty.is_never() {\n+            assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n+                    \"expression with never type wound up being adjusted\");\n+            let adj_ty = self.next_diverging_ty_var(\n+                TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::AdjustmentType,\n+                    span: expr.span,\n+                },\n+            );\n+            self.apply_adjustments(expr, vec![Adjustment {\n+                kind: Adjust::NeverToAny,\n+                target: adj_ty\n+            }]);\n+            ty = adj_ty;\n+        }\n+\n+        if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n+            let expr = match &expr.node {\n+                ExprKind::DropTemps(expr) => expr,\n+                _ => expr,\n+            };\n+            // Error possibly reported in `check_assign` so avoid emitting error again.\n+            err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n+        }\n+        ty\n+    }\n+\n+    pub(super) fn check_expr_coercable_to_type(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        // checks don't need two phase\n+        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n+    }\n+\n+    pub(super) fn check_expr_with_hint(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        self.check_expr_with_expectation(expr, ExpectHasType(expected))\n+    }\n+\n+    pub(super) fn check_expr_with_expectation(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n+    }\n+\n+    pub(super) fn check_expr(&self, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+        self.check_expr_with_expectation(expr, NoExpectation)\n+    }\n+\n+    pub(super) fn check_expr_with_needs(&self, expr: &'tcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n+        self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n+    }\n+\n     /// Invariant:\n     /// If an expression has any sub-expressions that result in a type error,\n     /// inspecting that expression's type with `ty.references_error()` will return\n@@ -44,7 +128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n-    pub(super) fn check_expr_with_expectation_and_needs(\n+    fn check_expr_with_expectation_and_needs(\n         &self,\n         expr: &'tcx hir::Expr,\n         expected: Expectation<'tcx>,"}, {"sha": "f5905f9a497c261ce5fecd22efaebcc50198e6e3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/18edf3ed08b5d7827cdd440801d70d1d5703d8c8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18edf3ed08b5d7827cdd440801d70d1d5703d8c8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=18edf3ed08b5d7827cdd440801d70d1d5703d8c8", "patch": "@@ -3197,82 +3197,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n-        let ty = self.check_expr_with_hint(expr, expected);\n-        self.demand_eqtype(expr.span, expected, ty);\n-    }\n-\n-    pub fn check_expr_has_type_or_error(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n-        self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n-    }\n-\n-    fn check_expr_meets_expectation_or_error(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-    ) -> Ty<'tcx> {\n-        let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n-        let mut ty = self.check_expr_with_expectation(expr, expected);\n-\n-        // While we don't allow *arbitrary* coercions here, we *do* allow\n-        // coercions from ! to `expected`.\n-        if ty.is_never() {\n-            assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n-                    \"expression with never type wound up being adjusted\");\n-            let adj_ty = self.next_diverging_ty_var(\n-                TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::AdjustmentType,\n-                    span: expr.span,\n-                },\n-            );\n-            self.apply_adjustments(expr, vec![Adjustment {\n-                kind: Adjust::NeverToAny,\n-                target: adj_ty\n-            }]);\n-            ty = adj_ty;\n-        }\n-\n-        if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            let expr = match &expr.node {\n-                ExprKind::DropTemps(expr) => expr,\n-                _ => expr,\n-            };\n-            // Error possibly reported in `check_assign` so avoid emitting error again.\n-            err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n-        }\n-        ty\n-    }\n-\n-    fn check_expr_coercable_to_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.check_expr_with_hint(expr, expected);\n-        // checks don't need two phase\n-        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n-    }\n-\n-    fn check_expr_with_hint(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_with_expectation(expr, ExpectHasType(expected))\n-    }\n-\n-    fn check_expr_with_expectation(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-    ) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n-    }\n-\n-    fn check_expr(&self, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n-        self.check_expr_with_expectation(expr, NoExpectation)\n-    }\n-\n-    fn check_expr_with_needs(&self, expr: &'tcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n-    }\n-\n     // Determine the `Self` type, using fresh variables for all variables\n     // declared on the impl declaration e.g., `impl<A,B> for Vec<(A,B)>`\n     // would return `($0, $1)` where `$0` and `$1` are freshly instantiated type"}]}