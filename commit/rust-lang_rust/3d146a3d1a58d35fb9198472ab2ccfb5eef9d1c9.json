{"sha": "3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMTQ2YTNkMWE1OGQzNWZiOTE5ODQ3MmFiMmNjZmI1ZWVmOWQxYzk=", "commit": {"author": {"name": "Phoebe Bell", "email": "minaphoebebell@gmail.com", "date": "2020-02-10T00:45:29Z"}, "committer": {"name": "Phoebe Bell", "email": "minaphoebebell@gmail.com", "date": "2020-03-06T03:47:58Z"}, "message": "Document unsafe blocks in core::fmt", "tree": {"sha": "4e8aa619a034b3e713b4ba9b4842d75fd0e9d9d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8aa619a034b3e713b4ba9b4842d75fd0e9d9d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "html_url": "https://github.com/rust-lang/rust/commit/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9/comments", "author": {"login": "foeb", "id": 16327576, "node_id": "MDQ6VXNlcjE2MzI3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16327576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/foeb", "html_url": "https://github.com/foeb", "followers_url": "https://api.github.com/users/foeb/followers", "following_url": "https://api.github.com/users/foeb/following{/other_user}", "gists_url": "https://api.github.com/users/foeb/gists{/gist_id}", "starred_url": "https://api.github.com/users/foeb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/foeb/subscriptions", "organizations_url": "https://api.github.com/users/foeb/orgs", "repos_url": "https://api.github.com/users/foeb/repos", "events_url": "https://api.github.com/users/foeb/events{/privacy}", "received_events_url": "https://api.github.com/users/foeb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "foeb", "id": 16327576, "node_id": "MDQ6VXNlcjE2MzI3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16327576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/foeb", "html_url": "https://github.com/foeb", "followers_url": "https://api.github.com/users/foeb/followers", "following_url": "https://api.github.com/users/foeb/following{/other_user}", "gists_url": "https://api.github.com/users/foeb/gists{/gist_id}", "starred_url": "https://api.github.com/users/foeb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/foeb/subscriptions", "organizations_url": "https://api.github.com/users/foeb/orgs", "repos_url": "https://api.github.com/users/foeb/repos", "events_url": "https://api.github.com/users/foeb/events{/privacy}", "received_events_url": "https://api.github.com/users/foeb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c79346a3e7ddbb5fb417810f226ac5a9209007", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c79346a3e7ddbb5fb417810f226ac5a9209007", "html_url": "https://github.com/rust-lang/rust/commit/d3c79346a3e7ddbb5fb417810f226ac5a9209007"}], "stats": {"total": 51, "additions": 45, "deletions": 6}, "files": [{"sha": "52d8349bc9a8770567f4079c2651b205bdaeab73", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "patch": "@@ -2,8 +2,6 @@ use crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n \n-// ignore-tidy-undocumented-unsafe\n-\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n@@ -16,6 +14,7 @@ fn float_to_decimal_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n@@ -48,6 +47,7 @@ fn float_to_decimal_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n@@ -103,6 +103,7 @@ fn float_to_exponential_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n@@ -132,6 +133,7 @@ fn float_to_exponential_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();"}, {"sha": "a7b34e5f2f1c5db498182ba3de856857a440414b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "patch": "@@ -1,7 +1,5 @@\n //! Utilities for formatting and printing strings.\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n@@ -271,6 +269,14 @@ impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n+        // SAFETY: `mem::transmute(x)` is safe because\n+        //     1. `&'b T` keeps the lifetime it originated with `'b`\n+        //              (so as to not have an unbounded lifetime)\n+        //     2. `&'b T` and `&'b Void` have the same memory layout\n+        //              (when `T` is `Sized`, as it is here)\n+        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n+        // and `fn(&Void, &mut Formatter<'_>) -> Result` have the same ABI\n+        // (as long as `T` is `Sized`)\n         unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n     }\n \n@@ -1389,6 +1395,14 @@ impl<'a> Formatter<'a> {\n \n     fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n         fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n+            // SAFETY: This is used for `flt2dec::Part::Num` and `flt2dec::Part::Copy`.\n+            // It's safe to use for `flt2dec::Part::Num` since every char `c` is between\n+            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n+            // It's also probably safe in practice to use for `flt2dec::Part::Copy(buf)`\n+            // since `buf` should be plain ASCII, but it's possible for someone to pass\n+            // in a bad value for `buf` into `flt2dec::to_shortest_str` since it is a\n+            // public function.\n+            // FIXME: Determine whether this could result in UB.\n             buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n         }\n "}, {"sha": "7d77e33d743785f1c6f795b51659d411865b684a", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "patch": "@@ -1,7 +1,5 @@\n //! Integer and floating-point number formatting\n \n-// ignore-tidy-undocumented-unsafe\n-\n use crate::fmt;\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n@@ -84,6 +82,8 @@ trait GenericRadix {\n             }\n         }\n         let buf = &buf[curr..];\n+        // SAFETY: The only chars in `buf` are created by `Self::digit` which are assumed to be\n+        // valid UTF-8\n         let buf = unsafe {\n             str::from_utf8_unchecked(slice::from_raw_parts(MaybeUninit::first_ptr(buf), buf.len()))\n         };\n@@ -189,11 +189,19 @@ static DEC_DIGITS_LUT: &[u8; 200] = b\"0001020304050607080910111213141516171819\\\n macro_rules! impl_Display {\n     ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n         fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n             let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n             let mut curr = buf.len() as isize;\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n+            // SAFETY: Since `d1` and `d2` are always less than or equal to `198`, we\n+            // can copy from `lut_ptr[d1..d1 + 1]` and `lut_ptr[d2..d2 + 1]`. To show\n+            // that it's OK to copy into `buf_ptr`, notice that at the beginning\n+            // `curr == buf.len() == 39 > log(n)` since `n < 2^128 < 10^39`, and at\n+            // each step this is kept the same as `n` is divided. Since `n` is always\n+            // non-negative, this means that `curr > 0` so `buf_ptr[curr..curr + 1]`\n+            // is safe to access.\n             unsafe {\n                 // need at least 16 bits for the 4-characters-at-a-time to work.\n                 assert!(crate::mem::size_of::<$u>() >= 2);\n@@ -206,6 +214,10 @@ macro_rules! impl_Display {\n                     let d1 = (rem / 100) << 1;\n                     let d2 = (rem % 100) << 1;\n                     curr -= 4;\n+\n+                    // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n+                    // otherwise `curr < 0`. But then `n` was originally at least `10000^10`\n+                    // which is `10^40 > 2^128 > n`.\n                     ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                     ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                 }\n@@ -232,6 +244,8 @@ macro_rules! impl_Display {\n                 }\n             }\n \n+            // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n+            // UTF-8 since `DEC_DIGITS_LUT` is\n             let buf_slice = unsafe {\n                 str::from_utf8_unchecked(\n                     slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n@@ -304,6 +318,8 @@ macro_rules! impl_Exp {\n             };\n \n             // 39 digits (worst case u128) + . = 40\n+            // Since `curr` always decreases by the number of digits copied, this means\n+            // that `curr >= 0`.\n             let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n             let mut curr = buf.len() as isize; //index for buf\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n@@ -313,6 +329,8 @@ macro_rules! impl_Exp {\n             while n >= 100 {\n                 let d1 = ((n % 100) as isize) << 1;\n                 curr -= 2;\n+                // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n+                // `DEC_DIGITS_LUT` has a length of 200.\n                 unsafe {\n                     ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                 }\n@@ -324,6 +342,7 @@ macro_rules! impl_Exp {\n             // decode second-to-last character\n             if n >= 10 {\n                 curr -= 1;\n+                // SAFETY: Safe since `40 > curr >= 0` (see comment)\n                 unsafe {\n                     *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n                 }\n@@ -333,11 +352,13 @@ macro_rules! impl_Exp {\n             // add decimal point iff >1 mantissa digit will be printed\n             if exponent != trailing_zeros || added_precision != 0 {\n                 curr -= 1;\n+                // SAFETY: Safe since `40 > curr >= 0`\n                 unsafe {\n                     *buf_ptr.offset(curr) = b'.';\n                 }\n             }\n \n+            // SAFETY: Safe since `40 > curr >= 0`\n             let buf_slice = unsafe {\n                 // decode last character\n                 curr -= 1;\n@@ -350,6 +371,8 @@ macro_rules! impl_Exp {\n             // stores 'e' (or 'E') and the up to 2-digit exponent\n             let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];\n             let exp_ptr = MaybeUninit::first_ptr_mut(&mut exp_buf);\n+            // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n+            // is contained within `exp_buf` since `len <= 3`.\n             let exp_slice = unsafe {\n                 *exp_ptr.offset(0) = if upper {b'E'} else {b'e'};\n                 let len = if exponent < 10 {"}]}