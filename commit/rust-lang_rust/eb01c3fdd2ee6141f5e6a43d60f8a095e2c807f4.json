{"sha": "eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMDFjM2ZkZDJlZTYxNDFmNWU2YTQzZDYwZjhhMDk1ZTJjODA3ZjQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-07-13T15:25:17Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-07-14T15:39:19Z"}, "message": "Use enum instead of boolean", "tree": {"sha": "3d47e53b2ff6c7a0973463d2e63a1c85e852925f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d47e53b2ff6c7a0973463d2e63a1c85e852925f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJgBAABCABKFiEEvpMjxK4/cnPNfesJHVy0/Fl8MAQFAllo5acsHGdpdC1uby1y\nZXBseS05ODc5MTY1NzE2NDc5NDEzMTMxQG9saS1vYmsuZGUACgkQHVy0/Fl8MASe\nkBAAvfE20q9EYmiKmuXNm8oGfqGXYQKXf04AYAWZ5imuGiJyGQLHxLrFFS6DqAOV\n8XKGMpuEfERnUaIf4EmGhJDQNGXU1QcJ8tbaPdzsLgxpKga0GqWpor29CcIkqhom\nOuI4fE9OeV6NXRGBsCL/cI72BEkjJC/SwTbJph8hkuwcKGh6lLn5Wakp3pUVMilN\nV6bipyKUYSGaG0ijZxmdztz2RcdQ43G4wQzurrvUrWKHcNnOHg1hq9kZgBTd/iam\ntZvXkq8MyskTbkQ+Q9AH6P20UFyZfvBIemGvy7o04cmRF6rd2/hF4CckGXC+5AhL\nH8TPmfK8gBeYSaOoTFN7XjavGglJcQTuJOx1Q/axgFBAZCUV+ZTyaGyLKMgOsc0v\nJc/tQ4OyyMWezCcoxssi/Ts4p6YDT+KQXPkPdeVACFf8w+I3uTE2oaIAqANMjaHk\nnb+5aGw6GHOeWWxJr94O6AqrqYKylD0nRX6jr4bZHBj8ZV6Zm7Mf6NiZ2zlLDmpS\nuoBrCzApvWRyMs5AA4ozRBPtvOPoDpcn7H0aiwDuii4Q7qdXsy9w+osLJO8KBAsB\n5lwB2rRepJD6gY1dKZY9hpAvkHzYgSfRf1WpQAAZhecDSRdTQWTHug9qqO35+rMy\nKWM81oOW1XKvfot1ZcAipn/H3AyhtppPQRNUPnYzbsaijNs=\n=F1ed\n-----END PGP SIGNATURE-----", "payload": "tree 3d47e53b2ff6c7a0973463d2e63a1c85e852925f\nparent 70a914cd34432b49da06c9778fceebd638bfa91d\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1499959517 +0200\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1500046759 +0200\n\nUse enum instead of boolean\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "html_url": "https://github.com/rust-lang/rust/commit/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70a914cd34432b49da06c9778fceebd638bfa91d", "url": "https://api.github.com/repos/rust-lang/rust/commits/70a914cd34432b49da06c9778fceebd638bfa91d", "html_url": "https://github.com/rust-lang/rust/commit/70a914cd34432b49da06c9778fceebd638bfa91d"}], "stats": {"total": 112, "additions": 61, "deletions": 51}, "files": [{"sha": "b538d2d835786ed03993c9158ce12f75a43a607e", "filename": "src/const_eval.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconst_eval.rs?ref=eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "patch": "@@ -1,5 +1,6 @@\n use rustc::traits::Reveal;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n+use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue};\n@@ -25,7 +26,12 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n                 ecx.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n                 mir.span);\n-        let cleanup = StackPopCleanup::MarkStatic(mutable);\n+        let mutability = if mutable {\n+            Mutability::Mutable\n+        } else {\n+            Mutability::Immutable\n+        };\n+        let cleanup = StackPopCleanup::MarkStatic(mutability);\n         let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n         trace!(\"pushing stack frame for global: {}\", name);\n         ecx.push_stack_frame("}, {"sha": "76ed797684b8878c182941fa486b1cd032819608", "filename": "src/eval_context.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "patch": "@@ -12,7 +12,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc::traits;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP, Span};\n-use syntax::ast;\n+use syntax::ast::{self, Mutability};\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n@@ -98,8 +98,7 @@ pub enum StackPopCleanup {\n     /// isn't modifyable afterwards in case of constants.\n     /// In case of `static mut`, mark the memory to ensure it's never marked as immutable through\n     /// references or deallocated\n-    /// The bool decides whether the value is mutable (true) or not (false)\n-    MarkStatic(bool),\n+    MarkStatic(Mutability),\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n@@ -354,23 +353,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n                     Value::ByRef(ptr, _aligned) =>\n                         // Alignment does not matter for this call\n-                        self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, !mutable)?,\n+                        self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_inner_allocation(ptr.alloc_id, !mutable)?;\n+                        self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, !mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, !mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                         }\n                     },\n                 }\n                 // see comment on `initialized` field\n                 assert!(!global_value.initialized);\n                 global_value.initialized = true;\n-                assert!(global_value.mutable);\n+                assert_eq!(global_value.mutable, Mutability::Mutable);\n                 global_value.mutable = mutable;\n             } else {\n                 bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_lvalue);\n@@ -1023,7 +1022,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n             Lvalue::Ptr { .. } => lvalue,\n             Lvalue::Global(cid) => {\n-                let global_val = *self.globals.get(&cid).expect(\"global not cached\");\n+                let global_val = self.globals.get(&cid).expect(\"global not cached\").clone();\n                 match global_val.value {\n                     Value::ByRef(ptr, aligned) =>\n                         Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None },\n@@ -1033,7 +1032,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         self.write_value_to_ptr(global_val.value, ptr.into(), global_val.ty)?;\n                         // see comment on `initialized` field\n                         if global_val.initialized {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, !global_val.mutable)?;\n+                            self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n                         }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n@@ -1109,8 +1108,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match dest {\n             Lvalue::Global(cid) => {\n-                let dest = *self.globals.get_mut(&cid).expect(\"global should be cached\");\n-                if !dest.mutable {\n+                let dest = self.globals.get_mut(&cid).expect(\"global should be cached\").clone();\n+                if dest.mutable == Mutability::Immutable {\n                     return Err(EvalError::ModifiedConstantMemory);\n                 }\n                 let write_dest = |this: &mut Self, val| {\n@@ -1595,8 +1594,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn modify_global<F>(&mut self, cid: GlobalId<'tcx>, f: F) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let mut val = *self.globals.get(&cid).expect(\"global not cached\");\n-        if !val.mutable {\n+        let mut val = self.globals.get(&cid).expect(\"global not cached\").clone();\n+        if val.mutable == Mutability::Immutable {\n             return Err(EvalError::ModifiedConstantMemory);\n         }\n         val.value = f(self, val.value)?;"}, {"sha": "5e02bb4a572210128e6aca825528e7289ff8b6df", "filename": "src/lvalue.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "patch": "@@ -2,6 +2,7 @@ use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n+use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n@@ -51,15 +52,15 @@ pub struct GlobalId<'tcx> {\n     pub(super) promoted: Option<mir::Promoted>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Global<'tcx> {\n     pub(super) value: Value,\n     /// Only used in `force_allocation` to ensure we don't mark the memory\n     /// before the static is initialized. It is possible to convert a\n     /// global which initially is `Value::ByVal(PrimVal::Undef)` and gets\n     /// lifted to an allocation before the static is fully initialized\n     pub(super) initialized: bool,\n-    pub(super) mutable: bool,\n+    pub(super) mutable: Mutability,\n     pub(super) ty: Ty<'tcx>,\n }\n \n@@ -113,13 +114,13 @@ impl<'tcx> Global<'tcx> {\n     pub(super) fn uninitialized(ty: Ty<'tcx>) -> Self {\n         Global {\n             value: Value::ByVal(PrimVal::Undef),\n-            mutable: true,\n+            mutable: Mutability::Mutable,\n             ty,\n             initialized: false,\n         }\n     }\n \n-    pub(super) fn initialized(ty: Ty<'tcx>, value: Value, mutable: bool) -> Self {\n+    pub(super) fn initialized(ty: Ty<'tcx>, value: Value, mutable: Mutability) -> Self {\n         Global {\n             value,\n             mutable,"}, {"sha": "75ebff2f97b0bff01ce83491ab80ab254d043a18", "filename": "src/memory.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "patch": "@@ -4,6 +4,7 @@ use std::{fmt, iter, ptr, mem, io};\n \n use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout};\n+use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use value::{PrimVal, self, Pointer};\n@@ -35,7 +36,7 @@ pub struct Allocation {\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: u64,\n     /// Whether the allocation may be modified.\n-    pub mutable: bool,\n+    pub mutable: Mutability,\n     /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n@@ -50,6 +51,11 @@ pub enum Kind {\n     C,\n     /// Error if deallocated except during a stack pop\n     Stack,\n+    /// Static in the process of being initialized.\n+    /// The difference is important: An immutable static referring to a\n+    /// mutable initialized static will freeze immutably and would not\n+    /// be able to distinguish already initialized statics from uninitialized ones\n+    UninitializedStatic,\n     /// May never be deallocated\n     Static,\n     /// Part of env var emulation\n@@ -189,7 +195,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n         let ptr = self.allocate(bytes.len() as u64, 1, Kind::Static)?;\n         self.write_bytes(PrimVal::Ptr(ptr), bytes)?;\n-        self.mark_static_initalized(ptr.alloc_id, true)?;\n+        self.mark_static_initalized(ptr.alloc_id, Mutability::Mutable)?;\n         self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n         Ok(ptr)\n     }\n@@ -213,7 +219,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             undef_mask: UndefMask::new(size),\n             align,\n             kind,\n-            mutable: true,\n+            mutable: Mutability::Mutable,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -404,7 +410,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => if alloc.mutable {\n+            Some(alloc) => if alloc.mutable == Mutability::Mutable {\n                 Ok(alloc)\n             } else {\n                 Err(EvalError::ModifiedConstantMemory)\n@@ -477,8 +483,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             }\n \n             let immutable = match (alloc.kind, alloc.mutable) {\n-                (Kind::Static, true) => \" (static mut)\",\n-                (Kind::Static, false) => \" (immutable)\",\n+                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\",\n+                (Kind::Static, Mutability::Mutable) => \" (static mut)\",\n+                (Kind::Static, Mutability::Immutable) => \" (immutable)\",\n                 (Kind::Env, _) => \" (env var)\",\n                 (Kind::C, _) => \" (malloc)\",\n                 (Kind::Rust, _) => \" (heap)\",\n@@ -584,31 +591,23 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     /// mark an allocation pointed to by a static as static and initialized\n-    pub fn mark_inner_allocation(&mut self, alloc: AllocId, make_immutable: bool) -> EvalResult<'tcx> {\n+    pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n         // relocations into other statics are not \"inner allocations\"\n         if !self.static_alloc.contains(&alloc) {\n-            self.mark_static_initalized(alloc, make_immutable)?;\n+            self.mark_static_initalized(alloc, mutability)?;\n         }\n         Ok(())\n     }\n \n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, make_immutable: bool) -> EvalResult<'tcx> {\n-        trace!(\"mark_static_initalized {:?}, make_immutable: {:?}\", alloc_id, make_immutable);\n+    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n+        trace!(\"mark_static_initalized {:?}, mutability: {:?}\", alloc_id, mutability);\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(&mut Allocation { kind: Kind::Static, ref mut mutable, .. }) => {\n-                if make_immutable {\n-                    *mutable = false;\n-                }\n-                return Ok(());\n-            },\n-            Some(&mut Allocation { ref mut relocations, ref mut kind, ref mut mutable, .. }) => {\n+            Some(&mut Allocation { ref mut relocations, kind: ref mut kind @ Kind::UninitializedStatic, ref mut mutable, .. }) => {\n                 *kind = Kind::Static;\n-                if make_immutable {\n-                    *mutable = false;\n-                }\n+                *mutable = mutability;\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n@@ -618,7 +617,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.mark_inner_allocation(alloc, make_immutable)?;\n+            self.mark_inner_allocation(alloc, mutability)?;\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "d854218d7a90d7bcd6fab787eabc5a0d8884ffe4", "filename": "src/step.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "patch": "@@ -15,6 +15,7 @@ use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n use syntax::codemap::Span;\n+use syntax::ast::Mutability;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n@@ -162,7 +163,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx subst::Substs<'tcx>,\n         span: Span,\n-        shared: bool,\n+        mutability: Mutability,\n     ) {\n         let instance = self.ecx.resolve_associated_const(def_id, substs);\n         let cid = GlobalId { instance, promoted: None };\n@@ -171,18 +172,22 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         }\n         if self.ecx.tcx.has_attr(def_id, \"linkage\") {\n             trace!(\"Initializing an extern global with NULL\");\n-            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), !shared));\n+            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n             return;\n         }\n         self.try(|this| {\n             let mir = this.ecx.load_mir(instance.def)?;\n             this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n-            let mutable = !shared ||\n-                !mir.return_ty.is_freeze(\n+            let internally_mutable = !mir.return_ty.is_freeze(\n                     this.ecx.tcx,\n                     ty::ParamEnv::empty(Reveal::All),\n                     span);\n-            let cleanup = StackPopCleanup::MarkStatic(mutable);\n+            let mutability = if mutability == Mutability::Mutable || internally_mutable {\n+                Mutability::Mutable\n+            } else {\n+                Mutability::Immutable\n+            };\n+            let cleanup = StackPopCleanup::MarkStatic(mutability);\n             let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n             trace!(\"pushing stack frame for global: {}\", name);\n             this.ecx.push_stack_frame(\n@@ -214,7 +219,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             // already computed by rustc\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n-                self.global_item(def_id, substs, constant.span, true);\n+                self.global_item(def_id, substs, constant.span, Mutability::Immutable);\n             },\n             mir::Literal::Promoted { index } => {\n                 let cid = GlobalId {\n@@ -233,7 +238,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               constant.span,\n                                               mir,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::MarkStatic(false),\n+                                              StackPopCleanup::MarkStatic(Mutability::Immutable),\n                     )\n                 });\n             }\n@@ -254,7 +259,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             if let Some(node_item) = self.ecx.tcx.hir.get_if_local(def_id) {\n                 if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n                     if let hir::ItemStatic(_, m, _) = *node {\n-                        self.global_item(def_id, substs, span, m == hir::MutImmutable);\n+                        self.global_item(def_id, substs, span, if m == hir::MutMutable { Mutability::Mutable } else { Mutability::Immutable });\n                         return;\n                     } else {\n                         bug!(\"static def id doesn't point to static\");\n@@ -265,7 +270,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             } else {\n                 let def = self.ecx.tcx.describe_def(def_id).expect(\"static not found\");\n                 if let hir::def::Def::Static(_, mutable) = def {\n-                    self.global_item(def_id, substs, span, !mutable);\n+                    self.global_item(def_id, substs, span, if mutable { Mutability::Mutable } else { Mutability::Immutable });\n                 } else {\n                     bug!(\"static found but isn't a static: {:?}\", def);\n                 }"}, {"sha": "b3e77a9299c13d5321aab3780a1e4cd2ca310c28", "filename": "src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=eb01c3fdd2ee6141f5e6a43d60f8a095e2c807f4", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use syntax::codemap::DUMMY_SP;\n-use syntax::ast;\n+use syntax::ast::{self, Mutability};\n \n use error::{EvalResult, EvalError};\n \n@@ -68,7 +68,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.mark_static_initalized(vtable.alloc_id, true)?;\n+        self.memory.mark_static_initalized(vtable.alloc_id, Mutability::Mutable)?;\n \n         Ok(vtable)\n     }"}]}