{"sha": "8293fe9fdf2d3398176297b82a72cd32d13538d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOTNmZTlmZGYyZDMzOTgxNzYyOTdiODJhNzJjZDMyZDEzNTM4ZDg=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-20T17:26:13Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-20T20:18:48Z"}, "message": "Implement the special repr(C)-non-clike-enum layout", "tree": {"sha": "26bf0d323a22ccde1d11f3cf562e1b6742268dcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26bf0d323a22ccde1d11f3cf562e1b6742268dcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8293fe9fdf2d3398176297b82a72cd32d13538d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8293fe9fdf2d3398176297b82a72cd32d13538d8", "html_url": "https://github.com/rust-lang/rust/commit/8293fe9fdf2d3398176297b82a72cd32d13538d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8293fe9fdf2d3398176297b82a72cd32d13538d8/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14", "html_url": "https://github.com/rust-lang/rust/commit/f50fd075c2555d8511ccee8a7fe7aee3f2c45e14"}], "stats": {"total": 42, "additions": 26, "deletions": 16}, "files": [{"sha": "7d262adffdb989df46a792f1c73f141ecb7e3613", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8293fe9fdf2d3398176297b82a72cd32d13538d8/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8293fe9fdf2d3398176297b82a72cd32d13538d8/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8293fe9fdf2d3398176297b82a72cd32d13538d8", "patch": "@@ -942,8 +942,8 @@ impl<'a, 'tcx> LayoutDetails {\n             AlwaysSized,\n             /// A univariant, the last field of which may be coerced to unsized.\n             MaybeUnsized,\n-            /// A univariant, but part of an enum.\n-            EnumVariant(Integer),\n+            /// A univariant, but with a prefix of an arbitrary size & alignment (e.g. enum tag).\n+            Prefixed(Size, Align),\n         }\n         let univariant_uninterned = |fields: &[TyLayout], repr: &ReprOptions, kind| {\n             let packed = repr.packed();\n@@ -962,14 +962,11 @@ impl<'a, 'tcx> LayoutDetails {\n             let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n             // Anything with repr(C) or repr(packed) doesn't optimize.\n-            let optimize = match kind {\n-                StructKind::AlwaysSized |\n-                StructKind::MaybeUnsized |\n-                StructKind::EnumVariant(I8) => {\n-                    (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty()\n-                }\n-                StructKind::EnumVariant(_) => false\n-            };\n+            let mut optimize = (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n+            if let StructKind::Prefixed(_, align) = kind {\n+                optimize &= align.abi() == 1;\n+            }\n+\n             if optimize {\n                 let end = if let StructKind::MaybeUnsized = kind {\n                     fields.len() - 1\n@@ -987,7 +984,7 @@ impl<'a, 'tcx> LayoutDetails {\n                             (!f.is_zst(), cmp::Reverse(f.align.abi()))\n                         })\n                     }\n-                    StructKind::EnumVariant(_) => {\n+                    StructKind::Prefixed(..) => {\n                         optimizing.sort_by_key(|&x| fields[x as usize].align.abi());\n                     }\n                 }\n@@ -1001,12 +998,11 @@ impl<'a, 'tcx> LayoutDetails {\n \n             let mut offset = Size::from_bytes(0);\n \n-            if let StructKind::EnumVariant(discr) = kind {\n-                offset = discr.size();\n+            if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n                 if !packed {\n-                    let discr_align = discr.align(dl);\n-                    align = align.max(discr_align);\n+                    align = align.max(prefix_align);\n                 }\n+                offset = prefix_size.abi_align(prefix_align);\n             }\n \n             for &i in &inverse_memory_index {\n@@ -1558,10 +1554,24 @@ impl<'a, 'tcx> LayoutDetails {\n                 let mut start_align = Align::from_bytes(256, 256).unwrap();\n                 assert_eq!(Integer::for_abi_align(dl, start_align), None);\n \n+                // repr(C) on an enum tells us to make a (tag, union) layout,\n+                // so we need to grow the prefix alignment to be at least\n+                // the alignment of the union. (This value is used both for\n+                // determining the alignment of the overall enum, and the\n+                // determining the alignment of the payload after the tag.)\n+                let mut prefix_align = min_ity.align(dl);\n+                if def.repr.c() {\n+                    for fields in &variants {\n+                        for field in fields {\n+                            prefix_align = prefix_align.max(field.align);\n+                        }\n+                    }\n+                }\n+\n                 // Create the set of structs that represent each variant.\n                 let mut variants = variants.into_iter().enumerate().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n-                        &def.repr, StructKind::EnumVariant(min_ity))?;\n+                        &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant."}]}