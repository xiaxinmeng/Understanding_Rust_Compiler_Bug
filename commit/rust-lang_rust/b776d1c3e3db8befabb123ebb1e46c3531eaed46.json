{"sha": "b776d1c3e3db8befabb123ebb1e46c3531eaed46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NzZkMWMzZTNkYjhiZWZhYmIxMjNlYmIxZTQ2YzM1MzFlYWVkNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-29T18:50:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-29T18:50:19Z"}, "message": "Auto merge of #79523 - Nadrieril:fix-usize-ranges, r=varkor\n\nFix overlap detection of `usize`/`isize` range patterns\n\n`usize` and `isize` are a bit of a special case in the match usefulness algorithm, because the range of values they contain depends on the platform. Specifically, we don't want `0..usize::MAX` to count as an exhaustive match (see also [`precise_pointer_size_matching`](https://github.com/rust-lang/rust/issues/56354)). The way this was initially implemented is by treating those ranges like float ranges, i.e. with limited cleverness. This means we didn't catch the following as unreachable:\n```rust\nmatch 0usize {\n    0..10 => {},\n    10..20 => {},\n    5..15 => {}, // oops, should be detected as unreachable\n    _ => {},\n}\n```\nThis PRs fixes this oversight. Now the only difference between `usize` and `u64` range patterns is in what ranges count as exhaustive.\n\nr? `@varkor`\n`@rustbot` label +A-exhaustiveness-checking", "tree": {"sha": "d3c1f37d4299d77cc8f07ba017b07c4625ec492f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3c1f37d4299d77cc8f07ba017b07c4625ec492f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b776d1c3e3db8befabb123ebb1e46c3531eaed46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b776d1c3e3db8befabb123ebb1e46c3531eaed46", "html_url": "https://github.com/rust-lang/rust/commit/b776d1c3e3db8befabb123ebb1e46c3531eaed46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b776d1c3e3db8befabb123ebb1e46c3531eaed46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88b81970ba7a989a728b32039dd075dc206f1360", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b81970ba7a989a728b32039dd075dc206f1360", "html_url": "https://github.com/rust-lang/rust/commit/88b81970ba7a989a728b32039dd075dc206f1360"}, {"sha": "bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "html_url": "https://github.com/rust-lang/rust/commit/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3"}], "stats": {"total": 169, "additions": 74, "deletions": 95}, "files": [{"sha": "3b2eef5a905dd3ac63840bf19d0b6b45d02c8b1a", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 56, "deletions": 91, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b776d1c3e3db8befabb123ebb1e46c3531eaed46/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776d1c3e3db8befabb123ebb1e46c3531eaed46/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=b776d1c3e3db8befabb123ebb1e46c3531eaed46", "patch": "@@ -37,14 +37,12 @@ use std::ops::RangeInclusive;\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n-#[derive(Clone, Debug)]\n-pub(super) struct IntRange<'tcx> {\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(super) struct IntRange {\n     range: RangeInclusive<u128>,\n-    ty: Ty<'tcx>,\n-    span: Span,\n }\n \n-impl<'tcx> IntRange<'tcx> {\n+impl IntRange {\n     #[inline]\n     fn is_integral(ty: Ty<'_>) -> bool {\n         matches!(ty.kind(), ty::Char | ty::Int(_) | ty::Uint(_) | ty::Bool)\n@@ -58,14 +56,8 @@ impl<'tcx> IntRange<'tcx> {\n         (*self.range.start(), *self.range.end())\n     }\n \n-    /// Don't treat `usize`/`isize` exhaustively unless the `precise_pointer_size_matching` feature\n-    /// is enabled.\n-    fn treat_exhaustively(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        !self.ty.is_ptr_sized_integral() || tcx.features().precise_pointer_size_matching\n-    }\n-\n     #[inline]\n-    fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n+    fn integral_size_and_signed_bias(tcx: TyCtxt<'_>, ty: Ty<'_>) -> Option<(Size, u128)> {\n         match *ty.kind() {\n             ty::Bool => Some((Size::from_bytes(1), 0)),\n             ty::Char => Some((Size::from_bytes(4), 0)),\n@@ -79,12 +71,11 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     #[inline]\n-    fn from_const(\n+    fn from_const<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &Const<'tcx>,\n-        span: Span,\n-    ) -> Option<IntRange<'tcx>> {\n+    ) -> Option<IntRange> {\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n             let ty = value.ty;\n             let val = (|| {\n@@ -101,21 +92,20 @@ impl<'tcx> IntRange<'tcx> {\n                 value.try_eval_bits(tcx, param_env, ty)\n             })()?;\n             let val = val ^ bias;\n-            Some(IntRange { range: val..=val, ty, span })\n+            Some(IntRange { range: val..=val })\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n-    fn from_range(\n+    fn from_range<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         lo: u128,\n         hi: u128,\n         ty: Ty<'tcx>,\n         end: &RangeEnd,\n-        span: Span,\n-    ) -> Option<IntRange<'tcx>> {\n+    ) -> Option<IntRange> {\n         if Self::is_integral(ty) {\n             // Perform a shift if the underlying types are signed,\n             // which makes the interval arithmetic simpler.\n@@ -126,14 +116,14 @@ impl<'tcx> IntRange<'tcx> {\n                 // This should have been caught earlier by E0030.\n                 bug!(\"malformed range pattern: {}..={}\", lo, (hi - offset));\n             }\n-            Some(IntRange { range: lo..=(hi - offset), ty, span })\n+            Some(IntRange { range: lo..=(hi - offset) })\n         } else {\n             None\n         }\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n-    fn signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> u128 {\n+    fn signed_bias(tcx: TyCtxt<'_>, ty: Ty<'_>) -> u128 {\n         match *ty.kind() {\n             ty::Int(ity) => {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n@@ -147,20 +137,13 @@ impl<'tcx> IntRange<'tcx> {\n         other.range.start() <= self.range.start() && self.range.end() <= other.range.end()\n     }\n \n-    fn intersection(&self, tcx: TyCtxt<'tcx>, other: &Self) -> Option<Self> {\n-        let ty = self.ty;\n+    fn intersection(&self, other: &Self) -> Option<Self> {\n         let (lo, hi) = self.boundaries();\n         let (other_lo, other_hi) = other.boundaries();\n-        if self.treat_exhaustively(tcx) {\n-            if lo <= other_hi && other_lo <= hi {\n-                let span = other.span;\n-                Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n-            } else {\n-                None\n-            }\n+        if lo <= other_hi && other_lo <= hi {\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi) })\n         } else {\n-            // If the range should not be treated exhaustively, fallback to checking for inclusion.\n-            if self.is_subrange(other) { Some(self.clone()) } else { None }\n+            None\n         }\n     }\n \n@@ -181,24 +164,23 @@ impl<'tcx> IntRange<'tcx> {\n         lo == other_hi || hi == other_lo\n     }\n \n-    fn to_pat(&self, tcx: TyCtxt<'tcx>) -> Pat<'tcx> {\n+    fn to_pat<'tcx>(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n         let (lo, hi) = self.boundaries();\n \n-        let bias = IntRange::signed_bias(tcx, self.ty);\n+        let bias = IntRange::signed_bias(tcx, ty);\n         let (lo, hi) = (lo ^ bias, hi ^ bias);\n \n-        let ty = ty::ParamEnv::empty().and(self.ty);\n-        let lo_const = ty::Const::from_bits(tcx, lo, ty);\n-        let hi_const = ty::Const::from_bits(tcx, hi, ty);\n+        let env = ty::ParamEnv::empty().and(ty);\n+        let lo_const = ty::Const::from_bits(tcx, lo, env);\n+        let hi_const = ty::Const::from_bits(tcx, hi, env);\n \n         let kind = if lo == hi {\n             PatKind::Constant { value: lo_const }\n         } else {\n             PatKind::Range(PatRange { lo: lo_const, hi: hi_const, end: RangeEnd::Included })\n         };\n \n-        // This is a brand new pattern, so we don't reuse `self.span`.\n-        Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(kind) }\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(kind) }\n     }\n \n     /// For exhaustive integer matching, some constructors are grouped within other constructors\n@@ -233,13 +215,11 @@ impl<'tcx> IntRange<'tcx> {\n     /// boundaries for each interval range, sort them, then create constructors for each new interval\n     /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n     /// merging operation depicted above.)\n-    fn split<'p>(\n+    fn split<'p, 'tcx>(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         hir_id: Option<HirId>,\n     ) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        let ty = pcx.ty;\n-\n         /// Represents a border between 2 integers. Because the intervals spanning borders\n         /// must be able to cover every integer, we need to be able to represent\n         /// 2^128 + 1 such borders.\n@@ -250,7 +230,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n \n         // A function for extracting the borders of an integer interval.\n-        fn range_borders(r: IntRange<'_>) -> impl Iterator<Item = Border> {\n+        fn range_borders(r: IntRange) -> impl Iterator<Item = Border> {\n             let (lo, hi) = r.range.into_inner();\n             let from = Border::JustBefore(lo);\n             let to = match hi.checked_add(1) {\n@@ -268,21 +248,23 @@ impl<'tcx> IntRange<'tcx> {\n         // class lies between 2 borders.\n         let row_borders = pcx\n             .matrix\n-            .head_ctors(pcx.cx)\n-            .filter_map(|ctor| ctor.as_int_range())\n-            .filter_map(|range| {\n-                let intersection = self.intersection(pcx.cx.tcx, &range);\n+            .head_ctors_and_spans(pcx.cx)\n+            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n+            .filter_map(|(range, span)| {\n+                let intersection = self.intersection(&range);\n                 let should_lint = self.suspicious_intersection(&range);\n                 if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n                     // FIXME: for now, only check for overlapping ranges on simple range\n                     // patterns. Otherwise with the current logic the following is detected\n                     // as overlapping:\n-                    //   match (10u8, true) {\n-                    //    (0 ..= 125, false) => {}\n-                    //    (126 ..= 255, false) => {}\n-                    //    (0 ..= 255, true) => {}\n-                    //  }\n-                    overlaps.push(range.clone());\n+                    // ```\n+                    // match (0u8, true) {\n+                    //   (0 ..= 125, false) => {}\n+                    //   (125 ..= 255, true) => {}\n+                    //   _ => {}\n+                    // }\n+                    // ```\n+                    overlaps.push((range.clone(), span));\n                 }\n                 intersection\n             })\n@@ -291,7 +273,7 @@ impl<'tcx> IntRange<'tcx> {\n         let mut borders: Vec<_> = row_borders.chain(self_borders).collect();\n         borders.sort_unstable();\n \n-        self.lint_overlapping_patterns(pcx.cx.tcx, hir_id, ty, overlaps);\n+        self.lint_overlapping_patterns(pcx, hir_id, overlaps);\n \n         // We're going to iterate through every adjacent pair of borders, making sure that\n         // each represents an interval of nonnegative length, and convert each such\n@@ -309,33 +291,32 @@ impl<'tcx> IntRange<'tcx> {\n                 [Border::JustBefore(n), Border::AfterMax] => Some(n..=u128::MAX),\n                 [Border::AfterMax, _] => None,\n             })\n-            .map(|range| IntRange { range, ty, span: pcx.span })\n+            .map(|range| IntRange { range })\n             .map(IntRange)\n             .collect()\n     }\n \n     fn lint_overlapping_patterns(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        pcx: PatCtxt<'_, '_, '_>,\n         hir_id: Option<HirId>,\n-        ty: Ty<'tcx>,\n-        overlaps: Vec<IntRange<'tcx>>,\n+        overlaps: Vec<(IntRange, Span)>,\n     ) {\n         if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n-            tcx.struct_span_lint_hir(\n+            pcx.cx.tcx.struct_span_lint_hir(\n                 lint::builtin::OVERLAPPING_PATTERNS,\n                 hir_id,\n-                self.span,\n+                pcx.span,\n                 |lint| {\n                     let mut err = lint.build(\"multiple patterns covering the same range\");\n-                    err.span_label(self.span, \"overlapping patterns\");\n-                    for int_range in overlaps {\n+                    err.span_label(pcx.span, \"overlapping patterns\");\n+                    for (int_range, span) in overlaps {\n                         // Use the real type for user display of the ranges:\n                         err.span_label(\n-                            int_range.span,\n+                            span,\n                             &format!(\n                                 \"this range overlaps on `{}`\",\n-                                IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n+                                int_range.to_pat(pcx.cx.tcx, pcx.ty),\n                             ),\n                         );\n                     }\n@@ -346,8 +327,8 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     /// See `Constructor::is_covered_by`\n-    fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n-        if self.intersection(pcx.cx.tcx, other).is_some() {\n+    fn is_covered_by(&self, other: &Self) -> bool {\n+        if self.intersection(other).is_some() {\n             // Constructor splitting should ensure that all intersections we encounter are actually\n             // inclusions.\n             assert!(self.is_subrange(other));\n@@ -358,13 +339,6 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n-/// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n-impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.range == other.range && self.ty == other.ty\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum SliceKind {\n     /// Patterns of length `n` (`[x, y]`).\n@@ -558,7 +532,7 @@ pub(super) enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n-    IntRange(IntRange<'tcx>),\n+    IntRange(IntRange),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n@@ -581,7 +555,7 @@ impl<'tcx> Constructor<'tcx> {\n         matches!(self, Wildcard)\n     }\n \n-    fn as_int_range(&self) -> Option<&IntRange<'tcx>> {\n+    fn as_int_range(&self) -> Option<&IntRange> {\n         match self {\n             IntRange(range) => Some(range),\n             _ => None,\n@@ -616,8 +590,7 @@ impl<'tcx> Constructor<'tcx> {\n                 Variant(adt_def.variants[variant_index].def_id)\n             }\n             PatKind::Constant { value } => {\n-                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value, pat.span)\n-                {\n+                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value) {\n                     IntRange(int_range)\n                 } else {\n                     match pat.ty.kind() {\n@@ -641,7 +614,6 @@ impl<'tcx> Constructor<'tcx> {\n                     hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                     ty,\n                     &end,\n-                    pat.span,\n                 ) {\n                     IntRange(int_range)\n                 } else {\n@@ -694,11 +666,7 @@ impl<'tcx> Constructor<'tcx> {\n             Wildcard => Constructor::split_wildcard(pcx),\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n-            IntRange(ctor_range)\n-                if ctor_range.treat_exhaustively(pcx.cx.tcx) && !ctor_range.is_singleton() =>\n-            {\n-                ctor_range.split(pcx, hir_id)\n-            }\n+            IntRange(ctor_range) if !ctor_range.is_singleton() => ctor_range.split(pcx, hir_id),\n             Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(pcx),\n             // Any other constructor can be used unchanged.\n             _ => smallvec![self.clone()],\n@@ -740,9 +708,7 @@ impl<'tcx> Constructor<'tcx> {\n             (Single, Single) => true,\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n \n-            (IntRange(self_range), IntRange(other_range)) => {\n-                self_range.is_covered_by(pcx, other_range)\n-            }\n+            (IntRange(self_range), IntRange(other_range)) => self_range.is_covered_by(other_range),\n             (\n                 FloatRange(self_from, self_to, self_end),\n                 FloatRange(other_from, other_to, other_end),\n@@ -803,15 +769,15 @@ impl<'tcx> Constructor<'tcx> {\n             IntRange(range) => used_ctors\n                 .iter()\n                 .filter_map(|c| c.as_int_range())\n-                .any(|other| range.is_covered_by(pcx, other)),\n+                .any(|other| range.is_covered_by(other)),\n             Slice(slice) => used_ctors\n                 .iter()\n                 .filter_map(|c| c.as_slice())\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n             Str(..) | FloatRange(..) | Opaque | Wildcard => {\n-                bug!(\"found unexpected ctor in all_ctors: {:?}\", self)\n+                span_bug!(pcx.span, \"found unexpected ctor in all_ctors: {:?}\", self)\n             }\n         }\n     }\n@@ -832,8 +798,7 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n     let make_range = |start, end| {\n         IntRange(\n             // `unwrap()` is ok because we know the type is an integer.\n-            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included, pcx.span)\n-                .unwrap(),\n+            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included).unwrap(),\n         )\n     };\n     match pcx.ty.kind() {\n@@ -1238,7 +1203,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             },\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n-            IntRange(range) => return range.to_pat(pcx.cx.tcx),\n+            IntRange(range) => return range.to_pat(pcx.cx.tcx, pcx.ty),\n             NonExhaustive => PatKind::Wild,\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n             Wildcard => bug!("}, {"sha": "f3e1507b37ae1813cfe9e7ab49c8bc67caf06671", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b776d1c3e3db8befabb123ebb1e46c3531eaed46/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776d1c3e3db8befabb123ebb1e46c3531eaed46/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=b776d1c3e3db8befabb123ebb1e46c3531eaed46", "patch": "@@ -535,14 +535,22 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         self.patterns.iter().map(|r| r.head())\n     }\n \n-    /// Iterate over the first constructor of each row\n+    /// Iterate over the first constructor of each row.\n     pub(super) fn head_ctors<'a>(\n         &'a self,\n         cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'a> + Captures<'p> {\n+    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n         self.patterns.iter().map(move |r| r.head_ctor(cx))\n     }\n \n+    /// Iterate over the first constructor and the corresponding span of each row.\n+    pub(super) fn head_ctors_and_spans<'a>(\n+        &'a self,\n+        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+    ) -> impl Iterator<Item = (&'a Constructor<'tcx>, Span)> + Captures<'p> {\n+        self.patterns.iter().map(move |r| (r.head_ctor(cx), r.head().span))\n+    }\n+\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,"}, {"sha": "6516925e93918b76679f7cf5ce6a48c358319113", "filename": "src/test/ui/pattern/usefulness/integer-ranges/reachability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b776d1c3e3db8befabb123ebb1e46c3531eaed46/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b776d1c3e3db8befabb123ebb1e46c3531eaed46/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.rs?ref=b776d1c3e3db8befabb123ebb1e46c3531eaed46", "patch": "@@ -72,7 +72,7 @@ fn main() {\n     match 0usize {\n         0..10 => {},\n         10..20 => {},\n-        5..15 => {}, // FIXME: should be unreachable\n+        5..15 => {}, //~ ERROR unreachable pattern\n         _ => {},\n     }\n     // Chars between '\\u{D7FF}' and '\\u{E000}' are invalid even though ranges that contain them are"}, {"sha": "e6878d950d62561e48fd7024ef545479559656b0", "filename": "src/test/ui/pattern/usefulness/integer-ranges/reachability.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b776d1c3e3db8befabb123ebb1e46c3531eaed46/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b776d1c3e3db8befabb123ebb1e46c3531eaed46/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr?ref=b776d1c3e3db8befabb123ebb1e46c3531eaed46", "patch": "@@ -124,6 +124,12 @@ error: unreachable pattern\n LL |         5..25 => {},\n    |         ^^^^^\n \n+error: unreachable pattern\n+  --> $DIR/reachability.rs:75:9\n+   |\n+LL |         5..15 => {},\n+   |         ^^^^^\n+\n error: unreachable pattern\n   --> $DIR/reachability.rs:82:9\n    |\n@@ -142,5 +148,5 @@ error: unreachable pattern\n LL |         BAR => {}\n    |         ^^^\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 24 previous errors\n "}]}