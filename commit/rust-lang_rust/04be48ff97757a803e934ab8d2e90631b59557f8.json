{"sha": "04be48ff97757a803e934ab8d2e90631b59557f8", "node_id": "C_kwDOAAsO6NoAKDA0YmU0OGZmOTc3NTdhODAzZTkzNGFiOGQyZTkwNjMxYjU5NTU3Zjg", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-04-15T05:44:18Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-04-15T06:11:16Z"}, "message": "Add float trait, and seal traits.", "tree": {"sha": "3098f69c514184433f2732d8ad4c44eb24012b82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3098f69c514184433f2732d8ad4c44eb24012b82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04be48ff97757a803e934ab8d2e90631b59557f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04be48ff97757a803e934ab8d2e90631b59557f8", "html_url": "https://github.com/rust-lang/rust/commit/04be48ff97757a803e934ab8d2e90631b59557f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04be48ff97757a803e934ab8d2e90631b59557f8/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "376957ad8cac70a85c08a26a147eb534d5cee380", "url": "https://api.github.com/repos/rust-lang/rust/commits/376957ad8cac70a85c08a26a147eb534d5cee380", "html_url": "https://github.com/rust-lang/rust/commit/376957ad8cac70a85c08a26a147eb534d5cee380"}], "stats": {"total": 713, "additions": 368, "deletions": 345}, "files": [{"sha": "701eb66b248afb2877a08b10b3c0537d22dfc1db", "filename": "crates/core_simd/src/elements.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements.rs?ref=04be48ff97757a803e934ab8d2e90631b59557f8", "patch": "@@ -1,5 +1,11 @@\n+mod float;\n mod int;\n mod uint;\n \n+mod sealed {\n+    pub trait Sealed {}\n+}\n+\n+pub use float::*;\n pub use int::*;\n pub use uint::*;"}, {"sha": "fafbd2a4d21370bfff2975da019c5238b39063ed", "filename": "crates/core_simd/src/elements/float.rs", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs?ref=04be48ff97757a803e934ab8d2e90631b59557f8", "patch": "@@ -0,0 +1,344 @@\n+use super::sealed::Sealed;\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdElement, SimdPartialEq, SimdPartialOrd,\n+    SupportedLaneCount,\n+};\n+\n+/// Operations on SIMD vectors of floats.\n+pub trait SimdFloat: Sized + Sealed {\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Bit representation of this SIMD vector type.\n+    type Bits;\n+\n+    /// Raw transmutation to an unsigned integer vector type with the\n+    /// same size and number of lanes.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_bits(self) -> Self::Bits;\n+\n+    /// Raw transmutation from an unsigned integer vector type with the\n+    /// same size and number of lanes.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn from_bits(bits: Self::Bits) -> Self;\n+\n+    /// Produces a vector where every lane has the absolute value of the\n+    /// equivalently-indexed lane in `self`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn abs(self) -> Self;\n+\n+    /// Takes the reciprocal (inverse) of each lane, `1/x`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn recip(self) -> Self;\n+\n+    /// Converts each lane from radians to degrees.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_degrees(self) -> Self;\n+\n+    /// Converts each lane from degrees to radians.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_radians(self) -> Self;\n+\n+    /// Returns true for each lane if it has a positive sign, including\n+    /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_sign_positive(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if it has a negative sign, including\n+    /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_sign_negative(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_nan(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is positive infinity or negative infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_infinite(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is neither infinite nor `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_finite(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is subnormal.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_subnormal(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is neither zero, infinite,\n+    /// subnormal, nor `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_normal(self) -> Self::Mask;\n+\n+    /// Replaces each lane with a number that represents its sign.\n+    ///\n+    /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n+    /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n+    /// * `NAN` if the number is `NAN`\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn signum(self) -> Self;\n+\n+    /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n+    ///\n+    /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn copysign(self, sign: Self) -> Self;\n+\n+    /// Returns the minimum of each lane.\n+    ///\n+    /// If one of the values is `NAN`, then the other value is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_min(self, other: Self) -> Self;\n+\n+    /// Returns the maximum of each lane.\n+    ///\n+    /// If one of the values is `NAN`, then the other value is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_max(self, other: Self) -> Self;\n+\n+    /// Restrict each lane to a certain interval unless it is NaN.\n+    ///\n+    /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n+    /// greater than `max`, and the corresponding lane in `min` if the lane is less\n+    /// than `min`.  Otherwise returns the lane in `self`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([1., 2.]);\n+    /// assert_eq!(v.reduce_sum(), 3.);\n+    /// ```\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Reducing multiply.  Returns the product of the lanes of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([3., 4.]);\n+    /// assert_eq!(v.reduce_product(), 12.);\n+    /// ```\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    ///\n+    /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+    /// return either.\n+    ///\n+    /// This function will not return `NaN` unless all lanes are `NaN`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([1., 2.]);\n+    /// assert_eq!(v.reduce_max(), 2.);\n+    ///\n+    /// // NaN values are skipped...\n+    /// let v = f32x2::from_array([1., f32::NAN]);\n+    /// assert_eq!(v.reduce_max(), 1.);\n+    ///\n+    /// // ...unless all values are NaN\n+    /// let v = f32x2::from_array([f32::NAN, f32::NAN]);\n+    /// assert!(v.reduce_max().is_nan());\n+    /// ```\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    ///\n+    /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+    /// return either.\n+    ///\n+    /// This function will not return `NaN` unless all lanes are `NaN`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([3., 7.]);\n+    /// assert_eq!(v.reduce_min(), 3.);\n+    ///\n+    /// // NaN values are skipped...\n+    /// let v = f32x2::from_array([1., f32::NAN]);\n+    /// assert_eq!(v.reduce_min(), 1.);\n+    ///\n+    /// // ...unless all values are NaN\n+    /// let v = f32x2::from_array([f32::NAN, f32::NAN]);\n+    /// assert!(v.reduce_min().is_nan());\n+    /// ```\n+    fn reduce_min(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty { bits: $bits_ty:ty, mask: $mask_ty:ty }),* } => {\n+        $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n+        impl<const LANES: usize> SimdFloat for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$mask_ty as SimdElement>::Mask, LANES>;\n+            type Scalar = $ty;\n+            type Bits = Simd<$bits_ty, LANES>;\n+\n+            #[inline]\n+            fn to_bits(self) -> Simd<$bits_ty, LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Self::Bits>());\n+                unsafe { core::mem::transmute_copy(&self) }\n+            }\n+\n+            #[inline]\n+            fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Self::Bits>());\n+                unsafe { core::mem::transmute_copy(&bits) }\n+            }\n+\n+            #[inline]\n+            fn abs(self) -> Self {\n+                unsafe { intrinsics::simd_fabs(self) }\n+            }\n+\n+            #[inline]\n+            fn recip(self) -> Self {\n+                Self::splat(1.0) / self\n+            }\n+\n+            #[inline]\n+            fn to_degrees(self) -> Self {\n+                // to_degrees uses a special constant for better precision, so extract that constant\n+                self * Self::splat(Self::Scalar::to_degrees(1.))\n+            }\n+\n+            #[inline]\n+            fn to_radians(self) -> Self {\n+                self * Self::splat(Self::Scalar::to_radians(1.))\n+            }\n+\n+            #[inline]\n+            fn is_sign_positive(self) -> Self::Mask {\n+                !self.is_sign_negative()\n+            }\n+\n+            #[inline]\n+            fn is_sign_negative(self) -> Self::Mask {\n+                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n+                sign_bits.simd_gt(Simd::splat(0))\n+            }\n+\n+            #[inline]\n+            fn is_nan(self) -> Self::Mask {\n+                self.simd_ne(self)\n+            }\n+\n+            #[inline]\n+            fn is_infinite(self) -> Self::Mask {\n+                self.abs().simd_eq(Self::splat(Self::Scalar::INFINITY))\n+            }\n+\n+            #[inline]\n+            fn is_finite(self) -> Self::Mask {\n+                self.abs().simd_lt(Self::splat(Self::Scalar::INFINITY))\n+            }\n+\n+            #[inline]\n+            fn is_subnormal(self) -> Self::Mask {\n+                self.abs().simd_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(Self::Scalar::INFINITY).to_bits()).simd_eq(Simd::splat(0))\n+            }\n+\n+            #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+            fn is_normal(self) -> Self::Mask {\n+                !(self.abs().simd_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n+            }\n+\n+            #[inline]\n+            fn signum(self) -> Self {\n+                self.is_nan().select(Self::splat(Self::Scalar::NAN), Self::splat(1.0).copysign(self))\n+            }\n+\n+            #[inline]\n+            fn copysign(self, sign: Self) -> Self {\n+                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n+                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n+                Self::from_bits(sign_bit | magnitude)\n+            }\n+\n+            #[inline]\n+            fn simd_min(self, other: Self) -> Self {\n+                unsafe { intrinsics::simd_fmin(self, other) }\n+            }\n+\n+            #[inline]\n+            fn simd_max(self, other: Self) -> Self {\n+                unsafe { intrinsics::simd_fmax(self, other) }\n+            }\n+\n+            #[inline]\n+            fn simd_clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.simd_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                let mut x = self;\n+                x = x.simd_lt(min).select(min, x);\n+                x = x.simd_gt(max).select(max, x);\n+                x\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // LLVM sum is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().sum()\n+                } else {\n+                    // Safety: `self` is a float vector\n+                    unsafe { intrinsics::simd_reduce_add_ordered(self, 0.) }\n+                }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // LLVM product is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().product()\n+                } else {\n+                    // Safety: `self` is a float vector\n+                    unsafe { intrinsics::simd_reduce_mul_ordered(self, 1.) }\n+                }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is a float vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is a float vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { f32 { bits: u32, mask: i32 }, f64 { bits: u64, mask: i64 } }"}, {"sha": "c3139b4ba3eb1d3ca28dba39846230556e75f099", "filename": "crates/core_simd/src/elements/int.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs?ref=04be48ff97757a803e934ab8d2e90631b59557f8", "patch": "@@ -1,9 +1,10 @@\n+use super::sealed::Sealed;\n use crate::simd::{\n     intrinsics, LaneCount, Mask, Simd, SimdElement, SimdPartialOrd, SupportedLaneCount,\n };\n \n /// Operations on SIMD vectors of signed integers.\n-pub trait SimdInt: Sized {\n+pub trait SimdInt: Sized + Sealed {\n     /// Mask type used for manipulating this SIMD vector type.\n     type Mask;\n \n@@ -167,6 +168,12 @@ pub trait SimdInt: Sized {\n macro_rules! impl_trait {\n     { $($ty:ty),* } => {\n         $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n         impl<const LANES: usize> SimdInt for Simd<$ty, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "cba1a9b0ce0d561d05075b8ec89e1169a4543311", "filename": "crates/core_simd/src/elements/uint.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs?ref=04be48ff97757a803e934ab8d2e90631b59557f8", "patch": "@@ -1,7 +1,8 @@\n+use super::sealed::Sealed;\n use crate::simd::{intrinsics, LaneCount, Simd, SupportedLaneCount};\n \n /// Operations on SIMD vectors of unsigned integers.\n-pub trait SimdUint: Sized {\n+pub trait SimdUint: Sized + Sealed {\n     /// Scalar type contained by this SIMD vector type.\n     type Scalar;\n \n@@ -61,6 +62,12 @@ pub trait SimdUint: Sized {\n macro_rules! impl_trait {\n     { $($ty:ty),* } => {\n         $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n         impl<const LANES: usize> SimdUint for Simd<$ty, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "590b2e4a1531db34a4bb87d1b633f4128b2a1c75", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=04be48ff97757a803e934ab8d2e90631b59557f8", "patch": "@@ -1,6 +1,3 @@\n-#[macro_use]\n-mod reduction;\n-\n #[macro_use]\n mod swizzle;\n "}, {"sha": "9d8639feeeed233bb9a777cacd57d238833e095e", "filename": "crates/core_simd/src/reduction.rs", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -1,127 +0,0 @@\n-use crate::simd::intrinsics::{\n-    simd_reduce_add_ordered, simd_reduce_max, simd_reduce_min, simd_reduce_mul_ordered,\n-};\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-macro_rules! impl_float_reductions {\n-    { $scalar:ty } => {\n-        impl<const LANES: usize> Simd<$scalar, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-\n-            /// Reducing add.  Returns the sum of the lanes of the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., 2.]);\")]\n-            /// assert_eq!(v.reduce_sum(), 3.);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_sum(self) -> $scalar {\n-                // LLVM sum is inaccurate on i586\n-                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_array().iter().sum()\n-                } else {\n-                    // Safety: `self` is a float vector\n-                    unsafe { simd_reduce_add_ordered(self, 0.) }\n-                }\n-            }\n-\n-            /// Reducing multiply.  Returns the product of the lanes of the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([3., 4.]);\")]\n-            /// assert_eq!(v.reduce_product(), 12.);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_product(self) -> $scalar {\n-                // LLVM product is inaccurate on i586\n-                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_array().iter().product()\n-                } else {\n-                    // Safety: `self` is a float vector\n-                    unsafe { simd_reduce_mul_ordered(self, 1.) }\n-                }\n-            }\n-\n-            /// Reducing maximum.  Returns the maximum lane in the vector.\n-            ///\n-            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.\n-            ///\n-            /// This function will not return `NaN` unless all lanes are `NaN`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., 2.]);\")]\n-            /// assert_eq!(v.reduce_max(), 2.);\n-            ///\n-            /// // NaN values are skipped...\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., \", stringify!($scalar), \"::NAN]);\")]\n-            /// assert_eq!(v.reduce_max(), 1.);\n-            ///\n-            /// // ...unless all values are NaN\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([\",\n-                stringify!($scalar), \"::NAN, \",\n-                stringify!($scalar), \"::NAN]);\"\n-            )]\n-            /// assert!(v.reduce_max().is_nan());\n-            /// ```\n-            #[inline]\n-            pub fn reduce_max(self) -> $scalar {\n-                // Safety: `self` is a float vector\n-                unsafe { simd_reduce_max(self) }\n-            }\n-\n-            /// Reducing minimum.  Returns the minimum lane in the vector.\n-            ///\n-            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.\n-            ///\n-            /// This function will not return `NaN` unless all lanes are `NaN`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([3., 7.]);\")]\n-            /// assert_eq!(v.reduce_min(), 3.);\n-            ///\n-            /// // NaN values are skipped...\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., \", stringify!($scalar), \"::NAN]);\")]\n-            /// assert_eq!(v.reduce_min(), 1.);\n-            ///\n-            /// // ...unless all values are NaN\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([\",\n-                stringify!($scalar), \"::NAN, \",\n-                stringify!($scalar), \"::NAN]);\"\n-            )]\n-            /// assert!(v.reduce_min().is_nan());\n-            /// ```\n-            #[inline]\n-            pub fn reduce_min(self) -> $scalar {\n-                // Safety: `self` is a float vector\n-                unsafe { simd_reduce_min(self) }\n-            }\n-        }\n-    }\n-}\n-\n-impl_float_reductions! { f32 }\n-impl_float_reductions! { f64 }"}, {"sha": "f836c99b1e2dc41564f0e85ad648f5ad2d476c04", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 1, "deletions": 210, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=04be48ff97757a803e934ab8d2e90631b59557f8", "patch": "@@ -1,145 +1,6 @@\n #![allow(non_camel_case_types)]\n \n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, Simd, SimdPartialEq, SimdPartialOrd, SupportedLaneCount};\n-\n-/// Implements inherent methods for a float vector containing multiple\n-/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n-/// representation.\n-macro_rules! impl_float_vector {\n-    { $type:ty, $bits_ty:ty, $mask_ty:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Raw transmutation to an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n-                unsafe { core::mem::transmute_copy(&self) }\n-            }\n-\n-            /// Raw transmutation from an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n-                unsafe { core::mem::transmute_copy(&bits) }\n-            }\n-\n-            /// Produces a vector where every lane has the absolute value of the\n-            /// equivalently-indexed lane in `self`.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn abs(self) -> Self {\n-                unsafe { intrinsics::simd_fabs(self) }\n-            }\n-\n-            /// Takes the reciprocal (inverse) of each lane, `1/x`.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn recip(self) -> Self {\n-                Self::splat(1.0) / self\n-            }\n-\n-            /// Converts each lane from radians to degrees.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_degrees(self) -> Self {\n-                // to_degrees uses a special constant for better precision, so extract that constant\n-                self * Self::splat(<$type>::to_degrees(1.))\n-            }\n-\n-            /// Converts each lane from degrees to radians.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_radians(self) -> Self {\n-                self * Self::splat(<$type>::to_radians(1.))\n-            }\n-\n-            /// Returns true for each lane if it has a positive sign, including\n-            /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n-                !self.is_sign_negative()\n-            }\n-\n-            /// Returns true for each lane if it has a negative sign, including\n-            /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n-                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n-                sign_bits.simd_gt(Simd::splat(0))\n-            }\n-\n-            /// Returns true for each lane if its value is `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n-                self.simd_ne(self)\n-            }\n-\n-            /// Returns true for each lane if its value is positive infinity or negative infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().simd_eq(Self::splat(<$type>::INFINITY))\n-            }\n-\n-            /// Returns true for each lane if its value is neither infinite nor `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().simd_lt(Self::splat(<$type>::INFINITY))\n-            }\n-\n-            /// Returns true for each lane if its value is subnormal.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().simd_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).simd_eq(Simd::splat(0))\n-            }\n-\n-            /// Returns true for each lane if its value is neither zero, infinite,\n-            /// subnormal, nor `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n-                !(self.abs().simd_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n-            }\n-\n-            /// Replaces each lane with a number that represents its sign.\n-            ///\n-            /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n-            /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n-            /// * `NAN` if the number is `NAN`\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn signum(self) -> Self {\n-                self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n-            }\n-\n-            /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n-            ///\n-            /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn copysign(self, sign: Self) -> Self {\n-                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n-                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n-                Self::from_bits(sign_bit | magnitude)\n-            }\n-        }\n-    };\n-}\n-\n-impl_float_vector! { f32, u32, i32 }\n-impl_float_vector! { f64, u64, i64 }\n+use crate::simd::Simd;\n \n /// A 64-bit SIMD vector with two elements of type `f32`.\n pub type f32x2 = Simd<f32, 2>;\n@@ -161,73 +22,3 @@ pub type f64x4 = Simd<f64, 4>;\n \n /// A 512-bit SIMD vector with eight elements of type `f64`.\n pub type f64x8 = Simd<f64, 8>;\n-\n-mod sealed {\n-    pub trait Sealed {}\n-}\n-use sealed::Sealed;\n-\n-/// SIMD operations on vectors of floating point numbers.\n-pub trait SimdFloat: Sized + Sealed {\n-    /// Returns the minimum of each lane.\n-    ///\n-    /// If one of the values is `NAN`, then the other value is returned.\n-    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-    fn simd_min(self, other: Self) -> Self;\n-\n-    /// Returns the maximum of each lane.\n-    ///\n-    /// If one of the values is `NAN`, then the other value is returned.\n-    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-    fn simd_max(self, other: Self) -> Self;\n-\n-    /// Restrict each lane to a certain interval unless it is NaN.\n-    ///\n-    /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n-    /// greater than `max`, and the corresponding lane in `min` if the lane is less\n-    /// than `min`.  Otherwise returns the lane in `self`.\n-    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-    fn simd_clamp(self, min: Self, max: Self) -> Self;\n-}\n-\n-macro_rules! impl_simd_float {\n-    { $($float:ty),* } => {\n-        $(\n-        impl <const LANES: usize> Sealed for Simd<$float, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-        }\n-\n-        impl <const LANES: usize> SimdFloat for Simd<$float, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            fn simd_min(self, other: Self) -> Self {\n-                unsafe { intrinsics::simd_fmin(self, other) }\n-            }\n-\n-            #[inline]\n-            fn simd_max(self, other: Self) -> Self {\n-                unsafe { intrinsics::simd_fmax(self, other) }\n-            }\n-\n-            #[inline]\n-            fn simd_clamp(self, min: Self, max: Self) -> Self {\n-                assert!(\n-                    min.simd_le(max).all(),\n-                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n-                );\n-                let mut x = self;\n-                x = x.simd_lt(min).select(min, x);\n-                x = x.simd_gt(max).select(max, x);\n-                x\n-            }\n-        }\n-        )*\n-    }\n-}\n-\n-impl_simd_float! { f32, f64 }"}, {"sha": "f759394d0758211d61abdb9dde5d1adbe150801e", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04be48ff97757a803e934ab8d2e90631b59557f8/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=04be48ff97757a803e934ab8d2e90631b59557f8", "patch": "@@ -348,6 +348,7 @@ macro_rules! impl_unsigned_tests {\n macro_rules! impl_float_tests {\n     { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n+            use core_simd::SimdFloat;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -464,7 +465,6 @@ macro_rules! impl_float_tests {\n                 }\n \n                 fn simd_min<const LANES: usize>() {\n-                    use core_simd::simd::SimdFloat;\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n                         &Vector::<LANES>::simd_min,\n@@ -488,7 +488,6 @@ macro_rules! impl_float_tests {\n                 }\n \n                 fn simd_max<const LANES: usize>() {\n-                    use core_simd::simd::SimdFloat;\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n                         &Vector::<LANES>::simd_max,\n@@ -512,7 +511,6 @@ macro_rules! impl_float_tests {\n                 }\n \n                 fn simd_clamp<const LANES: usize>() {\n-                    use core_simd::simd::SimdFloat;\n                     test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n                         for (min, max) in min.iter_mut().zip(max.iter_mut()) {\n                             if max < min {"}]}