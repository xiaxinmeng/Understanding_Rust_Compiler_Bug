{"sha": "c1e440a90f472468c8069ba6254b23c6feedc32e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZTQ0MGE5MGY0NzI0NjhjODA2OWJhNjI1NGIyM2M2ZmVlZGMzMmU=", "commit": {"author": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2019-10-06T15:26:14Z"}, "committer": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2019-10-06T15:26:14Z"}, "message": "redesign of the interface to the unikernel HermitCore\n\n- the old interface between HermitCore and the Rust Standard Library\n  based on a small C library (newlib)\n- remove this interface and call directly the unikernel\n- remove the dependency to the HermitCore linker\n- use rust-lld as linker", "tree": {"sha": "6e7920b36e0ecd63e8b7b1a6ec236ff5e86a5a01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7920b36e0ecd63e8b7b1a6ec236ff5e86a5a01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1e440a90f472468c8069ba6254b23c6feedc32e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e440a90f472468c8069ba6254b23c6feedc32e", "html_url": "https://github.com/rust-lang/rust/commit/c1e440a90f472468c8069ba6254b23c6feedc32e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1e440a90f472468c8069ba6254b23c6feedc32e/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "html_url": "https://github.com/rust-lang/rust/commit/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91"}], "stats": {"total": 2839, "additions": 2388, "deletions": 451}, "files": [{"sha": "c2aa75fd88fcc80376e2f09a93eec3afd593d564", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -160,7 +160,7 @@ mod job {\n     }\n }\n \n-#[cfg(any(target_os = \"haiku\", not(any(unix, windows))))]\n+#[cfg(any(target_os = \"haiku\", target_os = \"hermit\", not(any(unix, windows))))]\n mod job {\n     pub unsafe fn setup(_build: &mut crate::Build) {\n     }"}, {"sha": "5509f47bc8858ccdc5a668f71cf9f4f001ab32ff", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -54,7 +54,8 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n         core::intrinsics::abort();\n     }\n \n-    #[cfg(all(target_vendor=\"fortanix\", target_env=\"sgx\"))]\n+    #[cfg(any(target_os = \"hermit\",\n+              all(target_vendor=\"fortanix\", target_env=\"sgx\")))]\n     unsafe fn abort() -> ! {\n         // call std::sys::abort_internal\n         extern \"C\" { pub fn __rust_abort() -> !; }"}, {"sha": "8bee6ff09e551ef56f5a65a57a7e27530d209c2a", "filename": "src/libpanic_unwind/hermit.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibpanic_unwind%2Fhermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibpanic_unwind%2Fhermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fhermit.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,21 @@\n+//! Unwinding for *hermit* target.\n+//!\n+//! Right now we don't support this, so this is just stubs.\n+\n+use alloc::boxed::Box;\n+use core::ptr;\n+use core::any::Any;\n+\n+pub fn payload() -> *mut u8 {\n+    ptr::null_mut()\n+}\n+\n+pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n+    extern \"C\" { pub fn __rust_abort() -> !; }\n+    __rust_abort();\n+}\n+\n+pub unsafe fn panic(_data: Box<dyn Any + Send>) -> u32 {\n+    extern \"C\" { pub fn __rust_abort() -> !; }\n+    __rust_abort();\n+}"}, {"sha": "2089a02083c59a4d1855950d6d0e531231a21614", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -43,6 +43,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_arch = \"wasm32\")] {\n         #[path = \"dummy.rs\"]\n         mod imp;\n+    } else if #[cfg(target_os = \"hermit\")] {\n+        #[path = \"hermit.rs\"]\n+        mod imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {\n         #[path = \"dummy.rs\"]\n         mod imp;"}, {"sha": "f31de4dbd519418174790c755bc06ae12dfd4578", "filename": "src/librustc_target/spec/hermit_base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -1,26 +1,26 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, PanicStrategy, TargetOptions};\n+use crate::spec::{LldFlavor, LinkArgs, LinkerFlavor, PanicStrategy, TargetOptions};\n use std::default::Default;\n \n pub fn opts() -> TargetOptions {\n-    let mut args = LinkArgs::new();\n-    args.insert(LinkerFlavor::Gcc, vec![\n-        \"-Wl,-Bstatic\".to_string(),\n-        \"-Wl,--no-dynamic-linker\".to_string(),\n-        \"-Wl,--gc-sections\".to_string(),\n-        \"-Wl,--as-needed\".to_string(),\n+    let mut pre_link_args = LinkArgs::new();\n+    pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Ld), vec![\n+        \"--build-id\".to_string(),\n+        \"--hash-style=gnu\".to_string(),\n+        \"--Bstatic\".to_string(),\n     ]);\n \n     TargetOptions {\n+        linker: Some(\"rust-lld\".to_owned()),\n         executables: true,\n         has_elf_tls: true,\n         linker_is_gnu: true,\n-        no_default_libraries: false,\n+        pre_link_args,\n+        no_default_libraries: true,\n         panic_strategy: PanicStrategy::Abort,\n-        position_independent_executables: false,\n-        pre_link_args: args,\n+        position_independent_executables: true,\n         relocation_model: \"static\".to_string(),\n-        target_family: Some(\"unix\".to_string()),\n-        tls_model: \"local-exec\".to_string(),\n+        target_family: None,\n+        tls_model: \"initial-exec\".to_string(),\n         .. Default::default()\n     }\n }"}, {"sha": "b8be43be09766845cd8852eea8607216fc2efa39", "filename": "src/librustc_target/spec/x86_64_unknown_hermit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LldFlavor, LinkerFlavor, Target, TargetResult};\n \n pub fn target() -> TargetResult {\n     let mut base = super::hermit_base::opts();\n     base.cpu = \"x86-64\".to_string();\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n-    base.linker = Some(\"x86_64-hermit-gcc\".to_string());\n     base.max_atomic_width = Some(64);\n+    base.features = \"+rdrnd,+rdseed\".to_string();\n+    base.stack_probes = true;\n \n     Ok(Target {\n         llvm_target: \"x86_64-unknown-hermit\".to_string(),\n@@ -17,7 +17,7 @@ pub fn target() -> TargetResult {\n         target_os: \"hermit\".to_string(),\n         target_env: String::new(),\n         target_vendor: \"unknown\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: base,\n     })\n }"}, {"sha": "cf440924b2e63cc6d92b001a2d95e52513a70175", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -346,6 +346,7 @@ impl<'a> fmt::Display for Html<'a> {\n                         \"freebsd\" => \"FreeBSD\",\n                         \"fuchsia\" => \"Fuchsia\",\n                         \"haiku\" => \"Haiku\",\n+                        \"hermit\" => \"HermitCore\",\n                         \"ios\" => \"iOS\",\n                         \"l4re\" => \"L4Re\",\n                         \"linux\" => \"Linux\","}, {"sha": "1f839f165320f4a383cb7c1b5c512abdd8596a0d", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -54,5 +54,7 @@ fn main() {\n         }\n         println!(\"cargo:rustc-link-lib=c\");\n         println!(\"cargo:rustc-link-lib=compiler_rt\");\n+    } else if target.contains(\"hermit\") {\n+        println!(\"cargo:rustc-link-lib=hermit\");\n     }\n }"}, {"sha": "eb28a839ba86582871bcecba8922aeb7b49f144d", "filename": "src/libstd/os/hermit/fs.rs", "status": "removed", "additions": 0, "deletions": 377, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs?ref=7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "patch": "@@ -1,377 +0,0 @@\n-#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-\n-use crate::fs::Metadata;\n-use crate::sys_common::AsInner;\n-\n-#[allow(deprecated)]\n-use crate::os::hermit::raw;\n-\n-/// OS-specific extensions to [`fs::Metadata`].\n-///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-pub trait MetadataExt {\n-    /// Gain a reference to the underlying `stat` structure which contains\n-    /// the raw information returned by the OS.\n-    ///\n-    /// The contents of the returned [`stat`] are **not** consistent across\n-    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n-    /// cross-Unix abstractions contained within the raw stat.\n-    ///\n-    /// [`stat`]: ../../../../std/os/linux/raw/struct.stat.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let stat = meta.as_raw_stat();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n-    #[allow(deprecated)]\n-    fn as_raw_stat(&self) -> &raw::stat;\n-\n-    /// Returns the device ID on which this file resides.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_dev());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_dev(&self) -> u64;\n-    /// Returns the inode number.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_ino());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ino(&self) -> u64;\n-    /// Returns the file type and mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_mode());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mode(&self) -> u32;\n-    /// Returns the number of hard links to file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_nlink());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_nlink(&self) -> u64;\n-    /// Returns the user ID of the file owner.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_uid());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_uid(&self) -> u32;\n-    /// Returns the group ID of the file owner.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_gid());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_gid(&self) -> u32;\n-    /// Returns the device ID that this file represents. Only relevant for special file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_rdev());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_rdev(&self) -> u64;\n-    /// Returns the size of the file (if it is a regular file or a symbolic link) in bytes.\n-    ///\n-    /// The size of a symbolic link is the length of the pathname it contains,\n-    /// without a terminating null byte.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_size());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_size(&self) -> u64;\n-    /// Returns the last access time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_atime());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_atime(&self) -> i64;\n-    /// Returns the last access time, nano seconds part.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_atime_nsec());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_atime_nsec(&self) -> i64;\n-    /// Returns the last modification time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_mtime());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mtime(&self) -> i64;\n-    /// Returns the last modification time, nano seconds part.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_mtime_nsec());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mtime_nsec(&self) -> i64;\n-    /// Returns the last status change time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_ctime());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ctime(&self) -> i64;\n-    /// Returns the last status change time, nano seconds part.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_ctime_nsec());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ctime_nsec(&self) -> i64;\n-    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_blksize());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_blksize(&self) -> u64;\n-    /// Returns the number of blocks allocated to the file, 512-byte units.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_blocks());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_blocks(&self) -> u64;\n-}\n-\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-impl MetadataExt for Metadata {\n-    #[allow(deprecated)]\n-    fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat64\n-                                          as *const raw::stat)\n-        }\n-    }\n-    fn st_dev(&self) -> u64 {\n-        self.as_inner().as_inner().st_dev as u64\n-    }\n-    fn st_ino(&self) -> u64 {\n-        self.as_inner().as_inner().st_ino as u64\n-    }\n-    fn st_mode(&self) -> u32 {\n-        self.as_inner().as_inner().st_mode as u32\n-    }\n-    fn st_nlink(&self) -> u64 {\n-        self.as_inner().as_inner().st_nlink as u64\n-    }\n-    fn st_uid(&self) -> u32 {\n-        self.as_inner().as_inner().st_uid as u32\n-    }\n-    fn st_gid(&self) -> u32 {\n-        self.as_inner().as_inner().st_gid as u32\n-    }\n-    fn st_rdev(&self) -> u64 {\n-        self.as_inner().as_inner().st_rdev as u64\n-    }\n-    fn st_size(&self) -> u64 {\n-        self.as_inner().as_inner().st_size as u64\n-    }\n-    fn st_atime(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime as i64\n-    }\n-    fn st_atime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime_nsec as i64\n-    }\n-    fn st_mtime(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime as i64\n-    }\n-    fn st_mtime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime_nsec as i64\n-    }\n-    fn st_ctime(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime as i64\n-    }\n-    fn st_ctime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime_nsec as i64\n-    }\n-    fn st_blksize(&self) -> u64 {\n-        self.as_inner().as_inner().st_blksize as u64\n-    }\n-    fn st_blocks(&self) -> u64 {\n-        self.as_inner().as_inner().st_blocks as u64\n-    }\n-}"}, {"sha": "4dee2a6d43397313e2c68b105bfd9007ba976fb1", "filename": "src/libstd/os/hermit/mod.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs?ref=7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "patch": "@@ -1,6 +0,0 @@\n-//! HermitCore-specific definitions\n-\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-\n-pub mod raw;\n-pub mod fs;"}, {"sha": "0e232a808a09766a004ea36776a585dbdb8e69e8", "filename": "src/libstd/os/hermit/raw.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs?ref=7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "patch": "@@ -1,17 +0,0 @@\n-//! HermitCore-specific raw type definitions\n-\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n-#![allow(deprecated)]\n-#![allow(missing_debug_implementations)]\n-\n-#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n-pub use libc::pthread_t;\n-\n-#[doc(inline)]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use libc::{dev_t, mode_t, off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};"}, {"sha": "d44c8ca544e807076f9dbd69b1c3fa1f44f5cbe3", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -49,7 +49,6 @@ cfg_if::cfg_if! {\n #[cfg(target_os = \"solaris\")]    pub mod solaris;\n #[cfg(target_os = \"emscripten\")] pub mod emscripten;\n #[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n-#[cfg(target_os = \"hermit\")]     pub mod hermit;\n #[cfg(target_os = \"redox\")]      pub mod redox;\n #[cfg(target_os = \"wasi\")]       pub mod wasi;\n #[cfg(target_os = \"vxworks\")]    pub mod vxworks;"}, {"sha": "7a5b46be2523155e9cb1d46d208776b9be61686c", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -59,7 +59,6 @@ fn lang_start_internal(main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindS\n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start<T: crate::process::Termination + 'static>\n-    (main: fn() -> T, argc: isize, argv: *const *const u8) -> isize\n-{\n+    (main: fn() -> T, argc: isize, argv: *const *const u8) -> isize {\n     lang_start_internal(&move || main().report(), argc, argv)\n }"}, {"sha": "802a179fb67225dcf7ced23c63dffbe21e5d415b", "filename": "src/libstd/sys/hermit/alloc.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,40 @@\n+use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ptr;\n+\n+extern \"C\" {\n+    fn sys_malloc(size: usize, align: usize) -> *mut u8;\n+    fn sys_realloc(ptr: *mut u8, size: usize, align: usize, new_size: usize) -> *mut u8;\n+    fn sys_free(ptr: *mut u8, size: usize, align: usize);\n+}\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        sys_malloc(layout.size(), layout.align())\n+    }\n+\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        let addr = sys_malloc(layout.size(), layout.align());\n+\n+        if !addr.is_null() {\n+            ptr::write_bytes(\n+                addr,\n+                0x00,\n+                layout.size()\n+            );\n+        }\n+\n+        addr\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        sys_free(ptr, layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        sys_realloc(ptr, layout.size(), layout.align(), new_size)\n+    }\n+}"}, {"sha": "5b1f3add51fe06c9c172de361bfea597a8e928c0", "filename": "src/libstd/sys/hermit/args.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,82 @@\n+use crate::ffi::OsString;\n+use crate::marker::PhantomData;\n+use crate::vec;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+\n+/// One-time global cleanup.\n+pub unsafe fn cleanup() { imp::cleanup() }\n+\n+/// Returns the command line arguments\n+pub fn args() -> Args {\n+    imp::args()\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        self.iter.as_slice()\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n+mod imp {\n+    use crate::sys_common::os_str_bytes::*;\n+    use crate::ptr;\n+    use crate::ffi::{CStr, OsString};\n+    use crate::marker::PhantomData;\n+    use super::Args;\n+\n+    use crate::sys_common::mutex::Mutex;\n+\n+    static mut ARGC: isize = 0;\n+    static mut ARGV: *const *const u8 = ptr::null();\n+    static LOCK: Mutex = Mutex::new();\n+\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+        let _guard = LOCK.lock();\n+        ARGC = argc;\n+        ARGV = argv;\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        let _guard = LOCK.lock();\n+        ARGC = 0;\n+        ARGV = ptr::null();\n+    }\n+\n+    pub fn args() -> Args {\n+        Args {\n+            iter: clone().into_iter(),\n+            _dont_send_or_sync_me: PhantomData\n+        }\n+    }\n+\n+    fn clone() -> Vec<OsString> {\n+        unsafe {\n+            let _guard = LOCK.lock();\n+            (0..ARGC).map(|i| {\n+                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n+                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+            }).collect()\n+        }\n+    }\n+}"}, {"sha": "fa7783122c2e9baad872c6d928c3bb3372421ffb", "filename": "src/libstd/sys/hermit/cmath.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,29 @@\n+// These symbols are all defined in `compiler-builtins`\n+extern {\n+    pub fn acos(n: f64) -> f64;\n+    pub fn acosf(n: f32) -> f32;\n+    pub fn asin(n: f64) -> f64;\n+    pub fn asinf(n: f32) -> f32;\n+    pub fn atan(n: f64) -> f64;\n+    pub fn atan2(a: f64, b: f64) -> f64;\n+    pub fn atan2f(a: f32, b: f32) -> f32;\n+    pub fn atanf(n: f32) -> f32;\n+    pub fn cbrt(n: f64) -> f64;\n+    pub fn cbrtf(n: f32) -> f32;\n+    pub fn cosh(n: f64) -> f64;\n+    pub fn coshf(n: f32) -> f32;\n+    pub fn expm1(n: f64) -> f64;\n+    pub fn expm1f(n: f32) -> f32;\n+    pub fn fdim(a: f64, b: f64) -> f64;\n+    pub fn fdimf(a: f32, b: f32) -> f32;\n+    pub fn hypot(x: f64, y: f64) -> f64;\n+    pub fn hypotf(x: f32, y: f32) -> f32;\n+    pub fn log1p(n: f64) -> f64;\n+    pub fn log1pf(n: f32) -> f32;\n+    pub fn sinh(n: f64) -> f64;\n+    pub fn sinhf(n: f32) -> f32;\n+    pub fn tan(n: f64) -> f64;\n+    pub fn tanf(n: f32) -> f32;\n+    pub fn tanh(n: f64) -> f64;\n+    pub fn tanhf(n: f32) -> f32;\n+}"}, {"sha": "1cd97d95ad2366578852704a7bf54a1a494d61ff", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,68 @@\n+use crate::cmp;\n+use crate::sys::mutex::Mutex;\n+use crate::time::Duration;\n+\n+pub struct Condvar {\n+    identifier: usize,\n+}\n+\n+extern \"C\" {\n+   fn sys_notify(id: usize, count: i32) -> i32;\n+   fn sys_add_queue(id: usize, timeout_ns: i64) -> i32;\n+   fn sys_wait(id: usize) -> i32;\n+   fn sys_destroy_queue(id: usize) -> i32;\n+}\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { identifier: 0 }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        // nothing to do\n+    }\n+\n+    pub unsafe fn notify_one(&self) {\n+         let _ = sys_notify(self.id(), 1);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+         let _ = sys_notify(self.id(), -1 /* =all */);\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        // add current task to the wait queue\n+        let _ = sys_add_queue(self.id(), -1 /* no timeout */);\n+        mutex.unlock();\n+        let _ = sys_wait(self.id());\n+        mutex.lock();\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let nanos = dur.as_nanos();\n+        let nanos = cmp::min(i64::max_value() as u128, nanos);\n+\n+        // add current task to the wait queue\n+        let _ = sys_add_queue(self.id(), nanos as i64);\n+\n+        mutex.unlock();\n+        // If the return value is !0 then a timeout happened, so we return\n+        // `false` as we weren't actually notified.\n+        let ret = sys_wait(self.id()) == 0;\n+        mutex.lock();\n+\n+        ret\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let _ = sys_destroy_queue(self.id());\n+    }\n+\n+    #[inline]\n+    fn id(&self) -> usize {\n+        &self.identifier as *const usize as usize\n+    }\n+}"}, {"sha": "7a0fcb31ef2e87a66f2768aa263b8bf953ad28ca", "filename": "src/libstd/sys/hermit/env.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fenv.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,9 @@\n+pub mod os {\n+    pub const FAMILY: &str = \"\";\n+    pub const OS: &str = \"hermit\";\n+    pub const DLL_PREFIX: &str = \"\";\n+    pub const DLL_SUFFIX: &str = \"\";\n+    pub const DLL_EXTENSION: &str = \"\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "05464787a05d3c594f5bdd203715bff88b460d47", "filename": "src/libstd/sys/hermit/fast_thread_local.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffast_thread_local.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,4 @@\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;"}, {"sha": "cbc167a677f314a80bb3f9c653f12899f20c16c1", "filename": "src/libstd/sys/hermit/fd.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,87 @@\n+#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n+\n+use crate::io::{self, Read, ErrorKind};\n+use crate::mem;\n+use crate::sys::cvt;\n+use crate::sys_common::AsInner;\n+\n+extern {\n+    fn sys_read(fd: i32, buf: *mut u8, len: usize) -> isize;\n+    fn sys_write(fd: i32, buf: *const u8, len: usize) -> isize;\n+    fn sys_close(fd: i32) -> i32;\n+}\n+\n+#[derive(Debug)]\n+pub struct FileDesc {\n+    fd: i32,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: i32) -> FileDesc {\n+        FileDesc { fd }\n+    }\n+\n+    pub fn raw(&self) -> i32 { self.fd }\n+\n+    /// Extracts the actual file descriptor without closing it.\n+    pub fn into_raw(self) -> i32 {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let result = unsafe { sys_read(self.fd, buf.as_mut_ptr(), buf.len()) };\n+        cvt(result as i32)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let result = unsafe { sys_write(self.fd, buf.as_ptr(), buf.len()) };\n+        cvt(result as i32)\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<FileDesc> {\n+        self.duplicate_path(&[])\n+    }\n+    pub fn duplicate_path(&self, _path: &[u8]) -> io::Result<FileDesc> {\n+        Err(io::Error::new(ErrorKind::Other, \"duplicate isn't supported\"))\n+    }\n+\n+    pub fn nonblocking(&self) -> io::Result<bool> {\n+        Ok(false)\n+    }\n+\n+    pub fn set_cloexec(&self) -> io::Result<()> {\n+        Err(io::Error::new(ErrorKind::Other, \"cloexec isn't supported\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {\n+        Err(io::Error::new(ErrorKind::Other, \"nonblocking isn't supported\"))\n+    }\n+}\n+\n+impl<'a> Read for &'a FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+}\n+\n+impl AsInner<i32> for FileDesc {\n+    fn as_inner(&self) -> &i32 { &self.fd }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // Note that errors are ignored when closing a file descriptor. The\n+        // reason for this is that if an error occurs we don't actually know if\n+        // the file descriptor was closed or not, and if we retried (for\n+        // something like EINTR), we might close another valid file descriptor\n+        // (opened after we closed ours.\n+        let _ = unsafe { sys_close(self.fd) };\n+    }\n+}"}, {"sha": "2cec93e3e5e451410c38063c7cab08d5afe48c7f", "filename": "src/libstd/sys/hermit/fs.rs", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,389 @@\n+use crate::ffi::{OsString, CString, CStr};\n+use crate::fmt;\n+use crate::io::{self, Error, ErrorKind};\n+use crate::hash::{Hash, Hasher};\n+use crate::io::{SeekFrom, IoSlice, IoSliceMut};\n+use crate::path::{Path, PathBuf};\n+use crate::sys::time::SystemTime;\n+use crate::sys::{unsupported, Void};\n+use crate::sys::hermit::fd::FileDesc;\n+use crate::sys::cvt;\n+use crate::sys_common::os_str_bytes::OsStrExt;\n+\n+pub use crate::sys_common::fs::copy;\n+//pub use crate::sys_common::fs::remove_dir_all;\n+\n+extern {\n+    fn sys_open(name: *const i8, flags: i32, mode: i32) -> i32;\n+    fn sys_unlink(name: *const i8) -> i32;\n+}\n+\n+fn cstr(path: &Path) -> io::Result<CString> {\n+    Ok(CString::new(path.as_os_str().as_bytes())?)\n+}\n+//const O_ACCMODE: i32 = 00000003;\n+const O_RDONLY: i32 = 00000000;\n+const O_WRONLY: i32 = 00000001;\n+const O_RDWR: i32 = 00000002;\n+const O_CREAT: i32 = 00000100;\n+const O_EXCL: i32 = 00000200;\n+const O_TRUNC: i32 = 00001000;\n+const O_APPEND: i32 = 00002000;\n+\n+#[derive(Debug)]\n+pub struct File(FileDesc);\n+\n+pub struct FileAttr(Void);\n+\n+pub struct ReadDir(Void);\n+\n+pub struct DirEntry(Void);\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions {\n+    // generic\n+    read: bool,\n+    write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    mode: i32\n+}\n+\n+pub struct FilePermissions(Void);\n+\n+pub struct FileType(Void);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder { }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        match self.0 {}\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        match self.0 {}\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileAttr {\n+    fn clone(&self) -> FileAttr {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_readonly(&mut self, _readonly: bool) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FilePermissions {\n+    fn clone(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+}\n+\n+impl PartialEq for FilePermissions {\n+    fn eq(&self, _other: &FilePermissions) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FilePermissions {\n+}\n+\n+impl fmt::Debug for FilePermissions {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_file(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_symlink(&self) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileType {\n+    fn clone(&self) -> FileType {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for FileType {}\n+\n+impl PartialEq for FileType {\n+    fn eq(&self, _other: &FileType) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FileType {\n+}\n+\n+impl Hash for FileType {\n+    fn hash<H: Hasher>(&self, _h: &mut H) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for FileType {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        match self.0 {}\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            mode: 0x777\n+        }\n+    }\n+\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    fn get_access_mode(&self) -> io::Result<i32> {\n+        match (self.read, self.write, self.append) {\n+            (true,  false, false) => Ok(O_RDONLY),\n+            (false, true,  false) => Ok(O_WRONLY),\n+            (true,  true,  false) => Ok(O_RDWR),\n+            (false, _,     true)  => Ok(O_WRONLY | O_APPEND),\n+            (true,  _,     true)  => Ok(O_RDWR | O_APPEND),\n+            (false, false, false) => Err(io::Error::new(ErrorKind::InvalidInput, \"invalid access mode\")),\n+        }\n+    }\n+\n+    fn get_creation_mode(&self) -> io::Result<i32> {\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) =>\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n+                },\n+            (_, true) =>\n+                if self.truncate && !self.create_new {\n+                    return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n+                },\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => 0,\n+                (true,  false, false) => O_CREAT,\n+                (false, true,  false) => O_TRUNC,\n+                (true,  true,  false) => O_CREAT | O_TRUNC,\n+                (_,      _,    true)  => O_CREAT | O_EXCL,\n+           })\n+    }\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let path = cstr(path)?;\n+        File::open_c(&path, opts)\n+    }\n+\n+    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n+        let mut flags = opts.get_access_mode()?;\n+        flags = flags | opts.get_creation_mode()?;\n+\n+        let mode;\n+        if flags & O_CREAT == O_CREAT {\n+            mode = opts.mode;\n+        } else {\n+            mode = 0;\n+        }\n+\n+        let fd = unsafe { cvt(sys_open(path.as_ptr(), flags, mode))? };\n+        Ok(File(FileDesc::new(fd as i32)))\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        self.fsync()\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        loop {}\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { }\n+    }\n+\n+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n+    unsupported()\n+}\n+\n+pub fn unlink(path: &Path) -> io::Result<()> {\n+    let name = cstr(path)?;\n+    let _ = unsafe { cvt(sys_unlink(name.as_ptr()))? };\n+    Ok(())\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    match perm.0 {}\n+}\n+\n+pub fn rmdir(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n+    //unsupported()\n+    Ok(())\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}"}, {"sha": "976e122463d1b80ea9f60350ffb8dad875e9b741", "filename": "src/libstd/sys/hermit/io.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fio.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,46 @@\n+use crate::mem;\n+\n+pub struct IoSlice<'a>(&'a [u8]);\n+\n+impl<'a> IoSlice<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n+        IoSlice(buf)\n+    }\n+\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0 = &self.0[n..]\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoSliceMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoSliceMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n+        IoSliceMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        let (_, remaining) = slice.split_at_mut(n);\n+        self.0 = remaining;\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "9967482197eb3642a1e1fef3d1cdc04b9c05711d", "filename": "src/libstd/sys/hermit/memchr.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmemchr.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1 @@\n+pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "c413b3e5323649164c052b490f965ae19af65daf", "filename": "src/libstd/sys/hermit/mod.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,148 @@\n+//! System bindings for HermitCore\n+//!\n+//! This module contains the facade (aka platform-specific) implementations of\n+//! OS level functionality for HermitCore.\n+//!\n+//! This is all super highly experimental and not actually intended for\n+//! wide/production use yet, it's still all in the experimental category. This\n+//! will likely change over time.\n+//!\n+//! Currently all functions here are basically stubs that immediately return\n+//! errors. The hope is that with a portability lint we can turn actually just\n+//! remove all this and just omit parts of the standard library if we're\n+//! compiling for wasm. That way it's a compile time error for something that's\n+//! guaranteed to be a runtime error!\n+\n+use crate::os::raw::c_char;\n+use crate::intrinsics;\n+\n+pub mod alloc;\n+pub mod args;\n+pub mod condvar;\n+pub mod stdio;\n+pub mod memchr;\n+pub mod io;\n+pub mod mutex;\n+pub mod rwlock;\n+pub mod os;\n+pub mod cmath;\n+pub mod thread;\n+pub mod env;\n+pub mod fs;\n+pub mod fd;\n+pub mod net;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod stack_overflow;\n+pub mod time;\n+pub mod thread_local;\n+pub mod fast_thread_local;\n+\n+pub use crate::sys_common::os_str_bytes as os_str;\n+use crate::io::ErrorKind;\n+\n+pub fn unsupported<T>() -> crate::io::Result<T> {\n+    Err(unsupported_err())\n+}\n+\n+pub fn unsupported_err() -> crate::io::Error {\n+    crate::io::Error::new(crate::io::ErrorKind::Other,\n+           \"operation not supported on HermitCore yet\")\n+}\n+\n+// This enum is used as the storage for a bunch of types which can't actually\n+// exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub unsafe fn strlen(start: *const c_char) -> usize {\n+    let mut str = start;\n+\n+    while *str != 0 {\n+        str = str.offset(1);\n+    }\n+\n+    (str as usize) - (start as usize)\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn floor(x: f64) -> f64 {\n+    unsafe {\n+        intrinsics::floorf64(x)\n+    }\n+}\n+\n+pub unsafe fn abort_internal() -> ! {\n+    extern \"C\" {\n+        fn sys_abort() ->!;\n+    }\n+\n+    sys_abort();\n+}\n+\n+// TODO: just a workaround to test the system\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (1, 2)\n+}\n+\n+// This function is needed by the panic runtime. The symbol is named in\n+// pre-link args for the target specification, so keep that in sync.\n+#[cfg(not(test))]\n+#[no_mangle]\n+// NB. used by both libunwind and libpanic_abort\n+pub unsafe extern \"C\" fn __rust_abort() {\n+    abort_internal();\n+}\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+    unsafe {\n+        let _ = net::init();\n+    }\n+}\n+\n+#[cfg(not(test))]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn runtime_entry(argc: i32, argv: *const *const c_char, env: *const *const c_char) -> ! {\n+    extern \"C\" {\n+        fn main(argc: isize, argv: *const *const c_char) -> i32;\n+        fn sys_exit(arg: i32) ->!;\n+    }\n+\n+    // initialize environment\n+    os::init_environment(env as *const *const i8);\n+\n+    let result = main(argc as isize, argv);\n+\n+    sys_exit(result);\n+}\n+\n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno {\n+        x if x == 13 as i32 => ErrorKind::PermissionDenied,\n+        x if x == 98 as i32 => ErrorKind::AddrInUse,\n+        x if x == 99 as i32 => ErrorKind::AddrNotAvailable,\n+        x if x == 11 as i32 => ErrorKind::WouldBlock,\n+        x if x == 103 as i32 => ErrorKind::ConnectionAborted,\n+        x if x == 111 as i32 => ErrorKind::ConnectionRefused,\n+        x if x == 104 as i32 => ErrorKind::ConnectionReset,\n+        x if x == 17 as i32 => ErrorKind::AlreadyExists,\n+        x if x == 4 as i32 => ErrorKind::Interrupted,\n+        x if x == 22 as i32 => ErrorKind::InvalidInput,\n+        x if x == 2 as i32 => ErrorKind::NotFound,\n+        x if x == 107 as i32 => ErrorKind::NotConnected,\n+        x if x == 1 as i32 => ErrorKind::PermissionDenied,\n+        x if x == 32 as i32 => ErrorKind::BrokenPipe,\n+        x if x == 110 as i32 => ErrorKind::TimedOut,\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n+pub fn cvt(result: i32) -> crate::io::Result<usize> {\n+    if result < 0 {\n+        Err(crate::io::Error::from_raw_os_error(-result))\n+    } else {\n+        Ok(result as usize)\n+    }\n+}"}, {"sha": "f119c66a6dc48db47ad58e0d03a4dc7e6db5d99c", "filename": "src/libstd/sys/hermit/mutex.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,88 @@\n+use crate::ptr;\n+use crate::ffi::c_void;\n+\n+extern \"C\" {\n+    fn sys_sem_init(sem: *mut *const c_void, value: u32) -> i32;\n+    fn sys_sem_destroy(sem: *const c_void) -> i32;\n+    fn sys_sem_post(sem: *const c_void) -> i32;\n+    fn sys_sem_trywait(sem: *const c_void) -> i32;\n+    fn sys_sem_timedwait(sem: *const c_void, ms: u32) -> i32;\n+    fn sys_recmutex_init(recmutex: *mut *const c_void) -> i32;\n+    fn sys_recmutex_destroy(recmutex: *const c_void) -> i32;\n+    fn sys_recmutex_lock(recmutex: *const c_void) -> i32;\n+    fn sys_recmutex_unlock(recmutex: *const c_void) -> i32;\n+}\n+\n+pub struct Mutex {\n+    inner: *const c_void\n+}\n+\n+unsafe impl Send for Mutex {}\n+unsafe impl Sync for Mutex {}\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { inner: ptr::null() }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        let _ = sys_sem_init(&mut self.inner as *mut *const c_void, 1);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let _ = sys_sem_timedwait(self.inner, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let _ = sys_sem_post(self.inner);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let result = sys_sem_trywait(self.inner);\n+        result == 0\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let _ = sys_sem_destroy(self.inner);\n+    }\n+}\n+\n+pub struct ReentrantMutex {\n+    inner: *const c_void\n+}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex { inner: ptr::null() }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        let _ = sys_recmutex_init(&mut self.inner as *mut *const c_void);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let _ = sys_recmutex_lock(self.inner);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let _ = sys_recmutex_unlock(self.inner);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let _ = sys_recmutex_destroy(self.inner);\n+    }\n+}"}, {"sha": "5b7ff642271c5e8e0acee268d42848a49c04ee93", "filename": "src/libstd/sys/hermit/net.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,364 @@\n+use crate::fmt;\n+use crate::convert::TryFrom;\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use crate::str;\n+use crate::sys::{unsupported, Void};\n+use crate::time::Duration;\n+\n+//// Iinitializes HermitCore's network stack\n+pub unsafe fn init() -> io::Result<()> {\n+    Ok(())\n+}\n+\n+pub struct TcpStream(Void);\n+\n+impl TcpStream {\n+    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct TcpListener(Void);\n+\n+impl TcpListener {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct UdpSocket(Void);\n+\n+impl UdpSocket {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n+        unsupported()\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct LookupHost(Void);\n+\n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<SocketAddr> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl TryFrom<&str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: &str) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+#[allow(nonstandard_style)]\n+pub mod netc {\n+    pub const AF_INET: u8 = 0;\n+    pub const AF_INET6: u8 = 1;\n+    pub type sa_family_t = u8;\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in_addr {\n+        pub s_addr: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in {\n+        pub sin_family: sa_family_t,\n+        pub sin_port: u16,\n+        pub sin_addr: in_addr,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in6_addr {\n+        pub s6_addr: [u8; 16],\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in6 {\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: u16,\n+        pub sin6_addr: in6_addr,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr {\n+    }\n+\n+    pub type socklen_t = usize;\n+}"}, {"sha": "cdac1c74dcb85eae5ff18191fabd7ac0413c32a4", "filename": "src/libstd/sys/hermit/os.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,178 @@\n+use crate::error::Error as StdError;\n+use crate::ffi::{CStr, OsString, OsStr};\n+use crate::fmt;\n+use crate::io;\n+use crate::marker::PhantomData;\n+use crate::memchr;\n+use crate::path::{self, PathBuf};\n+use crate::ptr;\n+use crate::str;\n+use crate::sys::{unsupported, Void};\n+use crate::collections::HashMap;\n+use crate::vec;\n+use crate::sync::Mutex;\n+use crate::sys_common::os_str_bytes::*;\n+\n+extern \"C\" {\n+    fn sys_getpid() -> u32;\n+    fn sys_exit(arg: i32) ->!;\n+}\n+\n+pub fn errno() -> i32 {\n+    0\n+}\n+\n+pub fn error_string(_errno: i32) -> String {\n+    \"operation successful\".to_string()\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub struct SplitPaths<'a>(&'a Void);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        match *self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"not supported on hermit yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str {\n+        \"not supported on hermit yet\"\n+    }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+static mut ENV: Option<Mutex<HashMap<OsString, OsString>>> = None;\n+\n+pub fn init_environment(env: *const *const i8) {\n+    unsafe {\n+        ENV = Some(Mutex::new(HashMap::new()));\n+\n+        let mut guard = ENV.as_ref().unwrap().lock().unwrap();\n+        let mut environ = env;\n+        while environ != ptr::null() && *environ != ptr::null() {\n+            if let Some((key,value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+                guard.insert(key, value);\n+            }\n+            environ = environ.offset(1);\n+        }\n+    }\n+\n+    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n+        // Strategy (copied from glibc): Variable name and value are separated\n+        // by an ASCII equals sign '='. Since a variable name must not be\n+        // empty, allow variable names starting with an equals sign. Skip all\n+        // malformed lines.\n+        if input.is_empty() {\n+            return None;\n+        }\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n+        pos.map(|p| (\n+            OsStringExt::from_vec(input[..p].to_vec()),\n+            OsStringExt::from_vec(input[p+1..].to_vec()),\n+        ))\n+    }\n+}\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+   unsafe {\n+        let guard = ENV.as_ref().unwrap().lock().unwrap();\n+        let mut result = Vec::new();\n+\n+        for (key, value) in guard.iter() {\n+            result.push((key.clone(), value.clone()));\n+        }\n+\n+        return Env {\n+            iter: result.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+}\n+\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    unsafe {\n+        match ENV.as_ref().unwrap().lock().unwrap().get_mut(k) {\n+            Some(value) => { Ok(Some(value.clone())) },\n+            None => { Ok(None) },\n+        }\n+    }\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    unsafe {\n+        let (k, v) = (k.to_owned(), v.to_owned());\n+        ENV.as_ref().unwrap().lock().unwrap().insert(k, v);\n+    }\n+    Ok(())\n+}\n+\n+pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n+    unsafe {\n+        ENV.as_ref().unwrap().lock().unwrap().remove(k);\n+    }\n+    Ok(())\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    panic!(\"no filesystem on hermit\")\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe {\n+        sys_exit(code);\n+    }\n+}\n+\n+pub fn getpid() -> u32 {\n+    unsafe {\n+        sys_getpid()\n+    }\n+}"}, {"sha": "7a1839561078575c74850ce343f81b0989767916", "filename": "src/libstd/sys/hermit/path.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,19 @@\n+use crate::path::Prefix;\n+use crate::ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "9f07f054362feb550124adaaf5f3951dae58ed3c", "filename": "src/libstd/sys/hermit/pipe.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,33 @@\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::sys::Void;\n+\n+pub struct AnonPipe(Void);\n+\n+impl AnonPipe {\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn read2(p1: AnonPipe,\n+             _v1: &mut Vec<u8>,\n+             _p2: AnonPipe,\n+             _v2: &mut Vec<u8>) -> io::Result<()> {\n+    match p1.0 {}\n+}"}, {"sha": "edf933d10e07433f52f9ae280b89b1b7d16e5658", "filename": "src/libstd/sys/hermit/process.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,154 @@\n+use crate::ffi::OsStr;\n+use crate::fmt;\n+use crate::io;\n+use crate::sys::fs::File;\n+use crate::sys::pipe::AnonPipe;\n+use crate::sys::{unsupported, Void};\n+use crate::sys_common::process::CommandEnv;\n+\n+pub use crate::ffi::OsString as EnvKey;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    env: CommandEnv,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+}\n+\n+impl Command {\n+    pub fn new(_program: &OsStr) -> Command {\n+        Command {\n+            env: Default::default()\n+        }\n+    }\n+\n+    pub fn arg(&mut self, _arg: &OsStr) {\n+    }\n+\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n+        &mut self.env\n+    }\n+\n+    pub fn cwd(&mut self, _dir: &OsStr) {\n+    }\n+\n+    pub fn stdin(&mut self, _stdin: Stdio) {\n+    }\n+\n+    pub fn stdout(&mut self, _stdout: Stdio) {\n+    }\n+\n+    pub fn stderr(&mut self, _stderr: Stdio) {\n+    }\n+\n+    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n+        -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        pipe.diverge()\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        file.diverge()\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct ExitStatus(Void);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for ExitStatus {\n+    fn clone(&self) -> ExitStatus {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for ExitStatus {}\n+\n+impl PartialEq for ExitStatus {\n+    fn eq(&self, _other: &ExitStatus) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for ExitStatus {\n+}\n+\n+impl fmt::Debug for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(bool);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(false);\n+    pub const FAILURE: ExitCode = ExitCode(true);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n+pub struct Process(Void);\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        match self.0 {}\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        match self.0 {}\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        match self.0 {}\n+    }\n+}"}, {"sha": "990e7551114bbfff2611f89d42063197112ffbf7", "filename": "src/libstd/sys/hermit/rwlock.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,51 @@\n+use super::mutex::Mutex;\n+\n+pub struct RWLock {\n+    mutex: Mutex\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            mutex: Mutex::new()\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        self.mutex.lock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        self.mutex.try_lock()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        self.mutex.lock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        self.mutex.try_lock()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        self.mutex.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        self.mutex.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        self.mutex.destroy();\n+    }\n+}"}, {"sha": "b339e433e77dec9c55eceea5ff9348baec3457d2", "filename": "src/libstd/sys/hermit/stack_overflow.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,15 @@\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn init() {\n+}\n+\n+#[inline]\n+pub unsafe fn cleanup() {\n+}"}, {"sha": "07be3b6fdd3d648cb8a7b49bdb6715c18d633230", "filename": "src/libstd/sys/hermit/stdio.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,122 @@\n+use crate::io;\n+use crate::io::{IoSlice, IoSliceMut};\n+\n+extern \"C\" {\n+    fn sys_write(fd: i32, buf: *const u8, len: usize) -> isize;\n+}\n+\n+pub struct Stdin;\n+pub struct Stdout;\n+pub struct Stderr;\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin)\n+    }\n+\n+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+        self.read_vectored(&mut [IoSliceMut::new(data)])\n+    }\n+\n+    pub fn read_vectored(&self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        //ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDIN_FILENO as u32) })\n+        //    .read(data)\n+        Ok(0)\n+    }\n+\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout)\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = sys_write(1, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = sys_write(1, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr)\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = sys_write(2, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = sys_write(2, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        (&*self).write(data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (&*self).flush()\n+    }\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = 0;\n+\n+pub fn is_ebadf(_err: &io::Error) -> bool {\n+    true\n+}\n+\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n+}"}, {"sha": "cb5ed2963b161956027a9533142537b1bd6dc6d1", "filename": "src/libstd/sys/hermit/thread.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,121 @@\n+#![allow(dead_code)]\n+\n+use crate::ffi::CStr;\n+use crate::io;\n+use crate::time::Duration;\n+use crate::mem;\n+use crate::fmt;\n+use core::u32;\n+\n+use crate::sys_common::thread::*;\n+\n+pub type Tid = u32;\n+\n+/// Priority of a task\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Debug, Clone, Copy)]\n+pub struct Priority(u8);\n+\n+impl Priority {\n+    pub const fn into(self) -> u8 {\n+        self.0\n+    }\n+\n+    pub const fn from(x: u8) -> Self {\n+        Priority(x)\n+    }\n+}\n+\n+impl fmt::Display for Priority {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n+pub const NORMAL_PRIO: Priority = Priority::from(2);\n+\n+extern \"C\" {\n+    fn sys_usleep(usecs: u64);\n+    fn sys_spawn(id: *mut Tid, func: extern \"C\" fn(usize), arg: usize, prio: u8, core_id: isize) -> i32;\n+    fn sys_join(id: Tid) -> i32;\n+    fn sys_yield();\n+}\n+\n+pub struct Thread {\n+    tid: Tid\n+}\n+\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 262144;\n+\n+impl Thread {\n+    pub unsafe fn new_with_coreid(_stack: usize, p: Box<dyn FnOnce()>, core_id: isize)\n+        -> io::Result<Thread>\n+    {\n+        let p = box p;\n+        let mut tid: Tid = u32::MAX;\n+        let ret = sys_spawn(&mut tid as *mut Tid, thread_start, &*p as *const _ as *const u8 as usize,\n+                            Priority::into(NORMAL_PRIO), core_id);\n+\n+        return if ret == 0 {\n+            mem::forget(p); // ownership passed to pthread_create\n+            Ok(Thread { tid: tid })\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n+        };\n+\n+        extern fn thread_start(main: usize) {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n+        }\n+    }\n+\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n+        -> io::Result<Thread>\n+    {\n+        Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n+    }\n+\n+    #[inline]\n+    pub fn yield_now() {\n+        unsafe {\n+            sys_yield();\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn set_name(_name: &CStr) {\n+        // nope\n+    }\n+\n+    #[inline]\n+    pub fn sleep(dur: Duration) {\n+        unsafe {\n+            sys_usleep(dur.as_micros() as u64);\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        unsafe {\n+            let _ = sys_join(self.tid);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn id(&self) -> Tid { self.tid }\n+\n+    #[inline]\n+    pub fn into_id(self) -> Tid {\n+        let id = self.tid;\n+        mem::forget(self);\n+        id\n+    }\n+}\n+\n+pub mod guard {\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n+}"}, {"sha": "4bc8c4d5883da0a8e41340be42e55e9c063166f6", "filename": "src/libstd/sys/hermit/thread_local.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,61 @@\n+#![allow(dead_code)] // not used on all platforms\n+\n+use crate::collections::BTreeMap;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub type Key = usize;\n+\n+type Dtor = unsafe extern fn(*mut u8);\n+\n+static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n+\n+static mut KEYS: *mut BTreeMap<Key, Option<Dtor>> = ptr::null_mut();\n+\n+#[thread_local]\n+static mut LOCALS: *mut BTreeMap<Key, *mut u8> = ptr::null_mut();\n+\n+unsafe fn keys() -> &'static mut BTreeMap<Key, Option<Dtor>> {\n+    if KEYS == ptr::null_mut() {\n+        KEYS = Box::into_raw(Box::new(BTreeMap::new()));\n+    }\n+    &mut *KEYS\n+}\n+\n+unsafe fn locals() -> &'static mut BTreeMap<Key, *mut u8> {\n+    if LOCALS == ptr::null_mut() {\n+        LOCALS = Box::into_raw(Box::new(BTreeMap::new()));\n+    }\n+    &mut *LOCALS\n+}\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n+    let key = NEXT_KEY.fetch_add(1, Ordering::SeqCst);\n+    keys().insert(key, dtor);\n+    key\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    if let Some(&entry) = locals().get(&key) {\n+        entry\n+    } else {\n+        ptr::null_mut()\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    locals().insert(key, value);\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    keys().remove(&key);\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "2c8aafef0fe8e89af978290cc2424bc436fb137d", "filename": "src/libstd/sys/hermit/time.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -0,0 +1,188 @@\n+#![allow(dead_code)]\n+\n+use crate::time::Duration;\n+use crate::cmp::Ordering;\n+use crate::convert::TryInto;\n+use core::hash::{Hash, Hasher};\n+\n+const NSEC_PER_SEC: u64 = 1_000_000_000;\n+const CLOCK_REALTIME: u64 = 1;\n+const CLOCK_MONOTONIC: u64 = 4;\n+\n+extern \"C\" {\n+    fn sys_clock_gettime(clock_id: u64, tp: *mut timespec) -> i32;\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct timespec {\n+    pub tv_sec: i64,\n+    pub tv_nsec: i64,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct Timespec {\n+    t: timespec\n+}\n+\n+impl Timespec {\n+    const fn zero() -> Timespec {\n+        Timespec {\n+            t: timespec { tv_sec: 0, tv_nsec: 0 },\n+        }\n+    }\n+\n+    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n+        if self >= other {\n+            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n+                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n+                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+            } else {\n+                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                              other.t.tv_nsec as u32)\n+            })\n+        } else {\n+            match other.sub_timespec(self) {\n+                Ok(d) => Err(d),\n+                Err(d) => Ok(d),\n+            }\n+        }\n+    }\n+\n+    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = other\n+            .as_secs()\n+            .try_into() // <- target type would be `libc::time_t`\n+            .ok()\n+            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n+\n+        // Nano calculations can't overflow because nanos are <1B which fit\n+        // in a u32.\n+        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        if nsec >= NSEC_PER_SEC as u32 {\n+            nsec -= NSEC_PER_SEC as u32;\n+            secs = secs.checked_add(1)?;\n+        }\n+        Some(Timespec {\n+            t: timespec {\n+                tv_sec: secs,\n+                tv_nsec: nsec as _,\n+            },\n+        })\n+    }\n+\n+    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = other\n+            .as_secs()\n+            .try_into() // <- target type would be `libc::time_t`\n+            .ok()\n+            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n+\n+        // Similar to above, nanos can't overflow.\n+        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        if nsec < 0 {\n+            nsec += NSEC_PER_SEC as i32;\n+            secs = secs.checked_sub(1)?;\n+        }\n+        Some(Timespec {\n+            t: timespec {\n+                tv_sec: secs,\n+                tv_nsec: nsec as _,\n+            },\n+        })\n+    }\n+}\n+\n+impl PartialEq for Timespec {\n+    fn eq(&self, other: &Timespec) -> bool {\n+        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n+    }\n+}\n+\n+impl Eq for Timespec {}\n+\n+impl PartialOrd for Timespec {\n+    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Timespec {\n+    fn cmp(&self, other: &Timespec) -> Ordering {\n+        let me = (self.t.tv_sec, self.t.tv_nsec);\n+        let other = (other.t.tv_sec, other.t.tv_nsec);\n+        me.cmp(&other)\n+    }\n+}\n+\n+impl Hash for Timespec {\n+    fn hash<H : Hasher>(&self, state: &mut H) {\n+        self.t.tv_sec.hash(state);\n+        self.t.tv_nsec.hash(state);\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct Instant {\n+    t: Timespec,\n+}\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        let mut time: Timespec = Timespec::zero();\n+        let _ = unsafe { sys_clock_gettime(CLOCK_MONOTONIC, &mut time.t as *mut timespec) };\n+\n+        Instant { t: time }\n+    }\n+\n+    pub const fn zero() -> Instant {\n+        Instant { t: Timespec::zero() }\n+    }\n+\n+    pub fn actually_monotonic() -> bool {\n+        true\n+    }\n+\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+        self.t.sub_timespec(&other.t).ok()\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n+        Some(Instant { t: self.t.checked_add_duration(other)? })\n+    }\n+\n+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n+        Some(Instant { t: self.t.checked_sub_duration(other)? })\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct SystemTime {\n+    t: Timespec,\n+}\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime {\n+    t: Timespec::zero(),\n+};\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        let mut time: Timespec = Timespec::zero();\n+        let _ = unsafe { sys_clock_gettime(CLOCK_REALTIME, &mut time.t as *mut timespec) };\n+\n+        SystemTime { t: time }\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n+        self.t.sub_timespec(&other.t)\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n+    }\n+\n+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n+    }\n+}"}, {"sha": "16b0539cdb9f952f1411eb0e9c5717a0a9a99e79", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -35,6 +35,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_os = \"cloudabi\")] {\n         mod cloudabi;\n         pub use self::cloudabi::*;\n+    } else if #[cfg(target_os = \"hermit\")] {\n+        mod hermit;\n+        pub use self::hermit::*;\n     } else if #[cfg(target_os = \"wasi\")] {\n         mod wasi;\n         pub use self::wasi::*;\n@@ -60,6 +63,7 @@ cfg_if::cfg_if! {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub use self::ext as unix_ext;\n     } else if #[cfg(any(target_os = \"cloudabi\",\n+                        target_os = \"hermit\",\n                         target_arch = \"wasm32\",\n                         all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         // On CloudABI and wasm right now the module below doesn't compile"}, {"sha": "cf4900b48943e1d91a150a339ac7a388fc47c5db", "filename": "src/libstd/sys/unix/alloc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Falloc.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -53,7 +53,6 @@ unsafe impl GlobalAlloc for System {\n }\n \n #[cfg(any(target_os = \"android\",\n-          target_os = \"hermit\",\n           target_os = \"redox\",\n           target_os = \"solaris\"))]\n #[inline]\n@@ -79,7 +78,6 @@ unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n }\n \n #[cfg(not(any(target_os = \"android\",\n-              target_os = \"hermit\",\n               target_os = \"redox\",\n               target_os = \"solaris\")))]\n #[inline]"}, {"sha": "82ef35ea7b5d55dc46dcd0838207994e0b032fe2", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -56,7 +56,6 @@ impl DoubleEndedIterator for Args {\n           target_os = \"haiku\",\n           target_os = \"l4re\",\n           target_os = \"fuchsia\",\n-          target_os = \"hermit\",\n           target_os = \"redox\"))]\n mod imp {\n     use crate::os::unix::prelude::*;"}, {"sha": "6be844ded1936cf33ebc4183864689e3605fbef1", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -31,15 +31,13 @@ impl Condvar {\n               target_os = \"ios\",\n               target_os = \"l4re\",\n               target_os = \"android\",\n-              target_os = \"hermit\",\n               target_os = \"redox\"))]\n     pub unsafe fn init(&mut self) {}\n \n     #[cfg(not(any(target_os = \"macos\",\n                   target_os = \"ios\",\n                   target_os = \"l4re\",\n                   target_os = \"android\",\n-                  target_os = \"hermit\",\n                   target_os = \"redox\")))]\n     pub unsafe fn init(&mut self) {\n         use crate::mem::MaybeUninit;\n@@ -78,8 +76,7 @@ impl Condvar {\n     // from changes made to the system time.\n     #[cfg(not(any(target_os = \"macos\",\n                   target_os = \"ios\",\n-                  target_os = \"android\",\n-                  target_os = \"hermit\")))]\n+                  target_os = \"android\")))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n@@ -109,7 +106,7 @@ impl Condvar {\n     // This implementation is modeled after libcxx's condition_variable\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\", target_os = \"hermit\"))]\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n         use crate::ptr;\n         use crate::time::Instant;"}, {"sha": "984bcfa45099ba6d4ec70dfede19b9eec4b278e2", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -152,17 +152,6 @@ pub mod os {\n     pub const EXE_EXTENSION: &str = \"\";\n }\n \n-#[cfg(target_os = \"hermit\")]\n-pub mod os {\n-    pub const FAMILY: &str = \"unix\";\n-    pub const OS: &str = \"hermit\";\n-    pub const DLL_PREFIX: &str = \"lib\";\n-    pub const DLL_SUFFIX: &str = \".so\";\n-    pub const DLL_EXTENSION: &str = \"so\";\n-    pub const EXE_SUFFIX: &str = \"\";\n-    pub const EXE_EXTENSION: &str = \"\";\n-}\n-\n #[cfg(target_os = \"redox\")]\n pub mod os {\n     pub const FAMILY: &str = \"unix\";"}, {"sha": "c2064fca23eac8821437048c0597512a5a2e5eba", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -319,12 +319,12 @@ impl DirEntry {\n         lstat(&self.path())\n     }\n \n-    #[cfg(any(target_os = \"solaris\", target_os = \"haiku\", target_os = \"hermit\"))]\n+    #[cfg(any(target_os = \"solaris\", target_os = \"haiku\"))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"haiku\", target_os = \"hermit\")))]\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"haiku\")))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n             libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n@@ -347,7 +347,6 @@ impl DirEntry {\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n               target_os = \"fuchsia\",\n-              target_os = \"hermit\",\n               target_os = \"redox\"))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -378,8 +377,7 @@ impl DirEntry {\n               target_os = \"linux\",\n               target_os = \"emscripten\",\n               target_os = \"l4re\",\n-              target_os = \"haiku\",\n-              target_os = \"hermit\"))]\n+              target_os = \"haiku\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {\n             CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()"}, {"sha": "d0bed0f038e6c9b2a1c929f16f53b7abc183af0a", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -16,7 +16,6 @@ use crate::io::ErrorKind;\n #[cfg(all(not(rustdoc), target_os = \"emscripten\"))] pub use crate::os::emscripten as platform;\n #[cfg(all(not(rustdoc), target_os = \"fuchsia\"))]   pub use crate::os::fuchsia as platform;\n #[cfg(all(not(rustdoc), target_os = \"l4re\"))]      pub use crate::os::linux as platform;\n-#[cfg(all(not(rustdoc), target_os = \"hermit\"))]    pub use crate::os::hermit as platform;\n #[cfg(all(not(rustdoc), target_os = \"redox\"))]      pub use crate::os::redox as platform;\n \n pub use self::rand::hashmap_random_keys;"}, {"sha": "10cdb25999ca9d09c558fb2b94f5bc97eae11765", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -43,7 +43,6 @@ extern {\n     #[cfg_attr(any(target_os = \"netbsd\",\n                    target_os = \"openbsd\",\n                    target_os = \"android\",\n-                   target_os = \"hermit\",\n                    target_os = \"redox\",\n                    target_env = \"newlib\"),\n                link_name = \"__errno\")]\n@@ -394,7 +393,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     crate::fs::read_to_string(\"sys:exe\").map(PathBuf::from)\n }\n \n-#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\", target_os = \"hermit\"))]\n+#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use crate::io::ErrorKind;\n     Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))"}, {"sha": "72b0ac493da15cf1b544103161c9d5dcc257a45b", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -140,7 +140,6 @@ impl Thread {\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n               target_os = \"emscripten\",\n-              target_os = \"hermit\",\n               target_os = \"redox\"))]\n     pub fn set_name(_name: &CStr) {\n         // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name."}, {"sha": "a9122defa55062758a1157e2a67cd020f7c9dea7", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -371,9 +371,9 @@ mod inner {\n         }\n     }\n \n-    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"hermit\")))]\n+    #[cfg(not(target_os = \"dragonfly\"))]\n     pub type clock_t = libc::c_int;\n-    #[cfg(any(target_os = \"dragonfly\", target_os = \"hermit\"))]\n+    #[cfg(target_os = \"dragonfly\")]\n     pub type clock_t = libc::c_ulong;\n \n     fn now(clock: clock_t) -> Timespec {"}, {"sha": "7a0bcd03d758f7748c5b7dbc0cc1d0e4c6243733", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -49,6 +49,7 @@ pub mod mutex;\n           unix,\n           target_os = \"redox\",\n           target_os = \"cloudabi\",\n+          target_os = \"hermit\",\n           target_arch = \"wasm32\",\n           all(target_vendor = \"fortanix\", target_env = \"sgx\")))]\n pub mod os_str_bytes;\n@@ -67,6 +68,7 @@ pub mod fs;\n cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\",\n                  target_os = \"l4re\",\n+                 target_os = \"hermit\",\n                  all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n                  all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         pub use crate::sys::net;"}, {"sha": "4a28872decab2641210f5929e4ef58fa1eecab88", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -1052,6 +1052,7 @@ fn use_color(opts: &TestOpts) -> bool {\n \n #[cfg(any(\n     target_os = \"cloudabi\",\n+    target_os = \"hermit\",\n     all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n     all(target_vendor = \"fortanix\", target_env = \"sgx\")\n ))]\n@@ -1308,6 +1309,12 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n+    #[cfg(target_os = \"hermit\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: Implement num_cpus on HermitCore\n+        1\n+    }\n+\n     #[cfg(any(\n         all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n         all(target_vendor = \"fortanix\", target_env = \"sgx\")"}, {"sha": "a2e2df016bde1091bf7c428f2f18698da00bd399", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -43,6 +43,8 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=gcc_s\");\n     } else if target.contains(\"redox\") {\n         // redox is handled in lib.rs\n+    } else if target.contains(\"hermit\") {\n+        //println!(\"cargo:rustc-link-lib=unwind\");\n     } else if target.contains(\"cloudabi\") {\n         println!(\"cargo:rustc-link-lib=unwind\");\n     }"}, {"sha": "92231e8207b7c2a9ae7180efac63a4d4d17cc4e4", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -1,7 +1,26 @@\n #![allow(nonstandard_style)]\n \n+#[cfg(not(target_os = \"hermit\"))]\n use libc::{c_int, c_void, uintptr_t};\n \n+#[cfg(target_os = \"hermit\")]\n+pub type c_int = i32;\n+\n+#[cfg(target_os = \"hermit\")]\n+pub type uintptr_t = usize;\n+\n+#[cfg(target_os = \"hermit\")]\n+#[repr(u8)]\n+#[allow(missing_copy_implementations)]\n+#[allow(missing_debug_implementations)]\n+pub enum c_void {\n+    // Two dummy variants so the #[repr] attribute can be used.\n+    #[doc(hidden)]\n+    __variant1,\n+    #[doc(hidden)]\n+    __variant2,\n+}\n+\n #[repr(C)]\n #[derive(Debug, Copy, Clone, PartialEq)]\n pub enum _Unwind_Reason_Code {"}, {"sha": "bc6c19738709963fccd3350c1d03f149a8cd78d3", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e440a90f472468c8069ba6254b23c6feedc32e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=c1e440a90f472468c8069ba6254b23c6feedc32e", "patch": "@@ -52,6 +52,7 @@ static TARGETS: &[&str] = &[\n     \"aarch64-linux-android\",\n     \"aarch64-pc-windows-msvc\",\n     \"aarch64-unknown-cloudabi\",\n+    \"aarch64-unknown-hermit\",\n     \"aarch64-unknown-linux-gnu\",\n     \"aarch64-unknown-linux-musl\",\n     \"aarch64-unknown-redox\",\n@@ -136,6 +137,7 @@ static TARGETS: &[&str] = &[\n     \"x86_64-unknown-linux-musl\",\n     \"x86_64-unknown-netbsd\",\n     \"x86_64-unknown-redox\",\n+    \"x86_64-unknown-hermit\",\n ];\n \n static DOCS_TARGETS: &[&str] = &["}]}