{"sha": "9be109910713660e666f83ebdc6a6e717391e647", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZTEwOTkxMDcxMzY2MGU2NjZmODNlYmRjNmE2ZTcxNzM5MWU2NDc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-23T07:42:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-23T07:42:01Z"}, "message": "Rollup merge of #74141 - euclio:typos, r=steveklabnik\n\nlibstd/libcore: fix various typos", "tree": {"sha": "88d4fd2241a4b466a41166738bc5624c8b375ff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88d4fd2241a4b466a41166738bc5624c8b375ff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be109910713660e666f83ebdc6a6e717391e647", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGT9KCRBK7hj4Ov3rIwAAdHIIAJKoGfrCk26YekfBUj3yMxWE\nqr4Y/6TzSGflNvc4/OFAFLFiX/HK/3B+gqp/MAfIz5DUzG6nC6MeFNsd2I7N1m90\ngN63/Xo9aN0sd0WMvs4IGU/5q9HJGt2bPJsPjszqFidHVPuLy4uS1EH0AHCnjUOJ\n7m2J7j6JDpBfs634DPe9UOIXpYsM2rzjXrRCBQH6ZHBzsFMXOuLKu5nS4k6Dn1oi\nROVrG7YcgbL9KxCZycxEesE/9VBkrx0Kky5LwS3tdjLys+yTvjLQTRtANLZs/wW2\nDS3E/cJPiKhrU2CS4LjoUg6a1I4I9bQEnQgMGy5ATGLZURJQtsre/RAs3cAZgdM=\n=JR7N\n-----END PGP SIGNATURE-----\n", "payload": "tree 88d4fd2241a4b466a41166738bc5624c8b375ff7\nparent e8b55a4ad230ebec762fdfc4f241ba98a98560af\nparent 133e91da627a42218721caf2083c3f309e1b0dcc\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595490121 -0700\ncommitter GitHub <noreply@github.com> 1595490121 -0700\n\nRollup merge of #74141 - euclio:typos, r=steveklabnik\n\nlibstd/libcore: fix various typos\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be109910713660e666f83ebdc6a6e717391e647", "html_url": "https://github.com/rust-lang/rust/commit/9be109910713660e666f83ebdc6a6e717391e647", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be109910713660e666f83ebdc6a6e717391e647/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8b55a4ad230ebec762fdfc4f241ba98a98560af", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8b55a4ad230ebec762fdfc4f241ba98a98560af", "html_url": "https://github.com/rust-lang/rust/commit/e8b55a4ad230ebec762fdfc4f241ba98a98560af"}, {"sha": "133e91da627a42218721caf2083c3f309e1b0dcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/133e91da627a42218721caf2083c3f309e1b0dcc", "html_url": "https://github.com/rust-lang/rust/commit/133e91da627a42218721caf2083c3f309e1b0dcc"}], "stats": {"total": 68, "additions": 34, "deletions": 34}, "files": [{"sha": "03b798d57db9bcf37ba50b1ba515730782f2e7bd", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -677,7 +677,7 @@ impl AsRef<str> for str {\n ///\n ///\n /// However there is one case where `!` syntax can be used\n-/// before `!` is stabilized as a full-fleged type: in the position of a function\u2019s return type.\n+/// before `!` is stabilized as a full-fledged type: in the position of a function\u2019s return type.\n /// Specifically, it is possible implementations for two different function pointer types:\n ///\n /// ```"}, {"sha": "a9882d54de4f18b3e47d86ce132d760c852e2ab6", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -43,7 +43,7 @@ struct SipHasher24 {\n ///\n /// SipHash is a general-purpose hashing function: it runs at a good\n /// speed (competitive with Spooky and City) and permits strong _keyed_\n-/// hashing. This lets you key your hashtables from a strong RNG, such as\n+/// hashing. This lets you key your hash tables from a strong RNG, such as\n /// [`rand::os::OsRng`](https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html).\n ///\n /// Although the SipHash algorithm is considered to be generally strong,"}, {"sha": "1af4f1009d1ac86e94d3c2d49e62d3db44a93a25", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -15,7 +15,7 @@\n //!\n //! If an intrinsic is supposed to be used from a `const fn` with a `rustc_const_stable` attribute,\n //! the intrinsic's attribute must be `rustc_const_stable`, too. Such a change should not be done\n-//! without T-lang consulation, because it bakes a feature into the language that cannot be\n+//! without T-lang consultation, because it bakes a feature into the language that cannot be\n //! replicated in user code without compiler support.\n //!\n //! # Volatiles\n@@ -994,7 +994,7 @@ extern \"rust-intrinsic\" {\n     /// [`std::mem::align_of`](../../std/mem/fn.align_of.html).\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n-    /// The prefered alignment of a type.\n+    /// The preferred alignment of a type.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n@@ -1246,14 +1246,14 @@ extern \"rust-intrinsic\" {\n     ///     assert!(mid <= len);\n     ///     unsafe {\n     ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n-    ///         // first: transmute is not typesafe; all it checks is that T and\n+    ///         // first: transmute is not type safe; all it checks is that T and\n     ///         // U are of the same size. Second, right here, you have two\n     ///         // mutable references pointing to the same memory.\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n     ///\n-    /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n+    /// // This gets rid of the type safety problems; `&mut *` will *only* give\n     /// // you an `&mut T` from an `&mut T` or `*mut T`.\n     /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n     ///                          -> (&mut [T], &mut [T]) {"}, {"sha": "3ea3eeed6b0434f3f4f5fc7b3b5569051a255249", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -1069,7 +1069,7 @@ pub trait Iterator {\n     /// let vec = iter.collect::<Vec<_>>();\n     ///\n     /// // We have more elements which could fit in u32 (4, 5), but `map_while` returned `None` for `-3`\n-    /// // (as the `predicate` returned `None`) and `collect` stops at the first `None` entcountered.\n+    /// // (as the `predicate` returned `None`) and `collect` stops at the first `None` encountered.\n     /// assert_eq!(vec, vec![0, 1, 2]);\n     /// ```\n     ///"}, {"sha": "3b9057b7e8377911feec5d30b98e163a787d0fab", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -1047,7 +1047,7 @@ pub(crate) mod builtin {\n         };\n     }\n \n-    /// Includes a utf8-encoded file as a string.\n+    /// Includes a UTF-8 encoded file as a string.\n     ///\n     /// The file is located relative to the current file (similarly to how\n     /// modules are found). The provided path is interpreted in a platform-specific"}, {"sha": "6ff7baab70f61eee903dde10278c4e06dcdeabe1", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -348,11 +348,11 @@ pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// - If `T` is `Sized`, this function is always safe to call.\n /// - If the unsized tail of `T` is:\n-///     - a [slice], then the length of the slice tail must be an intialized\n+///     - a [slice], then the length of the slice tail must be an initialized\n ///       integer, and the size of the *entire value*\n ///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n ///     - a [trait object], then the vtable part of the pointer must point\n-///       to a valid vtable acquired by an unsizing coersion, and the size\n+///       to a valid vtable acquired by an unsizing coercion, and the size\n ///       of the *entire value* (dynamic tail length + statically sized prefix)\n ///       must fit in `isize`.\n ///     - an (unstable) [extern type], then this function is always safe to\n@@ -483,11 +483,11 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// - If `T` is `Sized`, this function is always safe to call.\n /// - If the unsized tail of `T` is:\n-///     - a [slice], then the length of the slice tail must be an intialized\n+///     - a [slice], then the length of the slice tail must be an initialized\n ///       integer, and the size of the *entire value*\n ///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n ///     - a [trait object], then the vtable part of the pointer must point\n-///       to a valid vtable acquired by an unsizing coersion, and the size\n+///       to a valid vtable acquired by an unsizing coercion, and the size\n ///       of the *entire value* (dynamic tail length + statically sized prefix)\n ///       must fit in `isize`.\n ///     - an (unstable) [extern type], then this function is always safe to"}, {"sha": "a5b1eb3f1fd67c61adcc65d041319bc7b88f6f29", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -687,7 +687,7 @@ impl f64 {\n     /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n     ///\n     /// Rather than trying to preserve signaling-ness cross-platform, this\n-    /// implementation favours preserving the exact bits. This means that\n+    /// implementation favors preserving the exact bits. This means that\n     /// any payloads encoded in NaNs will be preserved even if the result of\n     /// this method is sent over the network from an x86 machine to a MIPS one.\n     ///\n@@ -696,7 +696,7 @@ impl f64 {\n     ///\n     /// If the input isn't NaN, then there is no portability concern.\n     ///\n-    /// If you don't care about signalingness (very likely), then there is no\n+    /// If you don't care about signaling-ness (very likely), then there is no\n     /// portability concern.\n     ///\n     /// Note that this function is distinct from `as` casting, which attempts to"}, {"sha": "9bcacd8ddcf77ee54bb950f8a9dcff1d280fbf6d", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -128,7 +128,7 @@\n //!\n //! Crucially, we have to be able to rely on [`drop`] being called. If an element\n //! could be deallocated or otherwise invalidated without calling [`drop`], the pointers into it\n-//! from its neighbouring elements would become invalid, which would break the data structure.\n+//! from its neighboring elements would become invalid, which would break the data structure.\n //!\n //! Therefore, pinning also comes with a [`drop`]-related guarantee.\n //!"}, {"sha": "a2acc239bd38f942da26c334b1254e4a6a24db00", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -331,13 +331,13 @@ impl<T: ?Sized> *const T {\n         intrinsics::ptr_guaranteed_eq(self, other)\n     }\n \n-    /// Returns whether two pointers are guaranteed to be inequal.\n+    /// Returns whether two pointers are guaranteed to be unequal.\n     ///\n     /// At runtime this function behaves like `self != other`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n     ///\n     /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n     /// comparisons for which both functions return `false`."}, {"sha": "17fa90ecc08b5c81acc3e672bf9f3a6db429178d", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -317,13 +317,13 @@ impl<T: ?Sized> *mut T {\n         intrinsics::ptr_guaranteed_eq(self as *const _, other as *const _)\n     }\n \n-    /// Returns whether two pointers are guaranteed to be inequal.\n+    /// Returns whether two pointers are guaranteed to be unequal.\n     ///\n     /// At runtime this function behaves like `self != other`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n     ///\n     /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n     /// comparisons for which both functions return `false`."}, {"sha": "9f843a570990d615b795f7233734686b42675ed2", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -172,7 +172,7 @@ impl<T> NonNull<[T]> {\n     /// assert_eq!(unsafe { slice.as_ref()[2] }, 7);\n     /// ```\n     ///\n-    /// (Note that this example artifically demonstrates a use of this method,\n+    /// (Note that this example artificially demonstrates a use of this method,\n     /// but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)\n     #[unstable(feature = \"nonnull_slice_from_raw_parts\", issue = \"71941\")]\n     #[rustc_const_unstable(feature = \"const_nonnull_slice_from_raw_parts\", issue = \"71941\")]"}, {"sha": "c905bcf5e3db4255819b3c952eb5277012042add", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -1500,7 +1500,7 @@ mod tests {\n         assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n         assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n \n-        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // Check that NaNs roundtrip their bits regardless of signaling-ness\n         // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n         let masked_nan1 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n         let masked_nan2 = f32::NAN.to_bits() ^ 0x0055_5555;"}, {"sha": "f09fc8d790b28faade6c3d0a2193263d32b07a42", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -1523,7 +1523,7 @@ mod tests {\n         assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n         assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n \n-        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // Check that NaNs roundtrip their bits regardless of signaling-ness\n         // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n         let masked_nan1 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n         let masked_nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;"}, {"sha": "657737394ab82fe5feb1f29a57f2402cf1a2495c", "filename": "src/libstd/os/linux/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fos%2Flinux%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fos%2Flinux%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Ffs.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -285,7 +285,7 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime_nsec(&self) -> i64;\n-    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n+    /// Returns the \"preferred\" block size for efficient filesystem I/O.\n     ///\n     /// # Examples\n     ///"}, {"sha": "61b5bff380518674c4341fc74f121ea7a5381142", "filename": "src/libstd/os/redox/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Ffs.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -289,7 +289,7 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime_nsec(&self) -> i64;\n-    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n+    /// Returns the \"preferred\" block size for efficient filesystem I/O.\n     ///\n     /// # Examples\n     ///"}, {"sha": "e5dc5b5adaa934a0ed34de571c425e2e231275da", "filename": "src/libstd/sys/sgx/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -19,7 +19,7 @@ impl FileDesc {\n         self.fd\n     }\n \n-    /// Extracts the actual filedescriptor without closing it.\n+    /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> Fd {\n         let fd = self.fd;\n         mem::forget(self);"}, {"sha": "f174a59b49a6ba51b01a1bc50f720ee2a6e4dd37", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -624,7 +624,7 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn ctime_nsec(&self) -> i64;\n-    /// Returns the blocksize for filesystem I/O.\n+    /// Returns the block size for filesystem I/O.\n     ///\n     /// # Examples\n     ///\n@@ -635,7 +635,7 @@ pub trait MetadataExt {\n     ///\n     /// fn main() -> io::Result<()> {\n     ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let blocksize = meta.blksize();\n+    ///     let block_size = meta.blksize();\n     ///     Ok(())\n     /// }\n     /// ```"}, {"sha": "7384cbae3a14c02d04d8285966575ed2165910bd", "filename": "src/libstd/sys/vxworks/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -29,7 +29,7 @@ impl FileDesc {\n         self.fd\n     }\n \n-    /// Extracts the actual filedescriptor without closing it.\n+    /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n         let fd = self.fd;\n         mem::forget(self);"}, {"sha": "2eed9e436a956003a200a6af668024da9b786f0c", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be109910713660e666f83ebdc6a6e717391e647/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=9be109910713660e666f83ebdc6a6e717391e647", "patch": "@@ -597,14 +597,14 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n ///\n /// WASI has no fundamental capability to do this. All syscalls and operations\n /// are relative to already-open file descriptors. The C library, however,\n-/// manages a map of preopened file descriptors to their path, and then the C\n+/// manages a map of pre-opened file descriptors to their path, and then the C\n /// library provides an API to look at this. In other words, when you want to\n /// open a path `p`, you have to find a previously opened file descriptor in a\n /// global table and then see if `p` is relative to that file descriptor.\n ///\n /// This function, if successful, will return two items:\n ///\n-/// * The first is a `ManuallyDrop<WasiFd>`. This represents a preopened file\n+/// * The first is a `ManuallyDrop<WasiFd>`. This represents a pre-opened file\n ///   descriptor which we don't have ownership of, but we can use. You shouldn't\n ///   actually drop the `fd`.\n ///\n@@ -619,15 +619,15 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n /// appropriate rights for performing `rights` actions.\n ///\n /// Note that this can fail if `p` doesn't look like it can be opened relative\n-/// to any preopened file descriptor.\n+/// to any pre-opened file descriptor.\n fn open_parent(p: &Path) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n     let p = CString::new(p.as_os_str().as_bytes())?;\n     unsafe {\n         let mut ret = ptr::null();\n         let fd = __wasilibc_find_relpath(p.as_ptr(), &mut ret);\n         if fd == -1 {\n             let msg = format!(\n-                \"failed to find a preopened file descriptor \\\n+                \"failed to find a pre-opened file descriptor \\\n                  through which {:?} could be opened\",\n                 p\n             );"}]}