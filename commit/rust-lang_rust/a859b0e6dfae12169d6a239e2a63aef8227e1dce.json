{"sha": "a859b0e6dfae12169d6a239e2a63aef8227e1dce", "node_id": "C_kwDOAAsO6NoAKGE4NTliMGU2ZGZhZTEyMTY5ZDZhMjM5ZTJhNjNhZWY4MjI3ZTFkY2U", "commit": {"author": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-05-31T21:08:49Z"}, "committer": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-05-31T21:52:02Z"}, "message": "don't lint enums, update note in lint description", "tree": {"sha": "90a4f10494e289dd51f9bf3277ed6ef6b81aabbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90a4f10494e289dd51f9bf3277ed6ef6b81aabbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a859b0e6dfae12169d6a239e2a63aef8227e1dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a859b0e6dfae12169d6a239e2a63aef8227e1dce", "html_url": "https://github.com/rust-lang/rust/commit/a859b0e6dfae12169d6a239e2a63aef8227e1dce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a859b0e6dfae12169d6a239e2a63aef8227e1dce/comments", "author": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "committer": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "html_url": "https://github.com/rust-lang/rust/commit/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df"}], "stats": {"total": 271, "additions": 13, "deletions": 258}, "files": [{"sha": "8332d638f92abfdec22ab2f117b215e8f1642482", "filename": "clippy_lints/src/missing_fields_in_debug.rs", "status": "modified", "additions": 12, "deletions": 89, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a859b0e6dfae12169d6a239e2a63aef8227e1dce/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a859b0e6dfae12169d6a239e2a63aef8227e1dce/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs?ref=a859b0e6dfae12169d6a239e2a63aef8227e1dce", "patch": "@@ -2,22 +2,22 @@ use std::ops::ControlFlow;\n \n use clippy_utils::{\n     diagnostics::span_lint_and_then,\n-    paths,\n+    is_path_lang_item, paths,\n     ty::match_type,\n     visitors::{for_each_expr, Visitable},\n };\n use rustc_ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::Block;\n use rustc_hir::{\n     def::{DefKind, Res},\n-    Expr, ImplItemKind, MatchSource, Node,\n+    Expr, ImplItemKind, LangItem, Node,\n };\n-use rustc_hir::{Block, PatKind};\n use rustc_hir::{ExprKind, Impl, ItemKind, QPath, TyKind};\n use rustc_hir::{ImplItem, Item, VariantData};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeckResults;\n-use rustc_middle::ty::{EarlyBinder, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span, Symbol};\n \n@@ -38,11 +38,12 @@ declare_clippy_lint! {\n     /// Oftentimes there is more logic to a `Debug` impl if it uses `write!` macro, so it tries\n     /// to be on the conservative side and not lint in those cases in an attempt to prevent false positives.\n     ///\n-    /// This lint also does not look through function calls, so calling `.field(self.as_slice())` for example\n-    /// does not consider fields used inside of `as_slice()` as used by the `Debug` impl.\n+    /// This lint also does not look through function calls, so calling a function does not consider fields\n+    /// used inside of that function as used by the `Debug` impl.\n     ///\n     /// Lastly, it also ignores tuple structs as their `DebugTuple` formatter does not have a `finish_non_exhaustive`\n-    /// method.\n+    /// method, as well as enums because their exhaustiveness is already checked by the compiler when matching on the enum,\n+    /// making it much less likely to accidentally forget to update the `Debug` impl when adding a new variant.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -185,8 +186,7 @@ fn check_struct<'tcx>(\n         .fields()\n         .iter()\n         .filter_map(|field| {\n-            let EarlyBinder(field_ty) = cx.tcx.type_of(field.def_id);\n-            if field_accesses.contains(&field.ident.name) || field_ty.is_phantom_data() {\n+            if field_accesses.contains(&field.ident.name) || is_path_lang_item(cx, field.ty, LangItem::PhantomData) {\n                 None\n             } else {\n                 Some((field.span, \"this field is unused\"))\n@@ -201,82 +201,6 @@ fn check_struct<'tcx>(\n     }\n }\n \n-/// Attempts to find unused fields in variants assuming that\n-/// the item is an enum.\n-///\n-/// Currently, only simple cases are detected where the user\n-/// matches on `self` and calls `debug_struct` inside of the arms\n-fn check_enum<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    typeck_results: &TypeckResults<'tcx>,\n-    block: &'tcx Block<'tcx>,\n-    self_ty: Ty<'tcx>,\n-    item: &'tcx Item<'tcx>,\n-) {\n-    let Some(arms) = for_each_expr(block, |expr| {\n-        if let ExprKind::Match(val, arms, MatchSource::Normal) = expr.kind\n-            && let match_ty = typeck_results.expr_ty_adjusted(val).peel_refs()\n-            && match_ty == self_ty\n-        {\n-            ControlFlow::Break(arms)\n-        } else {\n-            ControlFlow::Continue(())\n-        }\n-    }) else {\n-        return;\n-    };\n-\n-    let mut span_notes = Vec::new();\n-\n-    for arm in arms {\n-        if !should_lint(cx, typeck_results, arm.body) {\n-            continue;\n-        }\n-\n-        arm.pat.walk_always(|pat| match pat.kind {\n-            PatKind::Wild => span_notes.push((pat.span, \"unused field here due to wildcard `_`\")),\n-            PatKind::Tuple(_, rest) | PatKind::TupleStruct(.., rest) if rest.as_opt_usize().is_some() => {\n-                span_notes.push((pat.span, \"more unused fields here due to rest pattern `..`\"));\n-            },\n-            PatKind::Struct(.., true) => {\n-                span_notes.push((pat.span, \"more unused fields here due to rest pattern `..`\"));\n-            },\n-            _ => {},\n-        });\n-\n-        let mut field_accesses = FxHashSet::default();\n-        let mut check_field_access = |sym, expr| {\n-            if !typeck_results.expr_ty(expr).is_phantom_data() {\n-                arm.pat.each_binding(|_, _, _, pat_ident| {\n-                    if sym == pat_ident.name {\n-                        field_accesses.insert(pat_ident);\n-                    }\n-                });\n-            }\n-        };\n-\n-        for_each_expr(arm.body, |expr| {\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind && let Some(segment) = path.segments.first()\n-            {\n-                check_field_access(segment.ident.name, expr);\n-            } else if let Some(sym) = as_field_call(cx, typeck_results, expr) {\n-                check_field_access(sym, expr);\n-            }\n-            ControlFlow::<!, _>::Continue(())\n-        });\n-\n-        arm.pat.each_binding(|_, _, span, pat_ident| {\n-            if !field_accesses.contains(&pat_ident) {\n-                span_notes.push((span, \"the field referenced by this binding is unused\"));\n-            }\n-        });\n-    }\n-\n-    if !span_notes.is_empty() {\n-        report_lints(cx, item.span, span_notes);\n-    }\n-}\n-\n impl<'tcx> LateLintPass<'tcx> for MissingFieldsInDebug {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx rustc_hir::Item<'tcx>) {\n         // is this an `impl Debug for X` block?\n@@ -301,10 +225,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingFieldsInDebug {\n             && let typeck_results = cx.tcx.typeck_body(*body_id)\n             && should_lint(cx, typeck_results, block)\n         {\n-            match &self_item.kind {\n-                ItemKind::Struct(data, _) => check_struct(cx, typeck_results, block, self_ty, item, data),\n-                ItemKind::Enum(..) => check_enum(cx, typeck_results, block, self_ty, item),\n-                _ => {}\n+            // we intentionally only lint structs, see lint description\n+            if let ItemKind::Struct(data, _) = &self_item.kind {\n+                check_struct(cx, typeck_results, block, self_ty, item, data);\n             }\n         }\n     }"}, {"sha": "c156d394eceaaf8c045fe9a551f1b698d4b22b60", "filename": "tests/ui/missing_fields_in_debug.rs", "status": "modified", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a859b0e6dfae12169d6a239e2a63aef8227e1dce/tests%2Fui%2Fmissing_fields_in_debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a859b0e6dfae12169d6a239e2a63aef8227e1dce/tests%2Fui%2Fmissing_fields_in_debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_fields_in_debug.rs?ref=a859b0e6dfae12169d6a239e2a63aef8227e1dce", "patch": "@@ -97,140 +97,12 @@ impl fmt::Debug for MultiExprDebugImpl {\n     }\n }\n \n-enum SingleVariantEnumUnnamed {\n-    A(u8),\n-}\n-\n-// ok\n-impl fmt::Debug for SingleVariantEnumUnnamed {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n-        }\n-    }\n-}\n-\n-enum MultiVariantEnum {\n-    A(u8),\n-    B { a: u8, b: String },\n-    C,\n-}\n-\n-impl fmt::Debug for MultiVariantEnum {\n-    // match arm Self::B ignores `b`\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n-            Self::B { a, b } => formatter.debug_struct(\"B\").field(\"a\", &a).finish(),\n-            Self::C => formatter.debug_struct(\"C\").finish(),\n-        }\n-    }\n-}\n-\n-enum MultiVariantEnumOk {\n-    A(u8),\n-    B { a: u8, b: String },\n-    C,\n-}\n-\n-// ok\n-impl fmt::Debug for MultiVariantEnumOk {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n-            Self::B { a, b } => formatter.debug_struct(\"B\").field(\"a\", &a).field(\"b\", &b).finish(),\n-            Self::C => formatter.debug_struct(\"C\").finish(),\n-        }\n-    }\n-}\n-\n-enum MultiVariantEnumNonExhaustive {\n-    A(u8),\n-    B { a: u8, b: String },\n-    C,\n-}\n-\n-// ok\n-impl fmt::Debug for MultiVariantEnumNonExhaustive {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n-            Self::B { a, b } => formatter.debug_struct(\"B\").field(\"b\", &b).finish_non_exhaustive(),\n-            Self::C => formatter.debug_struct(\"C\").finish(),\n-        }\n-    }\n-}\n-\n-enum MultiVariantRest {\n-    A(u8),\n-    B { a: u8, b: String },\n-    C,\n-}\n-\n-impl fmt::Debug for MultiVariantRest {\n-    // `a` field ignored due to rest pattern\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n-            Self::B { b, .. } => formatter.debug_struct(\"B\").field(\"b\", &b).finish(),\n-            Self::C => formatter.debug_struct(\"C\").finish(),\n-        }\n-    }\n-}\n-\n-enum MultiVariantRestNonExhaustive {\n-    A(u8),\n-    B { a: u8, b: String },\n-    C,\n-}\n-\n-// ok\n-impl fmt::Debug for MultiVariantRestNonExhaustive {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n-            Self::B { b, .. } => formatter.debug_struct(\"B\").field(\"b\", &b).finish_non_exhaustive(),\n-            Self::C => formatter.debug_struct(\"C\").finish(),\n-        }\n-    }\n-}\n-\n-enum Wildcard {\n-    A(u8),\n-    B(String),\n-}\n-\n-// ok\n-impl fmt::Debug for Wildcard {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n-            _ => todo!(),\n-        }\n-    }\n-}\n-\n-enum Empty {}\n-\n-// ok\n-impl fmt::Debug for Empty {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {}\n-    }\n-}\n-\n #[derive(Debug)]\n struct DerivedStruct {\n     a: u8,\n     b: i32,\n }\n \n-#[derive(Debug)]\n-enum DerivedEnum {\n-    A(i32),\n-    B { a: String },\n-}\n-\n // https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1166846953\n \n struct Inner {"}, {"sha": "ef9d02abab7dbf1ff2bee7120560bc5dadf030b3", "filename": "tests/ui/missing_fields_in_debug.stderr", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a859b0e6dfae12169d6a239e2a63aef8227e1dce/tests%2Fui%2Fmissing_fields_in_debug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a859b0e6dfae12169d6a239e2a63aef8227e1dce/tests%2Fui%2Fmissing_fields_in_debug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_fields_in_debug.stderr?ref=a859b0e6dfae12169d6a239e2a63aef8227e1dce", "patch": "@@ -69,45 +69,5 @@ LL |     b: String,\n    = help: consider including all fields in this `Debug` impl\n    = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n \n-error: manual `Debug` impl does not include all fields\n-  --> $DIR/missing_fields_in_debug.rs:119:1\n-   |\n-LL | / impl fmt::Debug for MultiVariantEnum {\n-LL | |     // match arm Self::B ignores `b`\n-LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-LL | |         match self {\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n-   |\n-note: the field referenced by this binding is unused\n-  --> $DIR/missing_fields_in_debug.rs:124:26\n-   |\n-LL |             Self::B { a, b } => formatter.debug_struct(\"B\").field(\"a\", &a).finish(),\n-   |                          ^\n-   = help: consider including all fields in this `Debug` impl\n-   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n-\n-error: manual `Debug` impl does not include all fields\n-  --> $DIR/missing_fields_in_debug.rs:170:1\n-   |\n-LL | / impl fmt::Debug for MultiVariantRest {\n-LL | |     // `a` field ignored due to rest pattern\n-LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-LL | |         match self {\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n-   |\n-note: more unused fields here due to rest pattern `..`\n-  --> $DIR/missing_fields_in_debug.rs:175:13\n-   |\n-LL |             Self::B { b, .. } => formatter.debug_struct(\"B\").field(\"b\", &b).finish(),\n-   |             ^^^^^^^^^^^^^^^^^\n-   = help: consider including all fields in this `Debug` impl\n-   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n "}]}