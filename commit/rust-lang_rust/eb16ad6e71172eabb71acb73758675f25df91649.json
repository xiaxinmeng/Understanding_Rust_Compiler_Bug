{"sha": "eb16ad6e71172eabb71acb73758675f25df91649", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMTZhZDZlNzExNzJlYWJiNzFhY2I3Mzc1ODY3NWYyNWRmOTE2NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-27T08:47:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-27T08:47:53Z"}, "message": "Auto merge of #25790 - eddyb:oh-snap-ctfe-arrived, r=alexcrichton", "tree": {"sha": "d851353c5d9c88e9d736f81b65758dd8607be1f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d851353c5d9c88e9d736f81b65758dd8607be1f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb16ad6e71172eabb71acb73758675f25df91649", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb16ad6e71172eabb71acb73758675f25df91649", "html_url": "https://github.com/rust-lang/rust/commit/eb16ad6e71172eabb71acb73758675f25df91649", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb16ad6e71172eabb71acb73758675f25df91649/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2cf2c66e0999b2028d99900d797b971dc1c531b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2cf2c66e0999b2028d99900d797b971dc1c531b", "html_url": "https://github.com/rust-lang/rust/commit/a2cf2c66e0999b2028d99900d797b971dc1c531b"}, {"sha": "377b0900aede976b2d37a499bbd7b62c2e39b358", "url": "https://api.github.com/repos/rust-lang/rust/commits/377b0900aede976b2d37a499bbd7b62c2e39b358", "html_url": "https://github.com/rust-lang/rust/commit/377b0900aede976b2d37a499bbd7b62c2e39b358"}], "stats": {"total": 2319, "additions": 441, "deletions": 1878}, "files": [{"sha": "290b0566fd1b53d768858dc38e17df26049b0aec", "filename": "src/liballoc/arc_stage0.rs", "status": "removed", "additions": 0, "deletions": 686, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/a2cf2c66e0999b2028d99900d797b971dc1c531b/src%2Fliballoc%2Farc_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cf2c66e0999b2028d99900d797b971dc1c531b/src%2Fliballoc%2Farc_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc_stage0.rs?ref=a2cf2c66e0999b2028d99900d797b971dc1c531b", "patch": "@@ -1,686 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-//! Threadsafe reference-counted boxes (the `Arc<T>` type).\n-//!\n-//! The `Arc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as `Send` because it uses atomic reference counting.\n-//!\n-//! If you do not need thread-safety, and just need shared ownership, consider\n-//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n-//! does not use atomics, making it both thread-unsafe as well as significantly\n-//! faster when updating the reference count.\n-//!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n-//!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n-//!\n-//! # Examples\n-//!\n-//! Sharing some immutable data between threads:\n-//!\n-//! ```no_run\n-//! use std::sync::Arc;\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(5);\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         println!(\"{:?}\", five);\n-//!     });\n-//! }\n-//! ```\n-//!\n-//! Sharing mutable data safely between threads with a `Mutex`:\n-//!\n-//! ```no_run\n-//! use std::sync::{Arc, Mutex};\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(Mutex::new(5));\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         let mut number = five.lock().unwrap();\n-//!\n-//!         *number += 1;\n-//!\n-//!         println!(\"{}\", *number); // prints 6\n-//!     });\n-//! }\n-//! ```\n-\n-use boxed::Box;\n-\n-use core::prelude::*;\n-\n-use core::atomic;\n-use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n-use core::fmt;\n-use core::cmp::Ordering;\n-use core::mem::{min_align_of, size_of};\n-use core::mem;\n-use core::nonzero::NonZero;\n-use core::ops::Deref;\n-use core::ptr;\n-use core::hash::{Hash, Hasher};\n-use heap::deallocate;\n-\n-/// An atomically reference counted wrapper for shared state.\n-///\n-/// # Examples\n-///\n-/// In this example, a large vector of floats is shared between several threads.\n-/// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// thread.\n-///\n-/// When you clone an `Arc<T>`, it will create another pointer to the data and\n-/// increase the reference counter.\n-///\n-/// ```\n-/// # #![feature(alloc, core)]\n-/// use std::sync::Arc;\n-/// use std::thread;\n-///\n-/// fn main() {\n-///     let numbers: Vec<_> = (0..100u32).collect();\n-///     let shared_numbers = Arc::new(numbers);\n-///\n-///     for _ in 0..10 {\n-///         let child_numbers = shared_numbers.clone();\n-///\n-///         thread::spawn(move || {\n-///             let local_numbers = &child_numbers[..];\n-///\n-///             // Work with the local numbers\n-///         });\n-///     }\n-/// }\n-/// ```\n-#[unsafe_no_drop_flag]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Arc<T> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut ArcInner<T>>,\n-}\n-\n-unsafe impl<T: Sync + Send> Send for Arc<T> { }\n-unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n-\n-\n-/// A weak pointer to an `Arc`.\n-///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n-/// used to break cycles between `Arc` pointers.\n-#[unsafe_no_drop_flag]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-pub struct Weak<T> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut ArcInner<T>>,\n-}\n-\n-unsafe impl<T: Sync + Send> Send for Weak<T> { }\n-unsafe impl<T: Sync + Send> Sync for Weak<T> { }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"(Weak)\")\n-    }\n-}\n-\n-struct ArcInner<T> {\n-    strong: atomic::AtomicUsize,\n-    weak: atomic::AtomicUsize,\n-    data: T,\n-}\n-\n-unsafe impl<T: Sync + Send> Send for ArcInner<T> {}\n-unsafe impl<T: Sync + Send> Sync for ArcInner<T> {}\n-\n-impl<T> Arc<T> {\n-    /// Constructs a new `Arc<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(data: T) -> Arc<T> {\n-        // Start the weak pointer count as 1 which is the weak pointer that's\n-        // held by all the strong pointers (kinda), see std/rc.rs for more info\n-        let x: Box<_> = box ArcInner {\n-            strong: atomic::AtomicUsize::new(1),\n-            weak: atomic::AtomicUsize::new(1),\n-            data: data,\n-        };\n-        Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n-    }\n-\n-    /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    /// ```\n-    #[unstable(feature = \"alloc\",\n-               reason = \"Weak pointers may not belong in this module.\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        // See the clone() impl for why this is relaxed\n-        self.inner().weak.fetch_add(1, Relaxed);\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-\n-impl<T> Arc<T> {\n-    #[inline]\n-    fn inner(&self) -> &ArcInner<T> {\n-        // This unsafety is ok because while this arc is alive we're guaranteed\n-        // that the inner pointer is valid. Furthermore, we know that the\n-        // `ArcInner` structure itself is `Sync` because the inner data is\n-        // `Sync` as well, so we're ok loaning out an immutable pointer to these\n-        // contents.\n-        unsafe { &**self._ptr }\n-    }\n-\n-    // Non-inlined part of `drop`.\n-    #[inline(never)]\n-    unsafe fn drop_slow(&mut self) {\n-        let ptr = *self._ptr;\n-\n-        // Destroy the data at this time, even though we may not free the box\n-        // allocation itself (there may still be weak pointers lying around).\n-        drop(ptr::read(&self.inner().data));\n-\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n-            deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(), min_align_of::<ArcInner<T>>())\n-        }\n-    }\n-}\n-\n-/// Get the number of weak references to this value.\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n-\n-/// Get the number of strong references to this value.\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n-\n-\n-/// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n-///\n-/// Returns `None` if the `Arc<T>` is not unique.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(alloc)]\n-/// extern crate alloc;\n-/// # fn main() {\n-/// use alloc::arc::{Arc, get_mut};\n-///\n-/// let mut x = Arc::new(3);\n-/// *get_mut(&mut x).unwrap() = 4;\n-/// assert_eq!(*x, 4);\n-///\n-/// let _y = x.clone();\n-/// assert!(get_mut(&mut x).is_none());\n-/// # }\n-/// ```\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn get_mut<T>(this: &mut Arc<T>) -> Option<&mut T> {\n-    if strong_count(this) == 1 && weak_count(this) == 0 {\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the Arc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n-        let inner = unsafe { &mut **this._ptr };\n-        Some(&mut inner.data)\n-    } else {\n-        None\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Arc<T> {\n-    /// Makes a clone of the `Arc<T>`.\n-    ///\n-    /// This increases the strong reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Arc<T> {\n-        // Using a relaxed ordering is alright here, as knowledge of the\n-        // original reference prevents other threads from erroneously deleting\n-        // the object.\n-        //\n-        // As explained in the [Boost documentation][1], Increasing the\n-        // reference counter can always be done with memory_order_relaxed: New\n-        // references to an object can only be formed from an existing\n-        // reference, and passing an existing reference from one thread to\n-        // another must already provide any required synchronization.\n-        //\n-        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        self.inner().strong.fetch_add(1, Relaxed);\n-        Arc { _ptr: self._ptr }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Deref for Arc<T> {\n-    type Target = T;\n-\n-    #[inline]\n-    fn deref(&self) -> &T {\n-        &self.inner().data\n-    }\n-}\n-\n-impl<T: Clone> Arc<T> {\n-    /// Make a mutable reference from the given `Arc<T>`.\n-    ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let mut five = Arc::new(5);\n-    ///\n-    /// let mut_five = five.make_unique();\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"alloc\")]\n-    pub fn make_unique(&mut self) -> &mut T {\n-        // Note that we hold a strong reference, which also counts as a weak\n-        // reference, so we only clone if there is an additional reference of\n-        // either kind.\n-        if self.inner().strong.load(SeqCst) != 1 ||\n-           self.inner().weak.load(SeqCst) != 1 {\n-            *self = Arc::new((**self).clone())\n-        }\n-        // As with `get_mut()`, the unsafety is ok because our reference was\n-        // either unique to begin with, or became one upon cloning the contents.\n-        let inner = unsafe { &mut **self._ptr };\n-        &mut inner.data\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Arc<T> {\n-    /// Drops the `Arc<T>`.\n-    ///\n-    /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    #[inline]\n-    fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n-        // more than once (but it is guaranteed to be zeroed after the first if\n-        // it's run more than once)\n-        let ptr = *self._ptr;\n-        // if ptr.is_null() { return }\n-        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n-\n-        // Because `fetch_sub` is already atomic, we do not need to synchronize\n-        // with other threads unless we are going to delete the object. This\n-        // same logic applies to the below `fetch_sub` to the `weak` count.\n-        if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n-\n-        // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data.  Because it is marked `Release`, the decreasing\n-        // of the reference count synchronizes with this `Acquire` fence. This\n-        // means that use of the data happens before decreasing the reference\n-        // count, which happens before this fence, which happens before the\n-        // deletion of the data.\n-        //\n-        // As explained in the [Boost documentation][1],\n-        //\n-        // > It is important to enforce any possible access to the object in one\n-        // > thread (through an existing reference) to *happen before* deleting\n-        // > the object in a different thread. This is achieved by a \"release\"\n-        // > operation after dropping a reference (any access to the object\n-        // > through this reference must obviously happened before), and an\n-        // > \"acquire\" operation before deleting the object.\n-        //\n-        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        atomic::fence(Acquire);\n-\n-        unsafe {\n-            self.drop_slow()\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n-    ///\n-    /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n-    ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    ///\n-    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n-    /// ```\n-    pub fn upgrade(&self) -> Option<Arc<T>> {\n-        // We use a CAS loop to increment the strong count instead of a\n-        // fetch_add because once the count hits 0 it must never be above 0.\n-        let inner = self.inner();\n-        loop {\n-            let n = inner.strong.load(SeqCst);\n-            if n == 0 { return None }\n-            let old = inner.strong.compare_and_swap(n, n + 1, SeqCst);\n-            if old == n { return Some(Arc { _ptr: self._ptr }) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn inner(&self) -> &ArcInner<T> {\n-        // See comments above for why this is \"safe\"\n-        unsafe { &**self._ptr }\n-    }\n-}\n-\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n-    ///\n-    /// This increases the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let weak_five = Arc::new(5).downgrade();\n-    ///\n-    /// weak_five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Weak<T> {\n-        // See comments in Arc::clone() for why this is relaxed\n-        self.inner().weak.fetch_add(1, Relaxed);\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n-    ///\n-    /// This will decrement the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(weak_five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    fn drop(&mut self) {\n-        let ptr = *self._ptr;\n-\n-        // see comments above for why this check is here\n-        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n-\n-        // If we find out that we were the last weak pointer, then its time to\n-        // deallocate the data entirely. See the discussion in Arc::drop() about\n-        // the memory orderings\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n-            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n-                                min_align_of::<ArcInner<T>>()) }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialEq> PartialEq for Arc<T> {\n-    /// Equality for two `Arc<T>`s.\n-    ///\n-    /// Two `Arc<T>`s are equal if their inner value are equal.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five == Arc::new(5);\n-    /// ```\n-    fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n-\n-    /// Inequality for two `Arc<T>`s.\n-    ///\n-    /// Two `Arc<T>`s are unequal if their inner value are unequal.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five != Arc::new(5);\n-    /// ```\n-    fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for Arc<T> {\n-    /// Partial comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `partial_cmp()` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five.partial_cmp(&Arc::new(5));\n-    /// ```\n-    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-\n-    /// Less-than comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `<` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five < Arc::new(5);\n-    /// ```\n-    fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n-\n-    /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `<=` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five <= Arc::new(5);\n-    /// ```\n-    fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n-\n-    /// Greater-than comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `>` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five > Arc::new(5);\n-    /// ```\n-    fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n-\n-    /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `>=` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five >= Arc::new(5);\n-    /// ```\n-    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for Arc<T> {\n-    fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for Arc<T> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Display> fmt::Display for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> fmt::Pointer for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self._ptr, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Default> Default for Arc<T> {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> Arc<T> { Arc::new(Default::default()) }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash> Hash for Arc<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state)\n-    }\n-}"}, {"sha": "12eadcc145d5244b0154ad457a409da6092e1035", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -57,16 +57,12 @@ use core::any::Any;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n+use core::marker::Unsize;\n use core::mem;\n-use core::ops::{Deref, DerefMut};\n+use core::ops::{CoerceUnsized, Deref, DerefMut};\n use core::ptr::{Unique};\n use core::raw::{TraitObject};\n \n-#[cfg(not(stage0))]\n-use core::marker::Unsize;\n-#[cfg(not(stage0))]\n-use core::ops::CoerceUnsized;\n-\n /// A value that represents the heap. This is the default place that the `box`\n /// keyword allocates into when no place is supplied.\n ///\n@@ -392,5 +388,4 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}"}, {"sha": "ac5a5d60cbd47d0afdfda1180827efa3a7d6e991", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -112,14 +112,7 @@ pub mod boxed;\n mod boxed { pub use std::boxed::{Box, HEAP}; }\n #[cfg(test)]\n mod boxed_test;\n-#[cfg(not(stage0))]\n pub mod arc;\n-#[cfg(stage0)]\n-mod arc_stage0;\n-#[cfg(stage0)]\n-pub mod arc {\n-    pub use arc_stage0::*;\n-}\n pub mod rc;\n \n /// Common out-of-memory routine"}, {"sha": "44f4a6a6290c8e04ae12ebd96416921c83a8043a", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 415, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -159,36 +159,19 @@ use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-use core::marker::{self, Sized};\n-use core::mem::{self, min_align_of, size_of, forget};\n+use core::intrinsics::{assume, drop_in_place};\n+use core::marker::{self, Sized, Unsize};\n+use core::mem::{self, min_align_of, size_of, min_align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n-use core::ops::{Deref, Drop};\n+use core::ops::{CoerceUnsized, Deref, Drop};\n use core::option::Option;\n use core::option::Option::{Some, None};\n use core::ptr;\n use core::result::Result;\n use core::result::Result::{Ok, Err};\n-use core::intrinsics::assume;\n-\n-#[cfg(not(stage0))]\n-use core::intrinsics::drop_in_place;\n-#[cfg(not(stage0))]\n-use core::marker::Unsize;\n-#[cfg(not(stage0))]\n-use core::mem::{min_align_of_val, size_of_val};\n-#[cfg(not(stage0))]\n-use core::ops::CoerceUnsized;\n \n use heap::deallocate;\n \n-#[cfg(stage0)]\n-struct RcBox<T> {\n-    strong: Cell<usize>,\n-    weak: Cell<usize>,\n-    value: T,\n-}\n-\n-#[cfg(not(stage0))]\n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n@@ -199,15 +182,6 @@ struct RcBox<T: ?Sized> {\n /// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n-#[cfg(stage0)]\n-#[unsafe_no_drop_flag]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with field\n-    // accesses of the contained type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-}\n-#[cfg(not(stage0))]\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n@@ -216,19 +190,9 @@ pub struct Rc<T: ?Sized> {\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n-#[cfg(stage0)]\n-impl<T> !marker::Send for Rc<T> {}\n-\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Send for Rc<T> {}\n-\n-#[cfg(stage0)]\n-impl<T> !marker::Sync for Rc<T> {}\n-\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Sync for Rc<T> {}\n \n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n \n impl<T> Rc<T> {\n@@ -259,7 +223,6 @@ impl<T> Rc<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T: ?Sized> Rc<T> {\n     /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n     ///\n@@ -281,44 +244,12 @@ impl<T: ?Sized> Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T> Rc<T> {\n-    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    /// ```\n-    #[unstable(feature = \"alloc\",\n-               reason = \"Weak pointers may not belong in this module\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-\n /// Get the number of weak references to this value.\n-#[cfg(stage0)]\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n-#[cfg(not(stage0))]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n-#[cfg(stage0)]\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n-#[cfg(not(stage0))]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n@@ -438,17 +369,6 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Deref for Rc<T> {\n-    type Target = T;\n-\n-    #[inline(always)]\n-    fn deref(&self) -> &T {\n-        &self.inner().value\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Rc<T> {\n     type Target = T;\n@@ -459,58 +379,6 @@ impl<T: ?Sized> Deref for Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Rc<T> {\n-    /// Drops the `Rc<T>`.\n-    ///\n-    /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    fn drop(&mut self) {\n-        unsafe {\n-            let ptr = *self._ptr;\n-            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n-                self.dec_strong();\n-                if self.strong() == 0 {\n-                    ptr::read(&**self); // destroy the contained object\n-\n-                    // remove the implicit \"strong weak\" pointer now that we've\n-                    // destroyed the contents.\n-                    self.dec_weak();\n-\n-                    if self.weak() == 0 {\n-                        deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n-                                   min_align_of::<RcBox<T>>())\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n@@ -564,32 +432,6 @@ impl<T: ?Sized> Drop for Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Rc<T> {\n-\n-    /// Makes a clone of the `Rc<T>`.\n-    ///\n-    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n-    /// increase the strong reference counter.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    ///\n-    /// five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Rc<T> {\n-        self.inc_strong();\n-        Rc { _ptr: self._ptr }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Rc<T> {\n \n@@ -634,17 +476,6 @@ impl<T: Default> Default for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: PartialEq> PartialEq for Rc<T> {\n-    #[inline(always)]\n-    fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n-\n-    #[inline(always)]\n-    fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -680,34 +511,9 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: Eq> Eq for Rc<T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + Eq> Eq for Rc<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: PartialOrd> PartialOrd for Rc<T> {\n-    #[inline(always)]\n-    fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-\n-    #[inline(always)]\n-    fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n-\n-    #[inline(always)]\n-    fn le(&self, other: &Rc<T>) -> bool { **self <= **other }\n-\n-    #[inline(always)]\n-    fn gt(&self, other: &Rc<T>) -> bool { **self > **other }\n-\n-    #[inline(always)]\n-    fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -793,13 +599,6 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: Ord> Ord for Rc<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///\n@@ -818,44 +617,20 @@ impl<T: ?Sized + Ord> Ord for Rc<T> {\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash> Hash for Rc<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Display> fmt::Display for Rc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -876,16 +651,6 @@ impl<T> fmt::Pointer for Rc<T> {\n /// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n-#[cfg(stage0)]\n-#[unsafe_no_drop_flag]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-pub struct Weak<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-}\n-#[cfg(not(stage0))]\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n@@ -895,51 +660,9 @@ pub struct Weak<T: ?Sized> {\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n-#[cfg(stage0)]\n-impl<T> !marker::Send for Weak<T> {}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Send for Weak<T> {}\n-\n-#[cfg(stage0)]\n-impl<T> !marker::Sync for Weak<T> {}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n-\n-#[cfg(stage0)]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Weak<T> {\n-\n-    /// Upgrades a weak reference to a strong reference.\n-    ///\n-    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n-    ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    ///\n-    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n-    /// ```\n-    pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n-            None\n-        } else {\n-            self.inc_strong();\n-            Some(Rc { _ptr: self._ptr })\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Weak<T> {\n@@ -973,52 +696,6 @@ impl<T: ?Sized> Weak<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n-    ///\n-    /// This will decrement the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(weak_five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    fn drop(&mut self) {\n-        unsafe {\n-            let ptr = *self._ptr;\n-            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n-                self.dec_weak();\n-                // the weak count starts at 1, and will only go to zero if all\n-                // the strong pointers have disappeared.\n-                if self.weak() == 0 {\n-                    deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n-                               min_align_of::<RcBox<T>>())\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n@@ -1064,32 +741,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Clone for Weak<T> {\n-\n-    /// Makes a clone of the `Weak<T>`.\n-    ///\n-    /// This increases the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let weak_five = Rc::new(5).downgrade();\n-    ///\n-    /// weak_five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Clone for Weak<T> {\n@@ -1115,45 +766,13 @@ impl<T: ?Sized> Clone for Weak<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"(Weak)\")\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n }\n \n-#[cfg(stage0)]\n-#[doc(hidden)]\n-trait RcBoxPtr<T> {\n-    fn inner(&self) -> &RcBox<T>;\n-\n-    #[inline]\n-    fn strong(&self) -> usize { self.inner().strong.get() }\n-\n-    #[inline]\n-    fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }\n-\n-    #[inline]\n-    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n-\n-    #[inline]\n-    fn weak(&self) -> usize { self.inner().weak.get() }\n-\n-    #[inline]\n-    fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }\n-\n-    #[inline]\n-    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n-}\n-#[cfg(not(stage0))]\n #[doc(hidden)]\n trait RcBoxPtr<T: ?Sized> {\n     fn inner(&self) -> &RcBox<T>;\n@@ -1177,21 +796,6 @@ trait RcBoxPtr<T: ?Sized> {\n     fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n }\n \n-#[cfg(stage0)]\n-impl<T> RcBoxPtr<T> for Rc<T> {\n-    #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n@@ -1206,21 +810,6 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T> RcBoxPtr<T> for Weak<T> {\n-    #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {"}, {"sha": "8e8fc0bedec6ac5080aaf82df975424268a73da8", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -116,17 +116,11 @@ impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n     fn borrow_mut(&mut self) -> &mut T { &mut **self }\n }\n \n-#[cfg(stage0)]\n-impl<T> Borrow<T> for rc::Rc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: ?Sized> Borrow<T> for rc::Rc<T> {\n     fn borrow(&self) -> &T { &**self }\n }\n \n-impl<T> Borrow<T> for arc::Arc<T> {\n+impl<T: ?Sized> Borrow<T> for arc::Arc<T> {\n     fn borrow(&self) -> &T { &**self }\n }\n "}, {"sha": "2d8335d37347325e6ce0a296ff9678a6c4a37fff", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -19,7 +19,6 @@ pub use self::TraversalItem::*;\n use core::prelude::*;\n \n use core::cmp::Ordering::{Greater, Less, Equal};\n-#[cfg(not(stage0))]\n use core::intrinsics::arith_offset;\n use core::iter::Zip;\n use core::marker::PhantomData;\n@@ -207,22 +206,6 @@ impl<T> RawItems<T> {\n         RawItems::from_parts(slice.as_ptr(), slice.len())\n     }\n \n-    #[cfg(stage0)]\n-    unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n-        if mem::size_of::<T>() == 0 {\n-            RawItems {\n-                head: ptr,\n-                tail: (ptr as usize + len) as *const T,\n-            }\n-        } else {\n-            RawItems {\n-                head: ptr,\n-                tail: ptr.offset(len as isize),\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n         if mem::size_of::<T>() == 0 {\n             RawItems {\n@@ -237,18 +220,6 @@ impl<T> RawItems<T> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    unsafe fn push(&mut self, val: T) {\n-        ptr::write(self.tail as *mut T, val);\n-\n-        if mem::size_of::<T>() == 0 {\n-            self.tail = (self.tail as usize + 1) as *const T;\n-        } else {\n-            self.tail = self.tail.offset(1);\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     unsafe fn push(&mut self, val: T) {\n         ptr::write(self.tail as *mut T, val);\n \n@@ -263,26 +234,6 @@ impl<T> RawItems<T> {\n impl<T> Iterator for RawItems<T> {\n     type Item = T;\n \n-    #[cfg(stage0)]\n-    fn next(&mut self) -> Option<T> {\n-        if self.head == self.tail {\n-            None\n-        } else {\n-            unsafe {\n-                let ret = Some(ptr::read(self.head));\n-\n-                if mem::size_of::<T>() == 0 {\n-                    self.head = (self.head as usize + 1) as *const T;\n-                } else {\n-                    self.head = self.head.offset(1);\n-                }\n-\n-                ret\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn next(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None\n@@ -303,24 +254,6 @@ impl<T> Iterator for RawItems<T> {\n }\n \n impl<T> DoubleEndedIterator for RawItems<T> {\n-    #[cfg(stage0)]\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.head == self.tail {\n-            None\n-        } else {\n-            unsafe {\n-                if mem::size_of::<T>() == 0 {\n-                    self.tail = (self.tail as usize - 1) as *const T;\n-                } else {\n-                    self.tail = self.tail.offset(-1);\n-                }\n-\n-                Some(ptr::read(self.tail))\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn next_back(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None"}, {"sha": "4d52eb8e8ae671e96666b95f01699748c763f8fb", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 71, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -66,9 +66,7 @@ use core::cmp::max;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::intrinsics::assume;\n-#[cfg(not(stage0))]\n-use core::intrinsics::arith_offset;\n+use core::intrinsics::{arith_offset, assume};\n use core::iter::{repeat, FromIterator};\n use core::marker::PhantomData;\n use core::mem;\n@@ -1526,25 +1524,6 @@ impl<T> IntoIterator for Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[cfg(stage0)]\n-    fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            let ptr = *self.ptr;\n-            assume(!ptr.is_null());\n-            let cap = self.cap;\n-            let begin = ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as usize + self.len()) as *const T\n-            } else {\n-                ptr.offset(self.len() as isize) as *const T\n-            };\n-            mem::forget(self);\n-            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = *self.ptr;\n@@ -1764,32 +1743,6 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     #[inline]\n-    #[cfg(stage0)]\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.ptr == self.end {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // purposefully don't use 'ptr.offset' because for\n-                    // vectors with 0-size elements this would return the\n-                    // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as usize + 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    let old = self.ptr;\n-                    self.ptr = self.ptr.offset(1);\n-\n-                    Some(ptr::read(old))\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn next(&mut self) -> Option<T> {\n         unsafe {\n             if self.ptr == self.end {\n@@ -1830,29 +1783,6 @@ impl<T> Iterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    #[cfg(stage0)]\n-    fn next_back(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.end == self.ptr {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as usize - 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    self.end = self.end.offset(-1);\n-\n-                    Some(ptr::read(mem::transmute(self.end)))\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn next_back(&mut self) -> Option<T> {\n         unsafe {\n             if self.end == self.ptr {"}, {"sha": "b4d3d0b1a22815d75000a21ceeff7ee5ac45ad58", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -399,7 +399,7 @@ fn test_map_in_place_zero_sized() {\n \n #[test]\n fn test_map_in_place_zero_drop_count() {\n-    use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n     #[derive(Clone, PartialEq, Debug)]\n     struct Nothing;\n@@ -413,7 +413,7 @@ fn test_map_in_place_zero_drop_count() {\n         }\n     }\n     const NUM_ELEMENTS: usize = 2;\n-    static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n \n     let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n "}, {"sha": "56b459f5f17d809915d45bc9f1a3a3e6de1b756e", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -76,7 +76,6 @@ use marker::Sync;\n \n use intrinsics;\n use cell::UnsafeCell;\n-use marker::PhantomData;\n \n use default::Default;\n \n@@ -87,8 +86,8 @@ pub struct AtomicBool {\n }\n \n impl Default for AtomicBool {\n-    fn default() -> AtomicBool {\n-        ATOMIC_BOOL_INIT\n+    fn default() -> Self {\n+        Self::new(Default::default())\n     }\n }\n \n@@ -101,8 +100,8 @@ pub struct AtomicIsize {\n }\n \n impl Default for AtomicIsize {\n-    fn default() -> AtomicIsize {\n-        ATOMIC_ISIZE_INIT\n+    fn default() -> Self {\n+        Self::new(Default::default())\n     }\n }\n \n@@ -115,8 +114,8 @@ pub struct AtomicUsize {\n }\n \n impl Default for AtomicUsize {\n-    fn default() -> AtomicUsize {\n-        ATOMIC_USIZE_INIT\n+    fn default() -> Self {\n+        Self::new(Default::default())\n     }\n }\n \n@@ -125,8 +124,7 @@ unsafe impl Sync for AtomicUsize {}\n /// A raw pointer type which can be safely shared between threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n-    p: UnsafeCell<usize>,\n-    _marker: PhantomData<*mut T>,\n+    p: UnsafeCell<*mut T>,\n }\n \n impl<T> Default for AtomicPtr<T> {\n@@ -175,16 +173,13 @@ pub enum Ordering {\n \n /// An `AtomicBool` initialized to `false`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_BOOL_INIT: AtomicBool =\n-        AtomicBool { v: UnsafeCell { value: 0 } };\n+pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n /// An `AtomicIsize` initialized to `0`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_ISIZE_INIT: AtomicIsize =\n-        AtomicIsize { v: UnsafeCell { value: 0 } };\n+pub const ATOMIC_ISIZE_INIT: AtomicIsize = AtomicIsize::new(0);\n /// An `AtomicUsize` initialized to `0`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_USIZE_INIT: AtomicUsize =\n-        AtomicUsize { v: UnsafeCell { value: 0, } };\n+pub const ATOMIC_USIZE_INIT: AtomicUsize = AtomicUsize::new(0);\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: usize = !0;\n@@ -202,9 +197,8 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(v: bool) -> AtomicBool {\n-        let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: UnsafeCell::new(val) }\n+    pub const fn new(v: bool) -> AtomicBool {\n+        AtomicBool { v: UnsafeCell::new(-(v as isize) as usize) }\n     }\n \n     /// Loads a value from the bool.\n@@ -445,7 +439,7 @@ impl AtomicIsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(v: isize) -> AtomicIsize {\n+    pub const fn new(v: isize) -> AtomicIsize {\n         AtomicIsize {v: UnsafeCell::new(v)}\n     }\n \n@@ -633,7 +627,7 @@ impl AtomicUsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(v: usize) -> AtomicUsize {\n+    pub const fn new(v: usize) -> AtomicUsize {\n         AtomicUsize { v: UnsafeCell::new(v) }\n     }\n \n@@ -821,9 +815,8 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: UnsafeCell::new(p as usize),\n-                    _marker: PhantomData }\n+    pub const fn new(p: *mut T) -> AtomicPtr<T> {\n+        AtomicPtr { p: UnsafeCell::new(p) }\n     }\n \n     /// Loads a value from the pointer.\n@@ -848,7 +841,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_load(self.p.get(), order) as *mut T\n+            atomic_load(self.p.get() as *mut usize, order) as *mut T\n         }\n     }\n \n@@ -875,7 +868,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(self.p.get(), ptr as usize, order); }\n+        unsafe { atomic_store(self.p.get() as *mut usize, ptr as usize, order); }\n     }\n \n     /// Stores a value into the pointer, returning the old value.\n@@ -897,7 +890,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(self.p.get(), ptr as usize, order) as *mut T }\n+        unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n     /// Stores a value into the pointer if the current value is the same as the expected value.\n@@ -925,7 +918,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get(), old as usize,\n+            atomic_compare_and_swap(self.p.get() as *mut usize, old as usize,\n                                     new as usize, order) as *mut T\n         }\n     }"}, {"sha": "c83421d3067cd0579e1dbfbf6efeffc2015bc2a1", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -170,7 +170,7 @@ impl<T:Copy> Cell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn new(value: T) -> Cell<T> {\n+    pub const fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n         }\n@@ -302,7 +302,7 @@ impl<T> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn new(value: T) -> RefCell<T> {\n+    pub const fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n             borrow: Cell::new(UNUSED),\n@@ -663,7 +663,7 @@ impl<T> UnsafeCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn new(value: T) -> UnsafeCell<T> {\n+    pub const fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n "}, {"sha": "88a686ec255f34732454abed6f2a643df9c30226", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -145,13 +145,9 @@ extern \"rust-intrinsic\" {\n     /// but no instructions will be emitted for it. This is appropriate for operations\n     /// on the same thread that may be preempted, such as when interacting with signal\n     /// handlers.\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence();\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence_acq();\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence_rel();\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence_acqrel();\n \n     /// Aborts the execution of the process.\n@@ -193,11 +189,8 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of<T>() -> usize;\n     pub fn pref_align_of<T>() -> usize;\n \n-    #[cfg(not(stage0))]\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n-    #[cfg(not(stage0))]\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n-    #[cfg(not(stage0))]\n     pub fn drop_in_place<T: ?Sized>(_: *mut T);\n \n     /// Gets a static string slice containing the name of a type.\n@@ -294,7 +287,6 @@ extern \"rust-intrinsic\" {\n     /// resulting pointer to point into or one byte past the end of an allocated\n     /// object, and it wraps with two's complement arithmetic. The resulting\n     /// value is not necessarily valid to be used to actually access memory.\n-    #[cfg(not(stage0))]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -592,13 +584,6 @@ extern \"rust-intrinsic\" {\n     /// Returns (a * b) mod 2^N, where N is the width of N in bits.\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n-    /// Returns the value of the discriminant for the variant in 'v',\n-    /// cast to a `u64`; if `T` has no discriminant, returns 0.\n-    pub fn discriminant_value<T>(v: &T) -> u64;\n-}\n-\n-#[cfg(not(stage0))]\n-extern \"rust-intrinsic\" {\n     /// Performs an unchecked signed division, which results in undefined behavior,\n     /// in cases where y == 0, or x == int::MIN and y == -1\n     pub fn unchecked_sdiv<T>(x: T, y: T) -> T;\n@@ -612,4 +597,8 @@ extern \"rust-intrinsic\" {\n     /// Returns the remainder of an unchecked signed division, which results in\n     /// undefined behavior, in cases where y == 0\n     pub fn unchecked_srem<T>(x: T, y: T) -> T;\n+\n+    /// Returns the value of the discriminant for the variant in 'v',\n+    /// cast to a `u64`; if `T` has no discriminant, returns 0.\n+    pub fn discriminant_value<T>(v: &T) -> u64;\n }"}, {"sha": "9dfaec0095a5a6e648799f7ceae90c9826aecd3d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -74,6 +74,7 @@\n #![feature(concat_idents)]\n #![feature(reflect)]\n #![feature(custom_attribute)]\n+#![feature(const_fn)]\n \n #[macro_use]\n mod macros;"}, {"sha": "bc0f3045972fe6b67e04c7189ea152cfe7ac9756", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -55,7 +55,6 @@ pub trait Sized {\n \n /// Types that can be \"unsized\" to a dynamically sized type.\n #[unstable(feature = \"core\")]\n-#[cfg(not(stage0))]\n #[lang=\"unsize\"]\n pub trait Unsize<T> {\n     // Empty."}, {"sha": "7749d053285ad09f646c27004bc28f7dd8c9a070", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -95,29 +95,12 @@ pub fn size_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n-#[cfg(not(stage0))]\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::size_of_val(val) }\n }\n \n-/// Returns the size of the type that `_val` points to in bytes.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::size_of_val(&5i32));\n-/// ```\n-#[cfg(stage0)]\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of_val<T>(_val: &T) -> usize {\n-    size_of::<T>()\n-}\n-\n /// Returns the ABI-required minimum alignment of a type\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n@@ -144,29 +127,12 @@ pub fn min_align_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n-#[cfg(not(stage0))]\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `_val` points to\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of_val(&5i32));\n-/// ```\n-#[cfg(stage0)]\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn min_align_of_val<T>(_val: &T) -> usize {\n-    min_align_of::<T>()\n-}\n-\n /// Returns the alignment in memory for a type.\n ///\n /// This function will return the alignment, in bytes, of a type in memory. If the alignment"}, {"sha": "32522794254f683eb7a2894f0400a91f225d2205", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -11,9 +11,7 @@\n //! Exposes the NonZero lang item which provides optimization hints.\n \n use marker::Sized;\n-use ops::Deref;\n-#[cfg(not(stage0))]\n-use ops::CoerceUnsized;\n+use ops::{CoerceUnsized, Deref};\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -57,5 +55,4 @@ impl<T: Zeroable> Deref for NonZero<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T: Zeroable+CoerceUnsized<U>, U: Zeroable> CoerceUnsized<NonZero<U>> for NonZero<T> {}"}, {"sha": "c52f4de732ff9f56d46902887b3e2e27a20d27e3", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -67,12 +67,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use marker::Sized;\n+use marker::{Sized, Unsize};\n use fmt;\n \n-#[cfg(not(stage0))]\n-use marker::Unsize;\n-\n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n /// is sometimes called a 'destructor'.\n ///\n@@ -1214,39 +1211,29 @@ mod impls {\n /// Trait that indicates that this is a pointer or a wrapper for one,\n /// where unsizing can be performed on the pointee.\n #[unstable(feature = \"core\")]\n-#[cfg(not(stage0))]\n #[lang=\"coerce_unsized\"]\n pub trait CoerceUnsized<T> {\n     // Empty.\n }\n \n // &mut T -> &mut U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n // &mut T -> &U\n-#[cfg(not(stage0))]\n impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n // &mut T -> *mut U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n // &mut T -> *const U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n \n // &T -> &U\n-#[cfg(not(stage0))]\n impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n // &T -> *const U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n \n // *mut T -> *mut U\n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n // *mut T -> *const U\n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}"}, {"sha": "2dc28a4786f2dd76169672ee069d783378370db8", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -125,19 +125,6 @@ pub trait SliceExt {\n }\n \n // Use macros to be generic over const/mut\n-#[cfg(stage0)]\n-macro_rules! slice_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            transmute((ptr as isize).wrapping_add($by))\n-        } else {\n-            ptr.offset($by)\n-        }\n-    }};\n-}\n-\n-#[cfg(not(stage0))]\n macro_rules! slice_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;"}, {"sha": "c50f18c235233ff57dfd2e5b897c657b7dbd7412", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -70,13 +70,15 @@ fn int_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n-static S_BOOL : AtomicBool = ATOMIC_BOOL_INIT;\n-static S_INT  : AtomicIsize  = ATOMIC_ISIZE_INIT;\n-static S_UINT : AtomicUsize = ATOMIC_USIZE_INIT;\n+static S_FALSE: AtomicBool = AtomicBool::new(false);\n+static S_TRUE: AtomicBool = AtomicBool::new(true);\n+static S_INT: AtomicIsize  = AtomicIsize::new(0);\n+static S_UINT: AtomicUsize = AtomicUsize::new(0);\n \n #[test]\n fn static_init() {\n-    assert!(!S_BOOL.load(SeqCst));\n+    assert!(!S_FALSE.load(SeqCst));\n+    assert!(S_TRUE.load(SeqCst));\n     assert!(S_INT.load(SeqCst) == 0);\n     assert!(S_UINT.load(SeqCst) == 0);\n }"}, {"sha": "4c92162b2d6dcc34546a1bd5a95221588c0362f3", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -184,7 +184,7 @@ use std::mem;\n use std::env;\n use std::rt;\n use std::slice;\n-use std::sync::{Once, ONCE_INIT, StaticMutex, MUTEX_INIT};\n+use std::sync::{Once, StaticMutex};\n \n use directive::LOG_LEVEL_NAMES;\n \n@@ -200,7 +200,7 @@ pub const MAX_LOG_LEVEL: u32 = 255;\n /// The default logging level of a crate if no other is specified.\n const DEFAULT_LOG_LEVEL: u32 = 1;\n \n-static LOCK: StaticMutex = MUTEX_INIT;\n+static LOCK: StaticMutex = StaticMutex::new();\n \n /// An unsafe constant that is the maximum logging level of any module\n /// specified. This is the first line of defense to determining whether a\n@@ -367,7 +367,7 @@ pub struct LogLocation {\n /// module's log statement should be emitted or not.\n #[doc(hidden)]\n pub fn mod_enabled(level: u32, module: &str) -> bool {\n-    static INIT: Once = ONCE_INIT;\n+    static INIT: Once = Once::new();\n     INIT.call_once(init);\n \n     // It's possible for many threads are in this function, only one of them"}, {"sha": "c92bb81c5fb254d841fd0b59a44b1d90e609962b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -167,7 +167,4 @@ mod rustc {\n }\n \n // Build the diagnostics array at the end so that the metadata includes error use sites.\n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "5a06a5193bf1c16c6fcd5a8ea6ef156730c19359", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -32,7 +32,7 @@ use std::env;\n use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n-use std::sync::atomic::{AtomicBool, Ordering, ATOMIC_BOOL_INIT};\n+use std::sync::atomic::{AtomicBool, Ordering};\n use syntax::ast;\n \n fn print_help_message() {\n@@ -76,7 +76,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     let output_path = {\n         let output_template = match requested_output {\n             Ok(ref s) if &**s == \"help\" => {\n-                static PRINTED_YET: AtomicBool = ATOMIC_BOOL_INIT;\n+                static PRINTED_YET: AtomicBool = AtomicBool::new(false);\n                 if !PRINTED_YET.load(Ordering::SeqCst) {\n                     print_help_message();\n                     PRINTED_YET.store(true, Ordering::SeqCst);"}, {"sha": "a8457d3bf94cdf93c3fa622bc927d634d16fb8eb", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -47,7 +47,4 @@ mod borrowck;\n \n pub mod graphviz;\n \n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "cae0c7c7f5792ac8322ea88104d9b68544700318", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -3723,7 +3723,4 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     }\n }\n \n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "bd16e018bc465462acd42e6dc73ccd7e230441d8", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -1005,8 +1005,8 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n }\n \n unsafe fn configure_llvm(sess: &Session) {\n-    use std::sync::{Once, ONCE_INIT};\n-    static INIT: Once = ONCE_INIT;\n+    use std::sync::Once;\n+    static INIT: Once = Once::new();\n \n     // Copy what clang does by turning on loop vectorization at O2 and\n     // slp vectorization at O3"}, {"sha": "8866e7ff19dccd3247651816d5c2c9ba06b7d11d", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -39,6 +39,7 @@\n #![feature(path_ext)]\n #![feature(fs)]\n #![feature(path_relative_from)]\n+#![feature(std_misc)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "c3f614c8cc06ac3e34472f9a56eb8d4e20926ca2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -2653,8 +2653,8 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n-        use std::sync::{Once, ONCE_INIT};\n-        static INIT: Once = ONCE_INIT;\n+        use std::sync::Once;\n+        static INIT: Once = Once::new();\n         static mut POISONED: bool = false;\n         INIT.call_once(|| {\n             if llvm::LLVMStartMultithreaded() != 1 {"}, {"sha": "ed398c2cdedfc79f0d035e8f080b35e30e528fcd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -344,7 +344,4 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     tcx.sess.abort_if_errors();\n }\n \n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "ebdc049bc7f5daffec0a94874e201c69e92cd381", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -211,8 +211,8 @@ mod dl {\n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n         F: FnOnce() -> T,\n     {\n-        use sync::{StaticMutex, MUTEX_INIT};\n-        static LOCK: StaticMutex = MUTEX_INIT;\n+        use sync::StaticMutex;\n+        static LOCK: StaticMutex = StaticMutex::new();\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence"}, {"sha": "0b9c659ea2e5bbe13c605aaccb507713c63b7f70", "filename": "src/libstd/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -23,8 +23,8 @@ use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n-use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::atomic::{AtomicIsize, Ordering};\n+use sync::StaticMutex;\n use sys::os as os_imp;\n \n /// Returns the current working directory as a `PathBuf`.\n@@ -70,7 +70,7 @@ pub fn set_current_dir<P: AsRef<Path>>(p: P) -> io::Result<()> {\n     os_imp::chdir(p.as_ref())\n }\n \n-static ENV_LOCK: StaticMutex = MUTEX_INIT;\n+static ENV_LOCK: StaticMutex = StaticMutex::new();\n \n /// An iterator over a snapshot of the environment variables of this process.\n ///\n@@ -475,7 +475,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     os_imp::current_exe()\n }\n \n-static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n+static EXIT_STATUS: AtomicIsize = AtomicIsize::new(0);\n \n /// Sets the process exit code\n ///"}, {"sha": "d398cb88af458a156760df6fd676f76f4dde7c3c", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -11,31 +11,31 @@\n use prelude::v1::*;\n \n use boxed;\n-use cell::UnsafeCell;\n+use cell::Cell;\n use rt;\n use sync::{StaticMutex, Arc};\n \n pub struct Lazy<T> {\n-    pub lock: StaticMutex,\n-    pub ptr: UnsafeCell<*mut Arc<T>>,\n-    pub init: fn() -> Arc<T>,\n+    lock: StaticMutex,\n+    ptr: Cell<*mut Arc<T>>,\n+    init: fn() -> Arc<T>,\n }\n \n unsafe impl<T> Sync for Lazy<T> {}\n \n-macro_rules! lazy_init {\n-    ($init:expr) => (::io::lazy::Lazy {\n-        lock: ::sync::MUTEX_INIT,\n-        ptr: ::cell::UnsafeCell { value: 0 as *mut _ },\n-        init: $init,\n-    })\n-}\n-\n impl<T: Send + Sync + 'static> Lazy<T> {\n+    pub const fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n+        Lazy {\n+            lock: StaticMutex::new(),\n+            ptr: Cell::new(0 as *mut _),\n+            init: init\n+        }\n+    }\n+\n     pub fn get(&'static self) -> Option<Arc<T>> {\n         let _g = self.lock.lock();\n+        let ptr = self.ptr.get();\n         unsafe {\n-            let ptr = *self.ptr.get();\n             if ptr.is_null() {\n                 Some(self.init())\n             } else if ptr as usize == 1 {\n@@ -53,14 +53,14 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         // `Arc`.\n         let registered = rt::at_exit(move || {\n             let g = self.lock.lock();\n-            let ptr = *self.ptr.get();\n-            *self.ptr.get() = 1 as *mut _;\n+            let ptr = self.ptr.get();\n+            self.ptr.set(1 as *mut _);\n             drop(g);\n             drop(Box::from_raw(ptr))\n         });\n         let ret = (self.init)();\n         if registered.is_ok() {\n-            *self.ptr.get() = boxed::into_raw(Box::new(ret.clone()));\n+            self.ptr.set(boxed::into_raw(Box::new(ret.clone())));\n         }\n         return ret\n     }"}, {"sha": "c664def304e09e55c7847874184d589f86ea8a31", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -36,13 +36,12 @@ pub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n #[doc(no_inline, hidden)]\n pub use self::stdio::{set_panic, set_print};\n \n-#[macro_use] mod lazy;\n-\n pub mod prelude;\n mod buffered;\n mod cursor;\n mod error;\n mod impls;\n+mod lazy;\n mod util;\n mod stdio;\n "}, {"sha": "9885ccfaae0850f2ac92db487b8977bac613e080", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -122,7 +122,7 @@ pub struct StdinLock<'a> {\n /// locked version, `StdinLock`, implements both `Read` and `BufRead`, however.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = lazy_init!(stdin_init);\n+    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = Lazy::new(stdin_init);\n     return Stdin {\n         inner: INSTANCE.get().expect(\"cannot access stdin during shutdown\"),\n     };\n@@ -236,7 +236,7 @@ pub struct StdoutLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = lazy_init!(stdout_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Lazy::new(stdout_init);\n     return Stdout {\n         inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n     };\n@@ -308,7 +308,7 @@ pub struct StderrLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<StderrRaw>>> = lazy_init!(stderr_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<StderrRaw>>> = Lazy::new(stderr_init);\n     return Stderr {\n         inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n     };"}, {"sha": "8305088057c41ed654338a4a0418d9d01ced1bc6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -109,6 +109,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(const_fn)]\n #![feature(into_cow)]\n #![feature(lang_items)]\n #![feature(libc)]"}, {"sha": "c6d839d55a865d97c8e45285d4b263b1cc0564f0", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -12,9 +12,9 @@ use prelude::v1::*;\n \n use env;\n use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n-use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use sync::atomic::{AtomicUsize, Ordering};\n \n-static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n+static PORT: AtomicUsize = AtomicUsize::new(0);\n \n pub fn next_test_ip4() -> SocketAddr {\n     let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();"}, {"sha": "a2e6915a6a6f7db90769bf238cc0d8b7559ee2ee", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -96,11 +96,11 @@ mod imp {\n                   target_arch = \"aarch64\",\n                   target_arch = \"powerpc\")))]\n     fn is_getrandom_available() -> bool {\n-        use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n-        use sync::{Once, ONCE_INIT};\n+        use sync::atomic::{AtomicBool, Ordering};\n+        use sync::Once;\n \n-        static CHECKER: Once = ONCE_INIT;\n-        static AVAILABLE: AtomicBool = ATOMIC_BOOL_INIT;\n+        static CHECKER: Once = Once::new();\n+        static AVAILABLE: AtomicBool = AtomicBool::new(false);\n \n         CHECKER.call_once(|| {\n             let mut buf: [u8; 0] = [];"}, {"sha": "d23a124a6ecda21ddc572d19f8dc37aa7f9dd2e2", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -52,10 +52,10 @@ mod imp {\n     use mem;\n     use ffi::CStr;\n \n-    use sync::{StaticMutex, MUTEX_INIT};\n+    use sync::StaticMutex;\n \n     static mut GLOBAL_ARGS_PTR: usize = 0;\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);"}, {"sha": "19a17be4ccf495b02dd58df5a46f7c4d65d59912", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -20,15 +20,15 @@ use boxed;\n use boxed::Box;\n use vec::Vec;\n use thunk::Thunk;\n-use sys_common::mutex::{Mutex, MUTEX_INIT};\n+use sys_common::mutex::Mutex;\n \n type Queue = Vec<Thunk<'static>>;\n \n // NB these are specifically not types from `std::sync` as they currently rely\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n-static LOCK: Mutex = MUTEX_INIT;\n+static LOCK: Mutex = Mutex::new();\n static mut QUEUE: *mut Queue = 0 as *mut Queue;\n \n // The maximum number of times the cleanup routines will be run. While running"}, {"sha": "2eadf36a6b4f0424abc762efff0c632bf8092dc1", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -22,7 +22,7 @@ pub use sys::backtrace::write;\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n-    static ENABLED: atomic::AtomicIsize = atomic::ATOMIC_ISIZE_INIT;\n+    static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n     match ENABLED.load(Ordering::SeqCst) {\n         1 => return false,\n         2 => return true,"}, {"sha": "c403976745aa4769af0e9ad3730d0714ab572a10", "filename": "src/libstd/rt/unwind/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fmod.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -72,7 +72,7 @@ use intrinsics;\n use libc::c_void;\n use mem;\n use sync::atomic::{self, Ordering};\n-use sys_common::mutex::{Mutex, MUTEX_INIT};\n+use sys_common::mutex::Mutex;\n \n // The actual unwinding implementation is cfg'd here, and we've got two current\n // implementations. One goes through SEH on Windows and the other goes through\n@@ -89,15 +89,15 @@ pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);\n // For more information, see below.\n const MAX_CALLBACKS: usize = 16;\n static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n-        [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT];\n-static CALLBACK_CNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+        [atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0)];\n+static CALLBACK_CNT: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n@@ -243,7 +243,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n     // `std::sync` one as accessing TLS can cause weird recursive problems (and\n     // we don't need poison checking).\n     unsafe {\n-        static LOCK: Mutex = MUTEX_INIT;\n+        static LOCK: Mutex = Mutex::new();\n         static mut INIT: bool = false;\n         LOCK.lock();\n         if !INIT {"}, {"sha": "b53219db245fc18a40dd801a0323ecc2dba9ab47", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -42,7 +42,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n }\n \n pub fn min_stack() -> usize {\n-    static MIN: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+    static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n     match MIN.load(Ordering::SeqCst) {\n         0 => {}\n         n => return n - 1,"}, {"sha": "f2c389f9426ebe3a273e6ac8bb4ff963aabc1d12", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::v1::*;\n \n-use sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n+use sync::atomic::{AtomicUsize, Ordering};\n use sync::{mutex, MutexGuard, PoisonError};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n@@ -84,10 +84,7 @@ pub struct StaticCondvar {\n /// Constant initializer for a statically allocated condition variable.\n #[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\")]\n-pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n-    inner: sys::CONDVAR_INIT,\n-    mutex: ATOMIC_USIZE_INIT,\n-};\n+pub const CONDVAR_INIT: StaticCondvar = StaticCondvar::new();\n \n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n@@ -96,7 +93,7 @@ impl Condvar {\n     pub fn new() -> Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n-                inner: unsafe { sys::Condvar::new() },\n+                inner: sys::Condvar::new(),\n                 mutex: AtomicUsize::new(0),\n             }\n         }\n@@ -234,6 +231,16 @@ impl Drop for Condvar {\n }\n \n impl StaticCondvar {\n+    /// Creates a new condition variable\n+    #[unstable(feature = \"static_condvar\",\n+               reason = \"may be merged with Condvar in the future\")]\n+    pub const fn new() -> StaticCondvar {\n+        StaticCondvar {\n+            inner: sys::Condvar::new(),\n+            mutex: AtomicUsize::new(0),\n+        }\n+    }\n+\n     /// Blocks the current thread until this condition variable receives a\n     /// notification.\n     ///\n@@ -388,10 +395,10 @@ impl StaticCondvar {\n mod tests {\n     use prelude::v1::*;\n \n-    use super::{StaticCondvar, CONDVAR_INIT};\n+    use super::StaticCondvar;\n     use sync::mpsc::channel;\n-    use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n-    use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use sync::{StaticMutex, Condvar, Mutex, Arc};\n+    use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n     use time::Duration;\n     use u32;\n@@ -405,16 +412,16 @@ mod tests {\n \n     #[test]\n     fn static_smoke() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n         C.notify_one();\n         C.notify_all();\n         unsafe { C.destroy(); }\n     }\n \n     #[test]\n     fn notify_one() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n-        static M: StaticMutex = MUTEX_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n+        static M: StaticMutex = StaticMutex::new();\n \n         let g = M.lock().unwrap();\n         let _t = thread::spawn(move|| {\n@@ -464,8 +471,8 @@ mod tests {\n \n     #[test]\n     fn wait_timeout_ms() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n-        static M: StaticMutex = MUTEX_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n+        static M: StaticMutex = StaticMutex::new();\n \n         let g = M.lock().unwrap();\n         let (g, _no_timeout) = C.wait_timeout_ms(g, 1).unwrap();\n@@ -483,9 +490,9 @@ mod tests {\n \n     #[test]\n     fn wait_timeout_with() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n-        static M: StaticMutex = MUTEX_INIT;\n-        static S: AtomicUsize = ATOMIC_USIZE_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n+        static M: StaticMutex = StaticMutex::new();\n+        static S: AtomicUsize = AtomicUsize::new(0);\n \n         let g = M.lock().unwrap();\n         let (g, success) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n@@ -530,9 +537,9 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn two_mutexes() {\n-        static M1: StaticMutex = MUTEX_INIT;\n-        static M2: StaticMutex = MUTEX_INIT;\n-        static C: StaticCondvar = CONDVAR_INIT;\n+        static M1: StaticMutex = StaticMutex::new();\n+        static M2: StaticMutex = StaticMutex::new();\n+        static C: StaticCondvar = StaticCondvar::new();\n \n         let mut g = M1.lock().unwrap();\n         let _t = thread::spawn(move|| {"}, {"sha": "0e5a98591168b5d6864a092f6a3b0a55d9ce5c6a", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -11,7 +11,7 @@\n //! Generic support for building blocking abstractions.\n \n use thread::{self, Thread};\n-use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n+use sync::atomic::{AtomicBool, Ordering};\n use sync::Arc;\n use marker::{Sync, Send};\n use mem;\n@@ -41,7 +41,7 @@ impl !Sync for WaitToken {}\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: thread::current(),\n-        woken: ATOMIC_BOOL_INIT,\n+        woken: AtomicBool::new(false),\n     });\n     let wait_token = WaitToken {\n         inner: inner.clone(),"}, {"sha": "fd22d723ebdb1c371403126520ad5f8f67fd393b", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -178,17 +178,14 @@ impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n /// other mutex constants.\n #[unstable(feature = \"std_misc\",\n            reason = \"may be merged with Mutex in the future\")]\n-pub const MUTEX_INIT: StaticMutex = StaticMutex {\n-    lock: sys::MUTEX_INIT,\n-    poison: poison::FLAG_INIT,\n-};\n+pub const MUTEX_INIT: StaticMutex = StaticMutex::new();\n \n impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n-            inner: box MUTEX_INIT,\n+            inner: box StaticMutex::new(),\n             data: UnsafeCell::new(t),\n         }\n     }\n@@ -271,9 +268,19 @@ impl<T: ?Sized + fmt::Debug + 'static> fmt::Debug for Mutex<T> {\n \n struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n+static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n \n impl StaticMutex {\n+    /// Creates a new mutex in an unlocked state ready for use.\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Mutex in the future\")]\n+    pub const fn new() -> StaticMutex {\n+        StaticMutex {\n+            lock: sys::Mutex::new(),\n+            poison: poison::Flag::new(),\n+        }\n+    }\n+\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n     #[unstable(feature = \"std_misc\",\n@@ -365,7 +372,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n+    use sync::{Arc, Mutex, StaticMutex, Condvar};\n     use thread;\n \n     struct Packet<T: Send>(Arc<(Mutex<T>, Condvar)>);\n@@ -382,7 +389,7 @@ mod tests {\n \n     #[test]\n     fn smoke_static() {\n-        static M: StaticMutex = MUTEX_INIT;\n+        static M: StaticMutex = StaticMutex::new();\n         unsafe {\n             drop(M.lock().unwrap());\n             drop(M.lock().unwrap());\n@@ -392,7 +399,7 @@ mod tests {\n \n     #[test]\n     fn lots_and_lots() {\n-        static M: StaticMutex = MUTEX_INIT;\n+        static M: StaticMutex = StaticMutex::new();\n         static mut CNT: u32 = 0;\n         const J: u32 = 1000;\n         const K: u32 = 3;"}, {"sha": "269affff20855ba52bfd130495d48d31f4341453", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -16,8 +16,8 @@\n use prelude::v1::*;\n \n use isize;\n-use sync::atomic::{AtomicIsize, Ordering, ATOMIC_ISIZE_INIT};\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::atomic::{AtomicIsize, Ordering};\n+use sync::StaticMutex;\n \n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n@@ -44,13 +44,19 @@ pub struct Once {\n \n /// Initialization value for static `Once` values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ONCE_INIT: Once = Once {\n-    mutex: MUTEX_INIT,\n-    cnt: ATOMIC_ISIZE_INIT,\n-    lock_cnt: ATOMIC_ISIZE_INIT,\n-};\n+pub const ONCE_INIT: Once = Once::new();\n \n impl Once {\n+    /// Creates a new `Once` value.\n+    #[unstable(feature = \"std_misc\")]\n+    pub const fn new() -> Once {\n+        Once {\n+            mutex: StaticMutex::new(),\n+            cnt: AtomicIsize::new(0),\n+            lock_cnt: AtomicIsize::new(0),\n+        }\n+    }\n+\n     /// Performs an initialization routine once and only once. The given closure\n     /// will be executed if this is the first time `call_once` has been called,\n     /// and otherwise the routine will *not* be invoked.\n@@ -129,12 +135,12 @@ mod tests {\n     use prelude::v1::*;\n \n     use thread;\n-    use super::{ONCE_INIT, Once};\n+    use super::Once;\n     use sync::mpsc::channel;\n \n     #[test]\n     fn smoke_once() {\n-        static O: Once = ONCE_INIT;\n+        static O: Once = Once::new();\n         let mut a = 0;\n         O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n@@ -144,7 +150,7 @@ mod tests {\n \n     #[test]\n     fn stampede_once() {\n-        static O: Once = ONCE_INIT;\n+        static O: Once = Once::new();\n         static mut run: bool = false;\n \n         let (tx, rx) = channel();"}, {"sha": "e7c3d744c179ab0fdb1096f283bc73f8434518d5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -102,10 +102,7 @@ pub struct StaticRwLock {\n /// Constant initialization for a statically-initialized rwlock.\n #[unstable(feature = \"std_misc\",\n            reason = \"may be merged with RwLock in the future\")]\n-pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n-    lock: sys::RWLOCK_INIT,\n-    poison: poison::FLAG_INIT,\n-};\n+pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n \n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n@@ -142,7 +139,7 @@ impl<T> RwLock<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n-        RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n+        RwLock { inner: box StaticRwLock::new(), data: UnsafeCell::new(t) }\n     }\n }\n \n@@ -280,9 +277,19 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n \n struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n+static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n \n impl StaticRwLock {\n+    /// Creates a new rwlock.\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with RwLock in the future\")]\n+    pub const fn new() -> StaticRwLock {\n+        StaticRwLock {\n+            lock: sys::RWLock::new(),\n+            poison: poison::Flag::new(),\n+        }\n+    }\n+\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n@@ -420,7 +427,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, TryLockError, RW_LOCK_INIT};\n+    use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n \n     #[test]\n     fn smoke() {\n@@ -433,7 +440,7 @@ mod tests {\n \n     #[test]\n     fn static_smoke() {\n-        static R: StaticRwLock = RW_LOCK_INIT;\n+        static R: StaticRwLock = StaticRwLock::new();\n         drop(R.read().unwrap());\n         drop(R.write().unwrap());\n         drop((R.read().unwrap(), R.read().unwrap()));\n@@ -443,7 +450,7 @@ mod tests {\n \n     #[test]\n     fn frob() {\n-        static R: StaticRwLock = RW_LOCK_INIT;\n+        static R: StaticRwLock = StaticRwLock::new();\n         const N: usize = 10;\n         const M: usize = 1000;\n "}, {"sha": "33734a88cf32b18467beae65149f94a01b6fc3b9", "filename": "src/libstd/sys/common/condvar.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -20,16 +20,12 @@ use sys::condvar as imp;\n /// this type.\n pub struct Condvar(imp::Condvar);\n \n-/// Static initializer for condition variables.\n-pub const CONDVAR_INIT: Condvar = Condvar(imp::CONDVAR_INIT);\n-\n impl Condvar {\n     /// Creates a new condition variable for use.\n     ///\n     /// Behavior is undefined if the condition variable is moved after it is\n     /// first used with any of the functions below.\n-    #[inline]\n-    pub unsafe fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n+    pub const fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n \n     /// Signals one waiter on this condition variable to wake up.\n     #[inline]"}, {"sha": "5a6dfe7fb1a1507739b6b47447490ec60d426b92", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -20,10 +20,13 @@ pub struct Mutex(imp::Mutex);\n \n unsafe impl Sync for Mutex {}\n \n-/// Constant initializer for statically allocated mutexes.\n-pub const MUTEX_INIT: Mutex = Mutex(imp::MUTEX_INIT);\n-\n impl Mutex {\n+    /// Creates a new mutex for use.\n+    ///\n+    /// Behavior is undefined if the mutex is moved after it is\n+    /// first used with any of the functions below.\n+    pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n+\n     /// Locks the mutex blocking the current thread until it is available.\n     ///\n     /// Behavior is undefined if the mutex has been moved between this and any"}, {"sha": "48c8198272588f8f1401252ac21b4731bb6d41fb", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -10,26 +10,28 @@\n \n use prelude::v1::*;\n \n-use marker::Reflect;\n-use cell::UnsafeCell;\n+use cell::Cell;\n use error::{Error};\n use fmt;\n+use marker::Reflect;\n use thread;\n \n-pub struct Flag { failed: UnsafeCell<bool> }\n+pub struct Flag { failed: Cell<bool> }\n \n // This flag is only ever accessed with a lock previously held. Note that this\n // a totally private structure.\n unsafe impl Send for Flag {}\n unsafe impl Sync for Flag {}\n \n-pub const FLAG_INIT: Flag = Flag { failed: UnsafeCell { value: false } };\n-\n impl Flag {\n+    pub const fn new() -> Flag {\n+        Flag { failed: Cell::new(false) }\n+    }\n+\n     #[inline]\n     pub fn borrow(&self) -> LockResult<Guard> {\n         let ret = Guard { panicking: thread::panicking() };\n-        if unsafe { *self.failed.get() } {\n+        if self.get() {\n             Err(PoisonError::new(ret))\n         } else {\n             Ok(ret)\n@@ -39,13 +41,13 @@ impl Flag {\n     #[inline]\n     pub fn done(&self, guard: &Guard) {\n         if !guard.panicking && thread::panicking() {\n-            unsafe { *self.failed.get() = true; }\n+            self.failed.set(true);\n         }\n     }\n \n     #[inline]\n     pub fn get(&self) -> bool {\n-        unsafe { *self.failed.get() }\n+        self.failed.get()\n     }\n }\n "}, {"sha": "72f8453233a4108ffffca4d6dfa0eb4b3bf754dc", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -54,7 +54,7 @@ impl<T> ReentrantMutex<T> {\n         unsafe {\n             let mut mutex = ReentrantMutex {\n                 inner: box sys::ReentrantMutex::uninitialized(),\n-                poison: poison::FLAG_INIT,\n+                poison: poison::Flag::new(),\n                 data: t,\n             };\n             mutex.inner.init();"}, {"sha": "71a4f01ec4cab9f2d3edcee78af3373f2484e24f", "filename": "src/libstd/sys/common/rwlock.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -17,10 +17,13 @@ use sys::rwlock as imp;\n /// safer types at the top level of this crate instead of this type.\n pub struct RWLock(imp::RWLock);\n \n-/// Constant initializer for static RWLocks.\n-pub const RWLOCK_INIT: RWLock = RWLock(imp::RWLOCK_INIT);\n-\n impl RWLock {\n+    /// Creates a new reader-writer lock for use.\n+    ///\n+    /// Behavior is undefined if the reader-writer lock is moved after it is\n+    /// first used with any of the functions below.\n+    pub const fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n+\n     /// Acquires shared access to the underlying lock, blocking the current\n     /// thread to do so.\n     ///"}, {"sha": "eb4cbfcfbcdda5a8c59b52c0604f95cc161b2a88", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -86,19 +86,13 @@ use sys::thread_local as imp;\n /// }\n /// ```\n pub struct StaticKey {\n-    /// Inner static TLS key (internals), created with by `INIT_INNER` in this\n-    /// module.\n-    pub inner: StaticKeyInner,\n+    /// Inner static TLS key (internals).\n+    key: AtomicUsize,\n     /// Destructor for the TLS value.\n     ///\n     /// See `Key::new` for information about when the destructor runs and how\n     /// it runs.\n-    pub dtor: Option<unsafe extern fn(*mut u8)>,\n-}\n-\n-/// Inner contents of `StaticKey`, created by the `INIT_INNER` constant.\n-pub struct StaticKeyInner {\n-    key: AtomicUsize,\n+    dtor: Option<unsafe extern fn(*mut u8)>,\n }\n \n /// A type for a safely managed OS-based TLS slot.\n@@ -129,19 +123,16 @@ pub struct Key {\n /// Constant initialization value for static TLS keys.\n ///\n /// This value specifies no destructor by default.\n-pub const INIT: StaticKey = StaticKey {\n-    inner: INIT_INNER,\n-    dtor: None,\n-};\n-\n-/// Constant initialization value for the inner part of static TLS keys.\n-///\n-/// This value allows specific configuration of the destructor for a TLS key.\n-pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n-    key: atomic::ATOMIC_USIZE_INIT,\n-};\n+pub const INIT: StaticKey = StaticKey::new(None);\n \n impl StaticKey {\n+    pub const fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> StaticKey {\n+        StaticKey {\n+            key: atomic::AtomicUsize::new(0),\n+            dtor: dtor\n+        }\n+    }\n+\n     /// Gets the value associated with this TLS key\n     ///\n     /// This will lazily allocate a TLS key from the OS if one has not already\n@@ -164,15 +155,15 @@ impl StaticKey {\n     /// Note that this does *not* run the user-provided destructor if one was\n     /// specified at definition time. Doing so must be done manually.\n     pub unsafe fn destroy(&self) {\n-        match self.inner.key.swap(0, Ordering::SeqCst) {\n+        match self.key.swap(0, Ordering::SeqCst) {\n             0 => {}\n             n => { imp::destroy(n as imp::Key) }\n         }\n     }\n \n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n-        match self.inner.key.load(Ordering::Relaxed) {\n+        match self.key.load(Ordering::Relaxed) {\n             0 => self.lazy_init() as imp::Key,\n             n => n as imp::Key\n         }\n@@ -197,7 +188,7 @@ impl StaticKey {\n             key2\n         };\n         assert!(key != 0);\n-        match self.inner.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n+        match self.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n             // The CAS succeeded, so we've created the actual key\n             0 => key as usize,\n             // If someone beat us to the punch, use their key instead\n@@ -245,7 +236,7 @@ impl Drop for Key {\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n-    use super::{Key, StaticKey, INIT_INNER};\n+    use super::{Key, StaticKey};\n \n     fn assert_sync<T: Sync>() {}\n     fn assert_send<T: Send>() {}\n@@ -267,8 +258,8 @@ mod tests {\n \n     #[test]\n     fn statik() {\n-        static K1: StaticKey = StaticKey { inner: INIT_INNER, dtor: None };\n-        static K2: StaticKey = StaticKey { inner: INIT_INNER, dtor: None };\n+        static K1: StaticKey = StaticKey::new(None);\n+        static K2: StaticKey = StaticKey::new(None);\n \n         unsafe {\n             assert!(K1.get().is_null());"}, {"sha": "b23a3eee1a1738e03e69f9706901a3d5e82b21fa", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -91,7 +91,7 @@ use io;\n use libc;\n use mem;\n use str;\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::StaticMutex;\n \n use sys_common::backtrace::*;\n \n@@ -117,7 +117,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     // while it doesn't requires lock for work as everything is\n     // local, it still displays much nicer backtraces when a\n     // couple of threads panic simultaneously\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n     try!(writeln!(w, \"stack backtrace:\"));\n@@ -148,7 +148,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     // is semi-reasonable in terms of printing anyway, and we know that all\n     // I/O done here is blocking I/O, not green I/O, so we don't have to\n     // worry about this being a native vs green mutex.\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n     try!(writeln!(w, \"stack backtrace:\"));"}, {"sha": "c8708190a2e18c6f6fef8b5f3a322508a15417b7", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -23,13 +23,8 @@ pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-pub const CONDVAR_INIT: Condvar = Condvar {\n-    inner: UnsafeCell { value: ffi::PTHREAD_COND_INITIALIZER },\n-};\n-\n impl Condvar {\n-    #[inline]\n-    pub unsafe fn new() -> Condvar {\n+    pub const fn new() -> Condvar {\n         // Might be moved and address is changing it is better to avoid\n         // initialization of potentially opaque OS data before it landed\n         Condvar { inner: UnsafeCell::new(ffi::PTHREAD_COND_INITIALIZER) }"}, {"sha": "6eed403dfc08071cdd70ed404154e6a873b372e6", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -21,20 +21,15 @@ pub unsafe fn raw(m: &Mutex) -> *mut ffi::pthread_mutex_t {\n     m.inner.get()\n }\n \n-pub const MUTEX_INIT: Mutex = Mutex {\n-    inner: UnsafeCell { value: ffi::PTHREAD_MUTEX_INITIALIZER },\n-};\n-\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n #[allow(dead_code)] // sys isn't exported yet\n impl Mutex {\n-    #[inline]\n-    pub unsafe fn new() -> Mutex {\n+    pub const fn new() -> Mutex {\n         // Might be moved and address is changing it is better to avoid\n         // initialization of potentially opaque OS data before it landed\n-        MUTEX_INIT\n+        Mutex { inner: UnsafeCell::new(ffi::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]\n     pub unsafe fn lock(&self) {"}, {"sha": "5178d7b8fb1a0ac962ddb058a68fb0b31ff65a20", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -216,8 +216,8 @@ pub fn current_exe() -> io::Result<PathBuf> {\n \n #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n-    use sync::{StaticMutex, MUTEX_INIT};\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    use sync::StaticMutex;\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     extern {\n         fn rust_current_exe() -> *const c_char;"}, {"sha": "ee687f350f02129c42988c775130d650cc997b37", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -16,14 +16,13 @@ use sys::sync as ffi;\n \n pub struct RWLock { inner: UnsafeCell<ffi::pthread_rwlock_t> }\n \n-pub const RWLOCK_INIT: RWLock = RWLock {\n-    inner: UnsafeCell { value: ffi::PTHREAD_RWLOCK_INITIALIZER },\n-};\n-\n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock { inner: UnsafeCell::new(ffi::PTHREAD_RWLOCK_INITIALIZER) }\n+    }\n     #[inline]\n     pub unsafe fn read(&self) {\n         let r = ffi::pthread_rwlock_rdlock(self.inner.get());"}, {"sha": "bb0e12e8df89944afeca8653820c5e4c661c9905", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -330,10 +330,10 @@ pub mod guard {\n #[cfg(target_os = \"linux\")]\n fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n     use dynamic_lib::DynamicLibrary;\n-    use sync::{Once, ONCE_INIT};\n+    use sync::Once;\n \n     type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n-    static INIT: Once = ONCE_INIT;\n+    static INIT: Once = Once::new();\n     static mut __pthread_get_minstack: Option<F> = None;\n \n     INIT.call_once(|| {"}, {"sha": "3afe84b25804c3c5d11836da16d80052984b7ec0", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(dead_code)] // sys isn't exported yet\n+\n use prelude::v1::*;\n use libc::c_int;\n "}, {"sha": "6b84baeca7dc9d6a2d0f298c253f53d196de2a62", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -17,7 +17,7 @@ mod inner {\n     use libc;\n     use time::Duration;\n     use ops::Sub;\n-    use sync::{Once, ONCE_INIT};\n+    use sync::Once;\n     use super::NSEC_PER_SEC;\n \n     pub struct SteadyTime {\n@@ -42,7 +42,7 @@ mod inner {\n             numer: 0,\n             denom: 0,\n         };\n-        static ONCE: Once = ONCE_INIT;\n+        static ONCE: Once = Once::new();\n \n         unsafe {\n             ONCE.call_once(|| {"}, {"sha": "3f595762fc71b58b0149f4fdf27461daf1fccd46", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -36,7 +36,7 @@ use mem;\n use path::Path;\n use ptr;\n use str;\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::StaticMutex;\n \n use sys_common::backtrace::*;\n \n@@ -295,7 +295,7 @@ impl Drop for Cleanup {\n pub fn write(w: &mut Write) -> io::Result<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n     // Open up dbghelp.dll, we don't link to it explicitly because it can't"}, {"sha": "3c9b2ef1b986ecbef40a4201ed11c51771b410aa", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -340,10 +340,10 @@ pub mod compat {\n                                       -> $rettype:ty { $fallback:expr }) => (\n             #[inline(always)]\n             pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+                use sync::atomic::{AtomicUsize, Ordering};\n                 use mem;\n \n-                static PTR: AtomicUsize = ATOMIC_USIZE_INIT;\n+                static PTR: AtomicUsize = AtomicUsize::new(0);\n \n                 fn load() -> usize {\n                     ::sys::c::compat::store_func(&PTR,"}, {"sha": "baa7d1ceea3316d41923f13ec0fafee8a5dbd6cc", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -22,13 +22,10 @@ pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-pub const CONDVAR_INIT: Condvar = Condvar {\n-    inner: UnsafeCell { value: ffi::CONDITION_VARIABLE_INIT }\n-};\n-\n impl Condvar {\n-    #[inline]\n-    pub unsafe fn new() -> Condvar { CONDVAR_INIT }\n+    pub const fn new() -> Condvar {\n+        Condvar { inner: UnsafeCell::new(ffi::CONDITION_VARIABLE_INIT) }\n+    }\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {"}, {"sha": "29e370698ad744b727f4c202c5d333a9ee6ea193", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -16,10 +16,6 @@ use mem;\n \n pub struct Mutex { inner: UnsafeCell<ffi::SRWLOCK> }\n \n-pub const MUTEX_INIT: Mutex = Mutex {\n-    inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n-};\n-\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n@@ -41,6 +37,9 @@ pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n //    is there there are no guarantees of fairness.\n \n impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+    }\n     #[inline]\n     pub unsafe fn lock(&self) {\n         ffi::AcquireSRWLockExclusive(self.inner.get())"}, {"sha": "71e064bcc6b82e971a556529f2260eb8fe4e7bb7", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -18,7 +18,7 @@ use net::SocketAddr;\n use num::One;\n use ops::Neg;\n use rt;\n-use sync::{Once, ONCE_INIT};\n+use sync::Once;\n use sys::c;\n use sys_common::{AsInner, FromInner};\n \n@@ -29,7 +29,7 @@ pub struct Socket(libc::SOCKET);\n /// Checks whether the Windows socket interface has been started already, and\n /// if not, starts it.\n pub fn init() {\n-    static START: Once = ONCE_INIT;\n+    static START: Once = Once::new();\n \n     START.call_once(|| unsafe {\n         let mut data: c::WSADATA = mem::zeroed();"}, {"sha": "178b6ea42d2bb20f6900b854e59c2c89ede8af8d", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -24,7 +24,7 @@ use mem;\n use os::windows::ffi::OsStrExt;\n use path::Path;\n use ptr;\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::StaticMutex;\n use sys::c;\n use sys::fs::{OpenOptions, File};\n use sys::handle::Handle;\n@@ -169,7 +169,7 @@ impl Process {\n         try!(unsafe {\n             // `CreateProcess` is racy!\n             // http://support.microsoft.com/kb/315939\n-            static CREATE_PROCESS_LOCK: StaticMutex = MUTEX_INIT;\n+            static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n             let _lock = CREATE_PROCESS_LOCK.lock();\n \n             cvt(CreateProcessW(ptr::null(),"}, {"sha": "e727638e3e9b5cddf67a2dfd14792649627a1080", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -15,14 +15,13 @@ use sys::sync as ffi;\n \n pub struct RWLock { inner: UnsafeCell<ffi::SRWLOCK> }\n \n-pub const RWLOCK_INIT: RWLock = RWLock {\n-    inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n-};\n-\n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+    }\n     #[inline]\n     pub unsafe fn read(&self) {\n         ffi::AcquireSRWLockShared(self.inner.get())"}, {"sha": "a3d522d1757a97fa11d5280dc053b4e00c5ce947", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -15,7 +15,7 @@ use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n use boxed;\n use ptr;\n use rt;\n-use sys_common::mutex::{MUTEX_INIT, Mutex};\n+use sys_common::mutex::Mutex;\n \n pub type Key = DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -58,7 +58,7 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n-static DTOR_LOCK: Mutex = MUTEX_INIT;\n+static DTOR_LOCK: Mutex = Mutex::new();\n static mut DTORS: *mut Vec<(Key, Dtor)> = 0 as *mut _;\n \n // -------------------------------------------------------------------------"}, {"sha": "f5a70ccc90743a34ba1be9cc27b17b498c78d7b9", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -10,7 +10,7 @@\n use libc;\n use ops::Sub;\n use time::Duration;\n-use sync::{Once, ONCE_INIT};\n+use sync::Once;\n \n const NANOS_PER_SEC: u64 = 1_000_000_000;\n \n@@ -28,7 +28,7 @@ impl SteadyTime {\n \n fn frequency() -> libc::LARGE_INTEGER {\n     static mut FREQUENCY: libc::LARGE_INTEGER = 0;\n-    static ONCE: Once = ONCE_INIT;\n+    static ONCE: Once = Once::new();\n \n     unsafe {\n         ONCE.call_once(|| {"}, {"sha": "0eafd4d5f12e952817ea91c94b48c762a7b3fd1d", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 87, "deletions": 159, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -18,12 +18,7 @@ use cell::UnsafeCell;\n \n // Sure wish we had macro hygiene, no?\n #[doc(hidden)]\n-pub mod __impl {\n-    pub use super::imp::Key as KeyInner;\n-    pub use super::imp::destroy_value;\n-    pub use sys_common::thread_local::INIT_INNER as OS_INIT_INNER;\n-    pub use sys_common::thread_local::StaticKey as OsStaticKey;\n-}\n+pub use self::imp::Key as __KeyInner;\n \n /// A thread local storage key which owns its contents.\n ///\n@@ -76,55 +71,10 @@ pub struct LocalKey<T> {\n     //\n     // This is trivially devirtualizable by LLVM because we never store anything\n     // to this field and rustc can declare the `static` as constant as well.\n-    #[doc(hidden)]\n-    pub inner: fn() -> &'static __impl::KeyInner<UnsafeCell<Option<T>>>,\n+    inner: fn() -> &'static __KeyInner<T>,\n \n     // initialization routine to invoke to create a value\n-    #[doc(hidden)]\n-    pub init: fn() -> T,\n-}\n-\n-/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n-///\n-/// See [LocalKey documentation](thread/struct.LocalKey.html) for more information.\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n-macro_rules! thread_local {\n-    (static $name:ident: $t:ty = $init:expr) => (\n-        static $name: ::std::thread::LocalKey<$t> = {\n-            use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread::__local::KeyInner as __KeyInner;\n-            use std::option::Option as __Option;\n-            use std::option::Option::None as __None;\n-\n-            __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n-                __UnsafeCell { value: __None }\n-            });\n-            fn __init() -> $t { $init }\n-            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n-                &__KEY\n-            }\n-            ::std::thread::LocalKey { inner: __getit, init: __init }\n-        };\n-    );\n-    (pub static $name:ident: $t:ty = $init:expr) => (\n-        pub static $name: ::std::thread::LocalKey<$t> = {\n-            use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread::__local::KeyInner as __KeyInner;\n-            use std::option::Option as __Option;\n-            use std::option::Option::None as __None;\n-\n-            __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n-                __UnsafeCell { value: __None }\n-            });\n-            fn __init() -> $t { $init }\n-            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n-                &__KEY\n-            }\n-            ::std::thread::LocalKey { inner: __getit, init: __init }\n-        };\n-    );\n+    init: fn() -> T,\n }\n \n // Macro pain #4586:\n@@ -147,50 +97,37 @@ macro_rules! thread_local {\n // To get around this, we're forced to inject the #[cfg] logic into the macro\n // itself. Woohoo.\n \n+/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n+///\n+/// See [LocalKey documentation](thread/struct.LocalKey.html) for more information.\n #[macro_export]\n-#[doc(hidden)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-macro_rules! __thread_local_inner {\n+macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n-        #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                       not(target_arch = \"aarch64\")),\n-                   thread_local)]\n-        static $name: ::std::thread::__local::KeyInner<$t> =\n-            __thread_local_inner!($init, $t);\n+        static $name: ::std::thread::LocalKey<$t> = {\n+            #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n+                           not(target_arch = \"aarch64\")),\n+                       thread_local)]\n+            static __KEY: ::std::thread::__LocalKeyInner<$t> =\n+                ::std::thread::__LocalKeyInner::new();\n+            fn __init() -> $t { $init }\n+            fn __getit() -> &'static ::std::thread::__LocalKeyInner<$t> { &__KEY }\n+            ::std::thread::LocalKey::new(__getit, __init)\n+        };\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n-        #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                       not(target_arch = \"aarch64\")),\n-                   thread_local)]\n-        pub static $name: ::std::thread::__local::KeyInner<$t> =\n-            __thread_local_inner!($init, $t);\n-    );\n-    ($init:expr, $t:ty) => ({\n-        #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]\n-        const _INIT: ::std::thread::__local::KeyInner<$t> = {\n-            ::std::thread::__local::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: $init },\n-                dtor_registered: ::std::cell::UnsafeCell { value: false },\n-                dtor_running: ::std::cell::UnsafeCell { value: false },\n-            }\n-        };\n-\n-        #[allow(trivial_casts)]\n-        #[cfg(any(not(any(target_os = \"macos\", target_os = \"linux\")), target_arch = \"aarch64\"))]\n-        const _INIT: ::std::thread::__local::KeyInner<$t> = {\n-            ::std::thread::__local::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread::__local::OsStaticKey {\n-                    inner: ::std::thread::__local::OS_INIT_INNER,\n-                    dtor: ::std::option::Option::Some(\n-                        ::std::thread::__local::destroy_value::<$t>\n-                    ),\n-                },\n-            }\n+        pub static $name: ::std::thread::LocalKey<$t> = {\n+            #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n+                           not(target_arch = \"aarch64\")),\n+                       thread_local)]\n+            static __KEY: ::std::thread::__LocalKeyInner<$t> =\n+                ::std::thread::__LocalKeyInner::new();\n+            fn __init() -> $t { $init }\n+            fn __getit() -> &'static ::std::thread::__LocalKeyInner<$t> { &__KEY }\n+            ::std::thread::LocalKey::new(__getit, __init)\n         };\n-\n-        _INIT\n-    });\n+    );\n }\n \n /// Indicator of the state of a thread local storage key.\n@@ -225,6 +162,14 @@ pub enum LocalKeyState {\n }\n \n impl<T: 'static> LocalKey<T> {\n+    #[doc(hidden)]\n+    pub const fn new(inner: fn() -> &'static __KeyInner<T>, init: fn() -> T) -> LocalKey<T> {\n+        LocalKey {\n+            inner: inner,\n+            init: init\n+        }\n+    }\n+\n     /// Acquires a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n@@ -300,44 +245,45 @@ impl<T: 'static> LocalKey<T> {\n mod imp {\n     use prelude::v1::*;\n \n-    use cell::UnsafeCell;\n+    use cell::{Cell, UnsafeCell};\n     use intrinsics;\n-    use ptr;\n \n     pub struct Key<T> {\n-        // Place the inner bits in an `UnsafeCell` to currently get around the\n-        // \"only Sync statics\" restriction. This allows any type to be placed in\n-        // the cell.\n-        //\n-        // Note that all access requires `T: 'static` so it can't be a type with\n-        // any borrowed pointers still.\n-        pub inner: UnsafeCell<T>,\n+        inner: UnsafeCell<Option<T>>,\n \n         // Metadata to keep track of the state of the destructor. Remember that\n         // these variables are thread-local, not global.\n-        pub dtor_registered: UnsafeCell<bool>, // should be Cell\n-        pub dtor_running: UnsafeCell<bool>, // should be Cell\n+        dtor_registered: Cell<bool>,\n+        dtor_running: Cell<bool>,\n     }\n \n     unsafe impl<T> ::marker::Sync for Key<T> { }\n \n     impl<T> Key<T> {\n-        pub unsafe fn get(&'static self) -> Option<&'static T> {\n-            if intrinsics::needs_drop::<T>() && *self.dtor_running.get() {\n+        pub const fn new() -> Key<T> {\n+            Key {\n+                inner: UnsafeCell::new(None),\n+                dtor_registered: Cell::new(false),\n+                dtor_running: Cell::new(false)\n+            }\n+        }\n+\n+        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+            if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n                 return None\n             }\n             self.register_dtor();\n-            Some(&*self.inner.get())\n+            Some(&self.inner)\n         }\n \n         unsafe fn register_dtor(&self) {\n-            if !intrinsics::needs_drop::<T>() || *self.dtor_registered.get() {\n+            if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n                 return\n             }\n \n             register_dtor(self as *const _ as *mut u8,\n                           destroy_value::<T>);\n-            *self.dtor_registered.get() = true;\n+            self.dtor_registered.set(true);\n         }\n     }\n \n@@ -354,6 +300,7 @@ mod imp {\n     unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         use boxed;\n         use mem;\n+        use ptr;\n         use libc;\n         use sys_common::thread_local as os;\n \n@@ -381,10 +328,7 @@ mod imp {\n         // *should* be the case that this loop always terminates because we\n         // provide the guarantee that a TLS key cannot be set after it is\n         // flagged for destruction.\n-        static DTORS: os::StaticKey = os::StaticKey {\n-            inner: os::INIT_INNER,\n-            dtor: Some(run_dtors as unsafe extern \"C\" fn(*mut u8)),\n-        };\n+        static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n         type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n         if DTORS.get().is_null() {\n             let v: Box<List> = box Vec::new();\n@@ -422,8 +366,8 @@ mod imp {\n         // Right before we run the user destructor be sure to flag the\n         // destructor as running for this thread so calls to `get` will return\n         // `None`.\n-        *(*ptr).dtor_running.get() = true;\n-        ptr::read((*ptr).inner.get());\n+        (*ptr).dtor_running.set(true);\n+        intrinsics::drop_in_place((*ptr).inner.get());\n     }\n }\n \n@@ -433,54 +377,50 @@ mod imp {\n     use prelude::v1::*;\n \n     use alloc::boxed;\n-    use cell::UnsafeCell;\n-    use mem;\n+    use cell::{Cell, UnsafeCell};\n+    use marker;\n     use ptr;\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n \n     pub struct Key<T> {\n-        // Statically allocated initialization expression, using an `UnsafeCell`\n-        // for the same reasons as above.\n-        pub inner: UnsafeCell<T>,\n-\n         // OS-TLS key that we'll use to key off.\n-        pub os: OsStaticKey,\n+        os: OsStaticKey,\n+        marker: marker::PhantomData<Cell<T>>,\n     }\n \n     unsafe impl<T> ::marker::Sync for Key<T> { }\n \n     struct Value<T: 'static> {\n         key: &'static Key<T>,\n-        value: T,\n+        value: UnsafeCell<Option<T>>,\n     }\n \n-    impl<T> Key<T> {\n-        pub unsafe fn get(&'static self) -> Option<&'static T> {\n-            self.ptr().map(|p| &*p)\n+    impl<T: 'static> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key {\n+                os: OsStaticKey::new(Some(destroy_value::<T>)),\n+                marker: marker::PhantomData\n+            }\n         }\n \n-        unsafe fn ptr(&'static self) -> Option<*mut T> {\n+        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n             let ptr = self.os.get() as *mut Value<T>;\n             if !ptr.is_null() {\n                 if ptr as usize == 1 {\n                     return None\n                 }\n-                return Some(&mut (*ptr).value as *mut T);\n+                return Some(&(*ptr).value);\n             }\n \n             // If the lookup returned null, we haven't initialized our own local\n             // copy, so do that now.\n-            //\n-            // Also note that this transmute_copy should be ok because the value\n-            // `inner` is already validated to be a valid `static` value, so we\n-            // should be able to freely copy the bits.\n             let ptr: Box<Value<T>> = box Value {\n                 key: self,\n-                value: mem::transmute_copy(&self.inner),\n+                value: UnsafeCell::new(None),\n             };\n             let ptr = boxed::into_raw(ptr);\n             self.os.set(ptr as *mut u8);\n-            Some(&mut (*ptr).value as *mut T)\n+            Some(&(*ptr).value)\n         }\n     }\n \n@@ -505,7 +445,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::{channel, Sender};\n-    use cell::UnsafeCell;\n+    use cell::{Cell, UnsafeCell};\n     use super::LocalKeyState;\n     use thread;\n \n@@ -520,23 +460,23 @@ mod tests {\n \n     #[test]\n     fn smoke_no_dtor() {\n-        thread_local!(static FOO: UnsafeCell<i32> = UnsafeCell { value: 1 });\n+        thread_local!(static FOO: Cell<i32> = Cell::new(1));\n \n-        FOO.with(|f| unsafe {\n-            assert_eq!(*f.get(), 1);\n-            *f.get() = 2;\n+        FOO.with(|f| {\n+            assert_eq!(f.get(), 1);\n+            f.set(2);\n         });\n         let (tx, rx) = channel();\n         let _t = thread::spawn(move|| {\n-            FOO.with(|f| unsafe {\n-                assert_eq!(*f.get(), 1);\n+            FOO.with(|f| {\n+                assert_eq!(f.get(), 1);\n             });\n             tx.send(()).unwrap();\n         });\n         rx.recv().unwrap();\n \n-        FOO.with(|f| unsafe {\n-            assert_eq!(*f.get(), 2);\n+        FOO.with(|f| {\n+            assert_eq!(f.get(), 2);\n         });\n     }\n \n@@ -565,9 +505,7 @@ mod tests {\n \n     #[test]\n     fn smoke_dtor() {\n-        thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n \n         let (tx, rx) = channel();\n         let _t = thread::spawn(move|| unsafe {\n@@ -583,12 +521,8 @@ mod tests {\n     fn circular() {\n         struct S1;\n         struct S2;\n-        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n-            value: None\n-        });\n-        thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n+        thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell::new(None));\n         static mut HITS: u32 = 0;\n \n         impl Drop for S1 {\n@@ -626,9 +560,7 @@ mod tests {\n     #[test]\n     fn self_referential() {\n         struct S1;\n-        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n@@ -644,12 +576,8 @@ mod tests {\n     #[test]\n     fn dtors_in_dtors_in_dtors() {\n         struct S1(Sender<()>);\n-        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n-            value: None\n-        });\n-        thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n+        thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n \n         impl Drop for S1 {\n             fn drop(&mut self) {"}, {"sha": "f090d3e77ddfc75a054717c49efa40f67b67f7e2", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -216,8 +216,7 @@ pub use self::local::{LocalKey, LocalKeyState};\n                       consider stabilizing its interface\")]\n pub use self::scoped_tls::ScopedKey;\n \n-#[doc(hidden)] pub use self::local::__impl as __local;\n-#[doc(hidden)] pub use self::scoped_tls::__impl as __scoped;\n+#[doc(hidden)] pub use self::local::__KeyInner as __LocalKeyInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}, {"sha": "dda1db9aecea4a80b3a5fa484311d229194a78de", "filename": "src/libstd/thread/scoped_tls.rs", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -43,13 +43,6 @@\n \n use prelude::v1::*;\n \n-// macro hygiene sure would be nice, wouldn't it?\n-#[doc(hidden)]\n-pub mod __impl {\n-    pub use super::imp::KeyInner;\n-    pub use sys_common::thread_local::INIT as OS_INIT;\n-}\n-\n /// Type representing a thread local storage key corresponding to a reference\n /// to the type parameter `T`.\n ///\n@@ -60,7 +53,7 @@ pub mod __impl {\n #[unstable(feature = \"scoped_tls\",\n            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                      stabilizing its interface\")]\n-pub struct ScopedKey<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n+pub struct ScopedKey<T> { inner: imp::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///\n@@ -71,18 +64,6 @@ pub struct ScopedKey<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n #[macro_export]\n #[allow_internal_unstable]\n macro_rules! scoped_thread_local {\n-    (static $name:ident: $t:ty) => (\n-        __scoped_thread_local_inner!(static $name: $t);\n-    );\n-    (pub static $name:ident: $t:ty) => (\n-        __scoped_thread_local_inner!(pub static $name: $t);\n-    );\n-}\n-\n-#[macro_export]\n-#[doc(hidden)]\n-#[allow_internal_unstable]\n-macro_rules! __scoped_thread_local_inner {\n     (static $name:ident: $t:ty) => (\n         #[cfg_attr(not(any(windows,\n                            target_os = \"android\",\n@@ -91,7 +72,7 @@ macro_rules! __scoped_thread_local_inner {\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n         static $name: ::std::thread::ScopedKey<$t> =\n-            __scoped_thread_local_inner!($t);\n+            ::std::thread::ScopedKey::new();\n     );\n     (pub static $name:ident: $t:ty) => (\n         #[cfg_attr(not(any(windows,\n@@ -101,42 +82,19 @@ macro_rules! __scoped_thread_local_inner {\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n         pub static $name: ::std::thread::ScopedKey<$t> =\n-            __scoped_thread_local_inner!($t);\n+            ::std::thread::ScopedKey::new();\n     );\n-    ($t:ty) => ({\n-        use std::thread::ScopedKey as __Key;\n-\n-        #[cfg(not(any(windows,\n-                      target_os = \"android\",\n-                      target_os = \"ios\",\n-                      target_os = \"openbsd\",\n-                      target_arch = \"aarch64\")))]\n-        const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread::__scoped::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n-            }\n-        };\n-\n-        #[cfg(any(windows,\n-                  target_os = \"android\",\n-                  target_os = \"ios\",\n-                  target_os = \"openbsd\",\n-                  target_arch = \"aarch64\"))]\n-        const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread::__scoped::KeyInner {\n-                inner: ::std::thread::__scoped::OS_INIT,\n-                marker: ::std::marker::PhantomData::<::std::cell::Cell<$t>>,\n-            }\n-        };\n-\n-        _INIT\n-    })\n }\n \n #[unstable(feature = \"scoped_tls\",\n            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                      stabilizing its interface\")]\n impl<T> ScopedKey<T> {\n+    #[doc(hidden)]\n+    pub const fn new() -> ScopedKey<T> {\n+        ScopedKey { inner: imp::KeyInner::new() }\n+    }\n+\n     /// Inserts a value into this scoped thread local storage slot for a\n     /// duration of a closure.\n     ///\n@@ -170,7 +128,7 @@ impl<T> ScopedKey<T> {\n         F: FnOnce() -> R,\n     {\n         struct Reset<'a, T: 'a> {\n-            key: &'a __impl::KeyInner<T>,\n+            key: &'a imp::KeyInner<T>,\n             val: *mut T,\n         }\n                 impl<'a, T> Drop for Reset<'a, T> {\n@@ -231,19 +189,18 @@ impl<T> ScopedKey<T> {\n               target_os = \"openbsd\",\n               target_arch = \"aarch64\")))]\n mod imp {\n-    use std::cell::UnsafeCell;\n+    use std::cell::Cell;\n \n-    #[doc(hidden)]\n-    pub struct KeyInner<T> { pub inner: UnsafeCell<*mut T> }\n+    pub struct KeyInner<T> { inner: Cell<*mut T> }\n \n     unsafe impl<T> ::marker::Sync for KeyInner<T> { }\n \n-    #[doc(hidden)]\n     impl<T> KeyInner<T> {\n-        #[doc(hidden)]\n-        pub unsafe fn set(&self, ptr: *mut T) { *self.inner.get() = ptr; }\n-        #[doc(hidden)]\n-        pub unsafe fn get(&self) -> *mut T { *self.inner.get() }\n+        pub const fn new() -> KeyInner<T> {\n+            KeyInner { inner: Cell::new(0 as *mut _) }\n+        }\n+        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr); }\n+        pub unsafe fn get(&self) -> *mut T { self.inner.get() }\n     }\n }\n \n@@ -253,23 +210,27 @@ mod imp {\n           target_os = \"openbsd\",\n           target_arch = \"aarch64\"))]\n mod imp {\n+    use prelude::v1::*;\n+\n+    use cell::Cell;\n     use marker;\n-    use std::cell::Cell;\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n \n-    #[doc(hidden)]\n     pub struct KeyInner<T> {\n         pub inner: OsStaticKey,\n         pub marker: marker::PhantomData<Cell<T>>,\n     }\n \n-    unsafe impl<T> ::marker::Sync for KeyInner<T> { }\n+    unsafe impl<T> marker::Sync for KeyInner<T> { }\n \n-    #[doc(hidden)]\n     impl<T> KeyInner<T> {\n-        #[doc(hidden)]\n+        pub const fn new() -> KeyInner<T> {\n+            KeyInner {\n+                inner: OsStaticKey::new(None),\n+                marker: marker::PhantomData\n+            }\n+        }\n         pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr as *mut _) }\n-        #[doc(hidden)]\n         pub unsafe fn get(&self) -> *mut T { self.inner.get() as *mut _ }\n     }\n }"}, {"sha": "1b2613d8c5045f21c655da2af1a5ac900bbdd71c", "filename": "src/snapshots.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -1,3 +1,13 @@\n+S 2015-05-24 ba0e1cd\n+  bitrig-x86_64 2a710e16e3e3ef3760df1f724d66b3af34c1ef3f\n+  freebsd-x86_64 370db40613f5c08563ed7e38357826dd42d4e0f8\n+  linux-i386 a6f22e481eabf098cc65bda97bf7e434a1fcc20b\n+  linux-x86_64 5fd8698fdfe953e6c4d86cf4fa1d5f3a0053248c\n+  macos-i386 9a273324a6b63a40f67a553029c0a9fb692ffd1f\n+  macos-x86_64 e5b12cb7c179fc98fa905a3c84803645d946a6ae\n+  winnt-i386 18d8d76c5380ee2247dd534bfb2c4ed1b3d83461\n+  winnt-x86_64 ef27ce42af4941be24a2f6097d969ffc845a31ee\n+\n S 2015-04-27 857ef6e\n   bitrig-x86_64 d28e2a5f8b478e69720703e751774f5e728a8edd\n   freebsd-x86_64 18925db56f6298cc190d1f41615ab5871de1dda0"}, {"sha": "b347e674f0a9f1995def749c41c9d5ebd2240e72", "filename": "src/test/auxiliary/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -11,12 +11,12 @@\n use std::sync::atomic;\n \n pub const C1: usize = 1;\n-pub const C2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+pub const C2: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n pub const C3: fn() = foo;\n pub const C4: usize = C1 * C1 + C1 / C1;\n pub const C5: &'static usize = &C4;\n \n pub static S1: usize = 3;\n-pub static S2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+pub static S2: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n fn foo() {}"}, {"sha": "c9713ebcebe986dccee88d3b11266d90d7044820", "filename": "src/test/compile-fail/dropck_arr_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -18,9 +18,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "9309f5a243cd38408d13987af80cacc2d37f4f5b", "filename": "src/test/compile-fail/dropck_tarena_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -26,9 +26,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "1d8c7e9ac3e823e7b8647a7d1b0f976976b17180", "filename": "src/test/compile-fail/dropck_trait_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -17,9 +17,9 @@ use std::cell::Cell;\n use id::Id;\n \n mod s {\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "8722246bb4eaa513f3551d40e2f70411a633c407", "filename": "src/test/compile-fail/dropck_vec_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -17,9 +17,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "3f41401eb69c12275b58d7968e2526f8bc0204d7", "filename": "src/test/compile-fail/functional-struct-update-respects-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -16,7 +16,7 @@ use self::foo::S;\n mod foo {\n     use std::cell::{UnsafeCell};\n \n-    static mut count : UnsafeCell<u64> = UnsafeCell { value: 1 };\n+    static mut count : UnsafeCell<u64> = UnsafeCell::new(1);\n \n     pub struct S { pub a: u8, pub b: String, secret_uid: u64 }\n "}, {"sha": "12a9a27463157e5eeab176d17fcb275d94256995", "filename": "src/test/compile-fail/issue-17718-const-borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -10,12 +10,12 @@\n \n use std::cell::UnsafeCell;\n \n-const A: UnsafeCell<usize> = UnsafeCell { value: 1 };\n+const A: UnsafeCell<usize> = UnsafeCell::new(1);\n const B: &'static UnsafeCell<usize> = &A;\n //~^ ERROR: cannot borrow a constant which contains interior mutability\n \n struct C { a: UnsafeCell<usize> }\n-const D: C = C { a: UnsafeCell { value: 1 } };\n+const D: C = C { a: UnsafeCell::new(1) };\n const E: &'static UnsafeCell<usize> = &D.a;\n //~^ ERROR: cannot borrow a constant which contains interior mutability\n const F: &'static C = &D;"}, {"sha": "999e5f9db2dfc05d5a0c0d9117252fa5f41c69c7", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -17,6 +17,5 @@ static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n //~^ ERROR allocations are not allowed in statics\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n-//~| ERROR E0015\n \n fn main() { }"}, {"sha": "35877db610e34e70607b613ab73968120ff153ab", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -15,11 +15,11 @@ use std::sync::atomic::*;\n use std::ptr;\n \n fn main() {\n-    let x = ATOMIC_BOOL_INIT;\n+    let x = AtomicBool::new(false);\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n-    let x = ATOMIC_ISIZE_INIT;\n+    let x = AtomicIsize::new(0);\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n-    let x = ATOMIC_USIZE_INIT;\n+    let x = AtomicUsize::new(0);\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n     let x: AtomicPtr<usize> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of borrowed content"}, {"sha": "0b2112edf728069dc39a341a628eb103695a07a8", "filename": "src/test/compile-fail/vec-must-not-hide-type-from-dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -28,9 +28,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     /// generates globally unique count (global across the current\n     /// process, that is)"}, {"sha": "72448ca2e001fc823b0dba9df9b71615e3babdb4", "filename": "src/test/debuginfo/constant-debug-locs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -19,7 +19,7 @@\n // This test makes sure that the compiler doesn't crash when trying to assign\n // debug locations to const-expressions.\n \n-use std::sync::MUTEX_INIT;\n+use std::sync::StaticMutex;\n use std::cell::UnsafeCell;\n \n const CONSTANT: u64 = 3 + 4;\n@@ -49,7 +49,7 @@ const VEC: [u32; 8] = [0; 8];\n \n const NESTED: (Struct, TupleStruct) = (STRUCT, TUPLE_STRUCT);\n \n-const UNSAFE_CELL: UnsafeCell<bool> = UnsafeCell { value: false };\n+const UNSAFE_CELL: UnsafeCell<bool> = UnsafeCell::new(false);\n \n fn main() {\n     let mut _constant = CONSTANT;\n@@ -61,6 +61,6 @@ fn main() {\n     let mut _string = STRING;\n     let mut _vec = VEC;\n     let mut _nested = NESTED;\n-    let mut _extern = MUTEX_INIT;\n+    let mut _extern = StaticMutex::new();\n     let mut _unsafe_cell = UNSAFE_CELL;\n }"}, {"sha": "2c3d7ef39e497123ab6ff1c749a20f792c40f1af", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -22,7 +22,7 @@ enum E {\n     C = 2\n }\n \n-static FLAG: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+static FLAG: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n impl Drop for E {\n     fn drop(&mut self) {"}, {"sha": "5ceb1013ad811dae95339b9f71300b0bac42e718", "filename": "src/test/run-pass/associated-types-project-from-type-param-via-bound-in-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -13,10 +13,10 @@\n // `T`. Issue #20300.\n \n use std::marker::{PhantomData};\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{AtomicUsize};\n use std::sync::atomic::Ordering::SeqCst;\n \n-static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+static COUNTER: AtomicUsize = AtomicUsize::new(0);\n \n // Preamble.\n trait Trait { type Item; }"}, {"sha": "1c7359a0fad9d40b08480babf181df99a9b3da41", "filename": "src/test/run-pass/box-of-array-of-drop-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -12,9 +12,9 @@\n // destructor.\n \n use std::thread;\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n struct D(u8);\n "}, {"sha": "ad781f00356d715c3efc976c521eb9bc2dd13dd8", "filename": "src/test/run-pass/box-of-array-of-drop-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -12,9 +12,9 @@\n // destructor.\n \n use std::thread;\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n struct D(u8);\n "}, {"sha": "c18d51e84d84f5ffaf829318d6df83ebc88a0fef", "filename": "src/test/run-pass/issue-17718-static-unsafe-interior.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -38,8 +38,8 @@ unsafe impl<T: Send> Sync for UnsafeEnum<T> {}\n \n static STATIC1: UnsafeEnum<isize> = UnsafeEnum::VariantSafe;\n \n-static STATIC2: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell { value: 1 });\n-const CONST: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell { value: 1 });\n+static STATIC2: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell::new(1));\n+const CONST: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell::new(1));\n static STATIC3: MyUnsafe<isize> = MyUnsafe{value: CONST};\n \n static STATIC4: &'static MyUnsafePack<isize> = &STATIC2;\n@@ -50,7 +50,7 @@ struct Wrap<T> {\n \n unsafe impl<T: Send> Sync for Wrap<T> {}\n \n-static UNSAFE: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell{value: 2});\n+static UNSAFE: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell::new(2));\n static WRAPPED_UNSAFE: Wrap<&'static MyUnsafePack<isize>> = Wrap { value: &UNSAFE };\n \n fn main() {"}, {"sha": "457bbb23e18204a9e5251bbc6802631581a9115e", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -15,10 +15,10 @@\n \n extern crate issue_17718 as other;\n \n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n const C1: usize = 1;\n-const C2: AtomicUsize = ATOMIC_USIZE_INIT;\n+const C2: AtomicUsize = AtomicUsize::new(0);\n const C3: fn() = foo;\n const C4: usize = C1 * C1 + C1 / C1;\n const C5: &'static usize = &C4;\n@@ -28,7 +28,7 @@ const C6: usize = {\n };\n \n static S1: usize = 3;\n-static S2: AtomicUsize = ATOMIC_USIZE_INIT;\n+static S2: AtomicUsize = AtomicUsize::new(0);\n \n mod test {\n     static A: usize = 4;"}, {"sha": "c20237f1f86b462aa4c38f31bfbfb60a2f20aec8", "filename": "src/test/run-pass/issue-21486.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fissue-21486.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fissue-21486.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21486.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -13,7 +13,7 @@\n // construction.\n \n \n-use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{Ordering, AtomicUsize};\n \n #[derive(Debug)]\n struct Noisy(u8);\n@@ -69,7 +69,7 @@ pub fn main() {\n     assert_eq!(0x03_04, event_log());\n }\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n fn reset_log() {\n     LOG.store(0, Ordering::SeqCst);"}, {"sha": "e59900caf07ec50be8869c5e1592b4b6b31d93f4", "filename": "src/test/run-pass/nested-vec-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -14,9 +14,9 @@\n \n \n use std::thread;\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n struct D(u8);\n "}, {"sha": "c0ed4ea3ce82f63a7084198ea62d089f61988212", "filename": "src/test/run-pass/struct-order-of-eval-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -12,7 +12,7 @@\n // even when no Drop-implementations are involved.\n \n \n-use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{Ordering, AtomicUsize};\n \n struct W { wrapped: u32 }\n struct S { f0: W, _f1: i32 }\n@@ -34,7 +34,7 @@ pub fn main() {\n             \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n }\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n fn event_log() -> usize {\n     LOG.load(Ordering::SeqCst)"}, {"sha": "83ea0e3ab74eab2babbfbe933ded8c0ff0113f4e", "filename": "src/test/run-pass/struct-order-of-eval-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -12,7 +12,7 @@\n // even when no Drop-implementations are involved.\n \n \n-use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{Ordering, AtomicUsize};\n \n struct W { wrapped: u32 }\n struct S { f0: W, _f1: i32 }\n@@ -31,7 +31,7 @@ pub fn main() {\n             \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n }\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n fn event_log() -> usize {\n     LOG.load(Ordering::SeqCst)"}, {"sha": "f3c4ecb035e51da3d76ae5c02e5c07ba869b6a73", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb16ad6e71172eabb71acb73758675f25df91649/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=eb16ad6e71172eabb71acb73758675f25df91649", "patch": "@@ -11,7 +11,7 @@\n \n #![feature(rand, core)]\n \n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n use std::__rand::{thread_rng, Rng};\n use std::thread;\n \n@@ -20,20 +20,20 @@ const MAX_LEN: usize = 32;\n static drop_counts: [AtomicUsize;  MAX_LEN] =\n     // FIXME #5244: AtomicUsize is not Copy.\n     [\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0),\n      ];\n \n-static creation_count: AtomicUsize = ATOMIC_USIZE_INIT;\n+static creation_count: AtomicUsize = AtomicUsize::new(0);\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]\n struct DropCounter { x: u32, creation_id: usize }"}]}