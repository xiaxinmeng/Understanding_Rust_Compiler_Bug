{"sha": "2cd7fbbdf1edf84d962c62e9990acc0906998413", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZDdmYmJkZjFlZGY4NGQ5NjJjNjJlOTk5MGFjYzA5MDY5OTg0MTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-26T00:24:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-26T00:24:19Z"}, "message": "rustc: Move all of the logic in type_of() to type_of_inner()", "tree": {"sha": "ca4fea0fbbc9b014937c1f420f34df062948e245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca4fea0fbbc9b014937c1f420f34df062948e245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cd7fbbdf1edf84d962c62e9990acc0906998413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd7fbbdf1edf84d962c62e9990acc0906998413", "html_url": "https://github.com/rust-lang/rust/commit/2cd7fbbdf1edf84d962c62e9990acc0906998413", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cd7fbbdf1edf84d962c62e9990acc0906998413/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c24d0403b2e8fefecc5eea11933d493a01f1daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c24d0403b2e8fefecc5eea11933d493a01f1daf", "html_url": "https://github.com/rust-lang/rust/commit/6c24d0403b2e8fefecc5eea11933d493a01f1daf"}], "stats": {"total": 78, "additions": 40, "deletions": 38}, "files": [{"sha": "29ff9d6e575fcaa0cb3b9101184bd78b3636a8c4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2cd7fbbdf1edf84d962c62e9990acc0906998413/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cd7fbbdf1edf84d962c62e9990acc0906998413/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2cd7fbbdf1edf84d962c62e9990acc0906998413", "patch": "@@ -419,10 +419,7 @@ fn T_opaque_obj_ptr(type_names tn) -> TypeRef {\n \n \n fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n-    let TypeRef llty = type_of_inner(cx, t);\n-    check (llty as int != 0);\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_str(t)), llty);\n-    ret llty;\n+    ret type_of_inner(cx, t);\n }\n \n fn type_of_explicit_args(@crate_ctxt cx,\n@@ -433,7 +430,7 @@ fn type_of_explicit_args(@crate_ctxt cx,\n             check (arg.mode == ast.alias);\n             atys += T_typaram_ptr(cx.tn);\n         } else {\n-            let TypeRef t = type_of(cx, arg.ty);\n+            let TypeRef t = type_of_inner(cx, arg.ty);\n             alt (arg.mode) {\n                 case (ast.alias) {\n                     t = T_ptr(t);\n@@ -464,7 +461,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n     if (ty.type_has_dynamic_size(output)) {\n         atys += T_typaram_ptr(cx.tn);\n     } else {\n-        atys += T_ptr(type_of(cx, output));\n+        atys += T_ptr(type_of_inner(cx, output));\n     }\n \n     // Arg 1: Task pointer.\n@@ -520,60 +517,62 @@ fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n                      vec[ty.arg] inputs,\n                      @ty.t output) -> TypeRef {\n     let vec[TypeRef] atys = type_of_explicit_args(cx, inputs);\n-    ret T_fn(atys, type_of(cx, output));\n+    ret T_fn(atys, type_of_inner(cx, output));\n }\n \n fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n+    let TypeRef llty = 0 as TypeRef;\n+\n     alt (t.struct) {\n-        case (ty.ty_native) { ret T_ptr(T_i8()); }\n-        case (ty.ty_nil) { ret T_nil(); }\n-        case (ty.ty_bool) { ret T_bool(); }\n-        case (ty.ty_int) { ret T_int(); }\n-        case (ty.ty_uint) { ret T_int(); }\n+        case (ty.ty_native) { llty = T_ptr(T_i8()); }\n+        case (ty.ty_nil) { llty = T_nil(); }\n+        case (ty.ty_bool) { llty = T_bool(); }\n+        case (ty.ty_int) { llty = T_int(); }\n+        case (ty.ty_uint) { llty = T_int(); }\n         case (ty.ty_machine(?tm)) {\n             alt (tm) {\n-                case (common.ty_i8) { ret T_i8(); }\n-                case (common.ty_u8) { ret T_i8(); }\n-                case (common.ty_i16) { ret T_i16(); }\n-                case (common.ty_u16) { ret T_i16(); }\n-                case (common.ty_i32) { ret T_i32(); }\n-                case (common.ty_u32) { ret T_i32(); }\n-                case (common.ty_i64) { ret T_i64(); }\n-                case (common.ty_u64) { ret T_i64(); }\n-                case (common.ty_f32) { ret T_f32(); }\n-                case (common.ty_f64) { ret T_f64(); }\n+                case (common.ty_i8) { llty = T_i8(); }\n+                case (common.ty_u8) { llty = T_i8(); }\n+                case (common.ty_i16) { llty = T_i16(); }\n+                case (common.ty_u16) { llty = T_i16(); }\n+                case (common.ty_i32) { llty = T_i32(); }\n+                case (common.ty_u32) { llty = T_i32(); }\n+                case (common.ty_i64) { llty = T_i64(); }\n+                case (common.ty_u64) { llty = T_i64(); }\n+                case (common.ty_f32) { llty = T_f32(); }\n+                case (common.ty_f64) { llty = T_f64(); }\n             }\n         }\n-        case (ty.ty_char) { ret T_char(); }\n-        case (ty.ty_str) { ret T_ptr(T_str()); }\n+        case (ty.ty_char) { llty = T_char(); }\n+        case (ty.ty_str) { llty = T_ptr(T_str()); }\n         case (ty.ty_tag(?tag_id, _)) {\n-            ret llvm.LLVMResolveTypeHandle(cx.tags.get(tag_id).th.llth);\n+            llty = llvm.LLVMResolveTypeHandle(cx.tags.get(tag_id).th.llth);\n         }\n         case (ty.ty_box(?t)) {\n-            ret T_ptr(T_box(type_of(cx, t)));\n+            llty = T_ptr(T_box(type_of_inner(cx, t)));\n         }\n         case (ty.ty_vec(?t)) {\n-            ret T_ptr(T_vec(type_of(cx, t)));\n+            llty = T_ptr(T_vec(type_of_inner(cx, t)));\n         }\n         case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n             for (@ty.t elt in elts) {\n-                tys += type_of(cx, elt);\n+                tys += type_of_inner(cx, elt);\n             }\n-            ret T_struct(tys);\n+            llty = T_struct(tys);\n         }\n         case (ty.ty_rec(?fields)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.field f in fields) {\n-                tys += type_of(cx, f.ty);\n+                tys += type_of_inner(cx, f.ty);\n             }\n-            ret T_struct(tys);\n+            llty = T_struct(tys);\n         }\n         case (ty.ty_fn(?proto, ?args, ?out)) {\n-            ret T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out));\n+            llty = T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out));\n         }\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n-            ret T_fn_pair(cx.tn, type_of_native_fn(cx, abi, args, out));\n+            llty = T_fn_pair(cx.tn, type_of_native_fn(cx, abi, args, out));\n         }\n         case (ty.ty_obj(?meths)) {\n             auto th = mk_type_handle();\n@@ -594,22 +593,25 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             auto abs_pair = llvm.LLVMResolveTypeHandle(th.llth);\n             llvm.LLVMRefineType(abs_pair, pair);\n             abs_pair = llvm.LLVMResolveTypeHandle(th.llth);\n-            ret abs_pair;\n+            llty = abs_pair;\n         }\n         case (ty.ty_var(_)) {\n             log \"ty_var in trans.type_of\";\n             fail;\n         }\n         case (ty.ty_param(_)) {\n-            ret T_typaram_ptr(cx.tn);\n+            llty = T_typaram_ptr(cx.tn);\n         }\n-        case (ty.ty_type) { ret T_ptr(T_tydesc(cx.tn)); }\n+        case (ty.ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n     }\n-    fail;\n+\n+    check (llty as int != 0);\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_str(t)), llty);\n+    ret llty;\n }\n \n fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n-    auto ty = type_of(cx, arg.ty);\n+    auto ty = type_of_inner(cx, arg.ty);\n     if (arg.mode == ast.alias) {\n         ty = T_ptr(ty);\n     }"}]}