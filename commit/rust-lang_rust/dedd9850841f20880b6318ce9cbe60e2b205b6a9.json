{"sha": "dedd9850841f20880b6318ce9cbe60e2b205b6a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZGQ5ODUwODQxZjIwODgwYjYzMThjZTljYmU2MGUyYjIwNWI2YTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-09T10:00:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-09T10:00:25Z"}, "message": "Auto merge of #38192 - stjepang:faster-sort-algorithm, r=bluss\n\nImplement a faster sort algorithm\n\nHi everyone, this is my first PR.\n\nI've made some changes to the standard sort algorithm, starting out with a few tweaks here and there, but in the end this endeavour became a complete rewrite of it.\n\n#### Summary\n\nChanges:\n\n* Improved performance, especially on partially sorted inputs.\n* Performs less comparisons on both random and partially sorted inputs.\n* Decreased the size of temporary memory: the new sort allocates 4x less.\n\nBenchmark:\n\n```\n name                                        out1 ns/iter          out2 ns/iter          diff ns/iter   diff %\n slice::bench::sort_large_ascending          85,323 (937 MB/s)     8,970 (8918 MB/s)          -76,353  -89.49%\n slice::bench::sort_large_big_ascending      2,135,297 (599 MB/s)  355,955 (3595 MB/s)     -1,779,342  -83.33%\n slice::bench::sort_large_big_descending     2,266,402 (564 MB/s)  416,479 (3073 MB/s)     -1,849,923  -81.62%\n slice::bench::sort_large_big_random         3,053,031 (419 MB/s)  1,921,389 (666 MB/s)    -1,131,642  -37.07%\n slice::bench::sort_large_descending         313,181 (255 MB/s)    14,725 (5432 MB/s)        -298,456  -95.30%\n slice::bench::sort_large_mostly_ascending   287,706 (278 MB/s)    243,204 (328 MB/s)         -44,502  -15.47%\n slice::bench::sort_large_mostly_descending  415,078 (192 MB/s)    271,028 (295 MB/s)        -144,050  -34.70%\n slice::bench::sort_large_random             545,872 (146 MB/s)    521,559 (153 MB/s)         -24,313   -4.45%\n slice::bench::sort_large_random_expensive   30,321,770 (2 MB/s)   23,533,735 (3 MB/s)     -6,788,035  -22.39%\n slice::bench::sort_medium_ascending         616 (1298 MB/s)       155 (5161 MB/s)               -461  -74.84%\n slice::bench::sort_medium_descending        1,952 (409 MB/s)      202 (3960 MB/s)             -1,750  -89.65%\n slice::bench::sort_medium_random            3,646 (219 MB/s)      3,421 (233 MB/s)              -225   -6.17%\n slice::bench::sort_small_ascending          39 (2051 MB/s)        34 (2352 MB/s)                  -5  -12.82%\n slice::bench::sort_small_big_ascending      96 (13333 MB/s)       96 (13333 MB/s)                  0    0.00%\n slice::bench::sort_small_big_descending     248 (5161 MB/s)       243 (5267 MB/s)                 -5   -2.02%\n slice::bench::sort_small_big_random         501 (2554 MB/s)       490 (2612 MB/s)                -11   -2.20%\n slice::bench::sort_small_descending         95 (842 MB/s)         63 (1269 MB/s)                 -32  -33.68%\n slice::bench::sort_small_random             372 (215 MB/s)        354 (225 MB/s)                 -18   -4.84%\n```\n\n#### Background\n\nFirst, let me just do a quick brain dump to discuss what I learned along the way.\n\nThe official documentation says that the standard sort in Rust is a stable sort. This constraint is thus set in stone and immediately rules out many popular sorting algorithms. Essentially, the only algorithms we might even take into consideration are:\n\n1. [Merge sort](https://en.wikipedia.org/wiki/Merge_sort)\n2. [Block sort](https://en.wikipedia.org/wiki/Block_sort) (famous implementations are [WikiSort](https://github.com/BonzaiThePenguin/WikiSort) and [GrailSort](https://github.com/Mrrl/GrailSort))\n3. [TimSort](https://en.wikipedia.org/wiki/Timsort)\n\nActually, all of those are just merge sort flavors. :) The current standard sort in Rust is a simple iterative merge sort. It has three problems. First, it's slow on partially sorted inputs (even though #29675 helped quite a bit). Second, it always makes around `log(n)` iterations copying the entire array between buffers, no matter what. Third, it allocates huge amounts of temporary memory (a buffer of size `2*n`, where `n` is the size of input).\n\nThe problem of auxilliary memory allocation is a tough one. Ideally, it would be best for our sort to allocate `O(1)` additional memory. This is what block sort (and it's variants) does. However, it's often very complicated (look at [this](https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.cpp)) and even then performs rather poorly. The author of WikiSort claims good performance, but that must be taken with a grain of salt. It performs well in comparison to `std::stable_sort` in C++. It can even beat `std::sort` on partially sorted inputs, but on random inputs it's always far worse. My rule of thumb is: high performance, low memory overhead, stability - choose two.\n\nTimSort is another option. It allocates a buffer of size `n/2`, which is not great, but acceptable. Performs extremelly well on partially sorted inputs. However, it seems pretty much all implementations suck on random inputs. I benchmarked implementations in [Rust](https://github.com/notriddle/rust-timsort), [C++](https://github.com/gfx/cpp-TimSort), and [D](https://github.com/dlang/phobos/blob/fd518eb310a9494cccf28c54892542b052c49669/std/algorithm/sorting.d#L2062). The results were a bit disappointing. It seems bad performance is due to complex galloping procedures in hot loops. Galloping noticeably improves performance on partially sorted inputs, but worsens it on random ones.\n\n#### The new algorithm\n\nChoosing the best algorithm is not easy. Plain merge sort is bad on partially sorted inputs. TimSort is bad on random inputs and block sort is even worse. However, if we take the main ideas from TimSort (intelligent merging strategy of sorted runs) and drop galloping, then we'll have great performance on random inputs and it won't be bad on partially sorted inputs either.\n\nThat is exactly what this new algorithm does. I can't call it TimSort, since it steals just a few of it's ideas. Complete TimSort would be a much more complex and elaborate implementation. In case we in the future figure out how to incorporate more of it's ideas into this implementation without crippling performance on random inputs, it's going to be very easy to extend. I also did several other minor improvements, like reworked insertion sort to make it faster.\n\nThere are also new, more thorough benchmarks and panic safety tests.\n\nThe final code is not terribly complex and has less unsafe code than I anticipated, but there's still plenty of it that should be carefully reviewed. I did my best at documenting non-obvious code.\n\nI'd like to notify several people of this PR, since they might be interested and have useful insights:\n\n1. @huonw because he wrote the [original merge sort](https://github.com/rust-lang/rust/pull/11064).\n2. @alexcrichton because he was involved in multiple discussions of it.\n3. @veddan because he wrote [introsort](https://github.com/veddan/rust-introsort) in Rust.\n4. @notriddle because he wrote [TimSort](https://github.com/notriddle/rust-timsort) in Rust.\n5. @bluss because he had an attempt at writing WikiSort in Rust.\n6. @gnzlbg, @rkruppe, and @mark-i-m because they were involved in discussion #36318.\n\n**P.S.** [quickersort](https://github.com/notriddle/quickersort) describes itself as being universally [faster](https://github.com/notriddle/quickersort/blob/master/perf.txt) than the standard sort, which is true. However, if this PR gets merged, things might [change](https://gist.github.com/stjepang/b9f0c3eaa0e1f1280b61b963dae19a30) a bit. ;)", "tree": {"sha": "5d0959fa119d39c0e7eac1976e02b9d89b7d936d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d0959fa119d39c0e7eac1976e02b9d89b7d936d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dedd9850841f20880b6318ce9cbe60e2b205b6a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dedd9850841f20880b6318ce9cbe60e2b205b6a9", "html_url": "https://github.com/rust-lang/rust/commit/dedd9850841f20880b6318ce9cbe60e2b205b6a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dedd9850841f20880b6318ce9cbe60e2b205b6a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adb4279e549f51d287140658c1c64b51d7715bfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/adb4279e549f51d287140658c1c64b51d7715bfa", "html_url": "https://github.com/rust-lang/rust/commit/adb4279e549f51d287140658c1c64b51d7715bfa"}, {"sha": "c0e150a2a65a762281ff5d28be8574cf6b207594", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e150a2a65a762281ff5d28be8574cf6b207594", "html_url": "https://github.com/rust-lang/rust/commit/c0e150a2a65a762281ff5d28be8574cf6b207594"}], "stats": {"total": 796, "additions": 481, "deletions": 315}, "files": [{"sha": "191a6b0b7a98056df75b1b68da3292cd87baca01", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=dedd9850841f20880b6318ce9cbe60e2b205b6a9", "patch": "@@ -47,14 +47,14 @@\n #![feature(placement_in)]\n #![feature(placement_new_protocol)]\n #![feature(shared)]\n+#![feature(slice_get_slice)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(staged_api)]\n-#![feature(step_by)]\n #![feature(trusted_len)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(slice_get_slice)]\n+#![feature(untagged_unions)]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "5fb8cd6e1e2b7a7b8b10f8135240c4629915b838", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 299, "deletions": 180, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=dedd9850841f20880b6318ce9cbe60e2b205b6a9", "patch": "@@ -98,8 +98,7 @@\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n use alloc::boxed::Box;\n-use core::cmp::Ordering::{self, Greater, Less};\n-use core::cmp;\n+use core::cmp::Ordering::{self, Greater};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n@@ -1042,8 +1041,8 @@ impl<T> [T] {\n \n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n-    /// This sort is stable and `O(n log n)` worst-case but allocates\n-    /// approximately `2 * n` where `n` is the length of `self`.\n+    /// This sort is stable and `O(n log n)` worst-case, but allocates\n+    /// temporary storage half the size of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -1064,8 +1063,8 @@ impl<T> [T] {\n     /// Sorts the slice, in place, using `f` to extract a key by which to\n     /// order the sort by.\n     ///\n-    /// This sort is stable and `O(n log n)` worst-case but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n+    /// This sort is stable and `O(n log n)` worst-case, but allocates\n+    /// temporary storage half the size of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -1086,8 +1085,8 @@ impl<T> [T] {\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n-    /// This sort is stable and `O(n log n)` worst-case but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n+    /// This sort is stable and `O(n log n)` worst-case, but allocates\n+    /// temporary storage half the size of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -1305,213 +1304,333 @@ impl<T: Clone> ToOwned for [T] {\n // Sorting\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn insertion_sort<T, F>(v: &mut [T], mut compare: F)\n+/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n+///\n+/// This is the integral subroutine of insertion sort.\n+fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n     where F: FnMut(&T, &T) -> Ordering\n {\n-    let len = v.len() as isize;\n-    let buf_v = v.as_mut_ptr();\n-\n-    // 1 <= i < len;\n-    for i in 1..len {\n-        // j satisfies: 0 <= j <= i;\n-        let mut j = i;\n+    if v.len() >= 2 && compare(&v[0], &v[1]) == Greater {\n         unsafe {\n-            // `i` is in bounds.\n-            let read_ptr = buf_v.offset(i) as *const T;\n-\n-            // find where to insert, we need to do strict <,\n-            // rather than <=, to maintain stability.\n-\n-            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n-            while j > 0 && compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n-                j -= 1;\n+            // There are three ways to implement insertion here:\n+            //\n+            // 1. Swap adjacent elements until the first one gets to its final destination.\n+            //    However, this way we copy data around more than is necessary. If elements are big\n+            //    structures (costly to copy), this method will be slow.\n+            //\n+            // 2. Iterate until the right place for the first element is found. Then shift the\n+            //    elements succeeding it to make room for it and finally place it into the\n+            //    remaining hole. This is a good method.\n+            //\n+            // 3. Copy the first element into a temporary variable. Iterate until the right place\n+            //    for it is found. As we go along, copy every traversed element into the slot\n+            //    preceding it. Finally, copy data from the temporary variable into the remaining\n+            //    hole. This method is very good. Benchmarks demonstrated slightly better\n+            //    performance than with the 2nd method.\n+            //\n+            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n+            let mut tmp = NoDrop { value: ptr::read(&v[0]) };\n+\n+            // Intermediate state of the insertion process is always tracked by `hole`, which\n+            // serves two purposes:\n+            // 1. Protects integrity of `v` from panics in `compare`.\n+            // 2. Fills the remaining hole in `v` in the end.\n+            //\n+            // Panic safety:\n+            //\n+            // If `compare` panics at any point during the process, `hole` will get dropped and\n+            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n+            // initially held exactly once.\n+            let mut hole = InsertionHole {\n+                src: &mut tmp.value,\n+                dest: &mut v[1],\n+            };\n+            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n+\n+            for i in 2..v.len() {\n+                if compare(&tmp.value, &v[i]) != Greater {\n+                    break;\n+                }\n+                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n+                hole.dest = &mut v[i];\n             }\n+            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n+        }\n+    }\n \n-            // shift everything to the right, to make space to\n-            // insert this value.\n+    // Holds a value, but never drops it.\n+    #[allow(unions_with_drop_fields)]\n+    union NoDrop<T> {\n+        value: T\n+    }\n \n-            // j + 1 could be `len` (for the last `i`), but in\n-            // that case, `i == j` so we don't copy. The\n-            // `.offset(j)` is always in bounds.\n+    // When dropped, copies from `src` into `dest`.\n+    struct InsertionHole<T> {\n+        src: *mut T,\n+        dest: *mut T,\n+    }\n \n-            if i != j {\n-                let tmp = ptr::read(read_ptr);\n-                ptr::copy(&*buf_v.offset(j), buf_v.offset(j + 1), (i - j) as usize);\n-                ptr::copy_nonoverlapping(&tmp, buf_v.offset(j), 1);\n-                mem::forget(tmp);\n-            }\n+    impl<T> Drop for InsertionHole<T> {\n+        fn drop(&mut self) {\n+            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n         }\n     }\n }\n \n-fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n+/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n+/// stores the result into `v[..]`.\n+///\n+/// # Safety\n+///\n+/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n+/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n+unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n     where F: FnMut(&T, &T) -> Ordering\n {\n-    // warning: this wildly uses unsafe.\n-    const BASE_INSERTION: usize = 32;\n-    const LARGE_INSERTION: usize = 16;\n-\n-    // FIXME #12092: smaller insertion runs seems to make sorting\n-    // vectors of large elements a little faster on some platforms,\n-    // but hasn't been tested/tuned extensively\n-    let insertion = if size_of::<T>() <= 16 {\n-        BASE_INSERTION\n+    let len = v.len();\n+    let v = v.as_mut_ptr();\n+    let v_mid = v.offset(mid as isize);\n+    let v_end = v.offset(len as isize);\n+\n+    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n+    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n+    // copying the lesser (or greater) one into `v`.\n+    //\n+    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n+    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n+    // hole in `v`.\n+    //\n+    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n+    // 1. Protects integrity of `v` from panics in `compare`.\n+    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n+    //\n+    // Panic safety:\n+    //\n+    // If `compare` panics at any point during the process, `hole` will get dropped and fill the\n+    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n+    // object it initially held exactly once.\n+    let mut hole;\n+\n+    if mid <= len - mid {\n+        // The left run is shorter.\n+        ptr::copy_nonoverlapping(v, buf, mid);\n+        hole = MergeHole {\n+            start: buf,\n+            end: buf.offset(mid as isize),\n+            dest: v,\n+        };\n+\n+        // Initially, these pointers point to the beginnings of their arrays.\n+        let left = &mut hole.start;\n+        let mut right = v_mid;\n+        let out = &mut hole.dest;\n+\n+        while *left < hole.end && right < v_end {\n+            // Consume the lesser side.\n+            // If equal, prefer the left run to maintain stability.\n+            let to_copy = if compare(&**left, &*right) == Greater {\n+                get_and_increment(&mut right)\n+            } else {\n+                get_and_increment(left)\n+            };\n+            ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+        }\n     } else {\n-        LARGE_INSERTION\n-    };\n+        // The right run is shorter.\n+        ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n+        hole = MergeHole {\n+            start: buf,\n+            end: buf.offset((len - mid) as isize),\n+            dest: v_mid,\n+        };\n+\n+        // Initially, these pointers point past the ends of their arrays.\n+        let left = &mut hole.dest;\n+        let right = &mut hole.end;\n+        let mut out = v_end;\n+\n+        while v < *left && buf < *right {\n+            // Consume the greater side.\n+            // If equal, prefer the right run to maintain stability.\n+            let to_copy = if compare(&*left.offset(-1), &*right.offset(-1)) == Greater {\n+                decrement_and_get(left)\n+            } else {\n+                decrement_and_get(right)\n+            };\n+            ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+        }\n+    }\n+    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n+    // it will now be copied into the hole in `v`.\n \n-    let len = v.len();\n+    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+        *ptr = ptr.offset(1);\n+        old\n+    }\n \n-    // short vectors get sorted in-place via insertion sort to avoid allocations\n-    if len <= insertion {\n-        insertion_sort(v, compare);\n-        return;\n+    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n+        *ptr = ptr.offset(-1);\n+        *ptr\n     }\n \n-    // allocate some memory to use as scratch memory, we keep the\n-    // length 0 so we can keep shallow copies of the contents of `v`\n-    // without risking the dtors running on an object twice if\n-    // `compare` panics.\n-    let mut working_space = Vec::with_capacity(2 * len);\n-    // these both are buffers of length `len`.\n-    let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe { buf_dat.offset(len as isize) };\n-\n-    // length `len`.\n-    let buf_v = v.as_ptr();\n-\n-    // step 1. sort short runs with insertion sort. This takes the\n-    // values from `v` and sorts them into `buf_dat`, leaving that\n-    // with sorted runs of length INSERTION.\n-\n-    // We could hardcode the sorting comparisons here, and we could\n-    // manipulate/step the pointers themselves, rather than repeatedly\n-    // .offset-ing.\n-    for start in (0..len).step_by(insertion) {\n-        // start <= i < len;\n-        for i in start..cmp::min(start + insertion, len) {\n-            // j satisfies: start <= j <= i;\n-            let mut j = i as isize;\n-            unsafe {\n-                // `i` is in bounds.\n-                let read_ptr = buf_v.offset(i as isize);\n+    // When dropped, copies the range `start..end` into `dest..`.\n+    struct MergeHole<T> {\n+        start: *mut T,\n+        end: *mut T,\n+        dest: *mut T,\n+    }\n+\n+    impl<T> Drop for MergeHole<T> {\n+        fn drop(&mut self) {\n+            // `T` is not a zero-sized type, so it's okay to divide by it's size.\n+            let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n+            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n+        }\n+    }\n+}\n \n-                // find where to insert, we need to do strict <,\n-                // rather than <=, to maintain stability.\n+/// This merge sort borrows some (but not all) ideas from TimSort, which is described in detail\n+/// [here](http://svn.python.org/projects/python/trunk/Objects/listsort.txt).\n+///\n+/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n+/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n+/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n+/// satisfied, for every `i` in `0 .. runs.len() - 2`:\n+///\n+/// 1. `runs[i].len > runs[i + 1].len`\n+/// 2. `runs[i].len > runs[i + 1].len + runs[i + 2].len`\n+///\n+/// The invariants ensure that the total running time is `O(n log n)` worst-case.\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n+    where F: FnMut(&T, &T) -> Ordering\n+{\n+    // Sorting has no meaningful behavior on zero-sized types.\n+    if size_of::<T>() == 0 {\n+        return;\n+    }\n \n-                // start <= j - 1 < len, so .offset(j - 1) is in\n-                // bounds.\n-                while j > start as isize && compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n-                    j -= 1;\n-                }\n+    // FIXME #12092: These numbers are platform-specific and need more extensive testing/tuning.\n+    //\n+    // If `v` has length up to `insertion_len`, simply switch to insertion sort because it is going\n+    // to perform better than merge sort. For bigger types `T`, the threshold is smaller.\n+    //\n+    // Short runs are extended using insertion sort to span at least `min_run` elements, in order\n+    // to improve performance.\n+    let (max_insertion, min_run) = if size_of::<T>() <= 16 {\n+        (64, 32)\n+    } else {\n+        (32, 16)\n+    };\n \n-                // shift everything to the right, to make space to\n-                // insert this value.\n+    let len = v.len();\n \n-                // j + 1 could be `len` (for the last `i`), but in\n-                // that case, `i == j` so we don't copy. The\n-                // `.offset(j)` is always in bounds.\n-                ptr::copy(&*buf_dat.offset(j), buf_dat.offset(j + 1), i - j as usize);\n-                ptr::copy_nonoverlapping(read_ptr, buf_dat.offset(j), 1);\n+    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n+    if len <= max_insertion {\n+        if len >= 2 {\n+            for i in (0..len-1).rev() {\n+                insert_head(&mut v[i..], &mut compare);\n             }\n         }\n+        return;\n     }\n \n-    // step 2. merge the sorted runs.\n-    let mut width = insertion;\n-    while width < len {\n-        // merge the sorted runs of length `width` in `buf_dat` two at\n-        // a time, placing the result in `buf_tmp`.\n-\n-        // 0 <= start <= len.\n-        for start in (0..len).step_by(2 * width) {\n-            // manipulate pointers directly for speed (rather than\n-            // using a `for` loop with `range` and `.offset` inside\n-            // that loop).\n-            unsafe {\n-                // the end of the first run & start of the\n-                // second. Offset of `len` is defined, since this is\n-                // precisely one byte past the end of the object.\n-                let right_start = buf_dat.offset(cmp::min(start + width, len) as isize);\n-                // end of the second. Similar reasoning to the above re safety.\n-                let right_end_idx = cmp::min(start + 2 * width, len);\n-                let right_end = buf_dat.offset(right_end_idx as isize);\n-\n-                // the pointers to the elements under consideration\n-                // from the two runs.\n-\n-                // both of these are in bounds.\n-                let mut left = buf_dat.offset(start as isize);\n-                let mut right = right_start;\n-\n-                // where we're putting the results, it is a run of\n-                // length `2*width`, so we step it once for each step\n-                // of either `left` or `right`.  `buf_tmp` has length\n-                // `len`, so these are in bounds.\n-                let mut out = buf_tmp.offset(start as isize);\n-                let out_end = buf_tmp.offset(right_end_idx as isize);\n-\n-                // If left[last] <= right[0], they are already in order:\n-                // fast-forward the left side (the right side is handled\n-                // in the loop).\n-                // If `right` is not empty then left is not empty, and\n-                // the offsets are in bounds.\n-                if right != right_end && compare(&*right.offset(-1), &*right) != Greater {\n-                    let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                    ptr::copy_nonoverlapping(&*left, out, elems);\n-                    out = out.offset(elems as isize);\n-                    left = right_start;\n+    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n+    // shallow copies of the contents of `v` without risking the dtors running on copies if\n+    // `compare` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n+    // which will always have length at most `len / 2`.\n+    let mut buf = Vec::with_capacity(len / 2);\n+\n+    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n+    // strange decision, but consider the fact that merges more often go in the opposite direction\n+    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n+    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n+    let mut runs = vec![];\n+    let mut end = len;\n+    while end > 0 {\n+        // Find the next natural run, and reverse it if it's strictly descending.\n+        let mut start = end - 1;\n+        if start > 0 {\n+            start -= 1;\n+            if compare(&v[start], &v[start + 1]) == Greater {\n+                while start > 0 && compare(&v[start - 1], &v[start]) == Greater {\n+                    start -= 1;\n                 }\n-\n-                while out < out_end {\n-                    // Either the left or the right run are exhausted,\n-                    // so just copy the remainder from the other run\n-                    // and move on; this gives a huge speed-up (order\n-                    // of 25%) for mostly sorted vectors (the best\n-                    // case).\n-                    if left == right_start {\n-                        // the number remaining in this run.\n-                        let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(&*right, out, elems);\n-                        break;\n-                    } else if right == right_end {\n-                        let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(&*left, out, elems);\n-                        break;\n-                    }\n-\n-                    // check which side is smaller, and that's the\n-                    // next element for the new run.\n-\n-                    // `left < right_start` and `right < right_end`,\n-                    // so these are valid.\n-                    let to_copy = if compare(&*left, &*right) == Greater {\n-                        step(&mut right)\n-                    } else {\n-                        step(&mut left)\n-                    };\n-                    ptr::copy_nonoverlapping(&*to_copy, out, 1);\n-                    step(&mut out);\n+                v[start..end].reverse();\n+            } else {\n+                while start > 0 && compare(&v[start - 1], &v[start]) != Greater {\n+                    start -= 1;\n                 }\n             }\n         }\n \n-        mem::swap(&mut buf_dat, &mut buf_tmp);\n+        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n+        // merge sort on short sequences, so this significantly improves performance.\n+        while start > 0 && end - start < min_run {\n+            start -= 1;\n+            insert_head(&mut v[start..end], &mut compare);\n+        }\n \n-        width *= 2;\n+        // Push this run onto the stack.\n+        runs.push(Run {\n+            start: start,\n+            len: end - start,\n+        });\n+        end = start;\n+\n+        // Merge some pairs of adjacent runs to satisfy the invariants.\n+        while let Some(r) = collapse(&runs) {\n+            let left = runs[r + 1];\n+            let right = runs[r];\n+            unsafe {\n+                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n+                      &mut compare);\n+            }\n+            runs[r] = Run {\n+                start: left.start,\n+                len: left.len + right.len,\n+            };\n+            runs.remove(r + 1);\n+        }\n     }\n \n-    // write the result to `v` in one go, so that there are never two copies\n-    // of the same object in `v`.\n-    unsafe {\n-        ptr::copy_nonoverlapping(&*buf_dat, v.as_mut_ptr(), len);\n+    // Finally, exactly one run must remain in the stack.\n+    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n+\n+    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n+    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n+    // algorithm should continue building a new run instead, `None` is returned.\n+    //\n+    // TimSort is infamous for it's buggy implementations, as described here:\n+    // http://envisage-project.eu/timsort-specification-and-verification/\n+    //\n+    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n+    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n+    // hold for *all* runs in the stack.\n+    //\n+    // This function correctly checks invariants for the top four runs. Additionally, if the top\n+    // run starts at index 0, it will always demand a merge operation until the stack is fully\n+    // collapsed, in order to complete the sort.\n+    #[inline]\n+    fn collapse(runs: &[Run]) -> Option<usize> {\n+        let n = runs.len();\n+        if n >= 2 && (runs[n - 1].start == 0 ||\n+                      runs[n - 2].len <= runs[n - 1].len ||\n+                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n+                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n+                Some(n - 3)\n+            } else {\n+                Some(n - 2)\n+            }\n+        } else {\n+            None\n+        }\n     }\n \n-    // increment the pointer, returning the old pointer.\n-    #[inline(always)]\n-    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-        *ptr = ptr.offset(1);\n-        old\n+    #[derive(Clone, Copy)]\n+    struct Run {\n+        start: usize,\n+        len: usize,\n     }\n }"}, {"sha": "1b52214dee6aebd0c7cf31eca00f8573764eab2c", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 88, "deletions": 66, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=dedd9850841f20880b6318ce9cbe60e2b205b6a9", "patch": "@@ -383,7 +383,7 @@ fn test_reverse() {\n \n #[test]\n fn test_sort() {\n-    for len in 4..25 {\n+    for len in (2..25).chain(500..510) {\n         for _ in 0..100 {\n             let mut v: Vec<_> = thread_rng().gen_iter::<i32>().take(len).collect();\n             let mut v1 = v.clone();\n@@ -410,7 +410,7 @@ fn test_sort() {\n \n #[test]\n fn test_sort_stability() {\n-    for len in 4..25 {\n+    for len in (2..25).chain(500..510) {\n         for _ in 0..10 {\n             let mut counts = [0; 10];\n \n@@ -441,6 +441,13 @@ fn test_sort_stability() {\n     }\n }\n \n+#[test]\n+fn test_sort_zero_sized_type() {\n+    // Should not panic.\n+    [(); 10].sort();\n+    [(); 100].sort();\n+}\n+\n #[test]\n fn test_concat() {\n     let v: [Vec<i32>; 0] = [];\n@@ -1338,89 +1345,104 @@ mod bench {\n         })\n     }\n \n-    #[bench]\n-    fn sort_random_small(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n-            v.sort();\n-        });\n-        b.bytes = 5 * mem::size_of::<u64>() as u64;\n+    fn gen_ascending(len: usize) -> Vec<u64> {\n+        (0..len as u64).collect()\n     }\n \n-    #[bench]\n-    fn sort_random_medium(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n-            v.sort();\n-        });\n-        b.bytes = 100 * mem::size_of::<u64>() as u64;\n+    fn gen_descending(len: usize) -> Vec<u64> {\n+        (0..len as u64).rev().collect()\n     }\n \n-    #[bench]\n-    fn sort_random_large(b: &mut Bencher) {\n+    fn gen_random(len: usize) -> Vec<u64> {\n         let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n-            v.sort();\n-        });\n-        b.bytes = 10000 * mem::size_of::<u64>() as u64;\n+        rng.gen_iter::<u64>().take(len).collect()\n     }\n \n-    #[bench]\n-    fn sort_sorted(b: &mut Bencher) {\n-        let mut v: Vec<_> = (0..10000).collect();\n-        b.iter(|| {\n-            v.sort();\n-        });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n+        let mut rng = thread_rng();\n+        let mut v = gen_ascending(len);\n+        for _ in (0usize..).take_while(|x| x * x <= len) {\n+            let x = rng.gen::<usize>() % len;\n+            let y = rng.gen::<usize>() % len;\n+            v.swap(x, y);\n+        }\n+        v\n     }\n \n-    type BigSortable = (u64, u64, u64, u64);\n-\n-    #[bench]\n-    fn sort_big_random_small(b: &mut Bencher) {\n+    fn gen_mostly_descending(len: usize) -> Vec<u64> {\n         let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>()\n-                .take(5)\n-                .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n+        let mut v = gen_descending(len);\n+        for _ in (0usize..).take_while(|x| x * x <= len) {\n+            let x = rng.gen::<usize>() % len;\n+            let y = rng.gen::<usize>() % len;\n+            v.swap(x, y);\n+        }\n+        v\n     }\n \n-    #[bench]\n-    fn sort_big_random_medium(b: &mut Bencher) {\n+    fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n         let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>()\n-                .take(100)\n-                .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n+        rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n     }\n \n-    #[bench]\n-    fn sort_big_random_large(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>()\n-                .take(10000)\n-                .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 10000 * mem::size_of::<BigSortable>() as u64;\n+    fn gen_big_ascending(len: usize) -> Vec<[u64; 16]> {\n+        (0..len as u64).map(|x| [x; 16]).take(len).collect()\n     }\n \n+    fn gen_big_descending(len: usize) -> Vec<[u64; 16]> {\n+        (0..len as u64).rev().map(|x| [x; 16]).take(len).collect()\n+    }\n+\n+    macro_rules! sort_bench {\n+        ($name:ident, $gen:expr, $len:expr) => {\n+            #[bench]\n+            fn $name(b: &mut Bencher) {\n+                b.iter(|| $gen($len).sort());\n+                b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n+            }\n+        }\n+    }\n+\n+    sort_bench!(sort_small_random, gen_random, 10);\n+    sort_bench!(sort_small_ascending, gen_ascending, 10);\n+    sort_bench!(sort_small_descending, gen_descending, 10);\n+\n+    sort_bench!(sort_small_big_random, gen_big_random, 10);\n+    sort_bench!(sort_small_big_ascending, gen_big_ascending, 10);\n+    sort_bench!(sort_small_big_descending, gen_big_descending, 10);\n+\n+    sort_bench!(sort_medium_random, gen_random, 100);\n+    sort_bench!(sort_medium_ascending, gen_ascending, 100);\n+    sort_bench!(sort_medium_descending, gen_descending, 100);\n+\n+    sort_bench!(sort_large_random, gen_random, 10000);\n+    sort_bench!(sort_large_ascending, gen_ascending, 10000);\n+    sort_bench!(sort_large_descending, gen_descending, 10000);\n+    sort_bench!(sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n+    sort_bench!(sort_large_mostly_descending, gen_mostly_descending, 10000);\n+\n+    sort_bench!(sort_large_big_random, gen_big_random, 10000);\n+    sort_bench!(sort_large_big_ascending, gen_big_ascending, 10000);\n+    sort_bench!(sort_large_big_descending, gen_big_descending, 10000);\n+\n     #[bench]\n-    fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v: Vec<BigSortable> = (0..10000).map(|i| (i, i, i, i)).collect();\n+    fn sort_large_random_expensive(b: &mut Bencher) {\n+        let len = 10000;\n         b.iter(|| {\n-            v.sort();\n+            let mut count = 0;\n+            let cmp = move |a: &u64, b: &u64| {\n+                count += 1;\n+                if count % 1_000_000_000 == 0 {\n+                    panic!(\"should not happen\");\n+                }\n+                (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n+            };\n+\n+            let mut v = gen_random(len);\n+            v.sort_by(cmp);\n+\n+            black_box(count);\n         });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+        b.bytes = len as u64 * mem::size_of::<u64>() as u64;\n     }\n }"}, {"sha": "87f1968918c3a83720216cd9e0ff05fd91186070", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 92, "deletions": 67, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedd9850841f20880b6318ce9cbe60e2b205b6a9/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=dedd9850841f20880b6318ce9cbe60e2b205b6a9", "patch": "@@ -17,86 +17,111 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n use std::__rand::{thread_rng, Rng};\n use std::thread;\n \n-const REPEATS: usize = 5;\n-const MAX_LEN: usize = 32;\n-static drop_counts: [AtomicUsize;  MAX_LEN] =\n+const MAX_LEN: usize = 80;\n+\n+static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n     // FIXME #5244: AtomicUsize is not Copy.\n-    [\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-        AtomicUsize::new(0), AtomicUsize::new(0),\n-     ];\n-\n-static creation_count: AtomicUsize = AtomicUsize::new(0);\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+];\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]\n-struct DropCounter { x: u32, creation_id: usize }\n+struct DropCounter {\n+    x: u32,\n+    id: usize,\n+}\n \n impl Drop for DropCounter {\n     fn drop(&mut self) {\n-        drop_counts[self.creation_id].fetch_add(1, Ordering::Relaxed);\n+        DROP_COUNTS[self.id].fetch_add(1, Ordering::Relaxed);\n     }\n }\n \n-pub fn main() {\n-    // len can't go above 64.\n-    for len in 2..MAX_LEN {\n-        for _ in 0..REPEATS {\n-            // reset the count for these new DropCounters, so their\n-            // IDs start from 0.\n-            creation_count.store(0, Ordering::Relaxed);\n+fn test(input: &[DropCounter]) {\n+    let len = input.len();\n \n-            let mut rng = thread_rng();\n-            let main = (0..len).map(|_| {\n-                DropCounter {\n-                    x: rng.next_u32(),\n-                    creation_id: creation_count.fetch_add(1, Ordering::Relaxed),\n-                }\n-            }).collect::<Vec<_>>();\n-\n-            // work out the total number of comparisons required to sort\n-            // this array...\n-            let mut count = 0_usize;\n-            main.clone().sort_by(|a, b| { count += 1; a.cmp(b) });\n-\n-            // ... and then panic on each and every single one.\n-            for panic_countdown in 0..count {\n-                // refresh the counters.\n-                for c in &drop_counts {\n-                    c.store(0, Ordering::Relaxed);\n-                }\n+    // Work out the total number of comparisons required to sort\n+    // this array...\n+    let mut count = 0usize;\n+    input.to_owned().sort_by(|a, b| { count += 1; a.cmp(b) });\n \n-                let v = main.clone();\n-\n-                let _ = thread::spawn(move|| {\n-                    let mut v = v;\n-                    let mut panic_countdown = panic_countdown;\n-                    v.sort_by(|a, b| {\n-                        if panic_countdown == 0 {\n-                            panic!()\n-                        }\n-                        panic_countdown -= 1;\n-                        a.cmp(b)\n-                    })\n-                }).join();\n-\n-                // check that the number of things dropped is exactly\n-                // what we expect (i.e. the contents of `v`).\n-                for (i, c) in drop_counts.iter().enumerate().take(len) {\n-                    let count = c.load(Ordering::Relaxed);\n-                    assert!(count == 1,\n-                            \"found drop count == {} for i == {}, len == {}\",\n-                            count, i, len);\n+    // ... and then panic on each and every single one.\n+    for panic_countdown in 0..count {\n+        // Refresh the counters.\n+        for i in 0..len {\n+            DROP_COUNTS[i].store(0, Ordering::Relaxed);\n+        }\n+\n+        let v = input.to_owned();\n+        let _ = thread::spawn(move || {\n+            let mut v = v;\n+            let mut panic_countdown = panic_countdown;\n+            v.sort_by(|a, b| {\n+                if panic_countdown == 0 {\n+                    panic!();\n                 }\n+                panic_countdown -= 1;\n+                a.cmp(b)\n+            })\n+        }).join();\n+\n+        // Check that the number of things dropped is exactly\n+        // what we expect (i.e. the contents of `v`).\n+        for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+            let count = c.load(Ordering::Relaxed);\n+            assert!(count == 1,\n+                    \"found drop count == {} for i == {}, len == {}\",\n+                    count, i, len);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    for len in (1..20).chain(70..MAX_LEN) {\n+        // Test on a random array.\n+        let mut rng = thread_rng();\n+        let input = (0..len).map(|id| {\n+            DropCounter {\n+                x: rng.next_u32(),\n+                id: id,\n             }\n+        }).collect::<Vec<_>>();\n+        test(&input);\n+\n+        // Test on a sorted array with two elements randomly swapped, creating several natural\n+        // runs of random lengths. Such arrays have very high chances of hitting all code paths in\n+        // the merge procedure.\n+        for _ in 0..5 {\n+            let mut input = (0..len).map(|i|\n+                DropCounter {\n+                    x: i as u32,\n+                    id: i,\n+                }\n+            ).collect::<Vec<_>>();\n+\n+            let a = rng.gen::<usize>() % len;\n+            let b = rng.gen::<usize>() % len;\n+            input.swap(a, b);\n+\n+            test(&input);\n         }\n     }\n }"}]}