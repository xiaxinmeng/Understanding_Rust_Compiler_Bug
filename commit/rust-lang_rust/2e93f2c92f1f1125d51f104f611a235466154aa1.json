{"sha": "2e93f2c92f1f1125d51f104f611a235466154aa1", "node_id": "C_kwDOAAsO6NoAKDJlOTNmMmM5MmYxZjExMjVkNTFmMTA0ZjYxMWEyMzU0NjYxNTRhYTE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-21T03:40:32Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-01-30T01:00:42Z"}, "message": "Allow more deriving on packed structs.\n\nCurrently, deriving on packed structs has some non-trivial limitations,\nrelated to the fact that taking references on unaligned fields is UB.\n\nThe current approach to field accesses in derived code:\n- Normal case: `&self.0`\n- In a packed struct that derives `Copy`: `&{self.0}`\n- In a packed struct that doesn't derive `Copy`: `&self.0`\n\nPlus, we disallow deriving any builtin traits other than `Default` for any\npacked generic type, because it's possible that there might be\nmisaligned fields. This is a fairly broad restriction.\n\nPlus, we disallow deriving any builtin traits other than `Default` for most\npacked types that don't derive `Copy`. (The exceptions are those where the\nalignments inherently satisfy the packing, e.g. in a type with\n`repr(packed(N))` where all the fields have alignments of `N` or less\nanyway. Such types are pretty strange, because the `packed` attribute is\nnot having any effect.)\n\nThis commit introduces a new, simpler approach to field accesses:\n- Normal case: `&self.0`\n- In a packed struct: `&{self.0}`\n\nIn the latter case, this requires that all fields impl `Copy`, which is\na new restriction. This means that the following example compiles under\nthe old approach and doesn't compile under the new approach.\n```\n #[derive(Debug)]\n struct NonCopy(u8);\n\n #[derive(Debug)\n #[repr(packed)]\n struct MyType(NonCopy);\n```\n(Note that the old approach's support for cases like this was brittle.\nChanging the `u8` to a `u16` would be enough to stop it working. So not\nmuch capability is lost here.)\n\nHowever, the other constraints from the old rules are removed. We can now\nderive builtin traits for packed generic structs like this:\n```\n trait Trait { type A; }\n\n #[derive(Hash)]\n #[repr(packed)]\n pub struct Foo<T: Trait>(T, T::A);\n```\nTo allow this, we add a `T: Copy` bound in the derived impl and a `T::A:\nCopy` bound in where clauses. So `T` and `T::A` must impl `Copy`.\n\nWe can now also derive builtin traits for packed structs that don't derive\n`Copy`, so long as the fields impl `Copy`:\n```\n #[derive(Hash)]\n #[repr(packed)]\n pub struct Foo(u32);\n```\nThis includes types that hand-impl `Copy` rather than deriving it, such as the\nfollowing, that show up in winapi-0.2:\n```\n #[derive(Clone)]\n #[repr(packed)]\n struct MyType(i32);\n\n impl Copy for MyType {}\n```\nThe new approach is simpler to understand and implement, and it avoids\nthe need for the `unsafe_derive_on_repr_packed` check.\n\nOne exception is required for backwards-compatibility: we allow `[u8]`\nfields for now. There is a new lint for this,\n`byte_slice_in_packed_struct_with_derive`.", "tree": {"sha": "f1e997c3df2ef243a6804830bdde7733a659ff86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1e997c3df2ef243a6804830bdde7733a659ff86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e93f2c92f1f1125d51f104f611a235466154aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e93f2c92f1f1125d51f104f611a235466154aa1", "html_url": "https://github.com/rust-lang/rust/commit/2e93f2c92f1f1125d51f104f611a235466154aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e93f2c92f1f1125d51f104f611a235466154aa1/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7bf469fecc75792e1598a0842ac40b361f0107b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bf469fecc75792e1598a0842ac40b361f0107b", "html_url": "https://github.com/rust-lang/rust/commit/c7bf469fecc75792e1598a0842ac40b361f0107b"}], "stats": {"total": 1121, "additions": 823, "deletions": 298}, "files": [{"sha": "0481a118906902697eb25900fda82ca07c5c5d6d", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -17,6 +17,7 @@ pub fn expand_deriving_copy(\n         span,\n         path: path_std!(marker::Copy),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: false,\n         additional_bounds: Vec::new(),\n         supports_unions: true,\n         methods: Vec::new(),"}, {"sha": "42f50d8ade2785c2535374a6bb2ccc69bfef2a41", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -73,6 +73,7 @@ pub fn expand_deriving_clone(\n         span,\n         path: path_std!(clone::Clone),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: bounds,\n         supports_unions: true,\n         methods: vec![MethodDef {"}, {"sha": "424719f97954f743b2115600469d96ee80ef7fa5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -27,6 +27,7 @@ pub fn expand_deriving_eq(\n         span,\n         path: path_std!(cmp::Eq),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: true,\n         methods: vec![MethodDef {"}, {"sha": "671f32550d2bbee957dd2775fa0976c1a8cefee7", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -20,6 +20,7 @@ pub fn expand_deriving_ord(\n         span,\n         path: path_std!(cmp::Ord),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "88d454fbc11230f5ad04f55269112bd8789dc1d9", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -84,6 +84,7 @@ pub fn expand_deriving_partial_eq(\n         span,\n         path: path_std!(cmp::PartialEq),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods,"}, {"sha": "bcc90442eb72bb91aef8f06a7cd2830155d881ff", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -59,6 +59,7 @@ pub fn expand_deriving_partial_ord(\n         span,\n         path: path_std!(cmp::PartialOrd),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: vec![],\n         supports_unions: false,\n         methods: vec![partial_cmp_def],"}, {"sha": "897048f64211e37d509d31457f1d71cf4d7edf3f", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -23,6 +23,7 @@ pub fn expand_deriving_debug(\n         span,\n         path: path_std!(fmt::Debug),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "c783e46eda9416ba23bb00a77d536e61d97891af", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -25,6 +25,7 @@ pub fn expand_deriving_rustc_decodable(\n         span,\n         path: Path::new_(vec![krate, sym::Decodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "a6c8b111527a3e241f26e55dfef9fa92ddf533e3", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -25,6 +25,7 @@ pub fn expand_deriving_default(\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),\n         skip_path_as_bound: has_a_default_variant(item),\n+        needs_copy_as_bound_if_packed: false,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "a5e2b599df4e8f0fae48ee2848f6c4bb2a772407", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -109,6 +109,7 @@ pub fn expand_deriving_rustc_encodable(\n         span,\n         path: Path::new_(vec![krate, sym::Encodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "97de40bac34661f12d86e27e12a139ae76ebdd36", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 87, "deletions": 48, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -165,11 +165,12 @@ pub use SubstructureFields::*;\n use crate::deriving;\n use rustc_ast::ptr::P;\n use rustc_ast::{\n-    self as ast, BindingAnnotation, ByRef, EnumDef, Expr, Generics, Mutability, PatKind,\n+    self as ast, BindingAnnotation, ByRef, EnumDef, Expr, GenericArg, GenericParamKind, Generics,\n+    Mutability, PatKind, TyKind, VariantData,\n };\n-use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_session::lint::builtin::BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::RefCell;\n@@ -191,6 +192,9 @@ pub struct TraitDef<'a> {\n     /// Whether to skip adding the current trait as a bound to the type parameters of the type.\n     pub skip_path_as_bound: bool,\n \n+    /// Whether `Copy` is needed as an additional bound on type parameters in a packed struct.\n+    pub needs_copy_as_bound_if_packed: bool,\n+\n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n     pub additional_bounds: Vec<Ty>,\n@@ -455,18 +459,6 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match &item.kind {\n-                    ast::ItemKind::Struct(_, generics)\n-                    | ast::ItemKind::Enum(_, generics)\n-                    | ast::ItemKind::Union(_, generics) => !generics\n-                        .params\n-                        .iter()\n-                        .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n-                    _ => unreachable!(),\n-                };\n-                let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n-                let copy_fields =\n-                    is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n                 let newitem = match &item.kind {\n                     ast::ItemKind::Struct(struct_def, generics) => self.expand_struct_def(\n@@ -475,7 +467,7 @@ impl<'a> TraitDef<'a> {\n                         item.ident,\n                         generics,\n                         from_scratch,\n-                        copy_fields,\n+                        is_packed,\n                     ),\n                     ast::ItemKind::Enum(enum_def, generics) => {\n                         // We ignore `is_packed` here, because `repr(packed)`\n@@ -493,7 +485,7 @@ impl<'a> TraitDef<'a> {\n                                 item.ident,\n                                 generics,\n                                 from_scratch,\n-                                copy_fields,\n+                                is_packed,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -565,6 +557,7 @@ impl<'a> TraitDef<'a> {\n         generics: &Generics,\n         field_tys: Vec<P<ast::Ty>>,\n         methods: Vec<P<ast::AssocItem>>,\n+        is_packed: bool,\n     ) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n@@ -607,20 +600,32 @@ impl<'a> TraitDef<'a> {\n             .map(|param| match &param.kind {\n                 GenericParamKind::Lifetime { .. } => param.clone(),\n                 GenericParamKind::Type { .. } => {\n-                    // I don't think this can be moved out of the loop, since\n-                    // a GenericBound requires an ast id\n-                    let bounds: Vec<_> =\n-                    // extra restrictions on the generics parameters to the\n-                    // type being derived upon\n-                    self.additional_bounds.iter().map(|p| {\n-                        cx.trait_bound(p.to_path(cx, self.span, type_ident, generics))\n-                    }).chain(\n-                        // require the current trait\n-                        self.skip_path_as_bound.not().then(|| cx.trait_bound(trait_path.clone()))\n-                    ).chain(\n-                        // also add in any bounds from the declaration\n-                        param.bounds.iter().cloned()\n-                    ).collect();\n+                    // Extra restrictions on the generics parameters to the\n+                    // type being derived upon.\n+                    let bounds: Vec<_> = self\n+                        .additional_bounds\n+                        .iter()\n+                        .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                        .chain(\n+                            // Add a bound for the current trait.\n+                            self.skip_path_as_bound\n+                                .not()\n+                                .then(|| cx.trait_bound(trait_path.clone())),\n+                        )\n+                        .chain({\n+                            // Add a `Copy` bound if required.\n+                            if is_packed && self.needs_copy_as_bound_if_packed {\n+                                let p = deriving::path_std!(marker::Copy);\n+                                Some(cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .chain(\n+                            // Also add in any bounds from the declaration.\n+                            param.bounds.iter().cloned(),\n+                        )\n+                        .collect();\n \n                     cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, bounds, None)\n                 }\n@@ -692,9 +697,17 @@ impl<'a> TraitDef<'a> {\n                             .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n                             .collect();\n \n-                        // require the current trait\n+                        // Require the current trait.\n                         bounds.push(cx.trait_bound(trait_path.clone()));\n \n+                        // Add a `Copy` bound if required.\n+                        if is_packed && self.needs_copy_as_bound_if_packed {\n+                            let p = deriving::path_std!(marker::Copy);\n+                            bounds.push(\n+                                cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)),\n+                            );\n+                        }\n+\n                         let predicate = ast::WhereBoundPredicate {\n                             span: self.span,\n                             bound_generic_params: field_ty_param.bound_generic_params,\n@@ -762,7 +775,7 @@ impl<'a> TraitDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n-        copy_fields: bool,\n+        is_packed: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -790,7 +803,7 @@ impl<'a> TraitDef<'a> {\n                         type_ident,\n                         &selflike_args,\n                         &nonselflike_args,\n-                        copy_fields,\n+                        is_packed,\n                     )\n                 };\n \n@@ -806,7 +819,7 @@ impl<'a> TraitDef<'a> {\n             })\n             .collect();\n \n-        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods, is_packed)\n     }\n \n     fn expand_enum_def(\n@@ -861,7 +874,8 @@ impl<'a> TraitDef<'a> {\n             })\n             .collect();\n \n-        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n+        let is_packed = false; // enums are never packed\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods, is_packed)\n     }\n }\n \n@@ -1011,8 +1025,8 @@ impl<'a> MethodDef<'a> {\n     /// ```\n     /// But if the struct is `repr(packed)`, we can't use something like\n     /// `&self.x` because that might cause an unaligned ref. So for any trait\n-    /// method that takes a reference, if the struct impls `Copy` then we use a\n-    /// local block to force a copy:\n+    /// method that takes a reference, we use a local block to force a copy.\n+    /// This requires that the field impl `Copy`.\n     /// ```\n     /// # struct A { x: u8, y: u8 }\n     /// impl PartialEq for A {\n@@ -1027,10 +1041,6 @@ impl<'a> MethodDef<'a> {\n     ///         ::core::hash::Hash::hash(&{ self.y }, state)\n     ///     }\n     /// }\n-    /// ```\n-    /// If the struct doesn't impl `Copy`, we use the normal `&self.x`. This\n-    /// only works if the fields match the alignment required by the\n-    /// `packed(N)` attribute. (We'll get errors later on if not.)\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1039,12 +1049,12 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         selflike_args: &[P<Expr>],\n         nonselflike_args: &[P<Expr>],\n-        copy_fields: bool,\n+        is_packed: bool,\n     ) -> BlockOrExpr {\n         assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n \n         let selflike_fields =\n-            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, copy_fields);\n+            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, is_packed);\n         self.call_substructure_method(\n             cx,\n             trait_,\n@@ -1514,7 +1524,7 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         selflike_args: &[P<Expr>],\n         struct_def: &'a VariantData,\n-        copy_fields: bool,\n+        is_packed: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n@@ -1533,10 +1543,39 @@ impl<'a> TraitDef<'a> {\n                             }),\n                         ),\n                     );\n-                    if copy_fields {\n-                        field_expr = cx.expr_block(\n-                            cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n-                        );\n+                    // In general, fields in packed structs are copied via a\n+                    // block, e.g. `&{self.0}`. The one exception is `[u8]`\n+                    // fields, which cannot be copied and also never cause\n+                    // unaligned references. This exception is allowed to\n+                    // handle the `FlexZeroSlice` type in the `zerovec` crate\n+                    // within `icu4x-0.9.0`.\n+                    //\n+                    // Once use of `icu4x-0.9.0` has dropped sufficiently, this\n+                    // exception should be removed.\n+                    let is_u8_slice = if let TyKind::Slice(ty) = &struct_field.ty.kind &&\n+                        let TyKind::Path(None, rustc_ast::Path { segments, .. }) = &ty.kind &&\n+                        let [seg] = segments.as_slice() &&\n+                        seg.ident.name == sym::u8 && seg.args.is_none()\n+                    {\n+                        true\n+                    } else {\n+                        false\n+                    };\n+                    if is_packed {\n+                        if is_u8_slice {\n+                            cx.sess.parse_sess.buffer_lint_with_diagnostic(\n+                                BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n+                                sp,\n+                                ast::CRATE_NODE_ID,\n+                                \"byte slice in a packed struct that derives a built-in trait\",\n+                                rustc_lint_defs::BuiltinLintDiagnostics::ByteSliceInPackedStructWithDerive\n+                            );\n+                        } else {\n+                            // Wrap the expression in `{...}`, causing a copy.\n+                            field_expr = cx.expr_block(\n+                                cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n+                            );\n+                        }\n                     }\n                     cx.expr_addr_of(sp, field_expr)\n                 })"}, {"sha": "5c2e89c5697b2776478d0dd5c707d15d957bfa0c", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -24,6 +24,7 @@ pub fn expand_deriving_hash(\n         span,\n         path,\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "d1d4bb375282f004673fb63bf2141c002f7b9956", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -882,6 +882,9 @@ pub trait LintContext: Sized {\n                         );\n                     }\n                 }\n+                BuiltinLintDiagnostics::ByteSliceInPackedStructWithDerive => {\n+                    db.help(\"consider implementing the trait by hand, or remove the `packed` attribute\");\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(db)"}, {"sha": "4438639d635283aa27119116e5d66689749adfdb", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -3381,6 +3381,7 @@ declare_lint_pass! {\n         REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n         NAMED_ARGUMENTS_USED_POSITIONALLY,\n         IMPLIED_BOUNDS_ENTAILMENT,\n+        BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n     ]\n }\n \n@@ -4109,3 +4110,35 @@ declare_lint! {\n         reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }\n+\n+declare_lint! {\n+    /// The `byte_slice_in_packed_struct_with_derive` lint detects cases where a byte slice field\n+    /// (`[u8]`) is used in a `packed` struct that derives one or more built-in traits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[repr(packed)]\n+    /// #[derive(Hash)]\n+    /// struct FlexZeroSlice {\n+    ///     width: u8,\n+    ///     data: [u8],\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This was previously accepted but is being phased out, because fields in packed structs are\n+    /// now required to implement `Copy` for `derive` to work. Byte slices are a temporary\n+    /// exception because certain crates depended on them.\n+    pub BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n+    Warn,\n+    \"`[u8]` slice used in a packed struct with `derive`\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #107457 <https://github.com/rust-lang/rust/issues/107457>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n+    };\n+    report_in_external_macro\n+}"}, {"sha": "6efbf5ce9eef308fa1100512b6f76ea6fc583bdf", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -521,6 +521,7 @@ pub enum BuiltinLintDiagnostics {\n         /// Indicates if the named argument is used as a width/precision for formatting\n         is_formatting_arg: bool,\n     },\n+    ByteSliceInPackedStructWithDerive,\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "fd1e2c072de348492151d7888321a17e51c5d85f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -807,15 +807,6 @@ rustc_queries! {\n         }\n     }\n \n-    /// HACK: when evaluated, this reports an \"unsafe derive on repr(packed)\" error.\n-    ///\n-    /// Unsafety checking is executed for each method separately, but we only want\n-    /// to emit this error once per derive. As there are some impls with multiple\n-    /// methods, we use a query for deduplication.\n-    query unsafe_derive_on_repr_packed(key: LocalDefId) -> () {\n-        desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n-    }\n-\n     /// Returns the types assumed to be well formed while \"inside\" of the given item.\n     ///\n     /// Note that we've liberated the late bound regions of function signatures, so"}, {"sha": "3e7571aa7a2e7f303fa0e02cc6fbd1f51f7906ac", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -1,17 +1,11 @@\n-use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::UNALIGNED_REFERENCES;\n \n use crate::util;\n use crate::MirLint;\n \n-pub(crate) fn provide(providers: &mut Providers) {\n-    *providers = Providers { unsafe_derive_on_repr_packed, ..*providers };\n-}\n-\n pub struct CheckPackedRef;\n \n impl<'tcx> MirLint<'tcx> for CheckPackedRef {\n@@ -30,32 +24,6 @@ struct PackedRefChecker<'a, 'tcx> {\n     source_info: SourceInfo,\n }\n \n-fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-    // FIXME: when we make this a hard error, this should have its\n-    // own error code.\n-\n-    let extra = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-        \"with type or const parameters\"\n-    } else {\n-        \"that does not derive `Copy`\"\n-    };\n-    let message = format!(\n-        \"`{}` can't be derived on this `#[repr(packed)]` struct {}\",\n-        tcx.item_name(tcx.trait_id_of_impl(def_id.to_def_id()).expect(\"derived trait name\")),\n-        extra\n-    );\n-\n-    tcx.struct_span_lint_hir(\n-        UNALIGNED_REFERENCES,\n-        lint_hir_id,\n-        tcx.def_span(def_id),\n-        message,\n-        |lint| lint,\n-    );\n-}\n-\n impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         // Make sure we know where in the MIR we are.\n@@ -73,14 +41,13 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 let def_id = self.body.source.instance.def_id();\n-                if let Some(impl_def_id) = self\n-                    .tcx\n-                    .impl_of_method(def_id)\n-                    .filter(|&def_id| self.tcx.is_builtin_derive(def_id))\n+                if let Some(impl_def_id) = self.tcx.impl_of_method(def_id)\n+                    && self.tcx.is_builtin_derive(impl_def_id)\n                 {\n-                    // If a method is defined in the local crate,\n-                    // the impl containing that method should also be.\n-                    self.tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n+                    // If we ever reach here it means that the generated derive\n+                    // code is somehow doing an unaligned reference, which it\n+                    // shouldn't do.\n+                    unreachable!();\n                 } else {\n                     let source_info = self.source_info;\n                     let lint_root = self.body.source_scopes[source_info.scope]"}, {"sha": "3d9137fa10253cc4934c3f2f8e4d0aa19be96315", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -104,7 +104,6 @@ use rustc_mir_dataflow::rustc_peek;\n \n pub fn provide(providers: &mut Providers) {\n     check_unsafety::provide(providers);\n-    check_packed_ref::provide(providers);\n     coverage::query::provide(providers);\n     ffi_unwind_calls::provide(providers);\n     shim::provide(providers);"}, {"sha": "cbd7432fce4eef79529e3b62ca2dda5fbedda08e", "filename": "tests/ui/derives/deriving-with-repr-packed-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-with-repr-packed-2.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -0,0 +1,22 @@\n+#![deny(unaligned_references)]\n+\n+// Check that deriving certain builtin traits on certain packed structs cause\n+// errors. To avoid potentially misaligned references, field copies must be\n+// used, which involves adding `T: Copy` bounds.\n+\n+#[derive(Copy, Clone, Default, PartialEq, Eq)]\n+#[repr(packed)]\n+pub struct Foo<T>(T, T, T);\n+\n+struct NonCopy;\n+\n+fn main() {\n+    // This one is fine because `u32` impls `Copy`.\n+    let x: Foo<u32> = Foo(1, 2, 3);\n+    _ = x.clone();\n+\n+    // This one is an error because `NonCopy` doesn't impl `Copy`.\n+    let x: Foo<NonCopy> = Foo(NonCopy, NonCopy, NonCopy);\n+    _ = x.clone();\n+    //~^ ERROR the method `clone` exists for struct `Foo<NonCopy>`, but its trait bounds were not satisfied\n+}"}, {"sha": "83540739ee3d9391c7709548d33b90ff35b472ee", "filename": "tests/ui/derives/deriving-with-repr-packed-2.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-with-repr-packed-2.stderr?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -0,0 +1,33 @@\n+error[E0599]: the method `clone` exists for struct `Foo<NonCopy>`, but its trait bounds were not satisfied\n+  --> $DIR/deriving-with-repr-packed-2.rs:20:11\n+   |\n+LL | pub struct Foo<T>(T, T, T);\n+   | -----------------\n+   | |\n+   | method `clone` not found for this struct\n+   | doesn't satisfy `Foo<NonCopy>: Clone`\n+LL |\n+LL | struct NonCopy;\n+   | --------------\n+   | |\n+   | doesn't satisfy `NonCopy: Clone`\n+   | doesn't satisfy `NonCopy: Copy`\n+...\n+LL |     _ = x.clone();\n+   |           ^^^^^ method cannot be called on `Foo<NonCopy>` due to unsatisfied trait bounds\n+   |\n+note: the following trait bounds were not satisfied:\n+      `NonCopy: Clone`\n+      `NonCopy: Copy`\n+  --> $DIR/deriving-with-repr-packed-2.rs:7:16\n+   |\n+LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n+   |                ^^^^^ unsatisfied trait bound introduced in this `derive` macro\n+help: consider annotating `NonCopy` with `#[derive(Clone, Copy)]`\n+   |\n+LL | #[derive(Clone, Copy)]\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "eddf41f55536e4e7ecb5ceeff537a22fd7910b84", "filename": "tests/ui/derives/deriving-with-repr-packed.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -1,45 +1,38 @@\n #![deny(unaligned_references)]\n \n // Check that deriving certain builtin traits on certain packed structs cause\n-// errors. This happens when the derived trait would need to use a potentially\n-// misaligned reference. But there are two cases that are allowed:\n-// - If all the fields within the struct meet the required alignment: 1 for\n-//   `repr(packed)`, or `N` for `repr(packed(N))`.\n-// - If `Default` is the only trait derived, because it doesn't involve any\n-//   references.\n+// errors. To avoid potentially misaligned references, field copies must be\n+// used, which involves adding `T: Copy` bounds.\n \n #[derive(Copy, Clone, Default, PartialEq, Eq)]\n-//~^ ERROR `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n-//~| hard error\n-//~^^^ ERROR `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n-//~| hard error\n #[repr(packed)]\n pub struct Foo<T>(T, T, T);\n \n+// This one is fine because the fields all impl `Copy`.\n #[derive(Default, Hash)]\n-//~^ ERROR `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n-//~| hard error\n #[repr(packed)]\n pub struct Bar(u32, u32, u32);\n \n-// This one is fine because the field alignment is 1.\n-#[derive(Default, Hash)]\n-#[repr(packed)]\n-pub struct Bar2(u8, i8, bool);\n-\n-// This one is fine because the field alignment is 2, matching `packed(2)`.\n-#[derive(Default, Hash)]\n-#[repr(packed(2))]\n-pub struct Bar3(u16, i16, bool);\n-\n // This one is fine because it's not packed.\n #[derive(Debug, Default)]\n struct Y(usize);\n \n+// This one has an error because `Y` doesn't impl `Copy`.\n+// Note: there is room for improvement in the error message.\n #[derive(Debug, Default)]\n-//~^ ERROR `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n-//~| hard error\n #[repr(packed)]\n struct X(Y);\n+//~^ ERROR cannot move out of `self` which is behind a shared reference\n+\n+// This is currently allowed, but will be phased out at some point. From\n+// `zerovec` within icu4x-0.9.0.\n+#[derive(Debug)]\n+#[repr(packed)]\n+struct FlexZeroSlice {\n+    width: u8,\n+    data: [u8],\n+    //~^ WARNING byte slice in a packed struct that derives a built-in trait\n+    //~^^ this was previously accepted\n+}\n \n fn main() {}"}, {"sha": "2cb2a696d9742ffe3357c0c7892ade4838bd01ff", "filename": "tests/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 30, "deletions": 96, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -1,111 +1,45 @@\n-error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n-  --> $DIR/deriving-with-repr-packed.rs:11:16\n+warning: byte slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-with-repr-packed.rs:33:5\n    |\n-LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n-   |                ^^^^^\n+LL | #[derive(Debug)]\n+   |          ----- in this derive macro expansion\n+...\n+LL |     data: [u8],\n+   |     ^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-note: the lint level is defined here\n-  --> $DIR/deriving-with-repr-packed.rs:1:9\n-   |\n-LL | #![deny(unaligned_references)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n-  --> $DIR/deriving-with-repr-packed.rs:11:32\n-   |\n-LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n-   |                                ^^^^^^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n-  --> $DIR/deriving-with-repr-packed.rs:19:19\n-   |\n-LL | #[derive(Default, Hash)]\n-   |                   ^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-   = note: this error originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n+   = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n-  --> $DIR/deriving-with-repr-packed.rs:39:10\n+error[E0507]: cannot move out of `self` which is behind a shared reference\n+  --> $DIR/deriving-with-repr-packed.rs:24:10\n    |\n LL | #[derive(Debug, Default)]\n-   |          ^^^^^\n+   |          ----- in this derive macro expansion\n+LL | #[repr(packed)]\n+LL | struct X(Y);\n+   |          ^ move occurs because `self.0` has type `Y`, which does not implement the `Copy` trait\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: aborting due to previous error; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0507`.\n Future incompatibility report: Future breakage diagnostic:\n-error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n-  --> $DIR/deriving-with-repr-packed.rs:11:16\n-   |\n-LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n-   |                ^^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-note: the lint level is defined here\n-  --> $DIR/deriving-with-repr-packed.rs:1:9\n-   |\n-LL | #![deny(unaligned_references)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-Future breakage diagnostic:\n-error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n-  --> $DIR/deriving-with-repr-packed.rs:11:32\n-   |\n-LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n-   |                                ^^^^^^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-note: the lint level is defined here\n-  --> $DIR/deriving-with-repr-packed.rs:1:9\n-   |\n-LL | #![deny(unaligned_references)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-Future breakage diagnostic:\n-error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n-  --> $DIR/deriving-with-repr-packed.rs:19:19\n-   |\n-LL | #[derive(Default, Hash)]\n-   |                   ^^^^\n+warning: byte slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-with-repr-packed.rs:33:5\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-note: the lint level is defined here\n-  --> $DIR/deriving-with-repr-packed.rs:1:9\n-   |\n-LL | #![deny(unaligned_references)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-Future breakage diagnostic:\n-error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n-  --> $DIR/deriving-with-repr-packed.rs:39:10\n-   |\n-LL | #[derive(Debug, Default)]\n-   |          ^^^^^\n+LL | #[derive(Debug)]\n+   |          ----- in this derive macro expansion\n+...\n+LL |     data: [u8],\n+   |     ^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n-note: the lint level is defined here\n-  --> $DIR/deriving-with-repr-packed.rs:1:9\n-   |\n-LL | #![deny(unaligned_references)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n+   = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "51f9708d3cd629518734df9d0dc9d80473430de7", "filename": "tests/ui/deriving/deriving-all-codegen.rs", "status": "modified", "additions": 72, "deletions": 13, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.rs?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -21,36 +21,88 @@\n #[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n struct Empty;\n \n-// A basic struct.\n+// A basic struct. Note: because this derives `Copy`, it gets the simple\n+// `clone` implemention that just does `*self`.\n #[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n struct Point {\n     x: u32,\n     y: u32,\n }\n \n-// A large struct.\n-#[derive(Clone, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+// A basic packed struct. Note: because this derives `Copy`, it gets the simple\n+// `clone` implemention that just does `*self`.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+#[repr(packed)]\n+struct PackedPoint {\n+    x: u32,\n+    y: u32,\n+}\n+\n+// A large struct. Note: because this derives `Copy`, it gets the simple\n+// `clone` implemention that just does `*self`.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n struct Big {\n     b1: u32, b2: u32, b3: u32, b4: u32, b5: u32, b6: u32, b7: u32, b8: u32,\n }\n \n+// A struct that doesn't impl `Copy`, which means it gets the non-simple\n+// `clone` implemention that clones the fields individually.\n+#[derive(Clone)]\n+struct NonCopy(u32);\n+\n+// A packed struct that doesn't impl `Copy`, which means it gets the non-simple\n+// `clone` implemention that clones the fields individually.\n+#[derive(Clone)]\n+#[repr(packed)]\n+struct PackedNonCopy(u32);\n+\n+// A struct that impls `Copy` manually, which means it gets the non-simple\n+// `clone` implemention that clones the fields individually.\n+#[derive(Clone)]\n+struct ManualCopy(u32);\n+impl Copy for ManualCopy {}\n+\n+// A packed struct that impls `Copy` manually, which means it gets the\n+// non-simple `clone` implemention that clones the fields individually.\n+#[derive(Clone)]\n+#[repr(packed)]\n+struct PackedManualCopy(u32);\n+impl Copy for PackedManualCopy {}\n+\n // A struct with an unsized field. Some derives are not usable in this case.\n #[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n struct Unsized([u32]);\n \n-// A packed tuple struct that impls `Copy`.\n-#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+// A packed struct with an unsized `[u8]` field. This is currently allowed, but\n+// causes a warning and will be phased out at some point.\n+#[derive(Debug, Hash)]\n #[repr(packed)]\n-struct PackedCopy(u32);\n+struct PackedUnsizedU8([u8]);\n+//~^ WARNING byte slice in a packed struct that derives a built-in trait\n+//~^^ WARNING byte slice in a packed struct that derives a built-in trait\n+//~^^^ this was previously accepted\n+//~^^^^ this was previously accepted\n \n-// A packed tuple struct that does not impl `Copy`. Note that the alignment of\n-// the field must be 1 for this code to be valid. Otherwise it triggers an\n-// error \"`#[derive]` can't be used on a `#[repr(packed)]` struct that does not\n-// derive Copy (error E0133)\" at MIR building time. This is a weird case and\n-// it's possible that this struct is not supposed to work, but for now it does.\n-#[derive(Clone, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+trait Trait {\n+    type A;\n+}\n+\n+// A generic struct involving an associated type.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+struct Generic<T: Trait, U> {\n+    t: T,\n+    ta: T::A,\n+    u: U,\n+}\n+\n+// A packed, generic tuple struct involving an associated type. Because it is\n+// packed, a `T: Copy` bound is added to all impls (and where clauses within\n+// them) except for `Default`. This is because we must access fields using\n+// copies (e.g. `&{self.0}`), instead of using direct references (e.g.\n+// `&self.0`) which may be misaligned in a packed struct.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n #[repr(packed)]\n-struct PackedNonCopy(u8);\n+struct PackedGeneric<T: Trait, U>(T, T::A, U);\n \n // An empty enum.\n #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n@@ -97,6 +149,13 @@ enum Fielded {\n     Z(Option<i32>),\n }\n \n+// A generic enum. Note that `Default` cannot be derived for this enum.\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum EnumGeneric<T, U> {\n+    One(T),\n+    Two(U),\n+}\n+\n // A union. Most builtin traits are not derivable for unions.\n #[derive(Clone, Copy)]\n pub union Union {"}, {"sha": "503f0cae73b6946741aa7edb51f38a59f27e8568", "filename": "tests/ui/deriving/deriving-all-codegen.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stderr?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -0,0 +1,63 @@\n+warning: byte slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-all-codegen.rs:80:24\n+   |\n+LL | #[derive(Debug, Hash)]\n+   |          ----- in this derive macro expansion\n+LL | #[repr(packed)]\n+LL | struct PackedUnsizedU8([u8]);\n+   |                        ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n+   = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: byte slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-all-codegen.rs:80:24\n+   |\n+LL | #[derive(Debug, Hash)]\n+   |                 ---- in this derive macro expansion\n+LL | #[repr(packed)]\n+LL | struct PackedUnsizedU8([u8]);\n+   |                        ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: this warning originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: 2 warnings emitted\n+\n+Future incompatibility report: Future breakage diagnostic:\n+warning: byte slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-all-codegen.rs:80:24\n+   |\n+LL | #[derive(Debug, Hash)]\n+   |          ----- in this derive macro expansion\n+LL | #[repr(packed)]\n+LL | struct PackedUnsizedU8([u8]);\n+   |                        ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n+   = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: byte slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-all-codegen.rs:80:24\n+   |\n+LL | #[derive(Debug, Hash)]\n+   |                 ---- in this derive macro expansion\n+LL | #[repr(packed)]\n+LL | struct PackedUnsizedU8([u8]);\n+   |                        ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n+   = note: this warning originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "b4874cef134f77df98fd94427bf3a878021c54bf", "filename": "tests/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 445, "deletions": 68, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2e93f2c92f1f1125d51f104f611a235466154aa1/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=2e93f2c92f1f1125d51f104f611a235466154aa1", "patch": "@@ -78,7 +78,8 @@ impl ::core::cmp::Ord for Empty {\n     }\n }\n \n-// A basic struct.\n+// A basic struct. Note: because this derives `Copy`, it gets the simple\n+// `clone` implemention that just does `*self`.\n struct Point {\n     x: u32,\n     y: u32,\n@@ -161,7 +162,95 @@ impl ::core::cmp::Ord for Point {\n     }\n }\n \n-// A large struct.\n+// A basic packed struct. Note: because this derives `Copy`, it gets the simple\n+// `clone` implemention that just does `*self`.\n+#[repr(packed)]\n+struct PackedPoint {\n+    x: u32,\n+    y: u32,\n+}\n+#[automatically_derived]\n+impl ::core::clone::Clone for PackedPoint {\n+    #[inline]\n+    fn clone(&self) -> PackedPoint {\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n+    }\n+}\n+#[automatically_derived]\n+impl ::core::marker::Copy for PackedPoint { }\n+#[automatically_derived]\n+impl ::core::fmt::Debug for PackedPoint {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        ::core::fmt::Formatter::debug_struct_field2_finish(f, \"PackedPoint\",\n+            \"x\", &&{ self.x }, \"y\", &&{ self.y })\n+    }\n+}\n+#[automatically_derived]\n+impl ::core::default::Default for PackedPoint {\n+    #[inline]\n+    fn default() -> PackedPoint {\n+        PackedPoint {\n+            x: ::core::default::Default::default(),\n+            y: ::core::default::Default::default(),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+impl ::core::hash::Hash for PackedPoint {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        ::core::hash::Hash::hash(&{ self.x }, state);\n+        ::core::hash::Hash::hash(&{ self.y }, state)\n+    }\n+}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for PackedPoint { }\n+#[automatically_derived]\n+impl ::core::cmp::PartialEq for PackedPoint {\n+    #[inline]\n+    fn eq(&self, other: &PackedPoint) -> bool {\n+        { self.x } == { other.x } && { self.y } == { other.y }\n+    }\n+}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for PackedPoint { }\n+#[automatically_derived]\n+impl ::core::cmp::Eq for PackedPoint {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+    }\n+}\n+#[automatically_derived]\n+impl ::core::cmp::PartialOrd for PackedPoint {\n+    #[inline]\n+    fn partial_cmp(&self, other: &PackedPoint)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match ::core::cmp::PartialOrd::partial_cmp(&{ self.x }, &{ other.x })\n+            {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+                ::core::cmp::PartialOrd::partial_cmp(&{ self.y },\n+                    &{ other.y }),\n+            cmp => cmp,\n+        }\n+    }\n+}\n+#[automatically_derived]\n+impl ::core::cmp::Ord for PackedPoint {\n+    #[inline]\n+    fn cmp(&self, other: &PackedPoint) -> ::core::cmp::Ordering {\n+        match ::core::cmp::Ord::cmp(&{ self.x }, &{ other.x }) {\n+            ::core::cmp::Ordering::Equal =>\n+                ::core::cmp::Ord::cmp(&{ self.y }, &{ other.y }),\n+            cmp => cmp,\n+        }\n+    }\n+}\n+\n+// A large struct. Note: because this derives `Copy`, it gets the simple\n+// `clone` implemention that just does `*self`.\n struct Big {\n     b1: u32,\n     b2: u32,\n@@ -176,19 +265,13 @@ struct Big {\n impl ::core::clone::Clone for Big {\n     #[inline]\n     fn clone(&self) -> Big {\n-        Big {\n-            b1: ::core::clone::Clone::clone(&self.b1),\n-            b2: ::core::clone::Clone::clone(&self.b2),\n-            b3: ::core::clone::Clone::clone(&self.b3),\n-            b4: ::core::clone::Clone::clone(&self.b4),\n-            b5: ::core::clone::Clone::clone(&self.b5),\n-            b6: ::core::clone::Clone::clone(&self.b6),\n-            b7: ::core::clone::Clone::clone(&self.b7),\n-            b8: ::core::clone::Clone::clone(&self.b8),\n-        }\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n     }\n }\n #[automatically_derived]\n+impl ::core::marker::Copy for Big { }\n+#[automatically_derived]\n impl ::core::fmt::Debug for Big {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         let names: &'static _ =\n@@ -336,6 +419,54 @@ impl ::core::cmp::Ord for Big {\n     }\n }\n \n+// A struct that doesn't impl `Copy`, which means it gets the non-simple\n+// `clone` implemention that clones the fields individually.\n+struct NonCopy(u32);\n+#[automatically_derived]\n+impl ::core::clone::Clone for NonCopy {\n+    #[inline]\n+    fn clone(&self) -> NonCopy {\n+        NonCopy(::core::clone::Clone::clone(&self.0))\n+    }\n+}\n+\n+// A packed struct that doesn't impl `Copy`, which means it gets the non-simple\n+// `clone` implemention that clones the fields individually.\n+#[repr(packed)]\n+struct PackedNonCopy(u32);\n+#[automatically_derived]\n+impl ::core::clone::Clone for PackedNonCopy {\n+    #[inline]\n+    fn clone(&self) -> PackedNonCopy {\n+        PackedNonCopy(::core::clone::Clone::clone(&{ self.0 }))\n+    }\n+}\n+\n+// A struct that impls `Copy` manually, which means it gets the non-simple\n+// `clone` implemention that clones the fields individually.\n+struct ManualCopy(u32);\n+#[automatically_derived]\n+impl ::core::clone::Clone for ManualCopy {\n+    #[inline]\n+    fn clone(&self) -> ManualCopy {\n+        ManualCopy(::core::clone::Clone::clone(&self.0))\n+    }\n+}\n+impl Copy for ManualCopy {}\n+\n+// A packed struct that impls `Copy` manually, which means it gets the\n+// non-simple `clone` implemention that clones the fields individually.\n+#[repr(packed)]\n+struct PackedManualCopy(u32);\n+#[automatically_derived]\n+impl ::core::clone::Clone for PackedManualCopy {\n+    #[inline]\n+    fn clone(&self) -> PackedManualCopy {\n+        PackedManualCopy(::core::clone::Clone::clone(&{ self.0 }))\n+    }\n+}\n+impl Copy for PackedManualCopy {}\n+\n // A struct with an unsized field. Some derives are not usable in this case.\n struct Unsized([u32]);\n #[automatically_derived]\n@@ -385,138 +516,265 @@ impl ::core::cmp::Ord for Unsized {\n     }\n }\n \n-// A packed tuple struct that impls `Copy`.\n+// A packed struct with an unsized `[u8]` field. This is currently allowed, but\n+// causes a warning and will be phased out at some point.\n #[repr(packed)]\n-struct PackedCopy(u32);\n+struct PackedUnsizedU8([u8]);\n+#[automatically_derived]\n+impl ::core::fmt::Debug for PackedUnsizedU8 {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        ::core::fmt::Formatter::debug_tuple_field1_finish(f,\n+            \"PackedUnsizedU8\", &&self.0)\n+    }\n+}\n #[automatically_derived]\n-impl ::core::clone::Clone for PackedCopy {\n+impl ::core::hash::Hash for PackedUnsizedU8 {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        ::core::hash::Hash::hash(&self.0, state)\n+    }\n+}\n+\n+trait Trait {\n+    type A;\n+}\n+\n+// A generic struct involving an associated type.\n+struct Generic<T: Trait, U> {\n+    t: T,\n+    ta: T::A,\n+    u: U,\n+}\n+#[automatically_derived]\n+impl<T: ::core::clone::Clone + Trait, U: ::core::clone::Clone>\n+    ::core::clone::Clone for Generic<T, U> where T::A: ::core::clone::Clone {\n     #[inline]\n-    fn clone(&self) -> PackedCopy {\n-        let _: ::core::clone::AssertParamIsClone<u32>;\n-        *self\n+    fn clone(&self) -> Generic<T, U> {\n+        Generic {\n+            t: ::core::clone::Clone::clone(&self.t),\n+            ta: ::core::clone::Clone::clone(&self.ta),\n+            u: ::core::clone::Clone::clone(&self.u),\n+        }\n     }\n }\n #[automatically_derived]\n-impl ::core::marker::Copy for PackedCopy { }\n+impl<T: ::core::marker::Copy + Trait, U: ::core::marker::Copy>\n+    ::core::marker::Copy for Generic<T, U> where T::A: ::core::marker::Copy {\n+}\n #[automatically_derived]\n-impl ::core::fmt::Debug for PackedCopy {\n+impl<T: ::core::fmt::Debug + Trait, U: ::core::fmt::Debug> ::core::fmt::Debug\n+    for Generic<T, U> where T::A: ::core::fmt::Debug {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedCopy\",\n-            &&{ self.0 })\n+        ::core::fmt::Formatter::debug_struct_field3_finish(f, \"Generic\", \"t\",\n+            &&self.t, \"ta\", &&self.ta, \"u\", &&self.u)\n     }\n }\n #[automatically_derived]\n-impl ::core::default::Default for PackedCopy {\n+impl<T: ::core::default::Default + Trait, U: ::core::default::Default>\n+    ::core::default::Default for Generic<T, U> where\n+    T::A: ::core::default::Default {\n     #[inline]\n-    fn default() -> PackedCopy {\n-        PackedCopy(::core::default::Default::default())\n+    fn default() -> Generic<T, U> {\n+        Generic {\n+            t: ::core::default::Default::default(),\n+            ta: ::core::default::Default::default(),\n+            u: ::core::default::Default::default(),\n+        }\n     }\n }\n #[automatically_derived]\n-impl ::core::hash::Hash for PackedCopy {\n+impl<T: ::core::hash::Hash + Trait, U: ::core::hash::Hash> ::core::hash::Hash\n+    for Generic<T, U> where T::A: ::core::hash::Hash {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        ::core::hash::Hash::hash(&{ self.0 }, state)\n+        ::core::hash::Hash::hash(&self.t, state);\n+        ::core::hash::Hash::hash(&self.ta, state);\n+        ::core::hash::Hash::hash(&self.u, state)\n     }\n }\n #[automatically_derived]\n-impl ::core::marker::StructuralPartialEq for PackedCopy { }\n+impl<T: Trait, U> ::core::marker::StructuralPartialEq for Generic<T, U> { }\n #[automatically_derived]\n-impl ::core::cmp::PartialEq for PackedCopy {\n+impl<T: ::core::cmp::PartialEq + Trait, U: ::core::cmp::PartialEq>\n+    ::core::cmp::PartialEq for Generic<T, U> where\n+    T::A: ::core::cmp::PartialEq {\n     #[inline]\n-    fn eq(&self, other: &PackedCopy) -> bool { { self.0 } == { other.0 } }\n+    fn eq(&self, other: &Generic<T, U>) -> bool {\n+        self.t == other.t && self.ta == other.ta && self.u == other.u\n+    }\n }\n #[automatically_derived]\n-impl ::core::marker::StructuralEq for PackedCopy { }\n+impl<T: Trait, U> ::core::marker::StructuralEq for Generic<T, U> { }\n #[automatically_derived]\n-impl ::core::cmp::Eq for PackedCopy {\n+impl<T: ::core::cmp::Eq + Trait, U: ::core::cmp::Eq> ::core::cmp::Eq for\n+    Generic<T, U> where T::A: ::core::cmp::Eq {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<T>;\n+        let _: ::core::cmp::AssertParamIsEq<T::A>;\n+        let _: ::core::cmp::AssertParamIsEq<U>;\n     }\n }\n #[automatically_derived]\n-impl ::core::cmp::PartialOrd for PackedCopy {\n+impl<T: ::core::cmp::PartialOrd + Trait, U: ::core::cmp::PartialOrd>\n+    ::core::cmp::PartialOrd for Generic<T, U> where\n+    T::A: ::core::cmp::PartialOrd {\n     #[inline]\n-    fn partial_cmp(&self, other: &PackedCopy)\n+    fn partial_cmp(&self, other: &Generic<T, U>)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        ::core::cmp::PartialOrd::partial_cmp(&{ self.0 }, &{ other.0 })\n+        match ::core::cmp::PartialOrd::partial_cmp(&self.t, &other.t) {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+                match ::core::cmp::PartialOrd::partial_cmp(&self.ta,\n+                        &other.ta) {\n+                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                        => ::core::cmp::PartialOrd::partial_cmp(&self.u, &other.u),\n+                    cmp => cmp,\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n #[automatically_derived]\n-impl ::core::cmp::Ord for PackedCopy {\n+impl<T: ::core::cmp::Ord + Trait, U: ::core::cmp::Ord> ::core::cmp::Ord for\n+    Generic<T, U> where T::A: ::core::cmp::Ord {\n     #[inline]\n-    fn cmp(&self, other: &PackedCopy) -> ::core::cmp::Ordering {\n-        ::core::cmp::Ord::cmp(&{ self.0 }, &{ other.0 })\n+    fn cmp(&self, other: &Generic<T, U>) -> ::core::cmp::Ordering {\n+        match ::core::cmp::Ord::cmp(&self.t, &other.t) {\n+            ::core::cmp::Ordering::Equal =>\n+                match ::core::cmp::Ord::cmp(&self.ta, &other.ta) {\n+                    ::core::cmp::Ordering::Equal =>\n+                        ::core::cmp::Ord::cmp(&self.u, &other.u),\n+                    cmp => cmp,\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n \n-// A packed tuple struct that does not impl `Copy`. Note that the alignment of\n-// the field must be 1 for this code to be valid. Otherwise it triggers an\n-// error \"`#[derive]` can't be used on a `#[repr(packed)]` struct that does not\n-// derive Copy (error E0133)\" at MIR building time. This is a weird case and\n-// it's possible that this struct is not supposed to work, but for now it does.\n+// A packed, generic tuple struct involving an associated type. Because it is\n+// packed, a `T: Copy` bound is added to all impls (and where clauses within\n+// them) except for `Default`. This is because we must access fields using\n+// copies (e.g. `&{self.0}`), instead of using direct references (e.g.\n+// `&self.0`) which may be misaligned in a packed struct.\n #[repr(packed)]\n-struct PackedNonCopy(u8);\n+struct PackedGeneric<T: Trait, U>(T, T::A, U);\n #[automatically_derived]\n-impl ::core::clone::Clone for PackedNonCopy {\n+impl<T: ::core::clone::Clone + ::core::marker::Copy + Trait,\n+    U: ::core::clone::Clone + ::core::marker::Copy> ::core::clone::Clone for\n+    PackedGeneric<T, U> where T::A: ::core::clone::Clone +\n+    ::core::marker::Copy {\n     #[inline]\n-    fn clone(&self) -> PackedNonCopy {\n-        PackedNonCopy(::core::clone::Clone::clone(&self.0))\n+    fn clone(&self) -> PackedGeneric<T, U> {\n+        PackedGeneric(::core::clone::Clone::clone(&{ self.0 }),\n+            ::core::clone::Clone::clone(&{ self.1 }),\n+            ::core::clone::Clone::clone(&{ self.2 }))\n     }\n }\n #[automatically_derived]\n-impl ::core::fmt::Debug for PackedNonCopy {\n+impl<T: ::core::marker::Copy + Trait, U: ::core::marker::Copy>\n+    ::core::marker::Copy for PackedGeneric<T, U> where\n+    T::A: ::core::marker::Copy {\n+}\n+#[automatically_derived]\n+impl<T: ::core::fmt::Debug + ::core::marker::Copy + Trait,\n+    U: ::core::fmt::Debug + ::core::marker::Copy> ::core::fmt::Debug for\n+    PackedGeneric<T, U> where T::A: ::core::fmt::Debug + ::core::marker::Copy\n+    {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedNonCopy\",\n-            &&self.0)\n+        ::core::fmt::Formatter::debug_tuple_field3_finish(f, \"PackedGeneric\",\n+            &&{ self.0 }, &&{ self.1 }, &&{ self.2 })\n     }\n }\n #[automatically_derived]\n-impl ::core::default::Default for PackedNonCopy {\n+impl<T: ::core::default::Default + Trait, U: ::core::default::Default>\n+    ::core::default::Default for PackedGeneric<T, U> where\n+    T::A: ::core::default::Default {\n     #[inline]\n-    fn default() -> PackedNonCopy {\n-        PackedNonCopy(::core::default::Default::default())\n+    fn default() -> PackedGeneric<T, U> {\n+        PackedGeneric(::core::default::Default::default(),\n+            ::core::default::Default::default(),\n+            ::core::default::Default::default())\n     }\n }\n #[automatically_derived]\n-impl ::core::hash::Hash for PackedNonCopy {\n+impl<T: ::core::hash::Hash + ::core::marker::Copy + Trait,\n+    U: ::core::hash::Hash + ::core::marker::Copy> ::core::hash::Hash for\n+    PackedGeneric<T, U> where T::A: ::core::hash::Hash + ::core::marker::Copy\n+    {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        ::core::hash::Hash::hash(&self.0, state)\n+        ::core::hash::Hash::hash(&{ self.0 }, state);\n+        ::core::hash::Hash::hash(&{ self.1 }, state);\n+        ::core::hash::Hash::hash(&{ self.2 }, state)\n     }\n }\n #[automatically_derived]\n-impl ::core::marker::StructuralPartialEq for PackedNonCopy { }\n+impl<T: Trait, U> ::core::marker::StructuralPartialEq for PackedGeneric<T, U>\n+    {\n+}\n #[automatically_derived]\n-impl ::core::cmp::PartialEq for PackedNonCopy {\n+impl<T: ::core::cmp::PartialEq + ::core::marker::Copy + Trait,\n+    U: ::core::cmp::PartialEq + ::core::marker::Copy> ::core::cmp::PartialEq\n+    for PackedGeneric<T, U> where T::A: ::core::cmp::PartialEq +\n+    ::core::marker::Copy {\n     #[inline]\n-    fn eq(&self, other: &PackedNonCopy) -> bool { self.0 == other.0 }\n+    fn eq(&self, other: &PackedGeneric<T, U>) -> bool {\n+        { self.0 } == { other.0 } && { self.1 } == { other.1 } &&\n+            { self.2 } == { other.2 }\n+    }\n }\n #[automatically_derived]\n-impl ::core::marker::StructuralEq for PackedNonCopy { }\n+impl<T: Trait, U> ::core::marker::StructuralEq for PackedGeneric<T, U> { }\n #[automatically_derived]\n-impl ::core::cmp::Eq for PackedNonCopy {\n+impl<T: ::core::cmp::Eq + ::core::marker::Copy + Trait, U: ::core::cmp::Eq +\n+    ::core::marker::Copy> ::core::cmp::Eq for PackedGeneric<T, U> where\n+    T::A: ::core::cmp::Eq + ::core::marker::Copy {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        let _: ::core::cmp::AssertParamIsEq<u8>;\n+        let _: ::core::cmp::AssertParamIsEq<T>;\n+        let _: ::core::cmp::AssertParamIsEq<T::A>;\n+        let _: ::core::cmp::AssertParamIsEq<U>;\n     }\n }\n #[automatically_derived]\n-impl ::core::cmp::PartialOrd for PackedNonCopy {\n+impl<T: ::core::cmp::PartialOrd + ::core::marker::Copy + Trait,\n+    U: ::core::cmp::PartialOrd + ::core::marker::Copy> ::core::cmp::PartialOrd\n+    for PackedGeneric<T, U> where T::A: ::core::cmp::PartialOrd +\n+    ::core::marker::Copy {\n     #[inline]\n-    fn partial_cmp(&self, other: &PackedNonCopy)\n+    fn partial_cmp(&self, other: &PackedGeneric<T, U>)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)\n+        match ::core::cmp::PartialOrd::partial_cmp(&{ self.0 }, &{ other.0 })\n+            {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+                match ::core::cmp::PartialOrd::partial_cmp(&{ self.1 },\n+                        &{ other.1 }) {\n+                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                        =>\n+                        ::core::cmp::PartialOrd::partial_cmp(&{ self.2 },\n+                            &{ other.2 }),\n+                    cmp => cmp,\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n #[automatically_derived]\n-impl ::core::cmp::Ord for PackedNonCopy {\n+impl<T: ::core::cmp::Ord + ::core::marker::Copy + Trait, U: ::core::cmp::Ord +\n+    ::core::marker::Copy> ::core::cmp::Ord for PackedGeneric<T, U> where\n+    T::A: ::core::cmp::Ord + ::core::marker::Copy {\n     #[inline]\n-    fn cmp(&self, other: &PackedNonCopy) -> ::core::cmp::Ordering {\n-        ::core::cmp::Ord::cmp(&self.0, &other.0)\n+    fn cmp(&self, other: &PackedGeneric<T, U>) -> ::core::cmp::Ordering {\n+        match ::core::cmp::Ord::cmp(&{ self.0 }, &{ other.0 }) {\n+            ::core::cmp::Ordering::Equal =>\n+                match ::core::cmp::Ord::cmp(&{ self.1 }, &{ other.1 }) {\n+                    ::core::cmp::Ordering::Equal =>\n+                        ::core::cmp::Ord::cmp(&{ self.2 }, &{ other.2 }),\n+                    cmp => cmp,\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n \n@@ -1051,6 +1309,125 @@ impl ::core::cmp::Ord for Fielded {\n     }\n }\n \n+// A generic enum. Note that `Default` cannot be derived for this enum.\n+enum EnumGeneric<T, U> { One(T), Two(U), }\n+#[automatically_derived]\n+impl<T: ::core::clone::Clone, U: ::core::clone::Clone> ::core::clone::Clone\n+    for EnumGeneric<T, U> {\n+    #[inline]\n+    fn clone(&self) -> EnumGeneric<T, U> {\n+        match self {\n+            EnumGeneric::One(__self_0) =>\n+                EnumGeneric::One(::core::clone::Clone::clone(__self_0)),\n+            EnumGeneric::Two(__self_0) =>\n+                EnumGeneric::Two(::core::clone::Clone::clone(__self_0)),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+impl<T: ::core::marker::Copy, U: ::core::marker::Copy> ::core::marker::Copy\n+    for EnumGeneric<T, U> {\n+}\n+#[automatically_derived]\n+impl<T: ::core::fmt::Debug, U: ::core::fmt::Debug> ::core::fmt::Debug for\n+    EnumGeneric<T, U> {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match self {\n+            EnumGeneric::One(__self_0) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"One\",\n+                    &__self_0),\n+            EnumGeneric::Two(__self_0) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Two\",\n+                    &__self_0),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+impl<T: ::core::hash::Hash, U: ::core::hash::Hash> ::core::hash::Hash for\n+    EnumGeneric<T, U> {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        ::core::hash::Hash::hash(&__self_tag, state);\n+        match self {\n+            EnumGeneric::One(__self_0) =>\n+                ::core::hash::Hash::hash(__self_0, state),\n+            EnumGeneric::Two(__self_0) =>\n+                ::core::hash::Hash::hash(__self_0, state),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+impl<T, U> ::core::marker::StructuralPartialEq for EnumGeneric<T, U> { }\n+#[automatically_derived]\n+impl<T: ::core::cmp::PartialEq, U: ::core::cmp::PartialEq>\n+    ::core::cmp::PartialEq for EnumGeneric<T, U> {\n+    #[inline]\n+    fn eq(&self, other: &EnumGeneric<T, U>) -> bool {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        __self_tag == __arg1_tag &&\n+            match (self, other) {\n+                (EnumGeneric::One(__self_0), EnumGeneric::One(__arg1_0)) =>\n+                    *__self_0 == *__arg1_0,\n+                (EnumGeneric::Two(__self_0), EnumGeneric::Two(__arg1_0)) =>\n+                    *__self_0 == *__arg1_0,\n+                _ => unsafe { ::core::intrinsics::unreachable() }\n+            }\n+    }\n+}\n+#[automatically_derived]\n+impl<T, U> ::core::marker::StructuralEq for EnumGeneric<T, U> { }\n+#[automatically_derived]\n+impl<T: ::core::cmp::Eq, U: ::core::cmp::Eq> ::core::cmp::Eq for\n+    EnumGeneric<T, U> {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        let _: ::core::cmp::AssertParamIsEq<T>;\n+        let _: ::core::cmp::AssertParamIsEq<U>;\n+    }\n+}\n+#[automatically_derived]\n+impl<T: ::core::cmp::PartialOrd, U: ::core::cmp::PartialOrd>\n+    ::core::cmp::PartialOrd for EnumGeneric<T, U> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &EnumGeneric<T, U>)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        match (self, other) {\n+            (EnumGeneric::One(__self_0), EnumGeneric::One(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            (EnumGeneric::Two(__self_0), EnumGeneric::Two(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            _ =>\n+                ::core::cmp::PartialOrd::partial_cmp(&__self_tag,\n+                    &__arg1_tag),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+impl<T: ::core::cmp::Ord, U: ::core::cmp::Ord> ::core::cmp::Ord for\n+    EnumGeneric<T, U> {\n+    #[inline]\n+    fn cmp(&self, other: &EnumGeneric<T, U>) -> ::core::cmp::Ordering {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {\n+            ::core::cmp::Ordering::Equal =>\n+                match (self, other) {\n+                    (EnumGeneric::One(__self_0), EnumGeneric::One(__arg1_0)) =>\n+                        ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n+                    (EnumGeneric::Two(__self_0), EnumGeneric::Two(__arg1_0)) =>\n+                        ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                },\n+            cmp => cmp,\n+        }\n+    }\n+}\n+\n // A union. Most builtin traits are not derivable for unions.\n pub union Union {\n     pub b: bool,"}]}