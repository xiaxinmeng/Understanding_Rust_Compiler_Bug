{"sha": "22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "node_id": "C_kwDOAAsO6NoAKDIyYTZiYzRkYTBjZTE1NjA2ZTNhN2ZiMDFjNWNjNmZmMTc1Zjc5YWY", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-10-26T14:40:41Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-10-26T14:40:41Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "9832a32abb629ff63b4842c4ea706efd8740d750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9832a32abb629ff63b4842c4ea706efd8740d750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "html_url": "https://github.com/rust-lang/rust/commit/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43dd3d514b6b11c5195de2fd8e665828801d0972", "url": "https://api.github.com/repos/rust-lang/rust/commits/43dd3d514b6b11c5195de2fd8e665828801d0972", "html_url": "https://github.com/rust-lang/rust/commit/43dd3d514b6b11c5195de2fd8e665828801d0972"}, {"sha": "43fb9563b2943d6abc5f3552195f3e27ac618966", "url": "https://api.github.com/repos/rust-lang/rust/commits/43fb9563b2943d6abc5f3552195f3e27ac618966", "html_url": "https://github.com/rust-lang/rust/commit/43fb9563b2943d6abc5f3552195f3e27ac618966"}], "stats": {"total": 3805, "additions": 2221, "deletions": 1584}, "files": [{"sha": "73e62ab32c6c5d1f310e5cc5734a1496a8409b29", "filename": "src/tools/rust-analyzer/.github/workflows/publish.yml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -2,8 +2,8 @@ name: publish\n on:\n   workflow_dispatch: # We can add version input when 1.0 is released and scheduled releases are removed\n \n-#   schedule:\n-#     - cron: \"0 0 * * *\" # midnight UTC\n+  #   schedule:\n+  #     - cron: \"0 0 * * *\" # midnight UTC\n \n   push:\n     branches:\n@@ -50,5 +50,7 @@ jobs:\n           cargo workspaces rename --from test-utils test_utils\n           cargo workspaces rename --from text-edit text_edit\n           cargo workspaces rename ra_ap_%n\n+          # Remove library crates from the workspaces so we don't auto-publish them as well\n+          sed -i 's/ \"lib\\/\\*\",//' ./Cargo.toml\n           find crates/rust-analyzer -type f -name '*.rs' -exec sed -i 's/rust_analyzer/ra_ap_rust_analyzer/g' {} +\n           cargo workspaces publish --yes --force '*' --exact --no-git-commit --allow-dirty --skip-published custom 0.0.$PATCH"}, {"sha": "73c3a48b4c5a3fd5fe017031a7e15ba0177b5ad1", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -21,6 +21,20 @@ pub use cargo_metadata::diagnostic::{\n     DiagnosticSpanMacroExpansion,\n };\n \n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub enum InvocationStrategy {\n+    Once,\n+    #[default]\n+    PerWorkspace,\n+}\n+\n+#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+pub enum InvocationLocation {\n+    Root(AbsPathBuf),\n+    #[default]\n+    Workspace,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand {\n@@ -37,6 +51,8 @@ pub enum FlycheckConfig {\n         command: String,\n         args: Vec<String>,\n         extra_env: FxHashMap<String, String>,\n+        invocation_strategy: InvocationStrategy,\n+        invocation_location: InvocationLocation,\n     },\n }\n \n@@ -136,11 +152,15 @@ enum Restart {\n     No,\n }\n \n+/// A [`FlycheckActor`] is a single check instance of a workspace.\n struct FlycheckActor {\n+    /// The workspace id of this flycheck instance.\n     id: usize,\n     sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n-    workspace_root: AbsPathBuf,\n+    /// Either the workspace root of the workspace we are flychecking,\n+    /// or the project root of the project.\n+    root: AbsPathBuf,\n     /// CargoHandle exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n@@ -162,11 +182,13 @@ impl FlycheckActor {\n         workspace_root: AbsPathBuf,\n     ) -> FlycheckActor {\n         tracing::info!(%id, ?workspace_root, \"Spawning flycheck\");\n-        FlycheckActor { id, sender, config, workspace_root, cargo_handle: None }\n+        FlycheckActor { id, sender, config, root: workspace_root, cargo_handle: None }\n     }\n-    fn progress(&self, progress: Progress) {\n+\n+    fn report_progress(&self, progress: Progress) {\n         self.send(Message::Progress { id: self.id, progress });\n     }\n+\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n         let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n         if let Ok(msg) = inbox.try_recv() {\n@@ -178,6 +200,7 @@ impl FlycheckActor {\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n         }\n     }\n+\n     fn run(mut self, inbox: Receiver<Restart>) {\n         'event: while let Some(event) = self.next_event(&inbox) {\n             match event {\n@@ -203,10 +226,10 @@ impl FlycheckActor {\n                                 \"did  restart flycheck\"\n                             );\n                             self.cargo_handle = Some(cargo_handle);\n-                            self.progress(Progress::DidStart);\n+                            self.report_progress(Progress::DidStart);\n                         }\n                         Err(error) => {\n-                            self.progress(Progress::DidFailToRestart(format!(\n+                            self.report_progress(Progress::DidFailToRestart(format!(\n                                 \"Failed to run the following command: {:?} error={}\",\n                                 self.check_command(),\n                                 error\n@@ -226,17 +249,17 @@ impl FlycheckActor {\n                             self.check_command()\n                         );\n                     }\n-                    self.progress(Progress::DidFinish(res));\n+                    self.report_progress(Progress::DidFinish(res));\n                 }\n                 Event::CheckEvent(Some(message)) => match message {\n                     CargoMessage::CompilerArtifact(msg) => {\n-                        self.progress(Progress::DidCheckCrate(msg.target.name));\n+                        self.report_progress(Progress::DidCheckCrate(msg.target.name));\n                     }\n \n                     CargoMessage::Diagnostic(msg) => {\n                         self.send(Message::AddDiagnostic {\n                             id: self.id,\n-                            workspace_root: self.workspace_root.clone(),\n+                            workspace_root: self.root.clone(),\n                             diagnostic: msg,\n                         });\n                     }\n@@ -254,12 +277,12 @@ impl FlycheckActor {\n                 \"did  cancel flycheck\"\n             );\n             cargo_handle.cancel();\n-            self.progress(Progress::DidCancel);\n+            self.report_progress(Progress::DidCancel);\n         }\n     }\n \n     fn check_command(&self) -> Command {\n-        let mut cmd = match &self.config {\n+        let (mut cmd, args) = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n                 target_triple,\n@@ -272,9 +295,7 @@ impl FlycheckActor {\n             } => {\n                 let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.current_dir(&self.workspace_root);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n-                    .arg(self.workspace_root.join(\"Cargo.toml\").as_os_str());\n+                cmd.args(&[\"--workspace\", \"--message-format=json\"]);\n \n                 if let Some(target) = target_triple {\n                     cmd.args(&[\"--target\", target.as_str()]);\n@@ -293,18 +314,41 @@ impl FlycheckActor {\n                         cmd.arg(features.join(\" \"));\n                     }\n                 }\n-                cmd.args(extra_args);\n                 cmd.envs(extra_env);\n-                cmd\n+                (cmd, extra_args)\n             }\n-            FlycheckConfig::CustomCommand { command, args, extra_env } => {\n+            FlycheckConfig::CustomCommand {\n+                command,\n+                args,\n+                extra_env,\n+                invocation_strategy,\n+                invocation_location,\n+            } => {\n                 let mut cmd = Command::new(command);\n-                cmd.args(args);\n                 cmd.envs(extra_env);\n-                cmd\n+\n+                match invocation_location {\n+                    InvocationLocation::Workspace => {\n+                        match invocation_strategy {\n+                            InvocationStrategy::Once => {\n+                                cmd.current_dir(&self.root);\n+                            }\n+                            InvocationStrategy::PerWorkspace => {\n+                                // FIXME: cmd.current_dir(&affected_workspace);\n+                                cmd.current_dir(&self.root);\n+                            }\n+                        }\n+                    }\n+                    InvocationLocation::Root(root) => {\n+                        cmd.current_dir(root);\n+                    }\n+                }\n+\n+                (cmd, args)\n             }\n         };\n-        cmd.current_dir(&self.workspace_root);\n+\n+        cmd.args(args);\n         cmd\n     }\n "}, {"sha": "fafcde25ae708549241644a6e50803b98c358ce7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -12,11 +12,11 @@ fn test_copy_expand_simple() {\n #[derive(Copy)]\n struct Foo;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Copy)]\n struct Foo;\n \n-impl < > core::marker::Copy for Foo< > {}\"##]],\n+impl < > core::marker::Copy for Foo< > {}\"#]],\n     );\n }\n \n@@ -33,15 +33,15 @@ macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro derive {}\n #[rustc_builtin_macro]\n macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \n-impl < > crate ::marker::Copy for Foo< > {}\"##]],\n+impl < > crate ::marker::Copy for Foo< > {}\"#]],\n     );\n }\n \n@@ -53,11 +53,11 @@ fn test_copy_expand_with_type_params() {\n #[derive(Copy)]\n struct Foo<A, B>;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Copy)]\n struct Foo<A, B>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy> core::marker::Copy for Foo<T0, T1> {}\"##]],\n+impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n     );\n }\n \n@@ -70,11 +70,11 @@ fn test_copy_expand_with_lifetimes() {\n #[derive(Copy)]\n struct Foo<A, B, 'a, 'b>;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Copy)]\n struct Foo<A, B, 'a, 'b>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy> core::marker::Copy for Foo<T0, T1> {}\"##]],\n+impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n     );\n }\n \n@@ -86,10 +86,26 @@ fn test_clone_expand() {\n #[derive(Clone)]\n struct Foo<A, B>;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Clone)]\n struct Foo<A, B>;\n \n-impl <T0: core::clone::Clone, T1: core::clone::Clone> core::clone::Clone for Foo<T0, T1> {}\"##]],\n+impl <T0: core::clone::Clone, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_clone_expand_with_const_generics() {\n+    check(\n+        r#\"\n+//- minicore: derive, clone\n+#[derive(Clone)]\n+struct Foo<const X: usize, T>(u32);\n+\"#,\n+        expect![[r#\"\n+#[derive(Clone)]\n+struct Foo<const X: usize, T>(u32);\n+\n+impl <const T0: usize, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n     );\n }"}, {"sha": "8966047c9b259d932bc8b618f11497fa5b28f205", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -60,7 +60,8 @@ pub fn find_builtin_derive(ident: &name::Name) -> Option<BuiltinDeriveExpander>\n \n struct BasicAdtInfo {\n     name: tt::Ident,\n-    type_or_const_params: usize,\n+    /// `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n+    param_types: Vec<Option<tt::Subtree>>,\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n@@ -92,65 +93,50 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n     let name_token_id =\n         token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n     let name_token = tt::Ident { id: name_token_id, text: name.text().into() };\n-    let type_or_const_params =\n-        params.map_or(0, |type_param_list| type_param_list.type_or_const_params().count());\n-    Ok(BasicAdtInfo { name: name_token, type_or_const_params })\n-}\n-\n-fn make_type_args(n: usize, bound: Vec<tt::TokenTree>) -> Vec<tt::TokenTree> {\n-    let mut result = Vec::<tt::TokenTree>::with_capacity(n * 2);\n-    result.push(\n-        tt::Leaf::Punct(tt::Punct {\n-            char: '<',\n-            spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n-        })\n-        .into(),\n-    );\n-    for i in 0..n {\n-        if i > 0 {\n-            result.push(\n-                tt::Leaf::Punct(tt::Punct {\n-                    char: ',',\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n-                })\n-                .into(),\n-            );\n-        }\n-        result.push(\n-            tt::Leaf::Ident(tt::Ident {\n-                id: tt::TokenId::unspecified(),\n-                text: format!(\"T{}\", i).into(),\n-            })\n-            .into(),\n-        );\n-        result.extend(bound.iter().cloned());\n-    }\n-    result.push(\n-        tt::Leaf::Punct(tt::Punct {\n-            char: '>',\n-            spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n+    let param_types = params\n+        .into_iter()\n+        .flat_map(|param_list| param_list.type_or_const_params())\n+        .map(|param| {\n+            if let ast::TypeOrConstParam::Const(param) = param {\n+                let ty = param\n+                    .ty()\n+                    .map(|ty| mbe::syntax_node_to_token_tree(ty.syntax()).0)\n+                    .unwrap_or_default();\n+                Some(ty)\n+            } else {\n+                None\n+            }\n         })\n-        .into(),\n-    );\n-    result\n+        .collect();\n+    Ok(BasicAdtInfo { name: name_token, param_types })\n }\n \n fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n         Err(e) => return ExpandResult::only_err(e),\n     };\n+    let (params, args): (Vec<_>, Vec<_>) = info\n+        .param_types\n+        .into_iter()\n+        .enumerate()\n+        .map(|(idx, param_ty)| {\n+            let ident = tt::Leaf::Ident(tt::Ident {\n+                id: tt::TokenId::unspecified(),\n+                text: format!(\"T{idx}\").into(),\n+            });\n+            let ident_ = ident.clone();\n+            if let Some(ty) = param_ty {\n+                (quote! { const #ident : #ty , }, quote! { #ident_ , })\n+            } else {\n+                let bound = trait_path.clone();\n+                (quote! { #ident : #bound , }, quote! { #ident_ , })\n+            }\n+        })\n+        .unzip();\n     let name = info.name;\n-    let trait_path_clone = trait_path.token_trees.clone();\n-    let bound = (quote! { : ##trait_path_clone }).token_trees;\n-    let type_params = make_type_args(info.type_or_const_params, bound);\n-    let type_args = make_type_args(info.type_or_const_params, Vec::new());\n-    let trait_path = trait_path.token_trees;\n     let expanded = quote! {\n-        impl ##type_params ##trait_path for #name ##type_args {}\n+        impl < ##params > #trait_path for #name < ##args > {}\n     };\n     ExpandResult::ok(expanded)\n }"}, {"sha": "d7586d129b768b1e639b915df81f51aa4a5c89b5", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -259,7 +259,6 @@ macro_rules! __known_path {\n     (core::future::Future) => {};\n     (core::future::IntoFuture) => {};\n     (core::ops::Try) => {};\n-    (core::ops::FromResidual) => {};\n     ($path:path) => {\n         compile_error!(\"Please register your known path in the path module\")\n     };"}, {"sha": "2679a1c3602671c35fcae81ba8f9fdef4eb90042", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -279,8 +279,6 @@ pub mod known {\n         RangeToInclusive,\n         RangeTo,\n         Range,\n-        Residual,\n-        FromResidual,\n         Neg,\n         Not,\n         None,"}, {"sha": "0efff651cc174f91fcdcd5af56d4ab6c10ec07ae", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -190,9 +190,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n-    IncorrectTryTarget { expr: ExprId },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n-    DoesNotImplement { expr: ExprId, trait_: TraitId, ty: Ty },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -907,6 +905,17 @@ impl<'a> InferenceContext<'a> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n+    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n+        // FIXME resolve via lang_item once try v2 is stable\n+        let path = path![core::ops::Try];\n+        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+        let trait_data = self.db.trait_data(trait_);\n+        trait_data\n+            // FIXME remove once try v2 is stable\n+            .associated_type_by_name(&name![Ok])\n+            .or_else(|| trait_data.associated_type_by_name(&name![Output]))\n+    }\n+\n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n         let trait_ = self.resolve_lang_item(name![neg])?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])"}, {"sha": "f56108b26c45bdaea3096f4616828c28ba260d12", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 8, "deletions": 91, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -19,24 +19,24 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::{name, name::Name};\n+use hir_expand::name::Name;\n use stdx::always;\n use syntax::ast::RangeOp;\n \n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::{coerce::CoerceMany, find_continuable, path, BreakableKind},\n+    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n     method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n-    static_lifetime, to_assoc_type_id, to_chalk_trait_id,\n+    static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n-    AdtId, AliasEq, AliasTy, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner,\n-    ProjectionTy, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner, Rawness, Scalar,\n+    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n@@ -564,29 +564,9 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n             }\n-            &Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr_inner(expr, &Expectation::none());\n-                match self.resolve_try_impl_for(inner_ty.clone()) {\n-                    Some((_, Some((output, residual)))) => {\n-                        if let Some((_trait, false)) =\n-                            self.implements_from_residual(self.return_ty.clone(), residual)\n-                        {\n-                            self.push_diagnostic(InferenceDiagnostic::IncorrectTryTarget {\n-                                expr: tgt_expr,\n-                            });\n-                        }\n-                        output\n-                    }\n-                    Some((trait_, None)) => {\n-                        self.push_diagnostic(InferenceDiagnostic::DoesNotImplement {\n-                            expr,\n-                            trait_,\n-                            ty: inner_ty,\n-                        });\n-                        self.err_ty()\n-                    }\n-                    None => self.err_ty(),\n-                }\n+            Expr::Try { expr } => {\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n+                self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n             }\n             Expr::Cast { expr, type_ref } => {\n                 // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n@@ -1550,67 +1530,4 @@ impl<'a> InferenceContext<'a> {\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n         (ctx.may_break.then(|| ctx.coerce.complete()), res)\n     }\n-\n-    /// Check whether `ty` implements `FromResidual<r>`\n-    fn implements_from_residual(&mut self, ty: Ty, r: Ty) -> Option<(hir_def::TraitId, bool)> {\n-        let from_residual_trait = self\n-            .resolver\n-            .resolve_known_trait(self.db.upcast(), &(super::path![core::ops::FromResidual]))?;\n-        let r = GenericArgData::Ty(r).intern(Interner);\n-        let b = TyBuilder::trait_ref(self.db, from_residual_trait);\n-        if b.remaining() != 2 {\n-            return Some((from_residual_trait, false));\n-        }\n-        let trait_ref = b.push(ty).push(r).build();\n-        Some((from_residual_trait, self.table.try_obligation(trait_ref.cast(Interner)).is_some()))\n-    }\n-\n-    fn resolve_try_impl_for(&mut self, ty: Ty) -> Option<(hir_def::TraitId, Option<(Ty, Ty)>)> {\n-        let path = path![core::ops::Try];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n-\n-        let trait_ref = TyBuilder::trait_ref(self.db, trait_).push(ty).build();\n-        let substitution = trait_ref.substitution.clone();\n-        self.push_obligation(trait_ref.clone().cast(Interner));\n-\n-        let trait_data = self.db.trait_data(trait_);\n-        let output = trait_data.associated_type_by_name(&name![Output]);\n-        let residual = trait_data.associated_type_by_name(&name![Residual]);\n-\n-        let output_ty = match output {\n-            Some(output) => {\n-                let output_ty = self.table.new_type_var();\n-                let alias_eq = AliasEq {\n-                    alias: AliasTy::Projection(ProjectionTy {\n-                        associated_ty_id: to_assoc_type_id(output),\n-                        substitution: substitution.clone(),\n-                    }),\n-                    ty: output_ty.clone(),\n-                };\n-                self.push_obligation(alias_eq.cast(Interner));\n-                output_ty\n-            }\n-            None => self.err_ty(),\n-        };\n-        let residual_ty = match residual {\n-            Some(residual) => {\n-                let residual_ty = self.table.new_type_var();\n-                let alias_eq = AliasEq {\n-                    alias: AliasTy::Projection(ProjectionTy {\n-                        associated_ty_id: to_assoc_type_id(residual),\n-                        substitution,\n-                    }),\n-                    ty: residual_ty.clone(),\n-                };\n-                self.push_obligation(alias_eq.cast(Interner));\n-                residual_ty\n-            }\n-            None => self.err_ty(),\n-        };\n-        // FIXME: We are doing the work twice here I think?\n-        Some((\n-            trait_,\n-            self.table.try_obligation(trait_ref.cast(Interner)).map(|_| (output_ty, residual_ty)),\n-        ))\n-    }\n }"}, {"sha": "3a1a3f4fdeb3b70d66d95c5415598723b6324c6c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -1111,24 +1111,6 @@ pub fn resolve_indexing_op(\n     }\n     None\n }\n-/// Returns the receiver type for the try branch trait call.\n-pub fn resolve_branch_op(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    ty: Canonical<Ty>,\n-    try_trait: TraitId,\n-) -> Option<ReceiverAdjustments> {\n-    let mut table = InferenceTable::new(db, env.clone());\n-    let ty = table.instantiate_canonical(ty);\n-    let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n-    for (ty, adj) in deref_chain.into_iter().zip(adj) {\n-        let goal = generic_implements_goal(db, env.clone(), try_trait, &ty);\n-        if db.trait_solve(env.krate, goal.cast(Interner)).is_some() {\n-            return Some(adj);\n-        }\n-    }\n-    None\n-}\n \n macro_rules! check_that {\n     ($cond:expr) => {"}, {"sha": "555b6972fb71eecb775979f640b33baa2e3a712e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -162,16 +162,98 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_try() {\n+    check_types(\n+        r#\"\n+//- /main.rs crate:main deps:core\n+fn test() {\n+    let r: Result<i32, u64> = Result::Ok(1);\n+    let v = r?;\n+    v;\n+} //^ i32\n+\n+//- /core.rs crate:core\n+pub mod ops {\n+    pub trait Try {\n+        type Ok;\n+        type Error;\n+    }\n+}\n+\n+pub mod result {\n+    pub enum Result<O, E> {\n+        Ok(O),\n+        Err(E)\n+    }\n+\n+    impl<O, E> crate::ops::Try for Result<O, E> {\n+        type Ok = O;\n+        type Error = E;\n+    }\n+}\n+\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub use crate::{result::*, ops::*};\n+    }\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_try_trait_v2() {\n     check_types(\n         r#\"\n-//- minicore: try\n-fn test() -> core::ops::ControlFlow<u32, f32> {\n-    let r: core::ops::ControlFlow<u32, f32> = core::ops::ControlFlow::Continue(1.0);\n+//- /main.rs crate:main deps:core\n+fn test() {\n+    let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n-      //^ f32\n-    r\n+    v;\n+} //^ i32\n+\n+//- /core.rs crate:core\n+mod ops {\n+    mod try_trait {\n+        pub trait Try: FromResidual {\n+            type Output;\n+            type Residual;\n+        }\n+        pub trait FromResidual<R = <Self as Try>::Residual> {}\n+    }\n+\n+    pub use self::try_trait::FromResidual;\n+    pub use self::try_trait::Try;\n+}\n+\n+mod convert {\n+    pub trait From<T> {}\n+    impl<T> From<T> for T {}\n+}\n+\n+pub mod result {\n+    use crate::convert::From;\n+    use crate::ops::{Try, FromResidual};\n+\n+    pub enum Infallible {}\n+    pub enum Result<O, E> {\n+        Ok(O),\n+        Err(E)\n+    }\n+\n+    impl<O, E> Try for Result<O, E> {\n+        type Output = O;\n+        type Error = Result<Infallible, E>;\n+    }\n+\n+    impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {}\n+}\n+\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub use crate::result::*;\n+    }\n }\n \"#,\n     );"}, {"sha": "c5dc60f1ec5f962e319af3c48191fe2769984243", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -6,7 +6,7 @@\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_def::{path::ModPath, TraitId};\n+use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n@@ -33,15 +33,13 @@ diagnostics![\n     BreakOutsideOfLoop,\n     InactiveCode,\n     IncorrectCase,\n-    IncorrectTryExpr,\n     InvalidDeriveTarget,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n-    NotImplemented,\n     NoSuchField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n@@ -155,16 +153,6 @@ pub struct MismatchedArgCount {\n     pub expected: usize,\n     pub found: usize,\n }\n-#[derive(Debug)]\n-pub struct IncorrectTryExpr {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-}\n-#[derive(Debug)]\n-pub struct NotImplemented {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-    pub trait_: TraitId,\n-    pub ty: Type,\n-}\n \n #[derive(Debug)]\n pub struct MissingMatchArms {"}, {"sha": "f5324208c9a4ef12cf6704f1a9066b11c7378b27", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -81,12 +81,11 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, IncorrectTryExpr,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NoSuchField, NotImplemented,\n-        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n+        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n+        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n+        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1283,45 +1282,30 @@ impl DefWithBody {\n         let infer = db.infer(self.into());\n         let source_map = Lazy::new(|| db.body_with_source_map(self.into()).1);\n         for d in &infer.diagnostics {\n-            match *d {\n+            match d {\n                 hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n-                    let field = source_map.field_syntax(expr);\n+                    let field = source_map.field_syntax(*expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n                     let expr = source_map\n                         .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n                     acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(call_expr) {\n+                    match source_map.expr_syntax(*call_expr) {\n                         Ok(source_ptr) => acc.push(\n                             MismatchedArgCount {\n                                 call_expr: source_ptr,\n-                                expected: expected,\n-                                found: found,\n+                                expected: *expected,\n+                                found: *found,\n                             }\n                             .into(),\n                         ),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                hir_ty::InferenceDiagnostic::IncorrectTryTarget { expr } => {\n-                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n-                    acc.push(IncorrectTryExpr { expr }.into())\n-                }\n-                hir_ty::InferenceDiagnostic::DoesNotImplement { expr, trait_, ref ty } => {\n-                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n-                    acc.push(\n-                        NotImplemented {\n-                            expr,\n-                            trait_,\n-                            ty: Type::new(db, DefWithBodyId::from(self), ty.clone()),\n-                        }\n-                        .into(),\n-                    )\n-                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {"}, {"sha": "ccdfcb0d9e4fd14767a23c1b9baf27c61b36857e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_constant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -77,7 +77,7 @@ pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n         target_data_for_generate_constant(ctx, current_module, constant_module).unwrap_or_else(\n             || {\n                 let indent = IndentLevel::from_node(statement.syntax());\n-                (statement.syntax().text_range().start(), indent, None, format!(\"\\n{}\", indent))\n+                (statement.syntax().text_range().start(), indent, None, format!(\"\\n{indent}\"))\n             },\n         );\n \n@@ -90,7 +90,7 @@ pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n             if let Some(file_id) = file_id {\n                 builder.edit_file(file_id);\n             }\n-            builder.insert(offset, format!(\"{}{}\", text, post_string));\n+            builder.insert(offset, format!(\"{text}{post_string}\"));\n         },\n     )\n }\n@@ -103,13 +103,13 @@ fn get_text_for_generate_constant(\n ) -> Option<String> {\n     let constant_token = not_exist_name_ref.pop()?;\n     let vis = if not_exist_name_ref.len() == 0 && !outer_exists { \"\" } else { \"\\npub \" };\n-    let mut text = format!(\"{}const {}: {} = $0;\", vis, constant_token, type_name);\n+    let mut text = format!(\"{vis}const {constant_token}: {type_name} = $0;\");\n     while let Some(name_ref) = not_exist_name_ref.pop() {\n         let vis = if not_exist_name_ref.len() == 0 && !outer_exists { \"\" } else { \"\\npub \" };\n         text = text.replace(\"\\n\", \"\\n    \");\n-        text = format!(\"{}mod {} {{{}\\n}}\", vis, name_ref.to_string(), text);\n+        text = format!(\"{vis}mod {name_ref} {{{text}\\n}}\");\n     }\n-    Some(text.replace(\"\\n\", &format!(\"\\n{}\", indent)))\n+    Some(text.replace(\"\\n\", &format!(\"\\n{indent}\")))\n }\n \n fn target_data_for_generate_constant(\n@@ -134,7 +134,7 @@ fn target_data_for_generate_constant(\n                 .find(|it| it.kind() == SyntaxKind::WHITESPACE && it.to_string().contains(\"\\n\"))\n                 .is_some();\n             let post_string =\n-                if siblings_has_newline { format!(\"{}\", indent) } else { format!(\"\\n{}\", indent) };\n+                if siblings_has_newline { format!(\"{indent}\") } else { format!(\"\\n{indent}\") };\n             Some((offset, indent + 1, Some(file_id), post_string))\n         }\n         _ => Some((TextSize::from(0), 0.into(), Some(file_id), \"\\n\".into())),"}, {"sha": "a6e3d49e0d1ae59b95fda24da8fa82559bf3aaa1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_default_from_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -55,12 +55,11 @@ pub(crate) fn generate_default_from_enum_variant(\n             let buf = format!(\n                 r#\"\n \n-impl Default for {0} {{\n+impl Default for {enum_name} {{\n     fn default() -> Self {{\n-        Self::{1}\n+        Self::{variant_name}\n     }}\n }}\"#,\n-                enum_name, variant_name\n             );\n             edit.insert(start_offset, buf);\n         },"}, {"sha": "49d9fd707ffccc234436efd8da912ed5c5a52c06", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -1,8 +1,7 @@\n use ide_db::famous_defs::FamousDefs;\n-use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    ast::{self, HasGenericParams, HasName, HasTypeBounds, Impl},\n+    ast::{self, make, HasGenericParams, HasName, Impl},\n     AstNode,\n };\n \n@@ -77,45 +76,47 @@ pub(crate) fn generate_default_from_new(acc: &mut Assists, ctx: &AssistContext<'\n     )\n }\n \n+// FIXME: based on from utils::generate_impl_text_inner\n fn generate_trait_impl_text_from_impl(impl_: &ast::Impl, trait_text: &str, code: &str) -> String {\n-    let generic_params = impl_.generic_param_list();\n-    let mut buf = String::with_capacity(code.len());\n-    buf.push_str(\"\\n\\n\");\n-    buf.push_str(\"impl\");\n-\n-    if let Some(generic_params) = &generic_params {\n-        let lifetimes = generic_params.lifetime_params().map(|lt| format!(\"{}\", lt.syntax()));\n-        let toc_params = generic_params.type_or_const_params().map(|toc_param| match toc_param {\n-            ast::TypeOrConstParam::Type(type_param) => {\n-                let mut buf = String::new();\n-                if let Some(it) = type_param.name() {\n-                    format_to!(buf, \"{}\", it.syntax());\n-                }\n-                if let Some(it) = type_param.colon_token() {\n-                    format_to!(buf, \"{} \", it);\n+    let impl_ty = impl_.self_ty().unwrap();\n+    let generic_params = impl_.generic_param_list().map(|generic_params| {\n+        let lifetime_params =\n+            generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);\n+        let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {\n+            // remove defaults since they can't be specified in impls\n+            match param {\n+                ast::TypeOrConstParam::Type(param) => {\n+                    let param = param.clone_for_update();\n+                    param.remove_default();\n+                    Some(ast::GenericParam::TypeParam(param))\n                 }\n-                if let Some(it) = type_param.type_bound_list() {\n-                    format_to!(buf, \"{}\", it.syntax());\n+                ast::TypeOrConstParam::Const(param) => {\n+                    let param = param.clone_for_update();\n+                    param.remove_default();\n+                    Some(ast::GenericParam::ConstParam(param))\n                 }\n-                buf\n             }\n-            ast::TypeOrConstParam::Const(const_param) => const_param.syntax().to_string(),\n         });\n-        let generics = lifetimes.chain(toc_params).format(\", \");\n-        format_to!(buf, \"<{}>\", generics);\n-    }\n \n-    buf.push(' ');\n-    buf.push_str(trait_text);\n-    buf.push_str(\" for \");\n-    buf.push_str(&impl_.self_ty().unwrap().syntax().text().to_string());\n+        make::generic_param_list(itertools::chain(lifetime_params, ty_or_const_params))\n+    });\n+\n+    let mut buf = String::with_capacity(code.len());\n+    buf.push_str(\"\\n\\n\");\n+\n+    // `impl{generic_params} {trait_text} for {impl_.self_ty()}`\n+    buf.push_str(\"impl\");\n+    if let Some(generic_params) = &generic_params {\n+        format_to!(buf, \"{generic_params}\")\n+    }\n+    format_to!(buf, \" {trait_text} for {impl_ty}\");\n \n     match impl_.where_clause() {\n         Some(where_clause) => {\n-            format_to!(buf, \"\\n{}\\n{{\\n{}\\n}}\", where_clause, code);\n+            format_to!(buf, \"\\n{where_clause}\\n{{\\n{code}\\n}}\");\n         }\n         None => {\n-            format_to!(buf, \" {{\\n{}\\n}}\", code);\n+            format_to!(buf, \" {{\\n{code}\\n}}\");\n         }\n     }\n "}, {"sha": "ceae80755037c00b56f401edb70c5a6264cb176e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -51,14 +51,14 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n         Some(field) => {\n             let field_name = field.name()?;\n             let field_ty = field.ty()?;\n-            (format!(\"{}\", field_name), field_ty, field.syntax().text_range())\n+            (field_name.to_string(), field_ty, field.syntax().text_range())\n         }\n         None => {\n             let field = ctx.find_node_at_offset::<ast::TupleField>()?;\n             let field_list = ctx.find_node_at_offset::<ast::TupleFieldList>()?;\n             let field_list_index = field_list.fields().position(|it| it == field)?;\n             let field_ty = field.ty()?;\n-            (format!(\"{}\", field_list_index), field_ty, field.syntax().text_range())\n+            (field_list_index.to_string(), field_ty, field.syntax().text_range())\n         }\n     };\n \n@@ -77,7 +77,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n     for method in methods {\n         let adt = ast::Adt::Struct(strukt.clone());\n         let name = method.name(ctx.db()).to_string();\n-        let impl_def = find_struct_impl(ctx, &adt, &name).flatten();\n+        let impl_def = find_struct_impl(ctx, &adt, &[name]).flatten();\n         acc.add_group(\n             &GroupLabel(\"Generate delegate methods\u2026\".to_owned()),\n             AssistId(\"generate_delegate_methods\", AssistKind::Generate),\n@@ -151,7 +151,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                             Some(cap) => {\n                                 let offset = strukt.syntax().text_range().end();\n                                 let snippet = render_snippet(cap, impl_def.syntax(), cursor);\n-                                let snippet = format!(\"\\n\\n{}\", snippet);\n+                                let snippet = format!(\"\\n\\n{snippet}\");\n                                 builder.insert_snippet(cap, offset, snippet);\n                             }\n                             None => {"}, {"sha": "55b7afb3d3b098e81fca1da02ea84f672dc6bc46", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -66,7 +66,7 @@ fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n     let target = field.syntax().text_range();\n     acc.add(\n         AssistId(\"generate_deref\", AssistKind::Generate),\n-        format!(\"Generate `{:?}` impl using `{}`\", deref_type_to_generate, field_name),\n+        format!(\"Generate `{deref_type_to_generate:?}` impl using `{field_name}`\"),\n         target,\n         |edit| {\n             generate_edit(\n@@ -106,7 +106,7 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n     let target = field.syntax().text_range();\n     acc.add(\n         AssistId(\"generate_deref\", AssistKind::Generate),\n-        format!(\"Generate `{:?}` impl using `{}`\", deref_type_to_generate, field.syntax()),\n+        format!(\"Generate `{deref_type_to_generate:?}` impl using `{field}`\"),\n         target,\n         |edit| {\n             generate_edit(\n@@ -132,18 +132,16 @@ fn generate_edit(\n     let start_offset = strukt.syntax().text_range().end();\n     let impl_code = match deref_type {\n         DerefType::Deref => format!(\n-            r#\"    type Target = {0};\n+            r#\"    type Target = {field_type_syntax};\n \n     fn deref(&self) -> &Self::Target {{\n-        &self.{1}\n+        &self.{field_name}\n     }}\"#,\n-            field_type_syntax, field_name\n         ),\n         DerefType::DerefMut => format!(\n             r#\"    fn deref_mut(&mut self) -> &mut Self::Target {{\n-        &mut self.{}\n+        &mut self.{field_name}\n     }}\"#,\n-            field_name\n         ),\n     };\n     let strukt_adt = ast::Adt::Struct(strukt);"}, {"sha": "b8415c72a2a3256ec14d84fb0ab874dc151d4c01", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -139,40 +139,44 @@ fn make_example_for_fn(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<St\n \n     let mut example = String::new();\n \n+    let use_path = build_path(ast_func, ctx)?;\n     let is_unsafe = ast_func.unsafe_token().is_some();\n     let param_list = ast_func.param_list()?;\n     let ref_mut_params = ref_mut_params(&param_list);\n     let self_name = self_name(ast_func);\n \n-    format_to!(example, \"use {};\\n\\n\", build_path(ast_func, ctx)?);\n+    format_to!(example, \"use {use_path};\\n\\n\");\n     if let Some(self_name) = &self_name {\n-        if let Some(mtbl) = is_ref_mut_self(ast_func) {\n-            let mtbl = if mtbl == true { \" mut\" } else { \"\" };\n-            format_to!(example, \"let{} {} = ;\\n\", mtbl, self_name);\n+        if let Some(mut_) = is_ref_mut_self(ast_func) {\n+            let mut_ = if mut_ == true { \"mut \" } else { \"\" };\n+            format_to!(example, \"let {mut_}{self_name} = ;\\n\");\n         }\n     }\n     for param_name in &ref_mut_params {\n-        format_to!(example, \"let mut {} = ;\\n\", param_name);\n+        format_to!(example, \"let mut {param_name} = ;\\n\");\n     }\n     // Call the function, check result\n     let function_call = function_call(ast_func, &param_list, self_name.as_deref(), is_unsafe)?;\n     if returns_a_value(ast_func, ctx) {\n         if count_parameters(&param_list) < 3 {\n-            format_to!(example, \"assert_eq!({}, );\\n\", function_call);\n+            format_to!(example, \"assert_eq!({function_call}, );\\n\");\n         } else {\n-            format_to!(example, \"let result = {};\\n\", function_call);\n+            format_to!(example, \"let result = {function_call};\\n\");\n             example.push_str(\"assert_eq!(result, );\\n\");\n         }\n     } else {\n-        format_to!(example, \"{};\\n\", function_call);\n+        format_to!(example, \"{function_call};\\n\");\n     }\n     // Check the mutated values\n-    if is_ref_mut_self(ast_func) == Some(true) {\n-        format_to!(example, \"assert_eq!({}, );\", self_name?);\n+    if let Some(self_name) = &self_name {\n+        if is_ref_mut_self(ast_func) == Some(true) {\n+            format_to!(example, \"assert_eq!({self_name}, );\");\n+        }\n     }\n     for param_name in &ref_mut_params {\n-        format_to!(example, \"assert_eq!({}, );\", param_name);\n+        format_to!(example, \"assert_eq!({param_name}, );\");\n     }\n+\n     Some(example)\n }\n \n@@ -189,7 +193,8 @@ fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<S\n         let intro_for_new = || {\n             let is_new = name == \"new\";\n             if is_new && ret_ty == self_ty {\n-                Some(format!(\"Creates a new [`{}`].\", linkable_self_ty?))\n+                let self_ty = linkable_self_ty?;\n+                Some(format!(\"Creates a new [`{self_ty}`].\"))\n             } else {\n                 None\n             }\n@@ -214,7 +219,9 @@ fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<S\n                 } else {\n                     \"\"\n                 };\n-                Some(format!(\"Returns{reference} the {what} of this [`{}`].\", linkable_self_ty?))\n+\n+                let self_ty = linkable_self_ty?;\n+                Some(format!(\"Returns{reference} the {what} of this [`{self_ty}`].\"))\n             }\n             _ => None,\n         };\n@@ -228,7 +235,9 @@ fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<S\n             if what == \"len\" {\n                 what = \"length\".into()\n             };\n-            Some(format!(\"Sets the {what} of this [`{}`].\", linkable_self_ty?))\n+\n+            let self_ty = linkable_self_ty?;\n+            Some(format!(\"Sets the {what} of this [`{self_ty}`].\"))\n         };\n \n         if let Some(intro) = intro_for_new() {\n@@ -404,7 +413,7 @@ fn arguments_from_params(param_list: &ast::ParamList) -> String {\n         // instance `TuplePat`) could be managed later.\n         Some(ast::Pat::IdentPat(ident_pat)) => match ident_pat.name() {\n             Some(name) => match is_a_ref_mut_param(&param) {\n-                true => format!(\"&mut {}\", name),\n+                true => format!(\"&mut {name}\"),\n                 false => name.to_string(),\n             },\n             None => \"_\".to_string(),\n@@ -424,14 +433,15 @@ fn function_call(\n     let name = ast_func.name()?;\n     let arguments = arguments_from_params(param_list);\n     let function_call = if param_list.self_param().is_some() {\n-        format!(\"{}.{}({})\", self_name?, name, arguments)\n+        let self_ = self_name?;\n+        format!(\"{self_}.{name}({arguments})\")\n     } else if let Some(implementation) = self_partial_type(ast_func) {\n-        format!(\"{}::{}({})\", implementation, name, arguments)\n+        format!(\"{implementation}::{name}({arguments})\")\n     } else {\n-        format!(\"{}({})\", name, arguments)\n+        format!(\"{name}({arguments})\")\n     };\n     match is_unsafe {\n-        true => Some(format!(\"unsafe {{ {} }}\", function_call)),\n+        true => Some(format!(\"unsafe {{ {function_call} }}\")),\n         false => Some(function_call),\n     }\n }\n@@ -469,8 +479,8 @@ fn build_path(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {\n         .unwrap_or_else(|| \"*\".into());\n     let module_def: ModuleDef = ctx.sema.to_def(ast_func)?.module(ctx.db()).into();\n     match module_def.canonical_path(ctx.db()) {\n-        Some(path) => Some(format!(\"{}::{}::{}\", crate_name, path, leaf)),\n-        None => Some(format!(\"{}::{}\", crate_name, leaf)),\n+        Some(path) => Some(format!(\"{crate_name}::{path}::{leaf}\")),\n+        None => Some(format!(\"{crate_name}::{leaf}\")),\n     }\n }\n "}, {"sha": "63e91b835f1f857d651b2a7daf2eac7675980145", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_is_method.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext<'_>\n     let fn_name = format!(\"is_{}\", &to_lower_snake_case(&variant_name.text()));\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(ctx, &parent_enum, &fn_name)?;\n+    let impl_def = find_struct_impl(ctx, &parent_enum, &[fn_name.clone()])?;\n \n     let target = variant.syntax().text_range();\n     acc.add_group(\n@@ -61,21 +61,15 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext<'_>\n         \"Generate an `is_` method for this enum variant\",\n         target,\n         |builder| {\n-            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n             let method = format!(\n-                \"    /// Returns `true` if the {} is [`{variant}`].\n+                \"    /// Returns `true` if the {enum_lowercase_name} is [`{variant_name}`].\n     ///\n-    /// [`{variant}`]: {}::{variant}\n+    /// [`{variant_name}`]: {enum_name}::{variant_name}\n     #[must_use]\n-    {}fn {}(&self) -> bool {{\n-        matches!(self, Self::{variant}{})\n+    {vis}fn {fn_name}(&self) -> bool {{\n+        matches!(self, Self::{variant_name}{pattern_suffix})\n     }}\",\n-                enum_lowercase_name,\n-                enum_name,\n-                vis,\n-                fn_name,\n-                pattern_suffix,\n-                variant = variant_name\n             );\n \n             add_method_to_adt(builder, &parent_enum, impl_def, &method);"}, {"sha": "bdd3cf4f06c253692d3e3989075ec4cd56e4ba15", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_projection_method.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -116,6 +116,14 @@ fn generate_enum_projection_method(\n     assist_description: &str,\n     props: ProjectionProps,\n ) -> Option<()> {\n+    let ProjectionProps {\n+        fn_name_prefix,\n+        self_param,\n+        return_prefix,\n+        return_suffix,\n+        happy_case,\n+        sad_case,\n+    } = props;\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n     let parent_enum = ast::Adt::Enum(variant.parent_enum());\n@@ -125,7 +133,7 @@ fn generate_enum_projection_method(\n             let (field,) = record.fields().collect_tuple()?;\n             let name = field.name()?.to_string();\n             let ty = field.ty()?;\n-            let pattern_suffix = format!(\" {{ {} }}\", name);\n+            let pattern_suffix = format!(\" {{ {name} }}\");\n             (pattern_suffix, ty, name)\n         }\n         ast::StructKind::Tuple(tuple) => {\n@@ -136,11 +144,10 @@ fn generate_enum_projection_method(\n         ast::StructKind::Unit => return None,\n     };\n \n-    let fn_name =\n-        format!(\"{}_{}\", props.fn_name_prefix, &to_lower_snake_case(&variant_name.text()));\n+    let fn_name = format!(\"{}_{}\", fn_name_prefix, &to_lower_snake_case(&variant_name.text()));\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(ctx, &parent_enum, &fn_name)?;\n+    let impl_def = find_struct_impl(ctx, &parent_enum, &[fn_name.clone()])?;\n \n     let target = variant.syntax().text_range();\n     acc.add_group(\n@@ -149,27 +156,15 @@ fn generate_enum_projection_method(\n         assist_description,\n         target,\n         |builder| {\n-            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n             let method = format!(\n-                \"    {0}fn {1}({2}) -> {3}{4}{5} {{\n-        if let Self::{6}{7} = self {{\n-            {8}({9})\n+                \"    {vis}fn {fn_name}({self_param}) -> {return_prefix}{field_type}{return_suffix} {{\n+        if let Self::{variant_name}{pattern_suffix} = self {{\n+            {happy_case}({bound_name})\n         }} else {{\n-            {10}\n+            {sad_case}\n         }}\n-    }}\",\n-                vis,\n-                fn_name,\n-                props.self_param,\n-                props.return_prefix,\n-                field_type.syntax(),\n-                props.return_suffix,\n-                variant_name,\n-                pattern_suffix,\n-                props.happy_case,\n-                bound_name,\n-                props.sad_case,\n-            );\n+    }}\");\n \n             add_method_to_adt(builder, &parent_enum, impl_def, &method);\n         },"}, {"sha": "7c81d2c6a6cc9b3767861f94fa1849f10a2edfe7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_from_impl_for_enum.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -56,23 +56,18 @@ pub(crate) fn generate_from_impl_for_enum(\n         target,\n         |edit| {\n             let start_offset = variant.parent_enum().syntax().text_range().end();\n-            let from_trait = format!(\"From<{}>\", field_type.syntax());\n+            let from_trait = format!(\"From<{field_type}>\");\n             let impl_code = if let Some(name) = field_name {\n                 format!(\n-                    r#\"    fn from({0}: {1}) -> Self {{\n-        Self::{2} {{ {0} }}\n-    }}\"#,\n-                    name.text(),\n-                    field_type.syntax(),\n-                    variant_name,\n+                    r#\"    fn from({name}: {field_type}) -> Self {{\n+        Self::{variant_name} {{ {name} }}\n+    }}\"#\n                 )\n             } else {\n                 format!(\n-                    r#\"    fn from(v: {}) -> Self {{\n-        Self::{}(v)\n-    }}\"#,\n-                    field_type.syntax(),\n-                    variant_name,\n+                    r#\"    fn from(v: {field_type}) -> Self {{\n+        Self::{variant_name}(v)\n+    }}\"#\n                 )\n             };\n             let from_impl = generate_trait_impl_text(&enum_, &from_trait, &impl_code);"}, {"sha": "c229127e48ffca348a66a7d56a54b75e8cb34c0a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -179,7 +179,7 @@ fn add_func_to_accumulator(\n         let function_template = function_builder.render(adt_name.is_some());\n         let mut func = function_template.to_string(ctx.config.snippet_cap);\n         if let Some(name) = adt_name {\n-            func = format!(\"\\n{}impl {} {{\\n{}\\n{}}}\", indent, name, func, indent);\n+            func = format!(\"\\n{indent}impl {name} {{\\n{func}\\n{indent}}}\");\n         }\n         builder.edit_file(file);\n         match ctx.config.snippet_cap {\n@@ -198,7 +198,7 @@ fn get_adt_source(\n     let file = ctx.sema.parse(range.file_id);\n     let adt_source =\n         ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n-    find_struct_impl(ctx, &adt_source, fn_name).map(|impl_| (impl_, range.file_id))\n+    find_struct_impl(ctx, &adt_source, &[fn_name.to_string()]).map(|impl_| (impl_, range.file_id))\n }\n \n struct FunctionTemplate {\n@@ -212,23 +212,26 @@ struct FunctionTemplate {\n \n impl FunctionTemplate {\n     fn to_string(&self, cap: Option<SnippetCap>) -> String {\n+        let Self { leading_ws, fn_def, ret_type, should_focus_return_type, trailing_ws, tail_expr } =\n+            self;\n+\n         let f = match cap {\n             Some(cap) => {\n-                let cursor = if self.should_focus_return_type {\n+                let cursor = if *should_focus_return_type {\n                     // Focus the return type if there is one\n-                    match self.ret_type {\n-                        Some(ref ret_type) => ret_type.syntax(),\n-                        None => self.tail_expr.syntax(),\n+                    match ret_type {\n+                        Some(ret_type) => ret_type.syntax(),\n+                        None => tail_expr.syntax(),\n                     }\n                 } else {\n-                    self.tail_expr.syntax()\n+                    tail_expr.syntax()\n                 };\n-                render_snippet(cap, self.fn_def.syntax(), Cursor::Replace(cursor))\n+                render_snippet(cap, fn_def.syntax(), Cursor::Replace(cursor))\n             }\n-            None => self.fn_def.to_string(),\n+            None => fn_def.to_string(),\n         };\n \n-        format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n+        format!(\"{leading_ws}{f}{trailing_ws}\")\n     }\n }\n \n@@ -330,19 +333,20 @@ impl FunctionBuilder {\n                 let mut indent = IndentLevel::from_node(&it);\n                 if is_method {\n                     indent = indent + 1;\n-                    leading_ws = format!(\"{}\", indent);\n+                    leading_ws = format!(\"{indent}\");\n                 } else {\n-                    leading_ws = format!(\"\\n\\n{}\", indent);\n+                    leading_ws = format!(\"\\n\\n{indent}\");\n                 }\n \n                 fn_def = fn_def.indent(indent);\n                 trailing_ws = String::new();\n             }\n             GeneratedFunctionTarget::InEmptyItemList(it) => {\n                 let indent = IndentLevel::from_node(&it);\n-                leading_ws = format!(\"\\n{}\", indent + 1);\n-                fn_def = fn_def.indent(indent + 1);\n-                trailing_ws = format!(\"\\n{}\", indent);\n+                let leading_indent = indent + 1;\n+                leading_ws = format!(\"\\n{leading_indent}\");\n+                fn_def = fn_def.indent(leading_indent);\n+                trailing_ws = format!(\"\\n{indent}\");\n             }\n         };\n "}, {"sha": "5e71914283495e7a44afd3310bb015406285a38c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 272, "deletions": 53, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -1,6 +1,9 @@\n use ide_db::famous_defs::FamousDefs;\n use stdx::{format_to, to_lower_snake_case};\n-use syntax::ast::{self, AstNode, HasName, HasVisibility};\n+use syntax::{\n+    ast::{self, AstNode, HasName, HasVisibility},\n+    TextRange,\n+};\n \n use crate::{\n     utils::{convert_reference_type, find_impl_block_end, find_struct_impl, generate_impl_text},\n@@ -72,92 +75,259 @@ pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n     generate_getter_impl(acc, ctx, true)\n }\n \n+#[derive(Clone, Debug)]\n+struct RecordFieldInfo {\n+    field_name: syntax::ast::Name,\n+    field_ty: syntax::ast::Type,\n+    fn_name: String,\n+    target: TextRange,\n+}\n+\n+struct GetterInfo {\n+    impl_def: Option<ast::Impl>,\n+    strukt: ast::Struct,\n+    mutable: bool,\n+}\n+\n pub(crate) fn generate_getter_impl(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n     mutable: bool,\n ) -> Option<()> {\n-    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n-    let field = ctx.find_node_at_offset::<ast::RecordField>()?;\n+    // This if condition denotes two modes this assist can work in:\n+    // - First is acting upon selection of record fields\n+    // - Next is acting upon a single record field\n+    //\n+    // This is the only part where implementation diverges a bit,\n+    // subsequent code is generic for both of these modes\n \n-    let field_name = field.name()?;\n-    let field_ty = field.ty()?;\n+    let (strukt, info_of_record_fields, fn_names) = if !ctx.has_empty_selection() {\n+        // Selection Mode\n+        let node = ctx.covering_element();\n \n-    // Return early if we've found an existing fn\n-    let mut fn_name = to_lower_snake_case(&field_name.to_string());\n-    if mutable {\n-        format_to!(fn_name, \"_mut\");\n+        let node = match node {\n+            syntax::NodeOrToken::Node(n) => n,\n+            syntax::NodeOrToken::Token(t) => t.parent()?,\n+        };\n+\n+        let parent_struct = node.ancestors().find_map(ast::Struct::cast)?;\n+\n+        let (info_of_record_fields, field_names) =\n+            extract_and_parse_record_fields(&parent_struct, ctx.selection_trimmed(), mutable)?;\n+\n+        (parent_struct, info_of_record_fields, field_names)\n+    } else {\n+        // Single Record Field mode\n+        let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n+        let field = ctx.find_node_at_offset::<ast::RecordField>()?;\n+\n+        let record_field_info = parse_record_field(field, mutable)?;\n+\n+        let fn_name = record_field_info.fn_name.clone();\n+\n+        (strukt, vec![record_field_info], vec![fn_name])\n+    };\n+\n+    // No record fields to do work on :(\n+    if info_of_record_fields.len() == 0 {\n+        return None;\n     }\n-    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), fn_name.as_str())?;\n+\n+    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &fn_names)?;\n \n     let (id, label) = if mutable {\n         (\"generate_getter_mut\", \"Generate a mut getter method\")\n     } else {\n         (\"generate_getter\", \"Generate a getter method\")\n     };\n-    let target = field.syntax().text_range();\n+\n+    // Computing collective text range of all record fields in selected region\n+    let target: TextRange = info_of_record_fields\n+        .iter()\n+        .map(|record_field_info| record_field_info.target)\n+        .reduce(|acc, target| acc.cover(target))?;\n+\n+    let getter_info = GetterInfo { impl_def, strukt, mutable };\n+\n     acc.add_group(\n         &GroupLabel(\"Generate getter/setter\".to_owned()),\n         AssistId(id, AssistKind::Generate),\n         label,\n         target,\n         |builder| {\n+            let record_fields_count = info_of_record_fields.len();\n+\n             let mut buf = String::with_capacity(512);\n \n-            if impl_def.is_some() {\n-                buf.push('\\n');\n+            // Check if an impl exists\n+            if let Some(impl_def) = &getter_info.impl_def {\n+                // Check if impl is empty\n+                if let Some(assoc_item_list) = impl_def.assoc_item_list() {\n+                    if assoc_item_list.assoc_items().next().is_some() {\n+                        // If not empty then only insert a new line\n+                        buf.push('\\n');\n+                    }\n+                }\n             }\n \n-            let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n-            let (ty, body) = if mutable {\n-                (format!(\"&mut {}\", field_ty), format!(\"&mut self.{}\", field_name))\n-            } else {\n-                (|| {\n-                    let krate = ctx.sema.scope(field_ty.syntax())?.krate();\n-                    let famous_defs = &FamousDefs(&ctx.sema, krate);\n-                    ctx.sema\n-                        .resolve_type(&field_ty)\n-                        .and_then(|ty| convert_reference_type(ty, ctx.db(), famous_defs))\n-                        .map(|conversion| {\n-                            cov_mark::hit!(convert_reference_type);\n-                            (\n-                                conversion.convert_type(ctx.db()),\n-                                conversion.getter(field_name.to_string()),\n-                            )\n-                        })\n-                })()\n-                .unwrap_or_else(|| (format!(\"&{}\", field_ty), format!(\"&self.{}\", field_name)))\n-            };\n-\n-            format_to!(\n-                buf,\n-                \"    {}fn {}(&{}self) -> {} {{\n-        {}\n-    }}\",\n-                vis,\n-                fn_name,\n-                mutable.then(|| \"mut \").unwrap_or_default(),\n-                ty,\n-                body,\n-            );\n-\n-            let start_offset = impl_def\n-                .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n+            for (i, record_field_info) in info_of_record_fields.iter().enumerate() {\n+                // this buf inserts a newline at the end of a getter\n+                // automatically, if one wants to add one more newline\n+                // for separating it from other assoc items, that needs\n+                // to be handled spearately\n+                let mut getter_buf =\n+                    generate_getter_from_info(ctx, &getter_info, &record_field_info);\n+\n+                // Insert `$0` only for last getter we generate\n+                if i == record_fields_count - 1 {\n+                    getter_buf = getter_buf.replacen(\"fn \", \"fn $0\", 1);\n+                }\n+\n+                // For first element we do not merge with '\\n', as\n+                // that can be inserted by impl_def check defined\n+                // above, for other cases which are:\n+                //\n+                // - impl exists but it empty, here we would ideally\n+                // not want to keep newline between impl <struct> {\n+                // and fn <fn-name>() { line\n+                //\n+                // - next if impl itself does not exist, in this\n+                // case we ourselves generate a new impl and that\n+                // again ends up with the same reasoning as above\n+                // for not keeping newline\n+                if i == 0 {\n+                    buf = buf + &getter_buf;\n+                } else {\n+                    buf = buf + \"\\n\" + &getter_buf;\n+                }\n+\n+                // We don't insert a new line at the end of\n+                // last getter as it will end up in the end\n+                // of an impl where we would not like to keep\n+                // getter and end of impl ( i.e. `}` ) with an\n+                // extra line for no reason\n+                if i < record_fields_count - 1 {\n+                    buf = buf + \"\\n\";\n+                }\n+            }\n+\n+            let start_offset = getter_info\n+                .impl_def\n+                .as_ref()\n+                .and_then(|impl_def| find_impl_block_end(impl_def.to_owned(), &mut buf))\n                 .unwrap_or_else(|| {\n-                    buf = generate_impl_text(&ast::Adt::Struct(strukt.clone()), &buf);\n-                    strukt.syntax().text_range().end()\n+                    buf = generate_impl_text(&ast::Adt::Struct(getter_info.strukt.clone()), &buf);\n+                    getter_info.strukt.syntax().text_range().end()\n                 });\n \n             match ctx.config.snippet_cap {\n-                Some(cap) => {\n-                    builder.insert_snippet(cap, start_offset, buf.replacen(\"fn \", \"fn $0\", 1))\n-                }\n+                Some(cap) => builder.insert_snippet(cap, start_offset, buf),\n                 None => builder.insert(start_offset, buf),\n             }\n         },\n     )\n }\n \n+fn generate_getter_from_info(\n+    ctx: &AssistContext<'_>,\n+    info: &GetterInfo,\n+    record_field_info: &RecordFieldInfo,\n+) -> String {\n+    let mut buf = String::with_capacity(512);\n+\n+    let vis = info.strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+    let (ty, body) = if info.mutable {\n+        (\n+            format!(\"&mut {}\", record_field_info.field_ty),\n+            format!(\"&mut self.{}\", record_field_info.field_name),\n+        )\n+    } else {\n+        (|| {\n+            let krate = ctx.sema.scope(record_field_info.field_ty.syntax())?.krate();\n+            let famous_defs = &FamousDefs(&ctx.sema, krate);\n+            ctx.sema\n+                .resolve_type(&record_field_info.field_ty)\n+                .and_then(|ty| convert_reference_type(ty, ctx.db(), famous_defs))\n+                .map(|conversion| {\n+                    cov_mark::hit!(convert_reference_type);\n+                    (\n+                        conversion.convert_type(ctx.db()),\n+                        conversion.getter(record_field_info.field_name.to_string()),\n+                    )\n+                })\n+        })()\n+        .unwrap_or_else(|| {\n+            (\n+                format!(\"&{}\", record_field_info.field_ty),\n+                format!(\"&self.{}\", record_field_info.field_name),\n+            )\n+        })\n+    };\n+\n+    format_to!(\n+        buf,\n+        \"    {}fn {}(&{}self) -> {} {{\n+        {}\n+    }}\",\n+        vis,\n+        record_field_info.fn_name,\n+        info.mutable.then(|| \"mut \").unwrap_or_default(),\n+        ty,\n+        body,\n+    );\n+\n+    buf\n+}\n+\n+fn extract_and_parse_record_fields(\n+    node: &ast::Struct,\n+    selection_range: TextRange,\n+    mutable: bool,\n+) -> Option<(Vec<RecordFieldInfo>, Vec<String>)> {\n+    let mut field_names: Vec<String> = vec![];\n+    let field_list = node.field_list()?;\n+\n+    match field_list {\n+        ast::FieldList::RecordFieldList(ele) => {\n+            let info_of_record_fields_in_selection = ele\n+                .fields()\n+                .filter_map(|record_field| {\n+                    if selection_range.contains_range(record_field.syntax().text_range()) {\n+                        let record_field_info = parse_record_field(record_field, mutable)?;\n+                        field_names.push(record_field_info.fn_name.clone());\n+                        return Some(record_field_info);\n+                    }\n+\n+                    None\n+                })\n+                .collect::<Vec<RecordFieldInfo>>();\n+\n+            if info_of_record_fields_in_selection.len() == 0 {\n+                return None;\n+            }\n+\n+            Some((info_of_record_fields_in_selection, field_names))\n+        }\n+        ast::FieldList::TupleFieldList(_) => {\n+            return None;\n+        }\n+    }\n+}\n+\n+fn parse_record_field(record_field: ast::RecordField, mutable: bool) -> Option<RecordFieldInfo> {\n+    let field_name = record_field.name()?;\n+    let field_ty = record_field.ty()?;\n+\n+    let mut fn_name = to_lower_snake_case(&field_name.to_string());\n+    if mutable {\n+        format_to!(fn_name, \"_mut\");\n+    }\n+\n+    let target = record_field.syntax().text_range();\n+\n+    Some(RecordFieldInfo { field_name, field_ty, fn_name, target })\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -489,4 +659,53 @@ impl Context {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_generate_multiple_getters_from_selection() {\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    $0data: Data,\n+    count: usize,$0\n+}\n+    \"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+    count: usize,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+\n+    fn $0count(&self) -> &usize {\n+        &self.count\n+    }\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_multiple_getters_from_selection_one_already_exists() {\n+        // As impl for one of the fields already exist, skip it\n+        check_assist_not_applicable(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    $0data: Data,\n+    count: usize,$0\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+    \"#,\n+        );\n+    }\n }"}, {"sha": "9af26c04eb458b34d0759a227023c9b5445e5795", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Optio\n \n     acc.add(\n         AssistId(\"generate_impl\", AssistKind::Generate),\n-        format!(\"Generate impl for `{}`\", name),\n+        format!(\"Generate impl for `{name}`\"),\n         target,\n         |edit| {\n             let start_offset = nominal.syntax().text_range().end();"}, {"sha": "17fadea0eaf19d28737afadc72a6b43861ba4fce", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -39,7 +39,8 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n     };\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), \"new\")?;\n+    let impl_def =\n+        find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &[String::from(\"new\")])?;\n \n     let current_module = ctx.sema.scope(strukt.syntax())?.module();\n \n@@ -51,11 +52,13 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n             buf.push('\\n');\n         }\n \n-        let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+        let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n \n         let trivial_constructors = field_list\n             .fields()\n             .map(|f| {\n+                let name = f.name()?;\n+\n                 let ty = ctx.sema.resolve_type(&f.ty()?)?;\n \n                 let item_in_ns = hir::ItemInNs::from(hir::ModuleDef::from(ty.as_adt()?));\n@@ -72,7 +75,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n                     &ty,\n                 )?;\n \n-                Some(format!(\"{}: {}\", f.name()?.syntax(), expr))\n+                Some(format!(\"{name}: {expr}\"))\n             })\n             .collect::<Vec<_>>();\n \n@@ -81,7 +84,10 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n             .enumerate()\n             .filter_map(|(i, f)| {\n                 if trivial_constructors[i].is_none() {\n-                    Some(format!(\"{}: {}\", f.name()?.syntax(), f.ty()?.syntax()))\n+                    let name = f.name()?;\n+                    let ty = f.ty()?;\n+\n+                    Some(format!(\"{name}: {ty}\"))\n                 } else {\n                     None\n                 }\n@@ -101,7 +107,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n             })\n             .format(\", \");\n \n-        format_to!(buf, \"    {}fn new({}) -> Self {{ Self {{ {} }} }}\", vis, params, fields);\n+        format_to!(buf, \"    {vis}fn new({params}) -> Self {{ Self {{ {fields} }} }}\");\n \n         let start_offset = impl_def\n             .and_then(|impl_def| find_impl_block_start(impl_def, &mut buf))"}, {"sha": "62f72df1c9d619823fa08bbac6352453df429cff", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_setter.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -36,11 +36,8 @@ pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opt\n \n     // Return early if we've found an existing fn\n     let fn_name = to_lower_snake_case(&field_name.to_string());\n-    let impl_def = find_struct_impl(\n-        ctx,\n-        &ast::Adt::Struct(strukt.clone()),\n-        format!(\"set_{}\", fn_name).as_str(),\n-    )?;\n+    let impl_def =\n+        find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &[format!(\"set_{fn_name}\")])?;\n \n     let target = field.syntax().text_range();\n     acc.add_group(\n@@ -55,18 +52,12 @@ pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opt\n                 buf.push('\\n');\n             }\n \n-            let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+            let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n             format_to!(\n                 buf,\n-                \"    {}fn set_{}(&mut self, {}: {}) {{\n-        self.{} = {};\n-    }}\",\n-                vis,\n-                fn_name,\n-                fn_name,\n-                field_ty,\n-                fn_name,\n-                fn_name,\n+                \"    {vis}fn set_{fn_name}(&mut self, {fn_name}: {field_ty}) {{\n+        self.{fn_name} = {fn_name};\n+    }}\"\n             );\n \n             let start_offset = impl_def"}, {"sha": "db32e7182c44d76ab78db38123862d8fe9f84257", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -331,10 +331,14 @@ fn calc_depth(pat: &ast::Pat, depth: usize) -> usize {\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n // FIXME: this partially overlaps with `find_impl_block_*`\n+\n+/// `find_struct_impl` looks for impl of a struct, but this also has additional feature\n+/// where it takes a list of function names and check if they exist inside impl_, if\n+/// even one match is found, it returns None\n pub(crate) fn find_struct_impl(\n     ctx: &AssistContext<'_>,\n     adt: &ast::Adt,\n-    name: &str,\n+    names: &[String],\n ) -> Option<Option<ast::Impl>> {\n     let db = ctx.db();\n     let module = adt.syntax().parent()?;\n@@ -362,20 +366,20 @@ pub(crate) fn find_struct_impl(\n     });\n \n     if let Some(ref impl_blk) = block {\n-        if has_fn(impl_blk, name) {\n+        if has_any_fn(impl_blk, names) {\n             return None;\n         }\n     }\n \n     Some(block)\n }\n \n-fn has_fn(imp: &ast::Impl, rhs_name: &str) -> bool {\n+fn has_any_fn(imp: &ast::Impl, names: &[String]) -> bool {\n     if let Some(il) = imp.assoc_item_list() {\n         for item in il.assoc_items() {\n             if let ast::AssocItem::Fn(f) = item {\n                 if let Some(name) = f.name() {\n-                    if name.text().eq_ignore_ascii_case(rhs_name) {\n+                    if names.iter().any(|n| n.eq_ignore_ascii_case(&name.text())) {\n                         return true;\n                     }\n                 }"}, {"sha": "085d8d32598a1301acb9f96512d1f9d7e71a008b", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/incorrect_try_expr.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/43dd3d514b6b11c5195de2fd8e665828801d0972/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dd3d514b6b11c5195de2fd8e665828801d0972/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs?ref=43dd3d514b6b11c5195de2fd8e665828801d0972", "patch": "@@ -1,37 +0,0 @@\n-use hir::InFile;\n-\n-use crate::{Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: incorrect-try-target\n-//\n-// This diagnostic is triggered if a question mark operator was used in a context where it is not applicable.\n-pub(crate) fn incorrect_try_expr(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::IncorrectTryExpr,\n-) -> Diagnostic {\n-    Diagnostic::new(\n-        \"incorrect-try-target\",\n-        format!(\"the return type of the containing function does not implement `FromResidual`\"),\n-        ctx.sema\n-            .diagnostics_display_range(InFile::new(d.expr.file_id, d.expr.value.clone().into()))\n-            .range,\n-    )\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::check_diagnostics;\n-\n-    #[test]\n-    fn try_ops_diag() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: try\n-fn test() {\n-    core::ops::ControlFlow::<u32, f32>::Continue(1.0)?;\n- // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: the return type of the containing function does not implement `FromResidual`\n-}\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "3bf6a4232298c7884a69c2ccd072f3483ed554c5", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/not_implemented.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/43dd3d514b6b11c5195de2fd8e665828801d0972/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dd3d514b6b11c5195de2fd8e665828801d0972/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs?ref=43dd3d514b6b11c5195de2fd8e665828801d0972", "patch": "@@ -1,35 +0,0 @@\n-use hir::{db::DefDatabase, HirDisplay};\n-\n-use crate::{Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: not-implemented\n-//\n-// This diagnostic is triggered if a type doesn't implement a necessary trait.\n-pub(crate) fn not_implemented(ctx: &DiagnosticsContext<'_>, d: &hir::NotImplemented) -> Diagnostic {\n-    Diagnostic::new(\n-        \"not-implemented\",\n-        format!(\n-            \"the trait `{}` is not implemented for `{}`\",\n-            ctx.sema.db.trait_data(d.trait_).name,\n-            d.ty.display(ctx.sema.db)\n-        ),\n-        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n-    )\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::check_diagnostics;\n-\n-    #[test]\n-    fn missing_try_impl() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: try\n-fn main() {\n-    ()?;\n-} //^^ error: the trait `Try` is not implemented for `()`\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "ae299f0584148937c64b897e7cf658359a5c7069", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -29,15 +29,13 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n-    pub(crate) mod incorrect_try_expr;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n     pub(crate) mod malformed_derive;\n     pub(crate) mod mismatched_arg_count;\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n-    pub(crate) mod not_implemented;\n     pub(crate) mod no_such_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n@@ -227,14 +225,12 @@ pub fn diagnostics(\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n-            AnyDiagnostic::IncorrectTryExpr(d) => handlers::incorrect_try_expr::incorrect_try_expr(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n-            AnyDiagnostic::NotImplemented(d) => handlers::not_implemented::not_implemented(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),"}, {"sha": "eb997e6fef83022f726dec8a2ff0e5cbcd6fdc86", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -4913,22 +4913,6 @@ fn foo() -> NotResult<(), Short> {\n                 ```\n             \"#]],\n     );\n-    check_hover_range(\n-        r#\"\n-//- minicore: try\n-use core::ops::ControlFlow;\n-fn foo() -> ControlFlow<()> {\n-    $0ControlFlow::Break(())?$0;\n-    ControlFlow::Continue(())\n-}\n-\"#,\n-        expect![[r#\"\n-            ```text\n-            Try Target Type: ControlFlow<(), {unknown}>\n-            Propagated as:          ControlFlow<(), ()>\n-            ```\n-        \"#]],\n-    );\n }\n \n #[test]\n@@ -4944,9 +4928,9 @@ fn foo() -> Option<()> {\n }\n \"#,\n         expect![[r#\"\n-            ```rust\n-            i32\n-            ```\"#]],\n+                ```rust\n+                <Option<i32> as Try>::Output\n+                ```\"#]],\n     );\n }\n "}, {"sha": "416817ca0b42c8c3bd4d7bb4c9c8b3afa7c43906", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -482,8 +482,18 @@ impl Analysis {\n     }\n \n     /// Returns crates this file belongs too.\n-    pub fn crate_for(&self, file_id: FileId) -> Cancellable<Vec<CrateId>> {\n-        self.with_db(|db| parent_module::crate_for(db, file_id))\n+    pub fn crates_for(&self, file_id: FileId) -> Cancellable<Vec<CrateId>> {\n+        self.with_db(|db| parent_module::crates_for(db, file_id))\n+    }\n+\n+    /// Returns crates this file belongs too.\n+    pub fn transitive_rev_deps(&self, crate_id: CrateId) -> Cancellable<Vec<CrateId>> {\n+        self.with_db(|db| db.crate_graph().transitive_rev_deps(crate_id).collect())\n+    }\n+\n+    /// Returns crates this file *might* belong too.\n+    pub fn relevant_crates_for(&self, file_id: FileId) -> Cancellable<Vec<CrateId>> {\n+        self.with_db(|db| db.relevant_crates(file_id).iter().copied().collect())\n     }\n \n     /// Returns the edition of the given crate."}, {"sha": "506f9452cf1964d003e3d3f06b5c20f5bcc9cde5", "filename": "src/tools/rust-analyzer/crates/ide/src/parent_module.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -1,6 +1,6 @@\n-use hir::Semantics;\n+use hir::{db::DefDatabase, Semantics};\n use ide_db::{\n-    base_db::{CrateId, FileId, FilePosition},\n+    base_db::{CrateId, FileId, FileLoader, FilePosition},\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -55,9 +55,13 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n }\n \n /// Returns `Vec` for the same reason as `parent_module`\n-pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n-    let sema = Semantics::new(db);\n-    sema.to_module_defs(file_id).map(|module| module.krate().into()).unique().collect()\n+pub(crate) fn crates_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n+    db.relevant_crates(file_id)\n+        .iter()\n+        .copied()\n+        .filter(|&crate_id| db.crate_def_map(crate_id).modules_for_file(file_id).next().is_some())\n+        .sorted()\n+        .collect()\n }\n \n #[cfg(test)]\n@@ -147,7 +151,7 @@ $0\n mod foo;\n \"#,\n         );\n-        assert_eq!(analysis.crate_for(file_id).unwrap().len(), 1);\n+        assert_eq!(analysis.crates_for(file_id).unwrap().len(), 1);\n     }\n \n     #[test]\n@@ -162,6 +166,6 @@ mod baz;\n mod baz;\n \"#,\n         );\n-        assert_eq!(analysis.crate_for(file_id).unwrap().len(), 2);\n+        assert_eq!(analysis.crates_for(file_id).unwrap().len(), 2);\n     }\n }"}, {"sha": "27ad1a948d13bcd41df548d764fd4f5accfadb63", "filename": "src/tools/rust-analyzer/crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -210,9 +210,7 @@ fn get_definition(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> Opt\n         let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops);\n         if let Some(&[x]) = def.as_deref() {\n             return Some(x);\n-        } else {\n-            continue;\n-        };\n+        }\n     }\n     None\n }"}, {"sha": "20810c25b3e81f976ee1b99190d788389165ad80", "filename": "src/tools/rust-analyzer/crates/ide/src/status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -45,7 +45,7 @@ pub(crate) fn status(db: &RootDatabase, file_id: Option<FileId>) -> String {\n \n     if let Some(file_id) = file_id {\n         format_to!(buf, \"\\nFile info:\\n\");\n-        let crates = crate::parent_module::crate_for(db, file_id);\n+        let crates = crate::parent_module::crates_for(db, file_id);\n         if crates.is_empty() {\n             format_to!(buf, \"Does not belong to any crate\");\n         }"}, {"sha": "cf9868740cb03a0d702fd65f517c101839caadd6", "filename": "src/tools/rust-analyzer/crates/project-model/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -17,7 +17,6 @@ semver = \"1.0.14\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = \"1.0.86\"\n anyhow = \"1.0.62\"\n-expect-test = \"1.4.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n \n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n@@ -26,3 +25,6 @@ toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n paths = { path = \"../paths\", version = \"0.0.0\" }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n+\n+[dev-dependencies]\n+expect-test = \"1.4.0\""}, {"sha": "a26a7c57acfce7541617ea48b6f7704ed30dbf5f", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 251, "deletions": 129, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -6,7 +6,12 @@\n //! This module implements this second part. We use \"build script\" terminology\n //! here, but it covers procedural macros as well.\n \n-use std::{cell::RefCell, io, path::PathBuf, process::Command};\n+use std::{\n+    cell::RefCell,\n+    io, mem,\n+    path::{self, PathBuf},\n+    process::Command,\n+};\n \n use cargo_metadata::{camino::Utf8Path, Message};\n use la_arena::ArenaMap;\n@@ -15,11 +20,14 @@ use rustc_hash::FxHashMap;\n use semver::Version;\n use serde::Deserialize;\n \n-use crate::{cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, Package};\n+use crate::{\n+    cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, InvocationLocation,\n+    InvocationStrategy, Package,\n+};\n \n #[derive(Debug, Default, Clone, PartialEq, Eq)]\n pub struct WorkspaceBuildScripts {\n-    outputs: ArenaMap<Package, Option<BuildScriptOutput>>,\n+    outputs: ArenaMap<Package, BuildScriptOutput>,\n     error: Option<String>,\n }\n \n@@ -38,106 +46,242 @@ pub(crate) struct BuildScriptOutput {\n     pub(crate) proc_macro_dylib_path: Option<AbsPathBuf>,\n }\n \n-impl WorkspaceBuildScripts {\n-    fn build_command(config: &CargoConfig) -> Command {\n-        if let Some([program, args @ ..]) = config.run_build_script_command.as_deref() {\n-            let mut cmd = Command::new(program);\n-            cmd.args(args);\n-            cmd.envs(&config.extra_env);\n-            return cmd;\n-        }\n+impl BuildScriptOutput {\n+    fn is_unchanged(&self) -> bool {\n+        self.cfgs.is_empty()\n+            && self.envs.is_empty()\n+            && self.out_dir.is_none()\n+            && self.proc_macro_dylib_path.is_none()\n+    }\n+}\n \n-        let mut cmd = Command::new(toolchain::cargo());\n-        cmd.envs(&config.extra_env);\n-        cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n+impl WorkspaceBuildScripts {\n+    fn build_command(config: &CargoConfig) -> io::Result<Command> {\n+        let mut cmd = match config.run_build_script_command.as_deref() {\n+            Some([program, args @ ..]) => {\n+                let mut cmd = Command::new(program);\n+                cmd.args(args);\n+                cmd\n+            }\n+            _ => {\n+                let mut cmd = Command::new(toolchain::cargo());\n \n-        // --all-targets includes tests, benches and examples in addition to the\n-        // default lib and bins. This is an independent concept from the --targets\n-        // flag below.\n-        cmd.arg(\"--all-targets\");\n+                cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n \n-        if let Some(target) = &config.target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n+                // --all-targets includes tests, benches and examples in addition to the\n+                // default lib and bins. This is an independent concept from the --targets\n+                // flag below.\n+                cmd.arg(\"--all-targets\");\n \n-        match &config.features {\n-            CargoFeatures::All => {\n-                cmd.arg(\"--all-features\");\n-            }\n-            CargoFeatures::Selected { features, no_default_features } => {\n-                if *no_default_features {\n-                    cmd.arg(\"--no-default-features\");\n+                if let Some(target) = &config.target {\n+                    cmd.args(&[\"--target\", target]);\n                 }\n-                if !features.is_empty() {\n-                    cmd.arg(\"--features\");\n-                    cmd.arg(features.join(\" \"));\n+\n+                match &config.features {\n+                    CargoFeatures::All => {\n+                        cmd.arg(\"--all-features\");\n+                    }\n+                    CargoFeatures::Selected { features, no_default_features } => {\n+                        if *no_default_features {\n+                            cmd.arg(\"--no-default-features\");\n+                        }\n+                        if !features.is_empty() {\n+                            cmd.arg(\"--features\");\n+                            cmd.arg(features.join(\" \"));\n+                        }\n+                    }\n                 }\n+\n+                cmd\n             }\n+        };\n+\n+        cmd.envs(&config.extra_env);\n+        if config.wrap_rustc_in_build_scripts {\n+            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n+            // that to compile only proc macros and build scripts during the initial\n+            // `cargo check`.\n+            let myself = std::env::current_exe()?;\n+            cmd.env(\"RUSTC_WRAPPER\", myself);\n+            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n         }\n \n-        cmd\n+        Ok(cmd)\n     }\n \n-    pub(crate) fn run(\n+    /// Runs the build scripts for the given workspace\n+    pub(crate) fn run_for_workspace(\n         config: &CargoConfig,\n         workspace: &CargoWorkspace,\n         progress: &dyn Fn(String),\n         toolchain: &Option<Version>,\n     ) -> io::Result<WorkspaceBuildScripts> {\n         const RUST_1_62: Version = Version::new(1, 62, 0);\n \n-        match Self::run_(Self::build_command(config), config, workspace, progress) {\n+        let current_dir = match &config.invocation_location {\n+            InvocationLocation::Root(root) if config.run_build_script_command.is_some() => {\n+                root.as_path()\n+            }\n+            _ => &workspace.workspace_root(),\n+        }\n+        .as_ref();\n+\n+        match Self::run_per_ws(Self::build_command(config)?, workspace, current_dir, progress) {\n             Ok(WorkspaceBuildScripts { error: Some(error), .. })\n                 if toolchain.as_ref().map_or(false, |it| *it >= RUST_1_62) =>\n             {\n                 // building build scripts failed, attempt to build with --keep-going so\n                 // that we potentially get more build data\n-                let mut cmd = Self::build_command(config);\n+                let mut cmd = Self::build_command(config)?;\n                 cmd.args(&[\"-Z\", \"unstable-options\", \"--keep-going\"]).env(\"RUSTC_BOOTSTRAP\", \"1\");\n-                let mut res = Self::run_(cmd, config, workspace, progress)?;\n+                let mut res = Self::run_per_ws(cmd, workspace, current_dir, progress)?;\n                 res.error = Some(error);\n                 Ok(res)\n             }\n             res => res,\n         }\n     }\n \n-    fn run_(\n-        mut cmd: Command,\n+    /// Runs the build scripts by invoking the configured command *once*.\n+    /// This populates the outputs for all passed in workspaces.\n+    pub(crate) fn run_once(\n         config: &CargoConfig,\n-        workspace: &CargoWorkspace,\n+        workspaces: &[&CargoWorkspace],\n         progress: &dyn Fn(String),\n-    ) -> io::Result<WorkspaceBuildScripts> {\n-        if config.wrap_rustc_in_build_scripts {\n-            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n-            // that to compile only proc macros and build scripts during the initial\n-            // `cargo check`.\n-            let myself = std::env::current_exe()?;\n-            cmd.env(\"RUSTC_WRAPPER\", myself);\n-            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n+    ) -> io::Result<Vec<WorkspaceBuildScripts>> {\n+        assert_eq!(config.invocation_strategy, InvocationStrategy::Once);\n+\n+        let current_dir = match &config.invocation_location {\n+            InvocationLocation::Root(root) => root,\n+            InvocationLocation::Workspace => {\n+                return Err(io::Error::new(\n+                    io::ErrorKind::Other,\n+                    \"Cannot run build scripts from workspace with invocation strategy `once`\",\n+                ))\n+            }\n+        };\n+        let cmd = Self::build_command(config)?;\n+        // NB: Cargo.toml could have been modified between `cargo metadata` and\n+        // `cargo check`. We shouldn't assume that package ids we see here are\n+        // exactly those from `config`.\n+        let mut by_id = FxHashMap::default();\n+        // some workspaces might depend on the same crates, so we need to duplicate the outputs\n+        // to those collisions\n+        let mut collisions = Vec::new();\n+        let mut res: Vec<_> = workspaces\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, workspace)| {\n+                let mut res = WorkspaceBuildScripts::default();\n+                for package in workspace.packages() {\n+                    res.outputs.insert(package, BuildScriptOutput::default());\n+                    if by_id.contains_key(&workspace[package].id) {\n+                        collisions.push((&workspace[package].id, idx, package));\n+                    } else {\n+                        by_id.insert(workspace[package].id.clone(), (package, idx));\n+                    }\n+                }\n+                res\n+            })\n+            .collect();\n+\n+        let errors = Self::run_command(\n+            cmd,\n+            current_dir.as_path().as_ref(),\n+            |package, cb| {\n+                if let Some(&(package, workspace)) = by_id.get(package) {\n+                    cb(&workspaces[workspace][package].name, &mut res[workspace].outputs[package]);\n+                }\n+            },\n+            progress,\n+        )?;\n+        res.iter_mut().for_each(|it| it.error = errors.clone());\n+        collisions.into_iter().for_each(|(id, workspace, package)| {\n+            if let Some(&(p, w)) = by_id.get(id) {\n+                res[workspace].outputs[package] = res[w].outputs[p].clone();\n+            }\n+        });\n+\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            for (idx, workspace) in workspaces.iter().enumerate() {\n+                for package in workspace.packages() {\n+                    let package_build_data = &mut res[idx].outputs[package];\n+                    if !package_build_data.is_unchanged() {\n+                        tracing::info!(\n+                            \"{}: {:?}\",\n+                            workspace[package].manifest.parent().display(),\n+                            package_build_data,\n+                        );\n+                    }\n+                }\n+            }\n         }\n \n-        cmd.current_dir(workspace.workspace_root());\n+        Ok(res)\n+    }\n \n+    fn run_per_ws(\n+        cmd: Command,\n+        workspace: &CargoWorkspace,\n+        current_dir: &path::Path,\n+        progress: &dyn Fn(String),\n+    ) -> io::Result<WorkspaceBuildScripts> {\n         let mut res = WorkspaceBuildScripts::default();\n         let outputs = &mut res.outputs;\n         // NB: Cargo.toml could have been modified between `cargo metadata` and\n         // `cargo check`. We shouldn't assume that package ids we see here are\n         // exactly those from `config`.\n         let mut by_id: FxHashMap<String, Package> = FxHashMap::default();\n         for package in workspace.packages() {\n-            outputs.insert(package, None);\n+            outputs.insert(package, BuildScriptOutput::default());\n             by_id.insert(workspace[package].id.clone(), package);\n         }\n \n+        res.error = Self::run_command(\n+            cmd,\n+            current_dir,\n+            |package, cb| {\n+                if let Some(&package) = by_id.get(package) {\n+                    cb(&workspace[package].name, &mut outputs[package]);\n+                }\n+            },\n+            progress,\n+        )?;\n+\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            for package in workspace.packages() {\n+                let package_build_data = &mut outputs[package];\n+                if !package_build_data.is_unchanged() {\n+                    tracing::info!(\n+                        \"{}: {:?}\",\n+                        workspace[package].manifest.parent().display(),\n+                        package_build_data,\n+                    );\n+                }\n+            }\n+        }\n+\n+        Ok(res)\n+    }\n+\n+    fn run_command(\n+        mut cmd: Command,\n+        current_dir: &path::Path,\n+        // ideally this would be something like:\n+        // with_output_for: impl FnMut(&str, dyn FnOnce(&mut BuildScriptOutput)),\n+        // but owned trait objects aren't a thing\n+        mut with_output_for: impl FnMut(&str, &mut dyn FnMut(&str, &mut BuildScriptOutput)),\n+        progress: &dyn Fn(String),\n+    ) -> io::Result<Option<String>> {\n         let errors = RefCell::new(String::new());\n         let push_err = |err: &str| {\n             let mut e = errors.borrow_mut();\n             e.push_str(err);\n             e.push('\\n');\n         };\n \n-        tracing::info!(\"Running build scripts: {:?}\", cmd);\n+        tracing::info!(\"Running build scripts in {}: {:?}\", current_dir.display(), cmd);\n+        cmd.current_dir(current_dir);\n         let output = stdx::process::spawn_with_streaming_output(\n             cmd,\n             &mut |line| {\n@@ -149,61 +293,58 @@ impl WorkspaceBuildScripts {\n                     .unwrap_or_else(|_| Message::TextLine(line.to_string()));\n \n                 match message {\n-                    Message::BuildScriptExecuted(message) => {\n-                        let package = match by_id.get(&message.package_id.repr) {\n-                            Some(&it) => it,\n-                            None => return,\n-                        };\n-                        progress(format!(\"running build-script: {}\", workspace[package].name));\n-\n-                        let cfgs = {\n-                            let mut acc = Vec::new();\n-                            for cfg in message.cfgs {\n-                                match cfg.parse::<CfgFlag>() {\n-                                    Ok(it) => acc.push(it),\n-                                    Err(err) => {\n-                                        push_err(&format!(\n-                                            \"invalid cfg from cargo-metadata: {}\",\n-                                            err\n-                                        ));\n-                                        return;\n-                                    }\n-                                };\n+                    Message::BuildScriptExecuted(mut message) => {\n+                        with_output_for(&message.package_id.repr, &mut |name, data| {\n+                            progress(format!(\"running build-script: {}\", name));\n+                            let cfgs = {\n+                                let mut acc = Vec::new();\n+                                for cfg in &message.cfgs {\n+                                    match cfg.parse::<CfgFlag>() {\n+                                        Ok(it) => acc.push(it),\n+                                        Err(err) => {\n+                                            push_err(&format!(\n+                                                \"invalid cfg from cargo-metadata: {}\",\n+                                                err\n+                                            ));\n+                                            return;\n+                                        }\n+                                    };\n+                                }\n+                                acc\n+                            };\n+                            if !message.env.is_empty() {\n+                                data.envs = mem::take(&mut message.env);\n                             }\n-                            acc\n-                        };\n-                        // cargo_metadata crate returns default (empty) path for\n-                        // older cargos, which is not absolute, so work around that.\n-                        let out_dir = message.out_dir.into_os_string();\n-                        if !out_dir.is_empty() {\n-                            let data = outputs[package].get_or_insert_with(Default::default);\n-                            data.out_dir = Some(AbsPathBuf::assert(PathBuf::from(out_dir)));\n-                            data.cfgs = cfgs;\n-                        }\n-                        if !message.env.is_empty() {\n-                            outputs[package].get_or_insert_with(Default::default).envs =\n-                                message.env;\n-                        }\n+                            // cargo_metadata crate returns default (empty) path for\n+                            // older cargos, which is not absolute, so work around that.\n+                            let out_dir = mem::take(&mut message.out_dir).into_os_string();\n+                            if !out_dir.is_empty() {\n+                                let out_dir = AbsPathBuf::assert(PathBuf::from(out_dir));\n+                                // inject_cargo_env(package, package_build_data);\n+                                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+                                if let Some(out_dir) =\n+                                    out_dir.as_os_str().to_str().map(|s| s.to_owned())\n+                                {\n+                                    data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n+                                }\n+                                data.out_dir = Some(out_dir);\n+                                data.cfgs = cfgs;\n+                            }\n+                        });\n                     }\n                     Message::CompilerArtifact(message) => {\n-                        let package = match by_id.get(&message.package_id.repr) {\n-                            Some(it) => *it,\n-                            None => return,\n-                        };\n-\n-                        progress(format!(\"building proc-macros: {}\", message.target.name));\n-\n-                        if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n-                            // Skip rmeta file\n-                            if let Some(filename) =\n-                                message.filenames.iter().find(|name| is_dylib(name))\n-                            {\n-                                let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n-                                outputs[package]\n-                                    .get_or_insert_with(Default::default)\n-                                    .proc_macro_dylib_path = Some(filename);\n+                        with_output_for(&message.package_id.repr, &mut |name, data| {\n+                            progress(format!(\"building proc-macros: {}\", name));\n+                            if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n+                                // Skip rmeta file\n+                                if let Some(filename) =\n+                                    message.filenames.iter().find(|name| is_dylib(name))\n+                                {\n+                                    let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n+                                    data.proc_macro_dylib_path = Some(filename);\n+                                }\n                             }\n-                        }\n+                        });\n                     }\n                     Message::CompilerMessage(message) => {\n                         progress(message.target.name);\n@@ -222,44 +363,25 @@ impl WorkspaceBuildScripts {\n             },\n         )?;\n \n-        for package in workspace.packages() {\n-            if let Some(package_build_data) = &mut outputs[package] {\n-                tracing::info!(\n-                    \"{}: {:?}\",\n-                    workspace[package].manifest.parent().display(),\n-                    package_build_data,\n-                );\n-                // inject_cargo_env(package, package_build_data);\n-                if let Some(out_dir) = &package_build_data.out_dir {\n-                    // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                    if let Some(out_dir) = out_dir.as_os_str().to_str().map(|s| s.to_owned()) {\n-                        package_build_data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut errors = errors.into_inner();\n-        if !output.status.success() {\n-            if errors.is_empty() {\n-                errors = \"cargo check failed\".to_string();\n-            }\n-            res.error = Some(errors);\n-        }\n-\n-        Ok(res)\n+        let errors = if !output.status.success() {\n+            let errors = errors.into_inner();\n+            Some(if errors.is_empty() { \"cargo check failed\".to_string() } else { errors })\n+        } else {\n+            None\n+        };\n+        Ok(errors)\n     }\n \n     pub fn error(&self) -> Option<&str> {\n         self.error.as_deref()\n     }\n \n     pub(crate) fn get_output(&self, idx: Package) -> Option<&BuildScriptOutput> {\n-        self.outputs.get(idx)?.as_ref()\n+        self.outputs.get(idx)\n     }\n }\n \n-// FIXME: File a better way to know if it is a dylib.\n+// FIXME: Find a better way to know if it is a dylib.\n fn is_dylib(path: &Utf8Path) -> bool {\n     match path.extension().map(|e| e.to_string().to_lowercase()) {\n         None => false,"}, {"sha": "b4c2ba436772f3d237e3d831ba4352aef3f26a99", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -14,8 +14,8 @@ use rustc_hash::FxHashMap;\n use serde::Deserialize;\n use serde_json::from_value;\n \n-use crate::CfgOverrides;\n-use crate::{utf8_stdout, ManifestPath};\n+use crate::{utf8_stdout, InvocationLocation, ManifestPath};\n+use crate::{CfgOverrides, InvocationStrategy};\n \n /// [`CargoWorkspace`] represents the logical structure of, well, a Cargo\n /// workspace. It pretty closely mirrors `cargo metadata` output.\n@@ -106,6 +106,8 @@ pub struct CargoConfig {\n     pub run_build_script_command: Option<Vec<String>>,\n     /// Extra env vars to set when invoking the cargo command\n     pub extra_env: FxHashMap<String, String>,\n+    pub invocation_strategy: InvocationStrategy,\n+    pub invocation_location: InvocationLocation,\n }\n \n impl CargoConfig {\n@@ -283,8 +285,6 @@ impl CargoWorkspace {\n             }\n             CargoFeatures::Selected { features, no_default_features } => {\n                 if *no_default_features {\n-                    // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n-                    // https://github.com/oli-obk/cargo_metadata/issues/79\n                     meta.features(CargoOpt::NoDefaultFeatures);\n                 }\n                 if !features.is_empty() {\n@@ -329,18 +329,21 @@ impl CargoWorkspace {\n         let ws_members = &meta.workspace_members;\n \n         meta.packages.sort_by(|a, b| a.id.cmp(&b.id));\n-        for meta_pkg in &meta.packages {\n+        for meta_pkg in meta.packages {\n             let cargo_metadata::Package {\n-                id,\n-                edition,\n                 name,\n-                manifest_path,\n                 version,\n-                metadata,\n+                id,\n+                source,\n+                targets: meta_targets,\n+                features,\n+                manifest_path,\n                 repository,\n+                edition,\n+                metadata,\n                 ..\n             } = meta_pkg;\n-            let meta = from_value::<PackageMetadata>(metadata.clone()).unwrap_or_default();\n+            let meta = from_value::<PackageMetadata>(metadata).unwrap_or_default();\n             let edition = match edition {\n                 cargo_metadata::Edition::E2015 => Edition::Edition2015,\n                 cargo_metadata::Edition::E2018 => Edition::Edition2018,\n@@ -352,35 +355,36 @@ impl CargoWorkspace {\n             };\n             // We treat packages without source as \"local\" packages. That includes all members of\n             // the current workspace, as well as any path dependency outside the workspace.\n-            let is_local = meta_pkg.source.is_none();\n-            let is_member = ws_members.contains(id);\n+            let is_local = source.is_none();\n+            let is_member = ws_members.contains(&id);\n \n             let pkg = packages.alloc(PackageData {\n                 id: id.repr.clone(),\n-                name: name.clone(),\n-                version: version.clone(),\n-                manifest: AbsPathBuf::assert(PathBuf::from(&manifest_path)).try_into().unwrap(),\n+                name,\n+                version,\n+                manifest: AbsPathBuf::assert(manifest_path.into()).try_into().unwrap(),\n                 targets: Vec::new(),\n                 is_local,\n                 is_member,\n                 edition,\n-                repository: repository.clone(),\n+                repository,\n                 dependencies: Vec::new(),\n-                features: meta_pkg.features.clone().into_iter().collect(),\n+                features: features.into_iter().collect(),\n                 active_features: Vec::new(),\n                 metadata: meta.rust_analyzer.unwrap_or_default(),\n             });\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(id, pkg);\n-            for meta_tgt in &meta_pkg.targets {\n-                let is_proc_macro = meta_tgt.kind.as_slice() == [\"proc-macro\"];\n+            for meta_tgt in meta_targets {\n+                let cargo_metadata::Target { name, kind, required_features, src_path, .. } =\n+                    meta_tgt;\n                 let tgt = targets.alloc(TargetData {\n                     package: pkg,\n-                    name: meta_tgt.name.clone(),\n-                    root: AbsPathBuf::assert(PathBuf::from(&meta_tgt.src_path)),\n-                    kind: TargetKind::new(meta_tgt.kind.as_slice()),\n-                    is_proc_macro,\n-                    required_features: meta_tgt.required_features.clone(),\n+                    name,\n+                    root: AbsPathBuf::assert(src_path.into()),\n+                    kind: TargetKind::new(&kind),\n+                    is_proc_macro: &*kind == [\"proc-macro\"],\n+                    required_features,\n                 });\n                 pkg_data.targets.push(tgt);\n             }"}, {"sha": "575581fa543a309495a5c3806d26703d03bf1298", "filename": "src/tools/rust-analyzer/crates/project-model/src/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -67,7 +67,7 @@ impl ProjectManifest {\n         if path.file_name().unwrap_or_default() == \"Cargo.toml\" {\n             return Ok(ProjectManifest::CargoToml(path));\n         }\n-        bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display())\n+        bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display());\n     }\n \n     pub fn discover_single(path: &AbsPath) -> Result<ProjectManifest> {\n@@ -78,7 +78,7 @@ impl ProjectManifest {\n         };\n \n         if !candidates.is_empty() {\n-            bail!(\"more than one project\")\n+            bail!(\"more than one project\");\n         }\n         Ok(res)\n     }\n@@ -157,3 +157,17 @@ fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     let stdout = String::from_utf8(output.stdout)?;\n     Ok(stdout.trim().to_string())\n }\n+\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub enum InvocationStrategy {\n+    Once,\n+    #[default]\n+    PerWorkspace,\n+}\n+\n+#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+pub enum InvocationLocation {\n+    Root(AbsPathBuf),\n+    #[default]\n+    Workspace,\n+}"}, {"sha": "fa8d76f3f45297922192f0ce6f0cca467552a7ed", "filename": "src/tools/rust-analyzer/crates/project-model/src/sysroot.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -64,14 +64,15 @@ impl Sysroot {\n         self.by_name(\"proc_macro\")\n     }\n \n-    pub fn crates<'a>(&'a self) -> impl Iterator<Item = SysrootCrate> + ExactSizeIterator + 'a {\n+    pub fn crates(&self) -> impl Iterator<Item = SysrootCrate> + ExactSizeIterator + '_ {\n         self.crates.iter().map(|(id, _data)| id)\n     }\n }\n \n impl Sysroot {\n+    /// Attempts to discover the toolchain's sysroot from the given `dir`.\n     pub fn discover(dir: &AbsPath, extra_env: &FxHashMap<String, String>) -> Result<Sysroot> {\n-        tracing::debug!(\"Discovering sysroot for {}\", dir.display());\n+        tracing::debug!(\"discovering sysroot for {}\", dir.display());\n         let sysroot_dir = discover_sysroot_dir(dir, extra_env)?;\n         let sysroot_src_dir =\n             discover_sysroot_src_dir_or_add_component(&sysroot_dir, dir, extra_env)?;\n@@ -83,11 +84,10 @@ impl Sysroot {\n         cargo_toml: &ManifestPath,\n         extra_env: &FxHashMap<String, String>,\n     ) -> Option<ManifestPath> {\n-        tracing::debug!(\"Discovering rustc source for {}\", cargo_toml.display());\n+        tracing::debug!(\"discovering rustc source for {}\", cargo_toml.display());\n         let current_dir = cargo_toml.parent();\n-        discover_sysroot_dir(current_dir, extra_env)\n-            .ok()\n-            .and_then(|sysroot_dir| get_rustc_src(&sysroot_dir))\n+        let sysroot_dir = discover_sysroot_dir(current_dir, extra_env).ok()?;\n+        get_rustc_src(&sysroot_dir)\n     }\n \n     pub fn with_sysroot_dir(sysroot_dir: AbsPathBuf) -> Result<Sysroot> {\n@@ -189,6 +189,7 @@ fn discover_sysroot_src_dir(sysroot_path: &AbsPathBuf) -> Option<AbsPathBuf> {\n \n     get_rust_src(sysroot_path)\n }\n+\n fn discover_sysroot_src_dir_or_add_component(\n     sysroot_path: &AbsPathBuf,\n     current_dir: &AbsPath,\n@@ -199,6 +200,7 @@ fn discover_sysroot_src_dir_or_add_component(\n             let mut rustup = Command::new(toolchain::rustup());\n             rustup.envs(extra_env);\n             rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n+            tracing::info!(\"adding rust-src component by {:?}\", rustup);\n             utf8_stdout(rustup).ok()?;\n             get_rust_src(sysroot_path)\n         })\n@@ -217,7 +219,7 @@ try installing the Rust source the same way you installed rustc\",\n fn get_rustc_src(sysroot_path: &AbsPath) -> Option<ManifestPath> {\n     let rustc_src = sysroot_path.join(\"lib/rustlib/rustc-src/rust/compiler/rustc/Cargo.toml\");\n     let rustc_src = ManifestPath::try_from(rustc_src).ok()?;\n-    tracing::debug!(\"Checking for rustc source code: {}\", rustc_src.display());\n+    tracing::debug!(\"checking for rustc source code: {}\", rustc_src.display());\n     if fs::metadata(&rustc_src).is_ok() {\n         Some(rustc_src)\n     } else {\n@@ -227,7 +229,7 @@ fn get_rustc_src(sysroot_path: &AbsPath) -> Option<ManifestPath> {\n \n fn get_rust_src(sysroot_path: &AbsPath) -> Option<AbsPathBuf> {\n     let rust_src = sysroot_path.join(\"lib/rustlib/src/rust/library\");\n-    tracing::debug!(\"Checking sysroot: {}\", rust_src.display());\n+    tracing::debug!(\"checking sysroot library: {}\", rust_src.display());\n     if fs::metadata(&rust_src).is_ok() {\n         Some(rust_src)\n     } else {"}, {"sha": "2780c62ed118afd022829408b3167148ea65e2f5", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -2,7 +2,7 @@\n //! metadata` or `rust-project.json`) into representation stored in the salsa\n //! database -- `CrateGraph`.\n \n-use std::{collections::VecDeque, fmt, fs, process::Command};\n+use std::{collections::VecDeque, fmt, fs, process::Command, sync::Arc};\n \n use anyhow::{format_err, Context, Result};\n use base_db::{\n@@ -21,8 +21,8 @@ use crate::{\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n-    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, Package, ProjectJson, ProjectManifest,\n-    Sysroot, TargetKind, WorkspaceBuildScripts,\n+    utf8_stdout, CargoConfig, CargoWorkspace, InvocationStrategy, ManifestPath, Package,\n+    ProjectJson, ProjectManifest, Sysroot, TargetKind, WorkspaceBuildScripts,\n };\n \n /// A set of cfg-overrides per crate.\n@@ -209,6 +209,9 @@ impl ProjectWorkspace {\n                     ),\n                     None => None,\n                 };\n+                if let Some(sysroot) = &sysroot {\n+                    tracing::info!(src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n+                }\n \n                 let rustc_dir = match &config.rustc_source {\n                     Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n@@ -217,6 +220,9 @@ impl ProjectWorkspace {\n                     }\n                     None => None,\n                 };\n+                if let Some(rustc_dir) = &rustc_dir {\n+                    tracing::info!(rustc_dir = %rustc_dir.display(), \"Using rustc source\");\n+                }\n \n                 let rustc = match rustc_dir {\n                     Some(rustc_dir) => Some({\n@@ -277,6 +283,9 @@ impl ProjectWorkspace {\n             }\n             (None, None) => None,\n         };\n+        if let Some(sysroot) = &sysroot {\n+            tracing::info!(src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n+        }\n \n         let rustc_cfg = rustc_cfg::get(None, target, extra_env);\n         Ok(ProjectWorkspace::Json { project: project_json, sysroot, rustc_cfg })\n@@ -294,23 +303,71 @@ impl ProjectWorkspace {\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n+    /// Runs the build scripts for this [`ProjectWorkspace`].\n     pub fn run_build_scripts(\n         &self,\n         config: &CargoConfig,\n         progress: &dyn Fn(String),\n     ) -> Result<WorkspaceBuildScripts> {\n         match self {\n             ProjectWorkspace::Cargo { cargo, toolchain, .. } => {\n-                WorkspaceBuildScripts::run(config, cargo, progress, toolchain).with_context(|| {\n-                    format!(\"Failed to run build scripts for {}\", &cargo.workspace_root().display())\n-                })\n+                WorkspaceBuildScripts::run_for_workspace(config, cargo, progress, toolchain)\n+                    .with_context(|| {\n+                        format!(\n+                            \"Failed to run build scripts for {}\",\n+                            &cargo.workspace_root().display()\n+                        )\n+                    })\n             }\n             ProjectWorkspace::Json { .. } | ProjectWorkspace::DetachedFiles { .. } => {\n                 Ok(WorkspaceBuildScripts::default())\n             }\n         }\n     }\n \n+    /// Runs the build scripts for the given [`ProjectWorkspace`]s. Depending on the invocation\n+    /// strategy this may run a single build process for all project workspaces.\n+    pub fn run_all_build_scripts(\n+        workspaces: &[ProjectWorkspace],\n+        config: &CargoConfig,\n+        progress: &dyn Fn(String),\n+    ) -> Vec<Result<WorkspaceBuildScripts>> {\n+        if matches!(config.invocation_strategy, InvocationStrategy::PerWorkspace)\n+            || config.run_build_script_command.is_none()\n+        {\n+            return workspaces.iter().map(|it| it.run_build_scripts(config, progress)).collect();\n+        }\n+\n+        let cargo_ws: Vec<_> = workspaces\n+            .iter()\n+            .filter_map(|it| match it {\n+                ProjectWorkspace::Cargo { cargo, .. } => Some(cargo),\n+                _ => None,\n+            })\n+            .collect();\n+        let ref mut outputs = match WorkspaceBuildScripts::run_once(config, &cargo_ws, progress) {\n+            Ok(it) => Ok(it.into_iter()),\n+            // io::Error is not Clone?\n+            Err(e) => Err(Arc::new(e)),\n+        };\n+\n+        workspaces\n+            .iter()\n+            .map(|it| match it {\n+                ProjectWorkspace::Cargo { cargo, .. } => match outputs {\n+                    Ok(outputs) => Ok(outputs.next().unwrap()),\n+                    Err(e) => Err(e.clone()).with_context(|| {\n+                        format!(\n+                            \"Failed to run build scripts for {}\",\n+                            &cargo.workspace_root().display()\n+                        )\n+                    }),\n+                },\n+                _ => Ok(WorkspaceBuildScripts::default()),\n+            })\n+            .collect()\n+    }\n+\n     pub fn set_build_scripts(&mut self, bs: WorkspaceBuildScripts) {\n         match self {\n             ProjectWorkspace::Cargo { build_scripts, .. } => *build_scripts = bs,"}, {"sha": "6ede194babc2067529fdec2f810fbee62cc1c06d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -118,7 +118,7 @@ impl CargoTargetSpec {\n         global_state_snapshot: &GlobalStateSnapshot,\n         file_id: FileId,\n     ) -> Result<Option<CargoTargetSpec>> {\n-        let crate_id = match &*global_state_snapshot.analysis.crate_for(file_id)? {\n+        let crate_id = match &*global_state_snapshot.analysis.crates_for(file_id)? {\n             &[crate_id, ..] => crate_id,\n             _ => return Ok(None),\n         };"}, {"sha": "8b77ccde0ee4aaf94a4a9cfb0da3830fd44e951e", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 38, "deletions": 69, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -8,8 +8,8 @@ use std::{\n use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n use hir::Name;\n use ide::{\n-    LineCol, MonikerDescriptorKind, MonikerResult, StaticIndex, StaticIndexedFile, TextRange,\n-    TokenId,\n+    LineCol, MonikerDescriptorKind, StaticIndex, StaticIndexedFile, TextRange, TokenId,\n+    TokenStaticData,\n };\n use ide_db::LineIndexDatabase;\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n@@ -75,7 +75,7 @@ impl flags::Scip {\n         let mut symbols_emitted: HashSet<TokenId> = HashSet::default();\n         let mut tokens_to_symbol: HashMap<TokenId, String> = HashMap::new();\n \n-        for file in si.files {\n+        for StaticIndexedFile { file_id, tokens, .. } in si.files {\n             let mut local_count = 0;\n             let mut new_local_symbol = || {\n                 let new_symbol = scip::types::Symbol::new_local(local_count);\n@@ -84,7 +84,6 @@ impl flags::Scip {\n                 new_symbol\n             };\n \n-            let StaticIndexedFile { file_id, tokens, .. } = file;\n             let relative_path = match get_relative_filepath(&vfs, &rootpath, file_id) {\n                 Some(relative_path) => relative_path,\n                 None => continue,\n@@ -107,28 +106,20 @@ impl flags::Scip {\n \n                 let mut occurrence = scip_types::Occurrence::default();\n                 occurrence.range = text_range_to_scip_range(&line_index, range);\n-                occurrence.symbol = match tokens_to_symbol.get(&id) {\n-                    Some(symbol) => symbol.clone(),\n-                    None => {\n-                        let symbol = match &token.moniker {\n-                            Some(moniker) => moniker_to_symbol(&moniker),\n-                            None => new_local_symbol(),\n-                        };\n-\n-                        let symbol = scip::symbol::format_symbol(symbol);\n-                        tokens_to_symbol.insert(id, symbol.clone());\n-                        symbol\n-                    }\n-                };\n+                occurrence.symbol = tokens_to_symbol\n+                    .entry(id)\n+                    .or_insert_with(|| {\n+                        let symbol = token_to_symbol(&token).unwrap_or_else(&mut new_local_symbol);\n+                        scip::symbol::format_symbol(symbol)\n+                    })\n+                    .clone();\n \n                 if let Some(def) = token.definition {\n                     if def.range == range {\n                         occurrence.symbol_roles |= scip_types::SymbolRole::Definition as i32;\n                     }\n \n-                    if !symbols_emitted.contains(&id) {\n-                        symbols_emitted.insert(id);\n-\n+                    if symbols_emitted.insert(id) {\n                         let mut symbol_info = scip_types::SymbolInformation::default();\n                         symbol_info.symbol = occurrence.symbol.clone();\n                         if let Some(hover) = &token.hover {\n@@ -207,9 +198,11 @@ fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_ty\n ///\n /// Only returns a Symbol when it's a non-local symbol.\n ///     So if the visibility isn't outside of a document, then it will return None\n-fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n+fn token_to_symbol(token: &TokenStaticData) -> Option<scip_types::Symbol> {\n     use scip_types::descriptor::Suffix::*;\n \n+    let moniker = token.moniker.as_ref()?;\n+\n     let package_name = moniker.package_information.name.clone();\n     let version = moniker.package_information.version.clone();\n     let descriptors = moniker\n@@ -233,7 +226,7 @@ fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n         })\n         .collect();\n \n-    scip_types::Symbol {\n+    Some(scip_types::Symbol {\n         scheme: \"rust-analyzer\".into(),\n         package: Some(scip_types::Package {\n             manager: \"cargo\".to_string(),\n@@ -244,19 +237,15 @@ fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n         .into(),\n         descriptors,\n         ..Default::default()\n-    }\n+    })\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n-    use hir::Semantics;\n-    use ide::{AnalysisHost, FilePosition};\n-    use ide_db::defs::IdentClass;\n-    use ide_db::{base_db::fixture::ChangeFixture, helpers::pick_best_token};\n+    use ide::{AnalysisHost, FilePosition, StaticIndex, TextSize};\n+    use ide_db::base_db::fixture::ChangeFixture;\n     use scip::symbol::format_symbol;\n-    use syntax::SyntaxKind::*;\n-    use syntax::{AstNode, T};\n \n     fn position(ra_fixture: &str) -> (AnalysisHost, FilePosition) {\n         let mut host = AnalysisHost::default();\n@@ -273,53 +262,33 @@ mod test {\n     fn check_symbol(ra_fixture: &str, expected: &str) {\n         let (host, position) = position(ra_fixture);\n \n+        let analysis = host.analysis();\n+        let si = StaticIndex::compute(&analysis);\n+\n         let FilePosition { file_id, offset } = position;\n \n-        let db = host.raw_database();\n-        let sema = &Semantics::new(db);\n-        let file = sema.parse(file_id).syntax().clone();\n-        let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-            IDENT\n-            | INT_NUMBER\n-            | LIFETIME_IDENT\n-            | T![self]\n-            | T![super]\n-            | T![crate]\n-            | T![Self]\n-            | COMMENT => 2,\n-            kind if kind.is_trivia() => 0,\n-            _ => 1,\n-        })\n-        .expect(\"OK OK\");\n-\n-        let navs = sema\n-            .descend_into_macros(original_token.clone())\n-            .into_iter()\n-            .filter_map(|token| {\n-                IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n-                    it.into_iter().flat_map(|def| {\n-                        let module = def.module(db).unwrap();\n-                        let current_crate = module.krate();\n-\n-                        match MonikerResult::from_def(sema.db, def, current_crate) {\n-                            Some(moniker_result) => Some(moniker_to_symbol(&moniker_result)),\n-                            None => None,\n-                        }\n-                    })\n-                })\n-            })\n-            .flatten()\n-            .collect::<Vec<_>>();\n+        let mut found_symbol = None;\n+        for file in &si.files {\n+            if file.file_id != file_id {\n+                continue;\n+            }\n+            for &(range, id) in &file.tokens {\n+                if range.contains(offset - TextSize::from(1)) {\n+                    let token = si.tokens.get(id).unwrap();\n+                    found_symbol = token_to_symbol(token);\n+                    break;\n+                }\n+            }\n+        }\n \n         if expected == \"\" {\n-            assert_eq!(0, navs.len(), \"must have no symbols {:?}\", navs);\n+            assert!(found_symbol.is_none(), \"must have no symbols {:?}\", found_symbol);\n             return;\n         }\n \n-        assert_eq!(1, navs.len(), \"must have one symbol {:?}\", navs);\n-\n-        let res = navs.get(0).unwrap();\n-        let formatted = format_symbol(res.clone());\n+        assert!(found_symbol.is_some(), \"must have one symbol {:?}\", found_symbol);\n+        let res = found_symbol.unwrap();\n+        let formatted = format_symbol(res);\n         assert_eq!(formatted, expected);\n     }\n "}, {"sha": "85322f12a834cce2ea6507e7020e07f8fbe610ac", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -69,6 +69,19 @@ config_data! {\n         cargo_autoreload: bool           = \"true\",\n         /// Run build scripts (`build.rs`) for more precise code analysis.\n         cargo_buildScripts_enable: bool  = \"true\",\n+        /// Specifies the working directory for running build scripts.\n+        /// - \"workspace\": run build scripts for a workspace in the workspace's root directory.\n+        ///   This is incompatible with `#rust-analyzer.cargo.buildScripts.invocationStrategy#` set to `once`.\n+        /// - \"root\": run build scripts in the project's root directory.\n+        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+        /// is set.\n+        cargo_buildScripts_invocationLocation: InvocationLocation = \"\\\"workspace\\\"\",\n+        /// Specifies the invocation strategy to use when running the build scripts command.\n+        /// If `per_workspace` is set, the command will be executed for each workspace.\n+        /// If `once` is set, the command will be executed once.\n+        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+        /// is set.\n+        cargo_buildScripts_invocationStrategy: InvocationStrategy = \"\\\"per_workspace\\\"\",\n         /// Override the command rust-analyzer uses to run build scripts and\n         /// build procedural macros. The command is required to output json\n         /// and should therefore include `--message-format=json` or a similar\n@@ -122,6 +135,20 @@ config_data! {\n         ///\n         /// Set to `\"all\"` to pass `--all-features` to Cargo.\n         checkOnSave_features: Option<CargoFeaturesDef>      = \"null\",\n+        /// Specifies the working directory for running checks.\n+        /// - \"workspace\": run checks for workspaces in the corresponding workspaces' root directories.\n+        // FIXME: Ideally we would support this in some way\n+        ///   This falls back to \"root\" if `#rust-analyzer.cargo.checkOnSave.invocationStrategy#` is set to `once`.\n+        /// - \"root\": run checks in the project's root directory.\n+        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+        /// is set.\n+        checkOnSave_invocationLocation: InvocationLocation = \"\\\"workspace\\\"\",\n+        /// Specifies the invocation strategy to use when running the checkOnSave command.\n+        /// If `per_workspace` is set, the command will be executed for each workspace.\n+        /// If `once` is set, the command will be executed once.\n+        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+        /// is set.\n+        checkOnSave_invocationStrategy: InvocationStrategy = \"\\\"per_workspace\\\"\",\n         /// Whether to pass `--no-default-features` to Cargo. Defaults to\n         /// `#rust-analyzer.cargo.noDefaultFeatures#`.\n         checkOnSave_noDefaultFeatures: Option<bool>      = \"null\",\n@@ -1056,6 +1083,16 @@ impl Config {\n             rustc_source,\n             unset_test_crates: UnsetTestCrates::Only(self.data.cargo_unsetTest.clone()),\n             wrap_rustc_in_build_scripts: self.data.cargo_buildScripts_useRustcWrapper,\n+            invocation_strategy: match self.data.cargo_buildScripts_invocationStrategy {\n+                InvocationStrategy::Once => project_model::InvocationStrategy::Once,\n+                InvocationStrategy::PerWorkspace => project_model::InvocationStrategy::PerWorkspace,\n+            },\n+            invocation_location: match self.data.cargo_buildScripts_invocationLocation {\n+                InvocationLocation::Root => {\n+                    project_model::InvocationLocation::Root(self.root_path.clone())\n+                }\n+                InvocationLocation::Workspace => project_model::InvocationLocation::Workspace,\n+            },\n             run_build_script_command: self.data.cargo_buildScripts_overrideCommand.clone(),\n             extra_env: self.data.cargo_extraEnv.clone(),\n         }\n@@ -1087,6 +1124,18 @@ impl Config {\n                     command,\n                     args,\n                     extra_env: self.check_on_save_extra_env(),\n+                    invocation_strategy: match self.data.checkOnSave_invocationStrategy {\n+                        InvocationStrategy::Once => flycheck::InvocationStrategy::Once,\n+                        InvocationStrategy::PerWorkspace => {\n+                            flycheck::InvocationStrategy::PerWorkspace\n+                        }\n+                    },\n+                    invocation_location: match self.data.checkOnSave_invocationLocation {\n+                        InvocationLocation::Root => {\n+                            flycheck::InvocationLocation::Root(self.root_path.clone())\n+                        }\n+                        InvocationLocation::Workspace => flycheck::InvocationLocation::Workspace,\n+                    },\n                 }\n             }\n             Some(_) | None => FlycheckConfig::CargoCommand {\n@@ -1587,6 +1636,20 @@ enum CargoFeaturesDef {\n     Selected(Vec<String>),\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+enum InvocationStrategy {\n+    Once,\n+    PerWorkspace,\n+}\n+\n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+enum InvocationLocation {\n+    Root,\n+    Workspace,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n enum LifetimeElisionDef {\n@@ -2001,6 +2064,22 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Render annotations above the whole item, including documentation comments and attributes.\"\n             ],\n         },\n+        \"InvocationStrategy\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"per_workspace\", \"once\"],\n+            \"enumDescriptions\": [\n+                \"The command will be executed for each workspace.\",\n+                \"The command will be executed once.\"\n+            ],\n+        },\n+        \"InvocationLocation\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"workspace\", \"root\"],\n+            \"enumDescriptions\": [\n+                \"The command will be executed in the corresponding workspace root.\",\n+                \"The command will be executed in the project root.\"\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}, {"sha": "57899b599146693e176c6135107b05dcff363fe1", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -52,7 +52,7 @@ impl<'a> RequestDispatcher<'a> {\n             let _pctx = stdx::panic_context::enter(panic_context);\n             f(self.global_state, params)\n         };\n-        if let Ok(response) = result_to_response::<R>(req.id.clone(), result) {\n+        if let Ok(response) = result_to_response::<R>(req.id, result) {\n             self.global_state.respond(response);\n         }\n \n@@ -80,7 +80,7 @@ impl<'a> RequestDispatcher<'a> {\n             f(global_state_snapshot, params)\n         });\n \n-        if let Ok(response) = thread_result_to_response::<R>(req.id.clone(), result) {\n+        if let Ok(response) = thread_result_to_response::<R>(req.id, result) {\n             self.global_state.respond(response);\n         }\n "}, {"sha": "3fb06c31f7ca792c068e1dcf81e1dab7c7f8af9c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -64,7 +64,7 @@ pub(crate) struct GlobalState {\n     pub(crate) source_root_config: SourceRootConfig,\n     pub(crate) proc_macro_clients: Vec<Result<ProcMacroServer, String>>,\n \n-    pub(crate) flycheck: Vec<FlycheckHandle>,\n+    pub(crate) flycheck: Arc<[FlycheckHandle]>,\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n     pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n \n@@ -117,6 +117,7 @@ pub(crate) struct GlobalStateSnapshot {\n     vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub(crate) proc_macros_loaded: bool,\n+    pub(crate) flycheck: Arc<[FlycheckHandle]>,\n }\n \n impl std::panic::UnwindSafe for GlobalStateSnapshot {}\n@@ -155,7 +156,7 @@ impl GlobalState {\n             source_root_config: SourceRootConfig::default(),\n             proc_macro_clients: vec![],\n \n-            flycheck: Vec::new(),\n+            flycheck: Arc::new([]),\n             flycheck_sender,\n             flycheck_receiver,\n \n@@ -295,6 +296,7 @@ impl GlobalState {\n             mem_docs: self.mem_docs.clone(),\n             semantic_tokens_cache: Arc::clone(&self.semantic_tokens_cache),\n             proc_macros_loaded: !self.fetch_build_data_queue.last_op_result().0.is_empty(),\n+            flycheck: self.flycheck.clone(),\n         }\n     }\n \n@@ -398,6 +400,10 @@ impl GlobalStateSnapshot {\n         url_from_abs_path(path)\n     }\n \n+    pub(crate) fn file_id_to_file_path(&self, file_id: FileId) -> vfs::VfsPath {\n+        self.vfs.read().0.file_path(file_id)\n+    }\n+\n     pub(crate) fn cargo_target_for_crate_root(\n         &self,\n         crate_id: CrateId,"}, {"sha": "34795a8eb40ab7844e11af047f8127b16a814247", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -658,7 +658,7 @@ pub(crate) fn handle_parent_module(\n \n         // check if invoked at the crate root\n         let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-        let crate_id = match snap.analysis.crate_for(file_id)?.first() {\n+        let crate_id = match snap.analysis.crates_for(file_id)?.first() {\n             Some(&crate_id) => crate_id,\n             None => return Ok(None),\n         };\n@@ -1782,7 +1782,15 @@ fn run_rustfmt(\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let file_id = from_proto::file_id(snap, &text_document.uri)?;\n     let file = snap.analysis.file_text(file_id)?;\n-    let crate_ids = snap.analysis.crate_for(file_id)?;\n+\n+    // find the edition of the package the file belongs to\n+    // (if it belongs to multiple we'll just pick the first one and pray)\n+    let edition = snap\n+        .analysis\n+        .relevant_crates_for(file_id)?\n+        .into_iter()\n+        .find_map(|crate_id| snap.cargo_target_for_crate_root(crate_id))\n+        .map(|(ws, target)| ws[ws[target].package].edition);\n \n     let line_index = snap.file_line_index(file_id)?;\n \n@@ -1808,9 +1816,7 @@ fn run_rustfmt(\n                     );\n                 }\n             }\n-            if let Some(&crate_id) = crate_ids.first() {\n-                // Assume all crates are in the same edition\n-                let edition = snap.analysis.crate_edition(crate_id)?;\n+            if let Some(edition) = edition {\n                 cmd.arg(\"--edition\");\n                 cmd.arg(edition.to_string());\n             }"}, {"sha": "b3cea64d4175e129672af57cf90ba647db346c21", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -87,6 +87,7 @@ impl GlobalState {\n         state: Progress,\n         message: Option<String>,\n         fraction: Option<f64>,\n+        cancel_token: Option<String>,\n     ) {\n         if !self.config.work_done_progress() {\n             return;\n@@ -95,7 +96,10 @@ impl GlobalState {\n             assert!((0.0..=1.0).contains(&f));\n             (f * 100.0) as u32\n         });\n-        let token = lsp_types::ProgressToken::String(format!(\"rustAnalyzer/{}\", title));\n+        let cancellable = Some(cancel_token.is_some());\n+        let token = lsp_types::ProgressToken::String(\n+            cancel_token.unwrap_or_else(|| format!(\"rustAnalyzer/{}\", title)),\n+        );\n         let work_done_progress = match state {\n             Progress::Begin => {\n                 self.send_request::<lsp_types::request::WorkDoneProgressCreate>(\n@@ -105,14 +109,14 @@ impl GlobalState {\n \n                 lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n                     title: title.into(),\n-                    cancellable: None,\n+                    cancellable,\n                     message,\n                     percentage,\n                 })\n             }\n             Progress::Report => {\n                 lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n-                    cancellable: None,\n+                    cancellable,\n                     message,\n                     percentage,\n                 })"}, {"sha": "2c928a580405c04c107851f2abb6185feeb171c5", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 109, "deletions": 75, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -10,7 +10,7 @@ use std::{\n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n use flycheck::FlycheckHandle;\n-use ide_db::base_db::{SourceDatabase, SourceDatabaseExt, VfsPath};\n+use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n use lsp_types::notification::Notification as _;\n@@ -191,7 +191,7 @@ impl GlobalState {\n         // NOTE: don't count blocking select! call as a loop-turn time\n         let _p = profile::span(\"GlobalState::handle_event\");\n \n-        tracing::debug!(\"handle_event({:?})\", event);\n+        tracing::debug!(\"{:?} handle_event({:?})\", loop_start, event);\n         let task_queue_len = self.task_pool.handle.len();\n         if task_queue_len > 0 {\n             tracing::info!(\"task queue len: {}\", task_queue_len);\n@@ -257,7 +257,7 @@ impl GlobalState {\n                         }\n                     };\n \n-                    self.report_progress(\"Indexing\", state, message, Some(fraction));\n+                    self.report_progress(\"Indexing\", state, message, Some(fraction), None);\n                 }\n             }\n             Event::Vfs(message) => {\n@@ -465,7 +465,7 @@ impl GlobalState {\n                     }\n                 };\n \n-                self.report_progress(\"Fetching\", state, msg, None);\n+                self.report_progress(\"Fetching\", state, msg, None, None);\n             }\n             Task::FetchBuildData(progress) => {\n                 let (state, msg) = match progress {\n@@ -481,7 +481,7 @@ impl GlobalState {\n                 };\n \n                 if let Some(state) = state {\n-                    self.report_progress(\"Loading\", state, msg, None);\n+                    self.report_progress(\"Loading\", state, msg, None, None);\n                 }\n             }\n         }\n@@ -518,6 +518,7 @@ impl GlobalState {\n                     state,\n                     Some(format!(\"{}/{}\", n_done, n_total)),\n                     Some(Progress::fraction(n_done, n_total)),\n+                    None,\n                 )\n             }\n         }\n@@ -542,7 +543,10 @@ impl GlobalState {\n                             diag.fix,\n                         ),\n                         Err(err) => {\n-                            tracing::error!(\"File with cargo diagnostic not found in VFS: {}\", err);\n+                            tracing::error!(\n+                                \"flycheck {id}: File with cargo diagnostic not found in VFS: {}\",\n+                                err\n+                            );\n                         }\n                     };\n                 }\n@@ -584,7 +588,13 @@ impl GlobalState {\n                 } else {\n                     format!(\"cargo check (#{})\", id + 1)\n                 };\n-                self.report_progress(&title, state, message, None);\n+                self.report_progress(\n+                    &title,\n+                    state,\n+                    message,\n+                    None,\n+                    Some(format!(\"rust-analyzer/checkOnSave/{}\", id)),\n+                );\n             }\n         }\n     }\n@@ -698,7 +708,16 @@ impl GlobalState {\n                 this.cancel(id);\n                 Ok(())\n             })?\n-            .on::<lsp_types::notification::WorkDoneProgressCancel>(|_this, _params| {\n+            .on::<lsp_types::notification::WorkDoneProgressCancel>(|this, params| {\n+                if let lsp_types::NumberOrString::String(s) = &params.token {\n+                    if let Some(id) = s.strip_prefix(\"rust-analyzer/checkOnSave/\") {\n+                        if let Ok(id) = u32::from_str_radix(id, 10) {\n+                            if let Some(flycheck) = this.flycheck.get(id as usize) {\n+                                flycheck.cancel();\n+                            }\n+                        }\n+                    }\n+                }\n                 // Just ignore this. It is OK to continue sending progress\n                 // notifications for this token, as the client can't know when\n                 // we accepted notification.\n@@ -711,7 +730,7 @@ impl GlobalState {\n                         .insert(path.clone(), DocumentData::new(params.text_document.version))\n                         .is_err();\n                     if already_exists {\n-                        tracing::error!(\"duplicate DidOpenTextDocument: {}\", path)\n+                        tracing::error!(\"duplicate DidOpenTextDocument: {}\", path);\n                     }\n                     this.vfs\n                         .write()\n@@ -758,83 +777,98 @@ impl GlobalState {\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidSaveTextDocument>(|this, params| {\n-                let mut updated = false;\n                 if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    let (vfs, _) = &*this.vfs.read();\n-\n-                    // Trigger flychecks for all workspaces that depend on the saved file\n-                    if let Some(file_id) = vfs.file_id(&vfs_path) {\n-                        let analysis = this.analysis_host.analysis();\n-                        // Crates containing or depending on the saved file\n-                        let crate_ids: Vec<_> = analysis\n-                            .crate_for(file_id)?\n-                            .into_iter()\n-                            .flat_map(|id| {\n-                                this.analysis_host\n-                                    .raw_database()\n-                                    .crate_graph()\n-                                    .transitive_rev_deps(id)\n-                            })\n-                            .sorted()\n-                            .unique()\n-                            .collect();\n-\n-                        let crate_root_paths: Vec<_> = crate_ids\n-                            .iter()\n-                            .filter_map(|&crate_id| {\n-                                analysis\n-                                    .crate_root(crate_id)\n-                                    .map(|file_id| {\n-                                        vfs.file_path(file_id).as_path().map(ToOwned::to_owned)\n-                                    })\n-                                    .transpose()\n-                            })\n-                            .collect::<ide::Cancellable<_>>()?;\n-                        let crate_root_paths: Vec<_> =\n-                            crate_root_paths.iter().map(Deref::deref).collect();\n-\n-                        // Find all workspaces that have at least one target containing the saved file\n-                        let workspace_ids =\n-                            this.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n-                                project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n-                                    cargo.packages().any(|pkg| {\n-                                        cargo[pkg].targets.iter().any(|&it| {\n-                                            crate_root_paths.contains(&cargo[it].root.as_path())\n-                                        })\n-                                    })\n-                                }\n-                                project_model::ProjectWorkspace::Json { project, .. } => project\n-                                    .crates()\n-                                    .any(|(c, _)| crate_ids.iter().any(|&crate_id| crate_id == c)),\n-                                project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n-                            });\n-\n-                        // Find and trigger corresponding flychecks\n-                        for flycheck in &this.flycheck {\n-                            for (id, _) in workspace_ids.clone() {\n-                                if id == flycheck.id() {\n-                                    updated = true;\n-                                    flycheck.restart();\n-                                    continue;\n-                                }\n-                            }\n-                        }\n-                    }\n-\n                     // Re-fetch workspaces if a workspace related file has changed\n                     if let Some(abs_path) = vfs_path.as_path() {\n                         if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n                             this.fetch_workspaces_queue\n                                 .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n                         }\n                     }\n+\n+                    let file_id = this.vfs.read().0.file_id(&vfs_path);\n+                    if let Some(file_id) = file_id {\n+                        let world = this.snapshot();\n+                        let mut updated = false;\n+                        let task = move || -> std::result::Result<(), ide::Cancelled> {\n+                            // Trigger flychecks for all workspaces that depend on the saved file\n+                            // Crates containing or depending on the saved file\n+                            let crate_ids: Vec<_> = world\n+                                .analysis\n+                                .crates_for(file_id)?\n+                                .into_iter()\n+                                .flat_map(|id| world.analysis.transitive_rev_deps(id))\n+                                .flatten()\n+                                .sorted()\n+                                .unique()\n+                                .collect();\n+\n+                            let crate_root_paths: Vec<_> = crate_ids\n+                                .iter()\n+                                .filter_map(|&crate_id| {\n+                                    world\n+                                        .analysis\n+                                        .crate_root(crate_id)\n+                                        .map(|file_id| {\n+                                            world\n+                                                .file_id_to_file_path(file_id)\n+                                                .as_path()\n+                                                .map(ToOwned::to_owned)\n+                                        })\n+                                        .transpose()\n+                                })\n+                                .collect::<ide::Cancellable<_>>()?;\n+                            let crate_root_paths: Vec<_> =\n+                                crate_root_paths.iter().map(Deref::deref).collect();\n+\n+                            // Find all workspaces that have at least one target containing the saved file\n+                            let workspace_ids =\n+                                world.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n+                                    project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+                                        cargo.packages().any(|pkg| {\n+                                            cargo[pkg].targets.iter().any(|&it| {\n+                                                crate_root_paths.contains(&cargo[it].root.as_path())\n+                                            })\n+                                        })\n+                                    }\n+                                    project_model::ProjectWorkspace::Json { project, .. } => {\n+                                        project.crates().any(|(c, _)| {\n+                                            crate_ids.iter().any(|&crate_id| crate_id == c)\n+                                        })\n+                                    }\n+                                    project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n+                                });\n+\n+                            // Find and trigger corresponding flychecks\n+                            for flycheck in world.flycheck.iter() {\n+                                for (id, _) in workspace_ids.clone() {\n+                                    if id == flycheck.id() {\n+                                        updated = true;\n+                                        flycheck.restart();\n+                                        continue;\n+                                    }\n+                                }\n+                            }\n+                            // No specific flycheck was triggered, so let's trigger all of them.\n+                            if !updated {\n+                                for flycheck in world.flycheck.iter() {\n+                                    flycheck.restart();\n+                                }\n+                            }\n+                            Ok(())\n+                        };\n+                        this.task_pool.handle.spawn_with_sender(move |_| {\n+                            if let Err(e) = std::panic::catch_unwind(task) {\n+                                tracing::error!(\"DidSaveTextDocument flycheck task panicked: {e:?}\")\n+                            }\n+                        });\n+                        return Ok(());\n+                    }\n                 }\n \n                 // No specific flycheck was triggered, so let's trigger all of them.\n-                if !updated {\n-                    for flycheck in &this.flycheck {\n-                        flycheck.restart();\n-                    }\n+                for flycheck in this.flycheck.iter() {\n+                    flycheck.restart();\n                 }\n                 Ok(())\n             })?"}, {"sha": "e1f651786dee411fc43456fdf30d797cda70f735", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -175,10 +175,8 @@ impl GlobalState {\n                     sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n                 }\n             };\n-            let mut res = Vec::new();\n-            for ws in workspaces.iter() {\n-                res.push(ws.run_build_scripts(&config, &progress));\n-            }\n+            let res = ProjectWorkspace::run_all_build_scripts(&workspaces, &config, &progress);\n+\n             sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n         });\n     }\n@@ -468,39 +466,54 @@ impl GlobalState {\n         let config = match self.config.flycheck() {\n             Some(it) => it,\n             None => {\n-                self.flycheck = Vec::new();\n+                self.flycheck = Arc::new([]);\n                 self.diagnostics.clear_check_all();\n                 return;\n             }\n         };\n \n         let sender = self.flycheck_sender.clone();\n-        self.flycheck = self\n-            .workspaces\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(id, w)| match w {\n-                ProjectWorkspace::Cargo { cargo, .. } => Some((id, cargo.workspace_root())),\n-                ProjectWorkspace::Json { project, .. } => {\n-                    // Enable flychecks for json projects if a custom flycheck command was supplied\n-                    // in the workspace configuration.\n-                    match config {\n-                        FlycheckConfig::CustomCommand { .. } => Some((id, project.path())),\n-                        _ => None,\n-                    }\n-                }\n-                ProjectWorkspace::DetachedFiles { .. } => None,\n-            })\n-            .map(|(id, root)| {\n-                let sender = sender.clone();\n-                FlycheckHandle::spawn(\n-                    id,\n-                    Box::new(move |msg| sender.send(msg).unwrap()),\n-                    config.clone(),\n-                    root.to_path_buf(),\n-                )\n-            })\n-            .collect();\n+        let invocation_strategy = match config {\n+            FlycheckConfig::CargoCommand { .. } => flycheck::InvocationStrategy::PerWorkspace,\n+            FlycheckConfig::CustomCommand { invocation_strategy, .. } => invocation_strategy,\n+        };\n+\n+        self.flycheck = match invocation_strategy {\n+            flycheck::InvocationStrategy::Once => vec![FlycheckHandle::spawn(\n+                0,\n+                Box::new(move |msg| sender.send(msg).unwrap()),\n+                config.clone(),\n+                self.config.root_path().clone(),\n+            )],\n+            flycheck::InvocationStrategy::PerWorkspace => {\n+                self.workspaces\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(id, w)| match w {\n+                        ProjectWorkspace::Cargo { cargo, .. } => Some((id, cargo.workspace_root())),\n+                        ProjectWorkspace::Json { project, .. } => {\n+                            // Enable flychecks for json projects if a custom flycheck command was supplied\n+                            // in the workspace configuration.\n+                            match config {\n+                                FlycheckConfig::CustomCommand { .. } => Some((id, project.path())),\n+                                _ => None,\n+                            }\n+                        }\n+                        ProjectWorkspace::DetachedFiles { .. } => None,\n+                    })\n+                    .map(|(id, root)| {\n+                        let sender = sender.clone();\n+                        FlycheckHandle::spawn(\n+                            id,\n+                            Box::new(move |msg| sender.send(msg).unwrap()),\n+                            config.clone(),\n+                            root.to_path_buf(),\n+                        )\n+                    })\n+                    .collect()\n+            }\n+        }\n+        .into();\n     }\n }\n "}, {"sha": "660c057e99c5671636e8cd0d5d3a75b2545fe08e", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -645,7 +645,7 @@ impl ast::RecordPatFieldList {\n }\n \n fn get_or_insert_comma_after(syntax: &SyntaxNode) -> SyntaxToken {\n-    let comma = match syntax\n+    match syntax\n         .siblings_with_tokens(Direction::Next)\n         .filter_map(|it| it.into_token())\n         .find(|it| it.kind() == T![,])\n@@ -656,8 +656,7 @@ fn get_or_insert_comma_after(syntax: &SyntaxNode) -> SyntaxToken {\n             ted::insert(Position::after(syntax), &comma);\n             comma\n         }\n-    };\n-    comma\n+    }\n }\n \n impl ast::StmtList {"}, {"sha": "84c66b27e69faa531336463f2a2366409bb468e5", "filename": "src/tools/rust-analyzer/crates/syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -92,7 +92,7 @@ impl<T> Parse<T> {\n         SyntaxNode::new_root(self.green.clone())\n     }\n     pub fn errors(&self) -> &[SyntaxError] {\n-        &*self.errors\n+        &self.errors\n     }\n }\n "}, {"sha": "69d2e62b2567357541b81ab43bb83ea2ff1ac7f3", "filename": "src/tools/rust-analyzer/crates/test-utils/src/minicore.rs", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -27,7 +27,6 @@\n //!     generator: pin\n //!     hash:\n //!     index: sized\n-//!     infallible:\n //!     iterator: option\n //!     iterators: iterator, fn\n //!     option:\n@@ -37,7 +36,7 @@\n //!     result:\n //!     sized:\n //!     slice:\n-//!     try: infallible\n+//!     try:\n //!     unsize: sized\n \n pub mod marker {\n@@ -151,9 +150,6 @@ pub mod convert {\n         fn as_ref(&self) -> &T;\n     }\n     // endregion:as_ref\n-    // region:infallible\n-    pub enum Infallible {}\n-    // endregion:infallible\n }\n \n pub mod ops {\n@@ -330,7 +326,7 @@ pub mod ops {\n             Continue(C),\n             Break(B),\n         }\n-        pub trait FromResidual<R = <Self as Try>::Residual> {\n+        pub trait FromResidual<R = Self::Residual> {\n             #[lang = \"from_residual\"]\n             fn from_residual(residual: R) -> Self;\n         }\n@@ -346,13 +342,13 @@ pub mod ops {\n \n         impl<B, C> Try for ControlFlow<B, C> {\n             type Output = C;\n-            type Residual = ControlFlow<B, crate::convert::Infallible>;\n+            type Residual = ControlFlow<B, convert::Infallible>;\n             fn from_output(output: Self::Output) -> Self {}\n             fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {}\n         }\n \n         impl<B, C> FromResidual for ControlFlow<B, C> {\n-            fn from_residual(residual: ControlFlow<B, crate::convert::Infallible>) -> Self {}\n+            fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {}\n         }\n     }\n     pub use self::try_::{ControlFlow, FromResidual, Try};\n@@ -473,33 +469,6 @@ pub mod option {\n             }\n         }\n     }\n-    // region:try\n-    impl<T> crate::ops::Try for Option<T> {\n-        type Output = T;\n-        type Residual = Option<crate::convert::Infallible>;\n-\n-        #[inline]\n-        fn from_output(output: Self::Output) -> Self {\n-            Some(output)\n-        }\n-\n-        #[inline]\n-        fn branch(self) -> crate::ops::ControlFlow<Self::Residual, Self::Output> {\n-            match self {\n-                Some(v) => crate::ops::ControlFlow::Continue(v),\n-                None => crate::ops::ControlFlow::Break(None),\n-            }\n-        }\n-    }\n-    impl<T> crate::ops::FromResidual for Option<T> {\n-        #[inline]\n-        fn from_residual(residual: Option<crate::convert::Infallible>) -> Self {\n-            match residual {\n-                None => None,\n-            }\n-        }\n-    }\n-    // endregion:try\n }\n // endregion:option\n "}, {"sha": "502833de72c161716d30f0456e4f2e3e6563d3ae", "filename": "src/tools/rust-analyzer/docs/user/generated_config.adoc", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -24,6 +24,25 @@ Automatically refresh project info via `cargo metadata` on\n --\n Run build scripts (`build.rs`) for more precise code analysis.\n --\n+[[rust-analyzer.cargo.buildScripts.invocationLocation]]rust-analyzer.cargo.buildScripts.invocationLocation (default: `\"workspace\"`)::\n++\n+--\n+Specifies the working directory for running build scripts.\n+- \"workspace\": run build scripts for a workspace in the workspace's root directory.\n+  This is incompatible with `#rust-analyzer.cargo.buildScripts.invocationStrategy#` set to `once`.\n+- \"root\": run build scripts in the project's root directory.\n+This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+is set.\n+--\n+[[rust-analyzer.cargo.buildScripts.invocationStrategy]]rust-analyzer.cargo.buildScripts.invocationStrategy (default: `\"per_workspace\"`)::\n++\n+--\n+Specifies the invocation strategy to use when running the build scripts command.\n+If `per_workspace` is set, the command will be executed for each workspace.\n+If `once` is set, the command will be executed once.\n+This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+is set.\n+--\n [[rust-analyzer.cargo.buildScripts.overrideCommand]]rust-analyzer.cargo.buildScripts.overrideCommand (default: `null`)::\n +\n --\n@@ -118,6 +137,25 @@ List of features to activate. Defaults to\n \n Set to `\"all\"` to pass `--all-features` to Cargo.\n --\n+[[rust-analyzer.checkOnSave.invocationLocation]]rust-analyzer.checkOnSave.invocationLocation (default: `\"workspace\"`)::\n++\n+--\n+Specifies the working directory for running checks.\n+- \"workspace\": run checks for workspaces in the corresponding workspaces' root directories.\n+  This falls back to \"root\" if `#rust-analyzer.cargo.checkOnSave.invocationStrategy#` is set to `once`.\n+- \"root\": run checks in the project's root directory.\n+This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+is set.\n+--\n+[[rust-analyzer.checkOnSave.invocationStrategy]]rust-analyzer.checkOnSave.invocationStrategy (default: `\"per_workspace\"`)::\n++\n+--\n+Specifies the invocation strategy to use when running the checkOnSave command.\n+If `per_workspace` is set, the command will be executed for each workspace.\n+If `once` is set, the command will be executed once.\n+This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+is set.\n+--\n [[rust-analyzer.checkOnSave.noDefaultFeatures]]rust-analyzer.checkOnSave.noDefaultFeatures (default: `null`)::\n +\n --"}, {"sha": "a72865d4fe44e1672847cd66548375621bc7db47", "filename": "src/tools/rust-analyzer/editors/code/package-lock.json", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage-lock.json?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -11,7 +11,7 @@\n             \"dependencies\": {\n                 \"d3\": \"^7.6.1\",\n                 \"d3-graphviz\": \"^4.1.1\",\n-                \"vscode-languageclient\": \"^8.0.0-next.14\"\n+                \"vscode-languageclient\": \"^8.0.2\"\n             },\n             \"devDependencies\": {\n                 \"@types/node\": \"~16.11.7\",\n@@ -3791,39 +3791,39 @@\n             }\n         },\n         \"node_modules/vscode-jsonrpc\": {\n-            \"version\": \"8.0.0-next.7\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-jsonrpc/-/vscode-jsonrpc-8.0.0-next.7.tgz\",\n-            \"integrity\": \"sha512-JX/F31LEsims0dAlOTKFE4E+AJMiJvdRSRViifFJSqSN7EzeYyWlfuDchF7g91oRNPZOIWfibTkDf3/UMsQGzQ==\",\n+            \"version\": \"8.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-jsonrpc/-/vscode-jsonrpc-8.0.2.tgz\",\n+            \"integrity\": \"sha512-RY7HwI/ydoC1Wwg4gJ3y6LpU9FJRZAUnTYMXthqhFXXu77ErDd/xkREpGuk4MyYkk4a+XDWAMqe0S3KkelYQEQ==\",\n             \"engines\": {\n                 \"node\": \">=14.0.0\"\n             }\n         },\n         \"node_modules/vscode-languageclient\": {\n-            \"version\": \"8.0.0-next.14\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageclient/-/vscode-languageclient-8.0.0-next.14.tgz\",\n-            \"integrity\": \"sha512-NqjkOuDTMu8uo+PhoMsV72VO9Gd3wBi/ZpOrkRUOrWKQo7yUdiIw183g8wjH8BImgbK9ZP51HM7TI0ZhCnI1Mw==\",\n+            \"version\": \"8.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageclient/-/vscode-languageclient-8.0.2.tgz\",\n+            \"integrity\": \"sha512-lHlthJtphG9gibGb/y72CKqQUxwPsMXijJVpHEC2bvbFqxmkj9LwQ3aGU9dwjBLqsX1S4KjShYppLvg1UJDF/Q==\",\n             \"dependencies\": {\n                 \"minimatch\": \"^3.0.4\",\n                 \"semver\": \"^7.3.5\",\n-                \"vscode-languageserver-protocol\": \"3.17.0-next.16\"\n+                \"vscode-languageserver-protocol\": \"3.17.2\"\n             },\n             \"engines\": {\n-                \"vscode\": \"^1.66.0\"\n+                \"vscode\": \"^1.67.0\"\n             }\n         },\n         \"node_modules/vscode-languageserver-protocol\": {\n-            \"version\": \"3.17.0-next.16\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-protocol/-/vscode-languageserver-protocol-3.17.0-next.16.tgz\",\n-            \"integrity\": \"sha512-tx4DnXw9u3N7vw+bx6n2NKp6FoxoNwiP/biH83AS30I2AnTGyLd7afSeH6Oewn2E8jvB7K15bs12sMppkKOVeQ==\",\n+            \"version\": \"3.17.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-protocol/-/vscode-languageserver-protocol-3.17.2.tgz\",\n+            \"integrity\": \"sha512-8kYisQ3z/SQ2kyjlNeQxbkkTNmVFoQCqkmGrzLH6A9ecPlgTbp3wDTnUNqaUxYr4vlAcloxx8zwy7G5WdguYNg==\",\n             \"dependencies\": {\n-                \"vscode-jsonrpc\": \"8.0.0-next.7\",\n-                \"vscode-languageserver-types\": \"3.17.0-next.9\"\n+                \"vscode-jsonrpc\": \"8.0.2\",\n+                \"vscode-languageserver-types\": \"3.17.2\"\n             }\n         },\n         \"node_modules/vscode-languageserver-types\": {\n-            \"version\": \"3.17.0-next.9\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.17.0-next.9.tgz\",\n-            \"integrity\": \"sha512-9/PeDNPYduaoXRUzYpqmu4ZV9L01HGo0wH9FUt+sSHR7IXwA7xoXBfNUlv8gB9H0D2WwEmMomSy1NmhjKQyn3A==\"\n+            \"version\": \"3.17.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.17.2.tgz\",\n+            \"integrity\": \"sha512-zHhCWatviizPIq9B7Vh9uvrH6x3sK8itC84HkamnBWoDFJtzBf7SWlpLCZUit72b3os45h6RWQNC9xHRDF8dRA==\"\n         },\n         \"node_modules/which\": {\n             \"version\": \"2.0.2\",\n@@ -6634,33 +6634,33 @@\n             }\n         },\n         \"vscode-jsonrpc\": {\n-            \"version\": \"8.0.0-next.7\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-jsonrpc/-/vscode-jsonrpc-8.0.0-next.7.tgz\",\n-            \"integrity\": \"sha512-JX/F31LEsims0dAlOTKFE4E+AJMiJvdRSRViifFJSqSN7EzeYyWlfuDchF7g91oRNPZOIWfibTkDf3/UMsQGzQ==\"\n+            \"version\": \"8.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-jsonrpc/-/vscode-jsonrpc-8.0.2.tgz\",\n+            \"integrity\": \"sha512-RY7HwI/ydoC1Wwg4gJ3y6LpU9FJRZAUnTYMXthqhFXXu77ErDd/xkREpGuk4MyYkk4a+XDWAMqe0S3KkelYQEQ==\"\n         },\n         \"vscode-languageclient\": {\n-            \"version\": \"8.0.0-next.14\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageclient/-/vscode-languageclient-8.0.0-next.14.tgz\",\n-            \"integrity\": \"sha512-NqjkOuDTMu8uo+PhoMsV72VO9Gd3wBi/ZpOrkRUOrWKQo7yUdiIw183g8wjH8BImgbK9ZP51HM7TI0ZhCnI1Mw==\",\n+            \"version\": \"8.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageclient/-/vscode-languageclient-8.0.2.tgz\",\n+            \"integrity\": \"sha512-lHlthJtphG9gibGb/y72CKqQUxwPsMXijJVpHEC2bvbFqxmkj9LwQ3aGU9dwjBLqsX1S4KjShYppLvg1UJDF/Q==\",\n             \"requires\": {\n                 \"minimatch\": \"^3.0.4\",\n                 \"semver\": \"^7.3.5\",\n-                \"vscode-languageserver-protocol\": \"3.17.0-next.16\"\n+                \"vscode-languageserver-protocol\": \"3.17.2\"\n             }\n         },\n         \"vscode-languageserver-protocol\": {\n-            \"version\": \"3.17.0-next.16\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-protocol/-/vscode-languageserver-protocol-3.17.0-next.16.tgz\",\n-            \"integrity\": \"sha512-tx4DnXw9u3N7vw+bx6n2NKp6FoxoNwiP/biH83AS30I2AnTGyLd7afSeH6Oewn2E8jvB7K15bs12sMppkKOVeQ==\",\n+            \"version\": \"3.17.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-protocol/-/vscode-languageserver-protocol-3.17.2.tgz\",\n+            \"integrity\": \"sha512-8kYisQ3z/SQ2kyjlNeQxbkkTNmVFoQCqkmGrzLH6A9ecPlgTbp3wDTnUNqaUxYr4vlAcloxx8zwy7G5WdguYNg==\",\n             \"requires\": {\n-                \"vscode-jsonrpc\": \"8.0.0-next.7\",\n-                \"vscode-languageserver-types\": \"3.17.0-next.9\"\n+                \"vscode-jsonrpc\": \"8.0.2\",\n+                \"vscode-languageserver-types\": \"3.17.2\"\n             }\n         },\n         \"vscode-languageserver-types\": {\n-            \"version\": \"3.17.0-next.9\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.17.0-next.9.tgz\",\n-            \"integrity\": \"sha512-9/PeDNPYduaoXRUzYpqmu4ZV9L01HGo0wH9FUt+sSHR7IXwA7xoXBfNUlv8gB9H0D2WwEmMomSy1NmhjKQyn3A==\"\n+            \"version\": \"3.17.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.17.2.tgz\",\n+            \"integrity\": \"sha512-zHhCWatviizPIq9B7Vh9uvrH6x3sK8itC84HkamnBWoDFJtzBf7SWlpLCZUit72b3os45h6RWQNC9xHRDF8dRA==\"\n         },\n         \"which\": {\n             \"version\": \"2.0.2\","}, {"sha": "6771cad28a792650729ef68041ab0c22a001b370", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -37,7 +37,7 @@\n     \"dependencies\": {\n         \"d3\": \"^7.6.1\",\n         \"d3-graphviz\": \"^4.1.1\",\n-        \"vscode-languageclient\": \"^8.0.0-next.14\"\n+        \"vscode-languageclient\": \"^8.0.2\"\n     },\n     \"devDependencies\": {\n         \"@types/node\": \"~16.11.7\",\n@@ -60,6 +60,7 @@\n         \"onCommand:rust-analyzer.analyzerStatus\",\n         \"onCommand:rust-analyzer.memoryUsage\",\n         \"onCommand:rust-analyzer.reloadWorkspace\",\n+        \"onCommand:rust-analyzer.startServer\",\n         \"workspaceContains:*/Cargo.toml\",\n         \"workspaceContains:*/rust-project.json\"\n     ],\n@@ -191,6 +192,16 @@\n                 \"title\": \"Restart server\",\n                 \"category\": \"rust-analyzer\"\n             },\n+            {\n+                \"command\": \"rust-analyzer.startServer\",\n+                \"title\": \"Start server\",\n+                \"category\": \"rust-analyzer\"\n+            },\n+            {\n+                \"command\": \"rust-analyzer.stopServer\",\n+                \"title\": \"Stop server\",\n+                \"category\": \"rust-analyzer\"\n+            },\n             {\n                 \"command\": \"rust-analyzer.onEnter\",\n                 \"title\": \"Enhanced enter key\",\n@@ -421,6 +432,32 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.cargo.buildScripts.invocationLocation\": {\n+                    \"markdownDescription\": \"Specifies the working directory for running build scripts.\\n- \\\"workspace\\\": run build scripts for a workspace in the workspace's root directory.\\n    This is incompatible with `#rust-analyzer.cargo.buildScripts.invocationStrategy#` set to `once`.\\n- \\\"root\\\": run build scripts in the project's root directory.\\nThis config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\\nis set.\",\n+                    \"default\": \"workspace\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"workspace\",\n+                        \"root\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"The command will be executed in the corresponding workspace root.\",\n+                        \"The command will be executed in the project root.\"\n+                    ]\n+                },\n+                \"rust-analyzer.cargo.buildScripts.invocationStrategy\": {\n+                    \"markdownDescription\": \"Specifies the invocation strategy to use when running the build scripts command.\\nIf `per_workspace` is set, the command will be executed for each workspace.\\nIf `once` is set, the command will be executed once.\\nThis config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\\nis set.\",\n+                    \"default\": \"per_workspace\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"per_workspace\",\n+                        \"once\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"The command will be executed for each workspace.\",\n+                        \"The command will be executed once.\"\n+                    ]\n+                },\n                 \"rust-analyzer.cargo.buildScripts.overrideCommand\": {\n                     \"markdownDescription\": \"Override the command rust-analyzer uses to run build scripts and\\nbuild procedural macros. The command is required to output json\\nand should therefore include `--message-format=json` or a similar\\noption.\\n\\nBy default, a cargo invocation will be constructed for the configured\\ntargets and features, with the following base command line:\\n\\n```bash\\ncargo check --quiet --workspace --message-format=json --all-targets\\n```\\n.\",\n                     \"default\": null,\n@@ -546,6 +583,32 @@\n                         }\n                     ]\n                 },\n+                \"rust-analyzer.checkOnSave.invocationLocation\": {\n+                    \"markdownDescription\": \"Specifies the working directory for running checks.\\n- \\\"workspace\\\": run checks for workspaces in the corresponding workspaces' root directories.\\n    This falls back to \\\"root\\\" if `#rust-analyzer.cargo.checkOnSave.invocationStrategy#` is set to `once`.\\n- \\\"root\\\": run checks in the project's root directory.\\nThis config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\\nis set.\",\n+                    \"default\": \"workspace\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"workspace\",\n+                        \"root\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"The command will be executed in the corresponding workspace root.\",\n+                        \"The command will be executed in the project root.\"\n+                    ]\n+                },\n+                \"rust-analyzer.checkOnSave.invocationStrategy\": {\n+                    \"markdownDescription\": \"Specifies the invocation strategy to use when running the checkOnSave command.\\nIf `per_workspace` is set, the command will be executed for each workspace.\\nIf `once` is set, the command will be executed once.\\nThis config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\\nis set.\",\n+                    \"default\": \"per_workspace\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"per_workspace\",\n+                        \"once\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"The command will be executed for each workspace.\",\n+                        \"The command will be executed once.\"\n+                    ]\n+                },\n                 \"rust-analyzer.checkOnSave.noDefaultFeatures\": {\n                     \"markdownDescription\": \"Whether to pass `--no-default-features` to Cargo. Defaults to\\n`#rust-analyzer.cargo.noDefaultFeatures#`.\",\n                     \"default\": null,"}, {"sha": "176040120f410db9049ec147bdf493788d1ad12f", "filename": "src/tools/rust-analyzer/editors/code/src/ast_inspector.ts", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fast_inspector.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fast_inspector.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fast_inspector.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -35,8 +35,10 @@ export class AstInspector implements vscode.HoverProvider, vscode.DefinitionProv\n     });\n \n     constructor(ctx: Ctx) {\n-        ctx.pushCleanup(vscode.languages.registerHoverProvider({ scheme: \"rust-analyzer\" }, this));\n-        ctx.pushCleanup(vscode.languages.registerDefinitionProvider({ language: \"rust\" }, this));\n+        ctx.pushExtCleanup(\n+            vscode.languages.registerHoverProvider({ scheme: \"rust-analyzer\" }, this)\n+        );\n+        ctx.pushExtCleanup(vscode.languages.registerDefinitionProvider({ language: \"rust\" }, this));\n         vscode.workspace.onDidCloseTextDocument(\n             this.onDidCloseTextDocument,\n             this,\n@@ -52,8 +54,6 @@ export class AstInspector implements vscode.HoverProvider, vscode.DefinitionProv\n             this,\n             ctx.subscriptions\n         );\n-\n-        ctx.pushCleanup(this);\n     }\n     dispose() {\n         this.setRustEditor(undefined);"}, {"sha": "374c3b8144c3841c2290dc0f0300cb38ce142f47", "filename": "src/tools/rust-analyzer/editors/code/src/bootstrap.ts", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fbootstrap.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fbootstrap.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fbootstrap.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -0,0 +1,148 @@\n+import * as vscode from \"vscode\";\n+import * as os from \"os\";\n+import { Config } from \"./config\";\n+import { log, isValidExecutable } from \"./util\";\n+import { PersistentState } from \"./persistent_state\";\n+import { exec } from \"child_process\";\n+\n+export async function bootstrap(\n+    context: vscode.ExtensionContext,\n+    config: Config,\n+    state: PersistentState\n+): Promise<string> {\n+    const path = await getServer(context, config, state);\n+    if (!path) {\n+        throw new Error(\n+            \"Rust Analyzer Language Server is not available. \" +\n+                \"Please, ensure its [proper installation](https://rust-analyzer.github.io/manual.html#installation).\"\n+        );\n+    }\n+\n+    log.info(\"Using server binary at\", path);\n+\n+    if (!isValidExecutable(path)) {\n+        if (config.serverPath) {\n+            throw new Error(`Failed to execute ${path} --version. \\`config.server.path\\` or \\`config.serverPath\\` has been set explicitly.\\\n+            Consider removing this config or making a valid server binary available at that path.`);\n+        } else {\n+            throw new Error(`Failed to execute ${path} --version`);\n+        }\n+    }\n+\n+    return path;\n+}\n+\n+async function patchelf(dest: vscode.Uri): Promise<void> {\n+    await vscode.window.withProgress(\n+        {\n+            location: vscode.ProgressLocation.Notification,\n+            title: \"Patching rust-analyzer for NixOS\",\n+        },\n+        async (progress, _) => {\n+            const expression = `\n+            {srcStr, pkgs ? import <nixpkgs> {}}:\n+                pkgs.stdenv.mkDerivation {\n+                    name = \"rust-analyzer\";\n+                    src = /. + srcStr;\n+                    phases = [ \"installPhase\" \"fixupPhase\" ];\n+                    installPhase = \"cp $src $out\";\n+                    fixupPhase = ''\n+                    chmod 755 $out\n+                    patchelf --set-interpreter \"$(cat $NIX_CC/nix-support/dynamic-linker)\" $out\n+                    '';\n+                }\n+            `;\n+            const origFile = vscode.Uri.file(dest.fsPath + \"-orig\");\n+            await vscode.workspace.fs.rename(dest, origFile, { overwrite: true });\n+            try {\n+                progress.report({ message: \"Patching executable\", increment: 20 });\n+                await new Promise((resolve, reject) => {\n+                    const handle = exec(\n+                        `nix-build -E - --argstr srcStr '${origFile.fsPath}' -o '${dest.fsPath}'`,\n+                        (err, stdout, stderr) => {\n+                            if (err != null) {\n+                                reject(Error(stderr));\n+                            } else {\n+                                resolve(stdout);\n+                            }\n+                        }\n+                    );\n+                    handle.stdin?.write(expression);\n+                    handle.stdin?.end();\n+                });\n+            } finally {\n+                await vscode.workspace.fs.delete(origFile);\n+            }\n+        }\n+    );\n+}\n+\n+async function getServer(\n+    context: vscode.ExtensionContext,\n+    config: Config,\n+    state: PersistentState\n+): Promise<string | undefined> {\n+    const explicitPath = serverPath(config);\n+    if (explicitPath) {\n+        if (explicitPath.startsWith(\"~/\")) {\n+            return os.homedir() + explicitPath.slice(\"~\".length);\n+        }\n+        return explicitPath;\n+    }\n+    if (config.package.releaseTag === null) return \"rust-analyzer\";\n+\n+    const ext = process.platform === \"win32\" ? \".exe\" : \"\";\n+    const bundled = vscode.Uri.joinPath(context.extensionUri, \"server\", `rust-analyzer${ext}`);\n+    const bundledExists = await vscode.workspace.fs.stat(bundled).then(\n+        () => true,\n+        () => false\n+    );\n+    if (bundledExists) {\n+        let server = bundled;\n+        if (await isNixOs()) {\n+            await vscode.workspace.fs.createDirectory(config.globalStorageUri).then();\n+            const dest = vscode.Uri.joinPath(config.globalStorageUri, `rust-analyzer${ext}`);\n+            let exists = await vscode.workspace.fs.stat(dest).then(\n+                () => true,\n+                () => false\n+            );\n+            if (exists && config.package.version !== state.serverVersion) {\n+                await vscode.workspace.fs.delete(dest);\n+                exists = false;\n+            }\n+            if (!exists) {\n+                await vscode.workspace.fs.copy(bundled, dest);\n+                await patchelf(dest);\n+            }\n+            server = dest;\n+        }\n+        await state.updateServerVersion(config.package.version);\n+        return server.fsPath;\n+    }\n+\n+    await state.updateServerVersion(undefined);\n+    await vscode.window.showErrorMessage(\n+        \"Unfortunately we don't ship binaries for your platform yet. \" +\n+            \"You need to manually clone the rust-analyzer repository and \" +\n+            \"run `cargo xtask install --server` to build the language server from sources. \" +\n+            \"If you feel that your platform should be supported, please create an issue \" +\n+            \"about that [here](https://github.com/rust-lang/rust-analyzer/issues) and we \" +\n+            \"will consider it.\"\n+    );\n+    return undefined;\n+}\n+function serverPath(config: Config): string | null {\n+    return process.env.__RA_LSP_SERVER_DEBUG ?? config.serverPath;\n+}\n+\n+async function isNixOs(): Promise<boolean> {\n+    try {\n+        const contents = (\n+            await vscode.workspace.fs.readFile(vscode.Uri.file(\"/etc/os-release\"))\n+        ).toString();\n+        const idString = contents.split(\"\\n\").find((a) => a.startsWith(\"ID=\")) || \"ID=linux\";\n+        return idString.indexOf(\"nixos\") !== -1;\n+    } catch {\n+        return false;\n+    }\n+}"}, {"sha": "fb667619c86be045490827de8a44fe6343243ded", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -4,9 +4,7 @@ import * as ra from \"../src/lsp_ext\";\n import * as Is from \"vscode-languageclient/lib/common/utils/is\";\n import { assert } from \"./util\";\n import { WorkspaceEdit } from \"vscode\";\n-import { Workspace } from \"./ctx\";\n-import { substituteVariablesInEnv } from \"./config\";\n-import { outputChannel, traceOutputChannel } from \"./main\";\n+import { substituteVSCodeVariables } from \"./config\";\n import { randomUUID } from \"crypto\";\n \n export interface Env {\n@@ -65,40 +63,42 @@ function renderHoverActions(actions: ra.CommandLinkGroup[]): vscode.MarkdownStri\n }\n \n export async function createClient(\n-    serverPath: string,\n-    workspace: Workspace,\n-    extraEnv: Env\n+    traceOutputChannel: vscode.OutputChannel,\n+    outputChannel: vscode.OutputChannel,\n+    initializationOptions: vscode.WorkspaceConfiguration,\n+    serverOptions: lc.ServerOptions\n ): Promise<lc.LanguageClient> {\n-    // '.' Is the fallback if no folder is open\n-    // TODO?: Workspace folders support Uri's (eg: file://test.txt).\n-    // It might be a good idea to test if the uri points to a file.\n-\n-    const newEnv = substituteVariablesInEnv(Object.assign({}, process.env, extraEnv));\n-    const run: lc.Executable = {\n-        command: serverPath,\n-        options: { env: newEnv },\n-    };\n-    const serverOptions: lc.ServerOptions = {\n-        run,\n-        debug: run,\n-    };\n-\n-    let initializationOptions = vscode.workspace.getConfiguration(\"rust-analyzer\");\n-\n-    if (workspace.kind === \"Detached Files\") {\n-        initializationOptions = {\n-            detachedFiles: workspace.files.map((file) => file.uri.fsPath),\n-            ...initializationOptions,\n-        };\n-    }\n-\n     const clientOptions: lc.LanguageClientOptions = {\n         documentSelector: [{ scheme: \"file\", language: \"rust\" }],\n         initializationOptions,\n         diagnosticCollectionName: \"rustc\",\n-        traceOutputChannel: traceOutputChannel(),\n-        outputChannel: outputChannel(),\n+        traceOutputChannel,\n+        outputChannel,\n         middleware: {\n+            workspace: {\n+                // HACK: This is a workaround, when the client has been disposed, VSCode\n+                // continues to emit events to the client and the default one for this event\n+                // attempt to restart the client for no reason\n+                async didChangeWatchedFile(event, next) {\n+                    if (client.isRunning()) {\n+                        await next(event);\n+                    }\n+                },\n+                async configuration(\n+                    params: lc.ConfigurationParams,\n+                    token: vscode.CancellationToken,\n+                    next: lc.ConfigurationRequest.HandlerSignature\n+                ) {\n+                    const resp = await next(params, token);\n+                    if (resp && Array.isArray(resp)) {\n+                        return resp.map((val) => {\n+                            return substituteVSCodeVariables(val);\n+                        });\n+                    } else {\n+                        return resp;\n+                    }\n+                },\n+            },\n             async provideHover(\n                 document: vscode.TextDocument,\n                 position: vscode.Position,\n@@ -255,6 +255,9 @@ export async function createClient(\n }\n \n class ExperimentalFeatures implements lc.StaticFeature {\n+    getState(): lc.FeatureState {\n+        return { kind: \"static\" };\n+    }\n     fillClientCapabilities(capabilities: lc.ClientCapabilities): void {\n         const caps: any = capabilities.experimental ?? {};\n         caps.snippetTextEdit = true;"}, {"sha": "12ceb4f2df8e1ca360ce86212dc7187cc3adf5e9", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 94, "deletions": 96, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -21,24 +21,24 @@ export function analyzerStatus(ctx: Ctx): Cmd {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-status://status\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n \n-        provideTextDocumentContent(_uri: vscode.Uri): vscode.ProviderResult<string> {\n+        async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n             if (!vscode.window.activeTextEditor) return \"\";\n+            const client = await ctx.getClient();\n \n             const params: ra.AnalyzerStatusParams = {};\n             const doc = ctx.activeRustEditor?.document;\n             if (doc != null) {\n-                params.textDocument =\n-                    ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(doc);\n+                params.textDocument = client.code2ProtocolConverter.asTextDocumentIdentifier(doc);\n             }\n-            return ctx.client.sendRequest(ra.analyzerStatus, params);\n+            return await client.sendRequest(ra.analyzerStatus, params);\n         }\n \n         get onDidChange(): vscode.Event<vscode.Uri> {\n             return this.eventEmitter.event;\n         }\n     })();\n \n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(\n         vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-status\", tdcp)\n     );\n \n@@ -60,17 +60,22 @@ export function memoryUsage(ctx: Ctx): Cmd {\n         provideTextDocumentContent(_uri: vscode.Uri): vscode.ProviderResult<string> {\n             if (!vscode.window.activeTextEditor) return \"\";\n \n-            return ctx.client.sendRequest(ra.memoryUsage).then((mem: any) => {\n-                return \"Per-query memory usage:\\n\" + mem + \"\\n(note: database has been cleared)\";\n-            });\n+            return ctx\n+                .getClient()\n+                .then((it) => it.sendRequest(ra.memoryUsage))\n+                .then((mem: any) => {\n+                    return (\n+                        \"Per-query memory usage:\\n\" + mem + \"\\n(note: database has been cleared)\"\n+                    );\n+                });\n         }\n \n         get onDidChange(): vscode.Event<vscode.Uri> {\n             return this.eventEmitter.event;\n         }\n     })();\n \n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(\n         vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-memory\", tdcp)\n     );\n \n@@ -83,23 +88,19 @@ export function memoryUsage(ctx: Ctx): Cmd {\n \n export function shuffleCrateGraph(ctx: Ctx): Cmd {\n     return async () => {\n-        const client = ctx.client;\n-        if (!client) return;\n-\n-        await client.sendRequest(ra.shuffleCrateGraph);\n+        return ctx.getClient().then((it) => it.sendRequest(ra.shuffleCrateGraph));\n     };\n }\n \n export function matchingBrace(ctx: Ctx): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n+        if (!editor) return;\n+\n+        const client = await ctx.getClient();\n \n         const response = await client.sendRequest(ra.matchingBrace, {\n-            textDocument: ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n-                editor.document\n-            ),\n+            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n             positions: editor.selections.map((s) =>\n                 client.code2ProtocolConverter.asPosition(s.active)\n             ),\n@@ -116,14 +117,13 @@ export function matchingBrace(ctx: Ctx): Cmd {\n export function joinLines(ctx: Ctx): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n+        if (!editor) return;\n+\n+        const client = await ctx.getClient();\n \n         const items: lc.TextEdit[] = await client.sendRequest(ra.joinLines, {\n             ranges: editor.selections.map((it) => client.code2ProtocolConverter.asRange(it)),\n-            textDocument: ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n-                editor.document\n-            ),\n+            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n         });\n         const textEdits = await client.protocol2CodeConverter.asTextEdits(items);\n         await editor.edit((builder) => {\n@@ -145,14 +145,12 @@ export function moveItemDown(ctx: Ctx): Cmd {\n export function moveItem(ctx: Ctx, direction: ra.Direction): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n+        if (!editor) return;\n+        const client = await ctx.getClient();\n \n         const lcEdits = await client.sendRequest(ra.moveItem, {\n             range: client.code2ProtocolConverter.asRange(editor.selection),\n-            textDocument: ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n-                editor.document\n-            ),\n+            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n             direction,\n         });\n \n@@ -166,13 +164,13 @@ export function moveItem(ctx: Ctx, direction: ra.Direction): Cmd {\n export function onEnter(ctx: Ctx): Cmd {\n     async function handleKeypress() {\n         const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n \n-        if (!editor || !client) return false;\n+        if (!editor) return false;\n \n+        const client = await ctx.getClient();\n         const lcEdits = await client\n             .sendRequest(ra.onEnter, {\n-                textDocument: ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n+                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n                     editor.document\n                 ),\n                 position: client.code2ProtocolConverter.asPosition(editor.selection.active),\n@@ -198,14 +196,13 @@ export function onEnter(ctx: Ctx): Cmd {\n export function parentModule(ctx: Ctx): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n+        if (!editor) return;\n         if (!(isRustDocument(editor.document) || isCargoTomlDocument(editor.document))) return;\n \n+        const client = await ctx.getClient();\n+\n         const locations = await client.sendRequest(ra.parentModule, {\n-            textDocument: ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n-                editor.document\n-            ),\n+            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n             position: client.code2ProtocolConverter.asPosition(editor.selection.active),\n         });\n         if (!locations) return;\n@@ -236,13 +233,11 @@ export function parentModule(ctx: Ctx): Cmd {\n export function openCargoToml(ctx: Ctx): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n+        if (!editor) return;\n \n+        const client = await ctx.getClient();\n         const response = await client.sendRequest(ra.openCargoToml, {\n-            textDocument: ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n-                editor.document\n-            ),\n+            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n         });\n         if (!response) return;\n \n@@ -259,12 +254,13 @@ export function openCargoToml(ctx: Ctx): Cmd {\n export function ssr(ctx: Ctx): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n+        if (!editor) return;\n+\n+        const client = await ctx.getClient();\n \n         const position = editor.selection.active;\n         const selections = editor.selections;\n-        const textDocument = ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n+        const textDocument = client.code2ProtocolConverter.asTextDocumentIdentifier(\n             editor.document\n         );\n \n@@ -314,6 +310,10 @@ export function ssr(ctx: Ctx): Cmd {\n \n export function serverVersion(ctx: Ctx): Cmd {\n     return async () => {\n+        if (!ctx.serverPath) {\n+            void vscode.window.showWarningMessage(`rust-analyzer server is not running`);\n+            return;\n+        }\n         const { stdout } = spawnSync(ctx.serverPath, [\"--version\"], { encoding: \"utf8\" });\n         const versionString = stdout.slice(`rust-analyzer `.length).trim();\n \n@@ -354,34 +354,34 @@ export function syntaxTree(ctx: Ctx): Cmd {\n             }\n         }\n \n-        provideTextDocumentContent(\n+        async provideTextDocumentContent(\n             uri: vscode.Uri,\n             ct: vscode.CancellationToken\n-        ): vscode.ProviderResult<string> {\n+        ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n+            const client = await ctx.getClient();\n \n             // When the range based query is enabled we take the range of the selection\n             const range =\n                 uri.query === \"range=true\" && !rustEditor.selection.isEmpty\n-                    ? ctx.client.code2ProtocolConverter.asRange(rustEditor.selection)\n+                    ? client.code2ProtocolConverter.asRange(rustEditor.selection)\n                     : null;\n \n             const params = { textDocument: { uri: rustEditor.document.uri.toString() }, range };\n-            return ctx.client.sendRequest(ra.syntaxTree, params, ct);\n+            return client.sendRequest(ra.syntaxTree, params, ct);\n         }\n \n         get onDidChange(): vscode.Event<vscode.Uri> {\n             return this.eventEmitter.event;\n         }\n     })();\n \n-    void new AstInspector(ctx);\n-\n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(new AstInspector(ctx));\n+    ctx.pushExtCleanup(\n         vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-syntax-tree\", tdcp)\n     );\n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(\n         vscode.languages.setLanguageConfiguration(\"ra_syntax_tree\", {\n             brackets: [[\"[\", \")\"]],\n         })\n@@ -437,14 +437,14 @@ export function viewHir(ctx: Ctx): Cmd {\n             }\n         }\n \n-        provideTextDocumentContent(\n+        async provideTextDocumentContent(\n             _uri: vscode.Uri,\n             ct: vscode.CancellationToken\n-        ): vscode.ProviderResult<string> {\n+        ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n-            const client = ctx.client;\n-            if (!rustEditor || !client) return \"\";\n+            if (!rustEditor) return \"\";\n \n+            const client = await ctx.getClient();\n             const params = {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n                     rustEditor.document\n@@ -459,7 +459,7 @@ export function viewHir(ctx: Ctx): Cmd {\n         }\n     })();\n \n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(\n         vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-hir\", tdcp)\n     );\n \n@@ -503,13 +503,13 @@ export function viewFileText(ctx: Ctx): Cmd {\n             }\n         }\n \n-        provideTextDocumentContent(\n+        async provideTextDocumentContent(\n             _uri: vscode.Uri,\n             ct: vscode.CancellationToken\n-        ): vscode.ProviderResult<string> {\n+        ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n-            const client = ctx.client;\n-            if (!rustEditor || !client) return \"\";\n+            if (!rustEditor) return \"\";\n+            const client = await ctx.getClient();\n \n             const params = client.code2ProtocolConverter.asTextDocumentIdentifier(\n                 rustEditor.document\n@@ -522,7 +522,7 @@ export function viewFileText(ctx: Ctx): Cmd {\n         }\n     })();\n \n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(\n         vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-file-text\", tdcp)\n     );\n \n@@ -566,13 +566,13 @@ export function viewItemTree(ctx: Ctx): Cmd {\n             }\n         }\n \n-        provideTextDocumentContent(\n+        async provideTextDocumentContent(\n             _uri: vscode.Uri,\n             ct: vscode.CancellationToken\n-        ): vscode.ProviderResult<string> {\n+        ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n-            const client = ctx.client;\n-            if (!rustEditor || !client) return \"\";\n+            if (!rustEditor) return \"\";\n+            const client = await ctx.getClient();\n \n             const params = {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n@@ -587,7 +587,7 @@ export function viewItemTree(ctx: Ctx): Cmd {\n         }\n     })();\n \n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(\n         vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-item-tree\", tdcp)\n     );\n \n@@ -618,8 +618,8 @@ function crateGraph(ctx: Ctx, full: boolean): Cmd {\n         const params = {\n             full: full,\n         };\n-\n-        const dot = await ctx.client.sendRequest(ra.viewCrateGraph, params);\n+        const client = await ctx.getClient();\n+        const dot = await client.sendRequest(ra.viewCrateGraph, params);\n         const uri = panel.webview.asWebviewUri(nodeModulesPath);\n \n         const html = `\n@@ -690,13 +690,13 @@ export function expandMacro(ctx: Ctx): Cmd {\n         eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n         async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n             const editor = vscode.window.activeTextEditor;\n-            const client = ctx.client;\n-            if (!editor || !client) return \"\";\n+            if (!editor) return \"\";\n+            const client = await ctx.getClient();\n \n             const position = editor.selection.active;\n \n             const expanded = await client.sendRequest(ra.expandMacro, {\n-                textDocument: ctx.client.code2ProtocolConverter.asTextDocumentIdentifier(\n+                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n                     editor.document\n                 ),\n                 position,\n@@ -712,7 +712,7 @@ export function expandMacro(ctx: Ctx): Cmd {\n         }\n     })();\n \n-    ctx.pushCleanup(\n+    ctx.pushExtCleanup(\n         vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-expand-macro\", tdcp)\n     );\n \n@@ -724,11 +724,11 @@ export function expandMacro(ctx: Ctx): Cmd {\n }\n \n export function reloadWorkspace(ctx: Ctx): Cmd {\n-    return async () => ctx.client.sendRequest(ra.reloadWorkspace);\n+    return async () => (await ctx.getClient()).sendRequest(ra.reloadWorkspace);\n }\n \n async function showReferencesImpl(\n-    client: LanguageClient,\n+    client: LanguageClient | undefined,\n     uri: string,\n     position: lc.Position,\n     locations: lc.Location[]\n@@ -745,7 +745,7 @@ async function showReferencesImpl(\n \n export function showReferences(ctx: Ctx): Cmd {\n     return async (uri: string, position: lc.Position, locations: lc.Location[]) => {\n-        await showReferencesImpl(ctx.client, uri, position, locations);\n+        await showReferencesImpl(await ctx.getClient(), uri, position, locations);\n     };\n }\n \n@@ -762,25 +762,23 @@ export function applyActionGroup(_ctx: Ctx): Cmd {\n \n export function gotoLocation(ctx: Ctx): Cmd {\n     return async (locationLink: lc.LocationLink) => {\n-        const client = ctx.client;\n-        if (client) {\n-            const uri = client.protocol2CodeConverter.asUri(locationLink.targetUri);\n-            let range = client.protocol2CodeConverter.asRange(locationLink.targetSelectionRange);\n-            // collapse the range to a cursor position\n-            range = range.with({ end: range.start });\n+        const client = await ctx.getClient();\n+        const uri = client.protocol2CodeConverter.asUri(locationLink.targetUri);\n+        let range = client.protocol2CodeConverter.asRange(locationLink.targetSelectionRange);\n+        // collapse the range to a cursor position\n+        range = range.with({ end: range.start });\n \n-            await vscode.window.showTextDocument(uri, { selection: range });\n-        }\n+        await vscode.window.showTextDocument(uri, { selection: range });\n     };\n }\n \n export function openDocs(ctx: Ctx): Cmd {\n     return async () => {\n-        const client = ctx.client;\n         const editor = vscode.window.activeTextEditor;\n-        if (!editor || !client) {\n+        if (!editor) {\n             return;\n         }\n+        const client = await ctx.getClient();\n \n         const position = editor.selection.active;\n         const textDocument = { uri: editor.document.uri.toString() };\n@@ -795,20 +793,21 @@ export function openDocs(ctx: Ctx): Cmd {\n \n export function cancelFlycheck(ctx: Ctx): Cmd {\n     return async () => {\n-        await ctx.client.sendRequest(ra.cancelFlycheck);\n+        const client = await ctx.getClient();\n+        await client.sendRequest(ra.cancelFlycheck);\n     };\n }\n \n export function resolveCodeAction(ctx: Ctx): Cmd {\n-    const client = ctx.client;\n     return async (params: lc.CodeAction) => {\n+        const client = await ctx.getClient();\n         params.command = undefined;\n-        const item = await client.sendRequest(lc.CodeActionResolveRequest.type, params);\n-        if (!item.edit) {\n+        const item = await client?.sendRequest(lc.CodeActionResolveRequest.type, params);\n+        if (!item?.edit) {\n             return;\n         }\n         const itemEdit = item.edit;\n-        const edit = await client.protocol2CodeConverter.asWorkspaceEdit(itemEdit);\n+        const edit = await client?.protocol2CodeConverter.asWorkspaceEdit(itemEdit);\n         // filter out all text edits and recreate the WorkspaceEdit without them so we can apply\n         // snippet edits on our own\n         const lcFileSystemEdit = {\n@@ -847,11 +846,10 @@ export function run(ctx: Ctx): Cmd {\n }\n \n export function peekTests(ctx: Ctx): Cmd {\n-    const client = ctx.client;\n-\n     return async () => {\n         const editor = ctx.activeRustEditor;\n-        if (!editor || !client) return;\n+        if (!editor) return;\n+        const client = await ctx.getClient();\n \n         await vscode.window.withProgress(\n             {\n@@ -937,10 +935,10 @@ export function newDebugConfig(ctx: Ctx): Cmd {\n     };\n }\n \n-export function linkToCommand(ctx: Ctx): Cmd {\n+export function linkToCommand(_: Ctx): Cmd {\n     return async (commandId: string) => {\n         const link = LINKED_COMMANDS.get(commandId);\n-        if (ctx.client && link) {\n+        if (link) {\n             const { command, arguments: args = [] } = link;\n             await vscode.commands.executeCommand(command, ...args);\n         }"}, {"sha": "632a7d86faa369dcf3da8c1395b1d3c479730412", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 136, "deletions": 55, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -1,4 +1,5 @@\n-import path = require(\"path\");\n+import * as path from \"path\";\n+import * as os from \"os\";\n import * as vscode from \"vscode\";\n import { Env } from \"./client\";\n import { log } from \"./util\";\n@@ -10,23 +11,17 @@ export type RunnableEnvCfg =\n \n export class Config {\n     readonly extensionId = \"rust-lang.rust-analyzer\";\n+    configureLang: vscode.Disposable | undefined;\n \n     readonly rootSection = \"rust-analyzer\";\n-    private readonly requiresWorkspaceReloadOpts = [\n-        \"serverPath\",\n-        \"server\",\n-        // FIXME: This shouldn't be here, changing this setting should reload\n-        // `continueCommentsOnNewline` behavior without restart\n-        \"typing\",\n-    ].map((opt) => `${this.rootSection}.${opt}`);\n     private readonly requiresReloadOpts = [\n         \"cargo\",\n         \"procMacro\",\n+        \"serverPath\",\n+        \"server\",\n         \"files\",\n         \"lens\", // works as lens.*\n-    ]\n-        .map((opt) => `${this.rootSection}.${opt}`)\n-        .concat(this.requiresWorkspaceReloadOpts);\n+    ].map((opt) => `${this.rootSection}.${opt}`);\n \n     readonly package: {\n         version: string;\n@@ -44,6 +39,11 @@ export class Config {\n             ctx.subscriptions\n         );\n         this.refreshLogging();\n+        this.configureLanguage();\n+    }\n+\n+    dispose() {\n+        this.configureLang?.dispose();\n     }\n \n     private refreshLogging() {\n@@ -57,33 +57,86 @@ export class Config {\n     private async onDidChangeConfiguration(event: vscode.ConfigurationChangeEvent) {\n         this.refreshLogging();\n \n+        this.configureLanguage();\n+\n         const requiresReloadOpt = this.requiresReloadOpts.find((opt) =>\n             event.affectsConfiguration(opt)\n         );\n \n         if (!requiresReloadOpt) return;\n \n-        const requiresWorkspaceReloadOpt = this.requiresWorkspaceReloadOpts.find((opt) =>\n-            event.affectsConfiguration(opt)\n-        );\n-\n-        if (!requiresWorkspaceReloadOpt && this.restartServerOnConfigChange) {\n+        if (this.restartServerOnConfigChange) {\n             await vscode.commands.executeCommand(\"rust-analyzer.reload\");\n             return;\n         }\n \n-        const message = requiresWorkspaceReloadOpt\n-            ? `Changing \"${requiresWorkspaceReloadOpt}\" requires a window reload`\n-            : `Changing \"${requiresReloadOpt}\" requires a reload`;\n-        const userResponse = await vscode.window.showInformationMessage(message, \"Reload now\");\n-\n-        if (userResponse === \"Reload now\") {\n-            const command = requiresWorkspaceReloadOpt\n-                ? \"workbench.action.reloadWindow\"\n-                : \"rust-analyzer.reload\";\n-            if (userResponse === \"Reload now\") {\n-                await vscode.commands.executeCommand(command);\n-            }\n+        const message = `Changing \"${requiresReloadOpt}\" requires a server restart`;\n+        const userResponse = await vscode.window.showInformationMessage(message, \"Restart now\");\n+\n+        if (userResponse) {\n+            const command = \"rust-analyzer.reload\";\n+            await vscode.commands.executeCommand(command);\n+        }\n+    }\n+\n+    /**\n+     * Sets up additional language configuration that's impossible to do via a\n+     * separate language-configuration.json file. See [1] for more information.\n+     *\n+     * [1]: https://github.com/Microsoft/vscode/issues/11514#issuecomment-244707076\n+     */\n+    private configureLanguage() {\n+        if (this.typingContinueCommentsOnNewline && !this.configureLang) {\n+            const indentAction = vscode.IndentAction.None;\n+\n+            this.configureLang = vscode.languages.setLanguageConfiguration(\"rust\", {\n+                onEnterRules: [\n+                    {\n+                        // Doc single-line comment\n+                        // e.g. ///|\n+                        beforeText: /^\\s*\\/{3}.*$/,\n+                        action: { indentAction, appendText: \"/// \" },\n+                    },\n+                    {\n+                        // Parent doc single-line comment\n+                        // e.g. //!|\n+                        beforeText: /^\\s*\\/{2}\\!.*$/,\n+                        action: { indentAction, appendText: \"//! \" },\n+                    },\n+                    {\n+                        // Begins an auto-closed multi-line comment (standard or parent doc)\n+                        // e.g. /** | */ or /*! | */\n+                        beforeText: /^\\s*\\/\\*(\\*|\\!)(?!\\/)([^\\*]|\\*(?!\\/))*$/,\n+                        afterText: /^\\s*\\*\\/$/,\n+                        action: {\n+                            indentAction: vscode.IndentAction.IndentOutdent,\n+                            appendText: \" * \",\n+                        },\n+                    },\n+                    {\n+                        // Begins a multi-line comment (standard or parent doc)\n+                        // e.g. /** ...| or /*! ...|\n+                        beforeText: /^\\s*\\/\\*(\\*|\\!)(?!\\/)([^\\*]|\\*(?!\\/))*$/,\n+                        action: { indentAction, appendText: \" * \" },\n+                    },\n+                    {\n+                        // Continues a multi-line comment\n+                        // e.g.  * ...|\n+                        beforeText: /^(\\ \\ )*\\ \\*(\\ ([^\\*]|\\*(?!\\/))*)?$/,\n+                        action: { indentAction, appendText: \"* \" },\n+                    },\n+                    {\n+                        // Dedents after closing a multi-line comment\n+                        // e.g.  */|\n+                        beforeText: /^(\\ \\ )*\\ \\*\\/\\s*$/,\n+                        action: { indentAction, removeText: 1 },\n+                    },\n+                ],\n+            });\n+        }\n+        if (!this.typingContinueCommentsOnNewline && this.configureLang) {\n+            this.configureLang.dispose();\n+            this.configureLang = undefined;\n         }\n     }\n \n@@ -187,6 +240,37 @@ export class Config {\n     }\n }\n \n+const VarRegex = new RegExp(/\\$\\{(.+?)\\}/g);\n+\n+export function substituteVSCodeVariableInString(val: string): string {\n+    return val.replace(VarRegex, (substring: string, varName) => {\n+        if (typeof varName === \"string\") {\n+            return computeVscodeVar(varName) || substring;\n+        } else {\n+            return substring;\n+        }\n+    });\n+}\n+\n+export function substituteVSCodeVariables(resp: any): any {\n+    if (typeof resp === \"string\") {\n+        return substituteVSCodeVariableInString(resp);\n+    } else if (resp && Array.isArray(resp)) {\n+        return resp.map((val) => {\n+            return substituteVSCodeVariables(val);\n+        });\n+    } else if (resp && typeof resp === \"object\") {\n+        const res: { [key: string]: any } = {};\n+        for (const key in resp) {\n+            const val = resp[key];\n+            res[key] = substituteVSCodeVariables(val);\n+        }\n+        return res;\n+    } else if (typeof resp === \"function\") {\n+        return null;\n+    }\n+    return resp;\n+}\n export function substituteVariablesInEnv(env: Env): Env {\n     const missingDeps = new Set<string>();\n     // vscode uses `env:ENV_NAME` for env vars resolution, and it's easier\n@@ -233,7 +317,7 @@ export function substituteVariablesInEnv(env: Env): Env {\n             }\n         } else {\n             envWithDeps[dep] = {\n-                value: computeVscodeVar(dep),\n+                value: computeVscodeVar(dep) || \"${\" + dep + \"}\",\n                 deps: [],\n             };\n         }\n@@ -264,37 +348,34 @@ export function substituteVariablesInEnv(env: Env): Env {\n     return resolvedEnv;\n }\n \n-function computeVscodeVar(varName: string): string {\n+function computeVscodeVar(varName: string): string | null {\n+    const workspaceFolder = () => {\n+        const folders = vscode.workspace.workspaceFolders ?? [];\n+        if (folders.length === 1) {\n+            // TODO: support for remote workspaces?\n+            return folders[0].uri.fsPath;\n+        } else if (folders.length > 1) {\n+            // could use currently opened document to detect the correct\n+            // workspace. However, that would be determined by the document\n+            // user has opened on Editor startup. Could lead to\n+            // unpredictable workspace selection in practice.\n+            // It's better to pick the first one\n+            return folders[0].uri.fsPath;\n+        } else {\n+            // no workspace opened\n+            return \"\";\n+        }\n+    };\n     // https://code.visualstudio.com/docs/editor/variables-reference\n     const supportedVariables: { [k: string]: () => string } = {\n-        workspaceFolder: () => {\n-            const folders = vscode.workspace.workspaceFolders ?? [];\n-            if (folders.length === 1) {\n-                // TODO: support for remote workspaces?\n-                return folders[0].uri.fsPath;\n-            } else if (folders.length > 1) {\n-                // could use currently opened document to detect the correct\n-                // workspace. However, that would be determined by the document\n-                // user has opened on Editor startup. Could lead to\n-                // unpredictable workspace selection in practice.\n-                // It's better to pick the first one\n-                return folders[0].uri.fsPath;\n-            } else {\n-                // no workspace opened\n-                return \"\";\n-            }\n-        },\n+        workspaceFolder,\n \n         workspaceFolderBasename: () => {\n-            const workspaceFolder = computeVscodeVar(\"workspaceFolder\");\n-            if (workspaceFolder) {\n-                return path.basename(workspaceFolder);\n-            } else {\n-                return \"\";\n-            }\n+            return path.basename(workspaceFolder());\n         },\n \n         cwd: () => process.cwd(),\n+        userHome: () => os.homedir(),\n \n         // see\n         // https://github.com/microsoft/vscode/blob/08ac1bb67ca2459496b272d8f4a908757f24f56f/src/vs/workbench/api/common/extHostVariableResolverService.ts#L81\n@@ -308,7 +389,7 @@ function computeVscodeVar(varName: string): string {\n     if (varName in supportedVariables) {\n         return supportedVariables[varName]();\n     } else {\n-        // can't resolve, keep the expression as is\n-        return \"${\" + varName + \"}\";\n+        // return \"${\" + varName + \"}\";\n+        return null;\n     }\n }"}, {"sha": "044a9470aa94782748ced04c732f59aa7412da0e", "filename": "src/tools/rust-analyzer/editors/code/src/ctx.ts", "status": "modified", "additions": 178, "deletions": 46, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -2,10 +2,12 @@ import * as vscode from \"vscode\";\n import * as lc from \"vscode-languageclient/node\";\n import * as ra from \"./lsp_ext\";\n \n-import { Config } from \"./config\";\n+import { Config, substituteVariablesInEnv, substituteVSCodeVariables } from \"./config\";\n import { createClient } from \"./client\";\n-import { isRustEditor, RustEditor } from \"./util\";\n+import { isRustEditor, log, RustEditor } from \"./util\";\n import { ServerStatusParams } from \"./lsp_ext\";\n+import { PersistentState } from \"./persistent_state\";\n+import { bootstrap } from \"./bootstrap\";\n \n export type Workspace =\n     | {\n@@ -16,66 +18,192 @@ export type Workspace =\n           files: vscode.TextDocument[];\n       };\n \n+export type CommandFactory = {\n+    enabled: (ctx: Ctx) => Cmd;\n+    disabled?: (ctx: Ctx) => Cmd;\n+};\n+\n export class Ctx {\n-    private constructor(\n-        readonly config: Config,\n-        private readonly extCtx: vscode.ExtensionContext,\n-        readonly client: lc.LanguageClient,\n-        readonly serverPath: string,\n-        readonly statusBar: vscode.StatusBarItem\n-    ) {}\n-\n-    static async create(\n-        config: Config,\n-        extCtx: vscode.ExtensionContext,\n-        serverPath: string,\n-        workspace: Workspace\n-    ): Promise<Ctx> {\n-        const client = await createClient(serverPath, workspace, config.serverExtraEnv);\n-\n-        const statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);\n-        extCtx.subscriptions.push(statusBar);\n-        statusBar.text = \"rust-analyzer\";\n-        statusBar.tooltip = \"ready\";\n-        statusBar.command = \"rust-analyzer.analyzerStatus\";\n-        statusBar.show();\n-\n-        const res = new Ctx(config, extCtx, client, serverPath, statusBar);\n-\n-        res.pushCleanup(client.start());\n-        await client.onReady();\n-        client.onNotification(ra.serverStatus, (params) => res.setServerStatus(params));\n-        return res;\n+    readonly statusBar: vscode.StatusBarItem;\n+    readonly config: Config;\n+\n+    private client: lc.LanguageClient | undefined;\n+    private _serverPath: string | undefined;\n+    private traceOutputChannel: vscode.OutputChannel | undefined;\n+    private outputChannel: vscode.OutputChannel | undefined;\n+    private clientSubscriptions: Disposable[];\n+    private state: PersistentState;\n+    private commandFactories: Record<string, CommandFactory>;\n+    private commandDisposables: Disposable[];\n+\n+    workspace: Workspace;\n+\n+    constructor(\n+        readonly extCtx: vscode.ExtensionContext,\n+        workspace: Workspace,\n+        commandFactories: Record<string, CommandFactory>\n+    ) {\n+        extCtx.subscriptions.push(this);\n+        this.statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);\n+        this.statusBar.text = \"rust-analyzer\";\n+        this.statusBar.tooltip = \"ready\";\n+        this.statusBar.command = \"rust-analyzer.analyzerStatus\";\n+        this.statusBar.show();\n+        this.workspace = workspace;\n+        this.clientSubscriptions = [];\n+        this.commandDisposables = [];\n+        this.commandFactories = commandFactories;\n+\n+        this.state = new PersistentState(extCtx.globalState);\n+        this.config = new Config(extCtx);\n+\n+        this.updateCommands();\n     }\n \n-    get activeRustEditor(): RustEditor | undefined {\n-        const editor = vscode.window.activeTextEditor;\n-        return editor && isRustEditor(editor) ? editor : undefined;\n+    dispose() {\n+        this.config.dispose();\n+        this.statusBar.dispose();\n+        void this.disposeClient();\n+        this.commandDisposables.forEach((disposable) => disposable.dispose());\n     }\n \n-    get visibleRustEditors(): RustEditor[] {\n-        return vscode.window.visibleTextEditors.filter(isRustEditor);\n+    clientFetcher() {\n+        const self = this;\n+        return {\n+            get client(): lc.LanguageClient | undefined {\n+                return self.client;\n+            },\n+        };\n     }\n \n-    registerCommand(name: string, factory: (ctx: Ctx) => Cmd) {\n-        const fullName = `rust-analyzer.${name}`;\n-        const cmd = factory(this);\n-        const d = vscode.commands.registerCommand(fullName, cmd);\n-        this.pushCleanup(d);\n+    async getClient() {\n+        if (!this.traceOutputChannel) {\n+            this.traceOutputChannel = vscode.window.createOutputChannel(\n+                \"Rust Analyzer Language Server Trace\"\n+            );\n+            this.pushExtCleanup(this.traceOutputChannel);\n+        }\n+        if (!this.outputChannel) {\n+            this.outputChannel = vscode.window.createOutputChannel(\"Rust Analyzer Language Server\");\n+            this.pushExtCleanup(this.outputChannel);\n+        }\n+\n+        if (!this.client) {\n+            this._serverPath = await bootstrap(this.extCtx, this.config, this.state).catch(\n+                (err) => {\n+                    let message = \"bootstrap error. \";\n+\n+                    message +=\n+                        'See the logs in \"OUTPUT > Rust Analyzer Client\" (should open automatically). ';\n+                    message +=\n+                        'To enable verbose logs use { \"rust-analyzer.trace.extension\": true }';\n+\n+                    log.error(\"Bootstrap error\", err);\n+                    throw new Error(message);\n+                }\n+            );\n+            const newEnv = substituteVariablesInEnv(\n+                Object.assign({}, process.env, this.config.serverExtraEnv)\n+            );\n+            const run: lc.Executable = {\n+                command: this._serverPath,\n+                options: { env: newEnv },\n+            };\n+            const serverOptions = {\n+                run,\n+                debug: run,\n+            };\n+\n+            let rawInitializationOptions = vscode.workspace.getConfiguration(\"rust-analyzer\");\n+\n+            if (this.workspace.kind === \"Detached Files\") {\n+                rawInitializationOptions = {\n+                    detachedFiles: this.workspace.files.map((file) => file.uri.fsPath),\n+                    ...rawInitializationOptions,\n+                };\n+            }\n+\n+            const initializationOptions = substituteVSCodeVariables(rawInitializationOptions);\n+\n+            this.client = await createClient(\n+                this.traceOutputChannel,\n+                this.outputChannel,\n+                initializationOptions,\n+                serverOptions\n+            );\n+            this.pushClientCleanup(\n+                this.client.onNotification(ra.serverStatus, (params) =>\n+                    this.setServerStatus(params)\n+                )\n+            );\n+        }\n+        return this.client;\n     }\n \n-    get extensionPath(): string {\n-        return this.extCtx.extensionPath;\n+    async activate() {\n+        log.info(\"Activating language client\");\n+        const client = await this.getClient();\n+        await client.start();\n+        this.updateCommands();\n+        return client;\n+    }\n+\n+    async deactivate() {\n+        log.info(\"Deactivating language client\");\n+        await this.client?.stop();\n+        this.updateCommands();\n+    }\n+\n+    async stop() {\n+        log.info(\"Stopping language client\");\n+        await this.disposeClient();\n+        this.updateCommands();\n+    }\n+\n+    private async disposeClient() {\n+        this.clientSubscriptions?.forEach((disposable) => disposable.dispose());\n+        this.clientSubscriptions = [];\n+        await this.client?.dispose();\n+        this._serverPath = undefined;\n+        this.client = undefined;\n+    }\n+\n+    get activeRustEditor(): RustEditor | undefined {\n+        const editor = vscode.window.activeTextEditor;\n+        return editor && isRustEditor(editor) ? editor : undefined;\n     }\n \n-    get globalState(): vscode.Memento {\n-        return this.extCtx.globalState;\n+    get extensionPath(): string {\n+        return this.extCtx.extensionPath;\n     }\n \n     get subscriptions(): Disposable[] {\n         return this.extCtx.subscriptions;\n     }\n \n+    get serverPath(): string | undefined {\n+        return this._serverPath;\n+    }\n+\n+    private updateCommands() {\n+        this.commandDisposables.forEach((disposable) => disposable.dispose());\n+        this.commandDisposables = [];\n+        const fetchFactory = (factory: CommandFactory, fullName: string) => {\n+            return this.client && this.client.isRunning()\n+                ? factory.enabled\n+                : factory.disabled ||\n+                      ((_) => () =>\n+                          vscode.window.showErrorMessage(\n+                              `command ${fullName} failed: rust-analyzer server is not running`\n+                          ));\n+        };\n+        for (const [name, factory] of Object.entries(this.commandFactories)) {\n+            const fullName = `rust-analyzer.${name}`;\n+            const callback = fetchFactory(factory, fullName)(this);\n+            this.commandDisposables.push(vscode.commands.registerCommand(fullName, callback));\n+        }\n+    }\n+\n     setServerStatus(status: ServerStatusParams) {\n         let icon = \"\";\n         const statusBar = this.statusBar;\n@@ -111,9 +239,13 @@ export class Ctx {\n         statusBar.text = `${icon}rust-analyzer`;\n     }\n \n-    pushCleanup(d: Disposable) {\n+    pushExtCleanup(d: Disposable) {\n         this.extCtx.subscriptions.push(d);\n     }\n+\n+    private pushClientCleanup(d: Disposable) {\n+        this.clientSubscriptions.push(d);\n+    }\n }\n \n export interface Disposable {"}, {"sha": "8c3a676ffb056700e059a276c6efd565d64bf725", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 113, "deletions": 362, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -1,53 +1,37 @@\n import * as vscode from \"vscode\";\n import * as lc from \"vscode-languageclient/node\";\n-import * as os from \"os\";\n \n import * as commands from \"./commands\";\n-import { Ctx } from \"./ctx\";\n-import { Config } from \"./config\";\n-import { log, isValidExecutable, isRustDocument } from \"./util\";\n-import { PersistentState } from \"./persistent_state\";\n+import { CommandFactory, Ctx, Workspace } from \"./ctx\";\n+import { isRustDocument } from \"./util\";\n import { activateTaskProvider } from \"./tasks\";\n import { setContextValue } from \"./util\";\n-import { exec } from \"child_process\";\n-\n-let ctx: Ctx | undefined;\n \n const RUST_PROJECT_CONTEXT_NAME = \"inRustProject\";\n \n-let TRACE_OUTPUT_CHANNEL: vscode.OutputChannel | null = null;\n-export function traceOutputChannel() {\n-    if (!TRACE_OUTPUT_CHANNEL) {\n-        TRACE_OUTPUT_CHANNEL = vscode.window.createOutputChannel(\n-            \"Rust Analyzer Language Server Trace\"\n-        );\n-    }\n-    return TRACE_OUTPUT_CHANNEL;\n-}\n-let OUTPUT_CHANNEL: vscode.OutputChannel | null = null;\n-export function outputChannel() {\n-    if (!OUTPUT_CHANNEL) {\n-        OUTPUT_CHANNEL = vscode.window.createOutputChannel(\"Rust Analyzer Language Server\");\n-    }\n-    return OUTPUT_CHANNEL;\n+export interface RustAnalyzerExtensionApi {\n+    // FIXME: this should be non-optional\n+    readonly client?: lc.LanguageClient;\n }\n \n-export interface RustAnalyzerExtensionApi {\n-    client?: lc.LanguageClient;\n+export async function deactivate() {\n+    await setContextValue(RUST_PROJECT_CONTEXT_NAME, undefined);\n }\n \n export async function activate(\n     context: vscode.ExtensionContext\n ): Promise<RustAnalyzerExtensionApi> {\n-    // VS Code doesn't show a notification when an extension fails to activate\n-    // so we do it ourselves.\n-    return await tryActivate(context).catch((err) => {\n-        void vscode.window.showErrorMessage(`Cannot activate rust-analyzer: ${err.message}`);\n-        throw err;\n-    });\n-}\n+    if (vscode.extensions.getExtension(\"rust-lang.rust\")) {\n+        vscode.window\n+            .showWarningMessage(\n+                `You have both the rust-analyzer (rust-lang.rust-analyzer) and Rust (rust-lang.rust) ` +\n+                    \"plugins enabled. These are known to conflict and cause various functions of \" +\n+                    \"both plugins to not work correctly. You should disable one of them.\",\n+                \"Got it\"\n+            )\n+            .then(() => {}, console.error);\n+    }\n \n-async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyzerExtensionApi> {\n     // We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n     // only those are in use.\n     // (r-a still somewhat works with Live Share, because commands are tunneled to the host)\n@@ -65,351 +49,118 @@ async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyz\n         return {};\n     }\n \n-    const config = new Config(context);\n-    const state = new PersistentState(context.globalState);\n-    const serverPath = await bootstrap(context, config, state).catch((err) => {\n-        let message = \"bootstrap error. \";\n-\n-        message += 'See the logs in \"OUTPUT > Rust Analyzer Client\" (should open automatically). ';\n-        message += 'To enable verbose logs use { \"rust-analyzer.trace.extension\": true }';\n+    const workspace: Workspace =\n+        folders.length === 0\n+            ? {\n+                  kind: \"Detached Files\",\n+                  files: rustDocuments,\n+              }\n+            : { kind: \"Workspace Folder\" };\n \n-        log.error(\"Bootstrap error\", err);\n-        throw new Error(message);\n+    const ctx = new Ctx(context, workspace, createCommands());\n+    // VS Code doesn't show a notification when an extension fails to activate\n+    // so we do it ourselves.\n+    const api = await activateServer(ctx).catch((err) => {\n+        void vscode.window.showErrorMessage(\n+            `Cannot activate rust-analyzer extension: ${err.message}`\n+        );\n+        throw err;\n     });\n+    await setContextValue(RUST_PROJECT_CONTEXT_NAME, true);\n+    return api;\n+}\n \n-    if (folders.length === 0) {\n-        ctx = await Ctx.create(config, context, serverPath, {\n-            kind: \"Detached Files\",\n-            files: rustDocuments,\n-        });\n-    } else {\n-        // Note: we try to start the server before we activate type hints so that it\n-        // registers its `onDidChangeDocument` handler before us.\n-        //\n-        // This a horribly, horribly wrong way to deal with this problem.\n-        ctx = await Ctx.create(config, context, serverPath, { kind: \"Workspace Folder\" });\n-        ctx.pushCleanup(activateTaskProvider(ctx.config));\n-    }\n-    await initCommonContext(context, ctx);\n-\n-    warnAboutExtensionConflicts();\n-\n-    if (config.typingContinueCommentsOnNewline) {\n-        ctx.pushCleanup(configureLanguage());\n+async function activateServer(ctx: Ctx): Promise<RustAnalyzerExtensionApi> {\n+    if (ctx.workspace.kind === \"Workspace Folder\") {\n+        ctx.pushExtCleanup(activateTaskProvider(ctx.config));\n     }\n \n     vscode.workspace.onDidChangeConfiguration(\n-        (_) =>\n-            ctx?.client\n-                ?.sendNotification(\"workspace/didChangeConfiguration\", { settings: \"\" })\n-                .catch(log.error),\n+        async (_) => {\n+            await ctx\n+                .clientFetcher()\n+                .client?.sendNotification(\"workspace/didChangeConfiguration\", { settings: \"\" });\n+        },\n         null,\n         ctx.subscriptions\n     );\n \n-    return {\n-        client: ctx.client,\n-    };\n-}\n-\n-async function initCommonContext(context: vscode.ExtensionContext, ctx: Ctx) {\n-    // Register a \"dumb\" onEnter command for the case where server fails to\n-    // start.\n-    //\n-    // FIXME: refactor command registration code such that commands are\n-    // **always** registered, even if the server does not start. Use API like\n-    // this perhaps?\n-    //\n-    // ```TypeScript\n-    // registerCommand(\n-    //    factory: (Ctx) => ((Ctx) => any),\n-    //    fallback: () => any = () => vscode.window.showErrorMessage(\n-    //        \"rust-analyzer is not available\"\n-    //    ),\n-    // )\n-    const defaultOnEnter = vscode.commands.registerCommand(\"rust-analyzer.onEnter\", () =>\n-        vscode.commands.executeCommand(\"default:type\", { text: \"\\n\" })\n-    );\n-    context.subscriptions.push(defaultOnEnter);\n-\n-    await setContextValue(RUST_PROJECT_CONTEXT_NAME, true);\n-\n-    // Commands which invokes manually via command palette, shortcut, etc.\n-\n-    // Reloading is inspired by @DanTup maneuver: https://github.com/microsoft/vscode/issues/45774#issuecomment-373423895\n-    ctx.registerCommand(\"reload\", (_) => async () => {\n-        void vscode.window.showInformationMessage(\"Reloading rust-analyzer...\");\n-        await doDeactivate();\n-        while (context.subscriptions.length > 0) {\n-            try {\n-                context.subscriptions.pop()!.dispose();\n-            } catch (err) {\n-                log.error(\"Dispose error:\", err);\n-            }\n-        }\n-        await activate(context).catch(log.error);\n-    });\n-\n-    ctx.registerCommand(\"analyzerStatus\", commands.analyzerStatus);\n-    ctx.registerCommand(\"memoryUsage\", commands.memoryUsage);\n-    ctx.registerCommand(\"shuffleCrateGraph\", commands.shuffleCrateGraph);\n-    ctx.registerCommand(\"reloadWorkspace\", commands.reloadWorkspace);\n-    ctx.registerCommand(\"matchingBrace\", commands.matchingBrace);\n-    ctx.registerCommand(\"joinLines\", commands.joinLines);\n-    ctx.registerCommand(\"parentModule\", commands.parentModule);\n-    ctx.registerCommand(\"syntaxTree\", commands.syntaxTree);\n-    ctx.registerCommand(\"viewHir\", commands.viewHir);\n-    ctx.registerCommand(\"viewFileText\", commands.viewFileText);\n-    ctx.registerCommand(\"viewItemTree\", commands.viewItemTree);\n-    ctx.registerCommand(\"viewCrateGraph\", commands.viewCrateGraph);\n-    ctx.registerCommand(\"viewFullCrateGraph\", commands.viewFullCrateGraph);\n-    ctx.registerCommand(\"expandMacro\", commands.expandMacro);\n-    ctx.registerCommand(\"run\", commands.run);\n-    ctx.registerCommand(\"copyRunCommandLine\", commands.copyRunCommandLine);\n-    ctx.registerCommand(\"debug\", commands.debug);\n-    ctx.registerCommand(\"newDebugConfig\", commands.newDebugConfig);\n-    ctx.registerCommand(\"openDocs\", commands.openDocs);\n-    ctx.registerCommand(\"openCargoToml\", commands.openCargoToml);\n-    ctx.registerCommand(\"peekTests\", commands.peekTests);\n-    ctx.registerCommand(\"moveItemUp\", commands.moveItemUp);\n-    ctx.registerCommand(\"moveItemDown\", commands.moveItemDown);\n-    ctx.registerCommand(\"cancelFlycheck\", commands.cancelFlycheck);\n-\n-    defaultOnEnter.dispose();\n-    ctx.registerCommand(\"onEnter\", commands.onEnter);\n-\n-    ctx.registerCommand(\"ssr\", commands.ssr);\n-    ctx.registerCommand(\"serverVersion\", commands.serverVersion);\n-\n-    // Internal commands which are invoked by the server.\n-    ctx.registerCommand(\"runSingle\", commands.runSingle);\n-    ctx.registerCommand(\"debugSingle\", commands.debugSingle);\n-    ctx.registerCommand(\"showReferences\", commands.showReferences);\n-    ctx.registerCommand(\"applySnippetWorkspaceEdit\", commands.applySnippetWorkspaceEditCommand);\n-    ctx.registerCommand(\"resolveCodeAction\", commands.resolveCodeAction);\n-    ctx.registerCommand(\"applyActionGroup\", commands.applyActionGroup);\n-    ctx.registerCommand(\"gotoLocation\", commands.gotoLocation);\n-\n-    ctx.registerCommand(\"linkToCommand\", commands.linkToCommand);\n-}\n-\n-export async function deactivate() {\n-    TRACE_OUTPUT_CHANNEL?.dispose();\n-    TRACE_OUTPUT_CHANNEL = null;\n-    OUTPUT_CHANNEL?.dispose();\n-    OUTPUT_CHANNEL = null;\n-    await doDeactivate();\n-}\n-\n-async function doDeactivate() {\n-    await setContextValue(RUST_PROJECT_CONTEXT_NAME, undefined);\n-    await ctx?.client.stop();\n-    ctx = undefined;\n-}\n-\n-async function bootstrap(\n-    context: vscode.ExtensionContext,\n-    config: Config,\n-    state: PersistentState\n-): Promise<string> {\n-    const path = await getServer(context, config, state);\n-    if (!path) {\n-        throw new Error(\n-            \"Rust Analyzer Language Server is not available. \" +\n-                \"Please, ensure its [proper installation](https://rust-analyzer.github.io/manual.html#installation).\"\n-        );\n-    }\n-\n-    log.info(\"Using server binary at\", path);\n-\n-    if (!isValidExecutable(path)) {\n-        if (config.serverPath) {\n-            throw new Error(`Failed to execute ${path} --version. \\`config.server.path\\` or \\`config.serverPath\\` has been set explicitly.\\\n-            Consider removing this config or making a valid server binary available at that path.`);\n-        } else {\n-            throw new Error(`Failed to execute ${path} --version`);\n-        }\n-    }\n-\n-    return path;\n+    await ctx.activate();\n+    return ctx.clientFetcher();\n }\n \n-async function patchelf(dest: vscode.Uri): Promise<void> {\n-    await vscode.window.withProgress(\n-        {\n-            location: vscode.ProgressLocation.Notification,\n-            title: \"Patching rust-analyzer for NixOS\",\n+function createCommands(): Record<string, CommandFactory> {\n+    return {\n+        onEnter: {\n+            enabled: commands.onEnter,\n+            disabled: (_) => () => vscode.commands.executeCommand(\"default:type\", { text: \"\\n\" }),\n         },\n-        async (progress, _) => {\n-            const expression = `\n-            {srcStr, pkgs ? import <nixpkgs> {}}:\n-                pkgs.stdenv.mkDerivation {\n-                    name = \"rust-analyzer\";\n-                    src = /. + srcStr;\n-                    phases = [ \"installPhase\" \"fixupPhase\" ];\n-                    installPhase = \"cp $src $out\";\n-                    fixupPhase = ''\n-                    chmod 755 $out\n-                    patchelf --set-interpreter \"$(cat $NIX_CC/nix-support/dynamic-linker)\" $out\n-                    '';\n-                }\n-            `;\n-            const origFile = vscode.Uri.file(dest.fsPath + \"-orig\");\n-            await vscode.workspace.fs.rename(dest, origFile, { overwrite: true });\n-            try {\n-                progress.report({ message: \"Patching executable\", increment: 20 });\n-                await new Promise((resolve, reject) => {\n-                    const handle = exec(\n-                        `nix-build -E - --argstr srcStr '${origFile.fsPath}' -o '${dest.fsPath}'`,\n-                        (err, stdout, stderr) => {\n-                            if (err != null) {\n-                                reject(Error(stderr));\n-                            } else {\n-                                resolve(stdout);\n-                            }\n-                        }\n-                    );\n-                    handle.stdin?.write(expression);\n-                    handle.stdin?.end();\n-                });\n-            } finally {\n-                await vscode.workspace.fs.delete(origFile);\n-            }\n-        }\n-    );\n-}\n-\n-async function getServer(\n-    context: vscode.ExtensionContext,\n-    config: Config,\n-    state: PersistentState\n-): Promise<string | undefined> {\n-    const explicitPath = serverPath(config);\n-    if (explicitPath) {\n-        if (explicitPath.startsWith(\"~/\")) {\n-            return os.homedir() + explicitPath.slice(\"~\".length);\n-        }\n-        return explicitPath;\n-    }\n-    if (config.package.releaseTag === null) return \"rust-analyzer\";\n-\n-    const ext = process.platform === \"win32\" ? \".exe\" : \"\";\n-    const bundled = vscode.Uri.joinPath(context.extensionUri, \"server\", `rust-analyzer${ext}`);\n-    const bundledExists = await vscode.workspace.fs.stat(bundled).then(\n-        () => true,\n-        () => false\n-    );\n-    if (bundledExists) {\n-        let server = bundled;\n-        if (await isNixOs()) {\n-            await vscode.workspace.fs.createDirectory(config.globalStorageUri).then();\n-            const dest = vscode.Uri.joinPath(config.globalStorageUri, `rust-analyzer${ext}`);\n-            let exists = await vscode.workspace.fs.stat(dest).then(\n-                () => true,\n-                () => false\n-            );\n-            if (exists && config.package.version !== state.serverVersion) {\n-                await vscode.workspace.fs.delete(dest);\n-                exists = false;\n-            }\n-            if (!exists) {\n-                await vscode.workspace.fs.copy(bundled, dest);\n-                await patchelf(dest);\n-            }\n-            server = dest;\n-        }\n-        await state.updateServerVersion(config.package.version);\n-        return server.fsPath;\n-    }\n-\n-    await state.updateServerVersion(undefined);\n-    await vscode.window.showErrorMessage(\n-        \"Unfortunately we don't ship binaries for your platform yet. \" +\n-            \"You need to manually clone the rust-analyzer repository and \" +\n-            \"run `cargo xtask install --server` to build the language server from sources. \" +\n-            \"If you feel that your platform should be supported, please create an issue \" +\n-            \"about that [here](https://github.com/rust-lang/rust-analyzer/issues) and we \" +\n-            \"will consider it.\"\n-    );\n-    return undefined;\n-}\n-\n-function serverPath(config: Config): string | null {\n-    return process.env.__RA_LSP_SERVER_DEBUG ?? config.serverPath;\n-}\n-\n-async function isNixOs(): Promise<boolean> {\n-    try {\n-        const contents = (\n-            await vscode.workspace.fs.readFile(vscode.Uri.file(\"/etc/os-release\"))\n-        ).toString();\n-        const idString = contents.split(\"\\n\").find((a) => a.startsWith(\"ID=\")) || \"ID=linux\";\n-        return idString.indexOf(\"nixos\") !== -1;\n-    } catch {\n-        return false;\n-    }\n-}\n-\n-function warnAboutExtensionConflicts() {\n-    if (vscode.extensions.getExtension(\"rust-lang.rust\")) {\n-        vscode.window\n-            .showWarningMessage(\n-                `You have both the rust-analyzer (rust-lang.rust-analyzer) and Rust (rust-lang.rust) ` +\n-                    \"plugins enabled. These are known to conflict and cause various functions of \" +\n-                    \"both plugins to not work correctly. You should disable one of them.\",\n-                \"Got it\"\n-            )\n-            .then(() => {}, console.error);\n-    }\n-}\n-\n-/**\n- * Sets up additional language configuration that's impossible to do via a\n- * separate language-configuration.json file. See [1] for more information.\n- *\n- * [1]: https://github.com/Microsoft/vscode/issues/11514#issuecomment-244707076\n- */\n-function configureLanguage(): vscode.Disposable {\n-    const indentAction = vscode.IndentAction.None;\n-    return vscode.languages.setLanguageConfiguration(\"rust\", {\n-        onEnterRules: [\n-            {\n-                // Doc single-line comment\n-                // e.g. ///|\n-                beforeText: /^\\s*\\/{3}.*$/,\n-                action: { indentAction, appendText: \"/// \" },\n-            },\n-            {\n-                // Parent doc single-line comment\n-                // e.g. //!|\n-                beforeText: /^\\s*\\/{2}\\!.*$/,\n-                action: { indentAction, appendText: \"//! \" },\n+        reload: {\n+            enabled: (ctx) => async () => {\n+                void vscode.window.showInformationMessage(\"Reloading rust-analyzer...\");\n+                // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n+                await ctx.stop();\n+                await ctx.activate();\n             },\n-            {\n-                // Begins an auto-closed multi-line comment (standard or parent doc)\n-                // e.g. /** | */ or /*! | */\n-                beforeText: /^\\s*\\/\\*(\\*|\\!)(?!\\/)([^\\*]|\\*(?!\\/))*$/,\n-                afterText: /^\\s*\\*\\/$/,\n-                action: { indentAction: vscode.IndentAction.IndentOutdent, appendText: \" * \" },\n+            disabled: (ctx) => async () => {\n+                void vscode.window.showInformationMessage(\"Reloading rust-analyzer...\");\n+                await ctx.activate();\n             },\n-            {\n-                // Begins a multi-line comment (standard or parent doc)\n-                // e.g. /** ...| or /*! ...|\n-                beforeText: /^\\s*\\/\\*(\\*|\\!)(?!\\/)([^\\*]|\\*(?!\\/))*$/,\n-                action: { indentAction, appendText: \" * \" },\n+        },\n+        startServer: {\n+            enabled: (ctx) => async () => {\n+                await ctx.activate();\n             },\n-            {\n-                // Continues a multi-line comment\n-                // e.g.  * ...|\n-                beforeText: /^(\\ \\ )*\\ \\*(\\ ([^\\*]|\\*(?!\\/))*)?$/,\n-                action: { indentAction, appendText: \"* \" },\n+            disabled: (ctx) => async () => {\n+                await ctx.activate();\n             },\n-            {\n-                // Dedents after closing a multi-line comment\n-                // e.g.  */|\n-                beforeText: /^(\\ \\ )*\\ \\*\\/\\s*$/,\n-                action: { indentAction, removeText: 1 },\n+        },\n+        stopServer: {\n+            enabled: (ctx) => async () => {\n+                // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n+                await ctx.stop();\n+                ctx.setServerStatus({\n+                    health: \"ok\",\n+                    quiescent: true,\n+                    message: \"server is not running\",\n+                });\n             },\n-        ],\n-    });\n+        },\n+\n+        analyzerStatus: { enabled: commands.analyzerStatus },\n+        memoryUsage: { enabled: commands.memoryUsage },\n+        shuffleCrateGraph: { enabled: commands.shuffleCrateGraph },\n+        reloadWorkspace: { enabled: commands.reloadWorkspace },\n+        matchingBrace: { enabled: commands.matchingBrace },\n+        joinLines: { enabled: commands.joinLines },\n+        parentModule: { enabled: commands.parentModule },\n+        syntaxTree: { enabled: commands.syntaxTree },\n+        viewHir: { enabled: commands.viewHir },\n+        viewFileText: { enabled: commands.viewFileText },\n+        viewItemTree: { enabled: commands.viewItemTree },\n+        viewCrateGraph: { enabled: commands.viewCrateGraph },\n+        viewFullCrateGraph: { enabled: commands.viewFullCrateGraph },\n+        expandMacro: { enabled: commands.expandMacro },\n+        run: { enabled: commands.run },\n+        copyRunCommandLine: { enabled: commands.copyRunCommandLine },\n+        debug: { enabled: commands.debug },\n+        newDebugConfig: { enabled: commands.newDebugConfig },\n+        openDocs: { enabled: commands.openDocs },\n+        openCargoToml: { enabled: commands.openCargoToml },\n+        peekTests: { enabled: commands.peekTests },\n+        moveItemUp: { enabled: commands.moveItemUp },\n+        moveItemDown: { enabled: commands.moveItemDown },\n+        cancelFlycheck: { enabled: commands.cancelFlycheck },\n+        ssr: { enabled: commands.ssr },\n+        serverVersion: { enabled: commands.serverVersion },\n+        // Internal commands which are invoked by the server.\n+        applyActionGroup: { enabled: commands.applyActionGroup },\n+        applySnippetWorkspaceEdit: { enabled: commands.applySnippetWorkspaceEditCommand },\n+        debugSingle: { enabled: commands.debugSingle },\n+        gotoLocation: { enabled: commands.gotoLocation },\n+        linkToCommand: { enabled: commands.linkToCommand },\n+        resolveCodeAction: { enabled: commands.resolveCodeAction },\n+        runSingle: { enabled: commands.runSingle },\n+        showReferences: { enabled: commands.showReferences },\n+    };\n }"}, {"sha": "dadaa41b1d1620c1e14053cb5b453f6a192c50d6", "filename": "src/tools/rust-analyzer/editors/code/src/run.ts", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts", "raw_url": "https://github.com/rust-lang/rust/raw/22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts?ref=22a6bc4da0ce15606e3a7fb01c5cc6ff175f79af", "patch": "@@ -18,9 +18,9 @@ export async function selectRunnable(\n     showButtons: boolean = true\n ): Promise<RunnableQuickPick | undefined> {\n     const editor = ctx.activeRustEditor;\n-    const client = ctx.client;\n-    if (!editor || !client) return;\n+    if (!editor) return;\n \n+    const client = await ctx.getClient();\n     const textDocument: lc.TextDocumentIdentifier = {\n         uri: editor.document.uri.toString(),\n     };"}]}