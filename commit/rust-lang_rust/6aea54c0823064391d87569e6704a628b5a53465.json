{"sha": "6aea54c0823064391d87569e6704a628b5a53465", "node_id": "C_kwDOAAsO6NoAKDZhZWE1NGMwODIzMDY0MzkxZDg3NTY5ZTY3MDRhNjI4YjVhNTM0NjU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-25T09:13:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-25T09:13:16Z"}, "message": "Rollup merge of #103511 - nnethercote:bb-tweaks, r=bjorn3\n\nCodegen tweaks\n\nBest reviewed one commit at a time.\n\nr? `@bjorn3`", "tree": {"sha": "0a0704a8b40df4119f426067c355eaa837f39820", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0704a8b40df4119f426067c355eaa837f39820"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aea54c0823064391d87569e6704a628b5a53465", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjV6isCRBK7hj4Ov3rIwAA0QoIADsujmJxw2syrDN4IKvmvPwC\nLdJn3pOcnBgSC/1Joz0lPgxs3INUTpUsOw8dBUk8J5/4LuJnlNisjA9tRp7CKMoz\na3pbArLVh6Fal1rlg2AgoSEo6TFYL4MKtTveYN+8BGSfEuI6BK82+z6y+zxMnxG/\n2DNhh+YTrtT9NfNDuKp1ZFJ+RtnPn8lEiX2Ul8uII+o32H2OwMILJ8NW2FhvXM+S\nIjmpNy5wOAixEY8NiVtEaGn201m9TpbdiZ6Mn3hLyjQnofn5JN9FP1oAWUtzWYg1\n+u9N8FPnSDg6ENFLisrQ1kDbd1q5bun+LumCF79VNIovK/rCshajG1CEfTogEg8=\n=Bboh\n-----END PGP SIGNATURE-----\n", "payload": "tree 0a0704a8b40df4119f426067c355eaa837f39820\nparent 35b46de61b015a2edac01bdcbbbc190ffcc57a71\nparent 6cd35ac2035327339d2428ff0be695ed5d5681dc\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1666689196 +0530\ncommitter GitHub <noreply@github.com> 1666689196 +0530\n\nRollup merge of #103511 - nnethercote:bb-tweaks, r=bjorn3\n\nCodegen tweaks\n\nBest reviewed one commit at a time.\n\nr? `@bjorn3`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aea54c0823064391d87569e6704a628b5a53465", "html_url": "https://github.com/rust-lang/rust/commit/6aea54c0823064391d87569e6704a628b5a53465", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aea54c0823064391d87569e6704a628b5a53465/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35b46de61b015a2edac01bdcbbbc190ffcc57a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/35b46de61b015a2edac01bdcbbbc190ffcc57a71", "html_url": "https://github.com/rust-lang/rust/commit/35b46de61b015a2edac01bdcbbbc190ffcc57a71"}, {"sha": "6cd35ac2035327339d2428ff0be695ed5d5681dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd35ac2035327339d2428ff0be695ed5d5681dc", "html_url": "https://github.com/rust-lang/rust/commit/6cd35ac2035327339d2428ff0be695ed5d5681dc"}], "stats": {"total": 157, "additions": 75, "deletions": 82}, "files": [{"sha": "84b89cd71a6d3047ba3fc9974b40ec6d4eee08c0", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=6aea54c0823064391d87569e6704a628b5a53465", "patch": "@@ -337,40 +337,26 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n pub fn cast_shift_expr_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n-    op: hir::BinOpKind,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value,\n-) -> Bx::Value {\n-    cast_shift_rhs(bx, op, lhs, rhs)\n-}\n-\n-fn cast_shift_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    op: hir::BinOpKind,\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n     // Shifts may have any size int on the rhs\n-    if op.is_shift() {\n-        let mut rhs_llty = bx.cx().val_ty(rhs);\n-        let mut lhs_llty = bx.cx().val_ty(lhs);\n-        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n-            rhs_llty = bx.cx().element_type(rhs_llty)\n-        }\n-        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n-            lhs_llty = bx.cx().element_type(lhs_llty)\n-        }\n-        let rhs_sz = bx.cx().int_width(rhs_llty);\n-        let lhs_sz = bx.cx().int_width(lhs_llty);\n-        if lhs_sz < rhs_sz {\n-            bx.trunc(rhs, lhs_llty)\n-        } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If in the future shifting by negative\n-            // values is no longer undefined then this is wrong.\n-            bx.zext(rhs, lhs_llty)\n-        } else {\n-            rhs\n-        }\n+    let mut rhs_llty = bx.cx().val_ty(rhs);\n+    let mut lhs_llty = bx.cx().val_ty(lhs);\n+    if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n+        rhs_llty = bx.cx().element_type(rhs_llty)\n+    }\n+    if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n+        lhs_llty = bx.cx().element_type(lhs_llty)\n+    }\n+    let rhs_sz = bx.cx().int_width(rhs_llty);\n+    let lhs_sz = bx.cx().int_width(lhs_llty);\n+    if lhs_sz < rhs_sz {\n+        bx.trunc(rhs, lhs_llty)\n+    } else if lhs_sz > rhs_sz {\n+        // FIXME (#1877: If in the future shifting by negative\n+        // values is no longer undefined then this is wrong.\n+        bx.zext(rhs, lhs_llty)\n     } else {\n         rhs\n     }"}, {"sha": "71f9179d02cca4d8755242083bf1e43b0e27812a", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=6aea54c0823064391d87569e6704a628b5a53465", "patch": "@@ -1,7 +1,6 @@\n #![allow(non_camel_case_types)]\n \n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n@@ -140,7 +139,7 @@ pub fn build_unchecked_lshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n@@ -152,7 +151,7 @@ pub fn build_unchecked_rshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     let is_signed = lhs_t.is_signed();"}, {"sha": "29b7c9b0a8832af029fd84c07812acc057143d9f", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=6aea54c0823064391d87569e6704a628b5a53465", "patch": "@@ -63,7 +63,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n-    fn lltarget<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with a landing\n+    /// pad next to it.\n+    fn llbb_with_landing_pad<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n@@ -73,32 +75,36 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n         match (self.funclet_bb, target_funclet) {\n             (None, None) => (lltarget, false),\n-            (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) => {\n-                (lltarget, false)\n-            }\n             // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n             (None, Some(_)) => (fx.landing_pad_for(target), false),\n             (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(_), Some(_)) => (fx.landing_pad_for(target), true),\n+            (Some(f), Some(t_f)) => {\n+                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    (lltarget, false)\n+                } else {\n+                    (fx.landing_pad_for(target), true)\n+                }\n+            }\n         }\n     }\n \n-    /// Create a basic block.\n-    fn llblock<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with cleanup\n+    /// stuff in it or next to it.\n+    fn llbb_with_cleanup<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> Bx::BasicBlock {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n             // MSVC cross-funclet jump - need a trampoline\n-\n-            debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n+            debug!(\"llbb_with_cleanup: creating cleanup trampoline for {:?}\", target);\n             let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n-            let trampoline = Bx::append_block(fx.cx, fx.llfn, name);\n-            let mut trampoline_bx = Bx::build(fx.cx, trampoline);\n+            let trampoline_llbb = Bx::append_block(fx.cx, fx.llfn, name);\n+            let mut trampoline_bx = Bx::build(fx.cx, trampoline_llbb);\n             trampoline_bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n-            trampoline\n+            trampoline_llbb\n         } else {\n             lltarget\n         }\n@@ -110,10 +116,11 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n     ) {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n-            // micro-optimization: generate a `ret` rather than a jump\n+            // MSVC micro-optimization: generate a `ret` rather than a jump\n             // to a trampoline.\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n             bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n         } else {\n             bx.br(lltarget);\n@@ -138,7 +145,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n         let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            Some(self.llblock(fx, cleanup))\n+            Some(self.llbb_with_cleanup(fx, cleanup))\n         } else if fx.mir[self.bb].is_cleanup\n             && fn_abi.can_unwind\n             && !base::wants_msvc_seh(fx.cx.tcx().sess)\n@@ -231,7 +238,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 options,\n                 line_spans,\n                 instance,\n-                Some((ret_llbb, self.llblock(fx, cleanup), self.funclet(fx))),\n+                Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n             );\n         } else {\n             bx.codegen_inline_asm(template, &operands, options, line_spans, instance, None);\n@@ -281,8 +288,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if target_iter.len() == 1 {\n             // If there are two targets (one conditional, one fallback), emit br instead of switch\n             let (test_value, target) = target_iter.next().unwrap();\n-            let lltrue = helper.llblock(self, target);\n-            let llfalse = helper.llblock(self, targets.otherwise());\n+            let lltrue = helper.llbb_with_cleanup(self, target);\n+            let llfalse = helper.llbb_with_cleanup(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n                 // Don't generate trivial icmps when switching on bool\n                 match test_value {\n@@ -299,8 +306,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             bx.switch(\n                 discr.immediate(),\n-                helper.llblock(self, targets.otherwise()),\n-                target_iter.map(|(value, target)| (value, helper.llblock(self, target))),\n+                helper.llbb_with_cleanup(self, targets.otherwise()),\n+                target_iter.map(|(value, target)| (value, helper.llbb_with_cleanup(self, target))),\n             );\n         }\n     }\n@@ -530,7 +537,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cond = bx.expect(cond, expected);\n \n         // Create the failure block and the conditional branch to it.\n-        let lltarget = helper.llblock(self, target);\n+        let lltarget = helper.llbb_with_cleanup(self, target);\n         let panic_block = bx.append_sibling_block(\"panic\");\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block);\n@@ -1459,20 +1466,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //          bar();\n                 //      }\n                 Some(&mir::TerminatorKind::Abort) => {\n-                    let cs_bb =\n+                    let cs_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n-                    let cp_bb =\n+                    let cp_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bb;\n+                    ret_llbb = cs_llbb;\n \n-                    let mut cs_bx = Bx::build(self.cx, cs_bb);\n-                    let cs = cs_bx.catch_switch(None, None, &[cp_bb]);\n+                    let mut cs_bx = Bx::build(self.cx, cs_llbb);\n+                    let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n \n                     // The \"null\" here is actually a RTTI type descriptor for the\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n-                    let mut cp_bx = Bx::build(self.cx, cp_bb);\n+                    let mut cp_bx = Bx::build(self.cx, cp_llbb);\n                     let null = cp_bx.const_null(\n                         cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n                     );\n@@ -1481,30 +1488,31 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     cp_bx.br(llbb);\n                 }\n                 _ => {\n-                    let cleanup_bb =\n+                    let cleanup_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bb;\n-                    let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n+                    ret_llbb = cleanup_llbb;\n+                    let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n                     funclet = cleanup_bx.cleanup_pad(None, &[]);\n                     cleanup_bx.br(llbb);\n                 }\n             }\n             self.funclets[bb] = Some(funclet);\n             ret_llbb\n         } else {\n-            let bb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n-            let mut bx = Bx::build(self.cx, bb);\n+            let cleanup_llbb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n+            let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n \n             let llpersonality = self.cx.eh_personality();\n             let llretty = self.landing_pad_type();\n-            let lp = bx.cleanup_landing_pad(llretty, llpersonality);\n+            let lp = cleanup_bx.cleanup_landing_pad(llretty, llpersonality);\n \n-            let slot = self.get_personality_slot(&mut bx);\n-            slot.storage_live(&mut bx);\n-            Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n+            let slot = self.get_personality_slot(&mut cleanup_bx);\n+            slot.storage_live(&mut cleanup_bx);\n+            Pair(cleanup_bx.extract_value(lp, 0), cleanup_bx.extract_value(lp, 1))\n+                .store(&mut cleanup_bx, slot);\n \n-            bx.br(llbb);\n-            bx.llbb()\n+            cleanup_bx.br(llbb);\n+            cleanup_llbb\n         }\n     }\n "}, {"sha": "da9aaf00ecf6e83f4e9c62af5df4e1d054d5a08c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aea54c0823064391d87569e6704a628b5a53465/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=6aea54c0823064391d87569e6704a628b5a53465", "patch": "@@ -148,10 +148,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n-    let mut bx = Bx::build(cx, start_llbb);\n+    let mut start_bx = Bx::build(cx, start_llbb);\n \n     if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n-        bx.set_personality_fn(cx.eh_personality());\n+        start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n@@ -180,7 +180,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         caller_location: None,\n     };\n \n-    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut bx);\n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut start_bx);\n \n     // Evaluate all required consts; codegen later assumes that CTFE will never fail.\n     let mut all_consts_ok = true;\n@@ -206,29 +206,29 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &mut fx, &memory_locals);\n+        let args = arg_local_refs(&mut start_bx, &mut fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.layout_of(fx.monomorphize(decl.ty));\n+            let layout = start_bx.layout_of(fx.monomorphize(decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);\n-                let llretptr = bx.get_param(0);\n+                let llretptr = start_bx.get_param(0);\n                 return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n             }\n \n             if memory_locals.contains(local) {\n                 debug!(\"alloc: {:?} -> place\", local);\n                 if layout.is_unsized() {\n-                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut bx, layout))\n+                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut start_bx, layout))\n                 } else {\n-                    LocalRef::Place(PlaceRef::alloca(&mut bx, layout))\n+                    LocalRef::Place(PlaceRef::alloca(&mut start_bx, layout))\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut bx, layout)\n+                LocalRef::new_operand(&mut start_bx, layout)\n             }\n         };\n \n@@ -240,7 +240,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     };\n \n     // Apply debuginfo to the newly allocated locals.\n-    fx.debug_introduce_locals(&mut bx);\n+    fx.debug_introduce_locals(&mut start_bx);\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in traversal::reverse_postorder(&mir) {"}]}