{"sha": "f26b7928e065f067d7181d3425fe17526dc3bcd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNmI3OTI4ZTA2NWYwNjdkNzE4MWQzNDI1ZmUxNzUyNmRjM2JjZDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-24T13:32:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-24T13:32:52Z"}, "message": "Merge pull request #4495 from vsrs/fixture_meta\n\nTest fixtures parsing improvements", "tree": {"sha": "40dc4f23507c621ce80d0923a89c65faf947da2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40dc4f23507c621ce80d0923a89c65faf947da2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f26b7928e065f067d7181d3425fe17526dc3bcd1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeyneECRBK7hj4Ov3rIwAAdHIIACjBAGt2sBq7j7iFfX8yf8M5\nOQYDcjoiOwUA5nPZCiL3ld0wfQcKoDM6PMAugLGoqovhGfvVIYCeZE0iXmibvpjq\nY80Z/I0s+AZzOX8J6fL7WAbLDY169CsxCiOMwJnHX7GhOWKuLMZbIg5xY0cK2Ft6\nLWCFZVXAbHyukO749w/gEVlTAdknXattF9MdgOB+SU2Lu9CLdJBHvyO4T8HA06Q6\n6sdmZsXoFaflbpqSXWFqhl6qiGkwNt3z7zz7aA8PFzeTmvk9Nrh/4wsL1gxil20e\nUSAf6nU52sIFINKuYAt9k6z8GFjplPWAx3hsYa8xwYuG7s5F/PU2JAqeemqBpGQ=\n=9jHU\n-----END PGP SIGNATURE-----\n", "payload": "tree 40dc4f23507c621ce80d0923a89c65faf947da2e\nparent ce7144a93d6fe290731cd018da3052d948df4d57\nparent cd45c73b660f85acc9b564e536bc407f0836891d\nauthor Aleksey Kladov <aleksey.kladov@gmail.com> 1590327172 +0200\ncommitter GitHub <noreply@github.com> 1590327172 +0200\n\nMerge pull request #4495 from vsrs/fixture_meta\n\nTest fixtures parsing improvements"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f26b7928e065f067d7181d3425fe17526dc3bcd1", "html_url": "https://github.com/rust-lang/rust/commit/f26b7928e065f067d7181d3425fe17526dc3bcd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f26b7928e065f067d7181d3425fe17526dc3bcd1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce7144a93d6fe290731cd018da3052d948df4d57", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce7144a93d6fe290731cd018da3052d948df4d57", "html_url": "https://github.com/rust-lang/rust/commit/ce7144a93d6fe290731cd018da3052d948df4d57"}, {"sha": "cd45c73b660f85acc9b564e536bc407f0836891d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd45c73b660f85acc9b564e536bc407f0836891d", "html_url": "https://github.com/rust-lang/rust/commit/cd45c73b660f85acc9b564e536bc407f0836891d"}], "stats": {"total": 403, "additions": 326, "deletions": 77}, "files": [{"sha": "f6b50c67cf207f2b5ca5c5b5b0f1fa5460b04452", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=f26b7928e065f067d7181d3425fe17526dc3bcd1", "patch": "@@ -63,7 +63,7 @@ use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n-use test_utils::{extract_offset, parse_fixture, parse_single_fixture, CURSOR_MARKER};\n+use test_utils::{extract_offset, parse_fixture, parse_single_fixture, FixtureMeta, CURSOR_MARKER};\n \n use crate::{\n     input::CrateName, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, RelativePathBuf,\n@@ -113,7 +113,7 @@ fn with_single_file(db: &mut dyn SourceDatabaseExt, ra_fixture: &str) -> FileId\n     let fixture = parse_single_fixture(ra_fixture);\n \n     let crate_graph = if let Some(entry) = fixture {\n-        let meta = match parse_meta(&entry.meta) {\n+        let meta = match ParsedMeta::from(&entry.meta) {\n             ParsedMeta::File(it) => it,\n             _ => panic!(\"with_single_file only support file meta\"),\n         };\n@@ -170,7 +170,7 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n     let mut file_position = None;\n \n     for entry in fixture.iter() {\n-        let meta = match parse_meta(&entry.meta) {\n+        let meta = match ParsedMeta::from(&entry.meta) {\n             ParsedMeta::Root { path } => {\n                 let source_root = std::mem::replace(&mut source_root, SourceRoot::new_local());\n                 db.set_source_root(source_root_id, Arc::new(source_root));\n@@ -258,53 +258,25 @@ struct FileMeta {\n     env: Env,\n }\n \n-//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo)\n-fn parse_meta(meta: &str) -> ParsedMeta {\n-    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n-\n-    if components[0] == \"root\" {\n-        let path: RelativePathBuf = components[1].into();\n-        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n-        return ParsedMeta::Root { path };\n-    }\n-\n-    let path: RelativePathBuf = components[0].into();\n-    assert!(path.starts_with(\"/\"));\n-\n-    let mut krate = None;\n-    let mut deps = Vec::new();\n-    let mut edition = Edition::Edition2018;\n-    let mut cfg = CfgOptions::default();\n-    let mut env = Env::default();\n-    for component in components[1..].iter() {\n-        let (key, value) = split1(component, ':').unwrap();\n-        match key {\n-            \"crate\" => krate = Some(value.to_string()),\n-            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n-            \"edition\" => edition = Edition::from_str(&value).unwrap(),\n-            \"cfg\" => {\n-                for key in value.split(',') {\n-                    match split1(key, '=') {\n-                        None => cfg.insert_atom(key.into()),\n-                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n-                    }\n-                }\n-            }\n-            \"env\" => {\n-                for key in value.split(',') {\n-                    if let Some((k, v)) = split1(key, '=') {\n-                        env.set(k, v.into());\n-                    }\n-                }\n+impl From<&FixtureMeta> for ParsedMeta {\n+    fn from(meta: &FixtureMeta) -> Self {\n+        match meta {\n+            FixtureMeta::Root { path } => {\n+                // `Self::Root` causes a false warning: 'variant is never constructed: `Root` '\n+                // see https://github.com/rust-lang/rust/issues/69018\n+                ParsedMeta::Root { path: path.to_owned() }\n             }\n-            _ => panic!(\"bad component: {:?}\", component),\n+            FixtureMeta::File(f) => Self::File(FileMeta {\n+                path: f.path.to_owned().into(),\n+                krate: f.crate_name.to_owned().into(),\n+                deps: f.deps.to_owned(),\n+                cfg: f.cfg.to_owned(),\n+                edition: f\n+                    .edition\n+                    .as_ref()\n+                    .map_or(Edition::Edition2018, |v| Edition::from_str(&v).unwrap()),\n+                env: Env::from(f.env.iter()),\n+            }),\n         }\n     }\n-\n-    ParsedMeta::File(FileMeta { path, krate, deps, edition, cfg, env })\n-}\n-\n-fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n-    let idx = haystack.find(delim)?;\n-    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n }"}, {"sha": "4d2d3b48a0c073f71ef52ec62f4367883c405924", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=f26b7928e065f067d7181d3425fe17526dc3bcd1", "patch": "@@ -311,6 +311,21 @@ impl fmt::Display for Edition {\n     }\n }\n \n+impl<'a, T> From<T> for Env\n+where\n+    T: Iterator<Item = (&'a String, &'a String)>,\n+{\n+    fn from(iter: T) -> Self {\n+        let mut result = Self::default();\n+\n+        for (k, v) in iter {\n+            result.entries.insert(k.to_owned(), v.to_owned());\n+        }\n+\n+        result\n+    }\n+}\n+\n impl Env {\n     pub fn set(&mut self, env: &str, value: String) {\n         self.entries.insert(env.to_owned(), value);"}, {"sha": "defd8176ff87ddb7dc75ae66e1c7f19340f5322b", "filename": "crates/ra_ide/src/call_hierarchy.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs?ref=f26b7928e065f067d7181d3425fe17526dc3bcd1", "patch": "@@ -245,6 +245,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_call_hierarchy_in_tests_mod() {\n+        check_hierarchy(\n+            r#\"\n+            //- /lib.rs cfg:test\n+            fn callee() {}\n+            fn caller1() {\n+                call<|>ee();\n+            }\n+\n+            #[cfg(test)]\n+            mod tests {\n+                use super::*;\n+\n+                #[test]\n+                fn test_caller() {\n+                    callee();\n+                }\n+            }\n+            \"#,\n+            \"callee FN_DEF FileId(1) 0..14 3..9\",\n+            &[\n+                \"caller1 FN_DEF FileId(1) 15..45 18..25 : [34..40]\",\n+                \"test_caller FN_DEF FileId(1) 93..147 108..119 : [132..138]\",\n+            ],\n+            &[],\n+        );\n+    }\n+\n     #[test]\n     fn test_call_hierarchy_in_different_files() {\n         check_hierarchy("}, {"sha": "ad78d2d93fd4d105b91d1673db85ab32b04581d5", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 102, "deletions": 21, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=f26b7928e065f067d7181d3425fe17526dc3bcd1", "patch": "@@ -1,21 +1,81 @@\n //! FIXME: write short doc here\n \n+use std::str::FromStr;\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n use ra_db::{CrateName, Env, RelativePathBuf};\n-use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n+use test_utils::{extract_offset, extract_range, parse_fixture, FixtureEntry, CURSOR_MARKER};\n \n use crate::{\n-    Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition::Edition2018, FileId, FilePosition,\n-    FileRange, SourceRootId,\n+    Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition, FileId, FilePosition, FileRange,\n+    SourceRootId,\n };\n \n+#[derive(Debug)]\n+enum MockFileData {\n+    Plain { path: String, content: String },\n+    Fixture(FixtureEntry),\n+}\n+\n+impl MockFileData {\n+    fn new(path: String, content: String) -> Self {\n+        // `Self::Plain` causes a false warning: 'variant is never constructed: `Plain` '\n+        // see https://github.com/rust-lang/rust/issues/69018\n+        MockFileData::Plain { path, content }\n+    }\n+\n+    fn path(&self) -> &str {\n+        match self {\n+            MockFileData::Plain { path, .. } => path.as_str(),\n+            MockFileData::Fixture(f) => f.meta.path().as_str(),\n+        }\n+    }\n+\n+    fn content(&self) -> &str {\n+        match self {\n+            MockFileData::Plain { content, .. } => content,\n+            MockFileData::Fixture(f) => f.text.as_str(),\n+        }\n+    }\n+\n+    fn cfg_options(&self) -> CfgOptions {\n+        match self {\n+            MockFileData::Fixture(f) => {\n+                f.meta.cfg_options().map_or_else(Default::default, |o| o.clone())\n+            }\n+            _ => CfgOptions::default(),\n+        }\n+    }\n+\n+    fn edition(&self) -> Edition {\n+        match self {\n+            MockFileData::Fixture(f) => {\n+                f.meta.edition().map_or(Edition::Edition2018, |v| Edition::from_str(v).unwrap())\n+            }\n+            _ => Edition::Edition2018,\n+        }\n+    }\n+\n+    fn env(&self) -> Env {\n+        match self {\n+            MockFileData::Fixture(f) => Env::from(f.meta.env()),\n+            _ => Env::default(),\n+        }\n+    }\n+}\n+\n+impl From<FixtureEntry> for MockFileData {\n+    fn from(fixture: FixtureEntry) -> Self {\n+        Self::Fixture(fixture)\n+    }\n+}\n+\n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n #[derive(Debug, Default)]\n pub struct MockAnalysis {\n-    files: Vec<(String, String)>,\n+    files: Vec<MockFileData>,\n }\n \n impl MockAnalysis {\n@@ -35,7 +95,7 @@ impl MockAnalysis {\n     pub fn with_files(fixture: &str) -> MockAnalysis {\n         let mut res = MockAnalysis::new();\n         for entry in parse_fixture(fixture) {\n-            res.add_file(&entry.meta, &entry.text);\n+            res.add_file_fixture(entry);\n         }\n         res\n     }\n@@ -48,38 +108,52 @@ impl MockAnalysis {\n         for entry in parse_fixture(fixture) {\n             if entry.text.contains(CURSOR_MARKER) {\n                 assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n-                position = Some(res.add_file_with_position(&entry.meta, &entry.text));\n+                position = Some(res.add_file_fixture_with_position(entry));\n             } else {\n-                res.add_file(&entry.meta, &entry.text);\n+                res.add_file_fixture(entry);\n             }\n         }\n         let position = position.expect(\"expected a marker (<|>)\");\n         (res, position)\n     }\n \n+    pub fn add_file_fixture(&mut self, fixture: FixtureEntry) -> FileId {\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::from(fixture));\n+        file_id\n+    }\n+\n+    pub fn add_file_fixture_with_position(&mut self, mut fixture: FixtureEntry) -> FilePosition {\n+        let (offset, text) = extract_offset(&fixture.text);\n+        fixture.text = text;\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::from(fixture));\n+        FilePosition { file_id, offset }\n+    }\n+\n     pub fn add_file(&mut self, path: &str, text: &str) -> FileId {\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text.to_string()));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text.to_string()));\n         file_id\n     }\n     pub fn add_file_with_position(&mut self, path: &str, text: &str) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text));\n         FilePosition { file_id, offset }\n     }\n     pub fn add_file_with_range(&mut self, path: &str, text: &str) -> FileRange {\n         let (range, text) = extract_range(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text));\n         FileRange { file_id, range }\n     }\n     pub fn id_of(&self, path: &str) -> FileId {\n         let (idx, _) = self\n             .files\n             .iter()\n             .enumerate()\n-            .find(|(_, (p, _text))| path == p)\n+            .find(|(_, data)| path == data.path())\n             .expect(\"no file in this mock\");\n         FileId(idx as u32 + 1)\n     }\n@@ -90,29 +164,32 @@ impl MockAnalysis {\n         change.add_root(source_root, true);\n         let mut crate_graph = CrateGraph::default();\n         let mut root_crate = None;\n-        for (i, (path, contents)) in self.files.into_iter().enumerate() {\n+        for (i, data) in self.files.into_iter().enumerate() {\n+            let path = data.path();\n             assert!(path.starts_with('/'));\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+            let cfg_options = data.cfg_options();\n             let file_id = FileId(i as u32 + 1);\n-            let cfg_options = CfgOptions::default();\n+            let edition = data.edition();\n+            let env = data.env();\n             if path == \"/lib.rs\" || path == \"/main.rs\" {\n                 root_crate = Some(crate_graph.add_crate_root(\n                     file_id,\n-                    Edition2018,\n+                    edition,\n                     None,\n                     cfg_options,\n-                    Env::default(),\n+                    env,\n                     Default::default(),\n                     Default::default(),\n                 ));\n             } else if path.ends_with(\"/lib.rs\") {\n                 let crate_name = path.parent().unwrap().file_name().unwrap();\n                 let other_crate = crate_graph.add_crate_root(\n                     file_id,\n-                    Edition2018,\n+                    edition,\n                     Some(CrateName::new(crate_name).unwrap()),\n                     cfg_options,\n-                    Env::default(),\n+                    env,\n                     Default::default(),\n                     Default::default(),\n                 );\n@@ -122,7 +199,7 @@ impl MockAnalysis {\n                         .unwrap();\n                 }\n             }\n-            change.add_file(source_root, file_id, path, Arc::new(contents));\n+            change.add_file(source_root, file_id, path, Arc::new(data.content().to_owned()));\n         }\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);\n@@ -131,6 +208,10 @@ impl MockAnalysis {\n     pub fn analysis(self) -> Analysis {\n         self.analysis_host().analysis()\n     }\n+\n+    fn next_id(&self) -> FileId {\n+        FileId((self.files.len() + 1) as u32)\n+    }\n }\n \n /// Creates analysis from a multi-file fixture, returns positions marked with <|>."}, {"sha": "66a6f4d541a2a16badbf12d76ae9537c52cebf2c", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=f26b7928e065f067d7181d3425fe17526dc3bcd1", "patch": "@@ -68,7 +68,7 @@ impl<'a> Project<'a> {\n         let mut paths = vec![];\n \n         for entry in parse_fixture(self.fixture) {\n-            let path = tmp_dir.path().join(entry.meta);\n+            let path = tmp_dir.path().join(entry.meta.path().as_str());\n             fs::create_dir_all(path.parent().unwrap()).unwrap();\n             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();\n             paths.push((path, entry.text));"}, {"sha": "4d185b01c752d26e41c9fa7437e189719a20c73b", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=f26b7928e065f067d7181d3425fe17526dc3bcd1", "patch": "@@ -11,3 +11,7 @@ doctest = false\n difference = \"2.0.0\"\n text-size = \"1.0.0\"\n serde_json = \"1.0.48\"\n+relative-path = \"1.0.0\"\n+rustc-hash = \"1.1.0\"\n+\n+ra_cfg = { path = \"../ra_cfg\" }\n\\ No newline at end of file"}, {"sha": "1bd97215cb8326ccef82a898a42c11022d5cdc66", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 154, "deletions": 6, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f26b7928e065f067d7181d3425fe17526dc3bcd1/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=f26b7928e065f067d7181d3425fe17526dc3bcd1", "patch": "@@ -14,6 +14,10 @@ use std::{\n     path::{Path, PathBuf},\n };\n \n+pub use ra_cfg::CfgOptions;\n+\n+pub use relative_path::{RelativePath, RelativePathBuf};\n+pub use rustc_hash::FxHashMap;\n use serde_json::Value;\n use text_size::{TextRange, TextSize};\n \n@@ -157,10 +161,82 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct FixtureEntry {\n-    pub meta: String,\n+    pub meta: FixtureMeta,\n     pub text: String,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n+pub enum FixtureMeta {\n+    Root { path: RelativePathBuf },\n+    File(FileMeta),\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct FileMeta {\n+    pub path: RelativePathBuf,\n+    pub crate_name: Option<String>,\n+    pub deps: Vec<String>,\n+    pub cfg: CfgOptions,\n+    pub edition: Option<String>,\n+    pub env: FxHashMap<String, String>,\n+}\n+\n+impl FixtureMeta {\n+    pub fn path(&self) -> &RelativePath {\n+        match self {\n+            FixtureMeta::Root { path } => &path,\n+            FixtureMeta::File(f) => &f.path,\n+        }\n+    }\n+\n+    pub fn crate_name(&self) -> Option<&String> {\n+        match self {\n+            FixtureMeta::File(f) => f.crate_name.as_ref(),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn cfg_options(&self) -> Option<&CfgOptions> {\n+        match self {\n+            FixtureMeta::File(f) => Some(&f.cfg),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn edition(&self) -> Option<&String> {\n+        match self {\n+            FixtureMeta::File(f) => f.edition.as_ref(),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn env(&self) -> impl Iterator<Item = (&String, &String)> {\n+        struct EnvIter<'a> {\n+            iter: Option<std::collections::hash_map::Iter<'a, String, String>>,\n+        }\n+\n+        impl<'a> EnvIter<'a> {\n+            fn new(meta: &'a FixtureMeta) -> Self {\n+                Self {\n+                    iter: match meta {\n+                        FixtureMeta::File(f) => Some(f.env.iter()),\n+                        _ => None,\n+                    },\n+                }\n+            }\n+        }\n+\n+        impl<'a> Iterator for EnvIter<'a> {\n+            type Item = (&'a String, &'a String);\n+            fn next(&mut self) -> Option<Self::Item> {\n+                self.iter.as_mut().and_then(|i| i.next())\n+            }\n+        }\n+\n+        EnvIter::new(self)\n+    }\n+}\n+\n /// Parses text which looks like this:\n ///\n ///  ```not_rust\n@@ -169,8 +245,8 @@ pub struct FixtureEntry {\n ///  line 2\n ///  // - other meta\n ///  ```\n-pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n-    let fixture = indent_first_line(fixture);\n+pub fn parse_fixture(ra_fixture: &str) -> Vec<FixtureEntry> {\n+    let fixture = indent_first_line(ra_fixture);\n     let margin = fixture_margin(&fixture);\n \n     let mut lines = fixture\n@@ -200,6 +276,7 @@ The offending line: {:?}\"#,\n     for line in lines.by_ref() {\n         if line.starts_with(\"//-\") {\n             let meta = line[\"//-\".len()..].trim().to_string();\n+            let meta = parse_meta(&meta);\n             res.push(FixtureEntry { meta, text: String::new() })\n         } else if let Some(entry) = res.last_mut() {\n             entry.text.push_str(line);\n@@ -209,6 +286,57 @@ The offending line: {:?}\"#,\n     res\n }\n \n+//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n+fn parse_meta(meta: &str) -> FixtureMeta {\n+    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n+\n+    if components[0] == \"root\" {\n+        let path: RelativePathBuf = components[1].into();\n+        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n+        return FixtureMeta::Root { path };\n+    }\n+\n+    let path: RelativePathBuf = components[0].into();\n+    assert!(path.starts_with(\"/\"));\n+\n+    let mut krate = None;\n+    let mut deps = Vec::new();\n+    let mut edition = None;\n+    let mut cfg = CfgOptions::default();\n+    let mut env = FxHashMap::default();\n+    for component in components[1..].iter() {\n+        let (key, value) = split1(component, ':').unwrap();\n+        match key {\n+            \"crate\" => krate = Some(value.to_string()),\n+            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n+            \"edition\" => edition = Some(value.to_string()),\n+            \"cfg\" => {\n+                for key in value.split(',') {\n+                    match split1(key, '=') {\n+                        None => cfg.insert_atom(key.into()),\n+                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n+                    }\n+                }\n+            }\n+            \"env\" => {\n+                for key in value.split(',') {\n+                    if let Some((k, v)) = split1(key, '=') {\n+                        env.insert(k.into(), v.into());\n+                    }\n+                }\n+            }\n+            _ => panic!(\"bad component: {:?}\", component),\n+        }\n+    }\n+\n+    FixtureMeta::File(FileMeta { path, crate_name: krate, deps, edition, cfg, env })\n+}\n+\n+fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let idx = haystack.find(delim)?;\n+    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+}\n+\n /// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n /// This allows fixtures to start off in a different indentation, e.g. to align the first line with\n /// the other lines visually:\n@@ -288,13 +416,33 @@ struct Bar;\n     )\n }\n \n+#[test]\n+fn parse_fixture_gets_full_meta() {\n+    let parsed = parse_fixture(\n+        r\"\n+    //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n+    mod m;\n+    \",\n+    );\n+    assert_eq!(1, parsed.len());\n+\n+    let parsed = &parsed[0];\n+    assert_eq!(\"mod m;\\n\\n\", parsed.text);\n+\n+    let meta = &parsed.meta;\n+    assert_eq!(\"foo\", meta.crate_name().unwrap());\n+    assert_eq!(\"/lib.rs\", meta.path());\n+    assert!(meta.cfg_options().is_some());\n+    assert_eq!(2, meta.env().count());\n+}\n+\n /// Same as `parse_fixture`, except it allow empty fixture\n-pub fn parse_single_fixture(fixture: &str) -> Option<FixtureEntry> {\n-    if !fixture.lines().any(|it| it.trim_start().starts_with(\"//-\")) {\n+pub fn parse_single_fixture(ra_fixture: &str) -> Option<FixtureEntry> {\n+    if !ra_fixture.lines().any(|it| it.trim_start().starts_with(\"//-\")) {\n         return None;\n     }\n \n-    let fixtures = parse_fixture(fixture);\n+    let fixtures = parse_fixture(ra_fixture);\n     if fixtures.len() > 1 {\n         panic!(\"too many fixtures\");\n     }"}]}