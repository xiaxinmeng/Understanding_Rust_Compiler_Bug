{"sha": "24e98121d81b75bafcd9c6005548776c00de8401", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZTk4MTIxZDgxYjc1YmFmY2Q5YzYwMDU1NDg3NzZjMDBkZTg0MDE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-07T14:27:03Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-07T14:48:06Z"}, "message": "Try to complete within macros", "tree": {"sha": "976841b2501ab4501613a5f66b1004cd67f7e369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/976841b2501ab4501613a5f66b1004cd67f7e369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24e98121d81b75bafcd9c6005548776c00de8401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24e98121d81b75bafcd9c6005548776c00de8401", "html_url": "https://github.com/rust-lang/rust/commit/24e98121d81b75bafcd9c6005548776c00de8401", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24e98121d81b75bafcd9c6005548776c00de8401/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aff82cf7ac172f213cb5dcca637cb2c5332294c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff82cf7ac172f213cb5dcca637cb2c5332294c1", "html_url": "https://github.com/rust-lang/rust/commit/aff82cf7ac172f213cb5dcca637cb2c5332294c1"}], "stats": {"total": 377, "additions": 339, "deletions": 38}, "files": [{"sha": "2e052d267b56ca757e904eae11d3499698eb5762", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -960,6 +960,7 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"either\",\n+ \"itertools\",\n  \"log\",\n  \"ra_db\",\n  \"ra_hir_def\","}, {"sha": "266c4cff3829b8a6b4065e8e04a0291193a9a5de", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -12,6 +12,8 @@ log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n either = \"1.5.3\"\n \n+itertools = \"0.8.2\"\n+\n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n ra_prof = { path = \"../ra_prof\" }"}, {"sha": "56bd763c76127da33db1b9d3e84bede6ebb9781b", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -6,13 +6,14 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    TraitId,\n+    AsMacroCall, TraitId,\n };\n use hir_expand::ExpansionInfo;\n use ra_db::{FileId, FileRange};\n use ra_prof::profile;\n use ra_syntax::{\n-    algo::skip_trivia_token, ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n+    algo::{self, skip_trivia_token},\n+    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -70,6 +71,37 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         Some(node)\n     }\n \n+    pub fn expand_hypothetical(\n+        &self,\n+        actual_macro_call: &ast::MacroCall,\n+        hypothetical_call: &ast::MacroCall,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        let macro_call =\n+            self.find_file(actual_macro_call.syntax().clone()).with_value(actual_macro_call);\n+        let sa = self.analyze2(macro_call.map(|it| it.syntax()), None);\n+        let macro_call_id = macro_call\n+            .as_call_id(self.db, |path| sa.resolver.resolve_path_as_macro(self.db, &path))?;\n+        let macro_file = macro_call_id.as_file().macro_file().unwrap();\n+        let (tt, tmap_1) =\n+            hir_expand::syntax_node_to_token_tree(hypothetical_call.token_tree().unwrap().syntax())\n+                .unwrap();\n+        let range = token_to_map\n+            .text_range()\n+            .checked_sub(hypothetical_call.token_tree().unwrap().syntax().text_range().start())?;\n+        let token_id = tmap_1.token_by_range(range)?;\n+        let macro_def = hir_expand::db::expander(self.db, macro_call_id)?;\n+        let (node, tmap_2) = hir_expand::db::parse_macro_with_arg(\n+            self.db,\n+            macro_file,\n+            Some(std::sync::Arc::new((tt, tmap_1))),\n+        )?;\n+        let token_id = macro_def.0.map_id_down(token_id);\n+        let range = tmap_2.range_by_token(token_id)?.by_kind(token_to_map.kind())?;\n+        let token = algo::find_covering_element(&node.syntax_node(), range).into_token()?;\n+        Some((node.syntax_node(), token))\n+    }\n+\n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n         let parent = token.parent();\n         let parent = self.find_file(parent);\n@@ -104,6 +136,25 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         node.ancestors_with_macros(self.db).map(|it| it.value)\n     }\n \n+    pub fn ancestors_at_offset_with_macros(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextUnit,\n+    ) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        use itertools::Itertools;\n+        node.token_at_offset(offset)\n+            .map(|token| self.ancestors_with_macros(token.parent()))\n+            .kmerge_by(|node1, node2| node1.text_range().len() < node2.text_range().len())\n+    }\n+\n+    pub fn find_node_at_offset_with_macros<N: AstNode>(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextUnit,\n+    ) -> Option<N> {\n+        self.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n+    }\n+\n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n         self.analyze(expr.syntax()).type_of(self.db, &expr)\n     }"}, {"sha": "a7aa60fc992fd217863a6fb21bb0ee469c7ece45", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -129,16 +129,43 @@ pub(crate) fn macro_arg(\n pub(crate) fn macro_expand(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n+) -> Result<Arc<tt::Subtree>, String> {\n+    macro_expand_with_arg(db, id, None)\n+}\n+\n+// TODO hack\n+pub fn expander(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n+    let lazy_id = match id {\n+        MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(_id) => {\n+            // TODO\n+            unimplemented!()\n+        }\n+    };\n+\n+    let loc = db.lookup_intern_macro(lazy_id);\n+    let macro_rules = db.macro_def(loc.def)?;\n+    Some(macro_rules)\n+}\n+\n+pub(crate) fn macro_expand_with_arg(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n ) -> Result<Arc<tt::Subtree>, String> {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(id) => {\n+            // TODO\n             return Ok(db.lookup_intern_eager_expansion(id).subtree);\n         }\n     };\n \n     let loc = db.lookup_intern_macro(lazy_id);\n-    let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n+    let macro_arg = arg.or_else(|| db.macro_arg(id)).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n     let tt = macro_rules.0.expand(db, lazy_id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n@@ -162,12 +189,24 @@ pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Optio\n pub(crate) fn parse_macro(\n     db: &dyn AstDatabase,\n     macro_file: MacroFile,\n+) -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n+    parse_macro_with_arg(db, macro_file, None)\n+}\n+\n+pub fn parse_macro_with_arg(\n+    db: &dyn AstDatabase,\n+    macro_file: MacroFile,\n+    arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n ) -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n     let _p = profile(\"parse_macro_query\");\n \n     let macro_call_id = macro_file.macro_call_id;\n-    let tt = db\n-        .macro_expand(macro_call_id)\n+    let expansion = if let Some(arg) = arg {\n+        macro_expand_with_arg(db, macro_call_id, Some(arg))\n+    } else {\n+        db.macro_expand(macro_call_id)\n+    };\n+    let tt = expansion\n         .map_err(|err| {\n             // Note:\n             // The final goal we would like to make all parse_macro success,\n@@ -185,15 +224,13 @@ pub(crate) fn parse_macro(\n                     .collect::<Vec<_>>()\n                     .join(\"\\n\");\n \n-                    log::warn!(\n+                    eprintln!(\n                         \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\",\n-                        err,\n-                        node.value,\n-                        parents\n+                        err, node.value, parents\n                     );\n                 }\n                 _ => {\n-                    log::warn!(\"fail on macro_parse: (reason: {})\", err);\n+                    eprintln!(\"fail on macro_parse: (reason: {})\", err);\n                 }\n             }\n         })"}, {"sha": "92f3902ddfa069e34497a074ad79d130de4175e7", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -157,6 +157,13 @@ impl HirFileId {\n             }\n         }\n     }\n+\n+    pub fn macro_file(self) -> Option<MacroFile> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(m) => Some(m),\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -296,7 +303,7 @@ pub struct ExpansionInfo {\n     exp_map: Arc<mbe::TokenMap>,\n }\n \n-pub use mbe::Origin;\n+pub use mbe::{syntax_node_to_token_tree, Origin};\n use ra_parser::FragmentKind;\n \n impl ExpansionInfo {"}, {"sha": "da2c4c1ab28a47d39a7b6f775aacb08f34386354", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -584,4 +584,102 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn works_in_simple_macro_1() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(a.x<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [156; 157),\n+                delete: [156; 157),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn works_in_simple_macro_recursive() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(a.x<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [156; 157),\n+                delete: [156; 157),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn works_in_simple_macro_2() {\n+        // this doesn't work yet because the macro doesn't expand without the token -- maybe it can be fixed with better recovery\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(a.<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"[]\"###\n+        );\n+    }\n+\n+    #[test]\n+    fn works_in_simple_macro_recursive_1() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(m!(m!(a.x<|>)))\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [162; 163),\n+                delete: [162; 163),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "4fa47951a84f373972835443af2c0e5a9e505543", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -1,4 +1,4 @@\n-//! Completion of paths, including when writing a single name.\n+//! Completion of paths, i.e. `some::prefix::<|>`.\n \n use hir::{Adt, PathResolution, ScopeDef};\n use ra_syntax::AstNode;"}, {"sha": "eb3c8cf1b6b491956b0ab5770910eb2f27c8e5dd", "filename": "crates/ra_ide/src/completion/complete_scope.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! Completion of names from the current scope, e.g. locals and imported items.\n \n use crate::completion::{CompletionContext, Completions};\n \n@@ -797,4 +797,72 @@ mod tests {\n         \"###\n         )\n     }\n+\n+    #[test]\n+    fn completes_in_simple_macro_1() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                fn quux(x: i32) {\n+                    let y = 92;\n+                    m!(<|>);\n+                }\n+                \"\n+            ),\n+            @\"[]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_in_simple_macro_2() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                fn quux(x: i32) {\n+                    let y = 92;\n+                    m!(x<|>);\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"m!\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"m!($0)\",\n+                kind: Macro,\n+                detail: \"macro_rules! m\",\n+            },\n+            CompletionItem {\n+                label: \"quux(\u2026)\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"quux(${1:x})$0\",\n+                kind: Function,\n+                lookup: \"quux\",\n+                detail: \"fn quux(x: i32)\",\n+            },\n+            CompletionItem {\n+                label: \"x\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"x\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+            CompletionItem {\n+                label: \"y\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"y\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "81a033fcbf5528e41b5e9f870aeb98499eef2ee5", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e98121d81b75bafcd9c6005548776c00de8401/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=24e98121d81b75bafcd9c6005548776c00de8401", "patch": "@@ -5,7 +5,7 @@ use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n-    ast, AstNode, SourceFile,\n+    ast, AstNode,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n@@ -20,6 +20,9 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) sema: Semantics<'a, RootDatabase>,\n     pub(super) db: &'a RootDatabase,\n     pub(super) offset: TextUnit,\n+    /// The token before the cursor, in the original file.\n+    pub(super) original_token: SyntaxToken,\n+    /// The token before the cursor, in the macro-expanded file.\n     pub(super) token: SyntaxToken,\n     pub(super) module: Option<hir::Module>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n@@ -67,12 +70,18 @@ impl<'a> CompletionContext<'a> {\n             let edit = AtomTextEdit::insert(position.offset, \"intellijRulezz\".to_string());\n             parse.reparse(&edit).tree()\n         };\n+        let fake_ident_token =\n+            file_with_fake_ident.syntax().token_at_offset(position.offset).right_biased().unwrap();\n \n+        // TODO: shouldn't this take the position into account? (in case we're inside a mod {})\n         let module = sema.to_module_def(position.file_id);\n-        let token = original_file.syntax().token_at_offset(position.offset).left_biased()?;\n+        let original_token =\n+            original_file.syntax().token_at_offset(position.offset).left_biased()?;\n+        let token = sema.descend_into_macros(original_token.clone());\n         let mut ctx = CompletionContext {\n             sema,\n             db,\n+            original_token,\n             token,\n             offset: position.offset,\n             module,\n@@ -95,15 +104,45 @@ impl<'a> CompletionContext<'a> {\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n         };\n-        ctx.fill(&original_file, file_with_fake_ident, position.offset);\n+\n+        let mut original_file = original_file.syntax().clone();\n+        let mut hypothetical_file = file_with_fake_ident.syntax().clone();\n+        let mut offset = position.offset;\n+        let mut fake_ident_token = fake_ident_token;\n+\n+        // Are we inside a macro call?\n+        while let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n+            find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n+            find_node_at_offset::<ast::MacroCall>(&hypothetical_file, offset),\n+        ) {\n+            if let (Some(actual_expansion), Some(hypothetical_expansion)) = (\n+                ctx.sema.expand(&actual_macro_call),\n+                ctx.sema.expand_hypothetical(\n+                    &actual_macro_call,\n+                    &macro_call_with_fake_ident,\n+                    fake_ident_token,\n+                ),\n+            ) {\n+                // TODO check that the expansions 'look the same' up to the inserted token?\n+                original_file = actual_expansion;\n+                hypothetical_file = hypothetical_expansion.0;\n+                fake_ident_token = hypothetical_expansion.1;\n+                offset = fake_ident_token.text_range().start();\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        ctx.fill(&original_file, hypothetical_file, offset);\n         Some(ctx)\n     }\n \n     // The range of the identifier that is being completed.\n     pub(crate) fn source_range(&self) -> TextRange {\n+        // check kind of macro-expanded token, but use range of original token\n         match self.token.kind() {\n             // workaroud when completion is triggered by trigger characters.\n-            IDENT => self.token.text_range(),\n+            IDENT => self.original_token.text_range(),\n             _ => TextRange::offset_len(self.offset, 0.into()),\n         }\n     }\n@@ -114,14 +153,12 @@ impl<'a> CompletionContext<'a> {\n \n     fn fill(\n         &mut self,\n-        original_file: &ast::SourceFile,\n-        file_with_fake_ident: ast::SourceFile,\n+        original_file: &SyntaxNode,\n+        file_with_fake_ident: SyntaxNode,\n         offset: TextUnit,\n     ) {\n         // First, let's try to complete a reference to some declaration.\n-        if let Some(name_ref) =\n-            find_node_at_offset::<ast::NameRef>(file_with_fake_ident.syntax(), offset)\n-        {\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&file_with_fake_ident, offset) {\n             // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n             // See RFC#1685.\n             if is_node::<ast::Param>(name_ref.syntax()) {\n@@ -133,8 +170,7 @@ impl<'a> CompletionContext<'a> {\n \n         // Otherwise, see if this is a declaration. We can use heuristics to\n         // suggest declaration names, see `CompletionKind::Magic`.\n-        if let Some(name) = find_node_at_offset::<ast::Name>(file_with_fake_ident.syntax(), offset)\n-        {\n+        if let Some(name) = find_node_at_offset::<ast::Name>(&file_with_fake_ident, offset) {\n             if let Some(bind_pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n                 let parent = bind_pat.syntax().parent();\n                 if parent.clone().and_then(ast::MatchArm::cast).is_some()\n@@ -148,23 +184,24 @@ impl<'a> CompletionContext<'a> {\n                 return;\n             }\n             if name.syntax().ancestors().find_map(ast::RecordFieldPatList::cast).is_some() {\n-                self.record_lit_pat = find_node_at_offset(original_file.syntax(), self.offset);\n+                self.record_lit_pat =\n+                    self.sema.find_node_at_offset_with_macros(&original_file, self.offset);\n             }\n         }\n     }\n \n-    fn classify_name_ref(&mut self, original_file: &SourceFile, name_ref: ast::NameRef) {\n+    fn classify_name_ref(&mut self, original_file: &SyntaxNode, name_ref: ast::NameRef) {\n         self.name_ref_syntax =\n-            find_node_at_offset(original_file.syntax(), name_ref.syntax().text_range().start());\n+            find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n         let name_range = name_ref.syntax().text_range();\n         if name_ref.syntax().parent().and_then(ast::RecordField::cast).is_some() {\n-            self.record_lit_syntax = find_node_at_offset(original_file.syntax(), self.offset);\n+            self.record_lit_syntax =\n+                self.sema.find_node_at_offset_with_macros(&original_file, self.offset);\n         }\n \n         self.impl_def = self\n-            .token\n-            .parent()\n-            .ancestors()\n+            .sema\n+            .ancestors_with_macros(self.token.parent())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::ImplDef::cast);\n \n@@ -183,12 +220,12 @@ impl<'a> CompletionContext<'a> {\n             _ => (),\n         }\n \n-        self.use_item_syntax = self.token.parent().ancestors().find_map(ast::UseItem::cast);\n+        self.use_item_syntax =\n+            self.sema.ancestors_with_macros(self.token.parent()).find_map(ast::UseItem::cast);\n \n         self.function_syntax = self\n-            .token\n-            .parent()\n-            .ancestors()\n+            .sema\n+            .ancestors_with_macros(self.token.parent())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::FnDef::cast);\n \n@@ -242,7 +279,7 @@ impl<'a> CompletionContext<'a> {\n \n                 if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n                     if let Some(if_expr) =\n-                        find_node_at_offset::<ast::IfExpr>(original_file.syntax(), off)\n+                        self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n                     {\n                         if if_expr.syntax().text_range().end()\n                             < name_ref.syntax().text_range().start()\n@@ -259,7 +296,7 @@ impl<'a> CompletionContext<'a> {\n             self.dot_receiver = field_expr\n                 .expr()\n                 .map(|e| e.syntax().text_range())\n-                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n+                .and_then(|r| find_node_with_range(original_file, r));\n             self.dot_receiver_is_ambiguous_float_literal =\n                 if let Some(ast::Expr::Literal(l)) = &self.dot_receiver {\n                     match l.kind() {\n@@ -275,7 +312,7 @@ impl<'a> CompletionContext<'a> {\n             self.dot_receiver = method_call_expr\n                 .expr()\n                 .map(|e| e.syntax().text_range())\n-                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n+                .and_then(|r| find_node_with_range(original_file, r));\n             self.is_call = true;\n         }\n     }"}]}