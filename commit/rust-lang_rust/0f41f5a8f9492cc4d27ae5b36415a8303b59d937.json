{"sha": "0f41f5a8f9492cc4d27ae5b36415a8303b59d937", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNDFmNWE4Zjk0OTJjYzRkMjdhZTViMzY0MTVhODMwM2I1OWQ5Mzc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-03T01:43:05Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-03T01:43:24Z"}, "message": "Improve translations of unary box operator and drop_ty on boxes.", "tree": {"sha": "88d3fd36721f50c303b2b2b32615ef60af83d397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88d3fd36721f50c303b2b2b32615ef60af83d397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f41f5a8f9492cc4d27ae5b36415a8303b59d937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f41f5a8f9492cc4d27ae5b36415a8303b59d937", "html_url": "https://github.com/rust-lang/rust/commit/0f41f5a8f9492cc4d27ae5b36415a8303b59d937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f41f5a8f9492cc4d27ae5b36415a8303b59d937/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e233978891d5b93641e1365e7448d20cdc8b0a12", "url": "https://api.github.com/repos/rust-lang/rust/commits/e233978891d5b93641e1365e7448d20cdc8b0a12", "html_url": "https://github.com/rust-lang/rust/commit/e233978891d5b93641e1365e7448d20cdc8b0a12"}], "stats": {"total": 68, "additions": 46, "deletions": 22}, "files": [{"sha": "255e0dc67fa5194409b5ae9abe9d7a5f0c172ea8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0f41f5a8f9492cc4d27ae5b36415a8303b59d937/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f41f5a8f9492cc4d27ae5b36415a8303b59d937/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0f41f5a8f9492cc4d27ae5b36415a8303b59d937", "patch": "@@ -374,16 +374,16 @@ fn C_struct(vec[ValueRef] elts) -> ValueRef {\n }\n \n fn C_tydesc(TypeRef t) -> ValueRef {\n-    ret C_struct(vec(C_null(T_opaque()),        // first_param\n-                     llvm.LLVMSizeOf(t),        // size\n-                     llvm.LLVMAlignOf(t),       // align\n-                     C_null(T_opaque()),        // copy_glue_off\n-                     C_null(T_opaque()),        // drop_glue_off\n-                     C_null(T_opaque()),        // free_glue_off\n-                     C_null(T_opaque()),        // sever_glue_off\n-                     C_null(T_opaque()),        // mark_glue_off\n-                     C_null(T_opaque()),        // obj_drop_glue_off\n-                     C_null(T_opaque())));      // is_stateful\n+    ret C_struct(vec(C_null(T_ptr(T_opaque())),        // first_param\n+                     llvm.LLVMSizeOf(t),               // size\n+                     llvm.LLVMAlignOf(t),              // align\n+                     C_null(T_ptr(T_opaque())),        // copy_glue_off\n+                     C_null(T_ptr(T_opaque())),        // drop_glue_off\n+                     C_null(T_ptr(T_opaque())),        // free_glue_off\n+                     C_null(T_ptr(T_opaque())),        // sever_glue_off\n+                     C_null(T_ptr(T_opaque())),        // mark_glue_off\n+                     C_null(T_ptr(T_opaque())),        // obj_drop_glue_off\n+                     C_null(T_ptr(T_opaque()))));      // is_stateful\n }\n \n fn decl_fn(ModuleRef llmod, str name, uint cc, TypeRef llty) -> ValueRef {\n@@ -450,6 +450,19 @@ fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n                                             C_int(0)));\n }\n \n+fn trans_malloc(@block_ctxt cx, @typeck.ty t) -> result {\n+    auto ptr_ty = type_of(cx.fcx.ccx, t);\n+    auto body_ty = lib.llvm.llvm.LLVMGetElementType(ptr_ty);\n+    // FIXME: need a table to collect tydesc globals.\n+    auto tydesc = C_int(0);\n+    auto sz = cx.build.IntCast(lib.llvm.llvm.LLVMSizeOf(body_ty), T_int());\n+    auto sub = trans_upcall(cx, \"upcall_malloc\", vec(sz, tydesc));\n+    sub.val = sub.bcx.build.IntToPtr(sub.val, ptr_ty);\n+    sub.bcx.cleanups += clean(bind drop_ty(_, sub.val, t));\n+    ret sub;\n+}\n+\n+\n fn incr_refcnt(@block_ctxt cx, ValueRef box_ptr) -> result {\n     auto rc_ptr = cx.build.GEP(box_ptr, vec(C_int(0),\n                                             C_int(abi.box_rc_field_refcnt)));\n@@ -636,16 +649,21 @@ fn drop_ty(@block_ctxt cx,\n                                         T_int(), C_int(0));\n         }\n \n-        case (typeck.ty_box(_)) {\n+        case (typeck.ty_box(?body_ty)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v,\n-                        @typeck.ty elt_ty) -> result {\n-                auto res = drop_ty(cx,\n-                                   cx.build.GEP(v, vec(C_int(0))),\n-                                   elt_ty);\n+                        @typeck.ty body_ty) -> result {\n+                auto body = cx.build.GEP(v,\n+                                         vec(C_int(0),\n+                                             C_int(abi.box_rc_field_body)));\n+\n+                auto res = drop_ty(cx, body, body_ty);\n                 // FIXME: switch gc/non-gc on stratum of the type.\n                 ret trans_non_gc_free(res.bcx, v);\n             }\n-            ret incr_refcnt(cx, v);\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind hit_zero(_, v, body_ty),\n+                                        \"free box\",\n+                                        T_int(), C_int(0));\n         }\n \n         case (_) {\n@@ -778,7 +796,7 @@ impure fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n                                         C_int(len)));\n             sub.val = sub.bcx.build.IntToPtr(sub.val,\n                                              T_ptr(T_str()));\n-            cx.cleanups += vec(clean(bind trans_drop_str(_, sub.val)));\n+            cx.cleanups += clean(bind trans_drop_str(_, sub.val));\n             ret sub;\n         }\n     }\n@@ -835,13 +853,19 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n             ret sub;\n         }\n         case (ast.box) {\n-            auto e_ty = node_type(cx.fcx.ccx, a);\n-            auto box_ty = T_box(e_ty);\n-            sub.val = cx.build.Malloc(box_ty);\n-            auto rc = sub.bcx.build.GEP(sub.val,\n+            auto e_ty = typeck.expr_ty(e);\n+            auto e_val = sub.val;\n+            sub = trans_malloc(sub.bcx, node_ann_type(sub.bcx.fcx.ccx, a));\n+            auto box = sub.val;\n+            auto rc = sub.bcx.build.GEP(box,\n                                         vec(C_int(0),\n                                             C_int(abi.box_rc_field_refcnt)));\n-            ret res(sub.bcx, cx.build.Store(C_int(1), rc));\n+            auto body = sub.bcx.build.GEP(box,\n+                                          vec(C_int(0),\n+                                              C_int(abi.box_rc_field_body)));\n+            sub.bcx.build.Store(C_int(1), rc);\n+            sub = copy_ty(sub.bcx, true, body, e_val, e_ty);\n+            ret res(sub.bcx, box);\n         }\n         case (_) {\n             cx.fcx.ccx.sess.unimpl(\"expr variant in trans_unary\");"}]}