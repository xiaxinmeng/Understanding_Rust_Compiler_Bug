{"sha": "75935cea7f43c317fc876fe8f914c11ff43d1483", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OTM1Y2VhN2Y0M2MzMTdmYzg3NmZlOGY5MTRjMTFmZjQzZDE0ODM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-25T17:56:30Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:24Z"}, "message": "cargo: capcase types", "tree": {"sha": "3bcc36c67e28c9a4e98ca19cb7302a697a91d37f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bcc36c67e28c9a4e98ca19cb7302a697a91d37f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75935cea7f43c317fc876fe8f914c11ff43d1483", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75935cea7f43c317fc876fe8f914c11ff43d1483", "html_url": "https://github.com/rust-lang/rust/commit/75935cea7f43c317fc876fe8f914c11ff43d1483", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75935cea7f43c317fc876fe8f914c11ff43d1483/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd502fc6e4039e269a78be5d5cfe5b0d8899d30c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd502fc6e4039e269a78be5d5cfe5b0d8899d30c", "html_url": "https://github.com/rust-lang/rust/commit/dd502fc6e4039e269a78be5d5cfe5b0d8899d30c"}], "stats": {"total": 155, "additions": 74, "deletions": 81}, "files": [{"sha": "5a04d2d821c396604cf279b56f822d036caf8845", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 74, "deletions": 81, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/75935cea7f43c317fc876fe8f914c11ff43d1483/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75935cea7f43c317fc876fe8f914c11ff43d1483/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=75935cea7f43c317fc876fe8f914c11ff43d1483", "patch": "@@ -17,7 +17,7 @@ use to_str::to_str;\n use getopts::{optflag, optopt, opt_present};\n use dvec::DVec;\n \n-type package = {\n+struct Package {\n     name: ~str,\n     uuid: ~str,\n     url: ~str,\n@@ -26,10 +26,10 @@ type package = {\n     reference: Option<~str>,\n     tags: ~[~str],\n     versions: ~[(~str, ~str)]\n-};\n+}\n \n-impl package : cmp::Ord {\n-    pure fn lt(other: &package) -> bool {\n+impl Package : cmp::Ord {\n+    pure fn lt(other: &Package) -> bool {\n         if self.name.lt(&(*other).name) { return true; }\n         if (*other).name.lt(&self.name) { return false; }\n         if self.uuid.lt(&(*other).uuid) { return true; }\n@@ -45,65 +45,58 @@ impl package : cmp::Ord {\n         if self.versions.lt(&(*other).versions) { return true; }\n         return false;\n     }\n-    pure fn le(other: &package) -> bool { !(*other).lt(&self) }\n-    pure fn ge(other: &package) -> bool { !self.lt(other)     }\n-    pure fn gt(other: &package) -> bool { (*other).lt(&self)  }\n+    pure fn le(other: &Package) -> bool { !(*other).lt(&self) }\n+    pure fn ge(other: &Package) -> bool { !self.lt(other)     }\n+    pure fn gt(other: &Package) -> bool { (*other).lt(&self)  }\n }\n \n-type local_package = {\n-    name: ~str,\n-    metaname: ~str,\n-    version: ~str,\n-    files: ~[~str]\n-};\n-\n-type source = @{\n+struct Source {\n     name: ~str,\n     mut url: ~str,\n     mut method: ~str,\n     mut key: Option<~str>,\n     mut keyfp: Option<~str>,\n-    packages: DVec<package>\n-};\n+    packages: DVec<Package>\n+}\n \n-type cargo = {\n+struct Cargo {\n     pgp: bool,\n     root: Path,\n     installdir: Path,\n     bindir: Path,\n     libdir: Path,\n     workdir: Path,\n     sourcedir: Path,\n-    sources: map::HashMap<~str, source>,\n+    sources: map::HashMap<~str, @Source>,\n     mut current_install: ~str,\n     dep_cache: map::HashMap<~str, bool>,\n-    opts: options\n-};\n+    opts: Options\n+}\n \n-type crate = {\n+struct Crate {\n     name: ~str,\n     vers: ~str,\n     uuid: ~str,\n     desc: Option<~str>,\n     sigs: Option<~str>,\n     crate_type: Option<~str>,\n     deps: ~[~str]\n-};\n+}\n \n-type options = {\n+struct Options {\n     test: bool,\n-    mode: mode,\n+    mode: Mode,\n     free: ~[~str],\n     help: bool,\n-};\n+}\n \n-enum mode { system_mode, user_mode, local_mode }\n+enum Mode { SystemMode, UserMode, LocalMode }\n \n-impl mode : cmp::Eq {\n-    pure fn eq(other: &mode) -> bool {\n+impl Mode : cmp::Eq {\n+    pure fn eq(other: &Mode) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &mode) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Mode) -> bool { !self.eq(other) }\n }\n \n fn opts() -> ~[getopts::Opt] {\n@@ -270,7 +263,7 @@ fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n     (name, vers, uuid)\n }\n \n-fn load_crate(filename: &Path) -> Option<crate> {\n+fn load_crate(filename: &Path) -> Option<Crate> {\n     let sess = parse::new_parse_sess(None);\n     let c = parse::parse_crate_from_crate_file(filename, ~[], sess);\n \n@@ -375,7 +368,7 @@ fn load_crate(filename: &Path) -> Option<crate> {\n \n     match (name, vers, uuid) {\n         (Some(name0), Some(vers0), Some(uuid0)) => {\n-            Some({\n+            Some(Crate {\n                 name: name0,\n                 vers: vers0,\n                 uuid: uuid0,\n@@ -419,7 +412,7 @@ fn valid_pkg_name(s: ~str) -> bool {\n     s.all(is_valid_digit)\n }\n \n-fn parse_source(name: ~str, j: json::Json) -> source {\n+fn parse_source(name: ~str, j: json::Json) -> @Source {\n     if !valid_pkg_name(name) {\n         fail fmt!(\"'%s' is an invalid source name\", name);\n     }\n@@ -445,7 +438,7 @@ fn parse_source(name: ~str, j: json::Json) -> source {\n             if method == ~\"file\" {\n                 url = os::make_absolute(&Path(url)).to_str();\n             }\n-            return @{\n+            return @Source {\n                 name: name,\n                 mut url: url,\n                 mut method: method,\n@@ -457,7 +450,7 @@ fn parse_source(name: ~str, j: json::Json) -> source {\n     };\n }\n \n-fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, source>) {\n+fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(c.get()) {\n@@ -472,7 +465,7 @@ fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, source>) {\n     }\n }\n \n-fn load_one_source_package(src: source, p: map::HashMap<~str, json::Json>) {\n+fn load_one_source_package(src: @Source, p: map::HashMap<~str, json::Json>) {\n     let name = match p.find(~\"name\") {\n         Some(json::String(n)) => {\n             if !valid_pkg_name(*n) {\n@@ -550,7 +543,7 @@ fn load_one_source_package(src: source, p: map::HashMap<~str, json::Json>) {\n         }\n     };\n \n-    let newpkg = {\n+    let newpkg = Package {\n         name: name,\n         uuid: uuid,\n         url: url,\n@@ -574,7 +567,7 @@ fn load_one_source_package(src: source, p: map::HashMap<~str, json::Json>) {\n     log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n }\n \n-fn load_source_info(c: &cargo, src: source) {\n+fn load_source_info(c: &Cargo, src: @Source) {\n     let dir = c.sourcedir.push(src.name);\n     let srcfile = dir.push(\"source.json\");\n     if !os::path_exists(&srcfile) { return; }\n@@ -595,7 +588,7 @@ fn load_source_info(c: &cargo, src: source) {\n         }\n     };\n }\n-fn load_source_packages(c: &cargo, src: source) {\n+fn load_source_packages(c: &Cargo, src: @Source) {\n     log(debug, ~\"loading source: \" + src.name);\n     let dir = c.sourcedir.push(src.name);\n     let pkgfile = dir.push(\"packages.json\");\n@@ -625,7 +618,7 @@ fn load_source_packages(c: &cargo, src: source) {\n     };\n }\n \n-fn build_cargo_options(argv: ~[~str]) -> options {\n+fn build_cargo_options(argv: ~[~str]) -> Options {\n     let matches = match getopts::getopts(argv, opts()) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n@@ -649,23 +642,23 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n     }\n \n     let mode =\n-        if (!is_install && !is_uninstall) || g { user_mode }\n-        else if G { system_mode }\n-        else { local_mode };\n+        if (!is_install && !is_uninstall) || g { UserMode }\n+        else if G { SystemMode }\n+        else { LocalMode };\n \n-    {test: test, mode: mode, free: matches.free, help: help}\n+    Options {test: test, mode: mode, free: matches.free, help: help}\n }\n \n-fn configure(opts: options) -> cargo {\n+fn configure(opts: Options) -> Cargo {\n     let home = match get_cargo_root() {\n         Ok(home) => home,\n         Err(_err) => get_cargo_sysroot().get()\n     };\n \n     let get_cargo_dir = match opts.mode {\n-        system_mode => get_cargo_sysroot,\n-        user_mode => get_cargo_root,\n-        local_mode => get_cargo_root_nearest\n+        SystemMode => get_cargo_sysroot,\n+        UserMode => get_cargo_root,\n+        LocalMode => get_cargo_root_nearest\n     };\n \n     let p = get_cargo_dir().get();\n@@ -676,7 +669,7 @@ fn configure(opts: options) -> cargo {\n \n     let dep_cache = map::HashMap();\n \n-    let mut c = {\n+    let mut c = Cargo {\n         pgp: pgp::supported(),\n         root: home,\n         installdir: p,\n@@ -714,7 +707,7 @@ fn configure(opts: options) -> cargo {\n     c\n }\n \n-fn for_each_package(c: &cargo, b: fn(source, package)) {\n+fn for_each_package(c: &Cargo, b: fn(s: @Source, p: Package)) {\n     for c.sources.each_value |v| {\n         for v.packages.each |p| {\n             b(v, *p);\n@@ -748,7 +741,7 @@ fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n     Some(buildpath)\n }\n \n-fn test_one_crate(_c: &cargo, path: &Path, cf: &Path) {\n+fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"testing\", path,\n                                            &Path(\"test\"),\n                                            cf,\n@@ -759,7 +752,7 @@ fn test_one_crate(_c: &cargo, path: &Path, cf: &Path) {\n   run_programs(&buildpath);\n }\n \n-fn install_one_crate(c: &cargo, path: &Path, cf: &Path) {\n+fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"installing\", path,\n                                            &Path(\"build\"),\n                                            cf, ~[]) {\n@@ -776,7 +769,7 @@ fn install_one_crate(c: &cargo, path: &Path, cf: &Path) {\n                                ~\"lib\")) {\n             debug!(\"  bin: %s\", ct.to_str());\n             install_to_dir(*ct, &c.bindir);\n-            if c.opts.mode == system_mode {\n+            if c.opts.mode == SystemMode {\n                 // FIXME (#2662): Put this file in PATH / symlink it so it can\n                 // be used as a generic executable\n                 // `cargo install -G rustray` and `rustray file.obj`\n@@ -800,7 +793,7 @@ fn rustc_sysroot() -> ~str {\n     }\n }\n \n-fn install_source(c: &cargo, path: &Path) {\n+fn install_source(c: &Cargo, path: &Path) {\n     debug!(\"source: %s\", path.to_str());\n     os::change_dir(path);\n \n@@ -839,7 +832,7 @@ fn install_source(c: &cargo, path: &Path) {\n     }\n }\n \n-fn install_git(c: &cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n+fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n     if reference.is_some() {\n         let r = reference.get();\n@@ -850,7 +843,7 @@ fn install_git(c: &cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     install_source(c, wd);\n }\n \n-fn install_curl(c: &cargo, wd: &Path, url: ~str) {\n+fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n     let tarpath = wd.push(\"pkg.tar\");\n     let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                          tarpath.to_str(), url]);\n@@ -863,14 +856,14 @@ fn install_curl(c: &cargo, wd: &Path, url: ~str) {\n     install_source(c, wd);\n }\n \n-fn install_file(c: &cargo, wd: &Path, path: &Path) {\n+fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n     run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n                                   ~\"-C\", wd.to_str(),\n                                   ~\"-f\", path.to_str()]);\n     install_source(c, wd);\n }\n \n-fn install_package(c: &cargo, src: ~str, wd: &Path, pkg: package) {\n+fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n     let url = copy pkg.url;\n     let method = match pkg.method {\n         ~\"git\" => ~\"git\",\n@@ -888,7 +881,7 @@ fn install_package(c: &cargo, src: ~str, wd: &Path, pkg: package) {\n     }\n }\n \n-fn cargo_suggestion(c: &cargo, fallback: fn())\n+fn cargo_suggestion(c: &Cargo, fallback: fn())\n {\n     if c.sources.size() == 0u {\n         error(~\"no sources defined - you may wish to run \" +\n@@ -898,7 +891,7 @@ fn cargo_suggestion(c: &cargo, fallback: fn())\n     fallback();\n }\n \n-fn install_uuid(c: &cargo, wd: &Path, uuid: ~str) {\n+fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n@@ -922,7 +915,7 @@ fn install_uuid(c: &cargo, wd: &Path, uuid: ~str) {\n     }\n }\n \n-fn install_named(c: &cargo, wd: &Path, name: ~str) {\n+fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.name == name {\n@@ -946,7 +939,7 @@ fn install_named(c: &cargo, wd: &Path, name: ~str) {\n     }\n }\n \n-fn install_uuid_specific(c: &cargo, wd: &Path, src: ~str, uuid: ~str) {\n+fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -961,7 +954,7 @@ fn install_uuid_specific(c: &cargo, wd: &Path, src: ~str, uuid: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + uuid);\n }\n \n-fn install_named_specific(c: &cargo, wd: &Path, src: ~str, name: ~str) {\n+fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -976,7 +969,7 @@ fn install_named_specific(c: &cargo, wd: &Path, src: ~str, name: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + name);\n }\n \n-fn cmd_uninstall(c: &cargo) {\n+fn cmd_uninstall(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         return;\n@@ -1028,7 +1021,7 @@ fn cmd_uninstall(c: &cargo) {\n     }\n }\n \n-fn install_query(c: &cargo, wd: &Path, target: ~str) {\n+fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n     match c.dep_cache.find(target) {\n         Some(inst) => {\n             if inst {\n@@ -1088,15 +1081,15 @@ fn install_query(c: &cargo, wd: &Path, target: ~str) {\n     }\n }\n \n-fn get_temp_workdir(c: &cargo) -> Path {\n+fn get_temp_workdir(c: &Cargo) -> Path {\n     match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n       Some(wd) => wd,\n       None => fail fmt!(\"needed temp dir: %s\",\n                         c.workdir.to_str())\n     }\n }\n \n-fn cmd_install(c: &cargo) unsafe {\n+fn cmd_install(c: &Cargo) unsafe {\n     let wd = get_temp_workdir(c);\n \n     if vec::len(c.opts.free) == 2u {\n@@ -1120,15 +1113,15 @@ fn cmd_install(c: &cargo) unsafe {\n     install_query(c, &wd, query);\n }\n \n-fn sync(c: &cargo) {\n+fn sync(c: &Cargo) {\n     for c.sources.each_key |k| {\n         let mut s = c.sources.get(k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n     }\n }\n \n-fn sync_one_file(c: &cargo, dir: &Path, src: source) -> bool {\n+fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json.new\");\n     let destsrcfile = dir.push(\"source.json\");\n@@ -1206,7 +1199,7 @@ fn sync_one_file(c: &cargo, dir: &Path, src: source) -> bool {\n     return true;\n }\n \n-fn sync_one_git(c: &cargo, dir: &Path, src: source) -> bool {\n+fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json\");\n     let pkgfile = dir.push(\"packages.json\");\n@@ -1309,7 +1302,7 @@ fn sync_one_git(c: &cargo, dir: &Path, src: source) -> bool {\n     return true;\n }\n \n-fn sync_one_curl(c: &cargo, dir: &Path, src: source) -> bool {\n+fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json.new\");\n     let destsrcfile = dir.push(\"source.json\");\n@@ -1425,7 +1418,7 @@ fn sync_one_curl(c: &cargo, dir: &Path, src: source) -> bool {\n     return true;\n }\n \n-fn sync_one(c: &cargo, src: source) {\n+fn sync_one(c: &Cargo, src: @Source) {\n     let name = src.name;\n     let dir = c.sourcedir.push(name);\n \n@@ -1445,7 +1438,7 @@ fn sync_one(c: &cargo, src: source) {\n     }\n }\n \n-fn cmd_init(c: &cargo) {\n+fn cmd_init(c: &Cargo) {\n     let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n@@ -1484,7 +1477,7 @@ fn cmd_init(c: &cargo) {\n     info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n }\n \n-fn print_pkg(s: source, p: package) {\n+fn print_pkg(s: @Source, p: Package) {\n     let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n     if vec::len(p.tags) > 0u {\n         m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n@@ -1495,7 +1488,7 @@ fn print_pkg(s: source, p: package) {\n     }\n }\n \n-fn print_source(s: source) {\n+fn print_source(s: @Source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n     let pks = sort::merge_sort(sys::shape_lt, s.packages.get());\n@@ -1516,7 +1509,7 @@ fn print_source(s: source) {\n     }));\n }\n \n-fn cmd_list(c: &cargo) {\n+fn cmd_list(c: &Cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n@@ -1542,7 +1535,7 @@ fn cmd_list(c: &cargo) {\n     }\n }\n \n-fn cmd_search(c: &cargo) {\n+fn cmd_search(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         return;\n@@ -1575,7 +1568,7 @@ fn install_to_dir(srcfile: &Path, destdir: &Path) {\n     }\n }\n \n-fn dump_cache(c: &cargo) {\n+fn dump_cache(c: &Cargo) {\n     need_dir(&c.root);\n \n     let out = c.root.push(\"cache.json\");\n@@ -1585,7 +1578,7 @@ fn dump_cache(c: &cargo) {\n         copy_warn(&out, &c.root.push(\"cache.json.old\"));\n     }\n }\n-fn dump_sources(c: &cargo) {\n+fn dump_sources(c: &Cargo) {\n     if c.sources.size() < 1u {\n         return;\n     }\n@@ -1641,7 +1634,7 @@ fn copy_warn(srcfile: &Path, destfile: &Path) {\n     }\n }\n \n-fn cmd_sources(c: &cargo) {\n+fn cmd_sources(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         for c.sources.each_value |v| {\n             info(fmt!(\"%s (%s) via %s\",\n@@ -1677,7 +1670,7 @@ fn cmd_sources(c: &cargo) {\n             if c.sources.contains_key(name) {\n                 error(fmt!(\"source already exists: %s\", name));\n             } else {\n-                c.sources.insert(name, @{\n+                c.sources.insert(name, @Source {\n                     name: name,\n                     mut url: url,\n                     mut method: assume_source_method(url),"}]}