{"sha": "a120caf8b4f8e77168378e6ad2b85d077baaa27b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMjBjYWY4YjRmOGU3NzE2ODM3OGU2YWQyYjg1ZDA3N2JhYWEyN2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-07-19T14:08:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-07-25T14:08:45Z"}, "message": "rustc: Update wasm32 support for LLVM 9\n\nThis commit brings in a number of minor updates for rustc's support for\nthe wasm target which has changed in the LLVM 9 update. Notable updates\ninclude:\n\n* The compiler now no longer manually inserts the `producers` section,\n  instead relying on LLVM to do so. LLVM uses the `llvm.ident` metadata\n  for the `processed-by` directive (which is now emitted on the wasm\n  target in this PR) and it uses debuginfo to figure out what `language`\n  to put in the `producers` section.\n\n* Threaded WebAssembly code now requires different flags to be passed\n  with LLD. In LLD we now pass:\n\n  * `--shared-memory` - required since objects are compiled with\n    atomics. This also means that the generated memory will be marked as\n    `shared`.\n  * `--max-memory=1GB` - required with the `--shared-memory` argument\n    since shared memories in WebAssembly must have a maximum size. The\n    1GB number is intended to be a conservative estimate for rustc, but\n    it should be overridable with `-C link-arg` if necessary.\n  * `--passive-segments` - this has become the default for multithreaded\n    memory, but when compiling a threaded module all data segments need\n    to be marked as passive to ensure they don't re-initialize memory\n    for each thread. This will also cause LLD to emit a synthetic\n    function to initialize memory which users will have to arrange to\n    call.\n  * The `__heap_base` and `__data_end` globals are explicitly exported\n    since they're now hidden by default due to the `--export` flags we\n    pass to LLD.", "tree": {"sha": "7850ed7f09597ca55e460f77da23987e68cc1915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7850ed7f09597ca55e460f77da23987e68cc1915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a120caf8b4f8e77168378e6ad2b85d077baaa27b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a120caf8b4f8e77168378e6ad2b85d077baaa27b", "html_url": "https://github.com/rust-lang/rust/commit/a120caf8b4f8e77168378e6ad2b85d077baaa27b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a120caf8b4f8e77168378e6ad2b85d077baaa27b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c", "html_url": "https://github.com/rust-lang/rust/commit/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c"}], "stats": {"total": 262, "additions": 59, "deletions": 203}, "files": [{"sha": "f0bdb0018efe7f71fc415390eb4c7a6697640edd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=a120caf8b4f8e77168378e6ad2b85d077baaa27b", "patch": "@@ -913,9 +913,12 @@ pub fn compile_unit_metadata(\n     }\n \n     debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n+    let rustc_producer = format!(\n+        \"rustc version {}\",\n+        option_env!(\"CFG_VERSION\").expect(\"CFG_VERSION\"),\n+    );\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n-    let producer = format!(\"clang LLVM (rustc version {})\",\n-                           (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n+    let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n     let name_in_debuginfo = SmallCStr::new(&name_in_debuginfo);\n@@ -980,6 +983,21 @@ pub fn compile_unit_metadata(\n                                               gcov_metadata);\n         }\n \n+        // Insert `llvm.ident` metadata on the wasm32 targets since that will\n+        // get hooked up to the \"producer\" sections `processed-by` information.\n+        if tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+            let name_metadata = llvm::LLVMMDStringInContext(\n+                debug_context.llcontext,\n+                rustc_producer.as_ptr() as *const _,\n+                rustc_producer.as_bytes().len() as c_uint,\n+            );\n+            llvm::LLVMAddNamedMetadataOperand(\n+                debug_context.llmod,\n+                const_cstr!(\"llvm.ident\").as_ptr(),\n+                llvm::LLVMMDNodeInContext(debug_context.llcontext, &name_metadata, 1),\n+            );\n+        }\n+\n         return unit_metadata;\n     };\n "}, {"sha": "3f6a1a72ea61ebb674fe212b29665e2520ab5ec2", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=a120caf8b4f8e77168378e6ad2b85d077baaa27b", "patch": "@@ -678,14 +678,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n         }\n     }\n-\n-    if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n-        super::wasm::add_producer_section(\n-            &out_filename,\n-            &sess.edition().to_string(),\n-            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n-        );\n-    }\n }\n \n /// Returns a boolean indicating whether the specified crate should be ignored"}, {"sha": "94356468fb9d95a5d52b94fa630042ca1ad8fdb7", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=a120caf8b4f8e77168378e6ad2b85d077baaa27b", "patch": "@@ -881,7 +881,38 @@ pub struct WasmLd<'a> {\n }\n \n impl<'a> WasmLd<'a> {\n-    fn new(cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+    fn new(mut cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+        // If the atomics feature is enabled for wasm then we need a whole bunch\n+        // of flags:\n+        //\n+        // * `--shared-memory` - the link won't even succeed without this, flags\n+        //   the one linear memory as `shared`\n+        //\n+        // * `--max-memory=1G` - when specifying a shared memory this must also\n+        //   be specified. We conservatively choose 1GB but users should be able\n+        //   to override this with `-C link-arg`.\n+        //\n+        // * `--import-memory` - it doesn't make much sense for memory to be\n+        //   exported in a threaded module because typically you're\n+        //   sharing memory and instantiating the module multiple times. As a\n+        //   result if it were exported then we'd just have no sharing.\n+        //\n+        // * `--passive-segments` - all memory segments should be passive to\n+        //   prevent each module instantiation from reinitializing memory.\n+        //\n+        // * `--export=__wasm_init_memory` - when using `--passive-segments` the\n+        //   linker will synthesize this function, and so we need to make sure\n+        //   that our usage of `--export` below won't accidentally cause this\n+        //   function to get deleted.\n+        let atomics = sess.opts.cg.target_feature.contains(\"+atomics\") ||\n+            sess.target.target.options.features.contains(\"+atomics\");\n+        if atomics {\n+            cmd.arg(\"--shared-memory\");\n+            cmd.arg(\"--max-memory=1073741824\");\n+            cmd.arg(\"--import-memory\");\n+            cmd.arg(\"--passive-segments\");\n+            cmd.arg(\"--export=__wasm_init_memory\");\n+        }\n         WasmLd { cmd, sess, info }\n     }\n }\n@@ -984,6 +1015,13 @@ impl<'a> Linker for WasmLd<'a> {\n         for sym in self.info.exports[&crate_type].iter() {\n             self.cmd.arg(\"--export\").arg(&sym);\n         }\n+\n+        // LLD will hide these otherwise-internal symbols since our `--export`\n+        // list above is a whitelist of what to export. Various bits and pieces\n+        // of tooling use this, so be sure these symbols make their way out of\n+        // the linker as well.\n+        self.cmd.arg(\"--export=__heap_base\");\n+        self.cmd.arg(\"--export=__data_end\");\n     }\n \n     fn subsystem(&mut self, _subsystem: &str) {"}, {"sha": "901891d85a465f397b921c2332a59fe218e53260", "filename": "src/librustc_codegen_ssa/back/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs?ref=a120caf8b4f8e77168378e6ad2b85d077baaa27b", "patch": "@@ -6,4 +6,3 @@ pub mod command;\n pub mod symbol_export;\n pub mod archive;\n pub mod rpath;\n-pub mod wasm;"}, {"sha": "2a9e81a788e52fad48c3d9a107283cffd17240b6", "filename": "src/librustc_codegen_ssa/back/wasm.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs?ref=eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c", "patch": "@@ -1,191 +0,0 @@\n-use std::fs;\n-use std::path::Path;\n-use std::str;\n-\n-use rustc_serialize::leb128;\n-\n-// https://webassembly.github.io/spec/core/binary/modules.html#binary-importsec\n-const WASM_CUSTOM_SECTION_ID: u8 = 0;\n-\n-/// Adds or augment the existing `producers` section to encode information about\n-/// the Rust compiler used to produce the wasm file.\n-pub fn add_producer_section(\n-    path: &Path,\n-    rust_version: &str,\n-    rustc_version: &str,\n-) {\n-    struct Field<'a> {\n-        name: &'a str,\n-        values: Vec<FieldValue<'a>>,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    struct FieldValue<'a> {\n-        name: &'a str,\n-        version: &'a str,\n-    }\n-\n-    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n-    let mut ret = WasmEncoder::new();\n-    ret.data.extend(&wasm[..8]);\n-\n-    // skip the 8 byte wasm/version header\n-    let rustc_value = FieldValue {\n-        name: \"rustc\",\n-        version: rustc_version,\n-    };\n-    let rust_value = FieldValue {\n-        name: \"Rust\",\n-        version: rust_version,\n-    };\n-    let mut fields = Vec::new();\n-    let mut wrote_rustc = false;\n-    let mut wrote_rust = false;\n-\n-    // Move all sections from the original wasm file to our output, skipping\n-    // everything except the producers section\n-    for (id, raw) in WasmSections(WasmDecoder::new(&wasm[8..])) {\n-        if id != WASM_CUSTOM_SECTION_ID {\n-            ret.byte(id);\n-            ret.bytes(raw);\n-            continue\n-        }\n-        let mut decoder = WasmDecoder::new(raw);\n-        if decoder.str() != \"producers\" {\n-            ret.byte(id);\n-            ret.bytes(raw);\n-            continue\n-        }\n-\n-        // Read off the producers section into our fields outside the loop,\n-        // we'll re-encode the producers section when we're done (to handle an\n-        // entirely missing producers section as well).\n-        info!(\"rewriting existing producers section\");\n-\n-        for _ in 0..decoder.u32() {\n-            let name = decoder.str();\n-            let mut values = Vec::new();\n-            for _ in 0..decoder.u32() {\n-                let name = decoder.str();\n-                let version = decoder.str();\n-                values.push(FieldValue { name, version });\n-            }\n-\n-            if name == \"language\" {\n-                values.push(rust_value);\n-                wrote_rust = true;\n-            } else if name == \"processed-by\" {\n-                values.push(rustc_value);\n-                wrote_rustc = true;\n-            }\n-            fields.push(Field { name, values });\n-        }\n-    }\n-\n-    if !wrote_rust {\n-        fields.push(Field {\n-            name: \"language\",\n-            values: vec![rust_value],\n-        });\n-    }\n-    if !wrote_rustc {\n-        fields.push(Field {\n-            name: \"processed-by\",\n-            values: vec![rustc_value],\n-        });\n-    }\n-\n-    // Append the producers section to the end of the wasm file.\n-    let mut section = WasmEncoder::new();\n-    section.str(\"producers\");\n-    section.u32(fields.len() as u32);\n-    for field in fields {\n-        section.str(field.name);\n-        section.u32(field.values.len() as u32);\n-        for value in field.values {\n-            section.str(value.name);\n-            section.str(value.version);\n-        }\n-    }\n-    ret.byte(WASM_CUSTOM_SECTION_ID);\n-    ret.bytes(&section.data);\n-\n-    fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n-}\n-\n-struct WasmSections<'a>(WasmDecoder<'a>);\n-\n-impl<'a> Iterator for WasmSections<'a> {\n-    type Item = (u8, &'a [u8]);\n-\n-    fn next(&mut self) -> Option<(u8, &'a [u8])> {\n-        if self.0.data.is_empty() {\n-            return None\n-        }\n-\n-        // see https://webassembly.github.io/spec/core/binary/modules.html#sections\n-        let id = self.0.byte();\n-        let section_len = self.0.u32();\n-        info!(\"new section {} / {} bytes\", id, section_len);\n-        let section = self.0.skip(section_len as usize);\n-        Some((id, section))\n-    }\n-}\n-\n-struct WasmDecoder<'a> {\n-    data: &'a [u8],\n-}\n-\n-impl<'a> WasmDecoder<'a> {\n-    fn new(data: &'a [u8]) -> WasmDecoder<'a> {\n-        WasmDecoder { data }\n-    }\n-\n-    fn byte(&mut self) -> u8 {\n-        self.skip(1)[0]\n-    }\n-\n-    fn u32(&mut self) -> u32 {\n-        let (n, l1) = leb128::read_u32_leb128(self.data);\n-        self.data = &self.data[l1..];\n-        return n\n-    }\n-\n-    fn skip(&mut self, amt: usize) -> &'a [u8] {\n-        let (data, rest) = self.data.split_at(amt);\n-        self.data = rest;\n-        data\n-    }\n-\n-    fn str(&mut self) -> &'a str {\n-        let len = self.u32();\n-        str::from_utf8(self.skip(len as usize)).unwrap()\n-    }\n-}\n-\n-struct WasmEncoder {\n-    data: Vec<u8>,\n-}\n-\n-impl WasmEncoder {\n-    fn new() -> WasmEncoder {\n-        WasmEncoder { data: Vec::new() }\n-    }\n-\n-    fn u32(&mut self, val: u32) {\n-        leb128::write_u32_leb128(&mut self.data, val);\n-    }\n-\n-    fn byte(&mut self, val: u8) {\n-        self.data.push(val);\n-    }\n-\n-    fn bytes(&mut self, val: &[u8]) {\n-        self.u32(val.len() as u32);\n-        self.data.extend_from_slice(val);\n-    }\n-\n-    fn str(&mut self, val: &str) {\n-        self.bytes(val.as_bytes())\n-    }\n-}"}]}