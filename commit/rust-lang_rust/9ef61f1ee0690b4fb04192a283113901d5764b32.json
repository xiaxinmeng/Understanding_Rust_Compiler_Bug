{"sha": "9ef61f1ee0690b4fb04192a283113901d5764b32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZjYxZjFlZTA2OTBiNGZiMDQxOTJhMjgzMTEzOTAxZDU3NjRiMzI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-05T12:38:49Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-28T14:12:27Z"}, "message": "Prep for dropflag hints: refactor `trans:_match` to pass around `MatchInput` rather than `ValueRef`.\n\n(already thumbs-upped pre-rebase by nikomatsakis)\n\nThe refactoring here is trivial because `trans::datum::Lvalue`\ncurrently carries no payload. However, future commits will start\nadding a payload to `Lvalue`, and thus will force us either\n\n 1. to thread the payload through the `_match` code (a long term goal), or\n\n 2. to ensure the payload has some reasonable default value.", "tree": {"sha": "96be9bb7dd605a6be88dfa5c80025f1f39dadf9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96be9bb7dd605a6be88dfa5c80025f1f39dadf9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ef61f1ee0690b4fb04192a283113901d5764b32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef61f1ee0690b4fb04192a283113901d5764b32", "html_url": "https://github.com/rust-lang/rust/commit/9ef61f1ee0690b4fb04192a283113901d5764b32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ef61f1ee0690b4fb04192a283113901d5764b32/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "html_url": "https://github.com/rust-lang/rust/commit/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44"}], "stats": {"total": 174, "additions": 118, "deletions": 56}, "files": [{"sha": "c1fb6f2437f70d1fb9efa9fbb0d1cae7d5dd0389", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 115, "deletions": 53, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/9ef61f1ee0690b4fb04192a283113901d5764b32/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef61f1ee0690b4fb04192a283113901d5764b32/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9ef61f1ee0690b4fb04192a283113901d5764b32", "patch": "@@ -417,16 +417,45 @@ fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     return false;\n }\n \n+// As noted in `fn match_datum`, we should eventually pass around a\n+// `Datum<Lvalue>` for the `val`; but until we get to that point, this\n+// `MatchInput` struct will serve -- it has everything `Datum<Lvalue>`\n+// does except for the type field.\n+#[derive(Copy, Clone)]\n+pub struct MatchInput { val: ValueRef, lval: Lvalue }\n+\n+impl<'tcx> Datum<'tcx, Lvalue> {\n+    pub fn match_input(&self) -> MatchInput {\n+        MatchInput {\n+            val: self.val,\n+            lval: self.kind,\n+        }\n+    }\n+}\n+\n+impl MatchInput {\n+    fn from_val(val: ValueRef) -> MatchInput {\n+        MatchInput {\n+            val: val,\n+            lval: Lvalue,\n+        }\n+    }\n+\n+    fn to_datum<'tcx>(self, ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n+        Datum::new(self.val, ty, self.lval)\n+    }\n+}\n+\n fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                               col: usize,\n-                                              val: ValueRef)\n+                                              val: MatchInput)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     m.iter().map(|br| {\n@@ -435,7 +464,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         loop {\n             pat = match pat.node {\n                 ast::PatIdent(_, ref path, Some(ref inner)) => {\n-                    bound_ptrs.push((path.node, val));\n+                    bound_ptrs.push((path.node, val.val));\n                     &**inner\n                 },\n                 _ => break\n@@ -457,7 +486,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           dm: &DefMap,\n                                           m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                           col: usize,\n-                                          val: ValueRef,\n+                                          val: MatchInput,\n                                           mut e: F)\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n     F: FnMut(&[&'p ast::Pat]) -> Option<Vec<&'p ast::Pat>>,\n@@ -466,7 +495,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n            bcx.to_str(),\n            m,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n@@ -476,7 +505,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             match this.node {\n                 ast::PatIdent(_, ref path, None) => {\n                     if pat_is_binding(dm, &*this) {\n-                        bound_ptrs.push((path.node, val));\n+                        bound_ptrs.push((path.node, val.val));\n                     }\n                 }\n                 ast::PatVec(ref before, Some(ref slice), ref after) => {\n@@ -503,13 +532,13 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      dm: &DefMap,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                      col: usize,\n-                                     val: ValueRef)\n+                                     val: MatchInput)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n@@ -560,14 +589,14 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              opt: &Opt,\n              col: usize,\n              variant_size: usize,\n-             val: ValueRef)\n+             val: MatchInput)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m,\n            *opt,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     let ctor = match opt {\n@@ -663,25 +692,25 @@ struct ExtractedBlock<'blk, 'tcx: 'blk> {\n fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     repr: &adt::Repr<'tcx>,\n                                     disr_val: ty::Disr,\n-                                    val: ValueRef)\n+                                    val: MatchInput)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n     let args = (0..adt::num_args(repr, disr_val)).map(|i| {\n-        adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n+        adt::trans_field_ptr(bcx, repr, val.val, disr_val, i)\n     }).collect();\n \n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n /// Helper for converting from the ValueRef that we pass around in the match code, which is always\n /// an lvalue, into a Datum. Eventually we should just pass around a Datum and be done with it.\n-fn match_datum<'tcx>(val: ValueRef, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n-    Datum::new(val, left_ty, Lvalue)\n+fn match_datum<'tcx>(val: MatchInput, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n+    val.to_datum(left_ty)\n }\n \n fn bind_subslice_pat(bcx: Block,\n                      pat_id: ast::NodeId,\n-                     val: ValueRef,\n+                     val: MatchInput,\n                      offset_left: usize,\n                      offset_right: usize) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n@@ -711,7 +740,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  left_ty: Ty<'tcx>,\n                                  before: usize,\n                                  after: usize,\n-                                 val: ValueRef)\n+                                 val: MatchInput)\n                                  -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(val, left_ty);\n@@ -952,15 +981,15 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      guard_expr: &ast::Expr,\n                                      data: &ArmData<'p, 'blk, 'tcx>,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                     vals: &[ValueRef],\n+                                     vals: &[MatchInput],\n                                      chk: &FailureHandler,\n                                      has_genuine_default: bool)\n                                      -> Block<'blk, 'tcx> {\n     debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n            guard_expr,\n            m,\n-           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().join(\", \"));\n+           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n     let _indenter = indenter();\n \n     let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n@@ -999,13 +1028,13 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                        vals: &[ValueRef],\n+                                        vals: &[MatchInput],\n                                         chk: &FailureHandler,\n                                         has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n            m,\n-           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().join(\", \"));\n+           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n@@ -1065,10 +1094,10 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                                 vals: &[ValueRef],\n+                                                 vals: &[MatchInput],\n                                                  chk: &FailureHandler,\n                                                  col: usize,\n-                                                 val: ValueRef,\n+                                                 val: MatchInput,\n                                                  has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n@@ -1098,13 +1127,13 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n         let arg_count = adt::num_args(&*repr, 0);\n         let (arg_count, struct_val) = if type_is_sized(bcx.tcx(), left_ty) {\n-            (arg_count, val)\n+            (arg_count, val.val)\n         } else {\n             // For an unsized ADT (i.e. DST struct), we need to treat\n             // the last field specially: instead of simply passing a\n             // ValueRef pointing to that field, as with all the others,\n             // we skip it and instead construct a 'fat ptr' below.\n-            (arg_count - 1, Load(bcx, expr::get_dataptr(bcx, val)))\n+            (arg_count - 1, Load(bcx, expr::get_dataptr(bcx, val.val)))\n         };\n         let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n             adt::trans_field_ptr(bcx, &*repr, struct_val, 0, ix)\n@@ -1123,7 +1152,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n                 let scratch = alloca_no_lifetime(bcx, llty, \"__struct_field_fat_ptr\");\n                 let data = adt::trans_field_ptr(bcx, &*repr, struct_val, 0, arg_count);\n-                let len = Load(bcx, expr::get_len(bcx, val));\n+                let len = Load(bcx, expr::get_len(bcx, val.val));\n                 Store(bcx, data, expr::get_dataptr(bcx, scratch));\n                 Store(bcx, len, expr::get_len(bcx, scratch));\n                 field_vals.push(scratch);\n@@ -1132,7 +1161,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         Some(field_vals)\n     } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n-        Some(vec!(Load(bcx, val)))\n+        Some(vec!(Load(bcx, val.val)))\n     } else {\n         match left_ty.sty {\n             ty::TyArray(_, n) => {\n@@ -1149,7 +1178,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         &check_match::Single, col,\n                                         field_vals.len())\n             );\n-            let mut vals = field_vals;\n+            let mut vals: Vec<_> = field_vals.into_iter()\n+                .map(|v|MatchInput::from_val(v))\n+                .collect();\n             vals.push_all(&vals_left);\n             compile_submatch(bcx, &pats, &vals, chk, has_genuine_default);\n             return;\n@@ -1161,25 +1192,25 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let opts = get_branches(bcx, m, col);\n     debug!(\"options={:?}\", opts);\n     let mut kind = NoBranch;\n-    let mut test_val = val;\n+    let mut test_val = val.val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if !opts.is_empty() {\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n-                test_val = load_if_immediate(bcx, val, left_ty);\n+                test_val = load_if_immediate(bcx, val.val, left_ty);\n                 kind = if left_ty.is_integral() {\n                     Switch\n                 } else {\n                     Compare\n                 };\n             }\n             Variant(_, ref repr, _, _) => {\n-                let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n+                let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val.val);\n                 kind = the_kind;\n                 if let Some(tval) = val_opt { test_val = tval; }\n             }\n             SliceLengthEqual(..) | SliceLengthGreaterOrEqual(..) => {\n-                let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n+                let (_, len) = tvec::get_base_and_len(bcx, val.val, left_ty);\n                 test_val = len;\n                 kind = Switch;\n             }\n@@ -1303,7 +1334,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ConstantValue(..) | ConstantRange(..) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n-        let mut opt_vals = unpacked;\n+        let mut opt_vals: Vec<_> = unpacked.into_iter()\n+            .map(|v|MatchInput::from_val(v))\n+            .collect();\n         opt_vals.push_all(&vals_left[..]);\n         compile_submatch(opt_cx,\n                          &opt_ms[..],\n@@ -1547,7 +1580,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, &matches[..], &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, &matches[..], &[discr_datum.match_input()], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in &arm_datas {\n@@ -1622,7 +1655,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 add_comment(bcx, \"creating zeroable ref llval\");\n             }\n             let var_scope = cleanup::var_scope(tcx, local.id);\n-            bind_irrefutable_pat(bcx, pat, init_datum.val, var_scope)\n+            bind_irrefutable_pat(bcx, pat, init_datum.match_input(), var_scope)\n         }\n         None => {\n             create_dummy_locals(bcx, pat)\n@@ -1671,7 +1704,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n /// - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     pat: &ast::Pat,\n-                                    val: ValueRef,\n+                                    val: MatchInput,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n     debug!(\"bind_irrefutable_pat(bcx={}, pat={:?})\",\n@@ -1702,18 +1735,18 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n-                                let d = Datum::new(val, ty, Lvalue);\n+                                let d = val.to_datum(ty);\n                                 d.store_to(bcx, llval)\n                             }\n \n                             ast::BindByRef(_) => {\n                                 // By ref binding: the value of the variable\n                                 // is the pointer `val` itself or fat pointer referenced by `val`\n                                 if type_is_fat_ptr(bcx.tcx(), ty) {\n-                                    expr::copy_fat_ptr(bcx, val, llval);\n+                                    expr::copy_fat_ptr(bcx, val.val, llval);\n                                 }\n                                 else {\n-                                    Store(bcx, val, llval);\n+                                    Store(bcx, val.val, llval);\n                                 }\n \n                                 bcx\n@@ -1738,8 +1771,11 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     val);\n                     if let Some(ref sub_pat) = *sub_pats {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, &*sub_pat[i],\n-                                                       argval, cleanup_scope);\n+                            bcx = bind_irrefutable_pat(\n+                                bcx,\n+                                &*sub_pat[i],\n+                                MatchInput::from_val(argval),\n+                                cleanup_scope);\n                         }\n                     }\n                 }\n@@ -1753,9 +1789,12 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n-                                                                  val, 0, i);\n-                                bcx = bind_irrefutable_pat(bcx, &**elem,\n-                                                           fldptr, cleanup_scope);\n+                                                                  val.val, 0, i);\n+                                bcx = bind_irrefutable_pat(\n+                                    bcx,\n+                                    &**elem,\n+                                    MatchInput::from_val(fldptr),\n+                                    cleanup_scope);\n                             }\n                         }\n                     }\n@@ -1772,26 +1811,45 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n                 for f in fields {\n                     let ix = tcx.field_idx_strict(f.node.ident.name, field_tys);\n-                    let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n-                                                      discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx, &*f.node.pat, fldptr, cleanup_scope);\n+                    let fldptr = adt::trans_field_ptr(\n+                        bcx,\n+                        &*pat_repr,\n+                        val.val,\n+                        discr,\n+                        ix);\n+                    bcx = bind_irrefutable_pat(bcx,\n+                                               &*f.node.pat,\n+                                               MatchInput::from_val(fldptr),\n+                                               cleanup_scope);\n                 }\n             })\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr, cleanup_scope);\n+                let fldptr = adt::trans_field_ptr(bcx, &*repr, val.val, 0, i);\n+                bcx = bind_irrefutable_pat(\n+                    bcx,\n+                    &**elem,\n+                    MatchInput::from_val(fldptr),\n+                    cleanup_scope);\n             }\n         }\n         ast::PatBox(ref inner) => {\n-            let llbox = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, cleanup_scope);\n+            let llbox = Load(bcx, val.val);\n+            bcx = bind_irrefutable_pat(\n+                bcx,\n+                &**inner,\n+                MatchInput::from_val(llbox),\n+                cleanup_scope);\n         }\n         ast::PatRegion(ref inner, _) => {\n-            let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, cleanup_scope);\n+            let loaded_val = Load(bcx, val.val);\n+            bcx = bind_irrefutable_pat(\n+                bcx,\n+                &**inner,\n+                MatchInput::from_val(loaded_val),\n+                cleanup_scope);\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n@@ -1811,7 +1869,11 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .chain(after.iter())\n                 .zip(extracted.vals)\n                 .fold(bcx, |bcx, (inner, elem)|\n-                    bind_irrefutable_pat(bcx, &**inner, elem, cleanup_scope)\n+                    bind_irrefutable_pat(\n+                        bcx,\n+                        &**inner,\n+                        MatchInput::from_val(elem),\n+                        cleanup_scope)\n                 );\n         }\n         ast::PatMac(..) => {"}, {"sha": "1e016ea1fdcf3da4e5e250611d6632b435ac08ef", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ef61f1ee0690b4fb04192a283113901d5764b32/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef61f1ee0690b4fb04192a283113901d5764b32/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9ef61f1ee0690b4fb04192a283113901d5764b32", "patch": "@@ -1335,9 +1335,9 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                 let llarg = get_param(fcx.llfn, idx);\n                 idx += 1;\n                 bcx.fcx.schedule_lifetime_end(arg_scope_id, llarg);\n-                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty);\n+                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n \n-                datum::Datum::new(llarg, arg_ty, datum::Lvalue)\n+                datum::Datum::new(llarg, arg_ty, datum::Lvalue::new(\"create_datum_for_fn_args\"))\n             } else if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 let data = get_param(fcx.llfn, idx);\n                 let extra = get_param(fcx.llfn, idx + 1);\n@@ -1408,7 +1408,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n         } else {\n             // General path. Copy out the values that are used in the\n             // pattern.\n-            _match::bind_irrefutable_pat(bcx, pat, arg_datum.val, arg_scope_id)\n+            _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n         };\n         debuginfo::create_argument_metadata(bcx, &args[i]);\n     }"}]}