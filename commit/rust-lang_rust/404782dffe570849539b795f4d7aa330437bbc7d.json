{"sha": "404782dffe570849539b795f4d7aa330437bbc7d", "node_id": "C_kwDOAAsO6NoAKDQwNDc4MmRmZmU1NzA4NDk1MzliNzk1ZjRkN2FhMzMwNDM3YmJjN2Q", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-05T16:24:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-05T16:24:36Z"}, "message": "Rollup merge of #100166 - GuillaumeGomez:rm-clean-impls, r=Dylan-DPC\n\nRemove more Clean trait implementations\n\nFollow-up of https://github.com/rust-lang/rust/pull/99638.\n\nr? `@notriddle`", "tree": {"sha": "6ab6c3de35fe6b086577e1cb6298787647171969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ab6c3de35fe6b086577e1cb6298787647171969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/404782dffe570849539b795f4d7aa330437bbc7d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi7URECRBK7hj4Ov3rIwAApAwIAI0jQIA4rmpYBub34k/xg8Gn\nkFenW499MY5ljRVUZmwiE2oDAuWxq+3lfnLj2I01Z+NPXsn7uFRH6Vwr3jAwMLmc\nNO5oO7Si4ONB8pAOzGzlACBOMmokggZbNsmbM5hC+QfRKycpgkmv3pP/KZMSn55c\n27DTViE0tqzbqqTLArfZUAXXbnDTWS+mMU7OMgH4vZqaRKM51g39WmOP9Pil5WG2\nE2KO4GrAkBjcIRjD7fsu36hC+LICPigHIxJRXiZ9qZbqf78JEOTIz4nu84JhIFLA\nbFrDTGIiEwLyh11+ED1oeXIT8xH6rK683fRGehBDcDX7bkgx3Tib6UBN4HB86iM=\n=MaZd\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ab6c3de35fe6b086577e1cb6298787647171969\nparent 823ef905ed0ff6be4c3e2ee11c365187c24021c3\nparent 46d17d6aaa6a4d3dfd4683927ac07245eb9e512c\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1659716676 +0530\ncommitter GitHub <noreply@github.com> 1659716676 +0530\n\nRollup merge of #100166 - GuillaumeGomez:rm-clean-impls, r=Dylan-DPC\n\nRemove more Clean trait implementations\n\nFollow-up of https://github.com/rust-lang/rust/pull/99638.\n\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/404782dffe570849539b795f4d7aa330437bbc7d", "html_url": "https://github.com/rust-lang/rust/commit/404782dffe570849539b795f4d7aa330437bbc7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/404782dffe570849539b795f4d7aa330437bbc7d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "823ef905ed0ff6be4c3e2ee11c365187c24021c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/823ef905ed0ff6be4c3e2ee11c365187c24021c3", "html_url": "https://github.com/rust-lang/rust/commit/823ef905ed0ff6be4c3e2ee11c365187c24021c3"}, {"sha": "46d17d6aaa6a4d3dfd4683927ac07245eb9e512c", "url": "https://api.github.com/repos/rust-lang/rust/commits/46d17d6aaa6a4d3dfd4683927ac07245eb9e512c", "html_url": "https://github.com/rust-lang/rust/commit/46d17d6aaa6a4d3dfd4683927ac07245eb9e512c"}], "stats": {"total": 129, "additions": 65, "deletions": 64}, "files": [{"sha": "2368a1f1c7ebfeb8e10512101480b3e2998d20db", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/404782dffe570849539b795f4d7aa330437bbc7d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404782dffe570849539b795f4d7aa330437bbc7d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=404782dffe570849539b795f4d7aa330437bbc7d", "patch": "@@ -156,7 +156,7 @@ impl<'tcx> Clean<'tcx, Option<GenericBound>> for hir::GenericBound<'tcx> {\n                     return None;\n                 }\n \n-                GenericBound::TraitBound(t.clean(cx), modifier)\n+                GenericBound::TraitBound(clean_poly_trait_ref(t, cx), modifier)\n             }\n         })\n     }\n@@ -1001,69 +1001,68 @@ fn clean_trait_ref<'tcx>(trait_ref: &hir::TraitRef<'tcx>, cx: &mut DocContext<'t\n     path\n }\n \n-impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> PolyTrait {\n-        PolyTrait {\n-            trait_: clean_trait_ref(&self.trait_ref, cx),\n-            generic_params: self\n-                .bound_generic_params\n-                .iter()\n-                .filter(|p| !is_elided_lifetime(p))\n-                .map(|x| clean_generic_param(cx, None, x))\n-                .collect(),\n-        }\n+fn clean_poly_trait_ref<'tcx>(\n+    poly_trait_ref: &hir::PolyTraitRef<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> PolyTrait {\n+    PolyTrait {\n+        trait_: clean_trait_ref(&poly_trait_ref.trait_ref, cx),\n+        generic_params: poly_trait_ref\n+            .bound_generic_params\n+            .iter()\n+            .filter(|p| !is_elided_lifetime(p))\n+            .map(|x| clean_generic_param(cx, None, x))\n+            .collect(),\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let local_did = self.def_id.to_def_id();\n-        cx.with_param_env(local_did, |cx| {\n-            let inner = match self.kind {\n-                hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n-                    clean_ty(ty, cx),\n-                    ConstantKind::Local { def_id: local_did, body: default },\n-                ),\n-                hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(clean_ty(ty, cx)),\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    let m = clean_function(cx, sig, self.generics, body);\n-                    MethodItem(m, None)\n-                }\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n-                    let (generics, decl) = enter_impl_trait(cx, |cx| {\n-                        // NOTE: generics must be cleaned before args\n-                        let generics = self.generics.clean(cx);\n-                        let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n-                        let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n-                        (generics, decl)\n-                    });\n-                    TyMethodItem(Box::new(Function { decl, generics }))\n-                }\n-                hir::TraitItemKind::Type(bounds, Some(default)) => {\n-                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n-                    let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n-                    AssocTypeItem(\n-                        Box::new(Typedef {\n-                            type_: clean_ty(default, cx),\n-                            generics,\n-                            item_type: Some(item_type),\n-                        }),\n-                        bounds,\n-                    )\n-                }\n-                hir::TraitItemKind::Type(bounds, None) => {\n-                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n-                    let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    TyAssocTypeItem(Box::new(generics), bounds)\n-                }\n-            };\n-            let what_rustc_thinks =\n-                Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n-            // Trait items always inherit the trait's visibility -- we don't want to show `pub`.\n-            Item { visibility: Inherited, ..what_rustc_thinks }\n-        })\n-    }\n+fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n+    let local_did = trait_item.def_id.to_def_id();\n+    cx.with_param_env(local_did, |cx| {\n+        let inner = match trait_item.kind {\n+            hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n+                clean_ty(ty, cx),\n+                ConstantKind::Local { def_id: local_did, body: default },\n+            ),\n+            hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(clean_ty(ty, cx)),\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n+                let m = clean_function(cx, sig, trait_item.generics, body);\n+                MethodItem(m, None)\n+            }\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n+                let (generics, decl) = enter_impl_trait(cx, |cx| {\n+                    // NOTE: generics must be cleaned before args\n+                    let generics = trait_item.generics.clean(cx);\n+                    let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n+                    let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n+                    (generics, decl)\n+                });\n+                TyMethodItem(Box::new(Function { decl, generics }))\n+            }\n+            hir::TraitItemKind::Type(bounds, Some(default)) => {\n+                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n+                let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n+                AssocTypeItem(\n+                    Box::new(Typedef {\n+                        type_: clean_ty(default, cx),\n+                        generics,\n+                        item_type: Some(item_type),\n+                    }),\n+                    bounds,\n+                )\n+            }\n+            hir::TraitItemKind::Type(bounds, None) => {\n+                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n+                TyAssocTypeItem(Box::new(generics), bounds)\n+            }\n+        };\n+        let what_rustc_thinks =\n+            Item::from_def_id_and_parts(local_did, Some(trait_item.ident.name), inner, cx);\n+        // Trait items always inherit the trait's visibility -- we don't want to show `pub`.\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n+    })\n }\n \n impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n@@ -1515,7 +1514,7 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n         }\n         TyKind::Path(_) => clean_qpath(ty, cx),\n         TyKind::TraitObject(bounds, ref lifetime, _) => {\n-            let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n+            let bounds = bounds.iter().map(|bound| clean_poly_trait_ref(bound, cx)).collect();\n             let lifetime =\n                 if !lifetime.is_elided() { Some(clean_lifetime(*lifetime, cx)) } else { None };\n             DynTrait(bounds, lifetime)\n@@ -1953,8 +1952,10 @@ fn clean_maybe_renamed_item<'tcx>(\n                 })\n             }\n             ItemKind::Trait(_, _, generics, bounds, item_ids) => {\n-                let items =\n-                    item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n+                let items = item_ids\n+                    .iter()\n+                    .map(|ti| clean_trait_item(cx.tcx.hir().trait_item(ti.id), cx))\n+                    .collect();\n \n                 TraitItem(Trait {\n                     def_id,"}]}