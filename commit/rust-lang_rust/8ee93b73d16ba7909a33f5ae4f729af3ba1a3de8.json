{"sha": "8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZTkzYjczZDE2YmE3OTA5YTMzZjVhZTRmNzI5YWYzYmExYTNkZTg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-20T23:35:56Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-21T23:01:01Z"}, "message": "Re-fold expanded items in `expand_mac_invoc`", "tree": {"sha": "45f6c99cff349fa996d19c1e254e880a0bb9f41e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45f6c99cff349fa996d19c1e254e880a0bb9f41e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8", "html_url": "https://github.com/rust-lang/rust/commit/8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e7afd73676f95ad3b944788c4798ad538a5edd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7afd73676f95ad3b944788c4798ad538a5edd2", "html_url": "https://github.com/rust-lang/rust/commit/2e7afd73676f95ad3b944788c4798ad538a5edd2"}], "stats": {"total": 76, "additions": 13, "deletions": 63}, "files": [{"sha": "8833b901ec7301d2a645d1a1884d3837edbab20a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 63, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8ee93b73d16ba7909a33f5ae4f729af3ba1a3de8", "patch": "@@ -93,18 +93,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             // Assert that we drop any macro attributes on the floor here\n             drop(attrs);\n \n-            let expanded_expr = match expand_mac_invoc(mac, span, fld) {\n-                Some(expr) => expr,\n-                None => {\n-                    return DummyResult::raw_expr(span);\n-                }\n-            };\n-\n-            // Keep going, outside-in.\n-            let fully_expanded = fld.fold_expr(expanded_expr);\n-            fld.cx.bt_pop();\n-\n-            fully_expanded\n+            expand_mac_invoc(mac, span, fld)\n         }\n \n         ast::ExprKind::InPlace(placer, value_expr) => {\n@@ -215,8 +204,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n }\n \n /// Expand a (not-ident-style) macro invocation. Returns the result of expansion.\n-fn expand_mac_invoc<T: MacroGenerable>(mac: ast::Mac, span: Span, fld: &mut MacroExpander)\n-                                       -> Option<T> {\n+fn expand_mac_invoc<T: MacroGenerable>(mac: ast::Mac, span: Span, fld: &mut MacroExpander) -> T {\n     // it would almost certainly be cleaner to pass the whole\n     // macro invocation in, rather than pulling it apart and\n     // marking the tts and the ctxt separately. This also goes\n@@ -229,7 +217,7 @@ fn expand_mac_invoc<T: MacroGenerable>(mac: ast::Mac, span: Span, fld: &mut Macr\n                         \"expected macro name without module \\\n                         separators\");\n         // let compilation continue\n-        return None;\n+        return T::dummy(span);\n     }\n     let extname = pth.segments[0].identifier.name;\n     match fld.cx.syntax_env.find(extname) {\n@@ -242,7 +230,7 @@ fn expand_mac_invoc<T: MacroGenerable>(mac: ast::Mac, span: Span, fld: &mut Macr\n             err.emit();\n \n             // let compilation continue\n-            None\n+            T::dummy(span)\n         }\n         Some(rc) => match *rc {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n@@ -275,17 +263,20 @@ fn expand_mac_invoc<T: MacroGenerable>(mac: ast::Mac, span: Span, fld: &mut Macr\n                         let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n                                           name = extname, kind = T::kind_name());\n                         fld.cx.span_err(pth.span, &msg);\n-                        return None;\n+                        return T::dummy(span);\n                     }\n                 };\n-                Some(parsed.fold_with(&mut Marker { mark: fm }))\n+                let marked = parsed.fold_with(&mut Marker { mark: fm });\n+                let fully_expanded = marked.fold_with(fld);\n+                fld.cx.bt_pop();\n+                fully_expanded\n             }\n             _ => {\n                 fld.cx.span_err(\n                     pth.span,\n                     &format!(\"'{}' is not a tt-style macro\",\n                             extname));\n-                None\n+                T::dummy(span)\n             }\n         }\n     }\n@@ -543,21 +534,9 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     // Assert that we drop any macro attributes on the floor here\n     drop(attrs);\n \n-    let maybe_new_items: Option<SmallVector<ast::Stmt>> =\n+    let mut fully_expanded: SmallVector<ast::Stmt> =\n         expand_mac_invoc(mac.unwrap(), stmt.span, fld);\n \n-    let mut fully_expanded = match maybe_new_items {\n-        Some(stmts) => {\n-            // Keep going, outside-in.\n-            let new_items = stmts.into_iter().flat_map(|s| {\n-                fld.fold_stmt(s).into_iter()\n-            }).collect();\n-            fld.cx.bt_pop();\n-            new_items\n-        }\n-        None => SmallVector::zero()\n-    };\n-\n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n@@ -1096,21 +1075,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n         }),\n         ast::ImplItemKind::Macro(mac) => {\n             check_attributes(&ii.attrs, fld);\n-\n-            let maybe_new_items: Option<SmallVector<ast::ImplItem>> =\n-                expand_mac_invoc(mac, ii.span, fld);\n-\n-            match maybe_new_items {\n-                Some(impl_items) => {\n-                    // expand again if necessary\n-                    let new_items = impl_items.into_iter().flat_map(|ii| {\n-                        expand_impl_item(ii, fld).into_iter()\n-                    }).collect();\n-                    fld.cx.bt_pop();\n-                    new_items\n-                }\n-                None => SmallVector::zero()\n-            }\n+            expand_mac_invoc(mac, ii.span, fld)\n         }\n         _ => fold::noop_fold_impl_item(ii, fld)\n     }\n@@ -1154,22 +1119,7 @@ pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n             if fld.cx.ecfg.features.unwrap().type_macros {\n-                let expanded_ty = match expand_mac_invoc(mac, t.span, fld) {\n-                    Some(ty) => ty,\n-                    None => {\n-                        return DummyResult::raw_ty(t.span);\n-                    }\n-                };\n-\n-                // Keep going, outside-in.\n-                let fully_expanded = fld.fold_ty(expanded_ty);\n-                fld.cx.bt_pop();\n-\n-                fully_expanded.map(|t| ast::Ty {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: t.node,\n-                    span: t.span,\n-                    })\n+                expand_mac_invoc(mac, t.span, fld)\n             } else {\n                 feature_gate::emit_feature_err(\n                     &fld.cx.parse_sess.span_diagnostic,"}]}