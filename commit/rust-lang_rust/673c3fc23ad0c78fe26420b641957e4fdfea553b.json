{"sha": "673c3fc23ad0c78fe26420b641957e4fdfea553b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3M2MzZmMyM2FkMGM3OGZlMjY0MjBiNjQxOTU3ZTRmZGZlYTU1M2I=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-12T08:43:15Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-19T18:16:08Z"}, "message": "rustc: disallow cloning HIR nodes.", "tree": {"sha": "b31611fff1cfcca26ccf8ff3a64227280f20ef18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b31611fff1cfcca26ccf8ff3a64227280f20ef18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/673c3fc23ad0c78fe26420b641957e4fdfea553b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/673c3fc23ad0c78fe26420b641957e4fdfea553b", "html_url": "https://github.com/rust-lang/rust/commit/673c3fc23ad0c78fe26420b641957e4fdfea553b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/673c3fc23ad0c78fe26420b641957e4fdfea553b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "887feeeaf7d40c25caa9532f2d9121cb79fca899", "url": "https://api.github.com/repos/rust-lang/rust/commits/887feeeaf7d40c25caa9532f2d9121cb79fca899", "html_url": "https://github.com/rust-lang/rust/commit/887feeeaf7d40c25caa9532f2d9121cb79fca899"}], "stats": {"total": 950, "additions": 476, "deletions": 474}, "files": [{"sha": "c87ab6869372693e2353680df8b3c030d9a6c407", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -608,15 +608,7 @@ impl<'a> LoweringContext<'a> {\n                 });\n \n                 if let Some(hir_id) = item_hir_id {\n-                    let item_generics = match self.lctx.items.get(&hir_id).unwrap().node {\n-                        hir::ItemKind::Impl(_, _, _, ref generics, ..)\n-                        | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-                            generics.params.clone()\n-                        }\n-                        _ => HirVec::new(),\n-                    };\n-\n-                    self.lctx.with_parent_impl_lifetime_defs(&item_generics, |this| {\n+                    self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                         let this = &mut ItemLowerer { lctx: this };\n                         if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n                             this.with_trait_impl_ref(opt_trait_ref, |this| {\n@@ -1054,14 +1046,22 @@ impl<'a> LoweringContext<'a> {\n     // This should only be used with generics that have already had their\n     // in-band lifetimes added. In practice, this means that this function is\n     // only used when lowering a child item of a trait or impl.\n-    fn with_parent_impl_lifetime_defs<T, F>(&mut self,\n-        params: &HirVec<hir::GenericParam>,\n+    fn with_parent_item_lifetime_defs<T, F>(&mut self,\n+        parent_hir_id: hir::HirId,\n         f: F\n     ) -> T where\n         F: FnOnce(&mut LoweringContext<'_>) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n-        let lt_def_names = params.iter().filter_map(|param| match param.kind {\n+\n+        let parent_generics = match self.items.get(&parent_hir_id).unwrap().node {\n+            hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+                &generics.params[..]\n+            }\n+            _ => &[],\n+        };\n+        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n             _ => None,\n         });\n@@ -1113,8 +1113,7 @@ impl<'a> LoweringContext<'a> {\n \n         lowered_generics.params = lowered_generics\n             .params\n-            .iter()\n-            .cloned()\n+            .into_iter()\n             .chain(in_band_defs)\n             .collect();\n \n@@ -3114,8 +3113,8 @@ impl<'a> LoweringContext<'a> {\n             &NodeMap::default(),\n             itctx.reborrow(),\n         );\n-        let trait_ref = self.with_parent_impl_lifetime_defs(\n-            &bound_generic_params,\n+        let trait_ref = self.with_in_scope_lifetime_defs(\n+            &p.bound_generic_params,\n             |this| this.lower_trait_ref(&p.trait_ref, itctx),\n         );\n \n@@ -3602,8 +3601,7 @@ impl<'a> LoweringContext<'a> {\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n                 for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n-                    let vis = vis.clone();\n-                    let ident = ident.clone();\n+                    let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n                         seg.id = self.sess.next_node_id();\n@@ -3616,19 +3614,7 @@ impl<'a> LoweringContext<'a> {\n                         let path =\n                             this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n-                        let vis_kind = match vis.node {\n-                            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n-                            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-                            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n-                                let path = this.renumber_segment_ids(path);\n-                                hir::VisibilityKind::Restricted {\n-                                    path,\n-                                    hir_id: this.next_id(),\n-                                }\n-                            }\n-                        };\n-                        let vis = respan(vis.span, vis_kind);\n+                        let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(\n                             hir::Item {\n@@ -3692,8 +3678,6 @@ impl<'a> LoweringContext<'a> {\n                 for &(ref use_tree, id) in trees {\n                     let new_hir_id = self.lower_node_id(id);\n \n-                    let mut vis = vis.clone();\n-                    let mut ident = ident.clone();\n                     let mut prefix = prefix.clone();\n \n                     // Give the segments new node-ids since they are being cloned.\n@@ -3707,27 +3691,16 @@ impl<'a> LoweringContext<'a> {\n                     // own its own names, we have to adjust the owner before\n                     // lowering the rest of the import.\n                     self.with_hir_id_owner(id, |this| {\n+                        let mut vis = this.rebuild_vis(&vis);\n+                        let mut ident = *ident;\n+\n                         let item = this.lower_use_tree(use_tree,\n                                                        &prefix,\n                                                        id,\n                                                        &mut vis,\n                                                        &mut ident,\n                                                        attrs);\n \n-                        let vis_kind = match vis.node {\n-                            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n-                            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-                            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n-                                let path = this.renumber_segment_ids(path);\n-                                hir::VisibilityKind::Restricted {\n-                                    path: path,\n-                                    hir_id: this.next_id(),\n-                                }\n-                            }\n-                        };\n-                        let vis = respan(vis.span, vis_kind);\n-\n                         this.insert_item(\n                             hir::Item {\n                                 hir_id: new_hir_id,\n@@ -3773,15 +3746,35 @@ impl<'a> LoweringContext<'a> {\n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n     /// `NodeId`s. (See, e.g., #56128.)\n-    fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n-        debug!(\"renumber_segment_ids(path = {:?})\", path);\n-        let mut path = path.clone();\n-        for seg in path.segments.iter_mut() {\n-            if seg.hir_id.is_some() {\n-                seg.hir_id = Some(self.next_id());\n-            }\n+    fn rebuild_use_path(&mut self, path: &hir::Path) -> hir::Path {\n+        debug!(\"rebuild_use_path(path = {:?})\", path);\n+        let segments = path.segments.iter().map(|seg| hir::PathSegment {\n+            ident: seg.ident,\n+            hir_id: seg.hir_id.map(|_| self.next_id()),\n+            res: seg.res,\n+            args: None,\n+            infer_args: seg.infer_args,\n+        }).collect();\n+        hir::Path {\n+            span: path.span,\n+            res: path.res,\n+            segments,\n         }\n-        path\n+    }\n+\n+    fn rebuild_vis(&mut self, vis: &hir::Visibility) -> hir::Visibility {\n+        let vis_kind = match vis.node {\n+            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n+            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n+                hir::VisibilityKind::Restricted {\n+                    path: P(self.rebuild_use_path(path)),\n+                    hir_id: self.next_id(),\n+                }\n+            }\n+        };\n+        respan(vis.span, vis_kind)\n     }\n \n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {"}, {"sha": "87da3273bd220b93fff33c5af9aacc09330689a6", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -51,11 +51,11 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn fn_decl(&self) -> Option<&FnDecl> {\n+    fn fn_decl(&self) -> Option<&'hir FnDecl> {\n         match self.node {\n             Node::Item(ref item) => {\n                 match item.node {\n-                    ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n+                    ItemKind::Fn(ref fn_decl, _, _, _) => Some(fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -76,7 +76,7 @@ impl<'hir> Entry<'hir> {\n \n             Node::Expr(ref expr) => {\n                 match expr.node {\n-                    ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n+                    ExprKind::Closure(_, ref fn_decl, ..) => Some(fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -412,9 +412,9 @@ impl<'hir> Map<'hir> {\n         self.forest.krate.body(id)\n     }\n \n-    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n+    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl> {\n         if let Some(entry) = self.find_entry(hir_id) {\n-            entry.fn_decl().cloned()\n+            entry.fn_decl()\n         } else {\n             bug!(\"no entry for hir_id `{}`\", hir_id)\n         }"}, {"sha": "2b46170a6d2322cc3e1313aff79b3e5d36c4c4b1", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -155,7 +155,7 @@ pub const DUMMY_HIR_ID: HirId = HirId {\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -295,7 +295,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Path {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -324,7 +324,7 @@ impl fmt::Display for Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n@@ -393,13 +393,13 @@ impl PathSegment {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Ty),\n@@ -431,7 +431,7 @@ impl GenericArg {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericArgs {\n     /// The generic arguments for this path segment.\n     pub args: HirVec<GenericArg>,\n@@ -505,7 +505,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -541,7 +541,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -556,7 +556,7 @@ pub enum GenericParamKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericParam {\n     pub hir_id: HirId,\n     pub name: ParamName,\n@@ -576,15 +576,15 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Generics {\n     pub params: HirVec<GenericParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n \n impl Generics {\n-    pub fn empty() -> Generics {\n+    pub const fn empty() -> Generics {\n         Generics {\n             params: HirVec::new(),\n             where_clause: WhereClause {\n@@ -638,7 +638,7 @@ pub enum SyntheticTyParamKind {\n }\n \n /// A where-clause in a definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereClause {\n     pub predicates: HirVec<WherePredicate>,\n     // Only valid if predicates isn't empty.\n@@ -656,7 +656,7 @@ impl WhereClause {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n@@ -677,7 +677,7 @@ impl WherePredicate {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -689,23 +689,23 @@ pub struct WhereBoundPredicate {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereEqPredicate {\n     pub hir_id: HirId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n     pub rhs_ty: P<Ty>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n@@ -720,7 +720,7 @@ pub struct ModuleItems {\n /// For more details, see the [rustc guide].\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: HirVec<Attribute>,\n@@ -815,7 +815,7 @@ impl Crate {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MacroDef {\n     pub name: Name,\n     pub vis: Visibility,\n@@ -829,7 +829,7 @@ pub struct MacroDef {\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Block {\n     /// Statements in a block.\n     pub stmts: HirVec<Stmt>,\n@@ -847,7 +847,7 @@ pub struct Block {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Pat {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -910,7 +910,7 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FieldPat {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -925,7 +925,7 @@ pub struct FieldPat {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BindingAnnotation {\n     /// No binding annotation given: this means that the final binding mode\n     /// will depend on whether we have skipped through a `&` reference\n@@ -952,7 +952,7 @@ pub enum RangeEnd {\n     Excluded,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -997,8 +997,8 @@ pub enum PatKind {\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n@@ -1014,7 +1014,7 @@ impl Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1148,7 +1148,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1177,7 +1177,7 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n     pub hir_id: HirId,\n     pub node: StmtKind,\n@@ -1192,7 +1192,7 @@ impl fmt::Debug for Stmt {\n }\n \n /// The contents of a statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum StmtKind {\n     /// A local (`let`) binding.\n     Local(P<Local>),\n@@ -1219,7 +1219,7 @@ impl StmtKind {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Local {\n     pub pat: P<Pat>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n@@ -1236,7 +1236,7 @@ pub struct Local {\n \n /// Represents a single arm of a `match` expression, e.g.\n /// `<pats> (if <guard>) => <body>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arm {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1250,12 +1250,12 @@ pub struct Arm {\n     pub body: P<Expr>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Guard {\n     If(P<Expr>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Field {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1265,15 +1265,15 @@ pub struct Field {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1305,7 +1305,7 @@ pub struct BodyId {\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,\n     pub value: Expr,\n@@ -1379,7 +1379,7 @@ pub struct AnonConst {\n }\n \n /// An expression\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Expr {\n     pub span: Span,\n     pub node: ExprKind,\n@@ -1490,7 +1490,7 @@ impl fmt::Debug for Expr {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1598,7 +1598,7 @@ pub enum ExprKind {\n }\n \n /// Represents an optionally `Self`-qualified value/type path or associated extension.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1618,7 +1618,7 @@ pub enum QPath {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1640,7 +1640,7 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1664,7 +1664,7 @@ pub enum MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -1674,7 +1674,7 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1692,7 +1692,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n@@ -1703,8 +1703,8 @@ pub struct Destination {\n }\n \n /// Whether a generator contains self-references, causing it to be `!Unpin`.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GeneratorMovability {\n     /// May contain self-references, `!Unpin`.\n     Static,\n@@ -1713,7 +1713,7 @@ pub enum GeneratorMovability {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await,\n@@ -1730,22 +1730,22 @@ impl fmt::Display for YieldSource {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum CaptureClause {\n     CaptureByValue,\n     CaptureByRef,\n }\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a method's signature in a trait declaration or implementation.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MethodSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n@@ -1763,7 +1763,7 @@ pub struct TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItem {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1774,7 +1774,7 @@ pub struct TraitItem {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n     Required(HirVec<Ident>),\n@@ -1784,7 +1784,7 @@ pub enum TraitMethod {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(P<Ty>, Option<BodyId>),\n@@ -1804,7 +1804,7 @@ pub struct ImplItemId {\n }\n \n /// Represents anything within an `impl` block\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItem {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1817,7 +1817,7 @@ pub struct ImplItem {\n }\n \n /// Represents various kinds of content within an `impl`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression\n@@ -1844,7 +1844,7 @@ pub enum ImplItemKind {\n ///    Binding(...),\n /// }\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TypeBinding {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n@@ -1854,7 +1854,7 @@ pub struct TypeBinding {\n }\n \n // Represents the two kinds of type bindings.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TypeBindingKind {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint {\n@@ -1875,7 +1875,7 @@ impl TypeBinding {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub hir_id: HirId,\n     pub node: TyKind,\n@@ -1890,7 +1890,7 @@ impl fmt::Debug for Ty {\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum PrimTy {\n     Int(IntTy),\n     Uint(UintTy),\n@@ -1900,7 +1900,7 @@ pub enum PrimTy {\n     Char,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -1909,7 +1909,7 @@ pub struct BareFnTy {\n     pub arg_names: HirVec<Ident>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n@@ -1929,7 +1929,7 @@ pub enum ExistTyOrigin {\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TyKind {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(P<Ty>),\n@@ -1971,7 +1971,7 @@ pub enum TyKind {\n     CVarArgs(Lifetime),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n@@ -1994,14 +1994,14 @@ pub struct InlineAsm {\n }\n \n /// Represents an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n     /// The types of the function's arguments.\n     ///\n@@ -2014,7 +2014,7 @@ pub struct FnDecl {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2119,7 +2119,7 @@ impl fmt::Debug for ImplPolarity {\n }\n \n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n     ///\n@@ -2149,7 +2149,7 @@ impl FunctionRetTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2158,25 +2158,25 @@ pub struct Mod {\n     pub item_ids: HirVec<ItemId>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub items: HirVec<ForeignItem>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n     #[stable_hasher(ignore)] // This is used for error reporting\n     pub ctxt: SyntaxContext,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct EnumDef {\n     pub variants: HirVec<Variant>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct VariantKind {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n@@ -2215,7 +2215,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: Path,\n     // Don't hash the ref_id. It is tracked via the thing it is used to access\n@@ -2237,7 +2237,7 @@ impl TraitRef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: HirVec<GenericParam>,\n@@ -2250,7 +2250,7 @@ pub struct PolyTraitRef {\n \n pub type Visibility = Spanned<VisibilityKind>;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n@@ -2285,7 +2285,7 @@ impl VisibilityKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct StructField {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n@@ -2305,7 +2305,7 @@ impl StructField {\n }\n \n /// Fields and constructor IDs of enum variants and structs.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n     /// A struct variant.\n     ///\n@@ -2350,7 +2350,7 @@ pub struct ItemId {\n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Item {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -2360,7 +2360,7 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -2377,7 +2377,7 @@ impl FnHeader {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2480,7 +2480,7 @@ impl ItemKind {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     #[stable_hasher(project(name))]\n@@ -2496,7 +2496,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n@@ -2515,7 +2515,7 @@ pub enum AssocItemKind {\n     Existential,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignItem {\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2527,7 +2527,7 @@ pub struct ForeignItem {\n }\n \n /// An item within an `extern` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ForeignItemKind {\n     /// A foreign function.\n     Fn(P<FnDecl>, HirVec<Ident>, Generics),"}, {"sha": "8b1984e04f55b596ad2d73207683aae84690f92b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -625,10 +625,10 @@ impl<'a> State<'a> {\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n-                        real_bounds.push(b.clone());\n+                        real_bounds.push(b);\n                     }\n                 }\n-                self.print_bounds(\":\", &real_bounds[..])?;\n+                self.print_bounds(\":\", real_bounds)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n@@ -698,10 +698,10 @@ impl<'a> State<'a> {\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n-                        real_bounds.push(b.clone());\n+                        real_bounds.push(b);\n                     }\n                 }\n-                self.print_bounds(\":\", &real_bounds[..])?;\n+                self.print_bounds(\":\", real_bounds)?;\n                 self.print_where_clause(&generics.where_clause)?;\n                 self.s.word(\" \")?;\n                 self.bopen()?;\n@@ -724,11 +724,11 @@ impl<'a> State<'a> {\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n-                        real_bounds.push(b.clone());\n+                        real_bounds.push(b);\n                     }\n                 }\n                 self.nbsp()?;\n-                self.print_bounds(\"=\", &real_bounds[..])?;\n+                self.print_bounds(\"=\", real_bounds)?;\n                 self.print_where_clause(&generics.where_clause)?;\n                 self.s.word(\";\")?;\n             }\n@@ -1998,31 +1998,34 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_bounds(&mut self, prefix: &'static str, bounds: &[hir::GenericBound])\n-                        -> io::Result<()> {\n-        if !bounds.is_empty() {\n-            self.s.word(prefix)?;\n-            let mut first = true;\n-            for bound in bounds {\n-                if !(first && prefix.is_empty()) {\n-                    self.nbsp()?;\n-                }\n-                if first {\n-                    first = false;\n-                } else {\n-                    self.word_space(\"+\")?;\n-                }\n+    pub fn print_bounds<'b>(\n+        &mut self,\n+        prefix: &'static str,\n+        bounds: impl IntoIterator<Item = &'b hir::GenericBound>,\n+    ) -> io::Result<()> {\n+        let mut first = true;\n+        for bound in bounds {\n+            if first {\n+                self.s.word(prefix)?;\n+            }\n+            if !(first && prefix.is_empty()) {\n+                self.nbsp()?;\n+            }\n+            if first {\n+                first = false;\n+            } else {\n+                self.word_space(\"+\")?;\n+            }\n \n-                match bound {\n-                    GenericBound::Trait(tref, modifier) => {\n-                        if modifier == &TraitBoundModifier::Maybe {\n-                            self.s.word(\"?\")?;\n-                        }\n-                        self.print_poly_trait_ref(tref)?;\n-                    }\n-                    GenericBound::Outlives(lt) => {\n-                        self.print_lifetime(lt)?;\n+            match bound {\n+                GenericBound::Trait(tref, modifier) => {\n+                    if modifier == &TraitBoundModifier::Maybe {\n+                        self.s.word(\"?\")?;\n                     }\n+                    self.print_poly_trait_ref(tref)?;\n+                }\n+                GenericBound::Outlives(lt) => {\n+                    self.print_lifetime(lt)?;\n                 }\n             }\n         }"}, {"sha": "2555833cd77e3099305b27a7ee84915604c4f431", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -1050,10 +1050,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n-                            node: hir::PatKind::Tuple(args, _),\n+                            node: hir::PatKind::Tuple(ref args, _),\n                             span,\n                             ..\n-                        } = arg.pat.clone().into_inner() {\n+                        } = *arg.pat {\n                             ArgKind::Tuple(\n                                 Some(span),\n                                 args.iter().map(|pat| {"}, {"sha": "dfaad95fa3cb9cf691dd7af9beb8bcad7326f237", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -1815,8 +1815,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // as the HIR doesn't have full types for closure arguments.\n                 let return_ty = *sig.output().skip_binder();\n                 let mut return_span = fn_decl.output.span();\n-                if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n-                    if let hir::TyKind::Rptr(lifetime, _) = ty.into_inner().node {\n+                if let hir::FunctionRetTy::Return(ty) = &fn_decl.output {\n+                    if let hir::TyKind::Rptr(lifetime, _) = ty.node {\n                         return_span = lifetime.span;\n                     }\n                 }"}, {"sha": "267f3798bd1e3d619b9e359a21f7f0c386efd7d1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -97,15 +97,15 @@ pub enum SizedByDefault {\n     No,\n }\n \n-struct ConvertedBinding<'tcx> {\n+struct ConvertedBinding<'a, 'tcx> {\n     item_name: ast::Ident,\n-    kind: ConvertedBindingKind<'tcx>,\n+    kind: ConvertedBindingKind<'a, 'tcx>,\n     span: Span,\n }\n \n-enum ConvertedBindingKind<'tcx> {\n+enum ConvertedBindingKind<'a, 'tcx> {\n     Equality(Ty<'tcx>),\n-    Constraint(P<[hir::GenericBound]>),\n+    Constraint(&'a [hir::GenericBound]),\n }\n \n #[derive(PartialEq)]\n@@ -596,7 +596,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>)\n-        -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n+        -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>)\n     {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -738,7 +738,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     hir::TypeBindingKind::Equality { ref ty } =>\n                         ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty)),\n                     hir::TypeBindingKind::Constraint { ref bounds } =>\n-                        ConvertedBindingKind::Constraint(bounds.clone()),\n+                        ConvertedBindingKind::Constraint(bounds),\n                 };\n                 ConvertedBinding {\n                     item_name: binding.ident,\n@@ -859,13 +859,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    fn create_substs_for_ast_trait_ref(\n+    fn create_substs_for_ast_trait_ref<'a>(\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        trait_segment: &hir::PathSegment,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>) {\n+        trait_segment: &'a hir::PathSegment,\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n@@ -912,7 +912,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for ab in ast_bounds {\n             if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab {\n                 if unbound.is_none() {\n-                    unbound = Some(ptr.trait_ref.clone());\n+                    unbound = Some(&ptr.trait_ref);\n                 } else {\n                     span_err!(\n                         tcx.sess,\n@@ -927,7 +927,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n         match unbound {\n-            Some(ref tpb) => {\n+            Some(tpb) => {\n                 // FIXME(#8559) currently requires the unbound to be built-in.\n                 if let Ok(kind_id) = kind_id {\n                     if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n@@ -1048,7 +1048,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         hir_ref_id: hir::HirId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-        binding: &ConvertedBinding<'tcx>,\n+        binding: &ConvertedBinding<'_, 'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n         dup_bindings: &mut FxHashMap<DefId, Span>,\n@@ -1165,7 +1165,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }), binding.span));\n             }\n-            ConvertedBindingKind::Constraint(ref ast_bounds) => {\n+            ConvertedBindingKind::Constraint(ast_bounds) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n                 //\n                 // `<T as Iterator>::Item: Debug`"}, {"sha": "0e83db48284a80e5ac3d24aff4c528d3653922c2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -3696,39 +3696,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(hir::FnDecl, ast::Ident)> {\n+    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, ast::Ident)> {\n         let parent = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_item(blk_id));\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_node_fn_decl(&self, node: Node<'_>) -> Option<(hir::FnDecl, ast::Ident, bool)> {\n+    fn get_node_fn_decl(&self, node: Node<'tcx>) -> Option<(&'tcx hir::FnDecl, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item {\n                 ident, node: hir::ItemKind::Fn(ref decl, ..), ..\n-            }) => decl.clone().and_then(|decl| {\n+            }) => {\n                 // This is less than ideal, it will not suggest a return type span on any\n                 // method called `main`, regardless of whether it is actually the entry point,\n                 // but it will still present it as the reason for the expected type.\n                 Some((decl, ident, ident.name != sym::main))\n-            }),\n+            }\n             Node::TraitItem(&hir::TraitItem {\n                 ident, node: hir::TraitItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n-            }) => decl.clone().and_then(|decl| Some((decl, ident, true))),\n+            }) => Some((decl, ident, true)),\n             Node::ImplItem(&hir::ImplItem {\n                 ident, node: hir::ImplItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n-            }) => decl.clone().and_then(|decl| Some((decl, ident, false))),\n+            }) => Some((decl, ident, false)),\n             _ => None,\n         }\n     }\n \n     /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n     /// suggestion can be made, `None` otherwise.\n-    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(hir::FnDecl, bool)> {\n+    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {"}, {"sha": "52cda4ac3c6285ecb84f60adb600e050730da87a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -165,7 +165,7 @@ impl ItemCtxt<'tcx> {\n         ItemCtxt { tcx, item_def_id }\n     }\n \n-    pub fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty(&self, ast_ty: &'tcx hir::Ty) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n@@ -338,7 +338,7 @@ impl ItemCtxt<'tcx> {\n     /// bounds for a type parameter `X` if `X::Foo` is used.\n     fn type_parameter_bounds_in_generics(\n         &self,\n-        ast_generics: &hir::Generics,\n+        ast_generics: &'tcx hir::Generics,\n         param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n@@ -1909,7 +1909,9 @@ fn explicit_predicates_of<'tcx>(\n     let mut is_default_impl_trait = None;\n \n     let icx = ItemCtxt::new(tcx, def_id);\n-    let no_generics = hir::Generics::empty();\n+\n+    const NO_GENERICS: &hir::Generics = &hir::Generics::empty();\n+\n     let empty_trait_items = HirVec::new();\n \n     let mut predicates = UniquePredicates::new();\n@@ -1991,17 +1993,17 @@ fn explicit_predicates_of<'tcx>(\n                     }\n                 }\n \n-                _ => &no_generics,\n+                _ => NO_GENERICS,\n             }\n         }\n \n         Node::ForeignItem(item) => match item.node {\n-            ForeignItemKind::Static(..) => &no_generics,\n+            ForeignItemKind::Static(..) => NO_GENERICS,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n-            ForeignItemKind::Type => &no_generics,\n+            ForeignItemKind::Type => NO_GENERICS,\n         },\n \n-        _ => &no_generics,\n+        _ => NO_GENERICS,\n     };\n \n     let generics = tcx.generics_of(def_id);\n@@ -2205,7 +2207,7 @@ fn explicit_predicates_of<'tcx>(\n fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx>,\n     param_ty: Ty<'tcx>,\n-    bound: &hir::GenericBound,\n+    bound: &'tcx hir::GenericBound,\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n@@ -2227,7 +2229,7 @@ fn predicates_from_bound<'tcx>(\n fn compute_sig_of_foreign_fn_decl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    decl: &hir::FnDecl,\n+    decl: &'tcx hir::FnDecl,\n     abi: abi::Abi,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {"}, {"sha": "b489ccf179c0e274ffa8c12f7f0cd88fb8383751", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n-        let mut module = self.module.clean(cx);\n+        let mut module = self.module.as_ref().unwrap().clean(cx);\n         let mut masked_crates = FxHashSet::default();\n \n         match module.inner {\n@@ -600,7 +600,7 @@ pub struct Module {\n     pub is_crate: bool,\n }\n \n-impl Clean<Item> for doctree::Module {\n+impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = if self.name.is_some() {\n             self.name.expect(\"No name provided\").clean(cx)\n@@ -620,7 +620,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.unions.iter().map(|x| x.clean(cx)));\n         items.extend(self.enums.iter().map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n-        items.extend(self.foreigns.iter().flat_map(|x| x.clean(cx)));\n+        items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.typedefs.iter().map(|x| x.clean(cx)));\n         items.extend(self.existentials.iter().map(|x| x.clean(cx)));\n@@ -1920,10 +1920,10 @@ pub struct Function {\n     pub ret_types: Vec<Type>,\n }\n \n-impl Clean<Item> for doctree::Function {\n+impl Clean<Item> for doctree::Function<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let (generics, decl) = enter_impl_trait(cx, || {\n-            (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n+            (self.generics.clean(cx), (self.decl, self.body).clean(cx))\n         });\n \n         let did = cx.tcx.hir().local_def_id_from_hir_id(self.id);\n@@ -2128,7 +2128,7 @@ pub struct Trait {\n     pub is_auto: bool,\n }\n \n-impl Clean<Item> for doctree::Trait {\n+impl Clean<Item> for doctree::Trait<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n@@ -2143,7 +2143,7 @@ impl Clean<Item> for doctree::Trait {\n             inner: TraitItem(Trait {\n                 auto: self.is_auto.clean(cx),\n                 unsafety: self.unsafety,\n-                items: self.items.clean(cx),\n+                items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n                 is_spotlight,\n@@ -2159,7 +2159,7 @@ pub struct TraitAlias {\n     pub bounds: Vec<GenericBound>,\n }\n \n-impl Clean<Item> for doctree::TraitAlias {\n+impl Clean<Item> for doctree::TraitAlias<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         Item {\n@@ -2853,11 +2853,11 @@ impl Clean<Type> for hir::Ty {\n                                             _ => None,\n                                         }\n                                     });\n-                                    if let Some(ty) = type_.cloned() {\n+                                    if let Some(ty) = type_ {\n                                         ty_substs.insert(ty_param_def_id, ty.clean(cx));\n                                     } else if let Some(default) = default.clone() {\n                                         ty_substs.insert(ty_param_def_id,\n-                                                         default.into_inner().clean(cx));\n+                                                         default.clean(cx));\n                                     }\n                                     indices.types += 1;\n                                 }\n@@ -2877,7 +2877,7 @@ impl Clean<Type> for hir::Ty {\n                                             _ => None,\n                                         }\n                                     });\n-                                    if let Some(ct) = const_.cloned() {\n+                                    if let Some(ct) = const_ {\n                                         ct_substs.insert(const_param_def_id, ct.clean(cx));\n                                     }\n                                     // FIXME(const_generics:defaults)\n@@ -2891,20 +2891,20 @@ impl Clean<Type> for hir::Ty {\n                 resolve_type(cx, path.clean(cx), self.hir_id)\n             }\n             TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n-                let mut segments: Vec<_> = p.segments.clone().into();\n-                segments.pop();\n-                let trait_path = hir::Path {\n-                    span: p.span,\n+                let segments = if p.is_global() { &p.segments[1..] } else { &p.segments };\n+                let trait_segments = &segments[..segments.len() - 1];\n+                let trait_path = self::Path {\n+                    global: p.is_global(),\n                     res: Res::Def(\n                         DefKind::Trait,\n                         cx.tcx.associated_item(p.res.def_id()).container.id(),\n                     ),\n-                    segments: segments.into(),\n+                    segments: trait_segments.clean(cx),\n                 };\n                 Type::QPath {\n                     name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path.clean(cx), self.hir_id)\n+                    trait_: box resolve_type(cx, trait_path, self.hir_id)\n                 }\n             }\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n@@ -3235,7 +3235,7 @@ pub struct Union {\n     pub fields_stripped: bool,\n }\n \n-impl Clean<Item> for doctree::Struct {\n+impl Clean<Item> for doctree::Struct<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3255,7 +3255,7 @@ impl Clean<Item> for doctree::Struct {\n     }\n }\n \n-impl Clean<Item> for doctree::Union {\n+impl Clean<Item> for doctree::Union<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3302,7 +3302,7 @@ pub struct Enum {\n     pub variants_stripped: bool,\n }\n \n-impl Clean<Item> for doctree::Enum {\n+impl Clean<Item> for doctree::Enum<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3326,7 +3326,7 @@ pub struct Variant {\n     pub kind: VariantKind,\n }\n \n-impl Clean<Item> for doctree::Variant {\n+impl Clean<Item> for doctree::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3631,7 +3631,7 @@ pub struct Typedef {\n     pub generics: Generics,\n }\n \n-impl Clean<Item> for doctree::Typedef {\n+impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3655,7 +3655,7 @@ pub struct Existential {\n     pub generics: Generics,\n }\n \n-impl Clean<Item> for doctree::Existential {\n+impl Clean<Item> for doctree::Existential<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3705,7 +3705,7 @@ pub struct Static {\n     pub expr: String,\n }\n \n-impl Clean<Item> for doctree::Static {\n+impl Clean<Item> for doctree::Static<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n@@ -3731,7 +3731,7 @@ pub struct Constant {\n     pub expr: String,\n }\n \n-impl Clean<Item> for doctree::Constant {\n+impl Clean<Item> for doctree::Constant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3801,11 +3801,11 @@ pub fn get_auto_trait_and_blanket_impls(\n         .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n }\n \n-impl Clean<Vec<Item>> for doctree::Impl {\n+impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n         let trait_ = self.trait_.clean(cx);\n-        let items = self.items.clean(cx);\n+        let items = self.items.iter().map(|ii| ii.clean(cx)).collect::<Vec<_>>();\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n@@ -3902,7 +3902,7 @@ fn build_deref_target_impls(cx: &DocContext<'_>,\n     }\n }\n \n-impl Clean<Vec<Item>> for doctree::ExternCrate {\n+impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n@@ -3941,7 +3941,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n     }\n }\n \n-impl Clean<Vec<Item>> for doctree::Import {\n+impl Clean<Vec<Item>> for doctree::Import<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n@@ -4017,22 +4017,11 @@ pub struct ImportSource {\n     pub did: Option<DefId>,\n }\n \n-impl Clean<Vec<Item>> for hir::ForeignMod {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        let mut items = self.items.clean(cx);\n-        for item in &mut items {\n-            if let ForeignFunctionItem(ref mut f) = item.inner {\n-                f.header.abi = self.abi;\n-            }\n-        }\n-        items\n-    }\n-}\n-\n-impl Clean<Item> for hir::ForeignItem {\n+impl Clean<Item> for doctree::ForeignItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.node {\n+        let inner = match self.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n+                let abi = cx.tcx.hir().get_foreign_abi(self.id);\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                 });\n@@ -4042,7 +4031,7 @@ impl Clean<Item> for hir::ForeignItem {\n                     generics,\n                     header: hir::FnHeader {\n                         unsafety: hir::Unsafety::Unsafe,\n-                        abi: Abi::Rust,\n+                        abi,\n                         constness: hir::Constness::NotConst,\n                         asyncness: hir::IsAsync::NotAsync,\n                     },\n@@ -4062,16 +4051,14 @@ impl Clean<Item> for hir::ForeignItem {\n             }\n         };\n \n-        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n-\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: local_did,\n+            source: self.whence.clean(cx),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n+            stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner,\n         }\n     }\n@@ -4246,7 +4233,7 @@ pub struct Macro {\n     pub imported_from: Option<String>,\n }\n \n-impl Clean<Item> for doctree::Macro {\n+impl Clean<Item> for doctree::Macro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = self.name.clean(cx);\n         Item {\n@@ -4275,7 +4262,7 @@ pub struct ProcMacro {\n     pub helpers: Vec<String>,\n }\n \n-impl Clean<Item> for doctree::ProcMacro {\n+impl Clean<Item> for doctree::ProcMacro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),"}, {"sha": "51deb4e9b974706cc393a04d8fe9146ea1948e77", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -7,52 +7,55 @@ use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::ptr::P;\n-use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n \n-pub struct Module {\n+pub struct Module<'hir> {\n     pub name: Option<Name>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n-    pub extern_crates: Vec<ExternCrate>,\n-    pub imports: Vec<Import>,\n-    pub structs: Vec<Struct>,\n-    pub unions: Vec<Union>,\n-    pub enums: Vec<Enum>,\n-    pub fns: Vec<Function>,\n-    pub mods: Vec<Module>,\n+    pub extern_crates: Vec<ExternCrate<'hir>>,\n+    pub imports: Vec<Import<'hir>>,\n+    pub structs: Vec<Struct<'hir>>,\n+    pub unions: Vec<Union<'hir>>,\n+    pub enums: Vec<Enum<'hir>>,\n+    pub fns: Vec<Function<'hir>>,\n+    pub mods: Vec<Module<'hir>>,\n     pub id: NodeId,\n-    pub typedefs: Vec<Typedef>,\n-    pub existentials: Vec<Existential>,\n-    pub statics: Vec<Static>,\n-    pub constants: Vec<Constant>,\n-    pub traits: Vec<Trait>,\n-    pub vis: hir::Visibility,\n+    pub typedefs: Vec<Typedef<'hir>>,\n+    pub existentials: Vec<Existential<'hir>>,\n+    pub statics: Vec<Static<'hir>>,\n+    pub constants: Vec<Constant<'hir>>,\n+    pub traits: Vec<Trait<'hir>>,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub impls: Vec<Impl>,\n-    pub foreigns: Vec<hir::ForeignMod>,\n-    pub macros: Vec<Macro>,\n-    pub proc_macros: Vec<ProcMacro>,\n-    pub trait_aliases: Vec<TraitAlias>,\n+    pub impls: Vec<Impl<'hir>>,\n+    pub foreigns: Vec<ForeignItem<'hir>>,\n+    pub macros: Vec<Macro<'hir>>,\n+    pub proc_macros: Vec<ProcMacro<'hir>>,\n+    pub trait_aliases: Vec<TraitAlias<'hir>>,\n     pub is_crate: bool,\n }\n \n-impl Module {\n-    pub fn new(name: Option<Name>) -> Module {\n+impl Module<'hir> {\n+    pub fn new(\n+        name: Option<Name>,\n+        attrs: &'hir hir::HirVec<ast::Attribute>,\n+        vis: &'hir hir::Visibility,\n+    ) -> Module<'hir> {\n         Module {\n             name       : name,\n             id: ast::CRATE_NODE_ID,\n-            vis: Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Inherited },\n+            vis,\n             stab: None,\n             depr: None,\n             where_outer: syntax_pos::DUMMY_SP,\n             where_inner: syntax_pos::DUMMY_SP,\n-            attrs      : hir::HirVec::new(),\n+            attrs,\n             extern_crates: Vec::new(),\n             imports    :   Vec::new(),\n             structs    :   Vec::new(),\n@@ -85,199 +88,210 @@ pub enum StructType {\n     Unit,\n }\n \n-pub struct Struct {\n-    pub vis: hir::Visibility,\n+pub struct Struct<'hir> {\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: hir::Generics,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub fields: hir::HirVec<hir::StructField>,\n+    pub generics: &'hir hir::Generics,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n \n-pub struct Union {\n-    pub vis: hir::Visibility,\n+pub struct Union<'hir> {\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: hir::Generics,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub fields: hir::HirVec<hir::StructField>,\n+    pub generics: &'hir hir::Generics,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n \n-pub struct Enum {\n-    pub vis: hir::Visibility,\n+pub struct Enum<'hir> {\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub variants: hir::HirVec<Variant>,\n-    pub generics: hir::Generics,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub variants: Vec<Variant<'hir>>,\n+    pub generics: &'hir hir::Generics,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub name: Name,\n }\n \n-pub struct Variant {\n+pub struct Variant<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub def: hir::VariantData,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub def: &'hir hir::VariantData,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub whence: Span,\n }\n \n-pub struct Function {\n-    pub decl: hir::FnDecl,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+pub struct Function<'hir> {\n+    pub decl: &'hir hir::FnDecl,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub name: Name,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub header: hir::FnHeader,\n     pub whence: Span,\n-    pub generics: hir::Generics,\n+    pub generics: &'hir hir::Generics,\n     pub body: hir::BodyId,\n }\n \n-pub struct Typedef {\n-    pub ty: P<hir::Ty>,\n-    pub gen: hir::Generics,\n+pub struct Typedef<'hir> {\n+    pub ty: &'hir P<hir::Ty>,\n+    pub gen: &'hir hir::Generics,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n-pub struct Existential {\n-    pub exist_ty: hir::ExistTy,\n+pub struct Existential<'hir> {\n+    pub exist_ty: &'hir hir::ExistTy,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n #[derive(Debug)]\n-pub struct Static {\n-    pub type_: P<hir::Ty>,\n+pub struct Static<'hir> {\n+    pub type_: &'hir P<hir::Ty>,\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub vis: hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n \n-pub struct Constant {\n-    pub type_: P<hir::Ty>,\n+pub struct Constant<'hir> {\n+    pub type_: &'hir P<hir::Ty>,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub vis: hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n \n-pub struct Trait {\n+pub struct Trait<'hir> {\n     pub is_auto: hir::IsAuto,\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n-    pub items: hir::HirVec<hir::TraitItem>,\n-    pub generics: hir::Generics,\n-    pub bounds: hir::HirVec<hir::GenericBound>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub items: Vec<&'hir hir::TraitItem>,\n+    pub generics: &'hir hir::Generics,\n+    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n-pub struct TraitAlias {\n+pub struct TraitAlias<'hir> {\n     pub name: Name,\n-    pub generics: hir::Generics,\n-    pub bounds: hir::HirVec<hir::GenericBound>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub generics: &'hir hir::Generics,\n+    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n #[derive(Debug)]\n-pub struct Impl {\n+pub struct Impl<'hir> {\n     pub unsafety: hir::Unsafety,\n     pub polarity: hir::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n-    pub generics: hir::Generics,\n-    pub trait_: Option<hir::TraitRef>,\n-    pub for_: P<hir::Ty>,\n-    pub items: hir::HirVec<hir::ImplItem>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub generics: &'hir hir::Generics,\n+    pub trait_: &'hir Option<hir::TraitRef>,\n+    pub for_: &'hir P<hir::Ty>,\n+    pub items: Vec<&'hir hir::ImplItem>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n }\n \n+pub struct ForeignItem<'hir> {\n+    pub vis: &'hir hir::Visibility,\n+    pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n+    pub id: hir::HirId,\n+    pub name: Name,\n+    pub kind: &'hir hir::ForeignItemKind,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub whence: Span,\n+}\n+\n // For Macro we store the DefId instead of the NodeId, since we also create\n // these imported macro_rules (which only have a DUMMY_NODE_ID).\n-pub struct Macro {\n+pub struct Macro<'hir> {\n     pub name: Name,\n     pub def_id: hir::def_id::DefId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub matchers: hir::HirVec<Span>,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub imported_from: Option<Name>,\n }\n \n-pub struct ExternCrate {\n+pub struct ExternCrate<'hir> {\n     pub name: Name,\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n-    pub vis: hir::Visibility,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub vis: &'hir hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n-pub struct Import {\n+pub struct Import<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub vis: hir::Visibility,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub path: hir::Path,\n+    pub vis: &'hir hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub path: &'hir hir::Path,\n     pub glob: bool,\n     pub whence: Span,\n }\n \n-pub struct ProcMacro {\n+pub struct ProcMacro<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n     pub kind: MacroKind,\n     pub helpers: Vec<Name>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,"}, {"sha": "c94149d31020a9ffbae90ca4fbfbb97c5f1e852b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 123, "deletions": 120, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673c3fc23ad0c78fe26420b641957e4fdfea553b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=673c3fc23ad0c78fe26420b641957e4fdfea553b", "patch": "@@ -29,8 +29,7 @@ use crate::doctree::*;\n // framework from syntax?.\n \n pub struct RustdocVisitor<'a, 'tcx> {\n-    pub module: Module,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub module: Option<Module<'tcx>>,\n     pub cx: &'a core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n@@ -47,8 +46,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let mut stack = FxHashSet::default();\n         stack.insert(hir::CRATE_HIR_ID);\n         RustdocVisitor {\n-            module: Module::new(None),\n-            attrs: hir::HirVec::new(),\n+            module: None,\n             cx,\n             view_item_stack: stack,\n             inlining: false,\n@@ -77,92 +75,91 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n-    pub fn visit(&mut self, krate: &hir::Crate) {\n-        self.attrs = krate.attrs.clone();\n-\n-        self.module = self.visit_mod_contents(krate.span,\n-                                              krate.attrs.clone(),\n-                                              Spanned { span: syntax_pos::DUMMY_SP,\n+    pub fn visit(&mut self, krate: &'tcx hir::Crate) {\n+        let mut module = self.visit_mod_contents(krate.span,\n+                                              &krate.attrs,\n+                                              &Spanned { span: syntax_pos::DUMMY_SP,\n                                                         node: hir::VisibilityKind::Public },\n                                               hir::CRATE_HIR_ID,\n                                               &krate.module,\n                                               None);\n         // Attach the crate's exported macros to the top-level module:\n-        let macro_exports: Vec<_> =\n-            krate.exported_macros.iter().map(|def| self.visit_local_macro(def, None)).collect();\n-        self.module.macros.extend(macro_exports);\n-        self.module.is_crate = true;\n+        module.macros.extend(\n+            krate.exported_macros.iter().map(|def| self.visit_local_macro(def, None)),\n+        );\n+        module.is_crate = true;\n+        self.module = Some(module);\n \n         self.cx.renderinfo.borrow_mut().exact_paths = self.exact_paths.take().unwrap();\n     }\n \n-    pub fn visit_variant_data(&mut self, item: &hir::Item,\n-                              name: ast::Name, sd: &hir::VariantData,\n-                              generics: &hir::Generics) -> Struct {\n+    pub fn visit_variant_data(&mut self, item: &'tcx hir::Item,\n+                              name: ast::Name, sd: &'tcx hir::VariantData,\n+                              generics: &'tcx hir::Generics) -> Struct<'tcx> {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n         Struct {\n             id: item.hir_id,\n             struct_type,\n             name,\n-            vis: item.vis.clone(),\n+            vis: &item.vis,\n             stab: self.stability(item.hir_id),\n             depr: self.deprecation(item.hir_id),\n-            attrs: item.attrs.clone(),\n-            generics: generics.clone(),\n-            fields: sd.fields().iter().cloned().collect(),\n+            attrs: &item.attrs,\n+            generics,\n+            fields: sd.fields(),\n             whence: item.span\n         }\n     }\n \n-    pub fn visit_union_data(&mut self, item: &hir::Item,\n-                            name: ast::Name, sd: &hir::VariantData,\n-                            generics: &hir::Generics) -> Union {\n+    pub fn visit_union_data(&mut self, item: &'tcx hir::Item,\n+                            name: ast::Name, sd: &'tcx hir::VariantData,\n+                            generics: &'tcx hir::Generics) -> Union<'tcx> {\n         debug!(\"Visiting union\");\n         let struct_type = struct_type_from_def(&*sd);\n         Union {\n             id: item.hir_id,\n             struct_type,\n             name,\n-            vis: item.vis.clone(),\n+            vis: &item.vis,\n             stab: self.stability(item.hir_id),\n             depr: self.deprecation(item.hir_id),\n-            attrs: item.attrs.clone(),\n-            generics: generics.clone(),\n-            fields: sd.fields().iter().cloned().collect(),\n+            attrs: &item.attrs,\n+            generics,\n+            fields: sd.fields(),\n             whence: item.span\n         }\n     }\n \n-    pub fn visit_enum_def(&mut self, it: &hir::Item,\n-                          name: ast::Name, def: &hir::EnumDef,\n-                          params: &hir::Generics) -> Enum {\n+    pub fn visit_enum_def(&mut self, it: &'tcx hir::Item,\n+                          name: ast::Name, def: &'tcx hir::EnumDef,\n+                          generics: &'tcx hir::Generics) -> Enum<'tcx> {\n         debug!(\"Visiting enum\");\n         Enum {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n                 name: v.node.ident.name,\n                 id: v.node.id,\n-                attrs: v.node.attrs.clone(),\n+                attrs: &v.node.attrs,\n                 stab: self.stability(v.node.id),\n                 depr: self.deprecation(v.node.id),\n-                def: v.node.data.clone(),\n+                def: &v.node.data,\n                 whence: v.span,\n             }).collect(),\n-            vis: it.vis.clone(),\n+            vis: &it.vis,\n             stab: self.stability(it.hir_id),\n             depr: self.deprecation(it.hir_id),\n-            generics: params.clone(),\n-            attrs: it.attrs.clone(),\n+            generics,\n+            attrs: &it.attrs,\n             id: it.hir_id,\n             whence: it.span,\n         }\n     }\n \n-    pub fn visit_fn(&mut self, om: &mut Module, item: &hir::Item,\n-                    name: ast::Name, fd: &hir::FnDecl,\n+    pub fn visit_fn(&mut self, om: &mut Module<'tcx>, item: &'tcx hir::Item,\n+                    name: ast::Name, decl: &'tcx hir::FnDecl,\n                     header: hir::FnHeader,\n-                    gen: &hir::Generics,\n+                    generics: &'tcx hir::Generics,\n                     body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n         let macro_kind = item.attrs.iter().filter_map(|a| {\n@@ -208,7 +205,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.hir_id,\n                     kind,\n                     helpers,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n@@ -217,30 +214,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => {\n                 om.fns.push(Function {\n                     id: item.hir_id,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n-                    attrs: item.attrs.clone(),\n-                    decl: fd.clone(),\n+                    attrs: &item.attrs,\n+                    decl,\n                     name,\n                     whence: item.span,\n-                    generics: gen.clone(),\n+                    generics,\n                     header,\n                     body,\n                 });\n             }\n         }\n     }\n \n-    pub fn visit_mod_contents(&mut self, span: Span, attrs: hir::HirVec<ast::Attribute>,\n-                              vis: hir::Visibility, id: hir::HirId,\n-                              m: &hir::Mod,\n-                              name: Option<ast::Name>) -> Module {\n-        let mut om = Module::new(name);\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: &'tcx hir::HirVec<ast::Attribute>,\n+                              vis: &'tcx hir::Visibility, id: hir::HirId,\n+                              m: &'tcx hir::Mod,\n+                              name: Option<ast::Name>) -> Module<'tcx> {\n+        let mut om = Module::new(name, attrs, vis);\n         om.where_outer = span;\n         om.where_inner = m.inner;\n-        om.attrs = attrs;\n-        om.vis = vis.clone();\n         om.stab = self.stability(id);\n         om.depr = self.deprecation(id);\n         om.id = self.cx.tcx.hir().hir_to_node_id(id);\n@@ -269,7 +264,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                           res: Res,\n                           renamed: Option<ast::Ident>,\n                           glob: bool,\n-                          om: &mut Module,\n+                          om: &mut Module<'tcx>,\n                           please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n@@ -359,14 +354,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 true\n             }\n             Node::ForeignItem(it) if !glob => {\n-                // Generate a fresh `extern {}` block if we want to inline a foreign item.\n-                om.foreigns.push(hir::ForeignMod {\n-                    abi: tcx.hir().get_foreign_abi(it.hir_id),\n-                    items: vec![hir::ForeignItem {\n-                        ident: renamed.unwrap_or(it.ident),\n-                        .. it.clone()\n-                    }].into(),\n-                });\n+                let prev = mem::replace(&mut self.inlining, true);\n+                self.visit_foreign_item(it, renamed, om);\n+                self.inlining = prev;\n                 true\n             }\n             Node::MacroDef(def) if !glob => {\n@@ -379,8 +369,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n-    pub fn visit_item(&mut self, item: &hir::Item,\n-                      renamed: Option<ast::Ident>, om: &mut Module) {\n+    pub fn visit_item(&mut self, item: &'tcx hir::Item,\n+                      renamed: Option<ast::Ident>, om: &mut Module<'tcx>) {\n         debug!(\"Visiting item {:?}\", item);\n         let ident = renamed.unwrap_or(item.ident);\n \n@@ -391,15 +381,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemKind::ForeignMod(ref fm) => {\n-                // If inlining we only want to include public functions.\n-                om.foreigns.push(if self.inlining {\n-                    hir::ForeignMod {\n-                        abi: fm.abi,\n-                        items: fm.items.iter().filter(|i| i.vis.node.is_pub()).cloned().collect(),\n-                    }\n-                } else {\n-                    fm.clone()\n-                });\n+                for item in &fm.items {\n+                    self.visit_foreign_item(item, None, om);\n+                }\n             }\n             // If we're inlining, skip private items.\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n@@ -411,8 +395,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                 .unwrap_or(LOCAL_CRATE),\n                     name: ident.name,\n                     path: orig_name.map(|x|x.to_string()),\n-                    vis: item.vis.clone(),\n-                    attrs: item.attrs.clone(),\n+                    vis: &item.vis,\n+                    attrs: &item.attrs,\n                     whence: item.span,\n                 })\n             }\n@@ -454,17 +438,17 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.imports.push(Import {\n                     name: ident.name,\n                     id: item.hir_id,\n-                    vis: item.vis.clone(),\n-                    attrs: item.attrs.clone(),\n-                    path: (**path).clone(),\n+                    vis: &item.vis,\n+                    attrs: &item.attrs,\n+                    path,\n                     glob: is_glob,\n                     whence: item.span,\n                 });\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n-                                                     item.attrs.clone(),\n-                                                     item.vis.clone(),\n+                                                     &item.attrs,\n+                                                     &item.vis,\n                                                      item.hir_id,\n                                                      m,\n                                                      Some(ident.name)));\n@@ -479,89 +463,89 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 self.visit_fn(om, item, ident.name, &**fd, header, gen, body),\n             hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n-                    ty: ty.clone(),\n-                    gen: gen.clone(),\n+                    ty,\n+                    gen,\n                     name: ident.name,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.typedefs.push(t);\n             },\n             hir::ItemKind::Existential(ref exist_ty) => {\n                 let t = Existential {\n-                    exist_ty: exist_ty.clone(),\n+                    exist_ty,\n                     name: ident.name,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.existentials.push(t);\n             },\n-            hir::ItemKind::Static(ref ty, ref mut_, ref exp) => {\n+            hir::ItemKind::Static(ref type_, mutability, expr) => {\n                 let s = Static {\n-                    type_: ty.clone(),\n-                    mutability: mut_.clone(),\n-                    expr: exp.clone(),\n+                    type_,\n+                    mutability,\n+                    expr,\n                     id: item.hir_id,\n                     name: ident.name,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.statics.push(s);\n             },\n-            hir::ItemKind::Const(ref ty, ref exp) => {\n+            hir::ItemKind::Const(ref type_, expr) => {\n                 let s = Constant {\n-                    type_: ty.clone(),\n-                    expr: exp.clone(),\n+                    type_,\n+                    expr,\n                     id: item.hir_id,\n                     name: ident.name,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.constants.push(s);\n             },\n-            hir::ItemKind::Trait(is_auto, unsafety, ref gen, ref b, ref item_ids) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n                 let items = item_ids.iter()\n-                                    .map(|ti| self.cx.tcx.hir().trait_item(ti.id).clone())\n+                                    .map(|ti| self.cx.tcx.hir().trait_item(ti.id))\n                                     .collect();\n                 let t = Trait {\n                     is_auto,\n                     unsafety,\n                     name: ident.name,\n                     items,\n-                    generics: gen.clone(),\n-                    bounds: b.iter().cloned().collect(),\n+                    generics,\n+                    bounds,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.traits.push(t);\n             },\n-            hir::ItemKind::TraitAlias(ref gen, ref b) => {\n+            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 let t = TraitAlias {\n                     name: ident.name,\n-                    generics: gen.clone(),\n-                    bounds: b.iter().cloned().collect(),\n+                    generics,\n+                    bounds,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n@@ -571,28 +555,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::ItemKind::Impl(unsafety,\n                           polarity,\n                           defaultness,\n-                          ref gen,\n-                          ref tr,\n-                          ref ty,\n+                          ref generics,\n+                          ref trait_,\n+                          ref for_,\n                           ref item_ids) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n-                if !self.inlining && tr.is_none() {\n+                if !self.inlining && trait_.is_none() {\n                     let items = item_ids.iter()\n-                                        .map(|ii| self.cx.tcx.hir().impl_item(ii.id).clone())\n+                                        .map(|ii| self.cx.tcx.hir().impl_item(ii.id))\n                                         .collect();\n                     let i = Impl {\n                         unsafety,\n                         polarity,\n                         defaultness,\n-                        generics: gen.clone(),\n-                        trait_: tr.clone(),\n-                        for_: ty.clone(),\n+                        generics,\n+                        trait_,\n+                        for_,\n                         items,\n-                        attrs: item.attrs.clone(),\n+                        attrs: &item.attrs,\n                         id: item.hir_id,\n                         whence: item.span,\n-                        vis: item.vis.clone(),\n+                        vis: &item.vis,\n                         stab: self.stability(item.hir_id),\n                         depr: self.deprecation(item.hir_id),\n                     };\n@@ -602,12 +586,31 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem,\n+                      renamed: Option<ast::Ident>, om: &mut Module<'tcx>) {\n+        // If inlining we only want to include public functions.\n+        if self.inlining && !item.vis.node.is_pub() {\n+            return;\n+        }\n+\n+        om.foreigns.push(ForeignItem {\n+            id: item.hir_id,\n+            name: renamed.unwrap_or(item.ident).name,\n+            kind: &item.node,\n+            vis: &item.vis,\n+            stab: self.stability(item.hir_id),\n+            depr: self.deprecation(item.hir_id),\n+            attrs: &item.attrs,\n+            whence: item.span\n+        });\n+    }\n+\n     // Convert each `exported_macro` into a doc item.\n     fn visit_local_macro(\n         &self,\n-        def: &hir::MacroDef,\n+        def: &'tcx hir::MacroDef,\n         renamed: Option<ast::Name>\n-    ) -> Macro {\n+    ) -> Macro<'tcx> {\n         debug!(\"visit_local_macro: {}\", def.name);\n         let tts = def.body.trees().collect::<Vec<_>>();\n         // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n@@ -616,7 +619,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         Macro {\n \n             def_id: self.cx.tcx.hir().local_def_id_from_hir_id(def.hir_id),\n-            attrs: def.attrs.clone(),\n+            attrs: &def.attrs,\n             name: renamed.unwrap_or(def.name),\n             whence: def.span,\n             matchers,"}]}