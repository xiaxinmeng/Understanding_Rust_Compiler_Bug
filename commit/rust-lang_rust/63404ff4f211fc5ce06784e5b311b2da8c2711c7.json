{"sha": "63404ff4f211fc5ce06784e5b311b2da8c2711c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNDA0ZmY0ZjIxMWZjNWNlMDY3ODRlNWIzMTFiMmRhOGMyNzExYzc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-15T00:17:27Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-15T00:17:27Z"}, "message": "Merge pull request #856 from Manishearth/stuffs\n\nVarious ~~small~~ stuffs", "tree": {"sha": "8a1ecbf545a29a4b4492013beb43c5221e19f3eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a1ecbf545a29a4b4492013beb43c5221e19f3eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63404ff4f211fc5ce06784e5b311b2da8c2711c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63404ff4f211fc5ce06784e5b311b2da8c2711c7", "html_url": "https://github.com/rust-lang/rust/commit/63404ff4f211fc5ce06784e5b311b2da8c2711c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63404ff4f211fc5ce06784e5b311b2da8c2711c7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c23b684ea586bdab67ad244289578dbfdcb33514", "url": "https://api.github.com/repos/rust-lang/rust/commits/c23b684ea586bdab67ad244289578dbfdcb33514", "html_url": "https://github.com/rust-lang/rust/commit/c23b684ea586bdab67ad244289578dbfdcb33514"}, {"sha": "72b747915c5173a493b58aad1c2292256a85250e", "url": "https://api.github.com/repos/rust-lang/rust/commits/72b747915c5173a493b58aad1c2292256a85250e", "html_url": "https://github.com/rust-lang/rust/commit/72b747915c5173a493b58aad1c2292256a85250e"}], "stats": {"total": 1182, "additions": 751, "deletions": 431}, "files": [{"sha": "f72ac01bc3eb84983afbf033f7273f255b12d9cd", "filename": ".travis.yml", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -13,11 +13,15 @@ script:\n  - rm -rf target/ Cargo.lock\n  - cargo test --features debugging\n \n- # only test regex_macros if it compiles\n- - if [[ \"$(cargo build --features 'debugging test-regex_macros')\" = 101 ]]; then cargo test --features 'debugging test-regex_macros'; fi\n-\n-# trigger rebuild of the clippy-service, to keep it up to date with clippy itself\n after_success:\n+# only test regex_macros if it compiles\n+- |\n+    #!/bin/bash\n+    cargo test --no-run --features 'debugging test-regex_macros'\n+    if [ \"$?\" != 101 ]; then\n+        cargo test --features 'debugging test-regex_macros' compile_test\n+    fi\n+# trigger rebuild of the clippy-service, to keep it up to date with clippy itself\n - |\n     #!/bin/bash\n     set -e"}, {"sha": "2493ae2502d4ce76aeb7b9ad7d4ffbcb4e0a6bbc", "filename": "CHANGELOG.md", "status": "modified", "additions": 134, "deletions": 2, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## Unreleased\n+* New lint: [`temporary_cstring_as_ptr`]\n+\n ## 0.0.63 \u2014 2016-04-08\n * Rustup to *rustc 1.9.0-nightly (7979dd608 2016-04-07)*\n \n@@ -31,7 +34,7 @@ All notable changes to this project will be documented in this file.\n \n ## 0.0.56 \u2014 2016-03-23\n * Update to *rustc 1.9.0-nightly (0dcc413e4 2016-03-22)*\n-* New lint: [`non_expressive_names`]\n+* New lints: [`many_single_char_names`] and [`similar_names`]\n \n ## 0.0.55 \u2014 2016-03-21\n * Update to *rustc 1.9.0-nightly (02310fd31 2016-03-19)*\n@@ -64,21 +67,150 @@ All notable changes to this project will be documented in this file.\n \n [configuration file]: ./rust-clippy#configuration\n \n+<!-- begin autogenerated links to wiki -->\n+[`absurd_extreme_comparisons`]: https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons\n+[`almost_swapped`]: https://github.com/Manishearth/rust-clippy/wiki#almost_swapped\n+[`approx_constant`]: https://github.com/Manishearth/rust-clippy/wiki#approx_constant\n+[`bad_bit_mask`]: https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask\n+[`blacklisted_name`]: https://github.com/Manishearth/rust-clippy/wiki#blacklisted_name\n+[`block_in_if_condition_expr`]: https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr\n+[`block_in_if_condition_stmt`]: https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt\n+[`bool_comparison`]: https://github.com/Manishearth/rust-clippy/wiki#bool_comparison\n+[`box_vec`]: https://github.com/Manishearth/rust-clippy/wiki#box_vec\n+[`boxed_local`]: https://github.com/Manishearth/rust-clippy/wiki#boxed_local\n+[`cast_possible_truncation`]: https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation\n+[`cast_possible_wrap`]: https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap\n+[`cast_precision_loss`]: https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss\n+[`cast_sign_loss`]: https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss\n+[`char_lit_as_u8`]: https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8\n+[`chars_next_cmp`]: https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp\n+[`clone_double_ref`]: https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref\n+[`clone_on_copy`]: https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy\n+[`cmp_nan`]: https://github.com/Manishearth/rust-clippy/wiki#cmp_nan\n+[`cmp_owned`]: https://github.com/Manishearth/rust-clippy/wiki#cmp_owned\n+[`collapsible_if`]: https://github.com/Manishearth/rust-clippy/wiki#collapsible_if\n [`crosspointer_transmute`]: https://github.com/Manishearth/rust-clippy/wiki#crosspointer_transmute\n+[`cyclomatic_complexity`]: https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity\n+[`deprecated_semver`]: https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver\n+[`derive_hash_xor_eq`]: https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq\n [`doc_markdown`]: https://github.com/Manishearth/rust-clippy/wiki#doc_markdown\n+[`drop_ref`]: https://github.com/Manishearth/rust-clippy/wiki#drop_ref\n+[`duplicate_underscore_argument`]: https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument\n+[`empty_loop`]: https://github.com/Manishearth/rust-clippy/wiki#empty_loop\n+[`enum_clike_unportable_variant`]: https://github.com/Manishearth/rust-clippy/wiki#enum_clike_unportable_variant\n+[`enum_glob_use`]: https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use\n+[`enum_variant_names`]: https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names\n+[`eq_op`]: https://github.com/Manishearth/rust-clippy/wiki#eq_op\n+[`expl_impl_clone_on_copy`]: https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy\n+[`explicit_counter_loop`]: https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop\n+[`explicit_iter_loop`]: https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop\n+[`extend_from_slice`]: https://github.com/Manishearth/rust-clippy/wiki#extend_from_slice\n+[`filter_next`]: https://github.com/Manishearth/rust-clippy/wiki#filter_next\n+[`float_cmp`]: https://github.com/Manishearth/rust-clippy/wiki#float_cmp\n+[`for_kv_map`]: https://github.com/Manishearth/rust-clippy/wiki#for_kv_map\n+[`for_loop_over_option`]: https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_option\n+[`for_loop_over_result`]: https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_result\n+[`identity_op`]: https://github.com/Manishearth/rust-clippy/wiki#identity_op\n+[`if_not_else`]: https://github.com/Manishearth/rust-clippy/wiki#if_not_else\n+[`if_same_then_else`]: https://github.com/Manishearth/rust-clippy/wiki#if_same_then_else\n+[`ifs_same_cond`]: https://github.com/Manishearth/rust-clippy/wiki#ifs_same_cond\n [`indexing_slicing`]: https://github.com/Manishearth/rust-clippy/wiki#indexing_slicing\n+[`ineffective_bit_mask`]: https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask\n+[`inline_always`]: https://github.com/Manishearth/rust-clippy/wiki#inline_always\n+[`invalid_regex`]: https://github.com/Manishearth/rust-clippy/wiki#invalid_regex\n [`invalid_upcast_comparisons`]: https://github.com/Manishearth/rust-clippy/wiki#invalid_upcast_comparisons\n+[`items_after_statements`]: https://github.com/Manishearth/rust-clippy/wiki#items_after_statements\n+[`iter_next_loop`]: https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop\n+[`len_without_is_empty`]: https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty\n+[`len_zero`]: https://github.com/Manishearth/rust-clippy/wiki#len_zero\n+[`let_and_return`]: https://github.com/Manishearth/rust-clippy/wiki#let_and_return\n+[`let_unit_value`]: https://github.com/Manishearth/rust-clippy/wiki#let_unit_value\n+[`linkedlist`]: https://github.com/Manishearth/rust-clippy/wiki#linkedlist\n [`logic_bug`]: https://github.com/Manishearth/rust-clippy/wiki#logic_bug\n+[`manual_swap`]: https://github.com/Manishearth/rust-clippy/wiki#manual_swap\n+[`many_single_char_names`]: https://github.com/Manishearth/rust-clippy/wiki#many_single_char_names\n+[`map_clone`]: https://github.com/Manishearth/rust-clippy/wiki#map_clone\n+[`map_entry`]: https://github.com/Manishearth/rust-clippy/wiki#map_entry\n+[`match_bool`]: https://github.com/Manishearth/rust-clippy/wiki#match_bool\n+[`match_overlapping_arm`]: https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm\n+[`match_ref_pats`]: https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats\n [`match_same_arms`]: https://github.com/Manishearth/rust-clippy/wiki#match_same_arms\n+[`min_max`]: https://github.com/Manishearth/rust-clippy/wiki#min_max\n+[`modulo_one`]: https://github.com/Manishearth/rust-clippy/wiki#modulo_one\n+[`mut_mut`]: https://github.com/Manishearth/rust-clippy/wiki#mut_mut\n+[`mutex_atomic`]: https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic\n+[`mutex_integer`]: https://github.com/Manishearth/rust-clippy/wiki#mutex_integer\n+[`needless_bool`]: https://github.com/Manishearth/rust-clippy/wiki#needless_bool\n+[`needless_lifetimes`]: https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes\n [`needless_range_loop`]: https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop\n+[`needless_return`]: https://github.com/Manishearth/rust-clippy/wiki#needless_return\n+[`needless_update`]: https://github.com/Manishearth/rust-clippy/wiki#needless_update\n+[`new_ret_no_self`]: https://github.com/Manishearth/rust-clippy/wiki#new_ret_no_self\n [`new_without_default`]: https://github.com/Manishearth/rust-clippy/wiki#new_without_default\n-[`non_expressive_names`]: https://github.com/Manishearth/rust-clippy/wiki#non_expressive_names\n+[`no_effect`]: https://github.com/Manishearth/rust-clippy/wiki#no_effect\n+[`non_ascii_literal`]: https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal\n [`nonminimal_bool`]: https://github.com/Manishearth/rust-clippy/wiki#nonminimal_bool\n+[`nonsensical_open_options`]: https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options\n+[`ok_expect`]: https://github.com/Manishearth/rust-clippy/wiki#ok_expect\n+[`option_map_unwrap_or`]: https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or\n+[`option_map_unwrap_or_else`]: https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else\n+[`option_unwrap_used`]: https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used\n+[`or_fun_call`]: https://github.com/Manishearth/rust-clippy/wiki#or_fun_call\n+[`out_of_bounds_indexing`]: https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing\n [`overflow_check_conditional`]: https://github.com/Manishearth/rust-clippy/wiki#overflow_check_conditional\n+[`panic_params`]: https://github.com/Manishearth/rust-clippy/wiki#panic_params\n+[`precedence`]: https://github.com/Manishearth/rust-clippy/wiki#precedence\n+[`print_stdout`]: https://github.com/Manishearth/rust-clippy/wiki#print_stdout\n+[`ptr_arg`]: https://github.com/Manishearth/rust-clippy/wiki#ptr_arg\n+[`range_step_by_zero`]: https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero\n+[`range_zip_with_len`]: https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len\n+[`redundant_closure`]: https://github.com/Manishearth/rust-clippy/wiki#redundant_closure\n [`redundant_closure_call`]: https://github.com/Manishearth/rust-clippy/wiki#redundant_closure_call\n+[`redundant_pattern`]: https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern\n+[`regex_macro`]: https://github.com/Manishearth/rust-clippy/wiki#regex_macro\n+[`result_unwrap_used`]: https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used\n+[`reverse_range_loop`]: https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop\n+[`search_is_some`]: https://github.com/Manishearth/rust-clippy/wiki#search_is_some\n+[`shadow_reuse`]: https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse\n+[`shadow_same`]: https://github.com/Manishearth/rust-clippy/wiki#shadow_same\n+[`shadow_unrelated`]: https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated\n+[`should_implement_trait`]: https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait\n+[`similar_names`]: https://github.com/Manishearth/rust-clippy/wiki#similar_names\n+[`single_char_pattern`]: https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern\n+[`single_match`]: https://github.com/Manishearth/rust-clippy/wiki#single_match\n+[`single_match_else`]: https://github.com/Manishearth/rust-clippy/wiki#single_match_else\n [`str_to_string`]: https://github.com/Manishearth/rust-clippy/wiki#str_to_string\n+[`string_add`]: https://github.com/Manishearth/rust-clippy/wiki#string_add\n+[`string_add_assign`]: https://github.com/Manishearth/rust-clippy/wiki#string_add_assign\n+[`string_lit_as_bytes`]: https://github.com/Manishearth/rust-clippy/wiki#string_lit_as_bytes\n [`string_to_string`]: https://github.com/Manishearth/rust-clippy/wiki#string_to_string\n+[`suspicious_assignment_formatting`]: https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting\n+[`suspicious_else_formatting`]: https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting\n+[`temporary_assignment`]: https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment\n+[`temporary_cstring_as_ptr`]: https://github.com/Manishearth/rust-clippy/wiki#temporary_cstring_as_ptr\n+[`too_many_arguments`]: https://github.com/Manishearth/rust-clippy/wiki#too_many_arguments\n+[`toplevel_ref_arg`]: https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg\n+[`transmute_ptr_to_ref`]: https://github.com/Manishearth/rust-clippy/wiki#transmute_ptr_to_ref\n+[`trivial_regex`]: https://github.com/Manishearth/rust-clippy/wiki#trivial_regex\n+[`type_complexity`]: https://github.com/Manishearth/rust-clippy/wiki#type_complexity\n+[`unicode_not_nfc`]: https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc\n+[`unit_cmp`]: https://github.com/Manishearth/rust-clippy/wiki#unit_cmp\n+[`unnecessary_mut_passed`]: https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed\n+[`unneeded_field_pattern`]: https://github.com/Manishearth/rust-clippy/wiki#unneeded_field_pattern\n [`unstable_as_mut_slice`]: https://github.com/Manishearth/rust-clippy/wiki#unstable_as_mut_slice\n [`unstable_as_slice`]: https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice\n+[`unused_collect`]: https://github.com/Manishearth/rust-clippy/wiki#unused_collect\n [`unused_label`]: https://github.com/Manishearth/rust-clippy/wiki#unused_label\n+[`unused_lifetimes`]: https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes\n+[`use_debug`]: https://github.com/Manishearth/rust-clippy/wiki#use_debug\n+[`used_underscore_binding`]: https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding\n+[`useless_format`]: https://github.com/Manishearth/rust-clippy/wiki#useless_format\n+[`useless_transmute`]: https://github.com/Manishearth/rust-clippy/wiki#useless_transmute\n [`useless_vec`]: https://github.com/Manishearth/rust-clippy/wiki#useless_vec\n+[`while_let_loop`]: https://github.com/Manishearth/rust-clippy/wiki#while_let_loop\n+[`while_let_on_iterator`]: https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator\n+[`wrong_pub_self_convention`]: https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention\n+[`wrong_self_convention`]: https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention\n+[`zero_divided_by_zero`]: https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero\n+[`zero_width_space`]: https://github.com/Manishearth/rust-clippy/wiki#zero_width_space\n+<!-- end autogenerated links to wiki -->"}, {"sha": "c7cee794db453d551735c08160015dc1234e8ebe", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -14,7 +14,7 @@ Table of contents:\n * [License](#license)\n \n ##Lints\n-There are 140 lints included in this crate:\n+There are 141 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -135,6 +135,7 @@ name\n [suspicious_assignment_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting) | warn    | suspicious formatting of `*=`, `-=` or `!=`\n [suspicious_else_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting)             | warn    | suspicious formatting of `else if`\n [temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries\n+[temporary_cstring_as_ptr](https://github.com/Manishearth/rust-clippy/wiki#temporary_cstring_as_ptr)                 | warn    | getting the inner pointer of a temporary `CString`\n [too_many_arguments](https://github.com/Manishearth/rust-clippy/wiki#too_many_arguments)                             | warn    | functions with too many arguments\n [toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n [transmute_ptr_to_ref](https://github.com/Manishearth/rust-clippy/wiki#transmute_ptr_to_ref)                         | warn    | transmutes from a pointer to a reference type"}, {"sha": "2295bd7832a404e0707b95ab3d130a6db7b664e8", "filename": "src/array_indexing.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farray_indexing.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -78,17 +78,16 @@ impl LateLintPass for ArrayIndexing {\n \n                 // Index is a constant range\n                 if let Some(range) = utils::unsugar_range(index) {\n-                    let start = range.start.map(|start|\n-                        eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None)).map(|v| v.ok());\n-                    let end = range.end.map(|end|\n-                        eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None)).map(|v| v.ok());\n+                    let start = range.start\n+                                     .map(|start| eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None))\n+                                     .map(|v| v.ok());\n+                    let end = range.end\n+                                   .map(|end| eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None))\n+                                   .map(|v| v.ok());\n \n                     if let Some((start, end)) = to_const_range(start, end, range.limits, size) {\n                         if start > size || end > size {\n-                            utils::span_lint(cx,\n-                                             OUT_OF_BOUNDS_INDEXING,\n-                                             e.span,\n-                                             \"range is out of bounds\");\n+                            utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"range is out of bounds\");\n                         }\n                         return;\n                     }\n@@ -111,11 +110,9 @@ impl LateLintPass for ArrayIndexing {\n }\n \n /// Returns an option containing a tuple with the start and end (exclusive) of the range.\n-fn to_const_range(start: Option<Option<ConstVal>>,\n-                  end: Option<Option<ConstVal>>,\n-                  limits: RangeLimits,\n+fn to_const_range(start: Option<Option<ConstVal>>, end: Option<Option<ConstVal>>, limits: RangeLimits,\n                   array_size: ConstInt)\n-                    -> Option<(ConstInt, ConstInt)> {\n+                  -> Option<(ConstInt, ConstInt)> {\n     let start = match start {\n         Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n@@ -131,7 +128,7 @@ fn to_const_range(start: Option<Option<ConstVal>>,\n             }\n         }\n         Some(_) => return None,\n-        None => array_size\n+        None => array_size,\n     };\n \n     Some((start, end))"}, {"sha": "6106486c71e2b4440fc183296624b0db10278467", "filename": "src/attrs.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -7,7 +7,8 @@ use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind};\n use syntax::attr::*;\n use syntax::codemap::Span;\n-use utils::{in_macro, match_path, span_lint, BEGIN_UNWIND};\n+use utils::{in_macro, match_path, span_lint};\n+use utils::paths;\n \n /// **What it does:** This lint checks for items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n ///\n@@ -114,7 +115,8 @@ fn is_relevant_block(block: &Block) -> bool {\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(_, _) => return true,\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+            StmtExpr(ref expr, _) |\n+            StmtSemi(ref expr, _) => {\n                 return is_relevant_expr(expr);\n             }\n         }\n@@ -129,7 +131,7 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n         ExprRet(None) | ExprBreak(_) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(_, ref path) = path_expr.node {\n-                !match_path(path, &BEGIN_UNWIND)\n+                !match_path(path, &paths::BEGIN_UNWIND)\n             } else {\n                 true\n             }"}, {"sha": "aec0990dcc68ac24a2975305121720852b5fd27e", "filename": "src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -264,7 +264,7 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n                 // borrowing.\n                 let def_map = cx.tcx.def_map.borrow();\n                 match def_map.get(&lit.id) {\n-                    Some(&PathResolution { base_def: Def::Const(def_id), ..}) => Some(def_id),\n+                    Some(&PathResolution { base_def: Def::Const(def_id), .. }) => Some(def_id),\n                     _ => None,\n                 }\n             }"}, {"sha": "908415acc7b954c6a1e66f34f9d9470da4c1daf7", "filename": "src/booleans.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbooleans.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -49,7 +49,7 @@ struct NonminimalBoolVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n use quine_mc_cluskey::Bool;\n struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n     terminals: Vec<&'v Expr>,\n-    cx: &'a LateContext<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n@@ -75,17 +75,17 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                     match binop.node {\n                         BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n                         BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n-                        _ => {},\n+                        _ => (),\n                     }\n-                },\n+                }\n                 ExprLit(ref lit) => {\n                     match lit.node {\n                         LitKind::Bool(true) => return Ok(Bool::True),\n                         LitKind::Bool(false) => return Ok(Bool::False),\n-                        _ => {},\n+                        _ => (),\n                     }\n-                },\n-                _ => {},\n+                }\n+                _ => (),\n             }\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n@@ -95,11 +95,13 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n             let negated = match e.node {\n                 ExprBinary(binop, ref lhs, ref rhs) => {\n-                    let mk_expr = |op| Expr {\n-                        id: DUMMY_NODE_ID,\n-                        span: DUMMY_SP,\n-                        attrs: None,\n-                        node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                    let mk_expr = |op| {\n+                        Expr {\n+                            id: DUMMY_NODE_ID,\n+                            span: DUMMY_SP,\n+                            attrs: None,\n+                            node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                        }\n                     };\n                     match binop.node {\n                         BiEq => mk_expr(BiNe),\n@@ -110,7 +112,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                         BiLe => mk_expr(BiGt),\n                         _ => continue,\n                     }\n-                },\n+                }\n                 _ => continue,\n             };\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n@@ -137,17 +139,17 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n             True => {\n                 s.push_str(\"true\");\n                 s\n-            },\n+            }\n             False => {\n                 s.push_str(\"false\");\n                 s\n-            },\n+            }\n             Not(ref inner) => {\n                 match **inner {\n                     And(_) | Or(_) => {\n                         s.push('!');\n                         recurse(true, cx, inner, terminals, s)\n-                    },\n+                    }\n                     Term(n) => {\n                         if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n                             let op = match binop.node {\n@@ -159,8 +161,8 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                                 BiGe => \" < \",\n                                 _ => {\n                                     s.push('!');\n-                                    return recurse(true, cx, inner, terminals, s)\n-                                },\n+                                    return recurse(true, cx, inner, terminals, s);\n+                                }\n                             };\n                             s.push_str(&snip(lhs));\n                             s.push_str(op);\n@@ -170,13 +172,13 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                             s.push('!');\n                             recurse(false, cx, inner, terminals, s)\n                         }\n-                    },\n+                    }\n                     _ => {\n                         s.push('!');\n                         recurse(false, cx, inner, terminals, s)\n-                    },\n+                    }\n                 }\n-            },\n+            }\n             And(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -198,7 +200,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            },\n+            }\n             Or(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -212,7 +214,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            },\n+            }\n             Term(n) => {\n                 if brackets {\n                     if let ExprBinary(..) = terminals[n as usize].node {\n@@ -243,13 +245,13 @@ fn simple_negate(b: Bool) -> Bool {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             Or(v)\n-        },\n+        }\n         Or(mut v) => {\n             for el in &mut v {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             And(v)\n-        },\n+        }\n         Not(inner) => *inner,\n     }\n }\n@@ -271,13 +273,13 @@ fn terminal_stats(b: &Bool) -> Stats {\n                     _ => stats.negations += 1,\n                 }\n                 recurse(inner, stats);\n-            },\n+            }\n             And(ref v) | Or(ref v) => {\n                 stats.ops += v.len() - 1;\n                 for inner in v {\n                     recurse(inner, stats);\n                 }\n-            },\n+            }\n             Term(n) => stats.terminals[n as usize] += 1,\n         }\n     }\n@@ -306,7 +308,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n             let mut simplified = expr.simplify();\n             for simple in Bool::Not(Box::new(expr.clone())).simplify() {\n                 match simple {\n-                    Bool::Not(_) | Bool::True | Bool::False => {},\n+                    Bool::Not(_) | Bool::True | Bool::False => {}\n                     _ => simplified.push(Bool::Not(Box::new(simple.clone()))),\n                 }\n                 let simple_negated = simple_negate(simple);\n@@ -325,36 +327,53 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                         continue 'simplified;\n                     }\n                     if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n-                        span_lint_and_then(self.0, LOGIC_BUG, e.span, \"this boolean expression contains a logic bug\", |db| {\n-                            db.span_help(h2q.terminals[i].span, \"this expression can be optimized out by applying boolean operations to the outer expression\");\n-                            db.span_suggestion(e.span, \"it would look like the following\", suggest(self.0, suggestion, &h2q.terminals));\n-                        });\n+                        span_lint_and_then(self.0,\n+                                           LOGIC_BUG,\n+                                           e.span,\n+                                           \"this boolean expression contains a logic bug\",\n+                                           |db| {\n+                                               db.span_help(h2q.terminals[i].span,\n+                                                            \"this expression can be optimized out by applying \\\n+                                                             boolean operations to the outer expression\");\n+                                               db.span_suggestion(e.span,\n+                                                                  \"it would look like the following\",\n+                                                                  suggest(self.0, suggestion, &h2q.terminals));\n+                                           });\n                         // don't also lint `NONMINIMAL_BOOL`\n                         return;\n                     }\n                     // if the number of occurrences of a terminal decreases or any of the stats decreases while none increases\n                     improvement |= (stats.terminals[i] > simplified_stats.terminals[i]) ||\n-                        (stats.negations > simplified_stats.negations && stats.ops == simplified_stats.ops) ||\n-                        (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n+                                   (stats.negations > simplified_stats.negations &&\n+                                    stats.ops == simplified_stats.ops) ||\n+                                   (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n                 }\n                 if improvement {\n                     improvements.push(suggestion);\n                 }\n             }\n             if !improvements.is_empty() {\n-                span_lint_and_then(self.0, NONMINIMAL_BOOL, e.span, \"this boolean expression can be simplified\", |db| {\n-                    for suggestion in &improvements {\n-                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n-                    }\n-                });\n+                span_lint_and_then(self.0,\n+                                   NONMINIMAL_BOOL,\n+                                   e.span,\n+                                   \"this boolean expression can be simplified\",\n+                                   |db| {\n+                                       for suggestion in &improvements {\n+                                           db.span_suggestion(e.span,\n+                                                              \"try\",\n+                                                              suggest(self.0, suggestion, &h2q.terminals));\n+                                       }\n+                                   });\n             }\n         }\n     }\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'v Expr) {\n-        if in_macro(self.0, e.span) { return }\n+        if in_macro(self.0, e.span) {\n+            return;\n+        }\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n             ExprUnary(UnNot, ref inner) => {\n@@ -363,7 +382,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n                 } else {\n                     walk_expr(self, e);\n                 }\n-            },\n+            }\n             _ => walk_expr(self, e),\n         }\n     }"}, {"sha": "38e04723e53024780edb4c8a3994428a18c878cc", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -70,7 +70,7 @@ fn check_if(cx: &LateContext, e: &Expr) {\n                     db.span_suggestion(block.span, \"try\", snippet_block(cx, else_.span, \"..\").into_owned());\n                 });\n             }}\n-        } else if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n+        } else if let Some(&Expr { node: ExprIf(ref check_inner, ref content, None), span: sp, .. }) =\n                single_stmt_of_block(then) {\n             if e.span.expn_id != sp.expn_id {\n                 return;\n@@ -89,7 +89,7 @@ fn check_if(cx: &LateContext, e: &Expr) {\n \n fn requires_brackets(e: &Expr) -> bool {\n     match e.node {\n-        ExprBinary(Spanned {node: n, ..}, _, _) if n == BiEq => false,\n+        ExprBinary(Spanned { node: n, .. }, _, _) if n == BiEq => false,\n         _ => true,\n     }\n }"}, {"sha": "0eed34a8055fbd82c09a386b4e67e6107b2f2190", "filename": "src/consts.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -85,7 +85,9 @@ impl PartialEq for Constant {\n             (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => ls == rs && l_sty == r_sty,\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(l), &Constant::Int(r)) => l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked(),\n+            (&Constant::Int(l), &Constant::Int(r)) => {\n+                l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked()\n+            }\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n                 // `Fw32 == Fw64` so don\u2019t compare them\n@@ -131,7 +133,8 @@ impl Hash for Constant {\n             Constant::Bool(b) => {\n                 b.hash(state);\n             }\n-            Constant::Vec(ref v) | Constant::Tuple(ref v) => {\n+            Constant::Vec(ref v) |\n+            Constant::Tuple(ref v) => {\n                 v.hash(state);\n             }\n             Constant::Repeat(ref c, l) => {\n@@ -186,12 +189,16 @@ fn lit_to_constant(lit: &LitKind) -> Constant {\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U16)) => Constant::Int(ConstInt::U16(value as u16)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U32)) => Constant::Int(ConstInt::U32(value as u32)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32))),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n+            Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n+        }\n         LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32))),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n+            Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n+        }\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -285,7 +292,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n             let mut maybe_id = None;\n-            if let Some(&PathResolution { base_def: Def::Const(id), ..}) = lcx.tcx.def_map.borrow().get(&e.id) {\n+            if let Some(&PathResolution { base_def: Def::Const(id), .. }) = lcx.tcx.def_map.borrow().get(&e.id) {\n                 maybe_id = Some(id);\n             }\n             // separate if lets to avoid double borrowing the def_map\n@@ -324,7 +331,11 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     fn binop(&mut self, op: BinOp, left: &Expr, right: &Expr) -> Option<Constant> {\n-        let l = if let Some(l) = self.expr(left) { l } else { return None; };\n+        let l = if let Some(l) = self.expr(left) {\n+            l\n+        } else {\n+            return None;\n+        };\n         let r = self.expr(right);\n         match (op.node, l, r) {\n             (BiAdd, Constant::Int(l), Some(Constant::Int(r))) => (l + r).ok().map(Constant::Int),"}, {"sha": "aba4638ab8bb90e9a94d4e799af2afcbcf227def", "filename": "src/copies.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -71,7 +71,7 @@ impl LateLintPass for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if !in_macro(cx, expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n-            if let Some(&Expr{node: ExprIf(_, _, Some(ref else_expr)), ..}) = get_parent_expr(cx, expr) {\n+            if let Some(&Expr { node: ExprIf(_, _, Some(ref else_expr)), .. }) = get_parent_expr(cx, expr) {\n                 if else_expr.id == expr.id {\n                     return;\n                 }\n@@ -185,7 +185,8 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, ty::Ty<'tcx>>) {\n         match pat.node {\n-            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatKind::Box(ref pat) |\n+            PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n             PatKind::TupleStruct(_, Some(ref pats)) => {\n                 for pat in pats {\n                     bindings_impl(cx, pat, map);"}, {"sha": "e8a3a569a140c475e991d3d5b605c29f704df68c", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,12 +1,12 @@\n //! calculate cyclomatic complexity and warn about overly complex functions\n \n-use rustc::lint::*;\n use rustc::cfg::CFG;\n+use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, walk_expr};\n use syntax::ast::Attribute;\n-use syntax::attr::*;\n+use syntax::attr;\n use syntax::codemap::Span;\n \n use utils::{in_macro, LimitStack, span_help_and_lint};\n@@ -44,6 +44,7 @@ impl CyclomaticComplexity {\n         if in_macro(cx, span) {\n             return;\n         }\n+\n         let cfg = CFG::new(cx.tcx, block);\n         let n = cfg.graph.len_nodes() as u64;\n         let e = cfg.graph.len_edges() as u64;\n@@ -59,12 +60,7 @@ impl CyclomaticComplexity {\n             tcx: &cx.tcx,\n         };\n         helper.visit_block(block);\n-        let CCHelper {\n-            match_arms,\n-            divergence,\n-            short_circuits,\n-            ..\n-        } = helper;\n+        let CCHelper { match_arms, divergence, short_circuits, .. } = helper;\n \n         if cc + divergence < match_arms + short_circuits {\n             report_cc_bug(cx, cc, match_arms, divergence, short_circuits, span);\n@@ -84,7 +80,9 @@ impl CyclomaticComplexity {\n impl LateLintPass for CyclomaticComplexity {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemFn(_, _, _, _, _, ref block) = item.node {\n-            self.check(cx, block, item.span);\n+            if !attr::contains_name(&item.attrs, \"test\") {\n+                self.check(cx, block, item.span);\n+            }\n         }\n     }\n \n@@ -129,7 +127,8 @@ impl<'a, 'b, 'tcx> Visitor<'a> for CCHelper<'b, 'tcx> {\n                 walk_expr(self, e);\n                 let ty = self.tcx.node_id_to_type(callee.id);\n                 match ty.sty {\n-                    ty::TyFnDef(_, _, ty) | ty::TyFnPtr(ty) if ty.sig.skip_binder().output.diverges() => {\n+                    ty::TyFnDef(_, _, ty) |\n+                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output.diverges() => {\n                         self.divergence += 1;\n                     }\n                     _ => (),\n@@ -140,7 +139,7 @@ impl<'a, 'b, 'tcx> Visitor<'a> for CCHelper<'b, 'tcx> {\n                 walk_expr(self, e);\n                 match op.node {\n                     BiAnd | BiOr => self.short_circuits += 1,\n-                    _ => {},\n+                    _ => (),\n                 }\n             }\n             _ => walk_expr(self, e),\n@@ -153,10 +152,10 @@ fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, sp\n     span_bug!(span,\n               \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n                div = {}, shorts = {}. Please file a bug report.\",\n-               cc,\n-               narms,\n-               div,\n-               shorts);\n+              cc,\n+              narms,\n+              div,\n+              shorts);\n }\n #[cfg(not(feature=\"debugging\"))]\n fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, span: Span) {"}, {"sha": "c9ac8f0a948b99b1f917dad2d6e4f907bcb59c32", "filename": "src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::ast::{Attribute, MetaItemKind};\n use syntax::codemap::Span;\n-use utils::{CLONE_TRAIT_PATH, HASH_PATH};\n+use utils::paths;\n use utils::{match_path, span_lint_and_then};\n \n /// **What it does:** This lint warns about deriving `Hash` but implementing `PartialEq`\n@@ -88,7 +88,7 @@ impl LateLintPass for Derive {\n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>, hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n-        match_path(&trait_ref.path, &HASH_PATH),\n+        match_path(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n     ], {\n         let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n@@ -129,7 +129,7 @@ fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &CLONE_TRAIT_PATH) {\n+    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n         let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n         let subst_ty = ty.subst(cx.tcx, &parameter_environment.free_substs);\n "}, {"sha": "54d5366729e246042ee77a786f6023f13b74c562", "filename": "src/doc.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -142,10 +142,10 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n                     }\n                     '`' => {\n                         current_word_begin = jump_to!(chars, '`', len);\n-                    },\n+                    }\n                     '[' => {\n                         let end = jump_to!(chars, ']', len);\n-                        let link_text = &doc[current_word_begin+1..end];\n+                        let link_text = &doc[current_word_begin + 1..end];\n \n                         match chars.peek() {\n                             Some(&(_, c)) => {\n@@ -199,7 +199,7 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n         }\n \n         let s = if s.ends_with('s') {\n-            &s[..s.len()-1]\n+            &s[..s.len() - 1]\n         } else {\n             s\n         };\n@@ -223,6 +223,9 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n     }\n \n     if has_underscore(word) || word.contains(\"::\") || is_camel_case(word) {\n-        span_lint(cx, DOC_MARKDOWN, span, &format!(\"you should put `{}` between ticks in the documentation\", word));\n+        span_lint(cx,\n+                  DOC_MARKDOWN,\n+                  span,\n+                  &format!(\"you should put `{}` between ticks in the documentation\", word));\n     }\n }"}, {"sha": "69156f15f31767defe95506365ccd5b87d66e46c", "filename": "src/drop_ref.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdrop_ref.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -2,8 +2,7 @@ use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n use syntax::codemap::Span;\n-use utils::DROP_PATH;\n-use utils::{match_def_path, span_note_and_lint};\n+use utils::{match_def_path, paths, span_note_and_lint};\n \n /// **What it does:** This lint checks for calls to `std::mem::drop` with a reference instead of an owned value.\n ///\n@@ -37,7 +36,7 @@ impl LateLintPass for DropRefPass {\n         if let ExprCall(ref path, ref args) = expr.node {\n             if let ExprPath(None, _) = path.node {\n                 let def_id = cx.tcx.def_map.borrow()[&path.id].def_id();\n-                if match_def_path(cx, def_id, &DROP_PATH) {\n+                if match_def_path(cx, def_id, &paths::DROP) {\n                     if args.len() != 1 {\n                         return;\n                     }"}, {"sha": "d63d8c67c5d37955656bfbb90e4aabb1d440a440", "filename": "src/entry.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,10 +1,9 @@\n-use rustc::lint::*;\n use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, walk_expr, walk_block};\n+use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n-use utils::{BTREEMAP_PATH, HASHMAP_PATH};\n-use utils::{get_item_name, match_type, snippet, span_lint_and_then, walk_ptrs_ty};\n+use utils::{get_item_name, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty};\n \n /// **What it does:** This lint checks for uses of `contains_key` + `insert` on `HashMap` or\n /// `BTreeMap`.\n@@ -48,7 +47,7 @@ impl LateLintPass for HashMapLint {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = else_block.is_none() &&\n-                        ((then_block.expr.is_some() as usize) + then_block.stmts.len() == 1);\n+                                    ((then_block.expr.is_some() as usize) + then_block.stmts.len() == 1);\n \n                     let mut visitor = InsertVisitor {\n                         cx: cx,\n@@ -89,10 +88,10 @@ fn check_cond<'a, 'tcx, 'b>(cx: &'a LateContext<'a, 'tcx>, check: &'b Expr) -> O\n         let map = &params[0];\n         let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(map));\n \n-        return if match_type(cx, obj_ty, &BTREEMAP_PATH) {\n+        return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n             Some((\"BTreeMap\", map, key))\n         }\n-        else if match_type(cx, obj_ty, &HASHMAP_PATH) {\n+        else if match_type(cx, obj_ty, &paths::HASHMAP) {\n             Some((\"HashMap\", map, key))\n         }\n         else {"}, {"sha": "37a89069d1927d3c9c5d18ebeab5bed5106af5e6", "filename": "src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_glob_use.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -54,7 +54,7 @@ impl EnumGlobUse {\n                         let child = cx.sess().cstore.item_children(def.def_id());\n                         if let Some(child) = child.first() {\n                             if let DefLike::DlDef(Def::Variant(..)) = child.def {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");   \n+                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n                             }\n                         }\n                     }"}, {"sha": "83abe215aa713d3df38269b633cb5d1060042455", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -60,9 +60,10 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 let fn_ty = cx.tcx.expr_ty(caller);\n                 match fn_ty.sty {\n                     // Is it an unsafe function? They don't implement the closure traits\n-                    ty::TyFnDef(_, _, fn_ty) | ty::TyFnPtr(fn_ty) => {\n+                    ty::TyFnDef(_, _, fn_ty) |\n+                    ty::TyFnPtr(fn_ty) => {\n                         if fn_ty.unsafety == Unsafety::Unsafe ||\n-                            fn_ty.sig.skip_binder().output == ty::FnOutput::FnDiverging {\n+                           fn_ty.sig.skip_binder().output == ty::FnOutput::FnDiverging {\n                             return;\n                         }\n                     }"}, {"sha": "0726fcaeab71eeb6bd317fb1a7b3f6986f9ccb41", "filename": "src/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformat.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,9 +1,9 @@\n+use rustc::hir::*;\n use rustc::hir::map::Node::NodeItem;\n use rustc::lint::*;\n use rustc::ty::TypeVariants;\n-use rustc::hir::*;\n use syntax::ast::LitKind;\n-use utils::{DISPLAY_FMT_METHOD_PATH, FMT_ARGUMENTS_NEWV1_PATH, STRING_PATH};\n+use utils::paths;\n use utils::{is_expn_of, match_path, match_type, span_lint, walk_ptrs_ty};\n \n /// **What it does:** This lints about use of `format!(\"string literal with no argument\")` and\n@@ -40,7 +40,7 @@ impl LateLintPass for FormatMacLint {\n                     if_let_chain!{[\n                         let ExprPath(_, ref path) = fun.node,\n                         args.len() == 2,\n-                        match_path(path, &FMT_ARGUMENTS_NEWV1_PATH),\n+                        match_path(path, &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -108,11 +108,11 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n         let ExprPath(None, ref path) = args[1].node,\n-        match_path(path, &DISPLAY_FMT_METHOD_PATH)\n+        match_path(path, &paths::DISPLAY_FMT_METHOD)\n     ], {\n         let ty = walk_ptrs_ty(cx.tcx.pat_ty(&pat[0]));\n \n-        return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &STRING_PATH);\n+        return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &paths::STRING);\n     }}\n \n     false"}, {"sha": "37b65e471fa26e32285bc6808ee2815c69763fc9", "filename": "src/functions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -31,9 +31,7 @@ pub struct Functions {\n \n impl Functions {\n     pub fn new(threshold: u64) -> Functions {\n-        Functions {\n-            threshold: threshold\n-        }\n+        Functions { threshold: threshold }\n     }\n }\n \n@@ -49,7 +47,8 @@ impl LateLintPass for Functions {\n \n         if let Some(NodeItem(ref item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n             match item.node {\n-                hir::ItemImpl(_, _, _, Some(_), _, _) | hir::ItemDefaultImpl(..) => return,\n+                hir::ItemImpl(_, _, _, Some(_), _, _) |\n+                hir::ItemDefaultImpl(..) => return,\n                 _ => (),\n             }\n         }\n@@ -68,7 +67,9 @@ impl Functions {\n     fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n-            span_lint(cx, TOO_MANY_ARGUMENTS, span,\n+            span_lint(cx,\n+                      TOO_MANY_ARGUMENTS,\n+                      span,\n                       &format!(\"this function has to many arguments ({}/{})\", args, self.threshold));\n         }\n     }"}, {"sha": "ebc2ce76fec96f7c6c64e16ba2af0f26db75a550", "filename": "src/if_not_else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fif_not_else.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -37,15 +37,15 @@ impl EarlyLintPass for IfNotElse {\n                                            item.span,\n                                            \"Unnecessary boolean `not` operation\",\n                                            \"remove the `!` and swap the blocks of the if/else\");\n-                    },\n+                    }\n                     ExprKind::Binary(ref kind, _, _) if kind.node == BinOpKind::Ne => {\n                         span_help_and_lint(cx,\n                                            IF_NOT_ELSE,\n                                            item.span,\n                                            \"Unnecessary `!=` operation\",\n                                            \"change to `==` and swap the blocks of the if/else\");\n-                    },\n-                    _ => {},\n+                    }\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "7a7a17bc79d19fb77e334e2bc82144b870f71567", "filename": "src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -64,7 +64,7 @@ impl LateLintPass for LenZero {\n             return;\n         }\n \n-        if let ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) = expr.node {\n+        if let ExprBinary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n             match cmp {\n                 BiEq => check_cmp(cx, expr.span, left, right, \"\"),\n                 BiGt | BiNe => check_cmp(cx, expr.span, left, right, \"!\"),\n@@ -155,7 +155,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n }\n \n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let Spanned{node: LitKind::Int(0, _), ..} = *lit {\n+    if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n         if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n                 db.span_suggestion(span,\n@@ -199,7 +199,8 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n               .map_or(false, |ids| ids.iter().any(|i| is_is_empty(cx, i)))\n         }\n         ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, &id)),\n-        ty::TyEnum(ref id, _) | ty::TyStruct(ref id, _) => has_is_empty_impl(cx, &id.did),\n+        ty::TyEnum(ref id, _) |\n+        ty::TyStruct(ref id, _) => has_is_empty_impl(cx, &id.did),\n         ty::TyArray(..) | ty::TyStr => true,\n         _ => false,\n     }"}, {"sha": "c1a7732e3f5b1c62babd839883915d5f1311bcb5", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -325,6 +325,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::SINGLE_CHAR_PATTERN,\n+        methods::TEMPORARY_CSTRING_AS_PTR,\n         methods::WRONG_SELF_CONVENTION,\n         minmax::MIN_MAX,\n         misc::CMP_NAN,"}, {"sha": "67dfabe2569cacf3053c5eaedc2bdf9161849318", "filename": "src/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -127,7 +127,7 @@ fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, fun\n         match slf.node {\n             SelfRegion(ref opt_lt, _, _) => input_visitor.record(opt_lt),\n             SelfExplicit(ref ty, _) => walk_ty(&mut input_visitor, ty),\n-            _ => {}\n+            _ => (),\n         }\n     }\n     // extract lifetimes in input argument types\n@@ -243,7 +243,8 @@ impl<'v, 't> RefVisitor<'v, 't> {\n             if params.lifetimes.is_empty() {\n                 if let Some(def) = self.cx.tcx.def_map.borrow().get(&ty.id).map(|r| r.full_def()) {\n                     match def {\n-                        Def::TyAlias(def_id) | Def::Struct(def_id) => {\n+                        Def::TyAlias(def_id) |\n+                        Def::Struct(def_id) => {\n                             let type_scheme = self.cx.tcx.lookup_item_type(def_id);\n                             for _ in type_scheme.generics.regions.as_slice() {\n                                 self.record(&None);\n@@ -255,7 +256,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                                 self.record(&None);\n                             }\n                         }\n-                        _ => {}\n+                        _ => (),\n                     }\n                 }\n             }\n@@ -277,7 +278,7 @@ impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n             TyPath(_, ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             }\n-            _ => {}\n+            _ => (),\n         }\n         walk_ty(self, ty);\n     }\n@@ -353,7 +354,7 @@ fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics,\n         match slf.node {\n             SelfRegion(Some(ref lt), _, _) => checker.visit_lifetime(lt),\n             SelfExplicit(ref t, _) => walk_ty(&mut checker, t),\n-            _ => {}\n+            _ => (),\n         }\n     }\n "}, {"sha": "0b341f645df3d2d3f3725ef98ada369a10867455", "filename": "src/loops.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -14,9 +14,9 @@ use std::collections::HashMap;\n use syntax::ast;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then,\n-            unsugar_range, walk_ptrs_ty, recover_for_loop};\n-use utils::{BTREEMAP_PATH, HASHMAP_PATH, LL_PATH, OPTION_PATH, RESULT_PATH, VEC_PATH};\n+            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, unsugar_range,\n+            walk_ptrs_ty, recover_for_loop};\n+use utils::paths;\n use utils::UnsugaredRange;\n \n /// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index.\n@@ -247,7 +247,8 @@ impl LateLintPass for LoopsPass {\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n-                        MatchSource::Normal | MatchSource::IfLetDesugar{..} => {\n+                        MatchSource::Normal |\n+                        MatchSource::IfLetDesugar { .. } => {\n                             if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n                                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n                                is_break_expr(&arms[1].body) {\n@@ -505,7 +506,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n /// Check for `for` loops over `Option`s and `Results`\n fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n     let ty = cx.tcx.expr_ty(arg);\n-    if match_type(cx, ty, &OPTION_PATH) {\n+    if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(cx,\n                            FOR_LOOP_OVER_OPTION,\n                            arg.span,\n@@ -515,7 +516,7 @@ fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n                            &format!(\"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n                                     snippet(cx, pat.span, \"_\"),\n                                     snippet(cx, arg.span, \"_\")));\n-    } else if match_type(cx, ty, &RESULT_PATH) {\n+    } else if match_type(cx, ty, &paths::RESULT) {\n         span_help_and_lint(cx,\n                            FOR_LOOP_OVER_RESULT,\n                            arg.span,\n@@ -589,7 +590,7 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n             };\n \n             let ty = walk_ptrs_ty(cx.tcx.expr_ty(arg));\n-            if match_type(cx, ty, &HASHMAP_PATH) || match_type(cx, ty, &BTREEMAP_PATH) {\n+            if match_type(cx, ty, &paths::HASHMAP) || match_type(cx, ty, &paths::BTREEMAP) {\n                 span_lint_and_then(cx,\n                                    FOR_KV_MAP,\n                                    expr.span,\n@@ -735,13 +736,13 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // will allow further borrows afterwards\n     let ty = cx.tcx.expr_ty(e);\n     is_iterable_array(ty) ||\n-    match_type(cx, ty, &VEC_PATH) ||\n-    match_type(cx, ty, &LL_PATH) ||\n-    match_type(cx, ty, &HASHMAP_PATH) ||\n+    match_type(cx, ty, &paths::VEC) ||\n+    match_type(cx, ty, &paths::LINKED_LIST) ||\n+    match_type(cx, ty, &paths::HASHMAP) ||\n     match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"]) ||\n     match_type(cx, ty, &[\"collections\", \"vec_deque\", \"VecDeque\"]) ||\n     match_type(cx, ty, &[\"collections\", \"binary_heap\", \"BinaryHeap\"]) ||\n-    match_type(cx, ty, &BTREEMAP_PATH) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n     match_type(cx, ty, &[\"collections\", \"btree\", \"set\", \"BTreeSet\"])\n }\n \n@@ -779,7 +780,8 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n         Some(ref expr) => Some(expr),\n         None if !block.stmts.is_empty() => {\n             match block.stmts[0].node {\n-                StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n+                StmtExpr(ref expr, _) |\n+                StmtSemi(ref expr, _) => Some(expr),\n                 _ => None,\n             }\n         }"}, {"sha": "caefb64eb5f1f45b412b6a6965d15dfa2a0a9440", "filename": "src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{CLONE_PATH, OPTION_PATH};\n-use utils::{is_adjusted, match_path, match_trait_method, match_type, snippet, span_help_and_lint, walk_ptrs_ty,\n-            walk_ptrs_ty_depth};\n+use utils::{is_adjusted, match_path, match_trait_method, match_type, paths, snippet,\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n /// **What it does:** This lint checks for mapping clone() over an iterator.\n ///\n@@ -65,7 +64,7 @@ impl LateLintPass for MapClonePass {\n                         }\n                     }\n                     ExprPath(_, ref path) => {\n-                        if match_path(path, &CLONE_PATH) {\n+                        if match_path(path, &paths::CLONE) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                             span_help_and_lint(cx,\n                                                MAP_CLONE,\n@@ -99,7 +98,7 @@ fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n     if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n         Some(\"iterator\")\n-    } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &OPTION_PATH) {\n+    } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &paths::OPTION) {\n         Some(\"Option\")\n     } else {\n         None"}, {"sha": "bce93b717a36c16ad31c910ef87931fa707dc945", "filename": "src/matches.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -8,7 +8,7 @@ use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n-use utils::{COW_PATH, OPTION_PATH, RESULT_PATH};\n+use utils::paths;\n use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice.\n@@ -184,13 +184,13 @@ fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n \n fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n-    let candidates = &[(&COW_PATH, \"Borrowed\"),\n-                       (&COW_PATH, \"Cow::Borrowed\"),\n-                       (&COW_PATH, \"Cow::Owned\"),\n-                       (&COW_PATH, \"Owned\"),\n-                       (&OPTION_PATH, \"None\"),\n-                       (&RESULT_PATH, \"Err\"),\n-                       (&RESULT_PATH, \"Ok\")];\n+    let candidates = &[(&paths::COW, \"Borrowed\"),\n+                       (&paths::COW, \"Cow::Borrowed\"),\n+                       (&paths::COW, \"Cow::Owned\"),\n+                       (&paths::COW, \"Owned\"),\n+                       (&paths::OPTION, \"None\"),\n+                       (&paths::RESULT, \"Err\"),\n+                       (&paths::RESULT, \"Ok\")];\n \n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, Some(ref inner)) => {\n@@ -252,19 +252,20 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n \n             if let Some((ref true_expr, ref false_expr)) = exprs {\n                 match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                    (false, false) =>\n+                    (false, false) => {\n                         Some(format!(\"if {} {} else {}\",\n                                      snippet(cx, ex.span, \"b\"),\n                                      expr_block(cx, true_expr, None, \"..\"),\n-                                     expr_block(cx, false_expr, None, \"..\"))),\n-                    (false, true) =>\n-                        Some(format!(\"if {} {}\",\n-                                     snippet(cx, ex.span, \"b\"),\n-                                     expr_block(cx, true_expr, None, \"..\"))),\n-                    (true, false) =>\n+                                     expr_block(cx, false_expr, None, \"..\")))\n+                    }\n+                    (false, true) => {\n+                        Some(format!(\"if {} {}\", snippet(cx, ex.span, \"b\"), expr_block(cx, true_expr, None, \"..\")))\n+                    }\n+                    (true, false) => {\n                         Some(format!(\"try\\nif !{} {}\",\n                                      snippet(cx, ex.span, \"b\"),\n-                                     expr_block(cx, false_expr, None, \"..\"))),\n+                                     expr_block(cx, false_expr, None, \"..\")))\n+                    }\n                     (true, true) => None,\n                 }\n             } else {\n@@ -312,9 +313,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n                                expr.span,\n                                \"you don't need to add `&` to both the expression and the patterns\",\n                                |db| {\n-                                   db.span_suggestion(expr.span,\n-                                                      \"try\",\n-                                                      template);\n+                                   db.span_suggestion(expr.span, \"try\", template);\n                                });\n         } else {\n             let template = match_template(cx, expr.span, source, \"*\", ex);\n@@ -324,7 +323,8 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n                                \"you don't need to add `&` to all patterns\",\n                                |db| {\n                                    db.span_suggestion(expr.span,\n-                                                      \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n+                                                      \"instead of prefixing all patterns with `&`, you can \\\n+                                                       dereference the expression\",\n                                                       template);\n                                });\n         }\n@@ -373,17 +373,18 @@ type TypedRanges = Vec<SpannedRange<ConstInt>>;\n /// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway and other types than\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n-    ranges.iter().filter_map(|range| {\n-        if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n-            Some(SpannedRange {\n-                span: range.span,\n-                node: (start, end),\n-            })\n-        } else {\n-            None\n-        }\n-    })\n-    .collect()\n+    ranges.iter()\n+          .filter_map(|range| {\n+              if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n+                  Some(SpannedRange {\n+                      span: range.span,\n+                      node: (start, end),\n+                  })\n+              } else {\n+                  None\n+              }\n+          })\n+          .collect()\n }\n \n fn is_unit_expr(expr: &Expr) -> bool {\n@@ -416,7 +417,7 @@ fn match_template(cx: &LateContext, span: Span, source: MatchSource, op: &str, e\n         MatchSource::IfLetDesugar { .. } => format!(\"if let .. = {}{} {{ .. }}\", op, expr_snippet),\n         MatchSource::WhileLetDesugar => format!(\"while let .. = {}{} {{ .. }}\", op, expr_snippet),\n         MatchSource::ForLoopDesugar => span_bug!(span, \"for loop desugared to match with &-patterns!\"),\n-        MatchSource::TryDesugar => span_bug!(span, \"`?` operator desugared to match with &-patterns!\")\n+        MatchSource::TryDesugar => span_bug!(span, \"`?` operator desugared to match with &-patterns!\"),\n     }\n }\n \n@@ -432,13 +433,15 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n     impl<'a, T: Copy> Kind<'a, T> {\n         fn range(&self) -> &'a SpannedRange<T> {\n             match *self {\n-                Kind::Start(_, r) | Kind::End(_, r) => r,\n+                Kind::Start(_, r) |\n+                Kind::End(_, r) => r,\n             }\n         }\n \n         fn value(self) -> T {\n             match self {\n-                Kind::Start(t, _) | Kind::End(t, _) => t,\n+                Kind::Start(t, _) |\n+                Kind::End(t, _) => t,\n             }\n         }\n     }"}, {"sha": "4a31a564a3e63e0aa728e7e5746dab4b31b9f114", "filename": "src/methods.rs", "status": "modified", "additions": 68, "deletions": 19, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -13,9 +13,8 @@ use syntax::ptr::P;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, snippet_opt, span_lint,\n             span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n-use utils::{BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH,\n-            VEC_PATH};\n use utils::MethodArgs;\n+use utils::paths;\n \n #[derive(Clone)]\n pub struct MethodsPass;\n@@ -286,6 +285,33 @@ declare_lint! {\n      `_.split(\\\"x\\\")`\"\n }\n \n+/// **What it does:** This lint checks for getting the inner pointer of a temporary `CString`.\n+///\n+/// **Why is this bad?** The inner pointer of a `CString` is only valid as long as the `CString` is\n+/// alive.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// let c_str = CString::new(\"foo\").unwrap().as_ptr();\n+/// unsafe {\n+/// call_some_ffi_func(c_str);\n+/// }\n+/// ```\n+/// Here `c_str` point to a freed address. The correct use would be:\n+/// ```rust,ignore\n+/// let c_str = CString::new(\"foo\").unwrap();\n+/// unsafe {\n+/// call_some_ffi_func(c_str.as_ptr());\n+/// }\n+/// ```\n+declare_lint! {\n+    pub TEMPORARY_CSTRING_AS_PTR,\n+    Warn,\n+    \"getting the inner pointer of a temporary `CString`\"\n+}\n+\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EXTEND_FROM_SLICE,\n@@ -303,7 +329,8 @@ impl LintPass for MethodsPass {\n                     CLONE_DOUBLE_REF,\n                     NEW_RET_NO_SELF,\n                     SINGLE_CHAR_PATTERN,\n-                    SEARCH_IS_SOME)\n+                    SEARCH_IS_SOME,\n+                    TEMPORARY_CSTRING_AS_PTR)\n     }\n }\n \n@@ -334,7 +361,11 @@ impl LateLintPass for MethodsPass {\n                     lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"extend\"]) {\n                     lint_extend(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"unwrap\", \"as_ptr\"]) {\n+                    lint_cstring_as_ptr(cx, expr, &arglists[0][0], &arglists[1][0]);\n                 }\n+\n+\n                 lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n                 if args.len() == 1 && name.node.as_str() == \"clone\" {\n                     lint_clone_on_copy(cx, expr);\n@@ -405,7 +436,8 @@ impl LateLintPass for MethodsPass {\n                     }\n \n                     let ret_ty = return_ty(cx, implitem.id);\n-                    if &name.as_str() == &\"new\" && !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n+                    if &name.as_str() == &\"new\" &&\n+                       !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n                         span_lint(cx,\n                                   NEW_RET_NO_SELF,\n                                   sig.explicit_self.span,\n@@ -438,7 +470,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.expr_ty(arg);\n-                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH) {\n+                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n                         default_trait_id\n                     } else {\n                         return false;\n@@ -465,13 +497,13 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n     fn check_general_case(cx: &LateContext, name: &str, fun: &Expr, self_expr: &Expr, arg: &Expr, or_has_args: bool,\n                           span: Span) {\n         // (path, fn_has_argument, methods)\n-        let know_types: &[(&[_], _, &[_], _)] = &[(&BTREEMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n-                                                  (&HASHMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n-                                                  (&OPTION_PATH,\n+        let know_types: &[(&[_], _, &[_], _)] = &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+                                                  (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+                                                  (&paths::OPTION,\n                                                    false,\n                                                    &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"],\n                                                    \"else\"),\n-                                                  (&RESULT_PATH, true, &[\"or\", \"unwrap_or\"], \"else\")];\n+                                                  (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n \n         let self_ty = cx.tcx.expr_ty(self_expr);\n \n@@ -539,7 +571,7 @@ fn lint_clone_double_ref(cx: &LateContext, expr: &Expr, arg: &Expr) {\n \n fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-    if !match_type(cx, obj_ty, &VEC_PATH) {\n+    if !match_type(cx, obj_ty, &paths::VEC) {\n         return;\n     }\n     let arg_ty = cx.tcx.expr_ty(&args[1]);\n@@ -554,11 +586,27 @@ fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     }\n }\n \n+fn lint_cstring_as_ptr(cx: &LateContext, expr: &Expr, new: &Expr, unwrap: &Expr) {\n+    if_let_chain!{[\n+        let ExprCall(ref fun, ref args) = new.node,\n+        args.len() == 1,\n+        let ExprPath(None, ref path) = fun.node,\n+        match_path(path, &paths::CSTRING_NEW),\n+    ], {\n+        span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n+                           \"you are getting the inner pointer of a temporary `CString`\",\n+                           |db| {\n+                               db.fileline_note(expr.span, \"that pointer will be invalid outside this expression\");\n+                               db.span_help(unwrap.span, \"assign the `CString` to a variable to extend its lifetime\");\n+                           });\n+    }}\n+}\n+\n fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span, &'static str)> {\n     fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n-            ty::TyStruct(..) => match_type(cx, ty, &VEC_PATH),\n+            ty::TyStruct(..) => match_type(cx, ty, &paths::VEC),\n             ty::TyArray(_, size) => size < 32,\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n             ty::TyBox(ref inner) => may_slice(cx, inner),\n@@ -593,9 +641,9 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span,\n fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n \n-    let mess = if match_type(cx, obj_ty, &OPTION_PATH) {\n+    let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if match_type(cx, obj_ty, &RESULT_PATH) {\n+    } else if match_type(cx, obj_ty, &paths::RESULT) {\n         Some((RESULT_UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -618,7 +666,7 @@ fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n /// lint use of `ok().expect()` for `Result`s\n fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n     // lint if the caller of `ok()` is a `Result`\n-    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &RESULT_PATH) {\n+    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tcx.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type) {\n             if has_debug_impl(error_type, cx) {\n@@ -636,7 +684,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n /// lint use of `map().unwrap_or()` for `Option`s\n fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling \\\n                    `map_or(a, f)` instead\";\n@@ -667,7 +715,7 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwr\n /// lint use of `map().unwrap_or_else()` for `Option`s\n fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling \\\n                    `map_or_else(g, f)` instead\";\n@@ -794,7 +842,7 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &Expr, arg: &Expr) {\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n-    if !match_type(cx, ty, &RESULT_PATH) {\n+    if !match_type(cx, ty, &paths::RESULT) {\n         return None;\n     }\n     if let ty::TyEnum(_, substs) = ty.sty {\n@@ -805,7 +853,7 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     None\n }\n \n-/// This checks whether a given type is known to implement `Debug`.\n+/// This checks whether a given type is known to implement Debug.\n fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n         Some(debug) => implements_trait(cx, ty, debug, Vec::new()),\n@@ -899,7 +947,8 @@ impl SelfKind {\n             (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) |\n             (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) |\n             (&SelfKind::No, &SelfStatic) => true,\n-            (&SelfKind::Ref, &SelfValue(_)) | (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n+            (&SelfKind::Ref, &SelfValue(_)) |\n+            (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n             (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n             _ => false,\n         }"}, {"sha": "7cd2d33cab949ab9c487bcc554d4f8e43a9c6fcb", "filename": "src/minmax.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -34,7 +34,9 @@ impl LateLintPass for MinMaxPass {\n                     return;\n                 }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n-                    (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n+                    (_, None) |\n+                    (MinMax::Max, Some(Ordering::Less)) |\n+                    (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n                     }"}, {"sha": "7323f18a46e239a6777dfe88ad3245859a206475", "filename": "src/misc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -226,7 +226,7 @@ impl LateLintPass for CmpOwned {\n \n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n-        ExprMethodCall(Spanned{node: ref name, ..}, _, ref args) if args.len() == 1 => {\n+        ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n             if name.as_str() == \"to_string\" || name.as_str() == \"to_owned\" && is_str_arg(cx, args) {\n                 (cx.tcx.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n@@ -309,7 +309,7 @@ impl LintPass for ModuloOne {\n impl LateLintPass for ModuloOne {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n-            if let Spanned {node: BinOp_::BiRem, ..} = *cmp {\n+            if let Spanned { node: BinOp_::BiRem, .. } = *cmp {\n                 if is_integer_literal(right, 1) {\n                     span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n@@ -422,7 +422,8 @@ impl LateLintPass for UsedUnderscoreBinding {\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(ref parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            ExprAssign(_, ref rhs) |\n+            ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n             _ => is_used(cx, &parent),\n         }\n     } else {"}, {"sha": "b43359f29b98d0c983737d72e3392a637bdb1aa8", "filename": "src/misc_early.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -134,11 +134,11 @@ impl EarlyLintPass for MiscEarly {\n                                        expr.span,\n                                        \"Try not to call a closure in the expression where it is declared.\",\n                                        |db| {\n-                                            if decl.inputs.is_empty() {\n-                                                let hint = format!(\"{}\", snippet(cx, block.span, \"..\"));\n-                                                db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n-                                            }\n-                                        });\n+                                           if decl.inputs.is_empty() {\n+                                               let hint = format!(\"{}\", snippet(cx, block.span, \"..\"));\n+                                               db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n+                                           }\n+                                       });\n                 }\n             }\n         }"}, {"sha": "7b7b5ecdf4e7918e816e9d8ccdf298d72bdccf7c", "filename": "src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -52,7 +52,7 @@ fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n \n     unwrap_addr(expr).map_or((), |e| {\n         unwrap_addr(e).map_or_else(|| {\n-                                       if let TyRef(_, TypeAndMut{mutbl: MutMutable, ..}) = cx.tcx.expr_ty(e).sty {\n+                                       if let TyRef(_, TypeAndMut { mutbl: MutMutable, .. }) = cx.tcx.expr_ty(e).sty {\n                                            span_lint(cx,\n                                                      MUT_MUT,\n                                                      expr.span,\n@@ -71,7 +71,7 @@ fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n \n fn unwrap_mut(ty: &Ty) -> Option<&Ty> {\n     match ty.node {\n-        TyRptr(_, MutTy{ ty: ref pty, mutbl: MutMutable }) => Some(pty),\n+        TyRptr(_, MutTy { ty: ref pty, mutbl: MutMutable }) => Some(pty),\n         _ => None,\n     }\n }"}, {"sha": "4ac4d83360ee65588e1fcdc55e49c716d8a29b1e", "filename": "src/mut_reference.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -47,27 +47,28 @@ impl LateLintPass for UnnecessaryMutPassed {\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 check_arguments(cx, &arguments, method_type.ty, &name.node.as_str())\n             }\n-            _ => {}\n+            _ => (),\n         }\n     }\n }\n \n fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &TyS, name: &str) {\n     match type_definition.sty {\n-        TypeVariants::TyFnDef(_, _, ref fn_type) | TypeVariants::TyFnPtr(ref fn_type) => {\n+        TypeVariants::TyFnDef(_, _, ref fn_type) |\n+        TypeVariants::TyFnPtr(ref fn_type) => {\n             let parameters = &fn_type.sig.skip_binder().inputs;\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    TypeVariants::TyRef(_, TypeAndMut {mutbl: MutImmutable, ..}) |\n-                    TypeVariants::TyRawPtr(TypeAndMut {mutbl: MutImmutable, ..}) => {\n+                    TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |\n+                    TypeVariants::TyRawPtr(TypeAndMut { mutbl: MutImmutable, .. }) => {\n                         if let ExprAddrOf(MutMutable, _) = argument.node {\n                             span_lint(cx,\n                                       UNNECESSARY_MUT_PASSED,\n                                       argument.span,\n                                       &format!(\"The function/method \\\"{}\\\" doesn't need a mutable reference\", name));\n                         }\n                     }\n-                    _ => {}\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "7d637adb8b8b05a4b55563dbb7d8559cdae87c32", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::subst::ParamSpace;\n use rustc::ty;\n use rustc::hir::Expr;\n use syntax::ast;\n-use utils::{span_lint, MUTEX_PATH, match_type};\n+use utils::{match_type, paths, span_lint};\n \n /// **What it does:** This lint checks for usages of `Mutex<X>` where an atomic will do.\n ///\n@@ -47,7 +47,7 @@ impl LateLintPass for MutexAtomic {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         let ty = cx.tcx.expr_ty(expr);\n         if let ty::TyStruct(_, subst) = ty.sty {\n-            if match_type(cx, ty, &MUTEX_PATH) {\n+            if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = &subst.types.get(ParamSpace::TypeSpace, 0).sty;\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\"}, {"sha": "f95d6f5c9c1b5547a0ddceb3f9f8f8882841c8de", "filename": "src/needless_bool.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -57,9 +57,10 @@ impl LateLintPass for NeedlessBool {\n                 span_lint_and_then(cx,\n                                    NEEDLESS_BOOL,\n                                    e.span,\n-                                   \"this if-then-else expression returns a bool literal\", |db| {\n-                    db.span_suggestion(e.span, \"you can reduce it to\", hint);\n-                });\n+                                   \"this if-then-else expression returns a bool literal\",\n+                                   |db| {\n+                                       db.span_suggestion(e.span, \"you can reduce it to\", hint);\n+                                   });\n             };\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                 (RetBool(true), RetBool(true)) |\n@@ -98,7 +99,7 @@ impl LintPass for BoolComparison {\n impl LateLintPass for BoolComparison {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         use self::Expression::*;\n-        if let ExprBinary(Spanned{ node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n+        if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n@@ -155,15 +156,17 @@ enum Expression {\n fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         ([], Some(e)) => fetch_bool_expr(&**e),\n-        ([ref e], None) => if let StmtSemi(ref e, _) = e.node {\n-            if let ExprRet(_) = e.node {\n-                fetch_bool_expr(&**e)\n+        ([ref e], None) => {\n+            if let StmtSemi(ref e, _) = e.node {\n+                if let ExprRet(_) = e.node {\n+                    fetch_bool_expr(&**e)\n+                } else {\n+                    Expression::Other\n+                }\n             } else {\n                 Expression::Other\n             }\n-        } else {\n-            Expression::Other\n-        },\n+        }\n         _ => Expression::Other,\n     }\n }\n@@ -177,11 +180,13 @@ fn fetch_bool_expr(expr: &Expr) -> Expression {\n             } else {\n                 Expression::Other\n             }\n-        },\n-        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n-            Expression::Bool(value) => Expression::RetBool(value),\n-            _ => Expression::Other,\n-        },\n+        }\n+        ExprRet(Some(ref expr)) => {\n+            match fetch_bool_expr(expr) {\n+                Expression::Bool(value) => Expression::RetBool(value),\n+                _ => Expression::Other,\n+            }\n+        }\n         _ => Expression::Other,\n     }\n }"}, {"sha": "f42b1d0d74a5bb92e957480253ebdc06ce8226d1", "filename": "src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnew_without_default.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,10 +1,10 @@\n-use rustc::lint::*;\n-use rustc::hir;\n use rustc::hir::intravisit::FnKind;\n+use rustc::hir;\n+use rustc::lint::*;\n use syntax::ast;\n use syntax::codemap::Span;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint,\n-            DEFAULT_TRAIT_PATH};\n+use utils::paths;\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint};\n \n /// **What it does:** This lints about type with a `fn new() -> Self` method and no `Default`\n /// implementation.\n@@ -54,7 +54,7 @@ impl LateLintPass for NewWithoutDefault {\n                     self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n                     let Some(ret_ty) = return_ty(cx, id),\n                     same_tys(cx, self_ty, ret_ty, id),\n-                    let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH),\n+                    let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n                     !implements_trait(cx, self_ty, default_trait_id, Vec::new())\n                 ], {\n                     span_lint(cx, NEW_WITHOUT_DEFAULT, span,"}, {"sha": "d928de415787209e20e89a0ca4285ac4fe8ee632", "filename": "src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fno_effect.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -52,7 +52,8 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n             }\n         }\n         Expr_::ExprBlock(ref block) => {\n-            block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n+            block.stmts.is_empty() &&\n+            if let Some(ref expr) = block.expr {\n                 has_no_effect(cx, expr)\n             } else {\n                 false"}, {"sha": "a6f0571c4993afaa9c8458876f975d3e97ebf384", "filename": "src/non_expressive_names.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnon_expressive_names.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -45,7 +45,7 @@ struct ExistingName {\n     interned: InternedString,\n     span: Span,\n     len: usize,\n-    whitelist: &'static[&'static str],\n+    whitelist: &'static [&'static str],\n }\n \n struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n@@ -57,6 +57,7 @@ struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n \n // this list contains lists of names that are allowed to be similar\n // the assumption is that no name is ever contained in multiple lists.\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n const WHITELIST: &'static [&'static [&'static str]] = &[\n     &[\"parsed\", \"parser\"],\n     &[\"lhs\", \"rhs\"],\n@@ -75,7 +76,7 @@ impl<'v, 'a, 'b, 'c> visit::Visitor<'v> for SimilarNamesNameVisitor<'a, 'b, 'c>\n     }\n }\n \n-fn get_whitelist(interned_name: &str) -> Option<&'static[&'static str]> {\n+fn get_whitelist(interned_name: &str) -> Option<&'static [&'static str]> {\n     for &allow in WHITELIST {\n         if whitelisted(interned_name, allow) {\n             return Some(allow);\n@@ -112,8 +113,7 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n             span_lint(self.0.cx,\n                       MANY_SINGLE_CHAR_NAMES,\n                       span,\n-                      &format!(\"{}th binding whose name is just one char\",\n-                               self.0.single_char_names.len()));\n+                      &format!(\"{}th binding whose name is just one char\", self.0.single_char_names.len()));\n         }\n     }\n     fn check_name(&mut self, span: Span, name: Name) {\n@@ -162,7 +162,8 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                     } else {\n                         let second_last_i = interned_chars.next_back().expect(\"we know we have at least three chars\");\n                         let second_last_e = existing_chars.next_back().expect(\"we know we have at least three chars\");\n-                        if !eq_or_numeric(second_last_i, second_last_e) || second_last_i == '_' || !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n+                        if !eq_or_numeric(second_last_i, second_last_e) || second_last_i == '_' ||\n+                           !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n                             // allowed similarity foo_x, foo_y\n                             // or too many chars differ (foo_x, boo_y) or (foox, booy)\n                             continue;\n@@ -172,7 +173,8 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                 } else {\n                     let second_i = interned_chars.next().expect(\"we know we have at least two chars\");\n                     let second_e = existing_chars.next().expect(\"we know we have at least two chars\");\n-                    if !eq_or_numeric(second_i, second_e) || second_i == '_' || !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n+                    if !eq_or_numeric(second_i, second_e) || second_i == '_' ||\n+                       !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n                         // allowed similarity x_foo, y_foo\n                         // or too many chars differ (x_foo, y_boo) or (xfoo, yboo)\n                         continue;\n@@ -187,10 +189,11 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                                |diag| {\n                                    diag.span_note(existing_name.span, \"existing binding defined here\");\n                                    if let Some(split) = split_at {\n-                                       diag.span_help(span, &format!(\"separate the discriminating character \\\n-                                                                      by an underscore like: `{}_{}`\",\n-                                                                     &interned_name[..split],\n-                                                                     &interned_name[split..]));\n+                                       diag.span_help(span,\n+                                                      &format!(\"separate the discriminating character by an \\\n+                                                                underscore like: `{}_{}`\",\n+                                                               &interned_name[..split],\n+                                                               &interned_name[split..]));\n                                    }\n                                });\n             return;"}, {"sha": "1d760599e3fb5d10f9a32fa94c55b9074399120a", "filename": "src/open_options.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,8 +1,8 @@\n-use rustc::lint::*;\n use rustc::hir::{Expr, ExprMethodCall, ExprLit};\n+use rustc::lint::*;\n use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n-use utils::{walk_ptrs_ty_depth, match_type, span_lint, OPEN_OPTIONS_PATH};\n+use utils::{match_type, paths, span_lint, walk_ptrs_ty_depth};\n \n /// **What it does:** This lint checks for duplicate open options as well as combinations that make no sense.\n ///\n@@ -31,7 +31,7 @@ impl LateLintPass for NonSensicalOpenOptions {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n-            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &OPEN_OPTIONS_PATH) {\n+            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);\n@@ -61,11 +61,11 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n         let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n-        if match_type(cx, obj_ty, &OPEN_OPTIONS_PATH) && arguments.len() >= 2 {\n+        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n \n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {\n-                    if let Spanned {node: LitKind::Bool(lit), ..} = **span {\n+                    if let Spanned { node: LitKind::Bool(lit), .. } = **span {\n                         if lit {\n                             Argument::True\n                         } else {\n@@ -96,7 +96,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n                 \"write\" => {\n                     options.push((OpenOption::Write, argument_option));\n                 }\n-                _ => {}\n+                _ => (),\n             }\n \n             get_open_options(cx, &arguments[0], options);"}, {"sha": "6a8ca368fc143ab57f9005802ba262715be2e139", "filename": "src/overflow_check_conditional.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow_check_conditional.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{span_lint};\n+use utils::span_lint;\n \n /// **What it does:** This lint finds classic underflow / overflow checks.\n ///"}, {"sha": "78499fa1a1aa7bdc77d2992032897d87b31801be", "filename": "src/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpanic.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,7 +1,7 @@\n-use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::lint::*;\n use syntax::ast::LitKind;\n-use utils::{span_lint, is_direct_expn_of, match_path, BEGIN_UNWIND};\n+use utils::{is_direct_expn_of, match_path, paths, span_lint};\n \n /// **What it does:** This lint checks for missing parameters in `panic!`.\n ///\n@@ -33,7 +33,7 @@ impl LateLintPass for PanicPass {\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n             let ExprPath(None, ref path) = fun.node,\n-            match_path(path, &BEGIN_UNWIND),\n+            match_path(path, &paths::BEGIN_UNWIND),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "825a1b84450d275748eb87d5c8d3b643ea5e3dba", "filename": "src/precedence.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -31,7 +31,7 @@ impl LintPass for Precedence {\n \n impl EarlyLintPass for Precedence {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if let ExprKind::Binary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.node {\n             if !is_bit_op(op) {\n                 return;\n             }\n@@ -75,7 +75,9 @@ impl EarlyLintPass for Precedence {\n                 if let Some(slf) = args.first() {\n                     if let ExprKind::Lit(ref lit) = slf.node {\n                         match lit.node {\n-                            LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => {\n+                            LitKind::Int(..) |\n+                            LitKind::Float(..) |\n+                            LitKind::FloatUnsuffixed(..) => {\n                                 span_lint(cx,\n                                           PRECEDENCE,\n                                           expr.span,\n@@ -94,7 +96,7 @@ impl EarlyLintPass for Precedence {\n \n fn is_arith_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprKind::Binary(Spanned { node: op, ..}, _, _) => is_arith_op(op),\n+        ExprKind::Binary(Spanned { node: op, .. }, _, _) => is_arith_op(op),\n         _ => false,\n     }\n }"}, {"sha": "d426286dba480fe3cac36de26344e1601218f404", "filename": "src/print.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprint.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,7 +1,7 @@\n+use rustc::hir::*;\n use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n-use rustc::hir::*;\n-use utils::{FMT_ARGUMENTV1_NEW_PATH, DEBUG_FMT_METHOD_PATH, IO_PRINT_PATH};\n+use utils::paths;\n use utils::{is_expn_of, match_path, span_lint};\n \n /// **What it does:** This lint warns whenever you print on *stdout*. The purpose of this lint is to catch debugging remnants.\n@@ -45,7 +45,7 @@ impl LateLintPass for PrintLint {\n             if let ExprPath(_, ref path) = fun.node {\n                 // Search for `std::io::_print(..)` which is unique in a\n                 // `print!` expansion.\n-                if match_path(path, &IO_PRINT_PATH) {\n+                if match_path(path, &paths::IO_PRINT) {\n                     if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n                         // `println!` uses `print!`.\n                         let (span, name) = match is_expn_of(cx, span, \"println\") {\n@@ -58,9 +58,9 @@ impl LateLintPass for PrintLint {\n                 }\n                 // Search for something like\n                 // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-                else if args.len() == 2 && match_path(path, &FMT_ARGUMENTV1_NEW_PATH) {\n+                else if args.len() == 2 && match_path(path, &paths::FMT_ARGUMENTV1_NEW) {\n                     if let ExprPath(None, ref path) = args[1].node {\n-                        if match_path(path, &DEBUG_FMT_METHOD_PATH) && !is_in_debug_impl(cx, expr) &&\n+                        if match_path(path, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n                            is_expn_of(cx, expr.span, \"panic\").is_none() {\n                             span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n                         }"}, {"sha": "addcfc9e84d1b9e4701908cb06012206cdb70fd1", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -1,12 +1,11 @@\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n+use rustc::hir::*;\n use rustc::hir::map::NodeItem;\n use rustc::lint::*;\n use rustc::ty;\n-use rustc::hir::*;\n use syntax::ast::NodeId;\n-use utils::{STRING_PATH, VEC_PATH};\n-use utils::{span_lint, match_type};\n+use utils::{match_type, paths, span_lint};\n \n /// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless the references are mutable.\n ///\n@@ -61,13 +60,13 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n \n     for (arg, ty) in decl.inputs.iter().zip(&fn_ty.inputs) {\n         if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n-            if match_type(cx, ty, &VEC_PATH) {\n+            if match_type(cx, ty, &paths::VEC) {\n                 span_lint(cx,\n                           PTR_ARG,\n                           arg.ty.span,\n                           \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n                            with non-Vec-based slices. Consider changing the type to `&[...]`\");\n-            } else if match_type(cx, ty, &STRING_PATH) {\n+            } else if match_type(cx, ty, &paths::STRING) {\n                 span_lint(cx,\n                           PTR_ARG,\n                           arg.ty.span,"}, {"sha": "72a33757027e3aadbd54786c344d2bda68f7b4b5", "filename": "src/regex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fregex.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -9,7 +9,7 @@ use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::{Span, BytePos};\n use syntax::parse::token::InternedString;\n-use utils::{is_expn_of, match_path, match_type, REGEX_NEW_PATH, span_lint, span_help_and_lint};\n+use utils::{is_expn_of, match_path, match_type, paths, span_lint, span_help_and_lint};\n \n /// **What it does:** This lint checks `Regex::new(_)` invocations for correct regex syntax.\n ///\n@@ -72,8 +72,8 @@ impl LateLintPass for RegexPass {\n         if_let_chain!{[\n             self.last.is_none(),\n             let Some(ref expr) = block.expr,\n-            match_type(cx, cx.tcx.expr_ty(expr), &[\"regex\", \"re\", \"Regex\"]),\n-            let Some(span) = is_expn_of(cx, expr.span, \"regex\")\n+            match_type(cx, cx.tcx.expr_ty(expr), &paths::REGEX),\n+            let Some(span) = is_expn_of(cx, expr.span, \"regex\"),\n         ], {\n             if !self.spans.contains(&span) {\n                 span_lint(cx,\n@@ -97,7 +97,7 @@ impl LateLintPass for RegexPass {\n         if_let_chain!{[\n             let ExprCall(ref fun, ref args) = expr.node,\n             let ExprPath(_, ref path) = fun.node,\n-            match_path(path, &REGEX_NEW_PATH) && args.len() == 1\n+            match_path(path, &paths::REGEX_NEW) && args.len() == 1\n         ], {\n             if let ExprLit(ref lit) = args[0].node {\n                 if let LitKind::Str(ref r, _) = lit.node {\n@@ -166,14 +166,14 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n \n     match *s {\n         Expr::Empty | Expr::StartText | Expr::EndText => Some(\"the regex is unlikely to be useful as it is\"),\n-        Expr::Literal {..} => Some(\"consider using `str::contains`\"),\n+        Expr::Literal { .. } => Some(\"consider using `str::contains`\"),\n         Expr::Concat(ref exprs) => {\n             match exprs.len() {\n                 2 => {\n                     match (&exprs[0], &exprs[1]) {\n                         (&Expr::StartText, &Expr::EndText) => Some(\"consider using `str::is_empty`\"),\n-                        (&Expr::StartText, &Expr::Literal {..}) => Some(\"consider using `str::starts_with`\"),\n-                        (&Expr::Literal {..}, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n+                        (&Expr::StartText, &Expr::Literal { .. }) => Some(\"consider using `str::starts_with`\"),\n+                        (&Expr::Literal { .. }, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n                         _ => None,\n                     }\n                 }"}, {"sha": "d78938212634ba6e39366f1689a500390880ce0f", "filename": "src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -71,7 +71,7 @@ impl ReturnPass {\n                     self.check_final_expr(cx, &arm.body);\n                 }\n             }\n-            _ => {}\n+            _ => (),\n         }\n     }\n "}, {"sha": "bb287f449e3f85a78cd23e6333f12c94361852ca", "filename": "src/shadow.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -77,7 +77,8 @@ fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(ref decl, _) => check_decl(cx, decl, bindings),\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n+            StmtExpr(ref e, _) |\n+            StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n         }\n     }\n     if let Some(ref o) = block.expr {\n@@ -94,7 +95,7 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n         return;\n     }\n     if let DeclLocal(ref local) = decl.node {\n-        let Local{ ref pat, ref ty, ref init, span, .. } = **local;\n+        let Local { ref pat, ref ty, ref init, span, .. } = **local;\n         if let Some(ref t) = *ty {\n             check_ty(cx, t, bindings)\n         }\n@@ -109,7 +110,8 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n \n fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n     match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-        Some(Def::Variant(..)) | Some(Def::Struct(..)) => false,\n+        Some(Def::Variant(..)) |\n+        Some(Def::Struct(..)) => false,\n         _ => true,\n     }\n }\n@@ -251,7 +253,8 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n         ExprBox(ref e) => check_expr(cx, e, bindings),\n-        ExprBlock(ref block) | ExprLoop(ref block, _) => check_block(cx, block, bindings),\n+        ExprBlock(ref block) |\n+        ExprLoop(ref block, _) => check_block(cx, block, bindings),\n         // ExprCall\n         // ExprMethodCall\n         ExprVec(ref v) | ExprTup(ref v) => {\n@@ -297,8 +300,8 @@ fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, expr, bindings);\n         }\n-        TyPtr(MutTy{ ty: ref mty, .. }) |\n-        TyRptr(_, MutTy{ ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n+        TyPtr(MutTy { ty: ref mty, .. }) |\n+        TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n         TyTup(ref tup) => {\n             for ref t in tup {\n                 check_ty(cx, t, bindings)"}, {"sha": "92bce8d0e4201e1fcd131dbf2c1d8dbae433ae32", "filename": "src/strings.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -3,12 +3,11 @@\n //! Note that since we have two lints where one subsumes the other, we try to\n //! disable the subsumed lint unless it has a higher level\n \n-use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::lint::*;\n use syntax::codemap::Spanned;\n-use utils::STRING_PATH;\n use utils::SpanlessEq;\n-use utils::{match_type, span_lint, span_lint_and_then, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, paths, span_lint, span_lint_and_then, walk_ptrs_ty, get_parent_expr};\n \n /// **What it does:** This lint matches code of the form `x = x + y` (without `let`!).\n ///\n@@ -75,7 +74,7 @@ impl LintPass for StringAdd {\n \n impl LateLintPass for StringAdd {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if let ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) = e.node {\n+        if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if let Allow = cx.current_level(STRING_ADD_ASSIGN) {\n                     // the string_add_assign is allow, so no duplicates\n@@ -108,12 +107,12 @@ impl LateLintPass for StringAdd {\n }\n \n fn is_string(cx: &LateContext, e: &Expr) -> bool {\n-    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &STRING_PATH)\n+    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &paths::STRING)\n }\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n+        ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         }\n@@ -146,8 +145,7 @@ impl LateLintPass for StringLitAsBytes {\n                                                e.span,\n                                                \"calling `as_bytes()` on a string literal\",\n                                                |db| {\n-                                                   let sugg = format!(\"b{}\",\n-                                                                      snippet(cx, args[0].span, r#\"\"foo\"\"#));\n+                                                   let sugg = format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#));\n                                                    db.span_suggestion(e.span,\n                                                                       \"consider using a byte string literal instead\",\n                                                                       sugg);"}, {"sha": "1496a45dac2499ae445fd5183c4eed2d9246ea25", "filename": "src/temporary_assignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftemporary_assignment.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -18,8 +18,7 @@ declare_lint! {\n \n fn is_temporary(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprStruct(..) |\n-        ExprTup(..) => true,\n+        ExprStruct(..) | ExprTup(..) => true,\n         _ => false,\n     }\n }\n@@ -37,7 +36,8 @@ impl LateLintPass for TemporaryAssignmentPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprAssign(ref target, _) = expr.node {\n             match target.node {\n-                ExprField(ref base, _) | ExprTupField(ref base, _) => {\n+                ExprField(ref base, _) |\n+                ExprTupField(ref base, _) => {\n                     if is_temporary(base) && !is_adjusted(cx, base) {\n                         span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                     }"}, {"sha": "2217fd59bd96594f4901c79bc73d7719f8ac20c3", "filename": "src/transmute.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftransmute.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -2,8 +2,7 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n use rustc::ty;\n use rustc::hir::*;\n-use utils::TRANSMUTE_PATH;\n-use utils::{match_def_path, snippet_opt, span_lint, span_lint_and_then};\n+use utils::{match_def_path, paths, snippet_opt, span_lint, span_lint_and_then};\n \n /// **What it does:** This lint checks for transmutes to the original type of the object.\n ///\n@@ -53,11 +52,7 @@ pub struct Transmute;\n \n impl LintPass for Transmute {\n     fn get_lints(&self) -> LintArray {\n-        lint_array! [\n-            CROSSPOINTER_TRANSMUTE,\n-            TRANSMUTE_PTR_TO_REF,\n-            USELESS_TRANSMUTE\n-        ]\n+        lint_array![CROSSPOINTER_TRANSMUTE, TRANSMUTE_PTR_TO_REF, USELESS_TRANSMUTE]\n     }\n }\n \n@@ -67,7 +62,7 @@ impl LateLintPass for Transmute {\n             if let ExprPath(None, _) = path_expr.node {\n                 let def_id = cx.tcx.def_map.borrow()[&path_expr.id].def_id();\n \n-                if match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n+                if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n                     let from_ty = cx.tcx.expr_ty(&args[0]);\n                     let to_ty = cx.tcx.expr_ty(e);\n \n@@ -80,12 +75,16 @@ impl LateLintPass for Transmute {\n                         span_lint(cx,\n                                   CROSSPOINTER_TRANSMUTE,\n                                   e.span,\n-                                  &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty));\n+                                  &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                                           from_ty,\n+                                           to_ty));\n                     } else if is_ptr_to(from_ty, to_ty) {\n                         span_lint(cx,\n                                   CROSSPOINTER_TRANSMUTE,\n                                   e.span,\n-                                  &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\", from_ty, to_ty));\n+                                  &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                                           from_ty,\n+                                           to_ty));\n                     } else {\n                         check_ptr_to_ref(cx, from_ty, to_ty, e, &args[0]);\n                     }\n@@ -103,10 +102,7 @@ fn is_ptr_to(from: ty::Ty, to: ty::Ty) -> bool {\n     }\n }\n \n-fn check_ptr_to_ref<'tcx>(cx: &LateContext,\n-                          from_ty: ty::Ty<'tcx>,\n-                          to_ty: ty::Ty<'tcx>,\n-                          e: &Expr, arg: &Expr) {\n+fn check_ptr_to_ref<'tcx>(cx: &LateContext, from_ty: ty::Ty<'tcx>, to_ty: ty::Ty<'tcx>, e: &Expr, arg: &Expr) {\n     if let TyRawPtr(ref from_pty) = from_ty.sty {\n         if let TyRef(_, ref to_rty) = to_ty.sty {\n             let mess = format!(\"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n@@ -123,8 +119,7 @@ fn check_ptr_to_ref<'tcx>(cx: &LateContext,\n \n                     let sugg = if from_pty.ty == to_rty.ty {\n                         format!(\"{}{}\", deref, arg)\n-                    }\n-                    else {\n+                    } else {\n                         format!(\"{}({} as {} {})\", deref, arg, cast, to_rty.ty)\n                     };\n "}, {"sha": "43d42cde501866984706b1de4b1e0b2b43f74cf0", "filename": "src/types.rs", "status": "modified", "additions": 69, "deletions": 47, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -6,7 +6,9 @@ use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n-use utils::*;\n+use utils::{comparisons, in_external_macro, in_macro, is_from_for_desugar, match_def_path, snippet,\n+            span_help_and_lint, span_lint};\n+use utils::paths;\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -63,7 +65,7 @@ impl LateLintPass for TypePass {\n                             let Some(ref vec) = ag.types.get(0),\n                             let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n                             let def::Def::Struct(..) = did.full_def(),\n-                            match_def_path(cx, did.def_id(), &VEC_PATH),\n+                            match_def_path(cx, did.def_id(), &paths::VEC),\n                         ],\n                         {\n                             span_help_and_lint(cx,\n@@ -73,7 +75,7 @@ impl LateLintPass for TypePass {\n                                                \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                         }\n                     }\n-                } else if match_def_path(cx, did.def_id(), &LL_PATH) {\n+                } else if match_def_path(cx, did.def_id(), &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n                                        LINKEDLIST,\n                                        ast_ty.span,\n@@ -246,7 +248,8 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n \n fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     match typ.sty {\n-        ty::TyInt(IntTy::Is) | ty::TyUint(UintTy::Us) => true,\n+        ty::TyInt(IntTy::Is) |\n+        ty::TyUint(UintTy::Us) => true,\n         _ => false,\n     }\n }\n@@ -534,9 +537,7 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n     fn visit_ty(&mut self, ty: &'v Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n-            TyInfer |\n-            TyPtr(..) |\n-            TyRptr(..) => (1, 0),\n+            TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n \n             // the \"normal\" components of a type: named types, arrays/tuples\n             TyPath(..) |\n@@ -661,17 +662,17 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n     Some(match rel {\n         Rel::Lt => {\n             match (lx, rx) {\n-                (Some(l @ Extr { which: Maximum, ..}), _) => (l, AlwaysFalse), // max < x\n-                (_, Some(r @ Extr { which: Minimum, ..})) => (r, AlwaysFalse), // x < min\n+                (Some(l @ Extr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n+                (_, Some(r @ Extr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n                 _ => return None,\n             }\n         }\n         Rel::Le => {\n             match (lx, rx) {\n-                (Some(l @ Extr { which: Minimum, ..}), _) => (l, AlwaysTrue), // min <= x\n-                (Some(l @ Extr { which: Maximum, ..}), _) => (l, InequalityImpossible), //max <= x\n-                (_, Some(r @ Extr { which: Minimum, ..})) => (r, InequalityImpossible), // x <= min\n-                (_, Some(r @ Extr { which: Maximum, ..})) => (r, AlwaysTrue), // x <= max\n+                (Some(l @ Extr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n+                (Some(l @ Extr { which: Maximum, .. }), _) => (l, InequalityImpossible), //max <= x\n+                (_, Some(r @ Extr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n+                (_, Some(r @ Extr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n                 _ => return None,\n             }\n         }\n@@ -700,14 +701,12 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n \n     let which = match (ty, cv) {\n         (&ty::TyBool, Bool(false)) |\n-\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MIN)))) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MIN)))) |\n         (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MIN))) |\n         (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MIN))) |\n         (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MIN))) |\n         (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MIN))) |\n-\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MIN)))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MIN)))) |\n         (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MIN))) |\n@@ -716,14 +715,12 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MIN))) => Minimum,\n \n         (&ty::TyBool, Bool(true)) |\n-\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MAX)))) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MAX)))) |\n         (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MAX))) |\n         (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MAX))) |\n         (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MAX))) |\n         (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MAX))) |\n-\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MAX)))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MAX)))) |\n         (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MAX))) |\n@@ -843,22 +840,26 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n-    if let ExprCast(ref cast_exp,_) = expr.node {\n+    if let ExprCast(ref cast_exp, _) = expr.node {\n         match cx.tcx.expr_ty(cast_exp).sty {\n-            TyInt(int_ty) => Some(match int_ty {\n-                IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),\n-                IntTy::I16 => (FullInt::S(i16::min_value() as i64), FullInt::S(i16::max_value() as i64)),\n-                IntTy::I32 => (FullInt::S(i32::min_value() as i64), FullInt::S(i32::max_value() as i64)),\n-                IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n-                IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n-            }),\n-            TyUint(uint_ty) => Some(match uint_ty {\n-                UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n-                UintTy::U16 => (FullInt::U(u16::min_value() as u64), FullInt::U(u16::max_value() as u64)),\n-                UintTy::U32 => (FullInt::U(u32::min_value() as u64), FullInt::U(u32::max_value() as u64)),\n-                UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n-                UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n-            }),\n+            TyInt(int_ty) => {\n+                Some(match int_ty {\n+                    IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),\n+                    IntTy::I16 => (FullInt::S(i16::min_value() as i64), FullInt::S(i16::max_value() as i64)),\n+                    IntTy::I32 => (FullInt::S(i32::min_value() as i64), FullInt::S(i32::max_value() as i64)),\n+                    IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n+                    IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n+                })\n+            }\n+            TyUint(uint_ty) => {\n+                Some(match uint_ty {\n+                    UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n+                    UintTy::U16 => (FullInt::U(u16::min_value() as u64), FullInt::U(u16::max_value() as u64)),\n+                    UintTy::U32 => (FullInt::U(u32::min_value() as u64), FullInt::U(u32::max_value() as u64)),\n+                    UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n+                    UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n+                })\n+            }\n             _ => None,\n         }\n     } else {\n@@ -883,29 +884,26 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n             } else {\n                 None\n             }\n-        },\n+        }\n         Err(_) => None,\n     }\n }\n \n fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: bool) {\n     if let ExprCast(ref cast_val, _) = expr.node {\n-        span_lint(\n-            cx,\n-            INVALID_UPCAST_COMPARISONS,\n-            *span,\n-            &format!(\n+        span_lint(cx,\n+                  INVALID_UPCAST_COMPARISONS,\n+                  *span,\n+                  &format!(\n                 \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n                 snippet(cx, cast_val.span, \"the expression\"),\n                 if always { \"true\" } else { \"false\" },\n-            )\n-        );\n+            ));\n     }\n }\n \n-fn upcast_comparison_bounds_err(\n-        cx: &LateContext, span: &Span, rel: comparisons::Rel,\n-        lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n+fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons::Rel,\n+                                lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n     use utils::comparisons::*;\n \n     if let Some((lb, ub)) = lhs_bounds {\n@@ -915,14 +913,38 @@ fn upcast_comparison_bounds_err(\n                     err_upcast_comparison(cx, &span, lhs, rel == Rel::Ne);\n                 }\n             } else if match rel {\n-                Rel::Lt => if invert { norm_rhs_val < lb } else { ub < norm_rhs_val },\n-                Rel::Le => if invert { norm_rhs_val <= lb  } else { ub <= norm_rhs_val },\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val < lb\n+                    } else {\n+                        ub < norm_rhs_val\n+                    }\n+                }\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val <= lb\n+                    } else {\n+                        ub <= norm_rhs_val\n+                    }\n+                }\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, &span, lhs, true)\n             } else if match rel {\n-                Rel::Lt => if invert { norm_rhs_val >= ub } else { lb >= norm_rhs_val },\n-                Rel::Le => if invert { norm_rhs_val > ub } else { lb > norm_rhs_val },\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val >= ub\n+                    } else {\n+                        lb >= norm_rhs_val\n+                    }\n+                }\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val > ub\n+                    } else {\n+                        lb > norm_rhs_val\n+                    }\n+                }\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, &span, lhs, false)"}, {"sha": "e773cc0e02505f49838614c8df4b2b6ece21176b", "filename": "src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fconf.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -8,7 +8,8 @@ use toml;\n pub fn conf_file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::InternedString>, (&'static str, codemap::Span)> {\n     for arg in args {\n         match arg.node {\n-            ast::MetaItemKind::Word(ref name) | ast::MetaItemKind::List(ref name, _) => {\n+            ast::MetaItemKind::Word(ref name) |\n+            ast::MetaItemKind::List(ref name, _) => {\n                 if name == &\"conf_file\" {\n                     return Err((\"`conf_file` must be a named value\", arg.span));\n                 }"}, {"sha": "379812a283d5e25aec93e9921949342b9a57eafa", "filename": "src/utils/hir.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -76,7 +76,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n-                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr))\n+                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n+                    l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                })\n             }\n             (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n@@ -114,9 +116,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 both(l_qself, r_qself, |l, r| self.eq_qself(l, r)) && self.eq_path(l_subpath, r_subpath)\n             }\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_path(l_path, r_path) &&\n-                    both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n-                    over(lf, rf, |l, r| self.eq_field(l, r))\n+                self.eq_path(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),"}, {"sha": "d8f5a0757b79f734ca49857c773f50fd06cb9735", "filename": "src/utils/mod.rs", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -22,44 +22,10 @@ use syntax::ptr::P;\n pub mod comparisons;\n pub mod conf;\n mod hir;\n+pub mod paths;\n pub use self::hir::{SpanlessEq, SpanlessHash};\n-pub type MethodArgs = HirVec<P<Expr>>;\n \n-// module DefPaths for certain structs/enums we check for\n-pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n-pub const BOX_NEW_PATH: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n-pub const BTREEMAP_ENTRY_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n-pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n-pub const CLONE_PATH: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n-pub const CLONE_TRAIT_PATH: [&'static str; 2] = [\"clone\", \"Clone\"];\n-pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n-pub const DEBUG_FMT_METHOD_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n-pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n-pub const DISPLAY_FMT_METHOD_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\"];\n-pub const DROP_PATH: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n-pub const FMT_ARGUMENTS_NEWV1_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTV1_NEW_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n-pub const HASHMAP_ENTRY_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n-pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n-pub const HASH_PATH: [&'static str; 2] = [\"hash\", \"Hash\"];\n-pub const IO_PRINT_PATH: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n-pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n-pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n-pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n-pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const RANGE_FROM_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FULL_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n-pub const RANGE_INCLUSIVE_NON_EMPTY_PATH: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n-pub const RANGE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n-pub const RANGE_TO_INCLUSIVE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n-pub const REGEX_NEW_PATH: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n-pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n-pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n-pub const TRANSMUTE_PATH: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n-pub const VEC_FROM_ELEM_PATH: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n-pub const VEC_PATH: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n-pub const BOX_PATH: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n+pub type MethodArgs = HirVec<P<Expr>>;\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n@@ -178,7 +144,8 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n /// Check if type is struct or enum type with given def path.\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n+        ty::TyEnum(ref adt, _) |\n+        ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n@@ -338,9 +305,9 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n-        Some(Node::NodeItem(&Item{ ref name, .. })) |\n-        Some(Node::NodeTraitItem(&TraitItem{ ref name, .. })) |\n-        Some(Node::NodeImplItem(&ImplItem{ ref name, .. })) => Some(*name),\n+        Some(Node::NodeItem(&Item { ref name, .. })) |\n+        Some(Node::NodeTraitItem(&TraitItem { ref name, .. })) |\n+        Some(Node::NodeImplItem(&ImplItem { ref name, .. })) => Some(*name),\n         _ => None,\n     }\n }\n@@ -465,7 +432,7 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(ref block) => Some(block),\n-            Node::NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n+            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n             _ => None,\n         }\n     } else {\n@@ -551,7 +518,8 @@ pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint,\n /// Return the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {\n-        ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n+        ty::TyRef(_, ref tm) |\n+        ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty,\n     }\n }\n@@ -560,7 +528,8 @@ pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n         match ty.sty {\n-            ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => inner(tm.ty, depth + 1),\n+            ty::TyRef(_, ref tm) |\n+            ty::TyRawPtr(ref tm) => inner(tm.ty, depth + 1),\n             _ => (ty, depth),\n         }\n     }\n@@ -763,23 +732,47 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n \n     match unwrap_unstable(&expr).node {\n         ExprPath(None, ref path) => {\n-            if match_path(path, &RANGE_FULL_PATH) {\n-                Some(UnsugaredRange { start: None, end: None, limits: RangeLimits::HalfOpen })\n+            if match_path(path, &paths::RANGE_FULL) {\n+                Some(UnsugaredRange {\n+                    start: None,\n+                    end: None,\n+                    limits: RangeLimits::HalfOpen,\n+                })\n             } else {\n                 None\n             }\n         }\n         ExprStruct(ref path, ref fields, None) => {\n-            if match_path(path, &RANGE_FROM_PATH) {\n-                Some(UnsugaredRange { start: get_field(\"start\", fields), end: None, limits: RangeLimits::HalfOpen })\n-            } else if match_path(path, &RANGE_INCLUSIVE_NON_EMPTY_PATH) {\n-                Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n-            } else if match_path(path, &RANGE_PATH) {\n-                Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n-            } else if match_path(path, &RANGE_TO_INCLUSIVE_PATH) {\n-                Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n-            } else if match_path(path, &RANGE_TO_PATH) {\n-                Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+            if match_path(path, &paths::RANGE_FROM) {\n+                Some(UnsugaredRange {\n+                    start: get_field(\"start\", fields),\n+                    end: None,\n+                    limits: RangeLimits::HalfOpen,\n+                })\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+                Some(UnsugaredRange {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::Closed,\n+                })\n+            } else if match_path(path, &paths::RANGE) {\n+                Some(UnsugaredRange {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::HalfOpen,\n+                })\n+            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n+                Some(UnsugaredRange {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::Closed,\n+                })\n+            } else if match_path(path, &paths::RANGE_TO) {\n+                Some(UnsugaredRange {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::HalfOpen,\n+                })\n             } else {\n                 None\n             }"}, {"sha": "88d0dd415aad1860ffc0a229407c324f2c38cf59", "filename": "src/utils/paths.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fpaths.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -0,0 +1,38 @@\n+//! This module contains paths to types and functions Clippy needs to know about.\n+\n+pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n+pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n+pub const BOX: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n+pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BTREEMAP: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const CLONE: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n+pub const CLONE_TRAIT: [&'static str; 2] = [\"clone\", \"Clone\"];\n+pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n+pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n+pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n+pub const DEFAULT_TRAIT: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n+pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\"];\n+pub const DROP: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n+pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n+pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASH: [&'static str; 2] = [\"hash\", \"Hash\"];\n+pub const IO_PRINT: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n+pub const LINKED_LIST: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const MUTEX: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n+pub const OPEN_OPTIONS: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n+pub const OPTION: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RANGE_FROM: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FULL: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n+pub const RANGE_TO_INCLUSIVE: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n+pub const REGEX: [&'static str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n+pub const REGEX_NEW: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n+pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n+pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];"}, {"sha": "63b9952c3c824a6995d69bbd110d3948607b25c1", "filename": "src/vec.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/src%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -3,8 +3,7 @@ use rustc::ty::TypeVariants;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n-use utils::VEC_FROM_ELEM_PATH;\n-use utils::{is_expn_of, match_path, recover_for_loop, snippet, span_lint_and_then};\n+use utils::{is_expn_of, match_path, paths, recover_for_loop, snippet, span_lint_and_then};\n \n /// **What it does:** This lint warns about using `&vec![..]` when using `&[..]` would be possible.\n ///\n@@ -64,8 +63,7 @@ fn check_vec_macro(cx: &LateContext, expr: &Expr, vec: &Expr) {\n                     };\n \n                     format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n-                }\n-                else {\n+                } else {\n                     \"&[]\".into()\n                 }\n             }\n@@ -92,7 +90,7 @@ pub fn unexpand_vec<'e>(cx: &LateContext, expr: &'e Expr) -> Option<VecArgs<'e>>\n         let ExprPath(_, ref path) = fun.node,\n         is_expn_of(cx, fun.span, \"vec\").is_some()\n     ], {\n-        return if match_path(path, &VEC_FROM_ELEM_PATH) && args.len() == 2 {\n+        return if match_path(path, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }"}, {"sha": "4b24f16eda77696ed9b9b376732d14b1a82e92ef", "filename": "tests/compile-fail/cyclomatic_complexity.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -171,6 +171,17 @@ fn bar() { //~ ERROR: the function has a cyclomatic complexity of 2\n     }\n }\n \n+#[test]\n+#[cyclomatic_complexity = \"0\"]\n+/// Tests are usually complex but simple at the same time. `cyclomatic_complexity` used to give\n+/// lots of false-positives in tests.\n+fn dont_warn_on_tests() {\n+    match 99 {\n+        0 => println!(\"hi\"),\n+        _ => println!(\"bye\"),\n+    }\n+}\n+\n #[cyclomatic_complexity = \"0\"]\n fn barr() { //~ ERROR: the function has a cyclomatic complexity of 2\n     match 99 {"}, {"sha": "1869fd12a69b32adab8295ffe43afb95a4ca7331", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -470,3 +470,15 @@ fn single_char_pattern() {\n     //~| HELP try using a char instead:\n     //~| SUGGESTION x.trim_right_matches('x');\n }\n+\n+#[allow(result_unwrap_used)]\n+fn temporary_cstring() {\n+    use std::ffi::CString;\n+\n+    ( // extra parenthesis to better test spans\n+    //~^ ERROR you are getting the inner pointer of a temporary `CString`\n+    //~| NOTE that pointer will be invalid outside this expression\n+        CString::new(\"foo\").unwrap()\n+        //~^ HELP assign the `CString` to a variable to extend its lifetime\n+    ).as_ptr();\n+}"}, {"sha": "6dcd1ff052459e64c9d74a3671366973b4b3615a", "filename": "tests/compile-test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -3,7 +3,7 @@ extern crate compiletest_rs as compiletest;\n use std::path::PathBuf;\n use std::env::var;\n \n-fn run_mode(mode: &'static str) {\n+fn run_mode(dir: &'static str, mode: &'static str) {\n     let mut config = compiletest::default_config();\n \n     let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n@@ -14,21 +14,21 @@ fn run_mode(mode: &'static str) {\n     }\n \n     config.mode = cfg_mode;\n-    config.src_base = PathBuf::from(format!(\"tests/{}\", mode));\n+    config.src_base = PathBuf::from(format!(\"tests/{}\", dir));\n \n     compiletest::run_tests(&config);\n }\n \n #[test]\n #[cfg(not(feature = \"test-regex_macros\"))]\n fn compile_test() {\n-    run_mode(\"run-pass\");\n-    run_mode(\"compile-fail\");\n+    run_mode(\"run-pass\", \"run-pass\");\n+    run_mode(\"compile-fail\", \"compile-fail\");\n }\n \n #[test]\n #[cfg(feature = \"test-regex_macros\")]\n fn compile_test() {\n-    run_mode(\"run-pass-regex_macros\");\n-    run_mode(\"compile-fail-regex_macros\");\n+    run_mode(\"run-pass-regex_macros\", \"run-pass\");\n+    run_mode(\"compile-fail-regex_macros\", \"compile-fail\");\n }"}, {"sha": "bf9728d4f58cc56be07ea06e95e09ba5a0825ce7", "filename": "util/update_lints.py", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63404ff4f211fc5ce06784e5b311b2da8c2711c7/util%2Fupdate_lints.py", "raw_url": "https://github.com/rust-lang/rust/raw/63404ff4f211fc5ce06784e5b311b2da8c2711c7/util%2Fupdate_lints.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_lints.py?ref=63404ff4f211fc5ce06784e5b311b2da8c2711c7", "patch": "@@ -135,7 +135,7 @@ def main(print_only=False, check=False):\n         return\n \n     # collect all lints from source files\n-    for root, dirs, files in os.walk('src'):\n+    for root, _, files in os.walk('src'):\n         for fn in files:\n             if fn.endswith('.rs'):\n                 collect(lints, deprecated_lints, os.path.join(root, fn))\n@@ -156,6 +156,15 @@ def main(print_only=False, check=False):\n         lambda: ['There are %d lints included in this crate:\\n' % len(lints)],\n         write_back=not check)\n \n+    # update the links in the CHANGELOG\n+    changed |= replace_region(\n+        'CHANGELOG.md',\n+        \"<!-- begin autogenerated links to wiki -->\",\n+        \"<!-- end autogenerated links to wiki -->\",\n+        lambda: [\"[`{0}`]: {1}#{0}\\n\".format(l[1], wiki_link) for l in\n+                 sorted(lints + deprecated_lints, key=lambda l: l[1])],\n+        replace_start=False, write_back=not check)\n+\n     # update the `pub mod` list\n     changed |= replace_region(\n         'src/lib.rs', r'begin lints modules', r'end lints modules',"}]}