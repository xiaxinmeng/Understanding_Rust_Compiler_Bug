{"sha": "2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYmJhNWJkYmFkZWVmNDAzYTY0ZTllMTU2OGNkYWQyMjVjYmNlYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-04T15:58:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-04T15:58:24Z"}, "message": "Auto merge of #43051 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 8 pull requests\n\n- Successful merges: #42227, #42836, #42975, #42994, #43041, #43042, #43043, #43045\n- Failed merges:", "tree": {"sha": "5c28e75455be93fe83569947dfe602866a56e6ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c28e75455be93fe83569947dfe602866a56e6ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "html_url": "https://github.com/rust-lang/rust/commit/2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de7f0617681fc94ecd0090d2dd2e4d70fea8f3a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/de7f0617681fc94ecd0090d2dd2e4d70fea8f3a2", "html_url": "https://github.com/rust-lang/rust/commit/de7f0617681fc94ecd0090d2dd2e4d70fea8f3a2"}, {"sha": "9cca462ca5faf348eb8a41d85193843fd6827434", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cca462ca5faf348eb8a41d85193843fd6827434", "html_url": "https://github.com/rust-lang/rust/commit/9cca462ca5faf348eb8a41d85193843fd6827434"}], "stats": {"total": 994, "additions": 561, "deletions": 433}, "files": [{"sha": "b54bab177d0aeb8b78f816b02b4bcb9c4afc0efe", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -51,6 +51,7 @@\n .hg/\n .hgignore\n .idea\n+*.iml\n __pycache__/\n *.py[cod]\n *$py.class"}, {"sha": "a1f018610753c801c34e0ab0f96a6f7d261b9590", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -40,8 +40,9 @@ Read [\"Installation\"] from [The Book].\n \n     > ***Note:*** Install locations can be adjusted by copying the config file\n     > from `./src/bootstrap/config.toml.example` to `./config.toml`, and\n-    > adjusting the `prefix` option under `[install]`. Various other options are\n-    > also supported, and are documented in the config file.\n+    > adjusting the `prefix` option under `[install]`. Various other options, such\n+    > as enabling debug information, are also supported, and are documented in\n+    > the config file.\n \n     When complete, `sudo ./x.py install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the"}, {"sha": "7232208b52234d278caf2a5d001ca04ee8261d8a", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -75,16 +75,11 @@ fn main() {\n         Err(_) => 0,\n     };\n \n-    // Build scripts always use the snapshot compiler which is guaranteed to be\n-    // able to produce an executable, whereas intermediate compilers may not\n-    // have the standard library built yet and may not be able to produce an\n-    // executable. Otherwise we just use the standard compiler we're\n-    // bootstrapping with.\n-    //\n-    // Also note that cargo will detect the version of the compiler to trigger\n-    // a rebuild when the compiler changes. If this happens, we want to make\n-    // sure to use the actual compiler instead of the snapshot compiler becase\n-    // that's the one that's actually changing.\n+    // Use a different compiler for build scripts, since there may not yet be a\n+    // libstd for the real compiler to use. However, if Cargo is attempting to\n+    // determine the version of the compiler, the real compiler needs to be\n+    // used. Currently, these two states are differentiated based on whether\n+    // --target and -vV is/isn't passed.\n     let (rustc, libdir) = if target.is_none() && version.is_none() {\n         (\"RUSTC_SNAPSHOT\", \"RUSTC_SNAPSHOT_LIBDIR\")\n     } else {"}, {"sha": "7c7161916ee2ce9c8ea8d96c3a49003a0670f309", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -42,10 +42,13 @@ use config::Target;\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    for target in build.config.target.iter() {\n+    //\n+    // This includes targets that aren't necessarily passed on the commandline\n+    // (FIXME: Perhaps it shouldn't?)\n+    for target in &build.config.target {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false)\n-           .target(target).host(&build.config.build);\n+           .target(target).host(&build.build);\n \n         let config = build.config.target_config.get(target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n@@ -64,10 +67,13 @@ pub fn find(build: &mut Build) {\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n-    for host in build.config.host.iter() {\n+    //\n+    // This includes hosts that aren't necessarily passed on the commandline\n+    // (FIXME: Perhaps it shouldn't?)\n+    for host in &build.config.host {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false).cpp(true)\n-           .target(host).host(&build.config.build);\n+           .target(host).host(&build.build);\n         let config = build.config.target_config.get(host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);"}, {"sha": "1153acfa57d39113b893ba8f78d2f9ba76e52f8e", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -23,12 +23,12 @@ use build_helper::output;\n use Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &'static str = \"1.20.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.20.0\";\n \n // An optional number to put after the label, e.g. '.2' -> '-beta.2'\n // Be sure to make this starts with a dot to conform to semver pre-release\n // versions (section 9)\n-pub const CFG_PRERELEASE_VERSION: &'static str = \".1\";\n+pub const CFG_PRERELEASE_VERSION: &str = \".1\";\n \n pub struct GitInfo {\n     inner: Option<Info>,\n@@ -99,6 +99,10 @@ impl GitInfo {\n             version.push_str(&inner.commit_date);\n             version.push_str(\")\");\n         }\n-        return version\n+        version\n+    }\n+\n+    pub fn is_git(&self) -> bool {\n+        self.inner.is_some()\n     }\n }"}, {"sha": "b3b5ae8d67d6551f97b6c54dd857831d02b18b3e", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -13,23 +13,22 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-extern crate build_helper;\n-\n use std::collections::HashSet;\n use std::env;\n+use std::iter;\n use std::fmt;\n use std::fs::{self, File};\n use std::path::{PathBuf, Path};\n use std::process::Command;\n use std::io::Read;\n \n-use build_helper::output;\n+use build_helper::{self, output};\n \n use {Build, Compiler, Mode};\n use dist;\n use util::{self, dylib_path, dylib_path_var, exe};\n \n-const ADB_TEST_DIR: &'static str = \"/data/tmp/work\";\n+const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n /// The two modes of the test runner; tests or benchmarks.\n #[derive(Copy, Clone)]\n@@ -60,7 +59,7 @@ impl fmt::Display for TestKind {\n }\n \n fn try_run(build: &Build, cmd: &mut Command) {\n-    if build.flags.cmd.no_fail_fast() {\n+    if !build.fail_fast {\n         if !build.try_run(cmd) {\n             let failures = build.delayed_failures.get();\n             build.delayed_failures.set(failures + 1);\n@@ -71,7 +70,7 @@ fn try_run(build: &Build, cmd: &mut Command) {\n }\n \n fn try_run_quiet(build: &Build, cmd: &mut Command) {\n-    if build.flags.cmd.no_fail_fast() {\n+    if !build.fail_fast {\n         if !build.try_run_quiet(cmd) {\n             let failures = build.delayed_failures.get();\n             build.delayed_failures.set(failures + 1);\n@@ -99,7 +98,7 @@ pub fn linkcheck(build: &Build, host: &str) {\n /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n /// test` to ensure that we don't regress the test suites there.\n pub fn cargotest(build: &Build, stage: u32, host: &str) {\n-    let ref compiler = Compiler::new(stage, host);\n+    let compiler = Compiler::new(stage, host);\n \n     // Note that this is a short, cryptic, and not scoped directory name. This\n     // is currently to minimize the length of path on Windows where we otherwise\n@@ -109,11 +108,11 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n \n     let _time = util::timeit();\n     let mut cmd = Command::new(build.tool(&Compiler::new(0, host), \"cargotest\"));\n-    build.prepare_tool_cmd(compiler, &mut cmd);\n-    try_run(build, cmd.arg(&build.cargo)\n+    build.prepare_tool_cmd(&compiler, &mut cmd);\n+    try_run(build, cmd.arg(&build.initial_cargo)\n                       .arg(&out_dir)\n-                      .env(\"RUSTC\", build.compiler_path(compiler))\n-                      .env(\"RUSTDOC\", build.rustdoc(compiler)));\n+                      .env(\"RUSTC\", build.compiler_path(&compiler))\n+                      .env(\"RUSTDOC\", build.rustdoc(&compiler)));\n }\n \n /// Runs `cargo test` for `cargo` packaged with Rust.\n@@ -124,13 +123,12 @@ pub fn cargo(build: &Build, stage: u32, host: &str) {\n     // and not RUSTC because the Cargo test suite has tests that will\n     // fail if rustc is not spelled `rustc`.\n     let path = build.sysroot(compiler).join(\"bin\");\n-    let old_path = ::std::env::var(\"PATH\").expect(\"\");\n-    let sep = if cfg!(windows) { \";\" } else {\":\" };\n-    let ref newpath = format!(\"{}{}{}\", path.display(), sep, old_path);\n+    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+    let newpath = env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\");\n \n     let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n     cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n-    if build.flags.cmd.no_fail_fast() {\n+    if !build.fail_fast {\n         cargo.arg(\"--no-fail-fast\");\n     }\n \n@@ -198,9 +196,9 @@ pub fn compiletest(build: &Build,\n     cmd.arg(\"--mode\").arg(mode);\n     cmd.arg(\"--target\").arg(target);\n     cmd.arg(\"--host\").arg(compiler.host);\n-    cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.config.build));\n+    cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.build));\n \n-    if let Some(nodejs) = build.config.nodejs.as_ref() {\n+    if let Some(ref nodejs) = build.config.nodejs {\n         cmd.arg(\"--nodejs\").arg(nodejs);\n     }\n \n@@ -224,7 +222,7 @@ pub fn compiletest(build: &Build,\n \n     cmd.arg(\"--docck-python\").arg(build.python());\n \n-    if build.config.build.ends_with(\"apple-darwin\") {\n+    if build.build.ends_with(\"apple-darwin\") {\n         // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n         // LLDB plugin's compiled module which only works with the system python\n         // (namely not Homebrew-installed python)\n@@ -251,7 +249,7 @@ pub fn compiletest(build: &Build,\n \n     cmd.args(&build.flags.cmd.test_args());\n \n-    if build.config.verbose() || build.flags.verbose() {\n+    if build.is_verbose() {\n         cmd.arg(\"--verbose\");\n     }\n \n@@ -279,7 +277,7 @@ pub fn compiletest(build: &Build,\n \n     if build.remote_tested(target) {\n         cmd.arg(\"--remote-test-client\")\n-           .arg(build.tool(&Compiler::new(0, &build.config.build),\n+           .arg(build.tool(&Compiler::new(0, &build.build),\n                            \"remote-test-client\"));\n     }\n \n@@ -368,7 +366,7 @@ pub fn error_index(build: &Build, compiler: &Compiler) {\n                              \"error_index_generator\")\n                    .arg(\"markdown\")\n                    .arg(&output)\n-                   .env(\"CFG_BUILD\", &build.config.build));\n+                   .env(\"CFG_BUILD\", &build.build));\n \n     markdown_test(build, compiler, &output);\n }\n@@ -450,7 +448,7 @@ pub fn krate(build: &Build,\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n-    if test_kind.subcommand() == \"test\" && build.flags.cmd.no_fail_fast() {\n+    if test_kind.subcommand() == \"test\" && !build.fail_fast {\n         cargo.arg(\"--no-fail-fast\");\n     }\n \n@@ -520,16 +518,14 @@ fn krate_emscripten(build: &Build,\n                     compiler: &Compiler,\n                     target: &str,\n                     mode: Mode) {\n-    let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n+    let tests = find_tests(&out_dir.join(\"deps\"), target);\n \n+    let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n     for test in tests {\n-        let test_file_name = test.to_string_lossy().into_owned();\n-        println!(\"running {}\", test_file_name);\n-        let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n+        println!(\"running {}\", test.display());\n         let mut cmd = Command::new(nodejs);\n-        cmd.arg(&test_file_name);\n+        cmd.arg(&test);\n         if build.config.quiet_tests {\n             cmd.arg(\"--quiet\");\n         }\n@@ -541,11 +537,10 @@ fn krate_remote(build: &Build,\n                 compiler: &Compiler,\n                 target: &str,\n                 mode: Mode) {\n-    let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n+    let tests = find_tests(&out_dir.join(\"deps\"), target);\n \n-    let tool = build.tool(&Compiler::new(0, &build.config.build),\n+    let tool = build.tool(&Compiler::new(0, &build.build),\n                           \"remote-test-client\");\n     for test in tests {\n         let mut cmd = Command::new(&tool);\n@@ -559,9 +554,8 @@ fn krate_remote(build: &Build,\n     }\n }\n \n-fn find_tests(dir: &Path,\n-              target: &str,\n-              dst: &mut Vec<PathBuf>) {\n+fn find_tests(dir: &Path, target: &str) -> Vec<PathBuf> {\n+    let mut dst = Vec::new();\n     for e in t!(dir.read_dir()).map(|e| t!(e)) {\n         let file_type = t!(e.file_type());\n         if !file_type.is_file() {\n@@ -576,6 +570,7 @@ fn find_tests(dir: &Path,\n             dst.push(e.path());\n         }\n     }\n+    dst\n }\n \n pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n@@ -590,7 +585,7 @@ pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n                       .join(exe(\"remote-test-server\", target));\n \n     // Spawn the emulator and wait for it to come online\n-    let tool = build.tool(&Compiler::new(0, &build.config.build),\n+    let tool = build.tool(&Compiler::new(0, &build.build),\n                           \"remote-test-client\");\n     let mut cmd = Command::new(&tool);\n     cmd.arg(\"spawn-emulator\")\n@@ -616,7 +611,7 @@ pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n \n /// Run \"distcheck\", a 'make check' from a tarball\n pub fn distcheck(build: &Build) {\n-    if build.config.build != \"x86_64-unknown-linux-gnu\" {\n+    if build.build != \"x86_64-unknown-linux-gnu\" {\n         return\n     }\n     if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n@@ -641,7 +636,7 @@ pub fn distcheck(build: &Build) {\n                      .args(&build.config.configure_args)\n                      .arg(\"--enable-vendor\")\n                      .current_dir(&dir));\n-    build.run(Command::new(build_helper::make(&build.config.build))\n+    build.run(Command::new(build_helper::make(&build.build))\n                      .arg(\"check\")\n                      .current_dir(&dir));\n \n@@ -659,7 +654,7 @@ pub fn distcheck(build: &Build) {\n     build.run(&mut cmd);\n \n     let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-    build.run(Command::new(&build.cargo)\n+    build.run(Command::new(&build.initial_cargo)\n                      .arg(\"generate-lockfile\")\n                      .arg(\"--manifest-path\")\n                      .arg(&toml)\n@@ -668,13 +663,13 @@ pub fn distcheck(build: &Build) {\n \n /// Test the build system itself\n pub fn bootstrap(build: &Build) {\n-    let mut cmd = Command::new(&build.cargo);\n+    let mut cmd = Command::new(&build.initial_cargo);\n     cmd.arg(\"test\")\n        .current_dir(build.src.join(\"src/bootstrap\"))\n        .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n        .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-       .env(\"RUSTC\", &build.rustc);\n-    if build.flags.cmd.no_fail_fast() {\n+       .env(\"RUSTC\", &build.initial_rustc);\n+    if !build.fail_fast {\n         cmd.arg(\"--no-fail-fast\");\n     }\n     cmd.arg(\"--\").args(&build.flags.cmd.test_args());"}, {"sha": "5a3106c7d5e64e59aa8c0cca9a64b61ad78769e4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -50,7 +50,7 @@ pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n     let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"build\");\n     let mut features = build.std_features();\n \n-    if let Ok(target) = env::var(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n+    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n@@ -158,7 +158,7 @@ pub fn build_startup_objects(build: &Build, for_compiler: &Compiler, target: &st\n         return\n     }\n \n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let compiler_path = build.compiler_path(&compiler);\n     let src_dir = &build.src.join(\"src/rtstartup\");\n     let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n@@ -199,7 +199,7 @@ pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n     let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n     build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n     let mut cargo = build.cargo(compiler, Mode::Libtest, target, \"build\");\n-    if let Ok(target) = env::var(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n+    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n     cargo.arg(\"--manifest-path\")\n@@ -247,7 +247,7 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     cargo.env(\"CFG_RELEASE\", build.rust_release())\n          .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n          .env(\"CFG_VERSION\", build.rust_version())\n-         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or(PathBuf::new()));\n+         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default());\n \n     if compiler.stage == 0 {\n         cargo.env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n@@ -351,7 +351,7 @@ pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n /// Prepare a new compiler from the artifacts in `stage`\n ///\n /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n-/// must have been previously produced by the `stage - 1` build.config.build\n+/// must have been previously produced by the `stage - 1` build.build\n /// compiler.\n pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     // nothing to do in stage0\n@@ -365,7 +365,7 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     let target_compiler = Compiler::new(stage, host);\n \n     // The compiler that compiled the compiler we're assembling\n-    let build_compiler = Compiler::new(stage - 1, &build.config.build);\n+    let build_compiler = Compiler::new(stage - 1, &build.build);\n \n     // Link in all dylibs to the libdir\n     let sysroot = build.sysroot(&target_compiler);\n@@ -385,7 +385,7 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     let rustc = out_dir.join(exe(\"rustc\", host));\n     let bindir = sysroot.join(\"bin\");\n     t!(fs::create_dir_all(&bindir));\n-    let compiler = build.compiler_path(&Compiler::new(stage, host));\n+    let compiler = build.compiler_path(&target_compiler);\n     let _ = fs::remove_file(&compiler);\n     copy(&rustc, &compiler);\n \n@@ -407,6 +407,8 @@ fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     let mut contents = Vec::new();\n     t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+    // This is the method we use for extracting paths from the stamp file passed to us. See\n+    // run_cargo for more information (in this file).\n     for part in contents.split(|b| *b == 0) {\n         if part.is_empty() {\n             continue\n@@ -421,7 +423,7 @@ fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n /// This will build the specified tool with the specified `host` compiler in\n /// `stage` into the normal cargo output directory.\n pub fn maybe_clean_tools(build: &Build, stage: u32, target: &str, mode: Mode) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let stamp = match mode {\n         Mode::Libstd => libstd_stamp(build, &compiler, target),\n@@ -441,7 +443,7 @@ pub fn tool(build: &Build, stage: u32, target: &str, tool: &str) {\n     let _folder = build.fold_output(|| format!(\"stage{}-{}\", stage, tool));\n     println!(\"Building stage{} tool {} ({})\", stage, tool, target);\n \n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let mut cargo = build.cargo(&compiler, Mode::Tool, target, \"build\");\n     let dir = build.src.join(\"src/tools\").join(tool);\n@@ -557,23 +559,24 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n             // If this was an output file in the \"host dir\" we don't actually\n             // worry about it, it's not relevant for us.\n             if filename.starts_with(&host_root_dir) {\n-                continue\n+                continue;\n+            }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n-            } else if filename.starts_with(&target_deps_dir) {\n+            if filename.starts_with(&target_deps_dir) {\n                 deps.push(filename.to_path_buf());\n+                continue;\n+            }\n \n             // Otherwise this was a \"top level artifact\" which right now doesn't\n             // have a hash in the name, but there's a version of this file in\n             // the `deps` folder which *does* have a hash in the name. That's\n             // the one we'll want to we'll probe for it later.\n-            } else {\n-                toplevel.push((filename.file_stem().unwrap()\n-                                       .to_str().unwrap().to_string(),\n-                               filename.extension().unwrap().to_owned()\n-                                       .to_str().unwrap().to_string()));\n-            }\n+            toplevel.push((filename.file_stem().unwrap()\n+                                    .to_str().unwrap().to_string(),\n+                            filename.extension().unwrap().to_owned()\n+                                    .to_str().unwrap().to_string()));\n         }\n     }\n "}, {"sha": "34628852ab3773a2ff50bc051d77231bfd96b438", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -81,8 +81,6 @@ pub struct Config {\n     pub build: String,\n     pub host: Vec<String>,\n     pub target: Vec<String>,\n-    pub rustc: Option<PathBuf>,\n-    pub cargo: Option<PathBuf>,\n     pub local_rebuild: bool,\n \n     // dist misc\n@@ -114,11 +112,18 @@ pub struct Config {\n     pub python: Option<PathBuf>,\n     pub configure_args: Vec<String>,\n     pub openssl_static: bool,\n+\n+\n+    // These are either the stage0 downloaded binaries or the locally installed ones.\n+    pub initial_cargo: PathBuf,\n+    pub initial_rustc: PathBuf,\n+\n }\n \n /// Per-target configuration stored in the global configuration structure.\n #[derive(Default)]\n pub struct Target {\n+    /// Some(path to llvm-config) if using an external LLVM.\n     pub llvm_config: Option<PathBuf>,\n     pub jemalloc: Option<PathBuf>,\n     pub cc: Option<PathBuf>,\n@@ -307,8 +312,6 @@ impl Config {\n                 config.target.push(target.clone());\n             }\n         }\n-        config.rustc = build.rustc.map(PathBuf::from);\n-        config.cargo = build.cargo.map(PathBuf::from);\n         config.nodejs = build.nodejs.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n         config.python = build.python.map(PathBuf::from);\n@@ -410,13 +413,25 @@ impl Config {\n             set(&mut config.rust_dist_src, t.src_tarball);\n         }\n \n+        let cwd = t!(env::current_dir());\n+        let out = cwd.join(\"build\");\n+\n+        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n+        config.initial_rustc = match build.rustc {\n+            Some(s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"rustc\", &config.build)),\n+        };\n+        config.initial_cargo = match build.cargo {\n+            Some(s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"cargo\", &config.build)),\n+        };\n \n         // compat with `./configure` while we're still using that\n         if fs::metadata(\"config.mk\").is_ok() {\n             config.update_with_config_mk();\n         }\n \n-        return config\n+        config\n     }\n \n     /// \"Temporary\" routine to parse `config.mk` into this configuration.\n@@ -609,8 +624,8 @@ impl Config {\n                 }\n                 \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n                     let path = parse_configure_path(value);\n-                    self.rustc = Some(push_exe_path(path.clone(), &[\"bin\", \"rustc\"]));\n-                    self.cargo = Some(push_exe_path(path, &[\"bin\", \"cargo\"]));\n+                    self.initial_rustc = push_exe_path(path.clone(), &[\"bin\", \"rustc\"]);\n+                    self.initial_cargo = push_exe_path(path, &[\"bin\", \"cargo\"]);\n                 }\n                 \"CFG_PYTHON\" if value.len() > 0 => {\n                     let path = parse_configure_path(value);"}, {"sha": "efc33bcee9b3becf2bca18c0964577df002949b2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -50,7 +50,7 @@ pub fn tmpdir(build: &Build) -> PathBuf {\n }\n \n fn rust_installer(build: &Build) -> Command {\n-    build.tool_cmd(&Compiler::new(0, &build.config.build), \"rust-installer\")\n+    build.tool_cmd(&Compiler::new(0, &build.build), \"rust-installer\")\n }\n \n /// Builds the `rust-docs` installer component.\n@@ -89,15 +89,15 @@ pub fn docs(build: &Build, stage: u32, host: &str) {\n \n     // As part of this step, *also* copy the docs directory to a directory which\n     // buildbot typically uploads.\n-    if host == build.config.build {\n+    if host == build.build {\n         let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n         t!(fs::create_dir_all(&dst));\n         cp_r(&src, &dst);\n     }\n }\n \n fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n-    let mut found = Vec::new();\n+    let mut found = Vec::with_capacity(files.len());\n \n     for file in files {\n         let file_path =\n@@ -119,17 +119,9 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n     //Ask gcc where it keeps its stuff\n     let mut cmd = Command::new(build.cc(target_triple));\n     cmd.arg(\"-print-search-dirs\");\n-    build.run_quiet(&mut cmd);\n-    let gcc_out =\n-        String::from_utf8(\n-                cmd\n-                .output()\n-                .expect(\"failed to execute gcc\")\n-                .stdout).expect(\"gcc.exe output was not utf8\");\n-\n-    let mut bin_path: Vec<_> =\n-        env::split_paths(&env::var_os(\"PATH\").unwrap_or_default())\n-        .collect();\n+    let gcc_out = output(&mut cmd);\n+\n+    let mut bin_path: Vec<_> = env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()).collect();\n     let mut lib_path = Vec::new();\n \n     for line in gcc_out.lines() {\n@@ -140,7 +132,7 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n             line[(idx + 1)..]\n                 .trim_left_matches(trim_chars)\n                 .split(';')\n-                .map(|s| PathBuf::from(s));\n+                .map(PathBuf::from);\n \n         if key == \"programs\" {\n             bin_path.extend(value);\n@@ -149,15 +141,15 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n         }\n     }\n \n-    let target_tools = vec![\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n+    let target_tools = [\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libstdc++-6.dll\", \"libwinpthread-1.dll\"];\n     if target_triple.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");\n     } else {\n         rustc_dlls.push(\"libgcc_s_seh-1.dll\");\n     }\n \n-    let target_libs = vec![ //MinGW libs\n+    let target_libs = [ //MinGW libs\n         \"libgcc.a\",\n         \"libgcc_eh.a\",\n         \"libgcc_s.a\",\n@@ -203,7 +195,7 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n     let target_libs = find_files(&target_libs, &lib_path);\n \n     fn copy_to_folder(src: &Path, dest_folder: &Path) {\n-        let file_name = src.file_name().unwrap().to_os_string();\n+        let file_name = src.file_name().unwrap();\n         let dest = dest_folder.join(file_name);\n         copy(src, &dest);\n     }\n@@ -234,8 +226,6 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n ///\n /// This contains all the bits and pieces to run the MinGW Windows targets\n /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n-/// Currently just shells out to a python script, but that should be rewritten\n-/// in Rust.\n pub fn mingw(build: &Build, host: &str) {\n     println!(\"Dist mingw ({})\", host);\n     let name = pkgname(build, \"rust-mingw\");\n@@ -366,9 +356,9 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n pub fn debugger_scripts(build: &Build,\n                         sysroot: &Path,\n                         host: &str) {\n+    let dst = sysroot.join(\"lib/rustlib/etc\");\n+    t!(fs::create_dir_all(&dst));\n     let cp_debugger_script = |file: &str| {\n-        let dst = sysroot.join(\"lib/rustlib/etc\");\n-        t!(fs::create_dir_all(&dst));\n         install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n     };\n     if host.contains(\"windows-msvc\") {\n@@ -404,7 +394,7 @@ pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n \n     // The only true set of target libraries came from the build triple, so\n     // let's reduce redundant work by only producing archives from that host.\n-    if compiler.host != build.config.build {\n+    if compiler.host != build.build {\n         println!(\"\\tskipping, not a build host\");\n         return\n     }\n@@ -450,7 +440,7 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n     assert!(build.config.extended);\n     println!(\"Dist analysis\");\n \n-    if compiler.host != build.config.build {\n+    if compiler.host != build.build {\n         println!(\"\\tskipping, not a build host\");\n         return;\n     }\n@@ -498,12 +488,11 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n         if spath.ends_with(\"~\") || spath.ends_with(\".pyc\") {\n             return false\n         }\n-        if spath.contains(\"llvm/test\") || spath.contains(\"llvm\\\\test\") {\n-            if spath.ends_with(\".ll\") ||\n-               spath.ends_with(\".td\") ||\n-               spath.ends_with(\".s\") {\n-                return false\n-            }\n+        if (spath.contains(\"llvm/test\") || spath.contains(\"llvm\\\\test\")) &&\n+            (spath.ends_with(\".ll\") ||\n+             spath.ends_with(\".td\") ||\n+             spath.ends_with(\".s\")) {\n+            return false\n         }\n \n         let full_path = Path::new(dir).join(path);\n@@ -595,7 +584,7 @@ pub fn rust_src(build: &Build) {\n     t!(fs::remove_dir_all(&image));\n }\n \n-const CARGO_VENDOR_VERSION: &'static str = \"0.1.4\";\n+const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n \n /// Creates the plain source tarball\n pub fn plain_source_tarball(build: &Build) {\n@@ -634,26 +623,26 @@ pub fn plain_source_tarball(build: &Build) {\n     write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n \n     // If we're building from git sources, we need to vendor a complete distribution.\n-    if build.src_is_git {\n+    if build.rust_info.is_git() {\n         // Get cargo-vendor installed, if it isn't already.\n         let mut has_cargo_vendor = false;\n-        let mut cmd = Command::new(&build.cargo);\n+        let mut cmd = Command::new(&build.initial_cargo);\n         for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n             has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n         }\n         if !has_cargo_vendor {\n-            let mut cmd = Command::new(&build.cargo);\n+            let mut cmd = Command::new(&build.initial_cargo);\n             cmd.arg(\"install\")\n                .arg(\"--force\")\n                .arg(\"--debug\")\n                .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n                .arg(\"cargo-vendor\")\n-               .env(\"RUSTC\", &build.rustc);\n+               .env(\"RUSTC\", &build.initial_rustc);\n             build.run(&mut cmd);\n         }\n \n         // Vendor all Cargo dependencies\n-        let mut cmd = Command::new(&build.cargo);\n+        let mut cmd = Command::new(&build.initial_cargo);\n         cmd.arg(\"vendor\")\n            .current_dir(&plain_dst_src.join(\"src\"));\n         build.run(&mut cmd);\n@@ -716,7 +705,7 @@ fn write_file(path: &Path, data: &[u8]) {\n \n pub fn cargo(build: &Build, stage: u32, target: &str) {\n     println!(\"Dist cargo stage{} ({})\", stage, target);\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let src = build.src.join(\"src/tools/cargo\");\n     let etc = src.join(\"src/etc\");\n@@ -777,7 +766,7 @@ pub fn cargo(build: &Build, stage: u32, target: &str) {\n pub fn rls(build: &Build, stage: u32, target: &str) {\n     assert!(build.config.extended);\n     println!(\"Dist RLS stage{} ({})\", stage, target);\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n \n     let src = build.src.join(\"src/tools/rls\");\n     let release_num = build.release_num(\"rls\");\n@@ -1209,7 +1198,7 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n }\n \n pub fn hash_and_sign(build: &Build) {\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n     let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n         panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")"}, {"sha": "7dbc3e5553957c4feb360b92a33a170cb15fda7f", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -45,7 +45,7 @@ pub fn rustbook_src(build: &Build, target: &str, name: &str, src: &Path) {\n     t!(fs::create_dir_all(&out));\n \n     let out = out.join(name);\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let src = src.join(name);\n     let index = out.join(\"index.html\");\n     let rustbook = build.tool(&compiler, \"rustbook\");\n@@ -95,7 +95,7 @@ pub fn book(build: &Build, target: &str, name: &str) {\n fn invoke_rustdoc(build: &Build, target: &str, markdown: &str) {\n     let out = build.doc_out(target);\n \n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n \n     let path = build.src.join(\"src/doc\").join(markdown);\n \n@@ -150,7 +150,7 @@ pub fn standalone(build: &Build, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n \n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n \n     let favicon = build.src.join(\"src/doc/favicon.inc\");\n     let footer = build.src.join(\"src/doc/footer.inc\");\n@@ -217,7 +217,7 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} std ({})\", stage, target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n     let compiler = if build.force_use_stage1(&compiler, target) {\n         Compiler::new(1, compiler.host)\n     } else {\n@@ -276,7 +276,7 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} test ({})\", stage, target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n     let compiler = if build.force_use_stage1(&compiler, target) {\n         Compiler::new(1, compiler.host)\n     } else {\n@@ -306,7 +306,7 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} compiler ({})\", stage, target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(stage, &build.build);\n     let compiler = if build.force_use_stage1(&compiler, target) {\n         Compiler::new(1, compiler.host)\n     } else {\n@@ -351,13 +351,13 @@ pub fn error_index(build: &Build, target: &str) {\n     println!(\"Documenting error index ({})\", target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n     index.arg(\"html\");\n     index.arg(out.join(\"error-index.html\"));\n \n     // FIXME: shouldn't have to pass this env var\n-    index.env(\"CFG_BUILD\", &build.config.build);\n+    index.env(\"CFG_BUILD\", &build.build);\n \n     build.run(&mut index);\n }\n@@ -367,7 +367,7 @@ pub fn unstable_book_gen(build: &Build, target: &str) {\n     let out = build.md_doc_out(target).join(\"unstable-book\");\n     t!(fs::create_dir_all(&out));\n     t!(fs::remove_dir_all(&out));\n-    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = Compiler::new(0, &build.build);\n     let mut cmd = build.tool_cmd(&compiler, \"unstable-book-gen\");\n     cmd.arg(build.src.join(\"src\"));\n     cmd.arg(out);"}, {"sha": "5804df34e8b383f21798c20fcf0791244d9628ac", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -35,22 +35,12 @@ pub struct Flags {\n     pub host: Vec<String>,\n     pub target: Vec<String>,\n     pub config: Option<PathBuf>,\n-    pub src: Option<PathBuf>,\n+    pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n }\n \n-impl Flags {\n-    pub fn verbose(&self) -> bool {\n-        self.verbose > 0\n-    }\n-\n-    pub fn very_verbose(&self) -> bool {\n-        self.verbose > 1\n-    }\n-}\n-\n pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n@@ -61,7 +51,7 @@ pub enum Subcommand {\n     Test {\n         paths: Vec<PathBuf>,\n         test_args: Vec<String>,\n-        no_fail_fast: bool,\n+        fail_fast: bool,\n     },\n     Bench {\n         paths: Vec<PathBuf>,\n@@ -122,16 +112,15 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n         // complete the definition of the options.  Then we can use the getopt::Matches object from\n         // there on out.\n-        let mut possible_subcommands = args.iter().collect::<Vec<_>>();\n-        possible_subcommands.retain(|&s|\n-                                           (s == \"build\")\n-                                        || (s == \"test\")\n-                                        || (s == \"bench\")\n-                                        || (s == \"doc\")\n-                                        || (s == \"clean\")\n-                                        || (s == \"dist\")\n-                                        || (s == \"install\"));\n-        let subcommand = match possible_subcommands.first() {\n+        let subcommand = args.iter().find(|&s|\n+            (s == \"build\")\n+            || (s == \"test\")\n+            || (s == \"bench\")\n+            || (s == \"doc\")\n+            || (s == \"clean\")\n+            || (s == \"dist\")\n+            || (s == \"install\"));\n+        let subcommand = match subcommand {\n             Some(s) => s,\n             None => {\n                 // No subcommand -- show the general usage and subcommand help\n@@ -164,7 +153,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         let mut pass_sanity_check = true;\n         match matches.free.get(0) {\n             Some(check_subcommand) => {\n-                if &check_subcommand != subcommand {\n+                if check_subcommand != subcommand {\n                     pass_sanity_check = false;\n                 }\n             },\n@@ -279,7 +268,7 @@ Arguments:\n                 Subcommand::Test {\n                     paths: paths,\n                     test_args: matches.opt_strs(\"test-args\"),\n-                    no_fail_fast: matches.opt_present(\"no-fail-fast\"),\n+                    fail_fast: !matches.opt_present(\"no-fail-fast\"),\n                 }\n             }\n             \"bench\" => {\n@@ -316,12 +305,15 @@ Arguments:\n \n         let mut stage = matches.opt_str(\"stage\").map(|j| j.parse().unwrap());\n \n-        if matches.opt_present(\"incremental\") {\n-            if stage.is_none() {\n-                stage = Some(1);\n-            }\n+        if matches.opt_present(\"incremental\") && stage.is_none() {\n+            stage = Some(1);\n         }\n \n+        let cwd = t!(env::current_dir());\n+        let src = matches.opt_str(\"src\").map(PathBuf::from)\n+            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n+            .unwrap_or(cwd);\n+\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: stage,\n@@ -333,7 +325,7 @@ Arguments:\n             host: split(matches.opt_strs(\"host\")),\n             target: split(matches.opt_strs(\"target\")),\n             config: cfg_file,\n-            src: matches.opt_str(\"src\").map(PathBuf::from),\n+            src: src,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd: cmd,\n             incremental: matches.opt_present(\"incremental\"),\n@@ -352,9 +344,9 @@ impl Subcommand {\n         }\n     }\n \n-    pub fn no_fail_fast(&self) -> bool {\n+    pub fn fail_fast(&self) -> bool {\n         match *self {\n-            Subcommand::Test { no_fail_fast, .. } => no_fail_fast,\n+            Subcommand::Test { fail_fast, .. } => fail_fast,\n             _ => false,\n         }\n     }"}, {"sha": "8e2ef527b1658dc0ea4a6a0aca491b439dfbf1f3", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -146,5 +146,5 @@ fn add_destdir(path: &Path, destdir: &Option<PathBuf>) -> PathBuf {\n             _ => {}\n         }\n     }\n-    return ret\n+    ret\n }"}, {"sha": "69b0c4a2756a681a1a22691d87af43010dae7c3b", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 80, "deletions": 48, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -161,25 +161,35 @@ pub struct Build {\n     flags: Flags,\n \n     // Derived properties from the above two configurations\n-    cargo: PathBuf,\n-    rustc: PathBuf,\n     src: PathBuf,\n     out: PathBuf,\n     rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rls_info: channel::GitInfo,\n     local_rebuild: bool,\n+    fail_fast: bool,\n+    verbosity: usize,\n+\n+    // Targets for which to build.\n+    build: String,\n+    hosts: Vec<String>,\n+    targets: Vec<String>,\n+\n+    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents.\n+    initial_rustc: PathBuf,\n+    initial_cargo: PathBuf,\n \n     // Probed tools at runtime\n     lldb_version: Option<String>,\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n+    // target -> (cc, ar)\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n+    // host -> (cc, ar)\n     cxx: HashMap<String, gcc::Tool>,\n     crates: HashMap<String, Crate>,\n     is_sudo: bool,\n-    src_is_git: bool,\n     ci_env: CiEnv,\n     delayed_failures: Cell<usize>,\n }\n@@ -202,20 +212,16 @@ struct Crate {\n /// build system, with each mod generating output in a different directory.\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub enum Mode {\n-    /// This cargo is going to build the standard library, placing output in the\n-    /// \"stageN-std\" directory.\n+    /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Libstd,\n \n-    /// This cargo is going to build libtest, placing output in the\n-    /// \"stageN-test\" directory.\n+    /// Build libtest, placing output in the \"stageN-test\" directory.\n     Libtest,\n \n-    /// This cargo is going to build librustc and compiler libraries, placing\n-    /// output in the \"stageN-rustc\" directory.\n+    /// Build librustc and compiler libraries, placing output in the \"stageN-rustc\" directory.\n     Librustc,\n \n-    /// This cargo is going to build some tool, placing output in the\n-    /// \"stageN-tools\" directory.\n+    /// Build some tool, placing output in the \"stageN-tools\" directory.\n     Tool,\n }\n \n@@ -226,22 +232,9 @@ impl Build {\n     /// By default all build output will be placed in the current directory.\n     pub fn new(flags: Flags, config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n-        let src = flags.src.clone().or_else(|| {\n-            env::var_os(\"SRC\").map(|x| x.into())\n-        }).unwrap_or(cwd.clone());\n+        let src = flags.src.clone();\n         let out = cwd.join(\"build\");\n \n-        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n-        let rustc = match config.rustc {\n-            Some(ref s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"rustc\", &config.build)),\n-        };\n-        let cargo = match config.cargo {\n-            Some(ref s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"cargo\", &config.build)),\n-        };\n-        let local_rebuild = config.local_rebuild;\n-\n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n             Some(sudo_user) => {\n                 match env::var_os(\"USER\") {\n@@ -254,32 +247,64 @@ impl Build {\n         let rust_info = channel::GitInfo::new(&src);\n         let cargo_info = channel::GitInfo::new(&src.join(\"src/tools/cargo\"));\n         let rls_info = channel::GitInfo::new(&src.join(\"src/tools/rls\"));\n-        let src_is_git = src.join(\".git\").exists();\n+\n+        let hosts = if !flags.host.is_empty() {\n+            for host in flags.host.iter() {\n+                if !config.host.contains(host) {\n+                    panic!(\"specified host `{}` is not in configuration\", host);\n+                }\n+            }\n+            flags.host.clone()\n+        } else {\n+            config.host.clone()\n+        };\n+        let targets = if !flags.target.is_empty() {\n+            for target in flags.target.iter() {\n+                if !config.target.contains(target) {\n+                    panic!(\"specified target `{}` is not in configuration\", target);\n+                }\n+            }\n+            flags.target.clone()\n+        } else {\n+            config.target.clone()\n+        };\n \n         Build {\n+            initial_rustc: config.initial_rustc.clone(),\n+            initial_cargo: config.initial_cargo.clone(),\n+            local_rebuild: config.local_rebuild,\n+            fail_fast: flags.cmd.fail_fast(),\n+            verbosity: cmp::max(flags.verbose, config.verbose),\n+\n+            build: config.host[0].clone(),\n+            hosts: hosts,\n+            targets: targets,\n+\n             flags: flags,\n             config: config,\n-            cargo: cargo,\n-            rustc: rustc,\n             src: src,\n             out: out,\n \n             rust_info: rust_info,\n             cargo_info: cargo_info,\n             rls_info: rls_info,\n-            local_rebuild: local_rebuild,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n             is_sudo: is_sudo,\n-            src_is_git: src_is_git,\n             ci_env: CiEnv::current(),\n             delayed_failures: Cell::new(0),\n         }\n     }\n \n+    fn build_slice(&self) -> &[String] {\n+        unsafe {\n+            std::slice::from_raw_parts(&self.build, 1)\n+        }\n+    }\n+\n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n         unsafe {\n@@ -296,7 +321,7 @@ impl Build {\n         sanity::check(self);\n         // If local-rust is the same major.minor as the current version, then force a local-rebuild\n         let local_version_verbose = output(\n-            Command::new(&self.rustc).arg(\"--version\").arg(\"--verbose\"));\n+            Command::new(&self.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n         let local_release = local_version_verbose\n             .lines().filter(|x| x.starts_with(\"release:\"))\n             .next().unwrap().trim_left_matches(\"release:\").trim();\n@@ -338,7 +363,7 @@ impl Build {\n              mode: Mode,\n              target: &str,\n              cmd: &str) -> Command {\n-        let mut cargo = Command::new(&self.cargo);\n+        let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n         cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n              .arg(cmd)\n@@ -422,7 +447,7 @@ impl Build {\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n         if mode == Mode::Libstd {\n-            cargo.env(\"RUSTC_SNAPSHOT\", &self.rustc)\n+            cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n             cargo.env(\"RUSTC_SNAPSHOT\", self.compiler_path(compiler))\n@@ -441,8 +466,7 @@ impl Build {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n \n-        let verbose = cmp::max(self.config.verbose, self.flags.verbose);\n-        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", verbose));\n+        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n@@ -480,7 +504,7 @@ impl Build {\n         // FIXME: should update code to not require this env var\n         cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n \n-        if self.config.verbose() || self.flags.verbose() {\n+        if self.is_verbose() {\n             cargo.arg(\"-v\");\n         }\n         // FIXME: cargo bench does not accept `--release`\n@@ -496,13 +520,13 @@ impl Build {\n \n         self.ci_env.force_coloring_in_ci(&mut cargo);\n \n-        return cargo\n+        cargo\n     }\n \n     /// Get a path to the compiler specified.\n     fn compiler_path(&self, compiler: &Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n-            self.rustc.clone()\n+            self.initial_rustc.clone()\n         } else {\n             self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n         }\n@@ -519,15 +543,15 @@ impl Build {\n         let mut rustdoc = self.compiler_path(compiler);\n         rustdoc.pop();\n         rustdoc.push(exe(\"rustdoc\", compiler.host));\n-        return rustdoc\n+        rustdoc\n     }\n \n     /// Get a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n     fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         self.prepare_tool_cmd(compiler, &mut cmd);\n-        return cmd\n+        cmd\n     }\n \n     /// Prepares the `cmd` provided to be able to run the `compiler` provided.\n@@ -578,7 +602,7 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n-        return features\n+        features\n     }\n \n     /// Get the space-separated set of activated features for the compiler.\n@@ -587,7 +611,7 @@ impl Build {\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n-        return features\n+        features\n     }\n \n     /// Component directory that Cargo will produce output into (e.g.\n@@ -760,7 +784,7 @@ impl Build {\n \n     /// Returns the libdir of the snapshot compiler.\n     fn rustc_snapshot_libdir(&self) -> PathBuf {\n-        self.rustc.parent().unwrap().parent().unwrap()\n+        self.initial_rustc.parent().unwrap().parent().unwrap()\n             .join(libdir(&self.config.build))\n     }\n \n@@ -792,17 +816,25 @@ impl Build {\n         try_run_suppressed(cmd)\n     }\n \n+    pub fn is_verbose(&self) -> bool {\n+        self.verbosity > 0\n+    }\n+\n+    pub fn is_very_verbose(&self) -> bool {\n+        self.verbosity > 1\n+    }\n+\n     /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n-        if self.flags.verbose() || self.config.verbose() {\n+        if self.is_verbose() {\n             println!(\"{}\", msg);\n         }\n     }\n \n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n-        self.flags.jobs.unwrap_or(num_cpus::get() as u32)\n+        self.flags.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -834,7 +866,7 @@ impl Build {\n         if target == \"i686-pc-windows-gnu\" {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n-        return base\n+        base\n     }\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n@@ -866,7 +898,7 @@ impl Build {\n             !target.contains(\"emscripten\") {\n             base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n         }\n-        return base\n+        base\n     }\n \n     /// Returns the \"musl root\" for this `target`, if defined\n@@ -1047,7 +1079,7 @@ impl<'a> Compiler<'a> {\n \n     /// Returns whether this is a snapshot compiler for `build`'s configuration\n     fn is_snapshot(&self, build: &Build) -> bool {\n-        self.stage == 0 && self.host == build.config.build\n+        self.stage == 0 && self.host == build.build\n     }\n \n     /// Returns if this compiler should be treated as a final stage one in the"}, {"sha": "9326bb7129afa7f59d50d8d72360fc3eaea2271f", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -56,7 +56,7 @@ fn build_krate(build: &mut Build, krate: &str) {\n     // of packages we're going to have to know what `-p` arguments to pass it\n     // to know what crates to test. Here we run `cargo metadata` to learn about\n     // the dependency graph and what `-p` arguments there are.\n-    let mut cargo = Command::new(&build.cargo);\n+    let mut cargo = Command::new(&build.initial_cargo);\n     cargo.arg(\"metadata\")\n          .arg(\"--format-version\").arg(\"1\")\n          .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));"}, {"sha": "20eec97d8e5aaa8e39fb675132e4644d79575331", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -94,7 +94,7 @@ pub fn llvm(build: &Build, target: &str) {\n     let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n     cfg.target(target)\n-       .host(&build.config.build)\n+       .host(&build.build)\n        .out_dir(&out_dir)\n        .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n@@ -129,11 +129,11 @@ pub fn llvm(build: &Build, target: &str) {\n     }\n \n     // http://llvm.org/docs/HowToCrossCompileLLVM.html\n-    if target != build.config.build {\n+    if target != build.build {\n         // FIXME: if the llvm root for the build triple is overridden then we\n         //        should use llvm-tblgen from there, also should verify that it\n         //        actually exists most of the time in normal installs of LLVM.\n-        let host = build.llvm_out(&build.config.build).join(\"bin/llvm-tblgen\");\n+        let host = build.llvm_out(&build.build).join(\"bin/llvm-tblgen\");\n         cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n            .define(\"LLVM_TABLEGEN\", &host);\n     }\n@@ -243,7 +243,7 @@ pub fn test_helpers(build: &Build, target: &str) {\n     cfg.cargo_metadata(false)\n        .out_dir(&dst)\n        .target(target)\n-       .host(&build.config.build)\n+       .host(&build.build)\n        .opt_level(0)\n        .debug(false)\n        .file(build.src.join(\"src/rt/rust_test_helpers.c\"))"}, {"sha": "a9c1b023dd4f543413de521cfd3aa8f711bd6ad0", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 72, "deletions": 96, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -18,9 +18,9 @@\n //! In theory if we get past this phase it's a bug if a build fails, but in\n //! practice that's likely not true!\n \n-use std::collections::HashSet;\n+use std::collections::HashMap;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::process::Command;\n use std::path::PathBuf;\n@@ -29,137 +29,125 @@ use build_helper::output;\n \n use Build;\n \n+struct Finder {\n+    cache: HashMap<OsString, Option<PathBuf>>,\n+    path: OsString,\n+}\n+\n+impl Finder {\n+    fn new() -> Self {\n+        Self {\n+            cache: HashMap::new(),\n+            path: env::var_os(\"PATH\").unwrap_or_default()\n+        }\n+    }\n+\n+    fn maybe_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> Option<PathBuf> {\n+        let cmd: OsString = cmd.as_ref().into();\n+        let path = self.path.clone();\n+        self.cache.entry(cmd.clone()).or_insert_with(|| {\n+            for path in env::split_paths(&path) {\n+                let target = path.join(&cmd);\n+                let mut cmd_alt = cmd.clone();\n+                cmd_alt.push(\".exe\");\n+                if target.is_file() || // some/path/git\n+                target.with_extension(\"exe\").exists() || // some/path/git.exe\n+                target.join(&cmd_alt).exists() { // some/path/git/git.exe\n+                    return Some(target);\n+                }\n+            }\n+            None\n+        }).clone()\n+    }\n+\n+    fn must_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> PathBuf {\n+        self.maybe_have(&cmd).unwrap_or_else(|| {\n+            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd.as_ref());\n+        })\n+    }\n+}\n+\n pub fn check(build: &mut Build) {\n-    let mut checked = HashSet::new();\n-    let path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+    let path = env::var_os(\"PATH\").unwrap_or_default();\n     // On Windows, quotes are invalid characters for filename paths, and if\n     // one is present as part of the PATH then that can lead to the system\n     // being unable to identify the files properly. See\n     // https://github.com/rust-lang/rust/issues/34959 for more details.\n-    if cfg!(windows) {\n-        if path.to_string_lossy().contains(\"\\\"\") {\n-            panic!(\"PATH contains invalid character '\\\"'\");\n-        }\n+    if cfg!(windows) && path.to_string_lossy().contains(\"\\\"\") {\n+        panic!(\"PATH contains invalid character '\\\"'\");\n     }\n-    let have_cmd = |cmd: &OsStr| {\n-        for path in env::split_paths(&path) {\n-            let target = path.join(cmd);\n-            let mut cmd_alt = cmd.to_os_string();\n-            cmd_alt.push(\".exe\");\n-            if target.is_file() ||\n-               target.with_extension(\"exe\").exists() ||\n-               target.join(cmd_alt).exists() {\n-                return Some(target);\n-            }\n-        }\n-        return None;\n-    };\n-\n-    let mut need_cmd = |cmd: &OsStr| {\n-        if !checked.insert(cmd.to_owned()) {\n-            return\n-        }\n-        if have_cmd(cmd).is_none() {\n-            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n-        }\n-    };\n \n+    let mut cmd_finder = Finder::new();\n     // If we've got a git directory we're gona need git to update\n     // submodules and learn about various other aspects.\n-    if build.src_is_git {\n-        need_cmd(\"git\".as_ref());\n+    if build.rust_info.is_git() {\n+        cmd_finder.must_have(\"git\");\n     }\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n     let building_llvm = build.config.host.iter()\n         .filter_map(|host| build.config.target_config.get(host))\n         .any(|config| config.llvm_config.is_none());\n     if building_llvm || build.config.sanitizers {\n-        need_cmd(\"cmake\".as_ref());\n+        cmd_finder.must_have(\"cmake\");\n     }\n \n     // Ninja is currently only used for LLVM itself.\n-    if building_llvm && build.config.ninja {\n-        // Some Linux distros rename `ninja` to `ninja-build`.\n-        // CMake can work with either binary name.\n-        if have_cmd(\"ninja-build\".as_ref()).is_none() {\n-            need_cmd(\"ninja\".as_ref());\n-        }\n+    // Some Linux distros rename `ninja` to `ninja-build`.\n+    // CMake can work with either binary name.\n+    if building_llvm && build.config.ninja && cmd_finder.maybe_have(\"ninja-build\").is_none() {\n+        cmd_finder.must_have(\"ninja\");\n     }\n \n-    if build.config.python.is_none() {\n-        // set by bootstrap.py\n-        if let Some(v) = env::var_os(\"BOOTSTRAP_PYTHON\") {\n-            build.config.python = Some(PathBuf::from(v));\n-        }\n-    }\n-    if build.config.python.is_none() {\n-        build.config.python = have_cmd(\"python2.7\".as_ref());\n-    }\n-    if build.config.python.is_none() {\n-        build.config.python = have_cmd(\"python2\".as_ref());\n-    }\n-    if build.config.python.is_none() {\n-        need_cmd(\"python\".as_ref());\n-        build.config.python = Some(\"python\".into());\n-    }\n-    need_cmd(build.config.python.as_ref().unwrap().as_ref());\n+    build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n+        .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n+        .or_else(|| cmd_finder.maybe_have(\"python2\"))\n+        .or_else(|| Some(cmd_finder.must_have(\"python\")));\n \n+    build.config.nodejs = build.config.nodejs.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"node\"))\n+        .or_else(|| cmd_finder.maybe_have(\"nodejs\"));\n \n-    if let Some(ref s) = build.config.nodejs {\n-        need_cmd(s.as_ref());\n-    } else {\n-        // Look for the nodejs command, needed for emscripten testing\n-        if let Some(node) = have_cmd(\"node\".as_ref()) {\n-            build.config.nodejs = Some(node);\n-        } else if let Some(node) = have_cmd(\"nodejs\".as_ref()) {\n-            build.config.nodejs = Some(node);\n-        }\n-    }\n-\n-    if let Some(ref gdb) = build.config.gdb {\n-        need_cmd(gdb.as_ref());\n-    } else {\n-        build.config.gdb = have_cmd(\"gdb\".as_ref());\n-    }\n+    build.config.gdb = build.config.gdb.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"gdb\"));\n \n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n-    for target in build.config.target.iter() {\n+    for target in &build.config.target {\n         // On emscripten we don't actually need the C compiler to just\n         // build the target artifacts, only for testing. For the sake\n         // of easier bot configuration, just skip detection.\n         if target.contains(\"emscripten\") {\n             continue;\n         }\n \n-        need_cmd(build.cc(target).as_ref());\n+        cmd_finder.must_have(build.cc(target));\n         if let Some(ar) = build.ar(target) {\n-            need_cmd(ar.as_ref());\n+            cmd_finder.must_have(ar);\n         }\n     }\n-    for host in build.config.host.iter() {\n-        need_cmd(build.cxx(host).unwrap().as_ref());\n-    }\n \n-    // The msvc hosts don't use jemalloc, turn it off globally to\n-    // avoid packaging the dummy liballoc_jemalloc on that platform.\n     for host in build.config.host.iter() {\n+        cmd_finder.must_have(build.cxx(host).unwrap());\n+\n+        // The msvc hosts don't use jemalloc, turn it off globally to\n+        // avoid packaging the dummy liballoc_jemalloc on that platform.\n         if host.contains(\"msvc\") {\n             build.config.use_jemalloc = false;\n         }\n     }\n \n     // Externally configured LLVM requires FileCheck to exist\n-    let filecheck = build.llvm_filecheck(&build.config.build);\n+    let filecheck = build.llvm_filecheck(&build.build);\n     if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {\n         panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n \n-    for target in build.config.target.iter() {\n+    for target in &build.config.target {\n         // Can't compile for iOS unless we're on macOS\n         if target.contains(\"apple-ios\") &&\n-           !build.config.build.contains(\"apple-darwin\") {\n+           !build.build.contains(\"apple-darwin\") {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n@@ -206,18 +194,6 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n         }\n     }\n \n-    for host in build.flags.host.iter() {\n-        if !build.config.host.contains(host) {\n-            panic!(\"specified host `{}` is not in the ./configure list\", host);\n-        }\n-    }\n-    for target in build.flags.target.iter() {\n-        if !build.config.target.contains(target) {\n-            panic!(\"specified target `{}` is not in the ./configure list\",\n-                   target);\n-        }\n-    }\n-\n     let run = |cmd: &mut Command| {\n         cmd.output().map(|output| {\n             String::from_utf8_lossy(&output.stdout)\n@@ -231,6 +207,6 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     }\n \n     if let Some(ref s) = build.config.ccache {\n-        need_cmd(s.as_ref());\n+        cmd_finder.must_have(s);\n     }\n }"}, {"sha": "c221d7076832fa6aee6b5d7b363d6d29d30a4fbd", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 63, "deletions": 71, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -104,10 +104,10 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"llvm\", \"src/llvm\")\n          .host(true)\n          .dep(move |s| {\n-             if s.target == build.config.build {\n+             if s.target == build.build {\n                  Step::noop()\n              } else {\n-                 s.target(&build.config.build)\n+                 s.target(&build.build)\n              }\n          })\n          .run(move |s| native::llvm(build, s.target));\n@@ -124,7 +124,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                  Step::noop()\n              } else {\n                  s.name(\"librustc\")\n-                  .host(&build.config.build)\n+                  .host(&build.build)\n                   .stage(s.stage - 1)\n              }\n          })\n@@ -148,7 +148,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                 }\n             }\n         }\n-        return ret\n+        ret\n     };\n \n     // ========================================================================\n@@ -215,29 +215,29 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n         let mut rule = rules.build(&krate, \"path/to/nowhere\");\n         rule.dep(move |s| {\n                 if build.force_use_stage1(&s.compiler(), s.target) {\n-                    s.host(&build.config.build).stage(1)\n-                } else if s.host == build.config.build {\n+                    s.host(&build.build).stage(1)\n+                } else if s.host == build.build {\n                     s.name(dep)\n                 } else {\n-                    s.host(&build.config.build)\n+                    s.host(&build.build)\n                 }\n             })\n             .run(move |s| {\n                 if build.force_use_stage1(&s.compiler(), s.target) {\n                     link(build,\n-                         &s.stage(1).host(&build.config.build).compiler(),\n+                         &s.stage(1).host(&build.build).compiler(),\n                          &s.compiler(),\n                          s.target)\n-                } else if s.host == build.config.build {\n+                } else if s.host == build.build {\n                     link(build, &s.compiler(), &s.compiler(), s.target)\n                 } else {\n                     link(build,\n-                         &s.host(&build.config.build).compiler(),\n+                         &s.host(&build.build).compiler(),\n                          &s.compiler(),\n                          s.target)\n                 }\n             });\n-            return rule\n+            rule\n     }\n \n     // Similar to the `libstd`, `libtest`, and `librustc` rules above, except\n@@ -269,7 +269,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"std\") {\n         rules.build(&krate.build_step, path)\n              .dep(|s| s.name(\"startup-objects\"))\n-             .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n+             .dep(move |s| s.name(\"rustc\").host(&build.build).target(s.host))\n              .run(move |s| compile::std(build, s.target, &s.compiler()));\n     }\n     for (krate, path, _default) in krates(\"test\") {\n@@ -280,7 +280,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.build(&krate.build_step, path)\n              .dep(|s| s.name(\"libtest-link\"))\n-             .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n+             .dep(move |s| s.name(\"llvm\").host(&build.build).stage(0))\n              .dep(|s| s.name(\"may-run-build-script\"))\n              .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n     }\n@@ -291,8 +291,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"may-run-build-script\", \"path/to/nowhere\")\n          .dep(move |s| {\n              s.name(\"libstd-link\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n          });\n     rules.build(\"startup-objects\", \"src/rtstartup\")\n          .dep(|s| s.name(\"create-sysroot\").target(s.host))\n@@ -332,7 +332,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n               \"incremental\");\n     }\n \n-    if build.config.build.contains(\"msvc\") {\n+    if build.build.contains(\"msvc\") {\n         // nothing to do for debuginfo tests\n     } else {\n         rules.test(\"check-debuginfo-lldb\", \"src/test/debuginfo-lldb\")\n@@ -352,7 +352,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                                          \"debuginfo-gdb\", \"debuginfo\"));\n         let mut rule = rules.test(\"check-debuginfo\", \"src/test/debuginfo\");\n         rule.default(true);\n-        if build.config.build.contains(\"apple\") {\n+        if build.build.contains(\"apple\") {\n             rule.dep(|s| s.name(\"check-debuginfo-lldb\"));\n         } else {\n             rule.dep(|s| s.name(\"check-debuginfo-gdb\"));\n@@ -594,8 +594,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n              // Cargo depends on procedural macros, which requires a full host\n              // compiler to be available, so we need to depend on that.\n              s.name(\"librustc-link\")\n-              .target(&build.config.build)\n-              .host(&build.config.build)\n+              .target(&build.build)\n+              .host(&build.build)\n          })\n          .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n     rules.build(\"tool-rls\", \"src/tools/rls\")\n@@ -606,8 +606,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(move |s| {\n              // rls, like cargo, uses procedural macros\n              s.name(\"librustc-link\")\n-              .target(&build.config.build)\n-              .host(&build.config.build)\n+              .target(&build.build)\n+              .host(&build.build)\n          })\n          .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n \n@@ -635,35 +635,35 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.doc(\"doc-book\", \"src/doc/book\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::book(build, s.target, \"book\"));\n     rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n     rules.doc(\"doc-reference\", \"src/doc/reference\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n     rules.doc(\"doc-unstable-book\", \"src/doc/unstable-book\")\n          .dep(move |s| {\n              s.name(\"tool-rustbook\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .dep(move |s| s.name(\"doc-unstable-book-gen\"))\n@@ -675,23 +675,23 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.doc(\"doc-standalone\", \"src/doc\")\n          .dep(move |s| {\n              s.name(\"rustc\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::standalone(build, s.target));\n     rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n-         .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build).stage(0))\n+         .dep(move |s| s.name(\"tool-error-index\").target(&build.build).stage(0))\n          .dep(move |s| s.name(\"librustc-link\"))\n          .default(build.config.docs)\n          .host(true)\n          .run(move |s| doc::error_index(build, s.target));\n     rules.doc(\"doc-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n          .dep(move |s| {\n              s.name(\"tool-unstable-book-gen\")\n-              .host(&build.config.build)\n-              .target(&build.config.build)\n+              .host(&build.build)\n+              .target(&build.build)\n               .stage(0)\n          })\n          .dep(move |s| s.name(\"libstd-link\"))\n@@ -725,7 +725,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     // ========================================================================\n     // Distribution targets\n     rules.dist(\"dist-rustc\", \"src/librustc\")\n-         .dep(move |s| s.name(\"rustc\").host(&build.config.build))\n+         .dep(move |s| s.name(\"rustc\").host(&build.build))\n          .host(true)\n          .only_host_build(true)\n          .default(true)\n@@ -811,7 +811,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .host(true)\n          .only_build(true)\n          .only_host_build(true)\n-         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.config.build).stage(0))\n+         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.build).stage(0))\n          .run(move |_| dist::hash_and_sign(build));\n \n     rules.install(\"install-docs\", \"src/doc\")\n@@ -861,8 +861,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     /// Helper to depend on a stage0 build-only rust-installer tool.\n     fn tool_rust_installer<'a>(build: &'a Build, step: &Step<'a>) -> Step<'a> {\n         step.name(\"tool-rust-installer\")\n-            .host(&build.config.build)\n-            .target(&build.config.build)\n+            .host(&build.build)\n+            .target(&build.build)\n             .stage(0)\n     }\n }\n@@ -1058,8 +1058,8 @@ impl<'a> Rules<'a> {\n             build: build,\n             sbuild: Step {\n                 stage: build.flags.stage.unwrap_or(2),\n-                target: &build.config.build,\n-                host: &build.config.build,\n+                target: &build.build,\n+                host: &build.build,\n                 name: \"\",\n             },\n             rules: BTreeMap::new(),\n@@ -1218,16 +1218,9 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n \n         rules.into_iter().flat_map(|(rule, _)| {\n             let hosts = if rule.only_host_build || rule.only_build {\n-                &self.build.config.host[..1]\n-            } else if self.build.flags.host.len() > 0 {\n-                &self.build.flags.host\n+                self.build.build_slice()\n             } else {\n-                &self.build.config.host\n-            };\n-            let targets = if self.build.flags.target.len() > 0 {\n-                &self.build.flags.target\n-            } else {\n-                &self.build.config.target\n+                &self.build.hosts\n             };\n             // Determine the actual targets participating in this rule.\n             // NOTE: We should keep the full projection from build triple to\n@@ -1236,19 +1229,18 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             // the original non-shadowed hosts array is used below.\n             let arr = if rule.host {\n                 // If --target was specified but --host wasn't specified,\n-                // don't run any host-only tests. Also, respect any `--host`\n-                // overrides as done for `hosts`.\n+                // don't run any host-only tests.\n                 if self.build.flags.host.len() > 0 {\n-                    &self.build.flags.host[..]\n+                    &self.build.hosts\n                 } else if self.build.flags.target.len() > 0 {\n                     &[]\n                 } else if rule.only_build {\n-                    &self.build.config.host[..1]\n+                    self.build.build_slice()\n                 } else {\n-                    &self.build.config.host[..]\n+                    &self.build.hosts\n                 }\n             } else {\n-                targets\n+                &self.build.targets\n             };\n \n             hosts.iter().flat_map(move |host| {\n@@ -1326,7 +1318,7 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         for idx in 0..nodes.len() {\n             self.topo_sort(idx, &idx_to_node, &edges, &mut visited, &mut order);\n         }\n-        return order\n+        order\n     }\n \n     /// Builds the dependency graph rooted at `step`.\n@@ -1365,7 +1357,7 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n \n         edges.entry(idx).or_insert(HashSet::new()).extend(deps);\n-        return idx\n+        idx\n     }\n \n     /// Given a dependency graph with a finished list of `nodes`, fill out more\n@@ -1494,8 +1486,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(plan.contains(&step.name(\"dist-docs\")));\n@@ -1517,8 +1509,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(plan.contains(&step.name(\"dist-docs\")));\n@@ -1545,8 +1537,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.host == \"B\"));\n@@ -1575,8 +1567,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.host == \"B\"));\n@@ -1612,8 +1604,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.target == \"A\"));\n@@ -1639,8 +1631,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         assert!(!plan.iter().any(|s| s.target == \"A\"));\n@@ -1683,8 +1675,8 @@ mod tests {\n         let step = super::Step {\n             name: \"\",\n             stage: 2,\n-            host: &build.config.build,\n-            target: &build.config.build,\n+            host: &build.build,\n+            target: &build.build,\n         };\n \n         // rustc built for all for of (A, B) x (A, B)"}, {"sha": "092fb04637ba72da2e0ec80fb421e4dcaee1dd24", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -14,7 +14,6 @@\n //! not a lot of interesting happenings here unfortunately.\n \n use std::env;\n-use std::ffi::OsString;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n@@ -32,16 +31,9 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Copies a file from `src` to `dst`, attempting to use hard links and then\n-/// falling back to an actually filesystem copy if necessary.\n+/// Copies a file from `src` to `dst`\n pub fn copy(src: &Path, dst: &Path) {\n-    // A call to `hard_link` will fail if `dst` exists, so remove it if it\n-    // already exists so we can try to help `hard_link` succeed.\n     let _ = fs::remove_file(&dst);\n-\n-    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n-    // windows), but if that fails just fall back to a slow `copy` operation.\n-    // let res = fs::hard_link(src, dst);\n     let res = fs::copy(src, dst);\n     if let Err(e) = res {\n         panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n@@ -149,8 +141,7 @@ pub fn dylib_path_var() -> &'static str {\n /// Parses the `dylib_path_var()` environment variable, returning a list of\n /// paths that are members of this lookup path.\n pub fn dylib_path() -> Vec<PathBuf> {\n-    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n-        .collect()\n+    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or_default()).collect()\n }\n \n /// `push` all components to `buf`. On windows, append `.exe` to the last component.\n@@ -422,4 +413,4 @@ impl CiEnv {\n             cmd.env(\"TERM\", \"xterm\").args(&[\"--color\", \"always\"]);\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "622cc68964bf7061cc49d3832a69bbc63186c81c", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -2008,10 +2008,10 @@ impl From<Box<str>> for String {\n     }\n }\n \n-#[stable(feature = \"box_from_str\", since = \"1.18.0\")]\n-impl Into<Box<str>> for String {\n-    fn into(self) -> Box<str> {\n-        self.into_boxed_str()\n+#[stable(feature = \"box_from_str\", since = \"1.20.0\")]\n+impl From<String> for Box<str> {\n+    fn from(s: String) -> Box<str> {\n+        s.into_boxed_str()\n     }\n }\n "}, {"sha": "17f1229c2060ef2145c377c122ee8e3996ca5e87", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -274,6 +274,11 @@ fn test_dedup_by() {\n     vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n \n     assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n+\n+    let mut vec = vec![(\"foo\", 1), (\"foo\", 2), (\"bar\", 3), (\"bar\", 4), (\"bar\", 5)];\n+    vec.dedup_by(|a, b| a.0 == b.0 && { b.1 += a.1; true });\n+\n+    assert_eq!(vec, [(\"foo\", 3), (\"bar\", 12)]);\n }\n \n #[test]"}, {"sha": "1a5975686df68b0265dc244170a70a7a2cf8b1e4", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -823,7 +823,8 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes consecutive elements in the vector that resolve to the same key.\n+    /// Removes all but the first of consecutive elements in the vector that resolve to the same\n+    /// key.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///\n@@ -842,11 +843,13 @@ impl<T> Vec<T> {\n         self.dedup_by(|a, b| key(a) == key(b))\n     }\n \n-    /// Removes consecutive elements in the vector according to a predicate.\n+    /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n+    /// relation.\n     ///\n     /// The `same_bucket` function is passed references to two elements from the vector, and\n-    /// returns `true` if the elements compare equal, or `false` if they do not. Only the first\n-    /// of adjacent equal items is kept.\n+    /// returns `true` if the elements compare equal, or `false` if they do not. The elements are\n+    /// passed in opposite order from their order in the vector, so if `same_bucket(a, b)` returns\n+    /// `true`, `a` is removed.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///"}, {"sha": "f133bd93c9178560b852f0c675f52425dab6fde9", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -343,7 +343,7 @@ impl Ordering {\n /// ```\n #[derive(PartialEq, Eq, Debug)]\n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n-pub struct Reverse<T>(pub T);\n+pub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n \n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n impl<T: PartialOrd> PartialOrd for Reverse<T> {"}, {"sha": "322df6e5b47c690e5d05d0204de35701b40d9065", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 129, "deletions": 10, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -49,9 +49,37 @@ impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n ///\n-/// Constructed by the `Formatter::debug_struct` method.\n+/// This is useful when you wish to output a formatted struct as a part of your\n+/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_struct`](struct.Formatter.html#method.debug_struct)\n+/// method.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo {\n+///     bar: i32,\n+///     baz: String,\n+/// }\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_struct(\"Foo\")\n+///            .field(\"bar\", &self.bar)\n+///            .field(\"baz\", &self.baz)\n+///            .finish()\n+///     }\n+/// }\n+///\n+/// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n+/// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -116,9 +144,34 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted tuple as a part of your\n+/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_tuple`](struct.Formatter.html#method.debug_tuple)\n+/// method.\n ///\n-/// Constructed by the `Formatter::debug_tuple` method.\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(i32, String);\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_tuple(\"Foo\")\n+///            .field(&self.0)\n+///            .field(&self.1)\n+///            .finish()\n+///     }\n+/// }\n+///\n+/// // prints \"Foo(10, \"Hello World\")\"\n+/// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -228,9 +281,31 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted set of items as a part\n+/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_set`](struct.Formatter.html#method.debug_set)\n+/// method.\n+///\n+/// # Example\n ///\n-/// Constructed by the `Formatter::debug_set` method.\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(Vec<i32>);\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_set().entries(self.0.iter()).finish()\n+///     }\n+/// }\n+///\n+/// // prints \"{10, 11}\"\n+/// println!(\"{:?}\", Foo(vec![10, 11]));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -277,9 +352,31 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted list of items as a part\n+/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_list`](struct.Formatter.html#method.debug_list)\n+/// method.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(Vec<i32>);\n ///\n-/// Constructed by the `Formatter::debug_list` method.\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_list().entries(self.0.iter()).finish()\n+///     }\n+/// }\n+///\n+/// // prints \"[10, 11]\"\n+/// println!(\"{:?}\", Foo(vec![10, 11]));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n@@ -326,9 +423,31 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n     }\n }\n \n-/// A struct to help with `fmt::Debug` implementations.\n+/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n+///\n+/// This is useful when you wish to output a formatted map as a part of your\n+/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n+///\n+/// This can be constructed by the\n+/// [`Formatter::debug_map`](struct.Formatter.html#method.debug_map)\n+/// method.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Foo(Vec<(String, i32)>);\n+///\n+/// impl fmt::Debug for Foo {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n+///     }\n+/// }\n ///\n-/// Constructed by the `Formatter::debug_map` method.\n+/// // prints \"{\"A\": 10, \"B\": 11}\"\n+/// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n+/// ```\n #[must_use]\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]"}, {"sha": "5f0b11a616eb0f02d236109a00bec23538ee13dc", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -585,11 +585,11 @@ impl From<Box<CStr>> for CString {\n     }\n }\n \n-#[stable(feature = \"box_from_c_string\", since = \"1.18.0\")]\n-impl Into<Box<CStr>> for CString {\n+#[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\n+impl From<CString> for Box<CStr> {\n     #[inline]\n-    fn into(self) -> Box<CStr> {\n-        self.into_boxed_c_str()\n+    fn from(s: CString) -> Box<CStr> {\n+        s.into_boxed_c_str()\n     }\n }\n "}, {"sha": "02a13ed7a5a03d822675da1219dbc27ded40e0ef", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -540,10 +540,10 @@ impl From<Box<OsStr>> for OsString {\n     }\n }\n \n-#[stable(feature = \"box_from_os_string\", since = \"1.18.0\")]\n-impl Into<Box<OsStr>> for OsString {\n-    fn into(self) -> Box<OsStr> {\n-        self.into_boxed_os_str()\n+#[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n+impl From<OsString> for Box<OsStr> {\n+    fn from(s: OsString) -> Box<OsStr> {\n+        s.into_boxed_os_str()\n     }\n }\n "}, {"sha": "e7c7be981d25f64763e427c80a5adafb40761af0", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -1348,10 +1348,10 @@ impl From<Box<Path>> for PathBuf {\n     }\n }\n \n-#[stable(feature = \"box_from_path_buf\", since = \"1.18.0\")]\n-impl Into<Box<Path>> for PathBuf {\n-    fn into(self) -> Box<Path> {\n-        self.into_boxed_path()\n+#[stable(feature = \"box_from_path_buf\", since = \"1.20.0\")]\n+impl From<PathBuf> for Box<Path> {\n+    fn from(p: PathBuf) -> Box<Path> {\n+        p.into_boxed_path()\n     }\n }\n "}, {"sha": "c5a19e8debe93ec349c6ec763791cce3b377faab", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -420,12 +420,19 @@ fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    canonicalize(p)\n-}\n-\n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    ::sys_common::util::dumb_print(format_args!(\"Symlink\\n\"));\n-    unimplemented!();\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_SYMLINK | syscall::O_RDONLY))?;\n+    let mut buf: [u8; 4096] = [0; 4096];\n+    let count = cvt(syscall::read(fd, &mut buf))?;\n+    cvt(syscall::close(fd))?;\n+    Ok(PathBuf::from(unsafe { String::from_utf8_unchecked(Vec::from(&buf[..count])) }))\n+}\n+\n+pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n+    let fd = cvt(syscall::open(dst.to_str().unwrap(),\n+                               syscall::O_SYMLINK | syscall::O_CREAT | syscall::O_WRONLY | 0o777))?;\n+    cvt(syscall::write(fd, src.to_str().unwrap().as_bytes()))?;\n+    cvt(syscall::close(fd))?;\n+    Ok(())\n }\n \n pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {"}, {"sha": "bd603cfe6ef9df25bcfe8380b374a9b0bd1c34b4", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbba5bdbadeef403a64e9e1568cdad225cbcec1/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=2fbba5bdbadeef403a64e9e1568cdad225cbcec1", "patch": "@@ -33,6 +33,7 @@ pub const MAP_WRITE_COMBINE: usize = 2;\n pub const MODE_TYPE: u16 = 0xF000;\n pub const MODE_DIR: u16 = 0x4000;\n pub const MODE_FILE: u16 = 0x8000;\n+pub const MODE_SYMLINK: u16 = 0xA000;\n \n pub const MODE_PERM: u16 = 0x0FFF;\n pub const MODE_SETUID: u16 = 0o4000;\n@@ -53,6 +54,7 @@ pub const O_TRUNC: usize =      0x0400_0000;\n pub const O_EXCL: usize =       0x0800_0000;\n pub const O_DIRECTORY: usize =  0x1000_0000;\n pub const O_STAT: usize =       0x2000_0000;\n+pub const O_SYMLINK: usize =    0x4000_0000;\n pub const O_ACCMODE: usize =    O_RDONLY | O_WRONLY | O_RDWR;\n \n pub const SEEK_SET: usize = 0;"}]}