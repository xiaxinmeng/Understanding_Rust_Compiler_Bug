{"sha": "be72308b7dfcb83925674b68e280f5f625b3100d", "node_id": "C_kwDOAAsO6NoAKGJlNzIzMDhiN2RmY2I4MzkyNTY3NGI2OGUyODBmNWY2MjViMzEwMGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T04:56:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T04:56:35Z"}, "message": "Auto merge of #94634 - Dylan-DPC:rollup-8wx1yrj, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #94446 (UNIX `remove_dir_all()`: Try recursing first on the slow path)\n - #94460 (Reenable generator drop tracking tests and fix mutation handling)\n - #94620 (Edit docs on consistency of `PartialOrd` and `PartialEq`)\n - #94624 (Downgrade `#[test]` on macro call to warning)\n - #94626 (Add known-bug directive to issue #47511 test case)\n - #94631 (Fix typo in c-variadic)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8cad004b408f8bf8d3ccd173ac2adb251581045e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cad004b408f8bf8d3ccd173ac2adb251581045e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be72308b7dfcb83925674b68e280f5f625b3100d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be72308b7dfcb83925674b68e280f5f625b3100d", "html_url": "https://github.com/rust-lang/rust/commit/be72308b7dfcb83925674b68e280f5f625b3100d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be72308b7dfcb83925674b68e280f5f625b3100d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c93948d6e9e09abfffc53d0b863ece16cde7286", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c93948d6e9e09abfffc53d0b863ece16cde7286", "html_url": "https://github.com/rust-lang/rust/commit/8c93948d6e9e09abfffc53d0b863ece16cde7286"}, {"sha": "e8a0a4e2affe1897ac09255735d3ce3b8d89d5fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8a0a4e2affe1897ac09255735d3ce3b8d89d5fa", "html_url": "https://github.com/rust-lang/rust/commit/e8a0a4e2affe1897ac09255735d3ce3b8d89d5fa"}], "stats": {"total": 430, "additions": 194, "deletions": 236}, "files": [{"sha": "0c2d20b8f2dc89eea86804cd2c56ed77d1d4ed11", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -105,14 +105,18 @@ pub fn expand_test_or_bench(\n \n     // Note: non-associated fn items are already handled by `expand_test_or_bench`\n     if !matches!(item.kind, ast::ItemKind::Fn(_)) {\n-        cx.sess\n-            .parse_sess\n-            .span_diagnostic\n-            .struct_span_err(\n-                attr_sp,\n-                \"the `#[test]` attribute may only be used on a non-associated function\",\n-            )\n-            .note(\"the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\")\n+        let diag = &cx.sess.parse_sess.span_diagnostic;\n+        let msg = \"the `#[test]` attribute may only be used on a non-associated function\";\n+        let mut err = match item.kind {\n+            // These were a warning before #92959 and need to continue being that to avoid breaking\n+            // stable user code (#94508).\n+            ast::ItemKind::MacCall(_) => diag.struct_span_warn(attr_sp, msg),\n+            // `.forget_guarantee()` needed to get these two arms to match types. Because of how\n+            // locally close the `.emit()` call is I'm comfortable with it, but if it can be\n+            // reworked in the future to not need it, it'd be nice.\n+            _ => diag.struct_span_err(attr_sp, msg).forget_guarantee(),\n+        };\n+        err.span_label(attr_sp, \"the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\")\n             .span_label(item.span, format!(\"expected a non-associated function, found {} {}\", item.kind.article(), item.kind.descr()))\n             .span_suggestion(attr_sp, \"replace with conditional compilation to make the item only exist when tests are being run\", String::from(\"#[cfg(test)]\"), Applicability::MaybeIncorrect)\n             .emit();"}, {"sha": "40ee6d863b5a7043fed064be998a6b635ae87159", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -6,14 +6,14 @@ use crate::{\n use hir::{def_id::DefId, Body, HirId, HirIdMap};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n \n pub(super) fn find_consumed_and_borrowed<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     def_id: DefId,\n     body: &'tcx Body<'tcx>,\n ) -> ConsumedAndBorrowedPlaces {\n-    let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n+    let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx, fcx.param_env);\n     expr_use_visitor.consume_body(fcx, def_id, body);\n     expr_use_visitor.places\n }\n@@ -36,14 +36,16 @@ pub(super) struct ConsumedAndBorrowedPlaces {\n /// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n /// record the parent expression, which is the point where the drop actually takes place.\n struct ExprUseDelegate<'tcx> {\n-    hir: Map<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     places: ConsumedAndBorrowedPlaces,\n }\n \n impl<'tcx> ExprUseDelegate<'tcx> {\n-    fn new(hir: Map<'tcx>) -> Self {\n+    fn new(tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Self {\n         Self {\n-            hir,\n+            tcx,\n+            param_env,\n             places: ConsumedAndBorrowedPlaces {\n                 consumed: <_>::default(),\n                 borrowed: <_>::default(),\n@@ -77,7 +79,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n         diag_expr_id: HirId,\n     ) {\n-        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n+        let parent = match self.tcx.hir().find_parent_node(place_with_id.hir_id) {\n             Some(parent) => parent,\n             None => place_with_id.hir_id,\n         };\n@@ -107,11 +109,22 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n         diag_expr_id: HirId,\n     ) {\n-        debug!(\"mutate {:?}; diag_expr_id={:?}\", assignee_place, diag_expr_id);\n-        // Count mutations as a borrow.\n-        self.places\n-            .borrowed\n-            .insert(TrackedValue::from_place_with_projections_allowed(assignee_place));\n+        debug!(\"mutate {assignee_place:?}; diag_expr_id={diag_expr_id:?}\");\n+        // If the type being assigned needs dropped, then the mutation counts as a borrow\n+        // since it is essentially doing `Drop::drop(&mut x); x = new_value;`.\n+        if assignee_place.place.base_ty.needs_drop(self.tcx, self.param_env) {\n+            self.places\n+                .borrowed\n+                .insert(TrackedValue::from_place_with_projections_allowed(assignee_place));\n+        }\n+    }\n+\n+    fn bind(\n+        &mut self,\n+        binding_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: HirId,\n+    ) {\n+        debug!(\"bind {binding_place:?}; diag_expr_id={diag_expr_id:?}\");\n     }\n \n     fn fake_read("}, {"sha": "8c19bbd3214eea75bec1513f8aa9ea23656010eb", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -51,6 +51,15 @@ pub trait Delegate<'tcx> {\n     /// `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n+    /// The path at `binding_place` is a binding that is being initialized.\n+    ///\n+    /// This covers cases such as `let x = 42;`\n+    fn bind(&mut self, binding_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n+        // Bindings can normally be treated as a regular assignment, so by default we\n+        // forward this to the mutate callback.\n+        self.mutate(binding_place, diag_expr_id)\n+    }\n+\n     /// The `place` should be a fake read because of specified `cause`.\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId);\n }\n@@ -648,11 +657,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n                     debug!(\"walk_pat: pat_ty={:?}\", pat_ty);\n \n-                    // Each match binding is effectively an assignment to the\n-                    // binding being produced.\n                     let def = Res::Local(canonical_id);\n                     if let Ok(ref binding_place) = mc.cat_res(pat.hir_id, pat.span, pat_ty, def) {\n-                        delegate.mutate(binding_place, binding_place.hir_id);\n+                        delegate.bind(binding_place, binding_place.hir_id);\n                     }\n \n                     // It is also a borrow or copy/move of the value being matched."}, {"sha": "ddaeb9eca975c7d28364bdeb2dc641119d24b4e4", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -885,19 +885,18 @@ impl PartialOrd for Ordering {\n /// The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using\n /// the `<`, `<=`, `>`, and `>=` operators, respectively.\n ///\n-/// The methods of this trait must be consistent with each other and with those of `PartialEq` in\n-/// the following sense:\n-///\n-/// - `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n-/// - `a < b` if and only if `partial_cmp(a, b) == Some(Less)`\n-///   (ensured by the default implementation).\n-/// - `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`\n-///   (ensured by the default implementation).\n-/// - `a <= b` if and only if `a < b || a == b`\n-///   (ensured by the default implementation).\n-/// - `a >= b` if and only if `a > b || a == b`\n-///   (ensured by the default implementation).\n-/// - `a != b` if and only if `!(a == b)` (already part of `PartialEq`).\n+/// The methods of this trait must be consistent with each other and with those of [`PartialEq`].\n+/// The following conditions must hold:\n+///\n+/// 1. `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n+/// 2. `a < b` if and only if `partial_cmp(a, b) == Some(Less)`\n+/// 3. `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`\n+/// 4. `a <= b` if and only if `a < b || a == b`\n+/// 5. `a >= b` if and only if `a > b || a == b`\n+/// 6. `a != b` if and only if `!(a == b)`.\n+///\n+/// Conditions 2\u20135 above are ensured by the default implementation.\n+/// Condition 6 is already ensured by [`PartialEq`].\n ///\n /// If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with\n /// `partial_cmp` (see the documentation of that trait for the exact requirements). It's"}, {"sha": "0851f512fd01b6644b1e3e98e960c9003a4a8948", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 74, "deletions": 131, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1482,140 +1482,60 @@ mod remove_dir_impl {\n     pub use crate::sys_common::fs::remove_dir_all;\n }\n \n-// Dynamically choose implementation Macos x86-64: modern for 10.10+, fallback for older versions\n-#[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+// Modern implementation using openat(), unlinkat() and fdopendir()\n+#[cfg(not(any(target_os = \"redox\", target_os = \"espidf\")))]\n mod remove_dir_impl {\n-    use super::{cstr, lstat, Dir, InnerReadDir, ReadDir};\n+    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n     use crate::ffi::CStr;\n     use crate::io;\n     use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n     use crate::os::unix::prelude::{OwnedFd, RawFd};\n     use crate::path::{Path, PathBuf};\n     use crate::sync::Arc;\n-    use crate::sys::weak::weak;\n     use crate::sys::{cvt, cvt_r};\n-    use libc::{c_char, c_int, DIR};\n-\n-    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n-        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n-        let fd = cvt_r(|| unsafe {\n-            openat.get().unwrap()(\n-                parent_fd.unwrap_or(libc::AT_FDCWD),\n-                p.as_ptr(),\n-                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n-            )\n-        })?;\n-        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n-    }\n \n-    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n-        weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n-        let ptr = unsafe { fdopendir.get().unwrap()(dir_fd.as_raw_fd()) };\n-        if ptr.is_null() {\n-            return Err(io::Error::last_os_error());\n-        }\n-        let dirp = Dir(ptr);\n-        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n-        let new_parent_fd = dir_fd.into_raw_fd();\n-        // a valid root is not needed because we do not call any functions involving the full path\n-        // of the DirEntrys.\n-        let dummy_root = PathBuf::new();\n-        Ok((\n-            ReadDir {\n-                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n-                end_of_stream: false,\n-            },\n-            new_parent_fd,\n-        ))\n-    }\n-\n-    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n-        weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n+    #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\"),))]\n+    use libc::{fdopendir, openat, unlinkat};\n+    #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+    use macos_weak::{fdopendir, openat, unlinkat};\n \n-        let pcstr = cstr(p)?;\n+    #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+    mod macos_weak {\n+        use crate::sys::weak::weak;\n+        use libc::{c_char, c_int, DIR};\n \n-        // entry is expected to be a directory, open as such\n-        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+        fn get_openat_fn() -> Option<unsafe extern \"C\" fn(c_int, *const c_char, c_int) -> c_int> {\n+            weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+            openat.get()\n+        }\n \n-        // open the directory passing ownership of the fd\n-        let (dir, fd) = fdreaddir(fd)?;\n-        for child in dir {\n-            let child = child?;\n-            match child.entry.d_type {\n-                libc::DT_DIR => {\n-                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                }\n-                libc::DT_UNKNOWN => {\n-                    match cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })\n-                    {\n-                        // type unknown - try to unlink\n-                        Err(err) if err.raw_os_error() == Some(libc::EPERM) => {\n-                            // if the file is a directory unlink fails with EPERM\n-                            remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                        }\n-                        result => {\n-                            result?;\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // not a directory -> unlink\n-                    cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })?;\n-                }\n-            }\n+        pub fn has_openat() -> bool {\n+            get_openat_fn().is_some()\n         }\n \n-        // unlink the directory after removing its contents\n-        cvt(unsafe {\n-            unlinkat.get().unwrap()(\n-                parent_fd.unwrap_or(libc::AT_FDCWD),\n-                pcstr.as_ptr(),\n-                libc::AT_REMOVEDIR,\n-            )\n-        })?;\n-        Ok(())\n-    }\n+        pub unsafe fn openat(dirfd: c_int, pathname: *const c_char, flags: c_int) -> c_int {\n+            get_openat_fn().map(|openat| openat(dirfd, pathname, flags)).unwrap_or_else(|| {\n+                crate::sys::unix::os::set_errno(libc::ENOSYS);\n+                -1\n+            })\n+        }\n \n-    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n-        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n-        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n-        // into symlinks.\n-        let attr = lstat(p)?;\n-        if attr.file_type().is_symlink() {\n-            crate::fs::remove_file(p)\n-        } else {\n-            remove_dir_all_recursive(None, p)\n+        pub unsafe fn fdopendir(fd: c_int) -> *mut DIR {\n+            weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n+            fdopendir.get().map(|fdopendir| fdopendir(fd)).unwrap_or_else(|| {\n+                crate::sys::unix::os::set_errno(libc::ENOSYS);\n+                crate::ptr::null_mut()\n+            })\n         }\n-    }\n \n-    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n-        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n-        if openat.get().is_some() {\n-            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n-            remove_dir_all_modern(p)\n-        } else {\n-            // fall back to classic implementation\n-            crate::sys_common::fs::remove_dir_all(p)\n+        pub unsafe fn unlinkat(dirfd: c_int, pathname: *const c_char, flags: c_int) -> c_int {\n+            weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n+            unlinkat.get().map(|unlinkat| unlinkat(dirfd, pathname, flags)).unwrap_or_else(|| {\n+                crate::sys::unix::os::set_errno(libc::ENOSYS);\n+                -1\n+            })\n         }\n     }\n-}\n-\n-// Modern implementation using openat(), unlinkat() and fdopendir()\n-#[cfg(not(any(\n-    all(target_os = \"macos\", target_arch = \"x86_64\"),\n-    target_os = \"redox\",\n-    target_os = \"espidf\"\n-)))]\n-mod remove_dir_impl {\n-    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n-    use crate::ffi::CStr;\n-    use crate::io;\n-    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n-    use crate::os::unix::prelude::{OwnedFd, RawFd};\n-    use crate::path::{Path, PathBuf};\n-    use crate::sync::Arc;\n-    use crate::sys::{cvt, cvt_r};\n-    use libc::{fdopendir, openat, unlinkat};\n \n     pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n         let fd = cvt_r(|| unsafe {\n@@ -1683,8 +1603,21 @@ mod remove_dir_impl {\n     fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n         let pcstr = cstr(p)?;\n \n-        // entry is expected to be a directory, open as such\n-        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+        // try opening as directory\n+        let fd = match openat_nofollow_dironly(parent_fd, &pcstr) {\n+            Err(err) if err.raw_os_error() == Some(libc::ENOTDIR) => {\n+                // not a directory - don't traverse further\n+                return match parent_fd {\n+                    // unlink...\n+                    Some(parent_fd) => {\n+                        cvt(unsafe { unlinkat(parent_fd, pcstr.as_ptr(), 0) }).map(drop)\n+                    }\n+                    // ...unless this was supposed to be the deletion root directory\n+                    None => Err(err),\n+                };\n+            }\n+            result => result?,\n+        };\n \n         // open the directory passing ownership of the fd\n         let (dir, fd) = fdreaddir(fd)?;\n@@ -1697,19 +1630,13 @@ mod remove_dir_impl {\n                 Some(false) => {\n                     cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) })?;\n                 }\n-                None => match cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) }) {\n-                    // type unknown - try to unlink\n-                    Err(err)\n-                        if err.raw_os_error() == Some(libc::EISDIR)\n-                            || err.raw_os_error() == Some(libc::EPERM) =>\n-                    {\n-                        // if the file is a directory unlink fails with EISDIR on Linux and EPERM everyhwere else\n-                        remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                    }\n-                    result => {\n-                        result?;\n-                    }\n-                },\n+                None => {\n+                    // POSIX specifies that calling unlink()/unlinkat(..., 0) on a directory can succeed\n+                    // if the process has the appropriate privileges. This however can causing orphaned\n+                    // directories requiring an fsck e.g. on Solaris and Illumos. So we try recursing\n+                    // into it first instead of trying to unlink() it.\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n             }\n         }\n \n@@ -1720,7 +1647,7 @@ mod remove_dir_impl {\n         Ok(())\n     }\n \n-    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n         // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n         // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n         // into symlinks.\n@@ -1731,4 +1658,20 @@ mod remove_dir_impl {\n             remove_dir_all_recursive(None, p)\n         }\n     }\n+\n+    #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        remove_dir_all_modern(p)\n+    }\n+\n+    #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        if macos_weak::has_openat() {\n+            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n+            remove_dir_all_modern(p)\n+        } else {\n+            // fall back to classic implementation\n+            crate::sys_common::fs::remove_dir_all(p)\n+        }\n+    }\n }"}, {"sha": "001c1bfa9ec03080e0686e1e013d54269a3643a4", "filename": "src/doc/unstable-book/src/language-features/c-variadic.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -7,7 +7,7 @@ The tracking issue for this feature is: [#44930]\n ------------------------\n \n The `c_variadic` language feature enables C-variadic functions to be\n-defined in Rust. The may be called both from within Rust and via FFI.\n+defined in Rust. They may be called both from within Rust and via FFI.\n \n ## Examples\n "}, {"sha": "d7f8d7ac546c052884c439298b52ff48e66e413b", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,9 +1,5 @@\n // edition:2018\n-// compile-flags: --crate-type lib\n-\n-// FIXME(eholk): temporarily disabled while drop range tracking is disabled\n-// (see generator_interior.rs:27)\n-// ignore-test\n+// compile-flags: --crate-type lib -Zdrop-tracking\n \n use std::{cell::RefCell, fmt::Debug, rc::Rc};\n "}, {"sha": "fa3f3303677daa204b6f607faa962a8f4301ca1c", "filename": "src/test/ui/async-await/drop-and-assign.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-and-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-and-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-and-assign.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -0,0 +1,19 @@\n+// edition:2021\n+// compile-flags: -Zdrop-tracking\n+// build-pass\n+\n+struct A;\n+impl Drop for A { fn drop(&mut self) {} }\n+\n+pub async fn f() {\n+    let mut a = A;\n+    a = A;\n+    drop(a);\n+    async {}.await;\n+}\n+\n+fn assert_send<T: Send>(_: T) {}\n+\n+fn main() {\n+    let _ = f();\n+}"}, {"sha": "6d6d80614910403afb7e5d2816d21c72eca30d14", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -2,10 +2,7 @@\n // Error message should pinpoint the type parameter T as needing to be bound\n // (rather than give a general error message)\n // edition:2018\n-\n-// FIXME(eholk): temporarily disabled while drop range tracking is disabled\n-// (see generator_interior.rs:27)\n-// ignore-test\n+// compile-flags: -Zdrop-tracking\n \n async fn bar<T>() -> () {}\n "}, {"sha": "7236c681f341cef1080752841952136c960f3472", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,35 +1,35 @@\n error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n+  --> $DIR/unresolved_type_param.rs:10:5\n    |\n LL |     bar().await;\n    |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n    |\n note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n+  --> $DIR/unresolved_type_param.rs:10:10\n    |\n LL |     bar().await;\n    |          ^^^^^^\n \n error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n+  --> $DIR/unresolved_type_param.rs:10:5\n    |\n LL |     bar().await;\n    |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n    |\n note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n+  --> $DIR/unresolved_type_param.rs:10:10\n    |\n LL |     bar().await;\n    |          ^^^^^^\n \n error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n+  --> $DIR/unresolved_type_param.rs:10:5\n    |\n LL |     bar().await;\n    |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n    |\n note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n+  --> $DIR/unresolved_type_param.rs:10:10\n    |\n LL |     bar().await;\n    |          ^^^^^^"}, {"sha": "d383680002f4b9fcdde3eadb3a3d6c7d0f923293", "filename": "src/test/ui/generator/drop-control-flow.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,10 +1,6 @@\n // build-pass\n // compile-flags: -Zdrop-tracking\n \n-// FIXME(eholk): temporarily disabled while drop range tracking is disabled\n-// (see generator_interior.rs:27)\n-// ignore-test\n-\n // A test to ensure generators capture values that were conditionally dropped,\n // and also that values that are dropped along all paths to a yield do not get\n // included in the generator type."}, {"sha": "91407ea1844f54922c084cb77f34619928f7d1e9", "filename": "src/test/ui/generator/issue-57478.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,8 +1,5 @@\n // check-pass\n-\n-// FIXME(eholk): temporarily disabled while drop range tracking is disabled\n-// (see generator_interior.rs:27)\n-// ignore-test\n+// compile-flags: -Zdrop-tracking\n \n #![feature(negative_impls, generators)]\n "}, {"sha": "c872fb7f3e6305745d3d4ff91c3d6a32aebdf3f7", "filename": "src/test/ui/generator/partial-drop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,6 +1,4 @@\n-// FIXME(eholk): temporarily disabled while drop range tracking is disabled\n-// (see generator_interior.rs:27)\n-// ignore-test\n+// compile-flags: -Zdrop-tracking\n \n #![feature(negative_impls, generators)]\n "}, {"sha": "16b34c917ece43395c24d729324f3d22188f11d9", "filename": "src/test/ui/generator/partial-drop.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,12 +1,12 @@\n error: generator cannot be sent between threads safely\n-  --> $DIR/partial-drop.rs:12:5\n+  --> $DIR/partial-drop.rs:14:5\n    |\n LL |     assert_send(|| {\n    |     ^^^^^^^^^^^ generator is not `Send`\n    |\n-   = help: within `[generator@$DIR/partial-drop.rs:12:17: 18:6]`, the trait `Send` is not implemented for `Foo`\n+   = help: within `[generator@$DIR/partial-drop.rs:14:17: 20:6]`, the trait `Send` is not implemented for `Foo`\n note: generator is not `Send` as this value is used across a yield\n-  --> $DIR/partial-drop.rs:17:9\n+  --> $DIR/partial-drop.rs:19:9\n    |\n LL |         let guard = Bar { foo: Foo, x: 42 };\n    |             ----- has type `Bar` which is not `Send`\n@@ -16,20 +16,20 @@ LL |         yield;\n LL |     });\n    |     - `guard` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/partial-drop.rs:40:19\n+  --> $DIR/partial-drop.rs:42:19\n    |\n LL | fn assert_send<T: Send>(_: T) {}\n    |                   ^^^^ required by this bound in `assert_send`\n \n error: generator cannot be sent between threads safely\n-  --> $DIR/partial-drop.rs:20:5\n+  --> $DIR/partial-drop.rs:22:5\n    |\n LL |     assert_send(|| {\n    |     ^^^^^^^^^^^ generator is not `Send`\n    |\n-   = help: within `[generator@$DIR/partial-drop.rs:20:17: 28:6]`, the trait `Send` is not implemented for `Foo`\n+   = help: within `[generator@$DIR/partial-drop.rs:22:17: 30:6]`, the trait `Send` is not implemented for `Foo`\n note: generator is not `Send` as this value is used across a yield\n-  --> $DIR/partial-drop.rs:27:9\n+  --> $DIR/partial-drop.rs:29:9\n    |\n LL |         let guard = Bar { foo: Foo, x: 42 };\n    |             ----- has type `Bar` which is not `Send`\n@@ -39,20 +39,20 @@ LL |         yield;\n LL |     });\n    |     - `guard` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/partial-drop.rs:40:19\n+  --> $DIR/partial-drop.rs:42:19\n    |\n LL | fn assert_send<T: Send>(_: T) {}\n    |                   ^^^^ required by this bound in `assert_send`\n \n error: generator cannot be sent between threads safely\n-  --> $DIR/partial-drop.rs:30:5\n+  --> $DIR/partial-drop.rs:32:5\n    |\n LL |     assert_send(|| {\n    |     ^^^^^^^^^^^ generator is not `Send`\n    |\n-   = help: within `[generator@$DIR/partial-drop.rs:30:17: 37:6]`, the trait `Send` is not implemented for `Foo`\n+   = help: within `[generator@$DIR/partial-drop.rs:32:17: 39:6]`, the trait `Send` is not implemented for `Foo`\n note: generator is not `Send` as this value is used across a yield\n-  --> $DIR/partial-drop.rs:36:9\n+  --> $DIR/partial-drop.rs:38:9\n    |\n LL |         let guard = Bar { foo: Foo, x: 42 };\n    |             ----- has type `Bar` which is not `Send`\n@@ -62,7 +62,7 @@ LL |         yield;\n LL |     });\n    |     - `guard` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/partial-drop.rs:40:19\n+  --> $DIR/partial-drop.rs:42:19\n    |\n LL | fn assert_send<T: Send>(_: T) {}\n    |                   ^^^^ required by this bound in `assert_send`"}, {"sha": "98c141b6c6a1ddc943b53bfb01e7d80c4059459e", "filename": "src/test/ui/issues/issue-47511.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fissues%2Fissue-47511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fissues%2Fissue-47511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47511.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,14 +1,15 @@\n+// check-fail\n+// known-bug\n+\n // Regression test for #47511: anonymous lifetimes can appear\n // unconstrained in a return type, but only if they appear just once\n // in the input, as the input to a projection.\n \n fn f(_: X) -> X {\n-    //~^ ERROR return type references an anonymous lifetime\n     unimplemented!()\n }\n \n fn g<'a>(_: X<'a>) -> X<'a> {\n-    //~^ ERROR return type references lifetime `'a`, which is not constrained\n     unimplemented!()\n }\n "}, {"sha": "5b84f7ed62c3a18239eb36191ebbe7795660b496", "filename": "src/test/ui/issues/issue-47511.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -1,13 +1,13 @@\n error[E0581]: return type references an anonymous lifetime, which is not constrained by the fn input types\n-  --> $DIR/issue-47511.rs:5:15\n+  --> $DIR/issue-47511.rs:8:15\n    |\n LL | fn f(_: X) -> X {\n    |               ^\n    |\n    = note: lifetimes appearing in an associated type are not considered constrained\n \n error[E0581]: return type references lifetime `'a`, which is not constrained by the fn input types\n-  --> $DIR/issue-47511.rs:10:23\n+  --> $DIR/issue-47511.rs:12:23\n    |\n LL | fn g<'a>(_: X<'a>) -> X<'a> {\n    |                       ^^^^^"}, {"sha": "a460480afb157efb7e030c3087dfa19da80b53e3", "filename": "src/test/ui/test-attrs/test-on-not-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-not-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-not-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-not-fn.rs?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -58,7 +58,7 @@ macro_rules! foo {\n     () => {};\n }\n \n-#[test] //~ ERROR: the `#[test]` attribute may only be used on a non-associated function\n+#[test] //~ WARN: the `#[test]` attribute may only be used on a non-associated function\n foo!();\n \n // make sure it doesn't erroneously trigger on a real test"}, {"sha": "23efd5bc0d9faee37fc5571f80e92eed55c6f3d0", "filename": "src/test/ui/test-attrs/test-on-not-fn.stderr", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-not-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be72308b7dfcb83925674b68e280f5f625b3100d/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-not-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-not-fn.stderr?ref=be72308b7dfcb83925674b68e280f5f625b3100d", "patch": "@@ -2,11 +2,10 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:3:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | mod test {}\n    | ----------- expected a non-associated function, found a module\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -16,7 +15,7 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:6:1\n    |\n LL |   #[test]\n-   |   ^^^^^^^\n+   |   ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | / mod loooooooooooooong_teeeeeeeeeest {\n LL | |     /*\n LL | |     this is a comment\n@@ -26,7 +25,6 @@ LL | |     */\n LL | | }\n    | |_- expected a non-associated function, found a module\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -36,11 +34,10 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:20:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | extern \"C\" {}\n    | ------------- expected a non-associated function, found an extern block\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -50,11 +47,10 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:23:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | trait Foo {}\n    | ------------ expected a non-associated function, found a trait\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -64,11 +60,10 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:26:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | impl Foo for i32 {}\n    | ------------------- expected a non-associated function, found an implementation\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -78,11 +73,10 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:29:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | const FOO: i32 = -1_i32;\n    | ------------------------ expected a non-associated function, found a constant item\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -92,11 +86,10 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:32:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | static BAR: u64 = 10_000_u64;\n    | ----------------------------- expected a non-associated function, found a static item\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -106,13 +99,12 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:35:1\n    |\n LL |   #[test]\n-   |   ^^^^^^^\n+   |   ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | / enum MyUnit {\n LL | |     Unit,\n LL | | }\n    | |_- expected a non-associated function, found an enum\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -122,11 +114,10 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:40:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | struct NewI32(i32);\n    | ------------------- expected a non-associated function, found a struct\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -136,14 +127,13 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:43:1\n    |\n LL |   #[test]\n-   |   ^^^^^^^\n+   |   ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | / union Spooky {\n LL | |     x: i32,\n LL | |     y: u32,\n LL | | }\n    | |_- expected a non-associated function, found a union\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n@@ -153,33 +143,31 @@ error: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:50:1\n    |\n LL |   #[test]\n-   |   ^^^^^^^\n+   |   ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL |   #[derive(Copy, Clone, Debug)]\n LL | / struct MoreAttrs {\n LL | |     a: i32,\n LL | |     b: u64,\n LL | | }\n    | |_- expected a non-associated function, found a struct\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n    | ~~~~~~~~~~~~\n \n-error: the `#[test]` attribute may only be used on a non-associated function\n+warning: the `#[test]` attribute may only be used on a non-associated function\n   --> $DIR/test-on-not-fn.rs:61:1\n    |\n LL | #[test]\n-   | ^^^^^^^\n+   | ^^^^^^^ the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n LL | foo!();\n    | ------- expected a non-associated function, found an item macro invocation\n    |\n-   = note: the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\n help: replace with conditional compilation to make the item only exist when tests are being run\n    |\n LL | #[cfg(test)]\n    | ~~~~~~~~~~~~\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors; 1 warning emitted\n "}]}