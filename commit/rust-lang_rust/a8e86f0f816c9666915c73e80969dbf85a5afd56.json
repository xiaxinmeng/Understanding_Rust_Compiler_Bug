{"sha": "a8e86f0f816c9666915c73e80969dbf85a5afd56", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZTg2ZjBmODE2Yzk2NjY5MTVjNzNlODA5NjlkYmY4NWE1YWZkNTY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-17T14:04:36Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-21T12:16:46Z"}, "message": "Fix fallout in `rustdoc` and tests.", "tree": {"sha": "91270a89ac1fe7a4d87e9c3785fd6bb69db8a6c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91270a89ac1fe7a4d87e9c3785fd6bb69db8a6c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8e86f0f816c9666915c73e80969dbf85a5afd56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e86f0f816c9666915c73e80969dbf85a5afd56", "html_url": "https://github.com/rust-lang/rust/commit/a8e86f0f816c9666915c73e80969dbf85a5afd56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8e86f0f816c9666915c73e80969dbf85a5afd56/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9935e4a377e6055bc9f52fd7f130c55728736d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9935e4a377e6055bc9f52fd7f130c55728736d4", "html_url": "https://github.com/rust-lang/rust/commit/c9935e4a377e6055bc9f52fd7f130c55728736d4"}], "stats": {"total": 250, "additions": 120, "deletions": 130}, "files": [{"sha": "103e2a949df19a24177df00930985a4f650441fc", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -1764,9 +1764,7 @@ mod tests {\n     use std::rc::Rc;\n     use super::{OutputType, OutputTypes, Externs};\n     use rustc_back::PanicStrategy;\n-    use syntax::{ast, attr};\n-    use syntax::parse::token::InternedString;\n-    use syntax::codemap::dummy_spanned;\n+    use syntax::symbol::Symbol;\n \n     fn optgroups() -> Vec<OptGroup> {\n         super::rustc_optgroups().into_iter()\n@@ -1795,9 +1793,7 @@ mod tests {\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess, cfg);\n-        assert!(attr::contains(&cfg, &dummy_spanned(ast::MetaItemKind::Word({\n-            InternedString::new(\"test\")\n-        }))));\n+        assert!(cfg.contains(&(Symbol::intern(\"test\"), None)));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1818,7 +1814,7 @@ mod tests {\n         let sess = build_session(sessopts, &dep_graph, None, registry,\n                                  Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess, cfg);\n-        let mut test_items = cfg.iter().filter(|m| m.name() == \"test\");\n+        let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());\n     }"}, {"sha": "228119e6cc7da46206696a7bf6452a38361182cc", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -54,7 +54,7 @@ use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n use syntax::parse::{self, PResult};\n-use syntax::symbol::{self, Symbol};\n+use syntax::symbol::Symbol;\n use syntax::util::node_count::NodeCounter;\n use syntax;\n use syntax_ext;"}, {"sha": "a4f0e2903847765b197d0685564fda2bc83b9919", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -34,8 +34,8 @@ use syntax::codemap::CodeMap;\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n-use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::Symbol;\n \n use rustc::hir;\n \n@@ -288,11 +288,11 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n+        self.infcx.tcx.mk_param(index, Symbol::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n-        let name = token::intern(name);\n+        let name = Symbol::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,"}, {"sha": "2cc1882ce3eae3411adaf179d03132f1127d51af", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -24,9 +24,9 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use syntax::print::pprust as syntax_pprust;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n@@ -242,7 +242,7 @@ impl Clean<ExternalCrate> for CrateNum {\n             }\n         });\n         ExternalCrate {\n-            name: (&cx.sess().cstore.crate_name(self.0)[..]).to_owned(),\n+            name: cx.sess().cstore.crate_name(self.0).to_string(),\n             attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n             primitives: primitives,\n         }\n@@ -2577,7 +2577,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n-            &a.name()[..] == \"doc\" && match a.meta_item_list() {\n+            a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(l, \"no_inline\") ||\n                            attr::list_contains_name(l, \"hidden\"),\n                 None => false,"}, {"sha": "3cdfa718eabae2a7f85568b8c3dea57bc42cd494", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -871,6 +871,7 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use symbol::keywords;\n     use std::rc::Rc;\n \n     #[test]\n@@ -1097,10 +1098,9 @@ mod tests {\n     #[test]\n     fn t11() {\n         // Test span_to_expanded_string works with expansion\n-        use ast::Name;\n         let cm = init_code_map();\n         let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n-        let format = ExpnFormat::MacroBang(Name(0u32));\n+        let format = ExpnFormat::MacroBang(keywords::Invalid.name());\n         let callee = NameAndSpan { format: format,\n                                    allow_internal_unstable: false,\n                                    span: None };\n@@ -1197,11 +1197,9 @@ mod tests {\n     fn init_expansion_chain(cm: &CodeMap) -> Span {\n         // Creates an expansion chain containing two recursive calls\n         // root -> expA -> expA -> expB -> expB -> end\n-        use ast::Name;\n-\n         let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n \n-        let format_root = ExpnFormat::MacroBang(Name(0u32));\n+        let format_root = ExpnFormat::MacroBang(keywords::Invalid.name());\n         let callee_root = NameAndSpan { format: format_root,\n                                         allow_internal_unstable: false,\n                                         span: Some(root) };\n@@ -1210,7 +1208,7 @@ mod tests {\n         let id_a1 = cm.record_expansion(info_a1);\n         let span_a1 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a1 };\n \n-        let format_a = ExpnFormat::MacroBang(Name(1u32));\n+        let format_a = ExpnFormat::MacroBang(keywords::As.name());\n         let callee_a = NameAndSpan { format: format_a,\n                                       allow_internal_unstable: false,\n                                       span: Some(span_a1) };\n@@ -1223,7 +1221,7 @@ mod tests {\n         let id_b1 = cm.record_expansion(info_b1);\n         let span_b1 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b1 };\n \n-        let format_b = ExpnFormat::MacroBang(Name(2u32));\n+        let format_b = ExpnFormat::MacroBang(keywords::Box.name());\n         let callee_b = NameAndSpan { format: format_b,\n                                      allow_internal_unstable: false,\n                                      span: None };"}, {"sha": "ff0255a2f21f23f2d255949c53f8f842030c0334", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -1332,9 +1332,8 @@ pub fn noop_fold_vis<T: Folder>(vis: Visibility, folder: &mut T) -> Visibility {\n #[cfg(test)]\n mod tests {\n     use std::io;\n-    use ast;\n+    use ast::{self, Ident};\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n-    use parse::token;\n     use print::pprust;\n     use fold;\n     use super::*;\n@@ -1350,7 +1349,7 @@ mod tests {\n \n     impl Folder for ToZzIdentFolder {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n-            token::str_to_ident(\"zz\")\n+            Ident::from_str(\"zz\")\n         }\n         fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n             fold::noop_fold_mac(mac, self)"}, {"sha": "681dec0ab564d1c922cf60320583f43314e06331", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -1702,6 +1702,7 @@ mod tests {\n     use super::*;\n \n     use ast::Ident;\n+    use symbol::Symbol;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION};\n     use codemap::CodeMap;\n     use errors;\n@@ -1752,7 +1753,7 @@ mod tests {\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan {\n-            tok: token::Ident(str_to_ident(\"main\")),\n+            tok: token::Ident(Ident::from_str(\"main\")),\n             sp: Span {\n                 lo: BytePos(24),\n                 hi: BytePos(28),\n@@ -1774,7 +1775,7 @@ mod tests {\n \n     // make the identifier by looking up the string in the interner\n     fn mk_ident(id: &str) -> token::Token {\n-        token::Ident(str_to_ident(id))\n+        token::Ident(Ident::from_str(id))\n     }\n \n     #[test]\n@@ -1838,7 +1839,7 @@ mod tests {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n-                   token::Lifetime(token::str_to_ident(\"'abc\")));\n+                   token::Lifetime(Ident::from_str(\"'abc\")));\n     }\n \n     #[test]\n@@ -1848,7 +1849,7 @@ mod tests {\n         assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                        .next_token()\n                        .tok,\n-                   token::Literal(token::StrRaw(Symol::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n+                   token::Literal(token::StrRaw(Symbol::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n     }\n \n     #[test]"}, {"sha": "be340a5b5aa93e0a9fca53629de5bfe931f30aa3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -597,12 +597,11 @@ mod tests {\n     use std::rc::Rc;\n     use syntax_pos::{self, Span, BytePos, Pos, NO_EXPANSION};\n     use codemap::Spanned;\n-    use ast::{self, PatKind};\n+    use ast::{self, Ident, PatKind};\n     use abi::Abi;\n     use attr::first_attr_value_str_by_name;\n     use parse;\n     use parse::parser::Parser;\n-    use parse::token::{str_to_ident};\n     use print::pprust::item_to_string;\n     use ptr::P;\n     use tokenstream::{self, TokenTree};\n@@ -624,7 +623,7 @@ mod tests {\n                         global: false,\n                         segments: vec![\n                             ast::PathSegment {\n-                                identifier: str_to_ident(\"a\"),\n+                                identifier: Ident::from_str(\"a\"),\n                                 parameters: ast::PathParameters::none(),\n                             }\n                         ],\n@@ -643,11 +642,11 @@ mod tests {\n                             global: true,\n                             segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"a\"),\n+                                    identifier: Ident::from_str(\"a\"),\n                                     parameters: ast::PathParameters::none(),\n                                 },\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"b\"),\n+                                    identifier: Ident::from_str(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                             ]\n@@ -676,8 +675,8 @@ mod tests {\n                 Some(&TokenTree::Token(_, token::Ident(name_zip))),\n                 Some(&TokenTree::Delimited(_, ref macro_delimed)),\n             )\n-            if name_macro_rules.name.as_str() == \"macro_rules\"\n-            && name_zip.name.as_str() == \"zip\" => {\n+            if name_macro_rules.name == \"macro_rules\"\n+            && name_zip.name == \"zip\" => {\n                 let tts = &macro_delimed.tts[..];\n                 match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                     (\n@@ -694,8 +693,7 @@ mod tests {\n                                 Some(&TokenTree::Token(_, token::Dollar)),\n                                 Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n-                            if first_delimed.delim == token::Paren\n-                            && ident.name.as_str() == \"a\" => {},\n+                            if first_delimed.delim == token::Paren && ident.name == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n@@ -706,7 +704,7 @@ mod tests {\n                                 Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n                             if second_delimed.delim == token::Paren\n-                            && ident.name.as_str() == \"a\" => {},\n+                            && ident.name == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),\n                         }\n                     },\n@@ -722,17 +720,17 @@ mod tests {\n         let tts = string_to_tts(\"fn a (b : i32) { b; }\".to_string());\n \n         let expected = vec![\n-            TokenTree::Token(sp(0, 2), token::Ident(str_to_ident(\"fn\"))),\n-            TokenTree::Token(sp(3, 4), token::Ident(str_to_ident(\"a\"))),\n+            TokenTree::Token(sp(0, 2), token::Ident(Ident::from_str(\"fn\"))),\n+            TokenTree::Token(sp(3, 4), token::Ident(Ident::from_str(\"a\"))),\n             TokenTree::Delimited(\n                 sp(5, 14),\n                 Rc::new(tokenstream::Delimited {\n                     delim: token::DelimToken::Paren,\n                     open_span: sp(5, 6),\n                     tts: vec![\n-                        TokenTree::Token(sp(6, 7), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(6, 7), token::Ident(Ident::from_str(\"b\"))),\n                         TokenTree::Token(sp(8, 9), token::Colon),\n-                        TokenTree::Token(sp(10, 13), token::Ident(str_to_ident(\"i32\"))),\n+                        TokenTree::Token(sp(10, 13), token::Ident(Ident::from_str(\"i32\"))),\n                     ],\n                     close_span: sp(13, 14),\n                 })),\n@@ -742,7 +740,7 @@ mod tests {\n                     delim: token::DelimToken::Brace,\n                     open_span: sp(15, 16),\n                     tts: vec![\n-                        TokenTree::Token(sp(17, 18), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(17, 18), token::Ident(Ident::from_str(\"b\"))),\n                         TokenTree::Token(sp(18, 19), token::Semi),\n                     ],\n                     close_span: sp(20, 21),\n@@ -763,7 +761,7 @@ mod tests {\n                             global: false,\n                             segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"d\"),\n+                                    identifier: Ident::from_str(\"d\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                             ],\n@@ -786,7 +784,7 @@ mod tests {\n                                global:false,\n                                segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"b\"),\n+                                    identifier: Ident::from_str(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                                ],\n@@ -810,7 +808,7 @@ mod tests {\n                 id: ast::DUMMY_NODE_ID,\n                 node: PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                     Spanned{ span:sp(0, 1),\n-                                             node: str_to_ident(\"b\")\n+                                             node: Ident::from_str(\"b\")\n                     },\n                                     None),\n                 span: sp(0,1)}));\n@@ -822,7 +820,7 @@ mod tests {\n         // this test depends on the intern order of \"fn\" and \"i32\"\n         assert_eq!(string_to_item(\"fn a (b : i32) { b; }\".to_string()),\n                   Some(\n-                      P(ast::Item{ident:str_to_ident(\"a\"),\n+                      P(ast::Item{ident:Ident::from_str(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemKind::Fn(P(ast::FnDecl {\n@@ -833,8 +831,7 @@ mod tests {\n                                         global:false,\n                                         segments: vec![\n                                             ast::PathSegment {\n-                                                identifier:\n-                                                    str_to_ident(\"i32\"),\n+                                                identifier: Ident::from_str(\"i32\"),\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n                                         ],\n@@ -847,7 +844,7 @@ mod tests {\n                                             ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                                 Spanned{\n                                                     span: sp(6,7),\n-                                                    node: str_to_ident(\"b\")},\n+                                                    node: Ident::from_str(\"b\")},\n                                                 None\n                                                     ),\n                                             span: sp(6,7)\n@@ -882,9 +879,7 @@ mod tests {\n                                                         global:false,\n                                                         segments: vec![\n                                                             ast::PathSegment {\n-                                                                identifier:\n-                                                                str_to_ident(\n-                                                                    \"b\"),\n+                                                                identifier: Ident::from_str(\"b\"),\n                                                                 parameters:\n                                                                 ast::PathParameters::none(),\n                                                             }\n@@ -996,20 +991,20 @@ mod tests {\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[..], \"/// doc comment\");\n+        assert_eq!(doc, \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n-        let docs = item.attrs.iter().filter(|a| &*a.name() == \"doc\")\n+        let docs = item.attrs.iter().filter(|a| a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, &sess).unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[..], \"/** doc comment\\n *  with CRLF */\");\n+        assert_eq!(doc, \"/** doc comment\\n *  with CRLF */\");\n     }\n \n     #[test]"}, {"sha": "3820f5ea90ccc6e147e835b9515f63a12f8164dc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -3080,12 +3080,11 @@ mod tests {\n \n     use ast;\n     use codemap;\n-    use parse::token;\n     use syntax_pos;\n \n     #[test]\n     fn test_fun_to_string() {\n-        let abba_ident = token::str_to_ident(\"abba\");\n+        let abba_ident = ast::Ident::from_str(\"abba\");\n \n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n@@ -3101,7 +3100,7 @@ mod tests {\n \n     #[test]\n     fn test_variant_to_string() {\n-        let ident = token::str_to_ident(\"principal_skinner\");\n+        let ident = ast::Ident::from_str(\"principal_skinner\");\n \n         let var = codemap::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n             name: ident,"}, {"sha": "0d5dcaf339feb086f6dddabb627cf161cce958cb", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -872,8 +872,9 @@ impl Index<usize> for InternalTS {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use syntax::ast::Ident;\n     use syntax_pos::{Span, BytePos, NO_EXPANSION, DUMMY_SP};\n-    use parse::token::{self, str_to_ident, Token};\n+    use parse::token::{self, Token};\n     use util::parser_testing::string_to_tts;\n     use std::rc::Rc;\n \n@@ -968,15 +969,17 @@ mod tests {\n         let test_res = TokenStream::from_tts(string_to_tts(\"foo::bar::baz\".to_string()))\n             .slice(2..3);\n         let test_eqs = TokenStream::from_tts(vec![TokenTree::Token(sp(5,8),\n-                                                    token::Ident(str_to_ident(\"bar\")))]);\n+                                                    token::Ident(Ident::from_str(\"bar\")))]);\n         assert_eq!(test_res, test_eqs)\n     }\n \n     #[test]\n     fn test_is_empty() {\n         let test0 = TokenStream::from_tts(Vec::new());\n-        let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),\n-                                                                Token::Ident(str_to_ident(\"a\")))]);\n+        let test1 = TokenStream::from_tts(\n+            vec![TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\")))]\n+        );\n+\n         let test2 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n \n         assert_eq!(test0.is_empty(), true);\n@@ -1036,20 +1039,20 @@ mod tests {\n         assert_eq!(test0, None);\n \n         let test1_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                                        token::Ident(Ident::from_str(\"bar\"))),\n                                        TokenTree::Token(sp(4, 6), token::ModSep),\n                                        TokenTree::Token(sp(6, 9),\n-                                                        token::Ident(str_to_ident(\"baz\")))]);\n+                                                        token::Ident(Ident::from_str(\"baz\")))]);\n         assert_eq!(test1, Some(test1_expected));\n \n         let test2_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(str_to_ident(\"foo\"))),\n+                                                        token::Ident(Ident::from_str(\"foo\"))),\n                                        TokenTree::Token(sp(4, 5), token::Comma),\n                                        TokenTree::Token(sp(5, 8),\n-                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                                        token::Ident(Ident::from_str(\"bar\"))),\n                                        TokenTree::Token(sp(8, 9), token::Comma),\n                                        TokenTree::Token(sp(9, 12),\n-                                                        token::Ident(str_to_ident(\"baz\")))]);\n+                                                        token::Ident(Ident::from_str(\"baz\")))]);\n         assert_eq!(test2, Some(test2_expected));\n \n         assert_eq!(test3, None);\n@@ -1070,7 +1073,7 @@ mod tests {\n \n         assert_eq!(test0, None);\n         assert_eq!(test1, None);\n-        assert_eq!(test2, Some(str_to_ident(\"foo\")));\n+        assert_eq!(test2, Some(Ident::from_str(\"foo\")));\n         assert_eq!(test3, None);\n         assert_eq!(test4, None);\n     }\n@@ -1080,9 +1083,9 @@ mod tests {\n         let test0 = as_paren_delimited_stream(string_to_tts(\"foo,bar,\".to_string()));\n         let test1 = as_paren_delimited_stream(string_to_tts(\"baz(foo,bar)\".to_string()));\n \n-        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"foo\"))),\n+        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"foo\"))),\n                              TokenTree::Token(sp(3, 4), token::Comma),\n-                             TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"bar\"))),\n+                             TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"bar\"))),\n                              TokenTree::Token(sp(7, 8), token::Comma)];\n         let test0_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(0, 8),\n                                                                Rc::new(Delimited {\n@@ -1095,11 +1098,11 @@ mod tests {\n         assert_eq!(test0, test0_stream);\n \n \n-        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"foo\"))),\n+        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"foo\"))),\n                              TokenTree::Token(sp(7, 8), token::Comma),\n-                             TokenTree::Token(sp(8, 11), token::Ident(str_to_ident(\"bar\")))];\n+                             TokenTree::Token(sp(8, 11), token::Ident(Ident::from_str(\"bar\")))];\n \n-        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"baz\"))),\n+        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"baz\"))),\n                                TokenTree::Delimited(sp(3, 12),\n                                                     Rc::new(Delimited {\n                                                         delim: token::DelimToken::Paren,"}, {"sha": "e703dc6b4191c50f933fa82e98777eb9cbf189fe", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use ast::{self, Ident};\n use parse::{ParseSess,PResult,filemap_to_tts};\n use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n-use parse::token;\n use ptr::P;\n use tokenstream;\n use std::iter::Peekable;\n@@ -78,9 +77,9 @@ pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n     })\n }\n \n-/// Convert a vector of strings to a vector of ast::Ident's\n-pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n-    ids.iter().map(|u| token::str_to_ident(*u)).collect()\n+/// Convert a vector of strings to a vector of Ident's\n+pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<Ident> {\n+    ids.iter().map(|u| Ident::from_str(*u)).collect()\n }\n \n /// Does the given string match the pattern? whitespace in the first string"}, {"sha": "8647797270f9a841f5092b974faf0ec745509cbb", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name.as_str() == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "dc88bfc40595f4401da5db5c86f16c2eede12ccd", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -19,8 +19,9 @@ extern crate rustc_plugin;\n \n use syntax::ast::{self, Item, MetaItem, ItemKind};\n use syntax::ext::base::*;\n-use syntax::parse::{self, token};\n+use syntax::parse;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::TokenTree;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n@@ -34,11 +35,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n-        token::intern(\"into_multi_foo\"),\n+        Symbol::intern(\"into_multi_foo\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n-        token::intern(\"duplicate\"),\n+        Symbol::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n }\n@@ -102,9 +103,9 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n                     push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {\n-        ast::MetaItemKind::List(_, ref xs) => {\n+        ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                token::str_to_ident(&word.name())\n+                ast::Ident::with_empty_ctxt(word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "8acab3369e48fb3ef3ba71b3c45160eaf2750970", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -16,8 +16,8 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::parse;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -30,7 +30,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "092adbf29e340cd52394c00e169fdb4dd746544f", "filename": "src/test/parse-fail/attr-bad-meta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// error-pattern:expected `]`\n+// error-pattern:expected one of `=` or `]`\n \n // asterisk is bogus\n #[attr*]"}, {"sha": "d692bb519c149ec33c24269302f268505e24f507", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -19,8 +19,8 @@ extern crate syntax_pos;\n \n use syntax::ast;\n use syntax::codemap;\n-use syntax::parse;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -33,7 +33,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "0336fe277c51f8eb6f064d6e248d1f0d00e26653", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -25,6 +25,7 @@ use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n \n+use std::collections::HashSet;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n@@ -65,7 +66,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n-    let cfg = build_configuration(&sess, vec![]);\n+    let cfg = build_configuration(&sess, HashSet::new());\n     let control = CompileController::basic();\n     let input = Input::Str { name: anon_src(), input: code };\n     compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);"}, {"sha": "664bb9da89a5765fa19fb4dd4a94f3f5930dcd06", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_noprelude_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -20,10 +20,10 @@ extern crate syntax;\n \n use proc_macro_tokens::build::ident_eq;\n \n+use syntax::ast::Ident;\n use syntax::ext::base::{ExtCtxt, MacResult};\n use syntax::ext::proc_macro_shim::build_block_emitter;\n use syntax::tokenstream::{TokenTree, TokenStream};\n-use syntax::parse::token::str_to_ident;\n use syntax::codemap::Span;\n \n use rustc_plugin::Registry;\n@@ -57,7 +57,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "31a5f5968bab6addf652bb73bf1a9fb834826497", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -26,7 +26,7 @@ use syntax::ast::Ident;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::ext::proc_macro_shim::build_block_emitter;\n use syntax::ext::base::{ExtCtxt, MacResult};\n-use syntax::parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+use syntax::parse::token::{self, Token, DelimToken};\n use syntax::tokenstream::{TokenTree, TokenStream};\n \n #[plugin_registrar]\n@@ -58,7 +58,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "6a2d159a4bdd96e774025f72df238e7ddac836ae", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_prelude_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -52,7 +52,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "da82545ca721077558db271454d522f587890407", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_partial_eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -25,12 +25,12 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{intern, InternedString};\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(intern(\"derive_CustomPartialEq\"),\n+    reg.register_syntax_extension(Symbol::intern(\"derive_CustomPartialEq\"),\n                                   MultiDecorator(Box::new(expand_deriving_partial_eq)));\n }\n \n@@ -52,7 +52,7 @@ fn expand_deriving_partial_eq(cx: &mut ExtCtxt, span: Span, mitem: &MetaItem, it\n                 substr)\n     }\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let methods = vec![MethodDef {\n         name: \"eq\","}, {"sha": "07f7d6bad7bf2b40967b8830f4bdc380dafcd0cc", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_plugin;\n use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax_pos::Span;\n@@ -32,7 +32,7 @@ use rustc_plugin::Registry;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n-        token::intern(\"derive_TotalSum\"),\n+        Symbol::intern(\"derive_TotalSum\"),\n         MultiDecorator(box expand));\n }\n \n@@ -66,7 +66,7 @@ fn expand(cx: &mut ExtCtxt,\n                             |cx, span, subexpr, field, _| {\n                                 cx.expr_binary(span, ast::BinOpKind::Add, subexpr,\n                                     cx.expr_method_call(span, field,\n-                                        token::str_to_ident(\"total_sum\"), vec![]))\n+                                        ast::Ident::from_str(\"total_sum\"), vec![]))\n                             },\n                             zero,\n                             box |cx, span, _, _| { cx.span_bug(span, \"wtf??\"); },"}, {"sha": "50b16a0e26fb49b79a951e0b8d019a73e5012aa9", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_plugin;\n use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n@@ -34,7 +34,7 @@ use rustc_plugin::Registry;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n-        token::intern(\"derive_TotalSum\"),\n+        Symbol::intern(\"derive_TotalSum\"),\n         MultiDecorator(box expand));\n }\n "}, {"sha": "8647797270f9a841f5092b974faf0ec745509cbb", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name.as_str() == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "29cc6b7db94741c4b44b1f0b5e66a65cea1a5b0a", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -23,6 +23,7 @@ use syntax::ext::base::*;\n use syntax::ext::quote::rt::ToTokens;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::TokenTree;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n@@ -36,15 +37,15 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n-        token::intern(\"into_multi_foo\"),\n+        Symbol::intern(\"into_multi_foo\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n-        token::intern(\"duplicate\"),\n+        Symbol::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n     reg.register_syntax_extension(\n-        token::intern(\"caller\"),\n+        Symbol::intern(\"caller\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_caller)));\n }\n@@ -108,9 +109,9 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n                     it: &Annotatable,\n                     push: &mut FnMut(Annotatable)) {\n     let copy_name = match mi.node {\n-        ast::MetaItemKind::List(_, ref xs) => {\n+        ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                token::str_to_ident(&word.name())\n+                ast::Ident::with_empty_ctxt(word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;\n@@ -179,7 +180,7 @@ fn expand_caller(cx: &mut ExtCtxt,\n         }\n \n         let fn_name = match list[0].name() {\n-            Some(name) => token::str_to_ident(&name),\n+            Some(name) => ast::Ident::with_empty_ctxt(name),\n             None => cx.span_fatal(list[0].span(), \"First parameter must be an ident.\")\n         };\n "}, {"sha": "ba2af77cdb297f75c2cbc2e6e66c6ee08c4031d3", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -22,9 +22,9 @@ use std::borrow::ToOwned;\n use syntax::ast;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager, NormalTT};\n-use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n use rustc_plugin::Registry;\n@@ -40,15 +40,14 @@ impl TTMacroExpander for Expander {\n                    _: &[tokenstream::TokenTree]) -> Box<MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n-        let interned = token::intern_and_get_ident(&args[..]);\n-        MacEager::expr(ecx.expr_str(sp, interned))\n+        MacEager::expr(ecx.expr_str(sp, Symbol::intern(&args)))\n     }\n }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n-    reg.register_syntax_extension(token::intern(\"plugin_args\"),\n+    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         NormalTT(Box::new(Expander { args: args, }), None, false));\n }"}, {"sha": "f97fb04aadf6ab2149c47be89aaaa677d9e54f0a", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -18,18 +18,19 @@ use proc_macro_tokens::prelude::*;\n use rustc_plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::proc_macro_shim::prelude::*;\n+use syntax::symbol::Symbol;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(token::intern(\"attr_tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"attr_tru\"),\n                                   SyntaxExtension::AttrProcMacro(Box::new(attr_tru)));\n-    reg.register_syntax_extension(token::intern(\"attr_identity\"),\n+    reg.register_syntax_extension(Symbol::intern(\"attr_identity\"),\n                                   SyntaxExtension::AttrProcMacro(Box::new(attr_identity)));\n-    reg.register_syntax_extension(token::intern(\"tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"tru\"),\n                                   SyntaxExtension::ProcMacro(Box::new(tru)));\n-    reg.register_syntax_extension(token::intern(\"ret_tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"ret_tru\"),\n                                   SyntaxExtension::ProcMacro(Box::new(ret_tru)));\n-    reg.register_syntax_extension(token::intern(\"identity\"),\n+    reg.register_syntax_extension(Symbol::intern(\"identity\"),\n                                   SyntaxExtension::ProcMacro(Box::new(identity)));\n }\n "}, {"sha": "2b3857048f36732acc33f5c524aa8cd6f7fa978c", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -18,8 +18,8 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::parse::token::{str_to_ident, NtExpr, NtPat};\n-use syntax::ast::{Pat};\n+use syntax::parse::token::{NtExpr, NtPat};\n+use syntax::ast::{Ident, Pat};\n use syntax::tokenstream::{TokenTree};\n use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n use syntax::ext::build::AstBuilder;\n@@ -44,12 +44,12 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n         }\n     };\n \n-    let matched_nt = match *map[&str_to_ident(\"matched\")] {\n+    let matched_nt = match *map[&Ident::from_str(\"matched\")] {\n         MatchedNonterminal(ref nt) => nt.clone(),\n         _ => unreachable!(),\n     };\n \n-    let mac_expr = match (&*matched_nt, &*map[&str_to_ident(\"pat\")]) {\n+    let mac_expr = match (&*matched_nt, &*map[&Ident::from_str(\"pat\")]) {\n         (&NtExpr(ref matched_expr), &MatchedSeq(ref pats, seq_sp)) => {\n             let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt| {\n                 match **pat_nt {"}, {"sha": "948b20c14771fa48aaf5c60d9e09366daaf75263", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -18,9 +18,6 @@ extern crate proc_macro_tokens;\n use proc_macro_tokens::prelude::*;\n \n extern crate syntax;\n-use syntax::ast::Ident;\n-use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token::{self, Token, keywords, str_to_ident};\n \n fn main() {\n     let lex_true = lex(\"true\");"}, {"sha": "b4ed57192ccf69647015b18639b858c7d7d574df", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e86f0f816c9666915c73e80969dbf85a5afd56/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=a8e86f0f816c9666915c73e80969dbf85a5afd56", "patch": "@@ -16,7 +16,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::print::pprust::*;\n-use syntax::parse::token::intern;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -29,7 +29,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }\n@@ -97,7 +97,7 @@ fn main() {\n     // quote_meta_item!\n \n     let meta = quote_meta_item!(cx, cfg(foo = \"bar\"));\n-    check!(meta_item_to_string, meta, *quote_meta_item!(cx, $meta); r#\"cfg(foo = \"bar\")\"#);\n+    check!(meta_item_to_string, meta, quote_meta_item!(cx, $meta); r#\"cfg(foo = \"bar\")\"#);\n \n     let attr = quote_attr!(cx, #![$meta]);\n     check!(attribute_to_string, attr; r#\"#![cfg(foo = \"bar\")]\"#);"}]}