{"sha": "5048af7a3a0c91e0fc5964c4bf6b373898b320aa", "node_id": "C_kwDOAAsO6NoAKDUwNDhhZjdhM2EwYzkxZTBmYzU5NjRjNGJmNmIzNzM4OThiMzIwYWE", "commit": {"author": {"name": "kyoto7250", "email": "50972773+kyoto7250@users.noreply.github.com", "date": "2022-06-13T14:27:26Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-08-21T08:47:03Z"}, "message": "feat(fix): Do not lint if the target code is inside a loop", "tree": {"sha": "d20c463715e2d7e105097db783b0786adf01984e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d20c463715e2d7e105097db783b0786adf01984e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5048af7a3a0c91e0fc5964c4bf6b373898b320aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmMB8QcACgkQHKDfKvWd\naKUCQw/+NsQlmbZeZztEYRi2XU5al+3OQP6SbUiZtRF1Br8CxB/1v+qSs/MonkVP\nGBFyJV1isDg2sPoFwLPL0XMfm6Y/A3goqy9WRnr1SdKDvbxDlfAWFCroGmqzeX4U\niK9m1QL6m4Ko19FOTQ3UjD0BUkmKtB9RxCgPBy61aln6Do++COyg8+L0Q+sGoSY9\nwqW/i6RSfatTvqoKMEsNu9pq26QX33u2Gbf39SlWGnYrduQFY5TPQ2Ti2cES8pf0\nO2V3h1dn1m2GqiYa8Gru6tIik9umjQROwzCL68GnGOvgrK6eT5Jp73aPvGrFIW20\nvtuaumYwh7+tXcfTw4ytdFCBunB1ZqwKm40OI/KCs5528dGArN10TiM0xbXg88+x\nw1clA/MrnEoZBmeTAQP/7yr3IqtCsGp5UmrUIz43Me0sbKRKZIV8EFtSEQ7TPwvK\nmSH3eEjBarSUp8V1bdzuvZ3UVPbgX+dEIpoMIDqsxyFX2B+8EuTG+HshKp7YJ3l4\nu0eYuYVmPR8CA9it9X4wScCtnc/aEF/HjMChwy1TyGzEhpJFH3GTZzUqYBBHK3f7\ng1vN9AH6i9Nl6VXzjUFB1AVT/bt51U8bX2zvgdkr0YwISweJjWV8QuCiFiE+TpYp\nl+kbEAYKkAAC8ynt9QoxO+92Gp4/5WoSswbq7FUhVIGBo/1GRGU=\n=Luzx\n-----END PGP SIGNATURE-----", "payload": "tree d20c463715e2d7e105097db783b0786adf01984e\nparent 41309df8efe99848a79782ae98ad73638668381c\nauthor kyoto7250 <50972773+kyoto7250@users.noreply.github.com> 1655130446 +0900\ncommitter Philipp Krones <hello@philkrones.com> 1661071623 +0200\n\nfeat(fix): Do not lint if the target code is inside a loop\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5048af7a3a0c91e0fc5964c4bf6b373898b320aa", "html_url": "https://github.com/rust-lang/rust/commit/5048af7a3a0c91e0fc5964c4bf6b373898b320aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5048af7a3a0c91e0fc5964c4bf6b373898b320aa/comments", "author": {"login": "kyoto7250", "id": 50972773, "node_id": "MDQ6VXNlcjUwOTcyNzcz", "avatar_url": "https://avatars.githubusercontent.com/u/50972773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyoto7250", "html_url": "https://github.com/kyoto7250", "followers_url": "https://api.github.com/users/kyoto7250/followers", "following_url": "https://api.github.com/users/kyoto7250/following{/other_user}", "gists_url": "https://api.github.com/users/kyoto7250/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyoto7250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyoto7250/subscriptions", "organizations_url": "https://api.github.com/users/kyoto7250/orgs", "repos_url": "https://api.github.com/users/kyoto7250/repos", "events_url": "https://api.github.com/users/kyoto7250/events{/privacy}", "received_events_url": "https://api.github.com/users/kyoto7250/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41309df8efe99848a79782ae98ad73638668381c", "url": "https://api.github.com/repos/rust-lang/rust/commits/41309df8efe99848a79782ae98ad73638668381c", "html_url": "https://github.com/rust-lang/rust/commit/41309df8efe99848a79782ae98ad73638668381c"}], "stats": {"total": 341, "additions": 339, "deletions": 2}, "files": [{"sha": "cc4827c56b6135131bc11edc2b2f6f560bda0783", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5048af7a3a0c91e0fc5964c4bf6b373898b320aa/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5048af7a3a0c91e0fc5964c4bf6b373898b320aa/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=5048af7a3a0c91e0fc5964c4bf6b373898b320aa", "patch": "@@ -1,5 +1,6 @@\n use super::NEEDLESS_COLLECT;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -184,10 +185,23 @@ struct IterFunctionVisitor<'a, 'tcx> {\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     fn visit_block(&mut self, block: &'tcx Block<'tcx>) {\n         for (expr, hir_id) in block.stmts.iter().filter_map(get_expr_and_hir_id_from_stmt) {\n+            if is_loop(expr) {\n+                continue;\n+            }\n             self.visit_block_expr(expr, hir_id);\n         }\n         if let Some(expr) = block.expr {\n-            self.visit_block_expr(expr, None);\n+            if is_loop(expr) {\n+                if let Some(higher::WhileLet { let_expr, .. }) = higher::WhileLet::hir(expr) {\n+                    self.visit_block_expr(let_expr, None);\n+                } else if let Some(higher::While { condition, .. }) = higher::While::hir(expr) {\n+                    self.visit_block_expr(condition, None);\n+                } else if let Some(higher::ForLoop { arg, .. }) = higher::ForLoop::hir(expr) {\n+                    self.visit_block_expr(arg, None);\n+                }\n+            } else {\n+                self.visit_block_expr(expr, None);\n+            }\n         }\n     }\n \n@@ -264,6 +278,23 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     }\n }\n \n+fn is_loop(expr: &Expr<'_>) -> bool {\n+    if let Some(higher::WhileLet { .. }) = higher::WhileLet::hir(expr) {\n+        return true;\n+    }\n+    if let Some(higher::While { .. }) = higher::While::hir(expr) {\n+        return true;\n+    }\n+    if let Some(higher::ForLoop { .. }) = higher::ForLoop::hir(expr) {\n+        return true;\n+    }\n+    if let ExprKind::Loop { .. } = expr.kind {\n+        return true;\n+    }\n+\n+    false\n+}\n+\n impl<'tcx> IterFunctionVisitor<'_, 'tcx> {\n     fn visit_block_expr(&mut self, expr: &'tcx Expr<'tcx>, hir_id: Option<HirId>) {\n         self.current_statement_hir_id = hir_id;"}, {"sha": "12a9ace1ee688679a5745698e314990480eda9f7", "filename": "tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/5048af7a3a0c91e0fc5964c4bf6b373898b320aa/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5048af7a3a0c91e0fc5964c4bf6b373898b320aa/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=5048af7a3a0c91e0fc5964c4bf6b373898b320aa", "patch": "@@ -112,3 +112,192 @@ fn allow_test() {\n     let v = [1].iter().collect::<Vec<_>>();\n     v.into_iter().collect::<HashSet<_>>();\n }\n+\n+mod issue_8553 {\n+    fn test_for() {\n+        let vec = vec![1, 2];\n+        let w: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+\n+        for i in 0..2 {\n+            // Do not lint, because this method call is in the loop\n+            w.contains(&i);\n+        }\n+\n+        for i in 0..2 {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            // Do lint\n+            y.contains(&i);\n+            for j in 0..2 {\n+                // Do not lint, because this method call is in the loop\n+                z.contains(&j);\n+            }\n+        }\n+\n+        // Do not lint, because this variable is used.\n+        w.contains(&0);\n+    }\n+\n+    fn test_while() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut n = 0;\n+        while n > 1 {\n+            // Do not lint, because this method call is in the loop\n+            x.contains(&n);\n+            n += 1;\n+        }\n+\n+        while n > 2 {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            // Do lint\n+            y.contains(&n);\n+            n += 1;\n+            while n > 4 {\n+                // Do not lint, because this method call is in the loop\n+                z.contains(&n);\n+                n += 1;\n+            }\n+        }\n+    }\n+\n+    fn test_loop() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut n = 0;\n+        loop {\n+            if n < 1 {\n+                // Do not lint, because this method call is in the loop\n+                x.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        loop {\n+            if n < 2 {\n+                let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+                let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+                // Do lint\n+                y.contains(&n);\n+                n += 1;\n+                loop {\n+                    if n < 4 {\n+                        // Do not lint, because this method call is in the loop\n+                        z.contains(&n);\n+                        n += 1;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    fn test_while_let() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let optional = Some(0);\n+        let mut n = 0;\n+        while let Some(value) = optional {\n+            if n < 1 {\n+                // Do not lint, because this method call is in the loop\n+                x.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while let Some(value) = optional {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            if n < 2 {\n+                // Do lint\n+                y.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+\n+            while let Some(value) = optional {\n+                if n < 4 {\n+                    // Do not lint, because this method call is in the loop\n+                    z.contains(&n);\n+                    n += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn test_if_cond() {\n+        let vec = vec![1, 2];\n+        let v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        for _ in 0..w.len() {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_if_cond_false_case() {\n+        let vec = vec![1, 2];\n+        let v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        for _ in 0..w.len() {\n+            todo!();\n+        }\n+\n+        w.len();\n+    }\n+\n+    fn test_while_cond() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        while 1 == w.len() {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_while_cond_false_case() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        while 1 == w.len() {\n+            todo!();\n+        }\n+\n+        w.len();\n+    }\n+\n+    fn test_while_let_cond() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        while let Some(i) = Some(w.len()) {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_while_let_cond_false_case() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        while let Some(i) = Some(w.len()) {\n+            todo!();\n+        }\n+        w.len();\n+    }\n+}"}, {"sha": "9f0880cc6069d1449c7ec43d6386387deddcc5b7", "filename": "tests/ui/needless_collect_indirect.stderr", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5048af7a3a0c91e0fc5964c4bf6b373898b320aa/tests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5048af7a3a0c91e0fc5964c4bf6b373898b320aa/tests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.stderr?ref=5048af7a3a0c91e0fc5964c4bf6b373898b320aa", "patch": "@@ -125,5 +125,122 @@ LL ~\n LL ~         sample.iter().count()\n    |\n \n-error: aborting due to 9 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:127:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |             y.contains(&i);\n+   |             -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             // Do lint\n+LL ~             vec.iter().map(|k| k * k).any(|x| x == i);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:152:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |             y.contains(&n);\n+   |             -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             // Do lint\n+LL ~             vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:181:63\n+   |\n+LL |                 let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                               ^^^^^^^\n+...\n+LL |                 y.contains(&n);\n+   |                 -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~                 \n+LL |                 let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |                 // Do lint\n+LL ~                 vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:217:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |                 y.contains(&n);\n+   |                 -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             if n < 2 {\n+LL |                 // Do lint\n+LL ~                 vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:242:26\n+   |\n+LL |         let w = v.iter().collect::<Vec<_>>();\n+   |                          ^^^^^^^\n+LL |         // Do lint\n+LL |         for _ in 0..w.len() {\n+   |                     ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         for _ in 0..v.iter().count() {\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:264:30\n+   |\n+LL |         let mut w = v.iter().collect::<Vec<_>>();\n+   |                              ^^^^^^^\n+LL |         // Do lint\n+LL |         while 1 == w.len() {\n+   |                    ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         while 1 == v.iter().count() {\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:286:30\n+   |\n+LL |         let mut w = v.iter().collect::<Vec<_>>();\n+   |                              ^^^^^^^\n+LL |         // Do lint\n+LL |         while let Some(i) = Some(w.len()) {\n+   |                                  ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         while let Some(i) = Some(v.iter().count()) {\n+   |\n+\n+error: aborting due to 16 previous errors\n "}]}