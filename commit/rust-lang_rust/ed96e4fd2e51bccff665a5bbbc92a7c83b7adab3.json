{"sha": "ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkOTZlNGZkMmU1MWJjY2ZmNjY1YTViYmJjOTJhN2M4M2I3YWRhYjM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-01T15:15:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-01T15:15:51Z"}, "message": "Rollup merge of #37296 - srinivasreddy:librustc_driver, r=nikomatsakis\n\nrun rustfmt on librustc_driver folder", "tree": {"sha": "4c7b9116295e63f107fca6fbed5d736e7862a8fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c7b9116295e63f107fca6fbed5d736e7862a8fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3", "html_url": "https://github.com/rust-lang/rust/commit/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9820bd02a1a0459b9218c404db7d7a98dc9612f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9820bd02a1a0459b9218c404db7d7a98dc9612f7", "html_url": "https://github.com/rust-lang/rust/commit/9820bd02a1a0459b9218c404db7d7a98dc9612f7"}, {"sha": "f32ce9c1421adfd957d357664e6dc95375ebaab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f32ce9c1421adfd957d357664e6dc95375ebaab0", "html_url": "https://github.com/rust-lang/rust/commit/f32ce9c1421adfd957d357664e6dc95375ebaab0"}], "stats": {"total": 379, "additions": 191, "deletions": 188}, "files": [{"sha": "289a7348cc8dd6b525855fff5046d9e9f285d13e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 145, "deletions": 133, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3", "patch": "@@ -101,8 +101,8 @@ impl PpMode {\n \n     pub fn needs_analysis(&self) -> bool {\n         match *self {\n-             PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n-             _ => false,\n+            PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n+            _ => false,\n         }\n     }\n }\n@@ -233,14 +233,11 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let annotation = TypedAnnotation {\n-                        tcx: tcx,\n-                    };\n+                    let annotation = TypedAnnotation { tcx: tcx };\n                     let _ignore = tcx.dep_graph.in_ignore();\n-                    f(&annotation,\n-                      payload,\n-                      ast_map.forest.krate())\n-                }), sess)\n+                    f(&annotation, payload, ast_map.forest.krate())\n+                }),\n+                             sess)\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -281,9 +278,11 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n     /// Computes an user-readable representation of a path, if possible.\n     fn node_path(&self, id: ast::NodeId) -> Option<String> {\n         self.ast_map().and_then(|map| map.def_path_from_id(id)).map(|path| {\n-            path.data.into_iter().map(|elem| {\n-                elem.data.to_string()\n-            }).collect::<Vec<_>>().join(\"::\")\n+            path.data\n+                .into_iter()\n+                .map(|elem| elem.data.to_string())\n+                .collect::<Vec<_>>()\n+                .join(\"::\")\n         })\n     }\n }\n@@ -352,7 +351,8 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(_) | pprust::NodeName(_) => Ok(()),\n+            pprust::NodeIdent(_) |\n+            pprust::NodeName(_) => Ok(()),\n \n             pprust::NodeItem(item) => {\n                 pp::space(&mut s.s)?;\n@@ -617,15 +617,14 @@ impl ReplaceBodyWithLoop {\n impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n         match i {\n-            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n+            ast::ItemKind::Static(..) |\n+            ast::ItemKind::Const(..) => {\n                 self.within_static_or_const = true;\n                 let ret = fold::noop_fold_item_kind(i, self);\n                 self.within_static_or_const = false;\n                 return ret;\n             }\n-            _ => {\n-                fold::noop_fold_item_kind(i, self)\n-            }\n+            _ => fold::noop_fold_item_kind(i, self),\n         }\n     }\n \n@@ -656,11 +655,15 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode, e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-                stmts: e.map(|e| ast::Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: e.span,\n-                    node: ast::StmtKind::Expr(e),\n-                }).into_iter().collect(),\n+                stmts: e.map(|e| {\n+                        ast::Stmt {\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: e.span,\n+                            node: ast::StmtKind::Expr(e),\n+                        }\n+                    })\n+                    .into_iter()\n+                    .collect(),\n                 rules: rules,\n                 id: ast::DUMMY_NODE_ID,\n                 span: syntax_pos::DUMMY_SP,\n@@ -721,9 +724,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         }\n         blocks::FnLikeCode(fn_like) => {\n             let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n-                                                              fn_like.to_fn_parts(),\n-                                                              &cfg);\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,\n@@ -756,13 +757,13 @@ pub fn fold_crate(krate: ast::Crate, ppm: PpMode) -> ast::Crate {\n fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, String) {\n     let src_name = driver::source_name(input);\n     let src = sess.codemap()\n-                  .get_filemap(&src_name)\n-                  .unwrap()\n-                  .src\n-                  .as_ref()\n-                  .unwrap()\n-                  .as_bytes()\n-                  .to_vec();\n+        .get_filemap(&src_name)\n+        .unwrap()\n+        .src\n+        .as_ref()\n+        .unwrap()\n+        .as_bytes()\n+        .to_vec();\n     (src, src_name)\n }\n \n@@ -795,17 +796,18 @@ pub fn print_after_parsing(sess: &Session,\n         // Silently ignores an identified node.\n         let out: &mut Write = &mut out;\n         s.call_with_pp_support(sess, None, box out, |annotation, out| {\n-            debug!(\"pretty printing source code {:?}\", s);\n-            let sess = annotation.sess();\n-            pprust::print_crate(sess.codemap(),\n-                                sess.diagnostic(),\n-                                krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                annotation.pp_ann(),\n-                                false)\n-        }).unwrap()\n+                debug!(\"pretty printing source code {:?}\", s);\n+                let sess = annotation.sess();\n+                pprust::print_crate(sess.codemap(),\n+                                    sess.diagnostic(),\n+                                    krate,\n+                                    src_name.to_string(),\n+                                    &mut rdr,\n+                                    out,\n+                                    annotation.pp_ann(),\n+                                    false)\n+            })\n+            .unwrap()\n     } else {\n         unreachable!();\n     };\n@@ -828,8 +830,15 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let _ignore = dep_graph.in_ignore();\n \n     if ppm.needs_analysis() {\n-        print_with_analysis(sess, ast_map, analysis, resolutions,\n-                            crate_name, arenas, ppm, opt_uii, ofile);\n+        print_with_analysis(sess,\n+                            ast_map,\n+                            analysis,\n+                            resolutions,\n+                            crate_name,\n+                            arenas,\n+                            ppm,\n+                            opt_uii,\n+                            ofile);\n         return;\n     }\n \n@@ -839,82 +848,82 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     match (ppm, opt_uii) {\n-        (PpmSource(s), _) => {\n-            // Silently ignores an identified node.\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                pprust::print_crate(sess.codemap(),\n-                                    sess.diagnostic(),\n-                                    krate,\n-                                    src_name.to_string(),\n-                                    &mut rdr,\n-                                    out,\n-                                    annotation.pp_ann(),\n-                                    true)\n-            })\n-        }\n+            (PpmSource(s), _) => {\n+                // Silently ignores an identified node.\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    pprust::print_crate(sess.codemap(),\n+                                        sess.diagnostic(),\n+                                        krate,\n+                                        src_name.to_string(),\n+                                        &mut rdr,\n+                                        out,\n+                                        annotation.pp_ann(),\n+                                        true)\n+                })\n+            }\n \n-        (PpmHir(s), None) => {\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n-                                       ast_map,\n-                                       analysis,\n-                                       resolutions,\n-                                       arenas,\n-                                       crate_name,\n-                                       box out,\n-                                       |annotation, out, krate| {\n-                                           debug!(\"pretty printing source code {:?}\", s);\n-                                           let sess = annotation.sess();\n-                                           pprust_hir::print_crate(sess.codemap(),\n-                                                                   sess.diagnostic(),\n-                                                                   krate,\n-                                                                   src_name.to_string(),\n-                                                                   &mut rdr,\n-                                                                   out,\n-                                                                   annotation.pp_ann(),\n-                                                                   true)\n-                                       })\n-        }\n+            (PpmHir(s), None) => {\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support_hir(sess,\n+                                           ast_map,\n+                                           analysis,\n+                                           resolutions,\n+                                           arenas,\n+                                           crate_name,\n+                                           box out,\n+                                           |annotation, out, krate| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    pprust_hir::print_crate(sess.codemap(),\n+                                            sess.diagnostic(),\n+                                            krate,\n+                                            src_name.to_string(),\n+                                            &mut rdr,\n+                                            out,\n+                                            annotation.pp_ann(),\n+                                            true)\n+                })\n+            }\n \n-        (PpmHir(s), Some(uii)) => {\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n-                                       ast_map,\n-                                       analysis,\n-                                       resolutions,\n-                                       arenas,\n-                                       crate_name,\n-                                       (out,uii),\n-                                       |annotation, (out,uii), _| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n-                let mut pp_state =\n-                    pprust_hir::State::new_from_input(sess.codemap(),\n-                                                      sess.diagnostic(),\n-                                                      src_name.to_string(),\n-                                                      &mut rdr,\n-                                                      box out,\n-                                                      annotation.pp_ann(),\n-                                                      true,\n-                                                      Some(ast_map.krate()));\n-                for node_id in uii.all_matching_node_ids(ast_map) {\n-                    let node = ast_map.get(node_id);\n-                    pp_state.print_node(&node)?;\n-                    pp::space(&mut pp_state.s)?;\n-                    let path = annotation.node_path(node_id)\n-                                         .expect(\"--unpretty missing node paths\");\n-                    pp_state.synth_comment(path)?;\n-                    pp::hardbreak(&mut pp_state.s)?;\n-                }\n-                pp::eof(&mut pp_state.s)\n-            })\n-       }\n-       _ => unreachable!(),\n-    }.unwrap();\n+            (PpmHir(s), Some(uii)) => {\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support_hir(sess,\n+                                           ast_map,\n+                                           analysis,\n+                                           resolutions,\n+                                           arenas,\n+                                           crate_name,\n+                                           (out, uii),\n+                                           |annotation, (out, uii), _| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n+                    let mut pp_state = pprust_hir::State::new_from_input(sess.codemap(),\n+                                                                         sess.diagnostic(),\n+                                                                         src_name.to_string(),\n+                                                                         &mut rdr,\n+                                                                         box out,\n+                                                                         annotation.pp_ann(),\n+                                                                         true,\n+                                                                         Some(ast_map.krate()));\n+                    for node_id in uii.all_matching_node_ids(ast_map) {\n+                        let node = ast_map.get(node_id);\n+                        pp_state.print_node(&node)?;\n+                        pp::space(&mut pp_state.s)?;\n+                        let path = annotation.node_path(node_id)\n+                            .expect(\"--unpretty missing node paths\");\n+                        pp_state.synth_comment(path)?;\n+                        pp::hardbreak(&mut pp_state.s)?;\n+                    }\n+                    pp::eof(&mut pp_state.s)\n+                })\n+            }\n+            _ => unreachable!(),\n+        }\n+        .unwrap();\n \n     write_output(out, ofile);\n }\n@@ -955,27 +964,28 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     let def_id = tcx.map.local_def_id(nodeid);\n                     match ppm {\n                         PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n-                        PpmMirCFG => {\n-                            write_mir_graphviz(tcx, iter::once(def_id), &mut out)\n-                        }\n+                        PpmMirCFG => write_mir_graphviz(tcx, iter::once(def_id), &mut out),\n                         _ => unreachable!(),\n                     }?;\n                 } else {\n                     match ppm {\n-                        PpmMir => write_mir_pretty(tcx,\n-                                                   tcx.mir_map.borrow().keys().into_iter(),\n-                                                   &mut out),\n-                        PpmMirCFG => write_mir_graphviz(tcx,\n-                                                        tcx.mir_map.borrow().keys().into_iter(),\n-                                                        &mut out),\n+                        PpmMir => {\n+                            write_mir_pretty(tcx, tcx.mir_map.borrow().keys().into_iter(), &mut out)\n+                        }\n+                        PpmMirCFG => {\n+                            write_mir_graphviz(tcx,\n+                                               tcx.mir_map.borrow().keys().into_iter(),\n+                                               &mut out)\n+                        }\n                         _ => unreachable!(),\n                     }?;\n                 }\n                 Ok(())\n             }\n             PpmFlowGraph(mode) => {\n-                let nodeid = nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or \\\n-                                            unique path suffix (b::c::d)\");\n+                let nodeid =\n+                    nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n+                                   suffix (b::c::d)\");\n                 let node = tcx.map.find(nodeid).unwrap_or_else(|| {\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n@@ -990,8 +1000,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                         print_flowgraph(variants, tcx, code, mode, out)\n                     }\n                     None => {\n-                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n-                                               {:?}\",\n+                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; \\\n+                                               got {:?}\",\n                                               node);\n \n                         // Point to what was found, if there's an accessible span.\n@@ -1004,7 +1014,9 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n             }\n             _ => unreachable!(),\n         }\n-    }), sess).unwrap();\n+    }),\n+                 sess)\n+        .unwrap();\n \n     write_output(out, ofile);\n }"}, {"sha": "ba51947a3330177b6385d8fb11d5e8e32395fbf0", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3", "patch": "@@ -20,26 +20,11 @@ use libc::c_char;\n // detection code will walk past the end of the feature array,\n // leading to crashes.\n \n-const ARM_WHITELIST: &'static [&'static str] = &[\n-    \"neon\\0\",\n-    \"vfp2\\0\",\n-    \"vfp3\\0\",\n-    \"vfp4\\0\",\n-];\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n \n-const X86_WHITELIST: &'static [&'static str] = &[\n-    \"avx\\0\",\n-    \"avx2\\0\",\n-    \"bmi\\0\",\n-    \"bmi2\\0\",\n-    \"sse\\0\",\n-    \"sse2\\0\",\n-    \"sse3\\0\",\n-    \"sse4.1\\0\",\n-    \"sse4.2\\0\",\n-    \"ssse3\\0\",\n-    \"tbm\\0\",\n-];\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n+                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n+                                                 \"ssse3\\0\", \"tbm\\0\"];\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n@@ -59,7 +44,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len()-1])))\n+            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len() - 1])))\n         }\n     }\n }"}, {"sha": "8dc21550148c0d9a54c8955c0c68e8187e564029", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ed96e4fd2e51bccff665a5bbbc92a7c83b7adab3", "patch": "@@ -40,7 +40,7 @@ use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n-struct Env<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n@@ -86,8 +86,7 @@ impl Emitter for ExpectErrorEmitter {\n \n fn errors(msgs: &[&str]) -> (Box<Emitter + Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n-    (box ExpectErrorEmitter { messages: v } as Box<Emitter + Send>,\n-     msgs.len())\n+    (box ExpectErrorEmitter { messages: v } as Box<Emitter + Send>, msgs.len())\n }\n \n fn test_env<F>(source_string: &str,\n@@ -103,18 +102,28 @@ fn test_env<F>(source_string: &str,\n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n-                                       Rc::new(CodeMap::new()), cstore.clone());\n+    let sess = session::build_session_(options,\n+                                       &dep_graph,\n+                                       None,\n+                                       diagnostic_handler,\n+                                       Rc::new(CodeMap::new()),\n+                                       cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: driver::anon_src(),\n         input: source_string.to_string(),\n     };\n     let krate = driver::phase_1_parse_input(&sess, &input).unwrap();\n     let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n-        driver::phase_2_configure_and_expand(\n-            &sess, &cstore, krate, None, \"test\", None, MakeGlobMap::No, |_| Ok(()),\n-        ).expect(\"phase 2 aborted\")\n+        driver::phase_2_configure_and_expand(&sess,\n+                                             &cstore,\n+                                             krate,\n+                                             None,\n+                                             \"test\",\n+                                             None,\n+                                             MakeGlobMap::No,\n+                                             |_| Ok(()))\n+            .expect(\"phase 2 aborted\")\n     };\n     let _ignore = dep_graph.in_ignore();\n \n@@ -167,14 +176,22 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n         let node = ast::NodeId::from_u32;\n         let dscope = self.infcx\n-                         .tcx\n-                         .region_maps\n-                         .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n-                                             region::ROOT_CODE_EXTENT);\n+            .tcx\n+            .region_maps\n+            .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n+                                region::ROOT_CODE_EXTENT);\n         self.create_region_hierarchy(&RH {\n-            id: node(1),\n-            sub: &[RH { id: node(10), sub: &[] }, RH { id: node(11), sub: &[] }],\n-        }, dscope);\n+                                         id: node(1),\n+                                         sub: &[RH {\n+                                                    id: node(10),\n+                                                    sub: &[],\n+                                                },\n+                                                RH {\n+                                                    id: node(11),\n+                                                    sub: &[],\n+                                                }],\n+                                     },\n+                                     dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -213,22 +230,16 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                 hir::ItemStatic(..) |\n                 hir::ItemFn(..) |\n                 hir::ItemForeignMod(..) |\n-                hir::ItemTy(..) => {\n-                    None\n-                }\n+                hir::ItemTy(..) => None,\n \n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemTrait(..) |\n                 hir::ItemImpl(..) |\n-                hir::ItemDefaultImpl(..) => {\n-                    None\n-                }\n+                hir::ItemDefaultImpl(..) => None,\n \n-                hir::ItemMod(ref m) => {\n-                    search_mod(this, m, idx, names)\n-                }\n+                hir::ItemMod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }\n@@ -281,18 +292,17 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n     }\n \n-    pub fn re_early_bound(&self,\n-                          index: u32,\n-                          name: &'static str)\n-                          -> &'tcx ty::Region {\n+    pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n         let name = token::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,\n         }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex)\n+    pub fn re_late_bound_with_debruijn(&self,\n+                                       id: u32,\n+                                       debruijn: ty::DebruijnIndex)\n                                        -> &'tcx ty::Region {\n         self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n@@ -394,19 +404,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n                 self.assert_eq(t, t_lub);\n             }\n-            Err(ref e) => {\n-                panic!(\"unexpected error in LUB: {}\", e)\n-            }\n+            Err(ref e) => panic!(\"unexpected error in LUB: {}\", e),\n         }\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n         match self.glb(t1, t2) {\n-            Err(e) => {\n-                panic!(\"unexpected error computing LUB: {:?}\", e)\n-            }\n+            Err(e) => panic!(\"unexpected error computing LUB: {:?}\", e),\n             Ok(InferOk { obligations, value: t }) => {\n                 // FIXME(#32730) once obligations are being propagated, assert the right thing.\n                 assert!(obligations.is_empty());"}]}