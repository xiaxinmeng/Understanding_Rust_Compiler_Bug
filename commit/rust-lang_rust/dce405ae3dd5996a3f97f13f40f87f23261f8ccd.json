{"sha": "dce405ae3dd5996a3f97f13f40f87f23261f8ccd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZTQwNWFlM2RkNTk5NmEzZjk3ZjEzZjQwZjg3ZjIzMjYxZjhjY2Q=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T18:38:25Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:19:00Z"}, "message": "Take sys/vxworks/net from sys/unix instead.", "tree": {"sha": "9ab095d56e23550b881c8efec05b40dac136a98f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ab095d56e23550b881c8efec05b40dac136a98f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dce405ae3dd5996a3f97f13f40f87f23261f8ccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dce405ae3dd5996a3f97f13f40f87f23261f8ccd", "html_url": "https://github.com/rust-lang/rust/commit/dce405ae3dd5996a3f97f13f40f87f23261f8ccd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dce405ae3dd5996a3f97f13f40f87f23261f8ccd/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a489c33bebaee645efa8be0c9455bed89ef6dd41", "url": "https://api.github.com/repos/rust-lang/rust/commits/a489c33bebaee645efa8be0c9455bed89ef6dd41", "html_url": "https://github.com/rust-lang/rust/commit/a489c33bebaee645efa8be0c9455bed89ef6dd41"}], "stats": {"total": 369, "additions": 9, "deletions": 360}, "files": [{"sha": "74c7db27226ef8a43b6e9f9177daf9914297ba7f", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dce405ae3dd5996a3f97f13f40f87f23261f8ccd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce405ae3dd5996a3f97f13f40f87f23261f8ccd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=dce405ae3dd5996a3f97f13f40f87f23261f8ccd", "patch": "@@ -77,6 +77,7 @@ impl Socket {\n         }\n     }\n \n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n         unsafe {\n             let mut fds = [0, 0];\n@@ -98,6 +99,11 @@ impl Socket {\n         }\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n+        unimplemented!()\n+    }\n+\n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n         let r = unsafe {\n@@ -366,7 +372,7 @@ impl IntoInner<c_int> for Socket {\n // res_init unconditionally, we call it only when we detect we're linking\n // against glibc version < 2.26. (That is, when we both know its needed and\n // believe it's thread-safe).\n-#[cfg(target_env = \"gnu\")]\n+#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\n fn on_resolver_failure() {\n     use crate::sys;\n \n@@ -378,5 +384,5 @@ fn on_resolver_failure() {\n     }\n }\n \n-#[cfg(not(target_env = \"gnu\"))]\n+#[cfg(any(not(target_env = \"gnu\"), target_os = \"vxworks\"))]\n fn on_resolver_failure() {}"}, {"sha": "27e53fa9854c0dee7247746e204ca2d91db9fe0c", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dce405ae3dd5996a3f97f13f40f87f23261f8ccd/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce405ae3dd5996a3f97f13f40f87f23261f8ccd/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=dce405ae3dd5996a3f97f13f40f87f23261f8ccd", "patch": "@@ -26,6 +26,7 @@ pub mod io;\n pub mod memchr;\n #[path = \"../unix/mutex.rs\"]\n pub mod mutex;\n+#[path = \"../unix/net.rs\"]\n pub mod net;\n pub mod os;\n pub mod path;"}, {"sha": "7613fbec46f397c454bab142949fdc58159486c8", "filename": "library/std/src/sys/vxworks/net.rs", "status": "removed", "additions": 0, "deletions": 335, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/a489c33bebaee645efa8be0c9455bed89ef6dd41/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a489c33bebaee645efa8be0c9455bed89ef6dd41/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs?ref=a489c33bebaee645efa8be0c9455bed89ef6dd41", "patch": "@@ -1,335 +0,0 @@\n-#[cfg(all(test, taget_env = \"gnu\"))]\n-mod tests;\n-\n-use crate::cmp;\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::io::{IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::net::{Shutdown, SocketAddr};\n-use crate::str;\n-use crate::sys::fd::FileDesc;\n-use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n-use crate::time::{Duration, Instant};\n-use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n-\n-pub use crate::sys::{cvt, cvt_r};\n-\n-#[allow(unused_extern_crates)]\n-pub extern crate libc as netc;\n-\n-pub type wrlen_t = size_t;\n-\n-pub struct Socket(FileDesc);\n-\n-pub fn init() {}\n-\n-pub fn cvt_gai(err: c_int) -> io::Result<()> {\n-    if err == 0 {\n-        return Ok(());\n-    }\n-\n-    // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n-    on_resolver_failure();\n-\n-    if err == EAI_SYSTEM {\n-        return Err(io::Error::last_os_error());\n-    }\n-\n-    let detail = unsafe {\n-        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n-    };\n-    Err(io::Error::new(\n-        io::ErrorKind::Other,\n-        &format!(\"failed to lookup address information: {}\", detail)[..],\n-    ))\n-}\n-\n-impl Socket {\n-    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n-        let fam = match *addr {\n-            SocketAddr::V4(..) => libc::AF_INET,\n-            SocketAddr::V6(..) => libc::AF_INET6,\n-        };\n-        Socket::new_raw(fam, ty)\n-    }\n-\n-    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n-        unsafe {\n-            let fd = cvt(libc::socket(fam, ty, 0))?;\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            let socket = Socket(fd);\n-            Ok(socket)\n-        }\n-    }\n-\n-    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n-        unimplemented!();\n-    }\n-\n-    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n-        self.set_nonblocking(true)?;\n-        let r = unsafe {\n-            let (addrp, len) = addr.into_inner();\n-            cvt(libc::connect(self.0.raw(), addrp, len))\n-        };\n-        self.set_nonblocking(false)?;\n-\n-        match r {\n-            Ok(_) => return Ok(()),\n-            // there's no ErrorKind for EINPROGRESS :(\n-            Err(ref e) if e.raw_os_error() == Some(libc::EINPROGRESS) => {}\n-            Err(e) => return Err(e),\n-        }\n-\n-        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n-\n-        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"cannot set a 0 duration timeout\",\n-            ));\n-        }\n-\n-        let start = Instant::now();\n-\n-        loop {\n-            let elapsed = start.elapsed();\n-            if elapsed >= timeout {\n-                return Err(io::Error::new(io::ErrorKind::TimedOut, \"connection timed out\"));\n-            }\n-\n-            let timeout = timeout - elapsed;\n-            let mut timeout = timeout\n-                .as_secs()\n-                .saturating_mul(1_000)\n-                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n-            if timeout == 0 {\n-                timeout = 1;\n-            }\n-\n-            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n-\n-            match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n-                -1 => {\n-                    let err = io::Error::last_os_error();\n-                    if err.kind() != io::ErrorKind::Interrupted {\n-                        return Err(err);\n-                    }\n-                }\n-                0 => {}\n-                _ => {\n-                    // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n-                    // for POLLHUP rather than read readiness\n-                    if pollfd.revents & libc::POLLHUP != 0 {\n-                        let e = self.take_error()?.unwrap_or_else(|| {\n-                            io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n-                        });\n-                        return Err(e);\n-                    }\n-\n-                    return Ok(());\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n-        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n-        let fd = FileDesc::new(fd);\n-        fd.set_cloexec()?;\n-        Ok(Socket(fd))\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<Socket> {\n-        self.0.duplicate().map(Socket)\n-    }\n-\n-    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, 0)\n-    }\n-\n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, MSG_PEEK)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    fn recv_from_with_flags(\n-        &self,\n-        buf: &mut [u8],\n-        flags: c_int,\n-    ) -> io::Result<(usize, SocketAddr)> {\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n-\n-        let n = cvt(unsafe {\n-            libc::recvfrom(\n-                self.0.raw(),\n-                buf.as_mut_ptr() as *mut c_void,\n-                buf.len(),\n-                flags,\n-                &mut storage as *mut _ as *mut _,\n-                &mut addrlen,\n-            )\n-        })?;\n-        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n-    }\n-\n-    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_with_flags(buf, 0)\n-    }\n-\n-    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_with_flags(buf, MSG_PEEK)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n-        let timeout = match dur {\n-            Some(dur) => {\n-                if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new(\n-                        io::ErrorKind::InvalidInput,\n-                        \"cannot set a 0 duration timeout\",\n-                    ));\n-                }\n-\n-                let secs = if dur.as_secs() > libc::time_t::MAX as u64 {\n-                    libc::time_t::MAX\n-                } else {\n-                    dur.as_secs() as libc::time_t\n-                };\n-                let mut timeout = libc::timeval {\n-                    tv_sec: secs,\n-                    tv_usec: (dur.subsec_nanos() / 1000) as libc::suseconds_t,\n-                };\n-                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n-                    timeout.tv_usec = 1;\n-                }\n-                timeout\n-            }\n-            None => libc::timeval { tv_sec: 0, tv_usec: 0 },\n-        };\n-        setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n-    }\n-\n-    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n-        let raw: libc::timeval = getsockopt(self, libc::SOL_SOCKET, kind)?;\n-        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n-            Ok(None)\n-        } else {\n-            let sec = raw.tv_sec as u64;\n-            let nsec = (raw.tv_usec as u32) * 1000;\n-            Ok(Some(Duration::new(sec, nsec)))\n-        }\n-    }\n-\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        let how = match how {\n-            Shutdown::Write => libc::SHUT_WR,\n-            Shutdown::Read => libc::SHUT_RD,\n-            Shutdown::Both => libc::SHUT_RDWR,\n-        };\n-        cvt(unsafe { libc::shutdown(self.0.raw(), how) })?;\n-        Ok(())\n-    }\n-\n-    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n-        setsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY, nodelay as c_int)\n-    }\n-\n-    pub fn nodelay(&self) -> io::Result<bool> {\n-        let raw: c_int = getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY)?;\n-        Ok(raw != 0)\n-    }\n-\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        let mut nonblocking = nonblocking as libc::c_int;\n-        cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(drop)\n-    }\n-\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n-        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n-    }\n-}\n-\n-impl AsInner<c_int> for Socket {\n-    fn as_inner(&self) -> &c_int {\n-        self.0.as_inner()\n-    }\n-}\n-\n-impl FromInner<c_int> for Socket {\n-    fn from_inner(fd: c_int) -> Socket {\n-        Socket(FileDesc::new(fd))\n-    }\n-}\n-\n-impl IntoInner<c_int> for Socket {\n-    fn into_inner(self) -> c_int {\n-        self.0.into_raw()\n-    }\n-}\n-\n-// In versions of glibc prior to 2.26, there's a bug where the DNS resolver\n-// will cache the contents of /etc/resolv.conf, so changes to that file on disk\n-// can be ignored by a long-running program. That can break DNS lookups on e.g.\n-// laptops where the network comes and goes. See\n-// https://sourceware.org/bugzilla/show_bug.cgi?id=984. Note however that some\n-// distros including Debian have patched glibc to fix this for a long time.\n-//\n-// A workaround for this bug is to call the res_init libc function, to clear\n-// the cached configs. Unfortunately, while we believe glibc's implementation\n-// of res_init is thread-safe, we know that other implementations are not\n-// (https://github.com/rust-lang/rust/issues/43592). Code here in libstd could\n-// try to synchronize its res_init calls with a Mutex, but that wouldn't\n-// protect programs that call into libc in other ways. So instead of calling\n-// res_init unconditionally, we call it only when we detect we're linking\n-// against glibc version < 2.26. (That is, when we both know its needed and\n-// believe it's thread-safe).\n-#[cfg(target_env = \"gnu\")]\n-fn on_resolver_failure() {\n-    /*\n-    use crate::sys;\n-\n-    // If the version fails to parse, we treat it the same as \"not glibc\".\n-    if let Some(version) = sys::os::glibc_version() {\n-        if version < (2, 26) {\n-            unsafe { libc::res_init() };\n-        }\n-    }\n-    */\n-}\n-\n-#[cfg(not(target_env = \"gnu\"))]\n-fn on_resolver_failure() {}"}, {"sha": "e7c6e348f8e5a44f8cdab12430ad3814ed164313", "filename": "library/std/src/sys/vxworks/net/tests.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a489c33bebaee645efa8be0c9455bed89ef6dd41/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a489c33bebaee645efa8be0c9455bed89ef6dd41/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs?ref=a489c33bebaee645efa8be0c9455bed89ef6dd41", "patch": "@@ -1,23 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn test_res_init() {\n-    // This mostly just tests that the weak linkage doesn't panic wildly...\n-    res_init_if_glibc_before_2_26().unwrap();\n-}\n-\n-#[test]\n-fn test_parse_glibc_version() {\n-    let cases = [\n-        (\"0.0\", Some((0, 0))),\n-        (\"01.+2\", Some((1, 2))),\n-        (\"3.4.5.six\", Some((3, 4))),\n-        (\"1\", None),\n-        (\"1.-2\", None),\n-        (\"1.foo\", None),\n-        (\"foo.1\", None),\n-    ];\n-    for &(version_str, parsed) in cases.iter() {\n-        assert_eq!(parsed, parse_glibc_version(version_str));\n-    }\n-}"}]}