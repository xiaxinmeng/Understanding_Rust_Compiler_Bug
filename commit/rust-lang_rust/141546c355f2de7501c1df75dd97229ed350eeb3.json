{"sha": "141546c355f2de7501c1df75dd97229ed350eeb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MTU0NmMzNTVmMmRlNzUwMWMxZGY3NWRkOTcyMjllZDM1MGVlYjM=", "commit": {"author": {"name": "Wesley Wiser", "email": "wesleywiser@microsoft.com", "date": "2021-05-13T20:39:19Z"}, "committer": {"name": "Wesley Wiser", "email": "wesleywiser@microsoft.com", "date": "2021-06-02T14:23:10Z"}, "message": "Generate better debuginfo for niche-layout enums\n\nPreviously, we would generate a single struct with the layout of the\ndataful variant plus an extra field whose name contained the value of\nthe niche (this would only really work for things like `Option<&_>`\nwhere we can determine that the `None` case maps to `0` but for enums\nthat have multiple tag only variants, this doesn't work).\n\nNow, we generate a union of two structs, one which is the layout of the\ndataful variant and one which just has a way of reading the\ndiscriminant. We also generate an enum which maps the discriminant value\nto the tag only variants.\n\nWe also encode information about the range of values which correspond to\nthe dataful variant in the type name and then use natvis to determine\nwhich union field we should display to the user.\n\nAs a result of this change, all niche-layout enums render correctly in\nWinDbg and Visual Studio!", "tree": {"sha": "8e375f460f557ef3e9e8c3253a503d1dbf6289d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e375f460f557ef3e9e8c3253a503d1dbf6289d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/141546c355f2de7501c1df75dd97229ed350eeb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/141546c355f2de7501c1df75dd97229ed350eeb3", "html_url": "https://github.com/rust-lang/rust/commit/141546c355f2de7501c1df75dd97229ed350eeb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/141546c355f2de7501c1df75dd97229ed350eeb3/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a025c1a765a593030fc6e80a45f4f1053f15aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a025c1a765a593030fc6e80a45f4f1053f15aae", "html_url": "https://github.com/rust-lang/rust/commit/2a025c1a765a593030fc6e80a45f4f1053f15aae"}], "stats": {"total": 272, "additions": 191, "deletions": 81}, "files": [{"sha": "1f268bd18786397290a612d35aa13db0400335ed", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 127, "deletions": 72, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/141546c355f2de7501c1df75dd97229ed350eeb3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141546c355f2de7501c1df75dd97229ed350eeb3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=141546c355f2de7501c1df75dd97229ed350eeb3", "patch": "@@ -1594,77 +1594,144 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 ref variants,\n                 tag_field,\n             } => {\n+                let calculate_niche_value = |i: VariantIdx| {\n+                    if i == dataful_variant {\n+                        None\n+                    } else {\n+                        let value = (i.as_u32() as u128)\n+                            .wrapping_sub(niche_variants.start().as_u32() as u128)\n+                            .wrapping_add(niche_start);\n+                        let value = tag.value.size(cx).truncate(value);\n+                        // NOTE(eddyb) do *NOT* remove this assert, until\n+                        // we pass the full 128-bit value to LLVM, otherwise\n+                        // truncation will be silent and remain undetected.\n+                        assert_eq!(value as u64 as u128, value);\n+                        Some(value as u64)\n+                    }\n+                };\n+\n+                // For MSVC, we will generate a union of two structs, one for the dataful variant and one that just points to\n+                // the discriminant field. We also create an enum that contains tag values for the non-dataful variants and\n+                // make the discriminant field that type. We then use natvis to render the enum type correctly in Windbg/VS.\n                 if fallback {\n-                    let variant = self.layout.for_variant(cx, dataful_variant);\n-                    // Create a description of the non-null variant.\n-                    let (variant_type_metadata, member_description_factory) = describe_enum_variant(\n+                    let unique_type_id = debug_context(cx)\n+                        .type_map\n+                        .borrow_mut()\n+                        .get_unique_type_id_of_enum_variant(cx, self.enum_type, \"discriminant$\");\n+\n+                    let variant_metadata = create_struct_stub(\n+                        cx,\n+                        self.layout.ty,\n+                        &\"discriminant$\",\n+                        unique_type_id,\n+                        Some(self_metadata),\n+                        DIFlags::FlagArtificial,\n+                    );\n+\n+                    let dataful_variant_layout = self.layout.for_variant(cx, dataful_variant);\n+\n+                    let mut discr_enum_ty = tag.value.to_ty(cx.tcx);\n+                    // If the niche is the NULL value of a reference, then `discr_enum_ty` will be a RawPtr.\n+                    // CodeView doesn't know what to do with enums whose base type is a pointer so we fix this up\n+                    // to just be `usize`.\n+                    if let ty::RawPtr(_) = discr_enum_ty.kind() {\n+                        discr_enum_ty = cx.tcx.types.usize;\n+                    }\n+\n+                    let tags: Vec<_> = variants\n+                        .iter_enumerated()\n+                        .filter_map(|(variant_idx, _)| {\n+                            calculate_niche_value(variant_idx).map(|tag| {\n+                                let variant = variant_info_for(variant_idx);\n+                                let name = variant.variant_name();\n+\n+                                Some(unsafe {\n+                                    llvm::LLVMRustDIBuilderCreateEnumerator(\n+                                        DIB(cx),\n+                                        name.as_ptr().cast(),\n+                                        name.len(),\n+                                        tag as i64,\n+                                        !discr_enum_ty.is_signed(),\n+                                    )\n+                                })\n+                            })\n+                        })\n+                        .collect();\n+\n+                    let discr_enum = unsafe {\n+                        llvm::LLVMRustDIBuilderCreateEnumerationType(\n+                            DIB(cx),\n+                            self_metadata,\n+                            \"tag$\".as_ptr().cast(),\n+                            \"tag$\".len(),\n+                            unknown_file_metadata(cx),\n+                            UNKNOWN_LINE_NUMBER,\n+                            tag.value.size(cx).bits(),\n+                            tag.value.align(cx).abi.bits() as u32,\n+                            create_DIArray(DIB(cx), &tags),\n+                            type_metadata(cx, discr_enum_ty, self.span),\n+                            true,\n+                        )\n+                    };\n+\n+                    let (size, align) =\n+                        cx.size_and_align_of(dataful_variant_layout.field(cx, tag_field).ty);\n+                    let members = vec![MemberDescription {\n+                        name: \"discriminant\".to_string(),\n+                        type_metadata: discr_enum,\n+                        offset: dataful_variant_layout.fields.offset(tag_field),\n+                        size,\n+                        align,\n+                        flags: DIFlags::FlagArtificial,\n+                        discriminant: None,\n+                        source_info: None,\n+                    }];\n+\n+                    set_members_of_composite_type(cx, self.enum_type, variant_metadata, members, None);\n+\n+                    let variant_info = variant_info_for(dataful_variant);\n+                    let (variant_type_metadata, member_desc_factory) = describe_enum_variant(\n                         cx,\n-                        variant,\n-                        variant_info_for(dataful_variant),\n+                        dataful_variant_layout,\n+                        variant_info,\n                         Some(NicheTag),\n                         self_metadata,\n                         self.span,\n                     );\n \n-                    let variant_member_descriptions =\n-                        member_description_factory.create_member_descriptions(cx);\n+                    let member_descriptions = member_desc_factory.create_member_descriptions(cx);\n \n                     set_members_of_composite_type(\n                         cx,\n                         self.enum_type,\n                         variant_type_metadata,\n-                        variant_member_descriptions,\n+                        member_descriptions,\n                         Some(&self.common_members),\n                     );\n \n-                    // Encode the information about the null variant in the union\n-                    // member's name.\n-                    let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n-                    // Right now it's not even going to work for `niche_start > 0`,\n-                    // and for multiple niche variants it only supports the first.\n-                    fn compute_field_path<'a, 'tcx>(\n-                        cx: &CodegenCx<'a, 'tcx>,\n-                        name: &mut String,\n-                        layout: TyAndLayout<'tcx>,\n-                        offset: Size,\n-                        size: Size,\n-                    ) {\n-                        for i in 0..layout.fields.count() {\n-                            let field_offset = layout.fields.offset(i);\n-                            if field_offset > offset {\n-                                continue;\n-                            }\n-                            let inner_offset = offset - field_offset;\n-                            let field = layout.field(cx, i);\n-                            if inner_offset + size <= field.size {\n-                                write!(name, \"{}$\", i).unwrap();\n-                                compute_field_path(cx, name, field, inner_offset, size);\n-                            }\n-                        }\n-                    }\n-                    compute_field_path(\n-                        cx,\n-                        &mut name,\n-                        self.layout,\n-                        self.layout.fields.offset(tag_field),\n-                        self.layout.field(cx, tag_field).size,\n-                    );\n-                    let variant_info = variant_info_for(*niche_variants.start());\n-                    variant_info.map_struct_name(|variant_name| {\n-                        name.push_str(variant_name);\n-                    });\n-\n-                    // Create the (singleton) list of descriptions of union members.\n-                    vec![MemberDescription {\n-                        name,\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::ZERO,\n-                        size: variant.size,\n-                        align: variant.align.abi,\n-                        flags: DIFlags::FlagZero,\n-                        discriminant: None,\n-                        source_info: variant_info.source_info(cx),\n-                    }]\n+                    vec![\n+                        MemberDescription {\n+                            // Name the dataful variant so that we can identify it for natvis\n+                            name: \"dataful_variant\".to_string(),\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: self.layout.size,\n+                            align: self.layout.align.abi,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                            source_info: variant_info.source_info(cx),\n+                        },\n+                        MemberDescription {\n+                            name: \"discriminant$\".into(),\n+                            type_metadata: variant_metadata,\n+                            offset: Size::ZERO,\n+                            size: self.layout.size,\n+                            align: self.layout.align.abi,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                            source_info: None,\n+                        },\n+                    ]\n                 } else {\n                     variants\n                         .iter_enumerated()\n@@ -1692,19 +1759,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 Some(&self.common_members),\n                             );\n \n-                            let niche_value = if i == dataful_variant {\n-                                None\n-                            } else {\n-                                let value = (i.as_u32() as u128)\n-                                    .wrapping_sub(niche_variants.start().as_u32() as u128)\n-                                    .wrapping_add(niche_start);\n-                                let value = tag.value.size(cx).truncate(value);\n-                                // NOTE(eddyb) do *NOT* remove this assert, until\n-                                // we pass the full 128-bit value to LLVM, otherwise\n-                                // truncation will be silent and remain undetected.\n-                                assert_eq!(value as u64 as u128, value);\n-                                Some(value as u64)\n-                            };\n+                            let niche_value = calculate_niche_value(i);\n \n                             MemberDescription {\n                                 name: variant_info.variant_name(),\n@@ -2040,9 +2095,9 @@ fn prepare_enum_metadata(\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n-            Variants::Single { .. }\n-            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => None,\n-            Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n+            Variants::Single { .. } => None,\n+            Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, ref tag, .. }\n+            | Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n                 Some(discriminant_type_metadata(tag.value))\n             }\n         };"}, {"sha": "1f3e94933188d5886728ebb409606cd03a97ba9d", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/141546c355f2de7501c1df75dd97229ed350eeb3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141546c355f2de7501c1df75dd97229ed350eeb3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=141546c355f2de7501c1df75dd97229ed350eeb3", "patch": "@@ -3,7 +3,8 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, subst::SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty, TyCtxt};\n+use rustc_target::abi::{TagEncoding, Variants};\n \n use std::fmt::Write;\n \n@@ -46,14 +47,10 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n             if def.is_enum() && cpp_like_names {\n-                output.push_str(\"_enum<\");\n-            }\n-\n-            push_item_name(tcx, def.did, qualified, output);\n-            push_type_params(tcx, substs, output, visited);\n-\n-            if def.is_enum() && cpp_like_names {\n-                output.push('>');\n+                msvc_enum_fallback(tcx, t, def, substs, output, visited);\n+            } else {\n+                push_item_name(tcx, def.did, qualified, output);\n+                push_type_params(tcx, substs, output, visited);\n             }\n         }\n         ty::Tuple(component_types) => {\n@@ -241,6 +238,50 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n     }\n \n+    fn msvc_enum_fallback(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        def: &AdtDef,\n+        substs: SubstsRef<'tcx>,\n+        output: &mut String,\n+        visited: &mut FxHashSet<Ty<'tcx>>,\n+    ) {\n+        let layout = tcx.layout_of(tcx.param_env(def.did).and(ty)).expect(\"layout error\");\n+\n+        if let Variants::Multiple {\n+            tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+            tag,\n+            variants,\n+            ..\n+        } = &layout.variants\n+        {\n+            let dataful_variant_layout = &variants[*dataful_variant];\n+\n+            // calculate the range of values for the dataful variant\n+            let dataful_discriminant_range =\n+                &dataful_variant_layout.largest_niche.as_ref().unwrap().scalar.valid_range;\n+\n+            let min = dataful_discriminant_range.start();\n+            let min = tag.value.size(&tcx).truncate(*min);\n+\n+            let max = dataful_discriminant_range.end();\n+            let max = tag.value.size(&tcx).truncate(*max);\n+\n+            output.push_str(\"_enum<\");\n+            push_item_name(tcx, def.did, true, output);\n+            push_type_params(tcx, substs, output, visited);\n+\n+            let dataful_variant_name = def.variants[*dataful_variant].ident.as_str();\n+\n+            output.push_str(&format!(\", {}, {}, {}>\", min, max, dataful_variant_name));\n+        } else {\n+            output.push_str(\"_enum<\");\n+            push_item_name(tcx, def.did, true, output);\n+            push_type_params(tcx, substs, output, visited);\n+            output.push('>');\n+        }\n+    }\n+\n     fn push_item_name(tcx: TyCtxt<'tcx>, def_id: DefId, qualified: bool, output: &mut String) {\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());"}, {"sha": "82d3ab15a704818cb3d69ac77a199bb625d1ce07", "filename": "src/etc/natvis/intrinsic.natvis", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/141546c355f2de7501c1df75dd97229ed350eeb3/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/141546c355f2de7501c1df75dd97229ed350eeb3/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fintrinsic.natvis?ref=141546c355f2de7501c1df75dd97229ed350eeb3", "patch": "@@ -187,4 +187,18 @@\n       <ExpandedItem Condition=\"tag() == 15\" Optional=\"true\">Variant15</ExpandedItem>\n     </Expand>\n   </Type>\n+\n+  <!-- $T1 is the name of the enum, $T2 is the low value of the dataful variant tag, $T3 is the high value of the dataful variant tag, $T4 is the name of the dataful variant -->\n+  <Type Name=\"_enum&lt;*, *, *, *&gt;\">\n+    <Intrinsic Name=\"tag\" Expression=\"discriminant$.discriminant\" />\n+    <Intrinsic Name=\"is_dataful\" Expression=\"tag() &gt;= $T2 &amp;&amp; tag() &lt;= $T3\" />\n+    <DisplayString Condition=\"is_dataful()\">{\"$T4\",sb}({dataful_variant})</DisplayString>\n+    <DisplayString Condition=\"!is_dataful()\">{discriminant$.discriminant,en}</DisplayString>\n+    <Expand>\n+      <ExpandedItem Condition=\"is_dataful()\">dataful_variant</ExpandedItem>\n+      <Synthetic Condition=\"is_dataful()\" Name=\"[variant]\">\n+        <DisplayString>{\"$T4\",sb}</DisplayString>\n+      </Synthetic>\n+    </Expand>\n+  </Type>\n </AutoVisualizer>"}]}