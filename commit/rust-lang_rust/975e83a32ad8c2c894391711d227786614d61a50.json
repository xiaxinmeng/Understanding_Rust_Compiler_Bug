{"sha": "975e83a32ad8c2c894391711d227786614d61a50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NWU4M2EzMmFkOGMyYzg5NDM5MTcxMWQyMjc3ODY2MTRkNjFhNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-10T02:41:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-10T02:41:00Z"}, "message": "Auto merge of #67184 - tmandry:rollup-mzqxtck, r=tmandry\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #66892 (Format libcore with rustfmt (including tests and benches))\n - #67106 (resolve: Resolve visibilities on fields with non-builtin attributes)\n - #67113 (Print the visibility in `print_variant`.)\n - #67115 (Simplify `check_decl_no_pat`.)\n - #67119 (libstd miri tests: avoid warnings)\n - #67125 (Added ExactSizeIterator bound to return types)\n - #67138 (Simplify `Layout::extend_packed`)\n - #67145 (fix miri step debug printing)\n - #67149 (Do not ICE #67123)\n - #67155 (Move `Layout`s instead of binding by reference)\n - #67169 (inline some common methods on OsStr)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8b0a3bba87213cfa3142c79d527e8edcd4a4b6e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b0a3bba87213cfa3142c79d527e8edcd4a4b6e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/975e83a32ad8c2c894391711d227786614d61a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/975e83a32ad8c2c894391711d227786614d61a50", "html_url": "https://github.com/rust-lang/rust/commit/975e83a32ad8c2c894391711d227786614d61a50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/975e83a32ad8c2c894391711d227786614d61a50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76a252ea9e7be93a61ffdf33b3533e24a9cf459d", "url": "https://api.github.com/repos/rust-lang/rust/commits/76a252ea9e7be93a61ffdf33b3533e24a9cf459d", "html_url": "https://github.com/rust-lang/rust/commit/76a252ea9e7be93a61ffdf33b3533e24a9cf459d"}, {"sha": "c25581524022e101d7093737fde4dc94a28e6ccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c25581524022e101d7093737fde4dc94a28e6ccc", "html_url": "https://github.com/rust-lang/rust/commit/c25581524022e101d7093737fde4dc94a28e6ccc"}], "stats": {"total": 2908, "additions": 1587, "deletions": 1321}, "files": [{"sha": "c902971638b8e02615420f38341ab663e2b87077", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -22,7 +22,7 @@ fn allocate_zeroed() {\n }\n \n #[bench]\n-#[cfg(not(miri))] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n fn alloc_owned_small(b: &mut Bencher) {\n     b.iter(|| {\n         let _: Box<_> = box 10;"}, {"sha": "1b1d8eab39bfc84f97686c629e5e1ef938fee124", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -182,7 +182,7 @@ fn test_insert_prev() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support threads\n+#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {"}, {"sha": "f2ce5b1d15dde13c94f03c9ef880fe0b7042f31a", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -3,7 +3,7 @@ use super::*;\n use ::test;\n \n #[bench]\n-#[cfg(not(miri))] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n fn bench_push_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -16,7 +16,7 @@ fn bench_push_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg(not(miri))] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n fn bench_push_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -29,7 +29,7 @@ fn bench_push_front_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg(not(miri))] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n fn bench_pop_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n \n@@ -43,7 +43,7 @@ fn bench_pop_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg(not(miri))] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n fn bench_pop_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n "}, {"sha": "9ddba495b7e786682b11ae446129a118fbcb8e17", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -29,7 +29,7 @@ impl Drop for Canary {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support threads\n+#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn manually_share_arc() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = Arc::new(v);\n@@ -334,7 +334,7 @@ fn test_ptr_eq() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support threads\n+#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_weak_count_locked() {\n     let mut a = Arc::new(atomic::AtomicBool::new(false));\n     let a2 = a.clone();"}, {"sha": "ec45de7c79e28e86bc735cb341e2dd22ac98d628", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -388,7 +388,7 @@ fn test_reverse() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_sort() {\n     let mut rng = thread_rng();\n \n@@ -1610,7 +1610,7 @@ fn panic_safe() {\n     let moduli = &[5, 20, 50];\n \n     #[cfg(miri)]\n-    let lens = (1..13);\n+    let lens = 1..13;\n     #[cfg(miri)]\n     let moduli = &[10];\n "}, {"sha": "1b011242d0137fac3790323fe4088ba19d35db48", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -166,7 +166,7 @@ fn test_join_for_different_lengths_with_long_separator() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_unsafe_slice() {\n     assert_eq!(\"ab\", unsafe {\"abc\".get_unchecked(0..2)});\n     assert_eq!(\"bc\", unsafe {\"abc\".get_unchecked(1..3)});\n@@ -483,8 +483,8 @@ mod slice_index {\n     }\n \n     #[test]\n-    #[cfg(not(target_os = \"emscripten\"))] // hits an OOM\n-    #[cfg(not(miri))] // Miri is too slow\n+    #[cfg_attr(target_os = \"emscripten\", ignore)] // hits an OOM\n+    #[cfg_attr(miri, ignore)] // Miri is too slow\n     fn simple_big() {\n         fn a_million_letter_x() -> String {\n             let mut i = 0;\n@@ -1069,7 +1069,7 @@ fn test_rev_iterator() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_chars_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1081,7 +1081,7 @@ fn test_chars_decoding() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_chars_rev_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1380,7 +1380,6 @@ fn test_bool_from_str() {\n     assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n }\n \n-#[cfg(not(miri))] // Miri is too slow\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in 0..s.len() {\n@@ -1391,7 +1390,7 @@ fn check_contains_all_substrings(s: &str) {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn strslice_issue_16589() {\n     assert!(\"bananas\".contains(\"nana\"));\n \n@@ -1408,7 +1407,7 @@ fn strslice_issue_16878() {\n \n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_strslice_contains() {\n     let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n     check_contains_all_substrings(x);"}, {"sha": "fe7b4ff24b8c9d2d2476a870375570b44ec2b336", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -523,7 +523,7 @@ fn test_reserve_exact() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support signalling OOM\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -601,7 +601,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support signalling OOM\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed."}, {"sha": "5e788d61f84fded8521b6e75e356d031d237f06d", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1080,7 +1080,7 @@ fn test_reserve_exact() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support signalling OOM\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -1183,7 +1183,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support signalling OOM\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed."}, {"sha": "ebcc832017172ed333c6c490b31a7e8b58396e1e", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1100,7 +1100,7 @@ fn test_reserve_exact_2() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support signalling OOM\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve() {\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n@@ -1214,7 +1214,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support signalling OOM\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments."}, {"sha": "f37c57e38b540e088a8e1040038b5da19943724c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -310,8 +310,7 @@ impl Layout {\n     pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n         let new_size = self.size().checked_add(next.size())\n             .ok_or(LayoutErr { private: () })?;\n-        let layout = Layout::from_size_align(new_size, self.align())?;\n-        Ok(layout)\n+        Layout::from_size_align(new_size, self.align())\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`.\n@@ -1143,9 +1142,9 @@ pub unsafe trait Alloc {\n         where Self: Sized\n     {\n         match Layout::array::<T>(n) {\n-            Ok(ref layout) if layout.size() > 0 => {\n+            Ok(layout) if layout.size() > 0 => {\n                 unsafe {\n-                    self.alloc(layout.clone()).map(|p| p.cast())\n+                    self.alloc(layout).map(|p| p.cast())\n                 }\n             }\n             _ => Err(AllocErr),\n@@ -1193,9 +1192,9 @@ pub unsafe trait Alloc {\n         where Self: Sized\n     {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n-            (Ok(ref k_old), Ok(ref k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n+            (Ok(k_old), Ok(k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n                 debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.cast(), k_old.clone(), k_new.size()).map(NonNull::cast)\n+                self.realloc(ptr.cast(), k_old, k_new.size()).map(NonNull::cast)\n             }\n             _ => {\n                 Err(AllocErr)\n@@ -1227,8 +1226,8 @@ pub unsafe trait Alloc {\n         where Self: Sized\n     {\n         match Layout::array::<T>(n) {\n-            Ok(ref k) if k.size() > 0 => {\n-                Ok(self.dealloc(ptr.cast(), k.clone()))\n+            Ok(k) if k.size() > 0 => {\n+                Ok(self.dealloc(ptr.cast(), k))\n             }\n             _ => {\n                 Err(AllocErr)"}, {"sha": "53099b78266f87b83a2bf568587fcd2597dc71aa", "filename": "src/libcore/benches/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fany.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,5 +1,5 @@\n use core::any::*;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_downcast_ref(b: &mut Bencher) {"}, {"sha": "76ccd3ddb6fd883060944cce98aea3703df23075", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -22,17 +22,9 @@\n //\n // Therefore:\n fn branchless_to_ascii_upper_case(byte: u8) -> u8 {\n-    byte &\n-    !(\n-        (\n-            byte.wrapping_add(0x1f) &\n-            !byte.wrapping_add(0x05) &\n-            0x80\n-        ) >> 2\n-    )\n+    byte & !((byte.wrapping_add(0x1f) & !byte.wrapping_add(0x05) & 0x80) >> 2)\n }\n \n-\n macro_rules! benches {\n     ($( fn $name: ident($arg: ident: &mut [u8]) $body: block )+ @iter $( $is_: ident, )+) => {\n         benches! {@\n@@ -254,12 +246,15 @@ benches! {\n }\n \n macro_rules! repeat {\n-    ($s: expr) => { concat!($s, $s, $s, $s, $s, $s, $s, $s, $s, $s) }\n+    ($s: expr) => {\n+        concat!($s, $s, $s, $s, $s, $s, $s, $s, $s, $s)\n+    };\n }\n \n const SHORT: &'static str = \"Alice's\";\n const MEDIUM: &'static str = \"Alice's Adventures in Wonderland\";\n-const LONG: &'static str = repeat!(r#\"\n+const LONG: &'static str = repeat!(\n+    r#\"\n     La Guida di Bragia, a Ballad Opera for the Marionette Theatre (around 1850)\n     Alice's Adventures in Wonderland (1865)\n     Phantasmagoria and Other Poems (1869)\n@@ -275,8 +270,10 @@ const LONG: &'static str = repeat!(r#\"\n     What the Tortoise Said to Achilles (1895)\n     Three Sunsets and Other Poems (1898)\n     The Manlet (1903)[106]\n-\"#);\n+\"#\n+);\n \n+#[rustfmt::skip]\n const ASCII_UPPERCASE_MAP: [u8; 256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n@@ -330,6 +327,7 @@ enum AsciiCharacterClass {\n }\n use self::AsciiCharacterClass::*;\n \n+#[rustfmt::skip]\n static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 256] = [\n //  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n     C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_"}, {"sha": "a9a08a4d76200139d342476ee39262854784a0e3", "filename": "src/libcore/benches/char/methods.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fchar%2Fmethods.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -25,8 +25,13 @@ fn bench_to_digit_radix_36(b: &mut Bencher) {\n \n #[bench]\n fn bench_to_digit_radix_var(b: &mut Bencher) {\n-    b.iter(|| CHARS.iter().cycle()\n-        .zip(RADIX.iter().cycle())\n-        .take(10_000)\n-        .map(|(c, radix)| c.to_digit(*radix)).min())\n+    b.iter(|| {\n+        CHARS\n+            .iter()\n+            .cycle()\n+            .zip(RADIX.iter().cycle())\n+            .take(10_000)\n+            .map(|(c, radix)| c.to_digit(*radix))\n+            .min()\n+    })\n }"}, {"sha": "dd72a33996f174c28a2f277305ac3e63b0321015", "filename": "src/libcore/benches/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Ffmt.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,5 +1,5 @@\n-use std::io::{self, Write as IoWrite};\n use std::fmt::{self, Write as FmtWrite};\n+use std::io::{self, Write as IoWrite};\n use test::Bencher;\n \n #[bench]"}, {"sha": "725c864dce9f151f976abed386be6071e4531a8c", "filename": "src/libcore/benches/hash/sip.rs", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,7 +1,7 @@\n #![allow(deprecated)]\n \n use core::hash::*;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n fn hash_bytes<H: Hasher>(mut s: H, x: &[u8]) -> u64 {\n     Hasher::write(&mut s, x);\n@@ -44,11 +44,11 @@ fn bench_str_over_8_bytes(b: &mut Bencher) {\n #[bench]\n fn bench_long_str(b: &mut Bencher) {\n     let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n-incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n-exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n-irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n-pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n-officia deserunt mollit anim id est laborum.\";\n+             incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n+             exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n+             irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n+             pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n+             officia deserunt mollit anim id est laborum.\";\n     b.iter(|| {\n         assert_eq!(hash(&s), 17717065544121360093);\n     })\n@@ -58,9 +58,7 @@ officia deserunt mollit anim id est laborum.\";\n fn bench_u32(b: &mut Bencher) {\n     let u = 162629500u32;\n     let u = black_box(u);\n-    b.iter(|| {\n-        hash(&u)\n-    });\n+    b.iter(|| hash(&u));\n     b.bytes = 8;\n }\n \n@@ -70,72 +68,56 @@ fn bench_u32_keyed(b: &mut Bencher) {\n     let u = black_box(u);\n     let k1 = black_box(0x1);\n     let k2 = black_box(0x2);\n-    b.iter(|| {\n-        hash_with(SipHasher::new_with_keys(k1, k2), &u)\n-    });\n+    b.iter(|| hash_with(SipHasher::new_with_keys(k1, k2), &u));\n     b.bytes = 8;\n }\n \n #[bench]\n fn bench_u64(b: &mut Bencher) {\n     let u = 16262950014981195938u64;\n     let u = black_box(u);\n-    b.iter(|| {\n-        hash(&u)\n-    });\n+    b.iter(|| hash(&u));\n     b.bytes = 8;\n }\n \n #[bench]\n fn bench_bytes_4(b: &mut Bencher) {\n     let data = black_box([b' '; 4]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n+    b.iter(|| hash_bytes(SipHasher::default(), &data));\n     b.bytes = 4;\n }\n \n #[bench]\n fn bench_bytes_7(b: &mut Bencher) {\n     let data = black_box([b' '; 7]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n+    b.iter(|| hash_bytes(SipHasher::default(), &data));\n     b.bytes = 7;\n }\n \n #[bench]\n fn bench_bytes_8(b: &mut Bencher) {\n     let data = black_box([b' '; 8]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n+    b.iter(|| hash_bytes(SipHasher::default(), &data));\n     b.bytes = 8;\n }\n \n #[bench]\n fn bench_bytes_a_16(b: &mut Bencher) {\n     let data = black_box([b' '; 16]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n+    b.iter(|| hash_bytes(SipHasher::default(), &data));\n     b.bytes = 16;\n }\n \n #[bench]\n fn bench_bytes_b_32(b: &mut Bencher) {\n     let data = black_box([b' '; 32]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n+    b.iter(|| hash_bytes(SipHasher::default(), &data));\n     b.bytes = 32;\n }\n \n #[bench]\n fn bench_bytes_c_128(b: &mut Bencher) {\n     let data = black_box([b' '; 128]);\n-    b.iter(|| {\n-        hash_bytes(SipHasher::default(), &data)\n-    });\n+    b.iter(|| hash_bytes(SipHasher::default(), &data));\n     b.bytes = 128;\n }"}, {"sha": "fb6b4b7837941115af4c86fa47ae87b25a28aea0", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,5 +1,5 @@\n use core::iter::*;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n@@ -14,7 +14,11 @@ fn bench_skip_while(b: &mut Bencher) {\n     b.iter(|| {\n         let it = 0..100;\n         let mut sum = 0;\n-        it.skip_while(|&x| { sum += x; sum < 4000 }).all(|_| true);\n+        it.skip_while(|&x| {\n+            sum += x;\n+            sum < 4000\n+        })\n+        .all(|_| true);\n     });\n }\n \n@@ -29,7 +33,9 @@ fn bench_multiple_take(b: &mut Bencher) {\n     });\n }\n \n-fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n+fn scatter(x: i32) -> i32 {\n+    (x * 31) % 127\n+}\n \n #[bench]\n fn bench_max_by_key(b: &mut Bencher) {\n@@ -76,23 +82,21 @@ pub fn add_zip(xs: &[f32], ys: &mut [f32]) {\n fn bench_zip_copy(b: &mut Bencher) {\n     let source = vec![0u8; 16 * 1024];\n     let mut dst = black_box(vec![0u8; 16 * 1024]);\n-    b.iter(|| {\n-        copy_zip(&source, &mut dst)\n-    })\n+    b.iter(|| copy_zip(&source, &mut dst))\n }\n \n #[bench]\n fn bench_zip_add(b: &mut Bencher) {\n     let source = vec![1.; 16 * 1024];\n     let mut dst = vec![0.; 16 * 1024];\n-    b.iter(|| {\n-        add_zip(&source, &mut dst)\n-    });\n+    b.iter(|| add_zip(&source, &mut dst));\n }\n \n /// `Iterator::for_each` implemented as a plain loop.\n-fn for_each_loop<I, F>(iter: I, mut f: F) where\n-    I: Iterator, F: FnMut(I::Item)\n+fn for_each_loop<I, F>(iter: I, mut f: F)\n+where\n+    I: Iterator,\n+    F: FnMut(I::Item),\n {\n     for item in iter {\n         f(item);\n@@ -101,8 +105,10 @@ fn for_each_loop<I, F>(iter: I, mut f: F) where\n \n /// `Iterator::for_each` implemented with `fold` for internal iteration.\n /// (except when `by_ref()` effectively disables that optimization.)\n-fn for_each_fold<I, F>(iter: I, mut f: F) where\n-    I: Iterator, F: FnMut(I::Item)\n+fn for_each_fold<I, F>(iter: I, mut f: F)\n+where\n+    I: Iterator,\n+    F: FnMut(I::Item),\n {\n     iter.fold((), move |(), item| f(item));\n }\n@@ -137,25 +143,20 @@ fn bench_for_each_chain_ref_fold(b: &mut Bencher) {\n     });\n }\n \n-\n /// Helper to benchmark `sum` for iterators taken by value which\n /// can optimize `fold`, and by reference which cannot.\n macro_rules! bench_sums {\n     ($bench_sum:ident, $bench_ref_sum:ident, $iter:expr) => {\n         #[bench]\n         fn $bench_sum(b: &mut Bencher) {\n-            b.iter(|| -> i64 {\n-                $iter.map(black_box).sum()\n-            });\n+            b.iter(|| -> i64 { $iter.map(black_box).sum() });\n         }\n \n         #[bench]\n         fn $bench_ref_sum(b: &mut Bencher) {\n-            b.iter(|| -> i64 {\n-                $iter.map(black_box).by_ref().sum()\n-            });\n+            b.iter(|| -> i64 { $iter.map(black_box).by_ref().sum() });\n         }\n-    }\n+    };\n }\n \n bench_sums! {\n@@ -286,7 +287,10 @@ fn bench_zip_then_skip(b: &mut Bencher) {\n     let t: Vec<_> = (0..100_000).collect();\n \n     b.iter(|| {\n-        let s = v.iter().zip(t.iter()).skip(10000)\n+        let s = v\n+            .iter()\n+            .zip(t.iter())\n+            .skip(10000)\n             .take_while(|t| *t.0 < 10100)\n             .map(|(a, b)| *a + *b)\n             .sum::<u64>();\n@@ -299,7 +303,10 @@ fn bench_skip_then_zip(b: &mut Bencher) {\n     let t: Vec<_> = (0..100_000).collect();\n \n     b.iter(|| {\n-        let s = v.iter().skip(10000).zip(t.iter().skip(10000))\n+        let s = v\n+            .iter()\n+            .skip(10000)\n+            .zip(t.iter().skip(10000))\n             .take_while(|t| *t.0 < 10100)\n             .map(|(a, b)| *a + *b)\n             .sum::<u64>();\n@@ -309,23 +316,17 @@ fn bench_skip_then_zip(b: &mut Bencher) {\n \n #[bench]\n fn bench_filter_count(b: &mut Bencher) {\n-    b.iter(|| {\n-        (0i64..1000000).map(black_box).filter(|x| x % 3 == 0).count()\n-    })\n+    b.iter(|| (0i64..1000000).map(black_box).filter(|x| x % 3 == 0).count())\n }\n \n #[bench]\n fn bench_filter_ref_count(b: &mut Bencher) {\n-    b.iter(|| {\n-        (0i64..1000000).map(black_box).by_ref().filter(|x| x % 3 == 0).count()\n-    })\n+    b.iter(|| (0i64..1000000).map(black_box).by_ref().filter(|x| x % 3 == 0).count())\n }\n \n #[bench]\n fn bench_filter_chain_count(b: &mut Bencher) {\n-    b.iter(|| {\n-        (0i64..1000000).chain(0..1000000).map(black_box).filter(|x| x % 3 == 0).count()\n-    })\n+    b.iter(|| (0i64..1000000).chain(0..1000000).map(black_box).filter(|x| x % 3 == 0).count())\n }\n \n #[bench]"}, {"sha": "6932c7fe221d0cd4d0f288c840fc692a6bbc20cd", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -6,9 +6,9 @@ extern crate test;\n mod any;\n mod ascii;\n mod char;\n+mod fmt;\n mod hash;\n mod iter;\n mod num;\n mod ops;\n mod slice;\n-mod fmt;"}, {"sha": "b810dd12ab61bb3f37b7b4517de10544886f9127", "filename": "src/libcore/benches/num/flt2dec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -3,17 +3,17 @@ mod strategy {\n     mod grisu;\n }\n \n+use core::num::flt2dec::MAX_SIG_DIGITS;\n+use core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n use std::f64;\n use std::io::Write;\n use std::vec::Vec;\n use test::Bencher;\n-use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n-use core::num::flt2dec::MAX_SIG_DIGITS;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n         FullDecoded::Finite(decoded) => decoded,\n-        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded),\n     }\n }\n "}, {"sha": "4052fec33813c665eadef8f3ec4a4d7e157df14d", "filename": "src/libcore/benches/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,6 +1,6 @@\n-use std::{i16, f64};\n use super::super::*;\n use core::num::flt2dec::strategy::dragon::*;\n+use std::{f64, i16};\n use test::Bencher;\n \n #[bench]"}, {"sha": "495074747c283bbfedbff5662f3e8a221f003095", "filename": "src/libcore/benches/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,12 +1,12 @@\n-use std::{i16, f64};\n use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n+use std::{f64, i16};\n use test::Bencher;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n         FullDecoded::Finite(decoded) => decoded,\n-        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded),\n     }\n }\n "}, {"sha": "852d4e481e20d9567c6d1f9a7c64200609c3a02e", "filename": "src/libcore/benches/num/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,8 +1,8 @@\n-mod flt2dec;\n mod dec2flt;\n+mod flt2dec;\n \n-use test::Bencher;\n use std::str::FromStr;\n+use test::Bencher;\n \n const ASCII_NUMBERS: [&str; 19] = [\n     \"0\",\n@@ -27,7 +27,7 @@ const ASCII_NUMBERS: [&str; 19] = [\n ];\n \n macro_rules! from_str_bench {\n-    ($mac:ident, $t:ty) => (\n+    ($mac:ident, $t:ty) => {\n         #[bench]\n         fn $mac(b: &mut Bencher) {\n             b.iter(|| {\n@@ -39,11 +39,11 @@ macro_rules! from_str_bench {\n                     .max()\n             })\n         }\n-    )\n+    };\n }\n \n macro_rules! from_str_radix_bench {\n-    ($mac:ident, $t:ty, $radix:expr) => (\n+    ($mac:ident, $t:ty, $radix:expr) => {\n         #[bench]\n         fn $mac(b: &mut Bencher) {\n             b.iter(|| {\n@@ -55,7 +55,7 @@ macro_rules! from_str_radix_bench {\n                     .max()\n             })\n         }\n-    )\n+    };\n }\n \n from_str_bench!(bench_u8_from_str, u8);"}, {"sha": "0a2be8a28819fc6809972bf206dc711e604d343d", "filename": "src/libcore/benches/ops.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fops.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -4,17 +4,16 @@ use test::Bencher;\n // Overhead of dtors\n \n struct HasDtor {\n-    _x: isize\n+    _x: isize,\n }\n \n impl Drop for HasDtor {\n-    fn drop(&mut self) {\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[bench]\n fn alloc_obj_with_dtor(b: &mut Bencher) {\n     b.iter(|| {\n-        HasDtor { _x : 10 };\n+        HasDtor { _x: 10 };\n     })\n }"}, {"sha": "06b37cb08448c4a065c65aa7c8e6a065479d9953", "filename": "src/libcore/benches/slice.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fslice.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -8,11 +8,12 @@ enum Cache {\n }\n \n fn binary_search<F>(b: &mut Bencher, cache: Cache, mapper: F)\n-    where F: Fn(usize) -> usize\n+where\n+    F: Fn(usize) -> usize,\n {\n     let size = match cache {\n-        Cache::L1 => 1000, // 8kb\n-        Cache::L2 => 10_000, // 80kb\n+        Cache::L1 => 1000,      // 8kb\n+        Cache::L2 => 10_000,    // 80kb\n         Cache::L3 => 1_000_000, // 8Mb\n     };\n     let v = (0..size).map(&mapper).collect::<Vec<_>>();"}, {"sha": "6e0865e8653b7cfb769f62dbdb2dd6042ef20130", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -15,11 +15,7 @@ impl bool {\n     #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n     #[inline]\n     pub fn then_some<T>(self, t: T) -> Option<T> {\n-        if self {\n-            Some(t)\n-        } else {\n-            None\n-        }\n+        if self { Some(t) } else { None }\n     }\n \n     /// Returns `Some(f())` if the `bool` is `true`, or `None` otherwise.\n@@ -35,10 +31,6 @@ impl bool {\n     #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n     #[inline]\n     pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n-        if self {\n-            Some(f())\n-        } else {\n-            None\n-        }\n+        if self { Some(f()) } else { None }\n     }\n }"}, {"sha": "d976c8b7f43612b15431225619c7dcc5a40395aa", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -146,7 +146,6 @@ impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.2\n // https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n // http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n \n-\n // Note: integers can only be represented with full precision in a float if\n // they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n // Lossy float conversions are not implemented at this time."}, {"sha": "f4fb9ab1757cd28bcf147bd5f281d94173e20473", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -64,31 +64,27 @@ pub unsafe fn unreachable_unchecked() -> ! {\n #[inline]\n #[unstable(feature = \"renamed_spin_loop\", issue = \"55002\")]\n pub fn spin_loop() {\n-    #[cfg(\n-        all(\n-            any(target_arch = \"x86\", target_arch = \"x86_64\"),\n-            target_feature = \"sse2\"\n-        )\n-    )] {\n-        #[cfg(target_arch = \"x86\")] {\n+    #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"), target_feature = \"sse2\"))]\n+    {\n+        #[cfg(target_arch = \"x86\")]\n+        {\n             unsafe { crate::arch::x86::_mm_pause() };\n         }\n \n-        #[cfg(target_arch = \"x86_64\")] {\n+        #[cfg(target_arch = \"x86_64\")]\n+        {\n             unsafe { crate::arch::x86_64::_mm_pause() };\n         }\n     }\n \n-    #[cfg(\n-        any(\n-            target_arch = \"aarch64\",\n-            all(target_arch = \"arm\", target_feature = \"v6\")\n-        )\n-    )] {\n-        #[cfg(target_arch = \"aarch64\")] {\n+    #[cfg(any(target_arch = \"aarch64\", all(target_arch = \"arm\", target_feature = \"v6\")))]\n+    {\n+        #[cfg(target_arch = \"aarch64\")]\n+        {\n             unsafe { crate::arch::aarch64::__yield() };\n         }\n-        #[cfg(target_arch = \"arm\")] {\n+        #[cfg(target_arch = \"arm\")]\n+        {\n             unsafe { crate::arch::arm::__yield() };\n         }\n     }"}, {"sha": "f21ab8dbc3737d180629262b0f42cf345cbd635d", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -91,9 +91,9 @@\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    message=\"a value of type `{Self}` cannot be built from an iterator \\\n-             over elements of type `{A}`\",\n-    label=\"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n+    message = \"a value of type `{Self}` cannot be built from an iterator \\\n+               over elements of type `{A}`\",\n+    label = \"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\"\n )]\n pub trait FromIterator<A>: Sized {\n     /// Creates a value from an iterator.\n@@ -116,7 +116,7 @@ pub trait FromIterator<A>: Sized {\n     /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n+    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self;\n }\n \n /// Conversion into an `Iterator`.\n@@ -214,7 +214,7 @@ pub trait IntoIterator {\n \n     /// Which kind of iterator are we turning this into?\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type IntoIter: Iterator<Item=Self::Item>;\n+    type IntoIter: Iterator<Item = Self::Item>;\n \n     /// Creates an iterator from a value.\n     ///\n@@ -340,7 +340,7 @@ pub trait Extend<A> {\n     /// assert_eq!(\"abcdef\", &message);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n+    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T);\n }\n \n #[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]"}, {"sha": "5446ce3e3b3e9d849e083e0b18e13d6d4f53a3be", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -439,7 +439,10 @@ impl f64 {\n     #[cfg(not(bootstrap))]\n     #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n     #[inline]\n-    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int\n+    where\n+        Self: FloatToInt<Int>,\n+    {\n         FloatToInt::<Int>::approx_unchecked(self)\n     }\n "}, {"sha": "22ba97b91df12c931cdc6d7738b76835461c0a84", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -5,20 +5,28 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[cfg_attr(not(bootstrap), rustc_on_unimplemented(\n-on(all(\n-any(from_method=\"from_error\", from_method=\"from_ok\"),\n-from_desugaring=\"QuestionMark\"),\n-message=\"the `?` operator can only be used in {ItemContext} \\\n-               that returns `Result` or `Option` \\\n-               (or another type that implements `{Try}`)\",\n-label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n-enclosing_scope=\"this function should return `Result` or `Option` to accept `?`\"),\n-on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n-message=\"the `?` operator can only be applied to values \\\n-               that implement `{Try}`\",\n-label=\"the `?` operator cannot be applied to type `{Self}`\")\n-))]\n+#[cfg_attr(\n+    not(bootstrap),\n+    rustc_on_unimplemented(\n+        on(\n+            all(\n+                any(from_method = \"from_error\", from_method = \"from_ok\"),\n+                from_desugaring = \"QuestionMark\"\n+            ),\n+            message = \"the `?` operator can only be used in {ItemContext} \\\n+                       that returns `Result` or `Option` \\\n+                       (or another type that implements `{Try}`)\",\n+            label = \"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n+            enclosing_scope = \"this function should return `Result` or `Option` to accept `?`\"\n+        ),\n+        on(\n+            all(from_method = \"into_result\", from_desugaring = \"QuestionMark\"),\n+            message = \"the `?` operator can only be applied to values \\\n+                       that implement `{Try}`\",\n+            label = \"the `?` operator cannot be applied to type `{Self}`\"\n+        )\n+    )\n+)]\n #[doc(alias = \"?\")]\n pub trait Try {\n     /// The type of this value when viewed as successful."}, {"sha": "4857b1145952d3556c4df50af5408fab7df929e6", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -22,18 +22,20 @@\n // ignore-tidy-undocumented-unsafe\n \n #![allow(dead_code, missing_docs)]\n-#![unstable(feature = \"core_panic\",\n-            reason = \"internal details of the implementation of the `panic!` \\\n-                      and related macros\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"core_panic\",\n+    reason = \"internal details of the implementation of the `panic!` \\\n+              and related macros\",\n+    issue = \"0\"\n+)]\n \n use crate::fmt;\n use crate::panic::{Location, PanicInfo};\n \n #[cold]\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n-#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n@@ -50,7 +52,7 @@ pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n }\n \n #[cold]\n-#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n@@ -59,13 +61,13 @@ fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n \n     panic_fmt(\n         format_args!(\"index out of bounds: the len is {} but the index is {}\", len, index),\n-        location\n+        location,\n     )\n }\n \n #[cold]\n-#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n-#[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { super::intrinsics::abort() }"}, {"sha": "24ffa3483298bdf985d3f693812b436f2f132ba4", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 144, "deletions": 91, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -65,15 +65,16 @@\n //! [`write_volatile`]: ./fn.write_volatile.html\n //! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n+// ignore-tidy-filelength\n // ignore-tidy-undocumented-unsafe\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::intrinsics;\n+use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::fmt;\n use crate::hash;\n+use crate::intrinsics;\n use crate::mem::{self, MaybeUninit};\n-use crate::cmp::Ordering::{self, Less, Equal, Greater};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::intrinsics::copy_nonoverlapping;\n@@ -197,7 +198,9 @@ unsafe fn real_drop_in_place<T: ?Sized>(to_drop: &mut T) {\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n-pub const fn null<T>() -> *const T { 0 as *const T }\n+pub const fn null<T>() -> *const T {\n+    0 as *const T\n+}\n \n /// Creates a null mutable raw pointer.\n ///\n@@ -212,7 +215,9 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n-pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n+pub const fn null_mut<T>() -> *mut T {\n+    0 as *mut T\n+}\n \n #[repr(C)]\n pub(crate) union Repr<T> {\n@@ -704,9 +709,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n     let mut tmp = MaybeUninit::<T>::uninit();\n-    copy_nonoverlapping(src as *const u8,\n-                        tmp.as_mut_ptr() as *mut u8,\n-                        mem::size_of::<T>());\n+    copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::<T>());\n     tmp.assume_init()\n }\n \n@@ -889,9 +892,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n-    copy_nonoverlapping(&src as *const T as *const u8,\n-                        dst as *mut u8,\n-                        mem::size_of::<T>());\n+    copy_nonoverlapping(&src as *const T as *const u8, dst as *mut u8, mem::size_of::<T>());\n     mem::forget(src);\n }\n \n@@ -1122,11 +1123,7 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() {\n-            None\n-        } else {\n-            Some(&*self)\n-        }\n+        if self.is_null() { None } else { Some(&*self) }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -1182,7 +1179,10 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {\n+    pub unsafe fn offset(self, count: isize) -> *const T\n+    where\n+        T: Sized,\n+    {\n         intrinsics::offset(self, count)\n     }\n \n@@ -1237,10 +1237,11 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *const T where T: Sized {\n-        unsafe {\n-            intrinsics::arith_offset(self, count)\n-        }\n+    pub fn wrapping_offset(self, count: isize) -> *const T\n+    where\n+        T: Sized,\n+    {\n+        unsafe { intrinsics::arith_offset(self, count) }\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in\n@@ -1308,7 +1309,10 @@ impl<T: ?Sized> *const T {\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\")]\n     #[inline]\n-    pub const unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n+    where\n+        T: Sized,\n+    {\n         let pointee_size = mem::size_of::<T>();\n         let ok = 0 < pointee_size && pointee_size <= isize::max_value() as usize;\n         // assert that the pointee size is valid in a const eval compatible way\n@@ -1353,7 +1357,10 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n     #[inline]\n-    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n+    where\n+        T: Sized,\n+    {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n \n@@ -1415,7 +1422,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset(count as isize)\n     }\n@@ -1475,7 +1483,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset((count as isize).wrapping_neg())\n     }\n@@ -1529,7 +1538,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset(count as isize)\n     }\n@@ -1583,7 +1593,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n@@ -1597,7 +1608,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         read(self)\n     }\n@@ -1615,7 +1627,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_volatile(self)\n     }\n@@ -1631,7 +1644,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_unaligned(self)\n     }\n@@ -1647,7 +1661,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy(self, dest, count)\n     }\n@@ -1663,7 +1678,8 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy_nonoverlapping(self, dest, count)\n     }\n@@ -1708,17 +1724,17 @@ impl<T: ?Sized> *const T {\n     /// # } }\n     /// ```\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n-    pub fn align_offset(self, align: usize) -> usize where T: Sized {\n+    pub fn align_offset(self, align: usize) -> usize\n+    where\n+        T: Sized,\n+    {\n         if !align.is_power_of_two() {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n-        unsafe {\n-            align_offset(self, align)\n-        }\n+        unsafe { align_offset(self, align) }\n     }\n }\n \n-\n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n     /// Returns `true` if the pointer is null.\n@@ -1805,11 +1821,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() {\n-            None\n-        } else {\n-            Some(&*self)\n-        }\n+        if self.is_null() { None } else { Some(&*self) }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -1865,7 +1877,10 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *mut T where T: Sized {\n+    pub unsafe fn offset(self, count: isize) -> *mut T\n+    where\n+        T: Sized,\n+    {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n@@ -1919,10 +1934,11 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *mut T where T: Sized {\n-        unsafe {\n-            intrinsics::arith_offset(self, count) as *mut T\n-        }\n+    pub fn wrapping_offset(self, count: isize) -> *mut T\n+    where\n+        T: Sized,\n+    {\n+        unsafe { intrinsics::arith_offset(self, count) as *mut T }\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a mutable\n@@ -1967,11 +1983,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n-        if self.is_null() {\n-            None\n-        } else {\n-            Some(&mut *self)\n-        }\n+        if self.is_null() { None } else { Some(&mut *self) }\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in\n@@ -2039,7 +2051,10 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\")]\n     #[inline]\n-    pub const unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n+    where\n+        T: Sized,\n+    {\n         (self as *const T).offset_from(origin)\n     }\n \n@@ -2079,7 +2094,10 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n     #[inline]\n-    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n+    where\n+        T: Sized,\n+    {\n         (self as *const T).wrapping_offset_from(origin)\n     }\n \n@@ -2137,7 +2155,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset(count as isize)\n     }\n@@ -2197,7 +2216,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.offset((count as isize).wrapping_neg())\n     }\n@@ -2251,7 +2271,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset(count as isize)\n     }\n@@ -2305,7 +2326,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n@@ -2319,7 +2341,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         read(self)\n     }\n@@ -2337,7 +2360,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_volatile(self)\n     }\n@@ -2353,7 +2377,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         read_unaligned(self)\n     }\n@@ -2369,7 +2394,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy(self, dest, count)\n     }\n@@ -2385,7 +2411,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy_nonoverlapping(self, dest, count)\n     }\n@@ -2401,7 +2428,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from(self, src: *const T, count: usize)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy(src, self, count)\n     }\n@@ -2417,7 +2445,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         copy_nonoverlapping(src, self, count)\n     }\n@@ -2442,7 +2471,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write(self, val: T)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         write(self, val)\n     }\n@@ -2456,7 +2486,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_bytes(self, val: u8, count: usize)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         write_bytes(self, val, count)\n     }\n@@ -2474,7 +2505,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_volatile(self, val: T)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         write_volatile(self, val)\n     }\n@@ -2490,7 +2522,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_unaligned(self, val: T)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         write_unaligned(self, val)\n     }\n@@ -2504,7 +2537,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn replace(self, src: T) -> T\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         replace(self, src)\n     }\n@@ -2519,7 +2553,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn swap(self, with: *mut T)\n-        where T: Sized,\n+    where\n+        T: Sized,\n     {\n         swap(self, with)\n     }\n@@ -2564,13 +2599,14 @@ impl<T: ?Sized> *mut T {\n     /// # } }\n     /// ```\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n-    pub fn align_offset(self, align: usize) -> usize where T: Sized {\n+    pub fn align_offset(self, align: usize) -> usize\n+    where\n+        T: Sized,\n+    {\n         if !align.is_power_of_two() {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n-        unsafe {\n-            align_offset(self, align)\n-        }\n+        unsafe { align_offset(self, align) }\n     }\n }\n \n@@ -2588,7 +2624,7 @@ impl<T: ?Sized> *mut T {\n /// than trying to adapt this to accommodate that change.\n ///\n /// Any questions go to @nagisa.\n-#[lang=\"align_offset\"]\n+#[lang = \"align_offset\"]\n pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n     ///\n@@ -2628,9 +2664,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                 // usize::max_value()` instead, because we take the result `mod n` at the end\n                 // anyway.\n-                inverse = inverse.wrapping_mul(\n-                    2usize.wrapping_sub(x.wrapping_mul(inverse))\n-                ) & (going_mod - 1);\n+                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)))\n+                    & (going_mod - 1);\n                 if going_mod > m {\n                     return inverse & (m - 1);\n                 }\n@@ -2689,13 +2724,13 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     usize::max_value()\n }\n \n-\n-\n // Equality for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> PartialEq for *const T {\n     #[inline]\n-    fn eq(&self, other: &*const T) -> bool { *self == *other }\n+    fn eq(&self, other: &*const T) -> bool {\n+        *self == *other\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2704,7 +2739,9 @@ impl<T: ?Sized> Eq for *const T {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> PartialEq for *mut T {\n     #[inline]\n-    fn eq(&self, other: &*mut T) -> bool { *self == *other }\n+    fn eq(&self, other: &*mut T) -> bool {\n+        *self == *other\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2890,7 +2927,7 @@ macro_rules! fnptr_impls_args {\n     };\n }\n \n-fnptr_impls_args! { }\n+fnptr_impls_args! {}\n fnptr_impls_args! { A }\n fnptr_impls_args! { A, B }\n fnptr_impls_args! { A, B, C }\n@@ -2927,16 +2964,24 @@ impl<T: ?Sized> PartialOrd for *const T {\n     }\n \n     #[inline]\n-    fn lt(&self, other: &*const T) -> bool { *self < *other }\n+    fn lt(&self, other: &*const T) -> bool {\n+        *self < *other\n+    }\n \n     #[inline]\n-    fn le(&self, other: &*const T) -> bool { *self <= *other }\n+    fn le(&self, other: &*const T) -> bool {\n+        *self <= *other\n+    }\n \n     #[inline]\n-    fn gt(&self, other: &*const T) -> bool { *self > *other }\n+    fn gt(&self, other: &*const T) -> bool {\n+        *self > *other\n+    }\n \n     #[inline]\n-    fn ge(&self, other: &*const T) -> bool { *self >= *other }\n+    fn ge(&self, other: &*const T) -> bool {\n+        *self >= *other\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2961,14 +3006,22 @@ impl<T: ?Sized> PartialOrd for *mut T {\n     }\n \n     #[inline]\n-    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n+    fn lt(&self, other: &*mut T) -> bool {\n+        *self < *other\n+    }\n \n     #[inline]\n-    fn le(&self, other: &*mut T) -> bool { *self <= *other }\n+    fn le(&self, other: &*mut T) -> bool {\n+        *self <= *other\n+    }\n \n     #[inline]\n-    fn gt(&self, other: &*mut T) -> bool { *self > *other }\n+    fn gt(&self, other: &*mut T) -> bool {\n+        *self > *other\n+    }\n \n     #[inline]\n-    fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n+    fn ge(&self, other: &*mut T) -> bool {\n+        *self >= *other\n+    }\n }"}, {"sha": "b0dc99034644a9fd4ba8b8d380cbc18de2ad09fc", "filename": "src/libcore/tests/any.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fany.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -24,11 +24,8 @@ fn any_referenced() {\n \n #[test]\n fn any_owning() {\n-    let (a, b, c) = (\n-        box 5_usize as Box<dyn Any>,\n-        box TEST as Box<dyn Any>,\n-        box Test as Box<dyn Any>,\n-    );\n+    let (a, b, c) =\n+        (box 5_usize as Box<dyn Any>, box TEST as Box<dyn Any>, box Test as Box<dyn Any>);\n \n     assert!(a.is::<usize>());\n     assert!(!b.is::<usize>());\n@@ -49,12 +46,12 @@ fn any_downcast_ref() {\n \n     match a.downcast_ref::<usize>() {\n         Some(&5) => {}\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n \n     match a.downcast_ref::<Test>() {\n         None => {}\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n }\n \n@@ -72,35 +69,35 @@ fn any_downcast_mut() {\n             assert_eq!(*x, 5);\n             *x = 612;\n         }\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n \n     match b_r.downcast_mut::<usize>() {\n         Some(x) => {\n             assert_eq!(*x, 7);\n             *x = 413;\n         }\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n \n     match a_r.downcast_mut::<Test>() {\n         None => (),\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n \n     match b_r.downcast_mut::<Test>() {\n         None => (),\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n \n     match a_r.downcast_mut::<usize>() {\n         Some(&mut 612) => {}\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n \n     match b_r.downcast_mut::<usize>() {\n         Some(&mut 413) => {}\n-        x => panic!(\"Unexpected value {:?}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x),\n     }\n }\n "}, {"sha": "c2a816f0a7d90acc2017924ff8b115c80261c866", "filename": "src/libcore/tests/array.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -41,7 +41,6 @@ fn array_try_from() {\n     }\n }\n \n-\n #[test]\n fn iterator_collect() {\n     let arr = [0, 1, 2, 5, 9];\n@@ -150,10 +149,7 @@ fn iterator_flat_map() {\n #[test]\n fn iterator_debug() {\n     let arr = [0, 1, 2, 5, 9];\n-    assert_eq!(\n-        format!(\"{:?}\", IntoIter::new(arr)),\n-        \"IntoIter([0, 1, 2, 5, 9])\",\n-    );\n+    assert_eq!(format!(\"{:?}\", IntoIter::new(arr)), \"IntoIter([0, 1, 2, 5, 9])\",);\n }\n \n #[test]\n@@ -168,7 +164,7 @@ fn iterator_drops() {\n     struct Foo<'a>(&'a Cell<usize>);\n \n     impl Drop for Foo<'_> {\n-       fn drop(&mut self) {\n+        fn drop(&mut self) {\n             self.0.set(self.0.get() + 1);\n         }\n     }"}, {"sha": "71275d40c46211c52e6e522ce247ad19844259ed", "filename": "src/libcore/tests/ascii.rs", "status": "modified", "additions": 64, "deletions": 66, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -22,10 +22,12 @@ fn test_to_ascii_uppercase() {\n     assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n \n     for i in 0..501 {\n-        let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n-                    else { i };\n-        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n-                   (from_u32(upper).unwrap()).to_string());\n+        let upper =\n+            if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 } else { i };\n+        assert_eq!(\n+            (from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n+            (from_u32(upper).unwrap()).to_string()\n+        );\n     }\n }\n \n@@ -36,23 +38,23 @@ fn test_to_ascii_lowercase() {\n     assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n \n     for i in 0..501 {\n-        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                    else { i };\n-        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n-                   (from_u32(lower).unwrap()).to_string());\n+        let lower =\n+            if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 } else { i };\n+        assert_eq!(\n+            (from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n+            (from_u32(lower).unwrap()).to_string()\n+        );\n     }\n }\n \n #[test]\n fn test_make_ascii_lower_case() {\n     macro_rules! test {\n-        ($from: expr, $to: expr) => {\n-            {\n-                let mut x = $from;\n-                x.make_ascii_lowercase();\n-                assert_eq!(x, $to);\n-            }\n-        }\n+        ($from: expr, $to: expr) => {{\n+            let mut x = $from;\n+            x.make_ascii_lowercase();\n+            assert_eq!(x, $to);\n+        }};\n     }\n     test!(b'A', b'a');\n     test!(b'a', b'a');\n@@ -65,17 +67,14 @@ fn test_make_ascii_lower_case() {\n     test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n }\n \n-\n #[test]\n fn test_make_ascii_upper_case() {\n     macro_rules! test {\n-        ($from: expr, $to: expr) => {\n-            {\n-                let mut x = $from;\n-                x.make_ascii_uppercase();\n-                assert_eq!(x, $to);\n-            }\n-        }\n+        ($from: expr, $to: expr) => {{\n+            let mut x = $from;\n+            x.make_ascii_uppercase();\n+            assert_eq!(x, $to);\n+        }};\n     }\n     test!(b'a', b'A');\n     test!(b'A', b'A');\n@@ -88,7 +87,7 @@ fn test_make_ascii_upper_case() {\n     test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n \n     let mut x = \"Hello\".to_string();\n-    x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n+    x[..3].make_ascii_uppercase(); // Test IndexMut on String.\n     assert_eq!(x, \"HELlo\")\n }\n \n@@ -103,10 +102,13 @@ fn test_eq_ignore_ascii_case() {\n     assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n \n     for i in 0..501 {\n-        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                    else { i };\n-        assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n-                &from_u32(lower).unwrap().to_string()));\n+        let lower =\n+            if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 } else { i };\n+        assert!(\n+            (from_u32(i).unwrap())\n+                .to_string()\n+                .eq_ignore_ascii_case(&from_u32(lower).unwrap().to_string())\n+        );\n     }\n }\n \n@@ -158,12 +160,14 @@ macro_rules! assert_none {\n \n #[test]\n fn test_is_ascii_alphabetic() {\n-    assert_all!(is_ascii_alphabetic,\n+    assert_all!(\n+        is_ascii_alphabetic,\n         \"\",\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n     );\n-    assert_none!(is_ascii_alphabetic,\n+    assert_none!(\n+        is_ascii_alphabetic,\n         \"0123456789\",\n         \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n         \" \\t\\n\\x0c\\r\",\n@@ -177,11 +181,9 @@ fn test_is_ascii_alphabetic() {\n \n #[test]\n fn test_is_ascii_uppercase() {\n-    assert_all!(is_ascii_uppercase,\n-        \"\",\n-        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-    );\n-    assert_none!(is_ascii_uppercase,\n+    assert_all!(is_ascii_uppercase, \"\", \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",);\n+    assert_none!(\n+        is_ascii_uppercase,\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"0123456789\",\n         \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n@@ -196,10 +198,9 @@ fn test_is_ascii_uppercase() {\n \n #[test]\n fn test_is_ascii_lowercase() {\n-    assert_all!(is_ascii_lowercase,\n-        \"abcdefghijklmnopqrstuvwxyz\",\n-    );\n-    assert_none!(is_ascii_lowercase,\n+    assert_all!(is_ascii_lowercase, \"abcdefghijklmnopqrstuvwxyz\",);\n+    assert_none!(\n+        is_ascii_lowercase,\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n         \"0123456789\",\n         \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n@@ -214,13 +215,15 @@ fn test_is_ascii_lowercase() {\n \n #[test]\n fn test_is_ascii_alphanumeric() {\n-    assert_all!(is_ascii_alphanumeric,\n+    assert_all!(\n+        is_ascii_alphanumeric,\n         \"\",\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n         \"0123456789\",\n     );\n-    assert_none!(is_ascii_alphanumeric,\n+    assert_none!(\n+        is_ascii_alphanumeric,\n         \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n         \" \\t\\n\\x0c\\r\",\n         \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n@@ -233,11 +236,9 @@ fn test_is_ascii_alphanumeric() {\n \n #[test]\n fn test_is_ascii_digit() {\n-    assert_all!(is_ascii_digit,\n-        \"\",\n-        \"0123456789\",\n-    );\n-    assert_none!(is_ascii_digit,\n+    assert_all!(is_ascii_digit, \"\", \"0123456789\",);\n+    assert_none!(\n+        is_ascii_digit,\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n         \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n@@ -252,12 +253,9 @@ fn test_is_ascii_digit() {\n \n #[test]\n fn test_is_ascii_hexdigit() {\n-    assert_all!(is_ascii_hexdigit,\n-        \"\",\n-        \"0123456789\",\n-        \"abcdefABCDEF\",\n-    );\n-    assert_none!(is_ascii_hexdigit,\n+    assert_all!(is_ascii_hexdigit, \"\", \"0123456789\", \"abcdefABCDEF\",);\n+    assert_none!(\n+        is_ascii_hexdigit,\n         \"ghijklmnopqrstuvwxyz\",\n         \"GHIJKLMNOQPRSTUVWXYZ\",\n         \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n@@ -272,11 +270,9 @@ fn test_is_ascii_hexdigit() {\n \n #[test]\n fn test_is_ascii_punctuation() {\n-    assert_all!(is_ascii_punctuation,\n-        \"\",\n-        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-    );\n-    assert_none!(is_ascii_punctuation,\n+    assert_all!(is_ascii_punctuation, \"\", \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",);\n+    assert_none!(\n+        is_ascii_punctuation,\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n         \"0123456789\",\n@@ -291,14 +287,16 @@ fn test_is_ascii_punctuation() {\n \n #[test]\n fn test_is_ascii_graphic() {\n-    assert_all!(is_ascii_graphic,\n+    assert_all!(\n+        is_ascii_graphic,\n         \"\",\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n         \"0123456789\",\n         \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n     );\n-    assert_none!(is_ascii_graphic,\n+    assert_none!(\n+        is_ascii_graphic,\n         \" \\t\\n\\x0c\\r\",\n         \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n         \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n@@ -310,11 +308,9 @@ fn test_is_ascii_graphic() {\n \n #[test]\n fn test_is_ascii_whitespace() {\n-    assert_all!(is_ascii_whitespace,\n-        \"\",\n-        \" \\t\\n\\x0c\\r\",\n-    );\n-    assert_none!(is_ascii_whitespace,\n+    assert_all!(is_ascii_whitespace, \"\", \" \\t\\n\\x0c\\r\",);\n+    assert_none!(\n+        is_ascii_whitespace,\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n         \"0123456789\",\n@@ -329,15 +325,17 @@ fn test_is_ascii_whitespace() {\n \n #[test]\n fn test_is_ascii_control() {\n-    assert_all!(is_ascii_control,\n+    assert_all!(\n+        is_ascii_control,\n         \"\",\n         \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n         \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n         \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n         \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n         \"\\x7f\",\n     );\n-    assert_none!(is_ascii_control,\n+    assert_none!(\n+        is_ascii_control,\n         \"abcdefghijklmnopqrstuvwxyz\",\n         \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n         \"0123456789\","}, {"sha": "acbd913982c1f699c60c434ef88328e0348ecc26", "filename": "src/libcore/tests/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fatomic.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,5 +1,5 @@\n-use core::sync::atomic::*;\n use core::sync::atomic::Ordering::SeqCst;\n+use core::sync::atomic::*;\n \n #[test]\n fn bool_() {\n@@ -15,7 +15,7 @@ fn bool_() {\n fn bool_and() {\n     let a = AtomicBool::new(true);\n     assert_eq!(a.fetch_and(false, SeqCst), true);\n-    assert_eq!(a.load(SeqCst),false);\n+    assert_eq!(a.load(SeqCst), false);\n }\n \n #[test]\n@@ -89,7 +89,7 @@ fn int_xor() {\n \n static S_FALSE: AtomicBool = AtomicBool::new(false);\n static S_TRUE: AtomicBool = AtomicBool::new(true);\n-static S_INT: AtomicIsize  = AtomicIsize::new(0);\n+static S_INT: AtomicIsize = AtomicIsize::new(0);\n static S_UINT: AtomicUsize = AtomicUsize::new(0);\n \n #[test]"}, {"sha": "801b60be0f093b8629bd1b5bf75abc35402acd94", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -236,7 +236,7 @@ fn ref_mut_map_accessor() {\n     }\n     let x = X(RefCell::new((7, 'z')));\n     {\n-        let mut d: RefMut<'_ ,u32> = x.accessor();\n+        let mut d: RefMut<'_, u32> = x.accessor();\n         assert_eq!(*d, 7);\n         *d += 1;\n     }\n@@ -250,15 +250,19 @@ fn as_ptr() {\n     assert_eq!(1, unsafe { *c1.as_ptr() });\n \n     let c2: Cell<usize> = Cell::new(0);\n-    unsafe { *c2.as_ptr() = 1; }\n+    unsafe {\n+        *c2.as_ptr() = 1;\n+    }\n     assert_eq!(1, c2.get());\n \n     let r1: RefCell<usize> = RefCell::new(0);\n     *r1.borrow_mut() = 1;\n     assert_eq!(1, unsafe { *r1.as_ptr() });\n \n     let r2: RefCell<usize> = RefCell::new(0);\n-    unsafe { *r2.as_ptr() = 1; }\n+    unsafe {\n+        *r2.as_ptr() = 1;\n+    }\n     assert_eq!(1, *r2.borrow());\n }\n "}, {"sha": "c16f54081ce06ca45da427db2475745bacaca2a8", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,6 +1,6 @@\n-use std::{char,str};\n use std::convert::TryFrom;\n use std::str::FromStr;\n+use std::{char, str};\n \n #[test]\n fn test_convert() {\n@@ -143,13 +143,13 @@ fn test_is_control() {\n \n #[test]\n fn test_is_numeric() {\n-   assert!('2'.is_numeric());\n-   assert!('7'.is_numeric());\n-   assert!('\u00be'.is_numeric());\n-   assert!(!'c'.is_numeric());\n-   assert!(!'i'.is_numeric());\n-   assert!(!'z'.is_numeric());\n-   assert!(!'Q'.is_numeric());\n+    assert!('2'.is_numeric());\n+    assert!('7'.is_numeric());\n+    assert!('\u00be'.is_numeric());\n+    assert!(!'c'.is_numeric());\n+    assert!(!'i'.is_numeric());\n+    assert!(!'z'.is_numeric());\n+    assert!(!'Q'.is_numeric());\n }\n \n #[test]\n@@ -176,9 +176,9 @@ fn test_escape_debug() {\n     assert_eq!(string('\\u{ff}'), \"\\u{ff}\");\n     assert_eq!(string('\\u{11b}'), \"\\u{11b}\");\n     assert_eq!(string('\\u{1d4b6}'), \"\\u{1d4b6}\");\n-    assert_eq!(string('\\u{301}'), \"\\\\u{301}\");     // combining character\n-    assert_eq!(string('\\u{200b}'),\"\\\\u{200b}\");      // zero width space\n-    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\");     // private use 1\n+    assert_eq!(string('\\u{301}'), \"\\\\u{301}\"); // combining character\n+    assert_eq!(string('\\u{200b}'), \"\\\\u{200b}\"); // zero width space\n+    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\"); // private use 1\n     assert_eq!(string('\\u{100000}'), \"\\\\u{100000}\"); // private use 2\n }\n \n@@ -272,8 +272,8 @@ fn test_len_utf16() {\n fn test_decode_utf16() {\n     fn check(s: &[u16], expected: &[Result<char, u16>]) {\n         let v = char::decode_utf16(s.iter().cloned())\n-                     .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-                     .collect::<Vec<_>>();\n+            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+            .collect::<Vec<_>>();\n         assert_eq!(v, expected);\n     }\n     check(&[0xD800, 0x41, 0x42], &[Err(0xD800), Ok('A'), Ok('B')]);"}, {"sha": "ba0220f0d92df86eda4aba30f5b979ab6664fcfd", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,7 +1,7 @@\n mod sip;\n \n-use std::hash::{Hash, Hasher};\n use std::default::Default;\n+use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n \n struct MyHasher {\n@@ -20,10 +20,11 @@ impl Hasher for MyHasher {\n             self.hash += *byte as u64;\n         }\n     }\n-    fn finish(&self) -> u64 { self.hash }\n+    fn finish(&self) -> u64 {\n+        self.hash\n+    }\n }\n \n-\n #[test]\n fn test_writer_hasher() {\n     fn hash<T: Hash>(t: &T) -> u64 {\n@@ -52,42 +53,54 @@ fn test_writer_hasher() {\n     assert_eq!(hash(&'a'), 97);\n \n     let s: &str = \"a\";\n-    assert_eq!(hash(& s), 97 + 0xFF);\n+    assert_eq!(hash(&s), 97 + 0xFF);\n     let s: Box<str> = String::from(\"a\").into_boxed_str();\n-    assert_eq!(hash(& s), 97 + 0xFF);\n+    assert_eq!(hash(&s), 97 + 0xFF);\n     let s: Rc<&str> = Rc::new(\"a\");\n     assert_eq!(hash(&s), 97 + 0xFF);\n     let cs: &[u8] = &[1, 2, 3];\n-    assert_eq!(hash(& cs), 9);\n+    assert_eq!(hash(&cs), 9);\n     let cs: Box<[u8]> = Box::new([1, 2, 3]);\n-    assert_eq!(hash(& cs), 9);\n+    assert_eq!(hash(&cs), 9);\n     let cs: Rc<[u8]> = Rc::new([1, 2, 3]);\n-    assert_eq!(hash(& cs), 9);\n+    assert_eq!(hash(&cs), 9);\n \n     let ptr = 5_usize as *const i32;\n     assert_eq!(hash(&ptr), 5);\n \n     let ptr = 5_usize as *mut i32;\n     assert_eq!(hash(&ptr), 5);\n \n+    if cfg!(miri) { // Miri cannot hash pointers\n+        return;\n+    }\n+\n     let cs: &mut [u8] = &mut [1, 2, 3];\n     let ptr = cs.as_ptr();\n     let slice_ptr = cs as *const [u8];\n-    #[cfg(not(miri))] // Miri cannot hash pointers\n     assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n \n     let slice_ptr = cs as *mut [u8];\n-    #[cfg(not(miri))] // Miri cannot hash pointers\n     assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n }\n \n-struct Custom { hash: u64 }\n-struct CustomHasher { output: u64 }\n+struct Custom {\n+    hash: u64,\n+}\n+struct CustomHasher {\n+    output: u64,\n+}\n \n impl Hasher for CustomHasher {\n-    fn finish(&self) -> u64 { self.output }\n-    fn write(&mut self, _: &[u8]) { panic!() }\n-    fn write_u64(&mut self, data: u64) { self.output = data; }\n+    fn finish(&self) -> u64 {\n+        self.output\n+    }\n+    fn write(&mut self, _: &[u8]) {\n+        panic!()\n+    }\n+    fn write_u64(&mut self, data: u64) {\n+        self.output = data;\n+    }\n }\n \n impl Default for CustomHasher {"}, {"sha": "0f09554991591a9d3a20da6d51abebf00c9e5583", "filename": "src/libcore/tests/hash/sip.rs", "status": "modified", "additions": 145, "deletions": 146, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -2,7 +2,7 @@\n \n use core::hash::{Hash, Hasher};\n use core::hash::{SipHasher, SipHasher13};\n-use core::{slice, mem};\n+use core::{mem, slice};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -16,25 +16,25 @@ impl<'a> Hash for Bytes<'a> {\n }\n \n macro_rules! u8to64_le {\n-    ($buf:expr, $i:expr) =>\n-    ($buf[0+$i] as u64 |\n-     ($buf[1+$i] as u64) << 8 |\n-     ($buf[2+$i] as u64) << 16 |\n-     ($buf[3+$i] as u64) << 24 |\n-     ($buf[4+$i] as u64) << 32 |\n-     ($buf[5+$i] as u64) << 40 |\n-     ($buf[6+$i] as u64) << 48 |\n-     ($buf[7+$i] as u64) << 56);\n-    ($buf:expr, $i:expr, $len:expr) =>\n-    ({\n+    ($buf:expr, $i:expr) => {\n+        $buf[0 + $i] as u64\n+            | ($buf[1 + $i] as u64) << 8\n+            | ($buf[2 + $i] as u64) << 16\n+            | ($buf[3 + $i] as u64) << 24\n+            | ($buf[4 + $i] as u64) << 32\n+            | ($buf[5 + $i] as u64) << 40\n+            | ($buf[6 + $i] as u64) << 48\n+            | ($buf[7 + $i] as u64) << 56\n+    };\n+    ($buf:expr, $i:expr, $len:expr) => {{\n         let mut t = 0;\n         let mut out = 0;\n         while t < $len {\n-            out |= ($buf[t+$i] as u64) << t*8;\n+            out |= ($buf[t + $i] as u64) << t * 8;\n             t += 1;\n         }\n         out\n-    });\n+    }};\n }\n \n fn hash_with<H: Hasher, T: Hash>(mut st: H, x: &T) -> u64 {\n@@ -49,71 +49,71 @@ fn hash<T: Hash>(x: &T) -> u64 {\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash_1_3() {\n-    let vecs : [[u8; 8]; 64] = [\n-        [ 0xdc, 0xc4, 0x0f, 0x05, 0x58, 0x01, 0xac, 0xab ],\n-        [ 0x93, 0xca, 0x57, 0x7d, 0xf3, 0x9b, 0xf4, 0xc9 ],\n-        [ 0x4d, 0xd4, 0xc7, 0x4d, 0x02, 0x9b, 0xcb, 0x82 ],\n-        [ 0xfb, 0xf7, 0xdd, 0xe7, 0xb8, 0x0a, 0xf8, 0x8b ],\n-        [ 0x28, 0x83, 0xd3, 0x88, 0x60, 0x57, 0x75, 0xcf ],\n-        [ 0x67, 0x3b, 0x53, 0x49, 0x2f, 0xd5, 0xf9, 0xde ],\n-        [ 0xa7, 0x22, 0x9f, 0xc5, 0x50, 0x2b, 0x0d, 0xc5 ],\n-        [ 0x40, 0x11, 0xb1, 0x9b, 0x98, 0x7d, 0x92, 0xd3 ],\n-        [ 0x8e, 0x9a, 0x29, 0x8d, 0x11, 0x95, 0x90, 0x36 ],\n-        [ 0xe4, 0x3d, 0x06, 0x6c, 0xb3, 0x8e, 0xa4, 0x25 ],\n-        [ 0x7f, 0x09, 0xff, 0x92, 0xee, 0x85, 0xde, 0x79 ],\n-        [ 0x52, 0xc3, 0x4d, 0xf9, 0xc1, 0x18, 0xc1, 0x70 ],\n-        [ 0xa2, 0xd9, 0xb4, 0x57, 0xb1, 0x84, 0xa3, 0x78 ],\n-        [ 0xa7, 0xff, 0x29, 0x12, 0x0c, 0x76, 0x6f, 0x30 ],\n-        [ 0x34, 0x5d, 0xf9, 0xc0, 0x11, 0xa1, 0x5a, 0x60 ],\n-        [ 0x56, 0x99, 0x51, 0x2a, 0x6d, 0xd8, 0x20, 0xd3 ],\n-        [ 0x66, 0x8b, 0x90, 0x7d, 0x1a, 0xdd, 0x4f, 0xcc ],\n-        [ 0x0c, 0xd8, 0xdb, 0x63, 0x90, 0x68, 0xf2, 0x9c ],\n-        [ 0x3e, 0xe6, 0x73, 0xb4, 0x9c, 0x38, 0xfc, 0x8f ],\n-        [ 0x1c, 0x7d, 0x29, 0x8d, 0xe5, 0x9d, 0x1f, 0xf2 ],\n-        [ 0x40, 0xe0, 0xcc, 0xa6, 0x46, 0x2f, 0xdc, 0xc0 ],\n-        [ 0x44, 0xf8, 0x45, 0x2b, 0xfe, 0xab, 0x92, 0xb9 ],\n-        [ 0x2e, 0x87, 0x20, 0xa3, 0x9b, 0x7b, 0xfe, 0x7f ],\n-        [ 0x23, 0xc1, 0xe6, 0xda, 0x7f, 0x0e, 0x5a, 0x52 ],\n-        [ 0x8c, 0x9c, 0x34, 0x67, 0xb2, 0xae, 0x64, 0xf4 ],\n-        [ 0x79, 0x09, 0x5b, 0x70, 0x28, 0x59, 0xcd, 0x45 ],\n-        [ 0xa5, 0x13, 0x99, 0xca, 0xe3, 0x35, 0x3e, 0x3a ],\n-        [ 0x35, 0x3b, 0xde, 0x4a, 0x4e, 0xc7, 0x1d, 0xa9 ],\n-        [ 0x0d, 0xd0, 0x6c, 0xef, 0x02, 0xed, 0x0b, 0xfb ],\n-        [ 0xf4, 0xe1, 0xb1, 0x4a, 0xb4, 0x3c, 0xd9, 0x88 ],\n-        [ 0x63, 0xe6, 0xc5, 0x43, 0xd6, 0x11, 0x0f, 0x54 ],\n-        [ 0xbc, 0xd1, 0x21, 0x8c, 0x1f, 0xdd, 0x70, 0x23 ],\n-        [ 0x0d, 0xb6, 0xa7, 0x16, 0x6c, 0x7b, 0x15, 0x81 ],\n-        [ 0xbf, 0xf9, 0x8f, 0x7a, 0xe5, 0xb9, 0x54, 0x4d ],\n-        [ 0x3e, 0x75, 0x2a, 0x1f, 0x78, 0x12, 0x9f, 0x75 ],\n-        [ 0x91, 0x6b, 0x18, 0xbf, 0xbe, 0xa3, 0xa1, 0xce ],\n-        [ 0x06, 0x62, 0xa2, 0xad, 0xd3, 0x08, 0xf5, 0x2c ],\n-        [ 0x57, 0x30, 0xc3, 0xa3, 0x2d, 0x1c, 0x10, 0xb6 ],\n-        [ 0xa1, 0x36, 0x3a, 0xae, 0x96, 0x74, 0xf4, 0xb3 ],\n-        [ 0x92, 0x83, 0x10, 0x7b, 0x54, 0x57, 0x6b, 0x62 ],\n-        [ 0x31, 0x15, 0xe4, 0x99, 0x32, 0x36, 0xd2, 0xc1 ],\n-        [ 0x44, 0xd9, 0x1a, 0x3f, 0x92, 0xc1, 0x7c, 0x66 ],\n-        [ 0x25, 0x88, 0x13, 0xc8, 0xfe, 0x4f, 0x70, 0x65 ],\n-        [ 0xa6, 0x49, 0x89, 0xc2, 0xd1, 0x80, 0xf2, 0x24 ],\n-        [ 0x6b, 0x87, 0xf8, 0xfa, 0xed, 0x1c, 0xca, 0xc2 ],\n-        [ 0x96, 0x21, 0x04, 0x9f, 0xfc, 0x4b, 0x16, 0xc2 ],\n-        [ 0x23, 0xd6, 0xb1, 0x68, 0x93, 0x9c, 0x6e, 0xa1 ],\n-        [ 0xfd, 0x14, 0x51, 0x8b, 0x9c, 0x16, 0xfb, 0x49 ],\n-        [ 0x46, 0x4c, 0x07, 0xdf, 0xf8, 0x43, 0x31, 0x9f ],\n-        [ 0xb3, 0x86, 0xcc, 0x12, 0x24, 0xaf, 0xfd, 0xc6 ],\n-        [ 0x8f, 0x09, 0x52, 0x0a, 0xd1, 0x49, 0xaf, 0x7e ],\n-        [ 0x9a, 0x2f, 0x29, 0x9d, 0x55, 0x13, 0xf3, 0x1c ],\n-        [ 0x12, 0x1f, 0xf4, 0xa2, 0xdd, 0x30, 0x4a, 0xc4 ],\n-        [ 0xd0, 0x1e, 0xa7, 0x43, 0x89, 0xe9, 0xfa, 0x36 ],\n-        [ 0xe6, 0xbc, 0xf0, 0x73, 0x4c, 0xb3, 0x8f, 0x31 ],\n-        [ 0x80, 0xe9, 0xa7, 0x70, 0x36, 0xbf, 0x7a, 0xa2 ],\n-        [ 0x75, 0x6d, 0x3c, 0x24, 0xdb, 0xc0, 0xbc, 0xb4 ],\n-        [ 0x13, 0x15, 0xb7, 0xfd, 0x52, 0xd8, 0xf8, 0x23 ],\n-        [ 0x08, 0x8a, 0x7d, 0xa6, 0x4d, 0x5f, 0x03, 0x8f ],\n-        [ 0x48, 0xf1, 0xe8, 0xb7, 0xe5, 0xd0, 0x9c, 0xd8 ],\n-        [ 0xee, 0x44, 0xa6, 0xf7, 0xbc, 0xe6, 0xf4, 0xf6 ],\n-        [ 0xf2, 0x37, 0x18, 0x0f, 0xd8, 0x9a, 0xc5, 0xae ],\n-        [ 0xe0, 0x94, 0x66, 0x4b, 0x15, 0xf6, 0xb2, 0xc3 ],\n-        [ 0xa8, 0xb3, 0xbb, 0xb7, 0x62, 0x90, 0x19, 0x9d ]\n+    let vecs: [[u8; 8]; 64] = [\n+        [0xdc, 0xc4, 0x0f, 0x05, 0x58, 0x01, 0xac, 0xab],\n+        [0x93, 0xca, 0x57, 0x7d, 0xf3, 0x9b, 0xf4, 0xc9],\n+        [0x4d, 0xd4, 0xc7, 0x4d, 0x02, 0x9b, 0xcb, 0x82],\n+        [0xfb, 0xf7, 0xdd, 0xe7, 0xb8, 0x0a, 0xf8, 0x8b],\n+        [0x28, 0x83, 0xd3, 0x88, 0x60, 0x57, 0x75, 0xcf],\n+        [0x67, 0x3b, 0x53, 0x49, 0x2f, 0xd5, 0xf9, 0xde],\n+        [0xa7, 0x22, 0x9f, 0xc5, 0x50, 0x2b, 0x0d, 0xc5],\n+        [0x40, 0x11, 0xb1, 0x9b, 0x98, 0x7d, 0x92, 0xd3],\n+        [0x8e, 0x9a, 0x29, 0x8d, 0x11, 0x95, 0x90, 0x36],\n+        [0xe4, 0x3d, 0x06, 0x6c, 0xb3, 0x8e, 0xa4, 0x25],\n+        [0x7f, 0x09, 0xff, 0x92, 0xee, 0x85, 0xde, 0x79],\n+        [0x52, 0xc3, 0x4d, 0xf9, 0xc1, 0x18, 0xc1, 0x70],\n+        [0xa2, 0xd9, 0xb4, 0x57, 0xb1, 0x84, 0xa3, 0x78],\n+        [0xa7, 0xff, 0x29, 0x12, 0x0c, 0x76, 0x6f, 0x30],\n+        [0x34, 0x5d, 0xf9, 0xc0, 0x11, 0xa1, 0x5a, 0x60],\n+        [0x56, 0x99, 0x51, 0x2a, 0x6d, 0xd8, 0x20, 0xd3],\n+        [0x66, 0x8b, 0x90, 0x7d, 0x1a, 0xdd, 0x4f, 0xcc],\n+        [0x0c, 0xd8, 0xdb, 0x63, 0x90, 0x68, 0xf2, 0x9c],\n+        [0x3e, 0xe6, 0x73, 0xb4, 0x9c, 0x38, 0xfc, 0x8f],\n+        [0x1c, 0x7d, 0x29, 0x8d, 0xe5, 0x9d, 0x1f, 0xf2],\n+        [0x40, 0xe0, 0xcc, 0xa6, 0x46, 0x2f, 0xdc, 0xc0],\n+        [0x44, 0xf8, 0x45, 0x2b, 0xfe, 0xab, 0x92, 0xb9],\n+        [0x2e, 0x87, 0x20, 0xa3, 0x9b, 0x7b, 0xfe, 0x7f],\n+        [0x23, 0xc1, 0xe6, 0xda, 0x7f, 0x0e, 0x5a, 0x52],\n+        [0x8c, 0x9c, 0x34, 0x67, 0xb2, 0xae, 0x64, 0xf4],\n+        [0x79, 0x09, 0x5b, 0x70, 0x28, 0x59, 0xcd, 0x45],\n+        [0xa5, 0x13, 0x99, 0xca, 0xe3, 0x35, 0x3e, 0x3a],\n+        [0x35, 0x3b, 0xde, 0x4a, 0x4e, 0xc7, 0x1d, 0xa9],\n+        [0x0d, 0xd0, 0x6c, 0xef, 0x02, 0xed, 0x0b, 0xfb],\n+        [0xf4, 0xe1, 0xb1, 0x4a, 0xb4, 0x3c, 0xd9, 0x88],\n+        [0x63, 0xe6, 0xc5, 0x43, 0xd6, 0x11, 0x0f, 0x54],\n+        [0xbc, 0xd1, 0x21, 0x8c, 0x1f, 0xdd, 0x70, 0x23],\n+        [0x0d, 0xb6, 0xa7, 0x16, 0x6c, 0x7b, 0x15, 0x81],\n+        [0xbf, 0xf9, 0x8f, 0x7a, 0xe5, 0xb9, 0x54, 0x4d],\n+        [0x3e, 0x75, 0x2a, 0x1f, 0x78, 0x12, 0x9f, 0x75],\n+        [0x91, 0x6b, 0x18, 0xbf, 0xbe, 0xa3, 0xa1, 0xce],\n+        [0x06, 0x62, 0xa2, 0xad, 0xd3, 0x08, 0xf5, 0x2c],\n+        [0x57, 0x30, 0xc3, 0xa3, 0x2d, 0x1c, 0x10, 0xb6],\n+        [0xa1, 0x36, 0x3a, 0xae, 0x96, 0x74, 0xf4, 0xb3],\n+        [0x92, 0x83, 0x10, 0x7b, 0x54, 0x57, 0x6b, 0x62],\n+        [0x31, 0x15, 0xe4, 0x99, 0x32, 0x36, 0xd2, 0xc1],\n+        [0x44, 0xd9, 0x1a, 0x3f, 0x92, 0xc1, 0x7c, 0x66],\n+        [0x25, 0x88, 0x13, 0xc8, 0xfe, 0x4f, 0x70, 0x65],\n+        [0xa6, 0x49, 0x89, 0xc2, 0xd1, 0x80, 0xf2, 0x24],\n+        [0x6b, 0x87, 0xf8, 0xfa, 0xed, 0x1c, 0xca, 0xc2],\n+        [0x96, 0x21, 0x04, 0x9f, 0xfc, 0x4b, 0x16, 0xc2],\n+        [0x23, 0xd6, 0xb1, 0x68, 0x93, 0x9c, 0x6e, 0xa1],\n+        [0xfd, 0x14, 0x51, 0x8b, 0x9c, 0x16, 0xfb, 0x49],\n+        [0x46, 0x4c, 0x07, 0xdf, 0xf8, 0x43, 0x31, 0x9f],\n+        [0xb3, 0x86, 0xcc, 0x12, 0x24, 0xaf, 0xfd, 0xc6],\n+        [0x8f, 0x09, 0x52, 0x0a, 0xd1, 0x49, 0xaf, 0x7e],\n+        [0x9a, 0x2f, 0x29, 0x9d, 0x55, 0x13, 0xf3, 0x1c],\n+        [0x12, 0x1f, 0xf4, 0xa2, 0xdd, 0x30, 0x4a, 0xc4],\n+        [0xd0, 0x1e, 0xa7, 0x43, 0x89, 0xe9, 0xfa, 0x36],\n+        [0xe6, 0xbc, 0xf0, 0x73, 0x4c, 0xb3, 0x8f, 0x31],\n+        [0x80, 0xe9, 0xa7, 0x70, 0x36, 0xbf, 0x7a, 0xa2],\n+        [0x75, 0x6d, 0x3c, 0x24, 0xdb, 0xc0, 0xbc, 0xb4],\n+        [0x13, 0x15, 0xb7, 0xfd, 0x52, 0xd8, 0xf8, 0x23],\n+        [0x08, 0x8a, 0x7d, 0xa6, 0x4d, 0x5f, 0x03, 0x8f],\n+        [0x48, 0xf1, 0xe8, 0xb7, 0xe5, 0xd0, 0x9c, 0xd8],\n+        [0xee, 0x44, 0xa6, 0xf7, 0xbc, 0xe6, 0xf4, 0xf6],\n+        [0xf2, 0x37, 0x18, 0x0f, 0xd8, 0x9a, 0xc5, 0xae],\n+        [0xe0, 0x94, 0x66, 0x4b, 0x15, 0xf6, 0xb2, 0xc3],\n+        [0xa8, 0xb3, 0xbb, 0xb7, 0x62, 0x90, 0x19, 0x9d],\n     ];\n \n     let k0 = 0x_07_06_05_04_03_02_01_00;\n@@ -143,71 +143,71 @@ fn test_siphash_1_3() {\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash_2_4() {\n-    let vecs : [[u8; 8]; 64] = [\n-        [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n-        [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n-        [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n-        [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n-        [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n-        [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n-        [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n-        [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n-        [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n-        [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n-        [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n-        [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n-        [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n-        [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n-        [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n-        [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n-        [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n-        [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n-        [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n-        [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n-        [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n-        [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n-        [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n-        [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n-        [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n-        [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n-        [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n-        [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n-        [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n-        [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n-        [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n-        [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n-        [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n-        [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n-        [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n-        [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n-        [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n-        [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n-        [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n-        [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n-        [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n-        [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n-        [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n-        [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n-        [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n-        [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n-        [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n-        [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n-        [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n-        [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n-        [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n-        [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n-        [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n-        [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n-        [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n-        [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n-        [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n-        [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n-        [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n-        [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n-        [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n-        [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n-        [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n-        [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n+    let vecs: [[u8; 8]; 64] = [\n+        [0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72],\n+        [0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74],\n+        [0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d],\n+        [0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85],\n+        [0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf],\n+        [0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18],\n+        [0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb],\n+        [0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab],\n+        [0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93],\n+        [0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e],\n+        [0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a],\n+        [0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4],\n+        [0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75],\n+        [0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14],\n+        [0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7],\n+        [0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1],\n+        [0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f],\n+        [0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69],\n+        [0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b],\n+        [0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb],\n+        [0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe],\n+        [0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0],\n+        [0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93],\n+        [0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8],\n+        [0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8],\n+        [0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc],\n+        [0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17],\n+        [0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f],\n+        [0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde],\n+        [0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6],\n+        [0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad],\n+        [0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32],\n+        [0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71],\n+        [0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7],\n+        [0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12],\n+        [0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15],\n+        [0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31],\n+        [0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02],\n+        [0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca],\n+        [0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a],\n+        [0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e],\n+        [0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad],\n+        [0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18],\n+        [0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4],\n+        [0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9],\n+        [0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9],\n+        [0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb],\n+        [0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0],\n+        [0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6],\n+        [0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7],\n+        [0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee],\n+        [0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1],\n+        [0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a],\n+        [0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81],\n+        [0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f],\n+        [0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24],\n+        [0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7],\n+        [0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea],\n+        [0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60],\n+        [0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66],\n+        [0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c],\n+        [0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f],\n+        [0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5],\n+        [0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95],\n     ];\n \n     let k0 = 0x_07_06_05_04_03_02_01_00;\n@@ -320,8 +320,7 @@ fn test_write_short_works() {\n     h1.write_u8(0x01u8);\n     let mut h2 = SipHasher::new();\n     h2.write(unsafe {\n-        slice::from_raw_parts(&test_usize as *const _ as *const u8,\n-                              mem::size_of::<usize>())\n+        slice::from_raw_parts(&test_usize as *const _ as *const u8, mem::size_of::<usize>())\n     });\n     h2.write(b\"bytes\");\n     h2.write(b\"string\");"}, {"sha": "fed7c4a5bf3991ddc69aaf9d46bbd46cfd54def1", "filename": "src/libcore/tests/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fintrinsics.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -2,7 +2,8 @@ use core::any::TypeId;\n \n #[test]\n fn test_typeid_sized_types() {\n-    struct X; struct Y(u32);\n+    struct X;\n+    struct Y(u32);\n \n     assert_eq!(TypeId::of::<X>(), TypeId::of::<X>());\n     assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());\n@@ -12,7 +13,8 @@ fn test_typeid_sized_types() {\n #[test]\n fn test_typeid_unsized_types() {\n     trait Z {}\n-    struct X(str); struct Y(dyn Z + 'static);\n+    struct X(str);\n+    struct Y(dyn Z + 'static);\n \n     assert_eq!(TypeId::of::<X>(), TypeId::of::<X>());\n     assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());"}, {"sha": "77a338daf7dcb45b60708d2c47d8013f92fc29ee", "filename": "src/libcore/tests/manually_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmanually_drop.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -13,7 +13,7 @@ fn smoke() {\n     drop(x);\n \n     // also test unsizing\n-    let x : Box<ManuallyDrop<[TypeWithDrop]>> =\n+    let x: Box<ManuallyDrop<[TypeWithDrop]>> =\n         Box::new(ManuallyDrop::new([TypeWithDrop, TypeWithDrop]));\n     drop(x);\n }"}, {"sha": "59588d97787b7adc19a93b15b83868fe8f980614", "filename": "src/libcore/tests/mem.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmem.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -96,7 +96,9 @@ fn test_transmute_copy() {\n \n #[test]\n fn test_transmute() {\n-    trait Foo { fn dummy(&self) { } }\n+    trait Foo {\n+        fn dummy(&self) {}\n+    }\n     impl Foo for isize {}\n \n     let a = box 100isize as Box<dyn Foo>;\n@@ -116,13 +118,13 @@ fn test_transmute() {\n fn test_discriminant_send_sync() {\n     enum Regular {\n         A,\n-        B(i32)\n+        B(i32),\n     }\n     enum NotSendSync {\n-        A(*const i32)\n+        A(*const i32),\n     }\n \n-    fn is_send_sync<T: Send + Sync>() { }\n+    fn is_send_sync<T: Send + Sync>() {}\n \n     is_send_sync::<Discriminant<Regular>>();\n     is_send_sync::<Discriminant<NotSendSync>>();"}, {"sha": "6c5d19845e406d05e6860069b00ae6a9c6520176", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -4,9 +4,7 @@ use std::mem::size_of;\n \n #[test]\n fn test_create_nonzero_instance() {\n-    let _a = unsafe {\n-        NonZeroU32::new_unchecked(21)\n-    };\n+    let _a = unsafe { NonZeroU32::new_unchecked(21) };\n }\n \n #[test]\n@@ -17,17 +15,15 @@ fn test_size_nonzero_in_option() {\n \n #[test]\n fn test_match_on_nonzero_option() {\n-    let a = Some(unsafe {\n-        NonZeroU32::new_unchecked(42)\n-    });\n+    let a = Some(unsafe { NonZeroU32::new_unchecked(42) });\n     match a {\n         Some(val) => assert_eq!(val.get(), 42),\n-        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\"),\n     }\n \n     match unsafe { Some(NonZeroU32::new_unchecked(43)) } {\n         Some(val) => assert_eq!(val.get(), 43),\n-        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\"),\n     }\n }\n \n@@ -45,7 +41,7 @@ fn test_match_option_vec() {\n     let a = Some(vec![1, 2, 3, 4]);\n     match a {\n         Some(v) => assert_eq!(v, [1, 2, 3, 4]),\n-        None => panic!(\"unexpected None while matching on Some(vec![1, 2, 3, 4])\")\n+        None => panic!(\"unexpected None while matching on Some(vec![1, 2, 3, 4])\"),\n     }\n }\n \n@@ -56,7 +52,7 @@ fn test_match_option_rc() {\n     let five = Rc::new(5);\n     match Some(five) {\n         Some(r) => assert_eq!(*r, 5),\n-        None => panic!(\"unexpected None while matching on Some(Rc::new(5))\")\n+        None => panic!(\"unexpected None while matching on Some(Rc::new(5))\"),\n     }\n }\n \n@@ -67,7 +63,7 @@ fn test_match_option_arc() {\n     let five = Arc::new(5);\n     match Some(five) {\n         Some(a) => assert_eq!(*a, 5),\n-        None => panic!(\"unexpected None while matching on Some(Arc::new(5))\")\n+        None => panic!(\"unexpected None while matching on Some(Arc::new(5))\"),\n     }\n }\n \n@@ -85,7 +81,7 @@ fn test_match_option_string() {\n     let five = \"Five\".to_string();\n     match Some(five) {\n         Some(s) => assert_eq!(s, \"Five\"),\n-        None => panic!(\"unexpected None while matching on Some(String { ... })\")\n+        None => panic!(\"unexpected None while matching on Some(String { ... })\"),\n     }\n }\n \n@@ -100,15 +96,17 @@ mod atom {\n }\n \n macro_rules! atom {\n-    (\"foo\") => { atom::FOO_ATOM }\n+    (\"foo\") => {\n+        atom::FOO_ATOM\n+    };\n }\n \n #[test]\n fn test_match_nonzero_const_pattern() {\n     match atom!(\"foo\") {\n         // Using as a pattern is supported by the compiler:\n         atom!(\"foo\") => {}\n-        _ => panic!(\"Expected the const item as a pattern to match.\")\n+        _ => panic!(\"Expected the const item as a pattern to match.\"),\n     }\n }\n \n@@ -129,10 +127,7 @@ fn test_from_signed_nonzero() {\n #[test]\n fn test_from_str() {\n     assert_eq!(\"123\".parse::<NonZeroU8>(), Ok(NonZeroU8::new(123).unwrap()));\n-    assert_eq!(\n-        \"0\".parse::<NonZeroU8>().err().map(|e| e.kind().clone()),\n-        Some(IntErrorKind::Zero)\n-    );\n+    assert_eq!(\"0\".parse::<NonZeroU8>().err().map(|e| e.kind().clone()), Some(IntErrorKind::Zero));\n     assert_eq!(\n         \"-1\".parse::<NonZeroU8>().err().map(|e| e.kind().clone()),\n         Some(IntErrorKind::InvalidDigit)"}, {"sha": "1457064cc8d572028374f5e95fda860a605dce53", "filename": "src/libcore/tests/num/bignum.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -70,7 +70,7 @@ fn test_sub_underflow_2() {\n fn test_mul_small() {\n     assert_eq!(*Big::from_small(7).mul_small(5), Big::from_small(35));\n     assert_eq!(*Big::from_small(0xff).mul_small(0xff), Big::from_u64(0xfe01));\n-    assert_eq!(*Big::from_u64(0xffffff/13).mul_small(13), Big::from_u64(0xffffff));\n+    assert_eq!(*Big::from_u64(0xffffff / 13).mul_small(13), Big::from_u64(0xffffff));\n }\n \n #[test]\n@@ -134,7 +134,7 @@ fn test_mul_digits() {\n     assert_eq!(*Big::from_u64(0x123).mul_digits(&[0x56, 0x4]), Big::from_u64(0x4edc2));\n     assert_eq!(*Big::from_u64(0x12345).mul_digits(&[0x67]), Big::from_u64(0x7530c3));\n     assert_eq!(*Big::from_small(0x12).mul_digits(&[0x67, 0x45, 0x3]), Big::from_u64(0x3ae13e));\n-    assert_eq!(*Big::from_u64(0xffffff/13).mul_digits(&[13]), Big::from_u64(0xffffff));\n+    assert_eq!(*Big::from_u64(0xffffff / 13).mul_digits(&[13]), Big::from_u64(0xffffff));\n     assert_eq!(*Big::from_small(13).mul_digits(&[0x3b, 0xb1, 0x13]), Big::from_u64(0xffffff));\n }\n \n@@ -156,10 +156,14 @@ fn test_div_rem_small() {\n     assert_eq!(as_val(Big::from_small(0xff).div_rem_small(15)), (Big::from_small(17), 0));\n     assert_eq!(as_val(Big::from_small(0xff).div_rem_small(16)), (Big::from_small(15), 15));\n     assert_eq!(as_val(Big::from_small(3).div_rem_small(40)), (Big::from_small(0), 3));\n-    assert_eq!(as_val(Big::from_u64(0xffffff).div_rem_small(123)),\n-               (Big::from_u64(0xffffff / 123), (0xffffffu64 % 123) as u8));\n-    assert_eq!(as_val(Big::from_u64(0x10000).div_rem_small(123)),\n-               (Big::from_u64(0x10000 / 123), (0x10000u64 % 123) as u8));\n+    assert_eq!(\n+        as_val(Big::from_u64(0xffffff).div_rem_small(123)),\n+        (Big::from_u64(0xffffff / 123), (0xffffffu64 % 123) as u8)\n+    );\n+    assert_eq!(\n+        as_val(Big::from_u64(0x10000).div_rem_small(123)),\n+        (Big::from_u64(0x10000 / 123), (0x10000u64 % 123) as u8)\n+    );\n }\n \n #[test]"}, {"sha": "6bb348fd752e637aab68d60680a690f9d780bfe9", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,6 +1,6 @@\n #![allow(overflowing_literals)]\n \n-use std::{i64, f32, f64};\n+use std::{f32, f64, i64};\n \n mod parse;\n mod rawfp;\n@@ -9,7 +9,7 @@ mod rawfp;\n // to be correct) and see if those strings are parsed back to the value of the literal.\n // Requires a *polymorphic literal*, i.e., one that can serve as f64 as well as f32.\n macro_rules! test_literal {\n-    ($x: expr) => ({\n+    ($x: expr) => {{\n         let x32: f32 = $x;\n         let x64: f64 = $x;\n         let inputs = &[stringify!($x).into(), format!(\"{:?}\", x64), format!(\"{:e}\", x64)];\n@@ -20,7 +20,7 @@ macro_rules! test_literal {\n             assert_eq!(neg_input.parse(), Ok(-x64));\n             assert_eq!(neg_input.parse(), Ok(-x32));\n         }\n-    })\n+    }};\n }\n \n #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n@@ -31,7 +31,11 @@ fn ordinary() {\n     test_literal!(0.1);\n     test_literal!(12345.);\n     test_literal!(0.9999999);\n-    #[cfg(not(miri))] // Miri is too slow\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     test_literal!(2.2250738585072014e-308);\n }\n \n@@ -53,7 +57,7 @@ fn large() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn subnormals() {\n     test_literal!(5e-324);\n     test_literal!(91e-324);\n@@ -65,7 +69,7 @@ fn subnormals() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn infinity() {\n     test_literal!(1e400);\n     test_literal!(1e309);\n@@ -77,9 +81,12 @@ fn infinity() {\n fn zero() {\n     test_literal!(0.0);\n     test_literal!(1e-325);\n-    #[cfg(not(miri))] // Miri is too slow\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     test_literal!(1e-326);\n-    #[cfg(not(miri))] // Miri is too slow\n     test_literal!(1e-500);\n }\n "}, {"sha": "bb7e51d30026ad1ed087a2196dfc6d29db43e62c", "filename": "src/libcore/tests/num/dec2flt/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,5 +1,5 @@\n-use core::num::dec2flt::parse::{Decimal, parse_decimal};\n-use core::num::dec2flt::parse::ParseResult::{Valid, Invalid};\n+use core::num::dec2flt::parse::ParseResult::{Invalid, Valid};\n+use core::num::dec2flt::parse::{parse_decimal, Decimal};\n \n #[test]\n fn missing_pieces() {"}, {"sha": "665fb6b9efb8c0901a85960593b79750b6eef81e", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,8 +1,8 @@\n+use core::num::dec2flt::rawfp::RawFloat;\n+use core::num::dec2flt::rawfp::{fp_to_float, next_float, prev_float, round_normal};\n+use core::num::diy_float::Fp;\n use std::f32;\n use std::f64;\n-use core::num::diy_float::Fp;\n-use core::num::dec2flt::rawfp::{fp_to_float, prev_float, next_float, round_normal};\n-use core::num::dec2flt::rawfp::RawFloat;\n \n fn integer_decode(f: f64) -> (u64, i16, i8) {\n     RawFloat::integer_decode(f)\n@@ -53,16 +53,23 @@ fn integers_to_f64() {\n     assert_eq!(fp_to_float::<f64>(Fp { f: 4, e: -3 }), 0.5);\n }\n \n-const SOME_FLOATS: [f64; 9] =\n-    [0.1f64, 33.568, 42.1e-5, 777.0e9, 1.1111, 0.347997,\n-     9843579834.35892, 12456.0e-150, 54389573.0e-150];\n-\n+const SOME_FLOATS: [f64; 9] = [\n+    0.1f64,\n+    33.568,\n+    42.1e-5,\n+    777.0e9,\n+    1.1111,\n+    0.347997,\n+    9843579834.35892,\n+    12456.0e-150,\n+    54389573.0e-150,\n+];\n \n #[test]\n fn human_f64_roundtrip() {\n     for &x in &SOME_FLOATS {\n         let (f, e, _) = integer_decode(x);\n-        let fp = Fp { f: f, e: e};\n+        let fp = Fp { f: f, e: e };\n         assert_eq!(fp_to_float::<f64>(fp), x);\n     }\n }"}, {"sha": "8ee06d895cae32011ac0458d76a4ea37568f7bf3", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -3,14 +3,24 @@ use core::num::flt2dec::estimator::*;\n #[test]\n fn test_estimate_scaling_factor() {\n     macro_rules! assert_almost_eq {\n-        ($actual:expr, $expected:expr) => ({\n+        ($actual:expr, $expected:expr) => {{\n             let actual = $actual;\n             let expected = $expected;\n-            println!(\"{} - {} = {} - {} = {}\", stringify!($expected), stringify!($actual),\n-                     expected, actual, expected - actual);\n-            assert!(expected == actual || expected == actual + 1,\n-                    \"expected {}, actual {}\", expected, actual);\n-        })\n+            println!(\n+                \"{} - {} = {} - {} = {}\",\n+                stringify!($expected),\n+                stringify!($actual),\n+                expected,\n+                actual,\n+                expected - actual\n+            );\n+            assert!(\n+                expected == actual || expected == actual + 1,\n+                \"expected {}, actual {}\",\n+                expected,\n+                actual\n+            );\n+        }};\n     }\n \n     assert_almost_eq!(estimate_scaling_factor(1, 0), 0);"}, {"sha": "2f94ea2fc4b70494737f01f8e5eb123fc94805ba", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -256,7 +256,6 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     check_shortest!(f(minf32) => b\"1\", -44);\n }\n \n-#[cfg(not(miri))] // Miri is too slow\n pub fn f32_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     let minf32 = ldexp_f32(1.0, -149);\n@@ -362,7 +361,6 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     check_shortest!(f(minf64) => b\"5\", -323);\n }\n \n-#[cfg(not(miri))] // Miri is too slow\n pub fn f64_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     let minf64 = ldexp_f64(1.0, -1074);"}, {"sha": "ecdfc4b30a59fcdcd1b1fd3bbf761e16a060cd47", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -3,36 +3,43 @@\n use std::i16;\n use std::str;\n \n-use core::num::flt2dec::MAX_SIG_DIGITS;\n use core::num::flt2dec::strategy::grisu::format_exact_opt;\n use core::num::flt2dec::strategy::grisu::format_shortest_opt;\n-use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n+use core::num::flt2dec::MAX_SIG_DIGITS;\n+use core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n \n-use rand::SeedableRng;\n-use rand::rngs::StdRng;\n use rand::distributions::{Distribution, Uniform};\n+use rand::rngs::StdRng;\n+use rand::SeedableRng;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n         FullDecoded::Finite(decoded) => decoded,\n-        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded),\n     }\n }\n \n-\n fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n-              V: FnMut(usize) -> Decoded {\n+where\n+    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    V: FnMut(usize) -> Decoded,\n+{\n     assert!(k <= 1024);\n \n     let mut npassed = 0; // f(x) = Some(g(x))\n     let mut nignored = 0; // f(x) = None\n \n     for i in 0..n {\n         if (i & 0xfffff) == 0 {\n-            println!(\"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n-                     i, n, nignored, npassed, i - nignored - npassed);\n+            println!(\n+                \"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n+                i,\n+                n,\n+                nignored,\n+                npassed,\n+                i - nignored - npassed\n+            );\n         }\n \n         let decoded = v(i);\n@@ -43,27 +50,47 @@ fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V\n             if e1 == e2 && &buf1[..len1] == &buf2[..len2] {\n                 npassed += 1;\n             } else {\n-                println!(\"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n-                         i, n, decoded, str::from_utf8(&buf1[..len1]).unwrap(), e1,\n-                                        str::from_utf8(&buf2[..len2]).unwrap(), e2);\n+                println!(\n+                    \"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n+                    i,\n+                    n,\n+                    decoded,\n+                    str::from_utf8(&buf1[..len1]).unwrap(),\n+                    e1,\n+                    str::from_utf8(&buf2[..len2]).unwrap(),\n+                    e2\n+                );\n             }\n         } else {\n             nignored += 1;\n         }\n     }\n-    println!(\"{}({}): done, ignored={} passed={} failed={}\",\n-             func, k, nignored, npassed, n - nignored - npassed);\n-    assert!(nignored + npassed == n,\n-            \"{}({}): {} out of {} values returns an incorrect value!\",\n-            func, k, n - nignored - npassed, n);\n+    println!(\n+        \"{}({}): done, ignored={} passed={} failed={}\",\n+        func,\n+        k,\n+        nignored,\n+        npassed,\n+        n - nignored - npassed\n+    );\n+    assert!(\n+        nignored + npassed == n,\n+        \"{}({}): {} out of {} values returns an incorrect value!\",\n+        func,\n+        k,\n+        n - nignored - npassed,\n+        n\n+    );\n     (npassed, nignored)\n }\n \n pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+where\n+    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     if cfg!(target_os = \"emscripten\") {\n-        return // using rng pulls in i128 support, which doesn't work\n+        return; // using rng pulls in i128 support, which doesn't work\n     }\n     let mut rng = StdRng::from_entropy();\n     let f32_range = Uniform::new(0x0000_0001u32, 0x7f80_0000);\n@@ -74,10 +101,12 @@ pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n }\n \n pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+where\n+    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     if cfg!(target_os = \"emscripten\") {\n-        return // using rng pulls in i128 support, which doesn't work\n+        return; // using rng pulls in i128 support, which doesn't work\n     }\n     let mut rng = StdRng::from_entropy();\n     let f64_range = Uniform::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n@@ -88,21 +117,22 @@ pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n }\n \n pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+where\n+    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n     // so why not simply testing all of them?\n     //\n     // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n     // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n \n     // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e., all finite ranges\n-    let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n-                                      k, 0x7f7f_ffff, f, g, |i: usize| {\n-\n-        let x = f32::from_bits(i as u32 + 1);\n-        decode_finite(x)\n-    });\n+    let (npassed, nignored) =\n+        iterate(\"f32_exhaustive_equivalence_test\", k, 0x7f7f_ffff, f, g, |i: usize| {\n+            let x = f32::from_bits(i as u32 + 1);\n+            decode_finite(x)\n+        });\n     assert_eq!((npassed, nignored), (2121451881, 17643158));\n }\n \n@@ -118,7 +148,8 @@ fn shortest_random_equivalence_test() {\n     f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, N);\n }\n \n-#[test] #[ignore] // it is too expensive\n+#[test]\n+#[ignore] // it is too expensive\n fn shortest_f32_exhaustive_equivalence_test() {\n     // it is hard to directly test the optimality of the output, but we can at least test if\n     // two different algorithms agree to each other.\n@@ -131,13 +162,13 @@ fn shortest_f32_exhaustive_equivalence_test() {\n     f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n }\n \n-#[test] #[ignore] // it is too expensive\n+#[test]\n+#[ignore] // it is too expensive\n fn shortest_f64_hard_random_equivalence_test() {\n     // this again probably has to use appropriate rustc flags.\n \n     use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f64_random_equivalence_test(format_shortest_opt, fallback,\n-                                         MAX_SIG_DIGITS, 100_000_000);\n+    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 100_000_000);\n }\n \n #[test]\n@@ -149,8 +180,12 @@ fn exact_f32_random_equivalence_test() {\n     const N: usize = 3;\n \n     for k in 1..21 {\n-        f32_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, N);\n+        f32_random_equivalence_test(\n+            |d, buf| format_exact_opt(d, buf, i16::MIN),\n+            |d, buf| fallback(d, buf, i16::MIN),\n+            k,\n+            N,\n+        );\n     }\n }\n \n@@ -163,7 +198,11 @@ fn exact_f64_random_equivalence_test() {\n     const N: usize = 3;\n \n     for k in 1..21 {\n-        f64_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, N);\n+        f64_random_equivalence_test(\n+            |d, buf| format_exact_opt(d, buf, i16::MIN),\n+            |d, buf| fallback(d, buf, i16::MIN),\n+            k,\n+            N,\n+        );\n     }\n }"}, {"sha": "3d985c6796b16908e96c71ba32f9523f9d622282", "filename": "src/libcore/tests/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -22,7 +22,7 @@ fn shortest_sanity_test() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn exact_sanity_test() {\n     // This test ends up running what I can only assume is some corner-ish case\n     // of the `exp2` library function, defined in whatever C runtime we're"}, {"sha": "ff8373c64551b3596e1ba58b80db322e623d3270", "filename": "src/libcore/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -6,12 +6,18 @@ fn test_cached_power() {\n     assert_eq!(CACHED_POW10.first().unwrap().1, CACHED_POW10_FIRST_E);\n     assert_eq!(CACHED_POW10.last().unwrap().1, CACHED_POW10_LAST_E);\n \n-    for e in -1137..961 { // full range for f64\n+    for e in -1137..961 {\n+        // full range for f64\n         let low = ALPHA - e - 64;\n         let high = GAMMA - e - 64;\n         let (_k, cached) = cached_power(low, high);\n-        assert!(low <= cached.e && cached.e <= high,\n-                \"cached_power({}, {}) = {:?} is incorrect\", low, high, cached);\n+        assert!(\n+            low <= cached.e && cached.e <= high,\n+            \"cached_power({}, {}) = {:?} is incorrect\",\n+            low,\n+            high,\n+            cached\n+        );\n     }\n }\n \n@@ -26,7 +32,6 @@ fn test_max_pow10_no_more_than() {\n     }\n }\n \n-\n #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn shortest_sanity_test() {\n@@ -36,7 +41,7 @@ fn shortest_sanity_test() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn exact_sanity_test() {\n     // See comments in dragon.rs's exact_sanity_test for why this test is\n     // ignored on MSVC"}, {"sha": "4a44b5f24b910edab00bdfe7f0472d744f04e5a0", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 239, "deletions": 238, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,240 +1,241 @@\n-macro_rules! int_module { ($T:ident, $T_i:ident) => (\n-#[cfg(test)]\n-mod tests {\n-    use core::$T_i::*;\n-    use core::isize;\n-    use core::ops::{Shl, Shr, Not, BitXor, BitAnd, BitOr};\n-    use core::mem;\n-\n-    use crate::num;\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert_eq!(MIN + MAX + 1, 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_rem_euclid() {\n-        assert_eq!((-1 as $T).rem_euclid(MIN), MAX);\n-    }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert_eq!((1 as $T).abs(), 1 as $T);\n-        assert_eq!((0 as $T).abs(), 0 as $T);\n-        assert_eq!((-1 as $T).abs(), 1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!((1 as $T).signum(), 1 as $T);\n-        assert_eq!((0 as $T).signum(), 0 as $T);\n-        assert_eq!((-0 as $T).signum(), 0 as $T);\n-        assert_eq!((-1 as $T).signum(), -1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!((1 as $T).is_positive());\n-        assert!(!(0 as $T).is_positive());\n-        assert!(!(-0 as $T).is_positive());\n-        assert!(!(-1 as $T).is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!(1 as $T).is_negative());\n-        assert!(!(0 as $T).is_negative());\n-        assert!(!(-0 as $T).is_negative());\n-        assert!((-1 as $T).is_negative());\n-    }\n-\n-    #[test]\n-    fn test_bitwise_operators() {\n-        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(0b1010 as $T));\n-        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(0b1010 as $T));\n-        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(0b1010 as $T));\n-        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(1));\n-        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(1));\n-        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n-    }\n-\n-    const A: $T = 0b0101100;\n-    const B: $T = 0b0100001;\n-    const C: $T = 0b1111001;\n-\n-    const _0: $T = 0;\n-    const _1: $T = !0;\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert_eq!(A.count_ones(), 3);\n-        assert_eq!(B.count_ones(), 2);\n-        assert_eq!(C.count_ones(), 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        let bits = mem::size_of::<$T>() * 8;\n-        assert_eq!(A.count_zeros(), bits as u32 - 3);\n-        assert_eq!(B.count_zeros(), bits as u32 - 2);\n-        assert_eq!(C.count_zeros(), bits as u32 - 5);\n-    }\n-\n-    #[test]\n-    fn test_rotate() {\n-        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n-        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n-        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n-\n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        assert_eq!(_0.rotate_left(124), _0);\n-        assert_eq!(_1.rotate_left(124), _1);\n-        assert_eq!(_0.rotate_right(124), _0);\n-        assert_eq!(_1.rotate_right(124), _1);\n-\n-        // Rotating by 0 should have no effect\n-        assert_eq!(A.rotate_left(0), A);\n-        assert_eq!(B.rotate_left(0), B);\n-        assert_eq!(C.rotate_left(0), C);\n-        // Rotating by a multiple of word size should also have no effect\n-        assert_eq!(A.rotate_left(64), A);\n-        assert_eq!(B.rotate_left(64), B);\n-        assert_eq!(C.rotate_left(64), C);\n-    }\n-\n-    #[test]\n-    fn test_swap_bytes() {\n-        assert_eq!(A.swap_bytes().swap_bytes(), A);\n-        assert_eq!(B.swap_bytes().swap_bytes(), B);\n-        assert_eq!(C.swap_bytes().swap_bytes(), C);\n-\n-        // Swapping these should make no difference\n-        assert_eq!(_0.swap_bytes(), _0);\n-        assert_eq!(_1.swap_bytes(), _1);\n-    }\n-\n-    #[test]\n-    fn test_le() {\n-        assert_eq!($T::from_le(A.to_le()), A);\n-        assert_eq!($T::from_le(B.to_le()), B);\n-        assert_eq!($T::from_le(C.to_le()), C);\n-        assert_eq!($T::from_le(_0), _0);\n-        assert_eq!($T::from_le(_1), _1);\n-        assert_eq!(_0.to_le(), _0);\n-        assert_eq!(_1.to_le(), _1);\n-    }\n-\n-    #[test]\n-    fn test_be() {\n-        assert_eq!($T::from_be(A.to_be()), A);\n-        assert_eq!($T::from_be(B.to_be()), B);\n-        assert_eq!($T::from_be(C.to_be()), C);\n-        assert_eq!($T::from_be(_0), _0);\n-        assert_eq!($T::from_be(_1), _1);\n-        assert_eq!(_0.to_be(), _0);\n-        assert_eq!(_1.to_be(), _1);\n-    }\n-\n-    #[test]\n-    fn test_signed_checked_div() {\n-        assert_eq!((10 as $T).checked_div(2), Some(5));\n-        assert_eq!((5 as $T).checked_div(0), None);\n-        assert_eq!(isize::MIN.checked_div(-1), None);\n-    }\n-\n-    #[test]\n-    fn test_saturating_abs() {\n-        assert_eq!((0 as $T).saturating_abs(), 0);\n-        assert_eq!((123 as $T).saturating_abs(), 123);\n-        assert_eq!((-123 as $T).saturating_abs(), 123);\n-        assert_eq!((MAX - 2).saturating_abs(), MAX - 2);\n-        assert_eq!((MAX - 1).saturating_abs(), MAX - 1);\n-        assert_eq!(MAX.saturating_abs(), MAX);\n-        assert_eq!((MIN + 2).saturating_abs(), MAX - 1);\n-        assert_eq!((MIN + 1).saturating_abs(), MAX);\n-        assert_eq!(MIN.saturating_abs(), MAX);\n-    }\n-\n-    #[test]\n-    fn test_saturating_neg() {\n-        assert_eq!((0 as $T).saturating_neg(), 0);\n-        assert_eq!((123 as $T).saturating_neg(), -123);\n-        assert_eq!((-123 as $T).saturating_neg(), 123);\n-        assert_eq!((MAX - 2).saturating_neg(), MIN + 3);\n-        assert_eq!((MAX - 1).saturating_neg(), MIN + 2);\n-        assert_eq!(MAX.saturating_neg(), MIN + 1);\n-        assert_eq!((MIN + 2).saturating_neg(), MAX - 1);\n-        assert_eq!((MIN + 1).saturating_neg(), MAX);\n-        assert_eq!(MIN.saturating_neg(), MAX);\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        fn from_str<T: ::std::str::FromStr>(t: &str) -> Option<T> {\n-            ::std::str::FromStr::from_str(t).ok()\n+macro_rules! int_module {\n+    ($T:ident, $T_i:ident) => {\n+        #[cfg(test)]\n+        mod tests {\n+            use core::isize;\n+            use core::mem;\n+            use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n+            use core::$T_i::*;\n+\n+            use crate::num;\n+\n+            #[test]\n+            fn test_overflows() {\n+                assert!(MAX > 0);\n+                assert!(MIN <= 0);\n+                assert_eq!(MIN + MAX + 1, 0);\n+            }\n+\n+            #[test]\n+            fn test_num() {\n+                num::test_num(10 as $T, 2 as $T);\n+            }\n+\n+            #[test]\n+            fn test_rem_euclid() {\n+                assert_eq!((-1 as $T).rem_euclid(MIN), MAX);\n+            }\n+\n+            #[test]\n+            pub fn test_abs() {\n+                assert_eq!((1 as $T).abs(), 1 as $T);\n+                assert_eq!((0 as $T).abs(), 0 as $T);\n+                assert_eq!((-1 as $T).abs(), 1 as $T);\n+            }\n+\n+            #[test]\n+            fn test_signum() {\n+                assert_eq!((1 as $T).signum(), 1 as $T);\n+                assert_eq!((0 as $T).signum(), 0 as $T);\n+                assert_eq!((-0 as $T).signum(), 0 as $T);\n+                assert_eq!((-1 as $T).signum(), -1 as $T);\n+            }\n+\n+            #[test]\n+            fn test_is_positive() {\n+                assert!((1 as $T).is_positive());\n+                assert!(!(0 as $T).is_positive());\n+                assert!(!(-0 as $T).is_positive());\n+                assert!(!(-1 as $T).is_positive());\n+            }\n+\n+            #[test]\n+            fn test_is_negative() {\n+                assert!(!(1 as $T).is_negative());\n+                assert!(!(0 as $T).is_negative());\n+                assert!(!(-0 as $T).is_negative());\n+                assert!((-1 as $T).is_negative());\n+            }\n+\n+            #[test]\n+            fn test_bitwise_operators() {\n+                assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(0b1010 as $T));\n+                assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(0b1010 as $T));\n+                assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(0b1010 as $T));\n+                assert_eq!(0b1110 as $T, (0b0111 as $T).shl(1));\n+                assert_eq!(0b0111 as $T, (0b1110 as $T).shr(1));\n+                assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n+            }\n+\n+            const A: $T = 0b0101100;\n+            const B: $T = 0b0100001;\n+            const C: $T = 0b1111001;\n+\n+            const _0: $T = 0;\n+            const _1: $T = !0;\n+\n+            #[test]\n+            fn test_count_ones() {\n+                assert_eq!(A.count_ones(), 3);\n+                assert_eq!(B.count_ones(), 2);\n+                assert_eq!(C.count_ones(), 5);\n+            }\n+\n+            #[test]\n+            fn test_count_zeros() {\n+                let bits = mem::size_of::<$T>() * 8;\n+                assert_eq!(A.count_zeros(), bits as u32 - 3);\n+                assert_eq!(B.count_zeros(), bits as u32 - 2);\n+                assert_eq!(C.count_zeros(), bits as u32 - 5);\n+            }\n+\n+            #[test]\n+            fn test_rotate() {\n+                assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+                assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+                assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+                // Rotating these should make no difference\n+                //\n+                // We test using 124 bits because to ensure that overlong bit shifts do\n+                // not cause undefined behaviour. See #10183.\n+                assert_eq!(_0.rotate_left(124), _0);\n+                assert_eq!(_1.rotate_left(124), _1);\n+                assert_eq!(_0.rotate_right(124), _0);\n+                assert_eq!(_1.rotate_right(124), _1);\n+\n+                // Rotating by 0 should have no effect\n+                assert_eq!(A.rotate_left(0), A);\n+                assert_eq!(B.rotate_left(0), B);\n+                assert_eq!(C.rotate_left(0), C);\n+                // Rotating by a multiple of word size should also have no effect\n+                assert_eq!(A.rotate_left(64), A);\n+                assert_eq!(B.rotate_left(64), B);\n+                assert_eq!(C.rotate_left(64), C);\n+            }\n+\n+            #[test]\n+            fn test_swap_bytes() {\n+                assert_eq!(A.swap_bytes().swap_bytes(), A);\n+                assert_eq!(B.swap_bytes().swap_bytes(), B);\n+                assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+                // Swapping these should make no difference\n+                assert_eq!(_0.swap_bytes(), _0);\n+                assert_eq!(_1.swap_bytes(), _1);\n+            }\n+\n+            #[test]\n+            fn test_le() {\n+                assert_eq!($T::from_le(A.to_le()), A);\n+                assert_eq!($T::from_le(B.to_le()), B);\n+                assert_eq!($T::from_le(C.to_le()), C);\n+                assert_eq!($T::from_le(_0), _0);\n+                assert_eq!($T::from_le(_1), _1);\n+                assert_eq!(_0.to_le(), _0);\n+                assert_eq!(_1.to_le(), _1);\n+            }\n+\n+            #[test]\n+            fn test_be() {\n+                assert_eq!($T::from_be(A.to_be()), A);\n+                assert_eq!($T::from_be(B.to_be()), B);\n+                assert_eq!($T::from_be(C.to_be()), C);\n+                assert_eq!($T::from_be(_0), _0);\n+                assert_eq!($T::from_be(_1), _1);\n+                assert_eq!(_0.to_be(), _0);\n+                assert_eq!(_1.to_be(), _1);\n+            }\n+\n+            #[test]\n+            fn test_signed_checked_div() {\n+                assert_eq!((10 as $T).checked_div(2), Some(5));\n+                assert_eq!((5 as $T).checked_div(0), None);\n+                assert_eq!(isize::MIN.checked_div(-1), None);\n+            }\n+\n+            #[test]\n+            fn test_saturating_abs() {\n+                assert_eq!((0 as $T).saturating_abs(), 0);\n+                assert_eq!((123 as $T).saturating_abs(), 123);\n+                assert_eq!((-123 as $T).saturating_abs(), 123);\n+                assert_eq!((MAX - 2).saturating_abs(), MAX - 2);\n+                assert_eq!((MAX - 1).saturating_abs(), MAX - 1);\n+                assert_eq!(MAX.saturating_abs(), MAX);\n+                assert_eq!((MIN + 2).saturating_abs(), MAX - 1);\n+                assert_eq!((MIN + 1).saturating_abs(), MAX);\n+                assert_eq!(MIN.saturating_abs(), MAX);\n+            }\n+\n+            #[test]\n+            fn test_saturating_neg() {\n+                assert_eq!((0 as $T).saturating_neg(), 0);\n+                assert_eq!((123 as $T).saturating_neg(), -123);\n+                assert_eq!((-123 as $T).saturating_neg(), 123);\n+                assert_eq!((MAX - 2).saturating_neg(), MIN + 3);\n+                assert_eq!((MAX - 1).saturating_neg(), MIN + 2);\n+                assert_eq!(MAX.saturating_neg(), MIN + 1);\n+                assert_eq!((MIN + 2).saturating_neg(), MAX - 1);\n+                assert_eq!((MIN + 1).saturating_neg(), MAX);\n+                assert_eq!(MIN.saturating_neg(), MAX);\n+            }\n+\n+            #[test]\n+            fn test_from_str() {\n+                fn from_str<T: ::std::str::FromStr>(t: &str) -> Option<T> {\n+                    ::std::str::FromStr::from_str(t).ok()\n+                }\n+                assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n+                assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n+                assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n+                assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n+                assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n+\n+                assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n+                assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n+                assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n+                assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n+                assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n+\n+                assert_eq!(from_str::<$T>(\"\"), None);\n+                assert_eq!(from_str::<$T>(\" \"), None);\n+                assert_eq!(from_str::<$T>(\"x\"), None);\n+            }\n+\n+            #[test]\n+            fn test_from_str_radix() {\n+                assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+                assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+                assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+                assert_eq!(i32::from_str_radix(\"123\", 16), Ok(291 as i32));\n+                assert_eq!(i32::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n+                assert_eq!(i32::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n+                assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+                assert_eq!($T::from_str_radix(\"Z\", 36), Ok(35 as $T));\n+\n+                assert_eq!($T::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n+                assert_eq!($T::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n+                assert_eq!($T::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n+                assert_eq!(i32::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n+                assert_eq!(i32::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n+                assert_eq!(i32::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n+                assert_eq!($T::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n+                assert_eq!($T::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n+\n+                assert_eq!($T::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n+                assert_eq!($T::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n+            }\n+\n+            #[test]\n+            fn test_pow() {\n+                let mut r = 2 as $T;\n+\n+                assert_eq!(r.pow(2), 4 as $T);\n+                assert_eq!(r.pow(0), 1 as $T);\n+                r = -2 as $T;\n+                assert_eq!(r.pow(2), 4 as $T);\n+                assert_eq!(r.pow(3), -8 as $T);\n+            }\n         }\n-        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n-        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n-        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n-        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n-        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n-        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n-        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"\"), None);\n-        assert_eq!(from_str::<$T>(\" \"), None);\n-        assert_eq!(from_str::<$T>(\"x\"), None);\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(i32::from_str_radix(\"123\", 16), Ok(291 as i32));\n-        assert_eq!(i32::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n-        assert_eq!(i32::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n-        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n-        assert_eq!($T::from_str_radix(\"Z\", 36), Ok(35 as $T));\n-\n-        assert_eq!($T::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n-        assert_eq!($T::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n-        assert_eq!($T::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n-        assert_eq!(i32::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n-        assert_eq!(i32::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n-        assert_eq!(i32::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n-        assert_eq!($T::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n-        assert_eq!($T::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n-\n-        assert_eq!($T::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n-        assert_eq!($T::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n-    }\n-\n-    #[test]\n-    fn test_pow() {\n-        let mut r = 2 as $T;\n-\n-        assert_eq!(r.pow(2), 4 as $T);\n-        assert_eq!(r.pow(0), 1 as $T);\n-        r = -2 as $T;\n-        assert_eq!(r.pow(2), 4 as $T);\n-        assert_eq!(r.pow(3), -8 as $T);\n-    }\n+    };\n }\n-\n-)}"}, {"sha": "f94b2f56bbbecec52e41ef95699b5308e640f660", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 161, "deletions": 159, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,160 +1,162 @@\n-macro_rules! uint_module { ($T:ident, $T_i:ident) => (\n-#[cfg(test)]\n-mod tests {\n-    use core::$T_i::*;\n-    use core::ops::{BitOr, BitAnd, BitXor, Shl, Shr, Not};\n-    use std::str::FromStr;\n-    use std::mem;\n-\n-    use crate::num;\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert!((MIN + MAX).wrapping_add(1) == 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(0b1010 as $T));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(0b1010 as $T));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(0b1010 as $T));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(1));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(1));\n-        assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n-    }\n-\n-    const A: $T = 0b0101100;\n-    const B: $T = 0b0100001;\n-    const C: $T = 0b1111001;\n-\n-    const _0: $T = 0;\n-    const _1: $T = !0;\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert!(A.count_ones() == 3);\n-        assert!(B.count_ones() == 2);\n-        assert!(C.count_ones() == 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        let bits = mem::size_of::<$T>() * 8;\n-        assert!(A.count_zeros() == bits as u32 - 3);\n-        assert!(B.count_zeros() == bits as u32 - 2);\n-        assert!(C.count_zeros() == bits as u32 - 5);\n-    }\n-\n-    #[test]\n-    fn test_rotate() {\n-        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n-        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n-        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n-\n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        assert_eq!(_0.rotate_left(124), _0);\n-        assert_eq!(_1.rotate_left(124), _1);\n-        assert_eq!(_0.rotate_right(124), _0);\n-        assert_eq!(_1.rotate_right(124), _1);\n-\n-        // Rotating by 0 should have no effect\n-        assert_eq!(A.rotate_left(0), A);\n-        assert_eq!(B.rotate_left(0), B);\n-        assert_eq!(C.rotate_left(0), C);\n-        // Rotating by a multiple of word size should also have no effect\n-        assert_eq!(A.rotate_left(64), A);\n-        assert_eq!(B.rotate_left(64), B);\n-        assert_eq!(C.rotate_left(64), C);\n-    }\n-\n-    #[test]\n-    fn test_swap_bytes() {\n-        assert_eq!(A.swap_bytes().swap_bytes(), A);\n-        assert_eq!(B.swap_bytes().swap_bytes(), B);\n-        assert_eq!(C.swap_bytes().swap_bytes(), C);\n-\n-        // Swapping these should make no difference\n-        assert_eq!(_0.swap_bytes(), _0);\n-        assert_eq!(_1.swap_bytes(), _1);\n-    }\n-\n-    #[test]\n-    fn test_reverse_bits() {\n-        assert_eq!(A.reverse_bits().reverse_bits(), A);\n-        assert_eq!(B.reverse_bits().reverse_bits(), B);\n-        assert_eq!(C.reverse_bits().reverse_bits(), C);\n-\n-        // Swapping these should make no difference\n-        assert_eq!(_0.reverse_bits(), _0);\n-        assert_eq!(_1.reverse_bits(), _1);\n-    }\n-\n-    #[test]\n-    fn test_le() {\n-        assert_eq!($T::from_le(A.to_le()), A);\n-        assert_eq!($T::from_le(B.to_le()), B);\n-        assert_eq!($T::from_le(C.to_le()), C);\n-        assert_eq!($T::from_le(_0), _0);\n-        assert_eq!($T::from_le(_1), _1);\n-        assert_eq!(_0.to_le(), _0);\n-        assert_eq!(_1.to_le(), _1);\n-    }\n-\n-    #[test]\n-    fn test_be() {\n-        assert_eq!($T::from_be(A.to_be()), A);\n-        assert_eq!($T::from_be(B.to_be()), B);\n-        assert_eq!($T::from_be(C.to_be()), C);\n-        assert_eq!($T::from_be(_0), _0);\n-        assert_eq!($T::from_be(_1), _1);\n-        assert_eq!(_0.to_be(), _0);\n-        assert_eq!(_1.to_be(), _1);\n-    }\n-\n-    #[test]\n-    fn test_unsigned_checked_div() {\n-        assert!((10 as $T).checked_div(2) == Some(5));\n-        assert!((5 as $T).checked_div(0) == None);\n-    }\n-\n-    fn from_str<T: FromStr>(t: &str) -> Option<T> {\n-        FromStr::from_str(t).ok()\n-    }\n-\n-    #[test]\n-    pub fn test_from_str() {\n-        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n-        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n-        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n-        assert_eq!(from_str::<u32>(\"123456789\"), Some(123456789 as u32));\n-        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"\"), None);\n-        assert_eq!(from_str::<$T>(\" \"), None);\n-        assert_eq!(from_str::<$T>(\"x\"), None);\n-    }\n-\n-    #[test]\n-    pub fn test_parse_bytes() {\n-        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(u16::from_str_radix(\"123\", 16), Ok(291 as u16));\n-        assert_eq!(u16::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n-        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n-\n-        assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n-        assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n-    }\n+macro_rules! uint_module {\n+    ($T:ident, $T_i:ident) => {\n+        #[cfg(test)]\n+        mod tests {\n+            use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n+            use core::$T_i::*;\n+            use std::mem;\n+            use std::str::FromStr;\n+\n+            use crate::num;\n+\n+            #[test]\n+            fn test_overflows() {\n+                assert!(MAX > 0);\n+                assert!(MIN <= 0);\n+                assert!((MIN + MAX).wrapping_add(1) == 0);\n+            }\n+\n+            #[test]\n+            fn test_num() {\n+                num::test_num(10 as $T, 2 as $T);\n+            }\n+\n+            #[test]\n+            fn test_bitwise_operators() {\n+                assert!(0b1110 as $T == (0b1100 as $T).bitor(0b1010 as $T));\n+                assert!(0b1000 as $T == (0b1100 as $T).bitand(0b1010 as $T));\n+                assert!(0b0110 as $T == (0b1100 as $T).bitxor(0b1010 as $T));\n+                assert!(0b1110 as $T == (0b0111 as $T).shl(1));\n+                assert!(0b0111 as $T == (0b1110 as $T).shr(1));\n+                assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n+            }\n+\n+            const A: $T = 0b0101100;\n+            const B: $T = 0b0100001;\n+            const C: $T = 0b1111001;\n+\n+            const _0: $T = 0;\n+            const _1: $T = !0;\n+\n+            #[test]\n+            fn test_count_ones() {\n+                assert!(A.count_ones() == 3);\n+                assert!(B.count_ones() == 2);\n+                assert!(C.count_ones() == 5);\n+            }\n+\n+            #[test]\n+            fn test_count_zeros() {\n+                let bits = mem::size_of::<$T>() * 8;\n+                assert!(A.count_zeros() == bits as u32 - 3);\n+                assert!(B.count_zeros() == bits as u32 - 2);\n+                assert!(C.count_zeros() == bits as u32 - 5);\n+            }\n+\n+            #[test]\n+            fn test_rotate() {\n+                assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+                assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+                assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+                // Rotating these should make no difference\n+                //\n+                // We test using 124 bits because to ensure that overlong bit shifts do\n+                // not cause undefined behaviour. See #10183.\n+                assert_eq!(_0.rotate_left(124), _0);\n+                assert_eq!(_1.rotate_left(124), _1);\n+                assert_eq!(_0.rotate_right(124), _0);\n+                assert_eq!(_1.rotate_right(124), _1);\n+\n+                // Rotating by 0 should have no effect\n+                assert_eq!(A.rotate_left(0), A);\n+                assert_eq!(B.rotate_left(0), B);\n+                assert_eq!(C.rotate_left(0), C);\n+                // Rotating by a multiple of word size should also have no effect\n+                assert_eq!(A.rotate_left(64), A);\n+                assert_eq!(B.rotate_left(64), B);\n+                assert_eq!(C.rotate_left(64), C);\n+            }\n+\n+            #[test]\n+            fn test_swap_bytes() {\n+                assert_eq!(A.swap_bytes().swap_bytes(), A);\n+                assert_eq!(B.swap_bytes().swap_bytes(), B);\n+                assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+                // Swapping these should make no difference\n+                assert_eq!(_0.swap_bytes(), _0);\n+                assert_eq!(_1.swap_bytes(), _1);\n+            }\n+\n+            #[test]\n+            fn test_reverse_bits() {\n+                assert_eq!(A.reverse_bits().reverse_bits(), A);\n+                assert_eq!(B.reverse_bits().reverse_bits(), B);\n+                assert_eq!(C.reverse_bits().reverse_bits(), C);\n+\n+                // Swapping these should make no difference\n+                assert_eq!(_0.reverse_bits(), _0);\n+                assert_eq!(_1.reverse_bits(), _1);\n+            }\n+\n+            #[test]\n+            fn test_le() {\n+                assert_eq!($T::from_le(A.to_le()), A);\n+                assert_eq!($T::from_le(B.to_le()), B);\n+                assert_eq!($T::from_le(C.to_le()), C);\n+                assert_eq!($T::from_le(_0), _0);\n+                assert_eq!($T::from_le(_1), _1);\n+                assert_eq!(_0.to_le(), _0);\n+                assert_eq!(_1.to_le(), _1);\n+            }\n+\n+            #[test]\n+            fn test_be() {\n+                assert_eq!($T::from_be(A.to_be()), A);\n+                assert_eq!($T::from_be(B.to_be()), B);\n+                assert_eq!($T::from_be(C.to_be()), C);\n+                assert_eq!($T::from_be(_0), _0);\n+                assert_eq!($T::from_be(_1), _1);\n+                assert_eq!(_0.to_be(), _0);\n+                assert_eq!(_1.to_be(), _1);\n+            }\n+\n+            #[test]\n+            fn test_unsigned_checked_div() {\n+                assert!((10 as $T).checked_div(2) == Some(5));\n+                assert!((5 as $T).checked_div(0) == None);\n+            }\n+\n+            fn from_str<T: FromStr>(t: &str) -> Option<T> {\n+                FromStr::from_str(t).ok()\n+            }\n+\n+            #[test]\n+            pub fn test_from_str() {\n+                assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n+                assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n+                assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n+                assert_eq!(from_str::<u32>(\"123456789\"), Some(123456789 as u32));\n+                assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n+\n+                assert_eq!(from_str::<$T>(\"\"), None);\n+                assert_eq!(from_str::<$T>(\" \"), None);\n+                assert_eq!(from_str::<$T>(\"x\"), None);\n+            }\n+\n+            #[test]\n+            pub fn test_parse_bytes() {\n+                assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+                assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+                assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+                assert_eq!(u16::from_str_radix(\"123\", 16), Ok(291 as u16));\n+                assert_eq!(u16::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n+                assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+\n+                assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n+                assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n+            }\n+        }\n+    };\n }\n-)}"}, {"sha": "43eb498d26ab19209144fe40461d33dd87e12f7a", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,4 +1,4 @@\n-use core::ops::{Bound, Range, RangeFull, RangeFrom, RangeTo, RangeInclusive};\n+use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo};\n \n // Test the Range structs without the syntactic sugar.\n \n@@ -59,28 +59,27 @@ fn test_range_inclusive() {\n     assert_eq!(r.next(), None);\n }\n \n-\n #[test]\n fn test_range_is_empty() {\n     use core::f32::*;\n \n-    assert!(!(0.0 .. 10.0).is_empty());\n-    assert!( (-0.0 .. 0.0).is_empty());\n-    assert!( (10.0 .. 0.0).is_empty());\n+    assert!(!(0.0..10.0).is_empty());\n+    assert!((-0.0..0.0).is_empty());\n+    assert!((10.0..0.0).is_empty());\n \n-    assert!(!(NEG_INFINITY .. INFINITY).is_empty());\n-    assert!( (EPSILON .. NAN).is_empty());\n-    assert!( (NAN .. EPSILON).is_empty());\n-    assert!( (NAN .. NAN).is_empty());\n+    assert!(!(NEG_INFINITY..INFINITY).is_empty());\n+    assert!((EPSILON..NAN).is_empty());\n+    assert!((NAN..EPSILON).is_empty());\n+    assert!((NAN..NAN).is_empty());\n \n-    assert!(!(0.0 ..= 10.0).is_empty());\n-    assert!(!(-0.0 ..= 0.0).is_empty());\n-    assert!( (10.0 ..= 0.0).is_empty());\n+    assert!(!(0.0..=10.0).is_empty());\n+    assert!(!(-0.0..=0.0).is_empty());\n+    assert!((10.0..=0.0).is_empty());\n \n-    assert!(!(NEG_INFINITY ..= INFINITY).is_empty());\n-    assert!( (EPSILON ..= NAN).is_empty());\n-    assert!( (NAN ..= EPSILON).is_empty());\n-    assert!( (NAN ..= NAN).is_empty());\n+    assert!(!(NEG_INFINITY..=INFINITY).is_empty());\n+    assert!((EPSILON..=NAN).is_empty());\n+    assert!((NAN..=EPSILON).is_empty());\n+    assert!((NAN..=NAN).is_empty());\n }\n \n #[test]"}, {"sha": "fa308160fc228e23e17b535ea9c15ba7b312cf3f", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,8 +1,8 @@\n-use core::option::*;\n-use core::mem;\n-use core::clone::Clone;\n use core::array::FixedSizeArray;\n+use core::clone::Clone;\n+use core::mem;\n use core::ops::DerefMut;\n+use core::option::*;\n \n #[test]\n fn test_get_ptr() {\n@@ -28,25 +28,23 @@ fn test_get_str() {\n \n #[test]\n fn test_get_resource() {\n-    use std::rc::Rc;\n     use core::cell::RefCell;\n+    use std::rc::Rc;\n \n     struct R {\n-       i: Rc<RefCell<isize>>,\n+        i: Rc<RefCell<isize>>,\n     }\n \n-        impl Drop for R {\n-       fn drop(&mut self) {\n+    impl Drop for R {\n+        fn drop(&mut self) {\n             let ii = &*self.i;\n             let i = *ii.borrow();\n             *ii.borrow_mut() = i + 1;\n         }\n     }\n \n     fn r(i: Rc<RefCell<isize>>) -> R {\n-        R {\n-            i,\n-        }\n+        R { i }\n     }\n \n     let i = Rc::new(RefCell::new(0));\n@@ -70,7 +68,8 @@ fn test_option_dance() {\n     assert!(y.is_none());\n }\n \n-#[test] #[should_panic]\n+#[test]\n+#[should_panic]\n fn test_option_too_much_dance() {\n     struct A;\n     let mut y = Some(A);\n@@ -210,7 +209,7 @@ fn test_mut_iter() {\n fn test_ord() {\n     let small = Some(1.0f64);\n     let big = Some(5.0f64);\n-    let nan = Some(0.0f64/0.0);\n+    let nan = Some(0.0f64 / 0.0);\n     assert!(!(nan < big));\n     assert!(!(nan > big));\n     assert!(small < big);\n@@ -226,9 +225,7 @@ fn test_collect() {\n     let v: Option<Vec<isize>> = (0..3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<isize>> = (0..3).map(|x| {\n-        if x > 1 { None } else { Some(x) }\n-    }).collect();\n+    let v: Option<Vec<isize>> = (0..3).map(|x| if x > 1 { None } else { Some(x) }).collect();\n     assert!(v == None);\n \n     // test that it does not take more elements than it needs"}, {"sha": "eea736bc88f013c9214956487180c86798fa77e0", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,22 +1,22 @@\n-use core::ptr::*;\n use core::cell::RefCell;\n+use core::ptr::*;\n \n #[test]\n fn test() {\n     unsafe {\n         struct Pair {\n             fst: isize,\n-            snd: isize\n+            snd: isize,\n         };\n-        let mut p = Pair {fst: 10, snd: 20};\n+        let mut p = Pair { fst: 10, snd: 20 };\n         let pptr: *mut Pair = &mut p;\n         let iptr: *mut isize = pptr as *mut isize;\n         assert_eq!(*iptr, 10);\n         *iptr = 30;\n         assert_eq!(*iptr, 30);\n         assert_eq!(p.fst, 30);\n \n-        *pptr = Pair {fst: 50, snd: 60};\n+        *pptr = Pair { fst: 50, snd: 60 };\n         assert_eq!(*iptr, 50);\n         assert_eq!(p.fst, 50);\n         assert_eq!(p.snd, 60);\n@@ -25,17 +25,11 @@ fn test() {\n         let mut v1 = vec![0u16, 0u16, 0u16];\n \n         copy(v0.as_ptr().offset(1), v1.as_mut_ptr().offset(1), 1);\n-        assert!((v1[0] == 0u16 &&\n-                 v1[1] == 32001u16 &&\n-                 v1[2] == 0u16));\n+        assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n         copy(v0.as_ptr().offset(2), v1.as_mut_ptr(), 1);\n-        assert!((v1[0] == 32002u16 &&\n-                 v1[1] == 32001u16 &&\n-                 v1[2] == 0u16));\n+        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n         copy(v0.as_ptr(), v1.as_mut_ptr().offset(2), 1);\n-        assert!((v1[0] == 32002u16 &&\n-                 v1[1] == 32001u16 &&\n-                 v1[2] == 32000u16));\n+        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16));\n     }\n }\n \n@@ -208,7 +202,7 @@ fn test_ptr_addition() {\n #[test]\n fn test_ptr_subtraction() {\n     unsafe {\n-        let xs = vec![0,1,2,3,4,5,6,7,8,9];\n+        let xs = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n         let mut idx = 9;\n         let ptr = xs.as_ptr();\n \n@@ -229,15 +223,17 @@ fn test_ptr_subtraction() {\n             m_ptr = m_ptr.offset(-1);\n         }\n \n-        assert_eq!(xs_mut, [0,2,4,6,8,10,12,14,16,18]);\n+        assert_eq!(xs_mut, [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]);\n     }\n }\n \n #[test]\n fn test_set_memory() {\n     let mut xs = [0u8; 20];\n     let ptr = xs.as_mut_ptr();\n-    unsafe { write_bytes(ptr, 5u8, xs.len()); }\n+    unsafe {\n+        write_bytes(ptr, 5u8, xs.len());\n+    }\n     assert!(xs == [5u8; 20]);\n }\n \n@@ -257,10 +253,10 @@ fn test_unsized_nonnull() {\n #[no_mangle]\n pub fn test_variadic_fnptr() {\n     use core::hash::{Hash, SipHasher};\n-    extern {\n+    extern \"C\" {\n         fn test_variadic_fnptr(_: u64, ...) -> f64;\n     }\n-    let p: unsafe extern fn(u64, ...) -> f64 = test_variadic_fnptr;\n+    let p: unsafe extern \"C\" fn(u64, ...) -> f64 = test_variadic_fnptr;\n     let q = p.clone();\n     assert_eq!(p, q);\n     assert!(!(p < q));\n@@ -285,13 +281,15 @@ fn write_unaligned_drop() {\n     {\n         let c = Dropper(0);\n         let mut t = Dropper(1);\n-        unsafe { write_unaligned(&mut t, c); }\n+        unsafe {\n+            write_unaligned(&mut t, c);\n+        }\n     }\n     DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n+#[cfg_attr(miri, ignore)] // Miri does not compute a maximal `mid` for `align_offset`\n fn align_offset_zst() {\n     // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n     // all, because no amount of elements will align the pointer.\n@@ -306,24 +304,29 @@ fn align_offset_zst() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n+#[cfg_attr(miri, ignore)] // Miri does not compute a maximal `mid` for `align_offset`\n fn align_offset_stride1() {\n     // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n     // number of bytes.\n     let mut align = 1;\n     while align < 1024 {\n-        for ptr in 1..2*align {\n+        for ptr in 1..2 * align {\n             let expected = ptr % align;\n             let offset = if expected == 0 { 0 } else { align - expected };\n-            assert_eq!((ptr as *const u8).align_offset(align), offset,\n-            \"ptr = {}, align = {}, size = 1\", ptr, align);\n+            assert_eq!(\n+                (ptr as *const u8).align_offset(align),\n+                offset,\n+                \"ptr = {}, align = {}, size = 1\",\n+                ptr,\n+                align\n+            );\n         }\n         align = (align + 1).next_power_of_two();\n     }\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn align_offset_weird_strides() {\n     #[repr(packed)]\n     struct A3(u16, u8);\n@@ -353,8 +356,14 @@ fn align_offset_weird_strides() {\n         }\n         let got = ptr.align_offset(align);\n         if got != expected {\n-            eprintln!(\"aligning {:p} (with stride of {}) to {}, expected {}, got {}\", ptr,\n-                      ::std::mem::size_of::<T>(), align, expected, got);\n+            eprintln!(\n+                \"aligning {:p} (with stride of {}) to {}, expected {}, got {}\",\n+                ptr,\n+                ::std::mem::size_of::<T>(),\n+                align,\n+                expected,\n+                got\n+            );\n             return true;\n         }\n         return false;\n@@ -365,7 +374,7 @@ fn align_offset_weird_strides() {\n     let mut align = 1;\n     let mut x = false;\n     while align < 1024 {\n-        for ptr in 1usize..4*align {\n+        for ptr in 1usize..4 * align {\n             unsafe {\n                 x |= test_weird_stride::<A3>(ptr as *const A3, align);\n                 x |= test_weird_stride::<A4>(ptr as *const A4, align);"}, {"sha": "cc274b4aecf54e24e50b447560cdfb97558f550b", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 73, "deletions": 46, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,4 +1,4 @@\n-use core::result::Result::{Ok, Err};\n+use core::result::Result::{Err, Ok};\n \n #[test]\n fn test_position() {\n@@ -50,8 +50,14 @@ fn test_binary_search() {\n     assert_eq!(b.binary_search(&0), Err(0));\n     assert_eq!(b.binary_search(&1), Ok(0));\n     assert_eq!(b.binary_search(&2), Err(1));\n-    assert!(match b.binary_search(&3) { Ok(1..=3) => true, _ => false });\n-    assert!(match b.binary_search(&3) { Ok(1..=3) => true, _ => false });\n+    assert!(match b.binary_search(&3) {\n+        Ok(1..=3) => true,\n+        _ => false,\n+    });\n+    assert!(match b.binary_search(&3) {\n+        Ok(1..=3) => true,\n+        _ => false,\n+    });\n     assert_eq!(b.binary_search(&4), Err(4));\n     assert_eq!(b.binary_search(&5), Err(4));\n     assert_eq!(b.binary_search(&6), Err(4));\n@@ -187,7 +193,8 @@ fn test_chunks_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    let res = v1.chunks(2)\n+    let res = v1\n+        .chunks(2)\n         .zip(v2.chunks(2))\n         .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n         .collect::<Vec<_>>();\n@@ -339,7 +346,8 @@ fn test_chunks_exact_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    let res = v1.chunks_exact(2)\n+    let res = v1\n+        .chunks_exact(2)\n         .zip(v2.chunks_exact(2))\n         .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n         .collect::<Vec<_>>();\n@@ -482,7 +490,8 @@ fn test_rchunks_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    let res = v1.rchunks(2)\n+    let res = v1\n+        .rchunks(2)\n         .zip(v2.rchunks(2))\n         .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n         .collect::<Vec<_>>();\n@@ -619,7 +628,8 @@ fn test_rchunks_exact_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    let res = v1.rchunks_exact(2)\n+    let res = v1\n+        .rchunks_exact(2)\n         .zip(v2.rchunks_exact(2))\n         .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n         .collect::<Vec<_>>();\n@@ -756,7 +766,8 @@ fn test_windows_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    let res = v1.windows(2)\n+    let res = v1\n+        .windows(2)\n         .zip(v2.windows(2))\n         .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n         .collect::<Vec<_>>();\n@@ -769,11 +780,11 @@ fn test_windows_zip() {\n fn test_iter_ref_consistency() {\n     use std::fmt::Debug;\n \n-    fn test<T : Copy + Debug + PartialEq>(x : T) {\n-        let v : &[T] = &[x, x, x];\n-        let v_ptrs : [*const T; 3] = match v {\n+    fn test<T: Copy + Debug + PartialEq>(x: T) {\n+        let v: &[T] = &[x, x, x];\n+        let v_ptrs: [*const T; 3] = match v {\n             [ref v1, ref v2, ref v3] => [v1 as *const _, v2 as *const _, v3 as *const _],\n-            _ => unreachable!()\n+            _ => unreachable!(),\n         };\n         let len = v.len();\n \n@@ -817,19 +828,20 @@ fn test_iter_ref_consistency() {\n                 assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n \n                 let prev = it.next_back().unwrap();\n-                assert_eq!(prev as *const _, v_ptrs[remaining-1]);\n+                assert_eq!(prev as *const _, v_ptrs[remaining - 1]);\n             }\n             assert_eq!(it.size_hint(), (0, Some(0)));\n             assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n         }\n     }\n \n-    fn test_mut<T : Copy + Debug + PartialEq>(x : T) {\n-        let v : &mut [T] = &mut [x, x, x];\n-        let v_ptrs : [*mut T; 3] = match v {\n-            [ref v1, ref v2, ref v3] =>\n-              [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _],\n-            _ => unreachable!()\n+    fn test_mut<T: Copy + Debug + PartialEq>(x: T) {\n+        let v: &mut [T] = &mut [x, x, x];\n+        let v_ptrs: [*mut T; 3] = match v {\n+            [ref v1, ref v2, ref v3] => {\n+                [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _]\n+            }\n+            _ => unreachable!(),\n         };\n         let len = v.len();\n \n@@ -873,7 +885,7 @@ fn test_iter_ref_consistency() {\n                 assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n \n                 let prev = it.next_back().unwrap();\n-                assert_eq!(prev as *mut _, v_ptrs[remaining-1]);\n+                assert_eq!(prev as *mut _, v_ptrs[remaining - 1]);\n             }\n             assert_eq!(it.size_hint(), (0, Some(0)));\n             assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n@@ -897,8 +909,7 @@ mod slice_index {\n     // This checks all six indexing methods, given an input range that\n     // should succeed. (it is NOT suitable for testing invalid inputs)\n     macro_rules! assert_range_eq {\n-        ($arr:expr, $range:expr, $expected:expr)\n-        => {\n+        ($arr:expr, $range:expr, $expected:expr) => {\n             let mut arr = $arr;\n             let mut expected = $expected;\n             {\n@@ -909,7 +920,8 @@ mod slice_index {\n                 assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n                 unsafe {\n                     assert_eq!(\n-                        s.get_unchecked($range), expected,\n+                        s.get_unchecked($range),\n+                        expected,\n                         \"(in assertion for: get_unchecked)\",\n                     );\n                 }\n@@ -918,22 +930,21 @@ mod slice_index {\n                 let s: &mut [_] = &mut arr;\n                 let expected: &mut [_] = &mut expected;\n \n+                assert_eq!(&mut s[$range], expected, \"(in assertion for: index_mut)\",);\n                 assert_eq!(\n-                    &mut s[$range], expected,\n-                    \"(in assertion for: index_mut)\",\n-                );\n-                assert_eq!(\n-                    s.get_mut($range), Some(&mut expected[..]),\n+                    s.get_mut($range),\n+                    Some(&mut expected[..]),\n                     \"(in assertion for: get_mut)\",\n                 );\n                 unsafe {\n                     assert_eq!(\n-                        s.get_unchecked_mut($range), expected,\n+                        s.get_unchecked_mut($range),\n+                        expected,\n                         \"(in assertion for: get_unchecked_mut)\",\n                     );\n                 }\n             }\n-        }\n+        };\n     }\n \n     // Make sure the macro can actually detect bugs,\n@@ -1126,8 +1137,8 @@ fn test_find_rfind() {\n #[test]\n fn test_iter_folds() {\n     let a = [1, 2, 3, 4, 5]; // len>4 so the unroll is used\n-    assert_eq!(a.iter().fold(0, |acc, &x| 2*acc + x), 57);\n-    assert_eq!(a.iter().rfold(0, |acc, &x| 2*acc + x), 129);\n+    assert_eq!(a.iter().fold(0, |acc, &x| 2 * acc + x), 57);\n+    assert_eq!(a.iter().rfold(0, |acc, &x| 2 * acc + x), 129);\n     let fold = |acc: i32, &x| acc.checked_mul(2)?.checked_add(x);\n     assert_eq!(a.iter().try_fold(0, &fold), Some(57));\n     assert_eq!(a.iter().try_rfold(0, &fold), Some(129));\n@@ -1172,7 +1183,7 @@ fn test_rotate_right() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn brute_force_rotate_test_0() {\n     // In case of edge cases involving multiple algorithms\n     let n = 300;\n@@ -1214,7 +1225,7 @@ fn brute_force_rotate_test_1() {\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n-    use rand::{SeedableRng, Rng, rngs::StdRng, seq::SliceRandom};\n+    use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n \n     #[cfg(not(miri))] // Miri is too slow\n     let large_range = 500..510;\n@@ -1291,12 +1302,12 @@ fn sort_unstable() {\n \n #[test]\n #[cfg(not(target_arch = \"wasm32\"))]\n-#[cfg(not(miri))] // Miri is too slow\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn partition_at_index() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use rand::rngs::StdRng;\n     use rand::seq::SliceRandom;\n-    use rand::{SeedableRng, Rng};\n+    use rand::{Rng, SeedableRng};\n \n     let mut rng = StdRng::from_entropy();\n \n@@ -1494,7 +1505,7 @@ pub mod memchr {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n+#[cfg_attr(miri, ignore)] // Miri does not compute a maximal `mid` for `align_offset`\n fn test_align_to_simple() {\n     let bytes = [1u8, 2, 3, 4, 5, 6, 7];\n     let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u16>() };\n@@ -1504,9 +1515,15 @@ fn test_align_to_simple() {\n     let expect2 = [1 | 2 << 8, 3 | 4 << 8, 5 | 6 << 8];\n     let expect3 = [2 << 8 | 3, 4 << 8 | 5, 6 << 8 | 7];\n     let expect4 = [2 | 3 << 8, 4 | 5 << 8, 6 | 7 << 8];\n-    assert!(aligned == expect1 || aligned == expect2 || aligned == expect3 || aligned == expect4,\n-            \"aligned={:?} expected={:?} || {:?} || {:?} || {:?}\",\n-            aligned, expect1, expect2, expect3, expect4);\n+    assert!(\n+        aligned == expect1 || aligned == expect2 || aligned == expect3 || aligned == expect4,\n+        \"aligned={:?} expected={:?} || {:?} || {:?} || {:?}\",\n+        aligned,\n+        expect1,\n+        expect2,\n+        expect3,\n+        expect4\n+    );\n }\n \n #[test]\n@@ -1518,12 +1535,22 @@ fn test_align_to_zst() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n+#[cfg_attr(miri, ignore)] // Miri does not compute a maximal `mid` for `align_offset`\n fn test_align_to_non_trivial() {\n-    #[repr(align(8))] struct U64(u64, u64);\n-    #[repr(align(8))] struct U64U64U32(u64, u64, u32);\n-    let data = [U64(1, 2), U64(3, 4), U64(5, 6), U64(7, 8), U64(9, 10), U64(11, 12), U64(13, 14),\n-                U64(15, 16)];\n+    #[repr(align(8))]\n+    struct U64(u64, u64);\n+    #[repr(align(8))]\n+    struct U64U64U32(u64, u64, u32);\n+    let data = [\n+        U64(1, 2),\n+        U64(3, 4),\n+        U64(5, 6),\n+        U64(7, 8),\n+        U64(9, 10),\n+        U64(11, 12),\n+        U64(13, 14),\n+        U64(15, 16),\n+    ];\n     let (prefix, aligned, suffix) = unsafe { data.align_to::<U64U64U32>() };\n     assert_eq!(aligned.len(), 4);\n     assert_eq!(prefix.len() + suffix.len(), 2);\n@@ -1538,7 +1565,7 @@ fn test_align_to_empty_mid() {\n     let bytes = [1, 2, 3, 4, 5, 6, 7];\n     type Chunk = u32;\n     for offset in 0..4 {\n-        let (_, mid, _) = unsafe { bytes[offset..offset+1].align_to::<Chunk>() };\n+        let (_, mid, _) = unsafe { bytes[offset..offset + 1].align_to::<Chunk>() };\n         assert_eq!(mid.as_ptr() as usize % mem::align_of::<Chunk>(), 0);\n     }\n }"}, {"sha": "d4b47a4708e4b4b65b11df5b7b17e7e4cdf19c30", "filename": "src/libcore/tests/str_lossy.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fstr_lossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Fstr_lossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fstr_lossy.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -3,79 +3,83 @@ use core::str::lossy::*;\n #[test]\n fn chunks() {\n     let mut iter = Utf8Lossy::from_bytes(b\"hello\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"hello\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"hello\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     let mut iter = Utf8Lossy::from_bytes(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes()).chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC2 There\\xFF Goodbye\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC2\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xFF\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC2\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xFF\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC0\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xE6\\x83\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC0\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xE6\\x83\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     let mut iter = Utf8Lossy::from_bytes(b\"\\xF5foo\\xF5\\x80bar\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF5\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF5\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF5\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF5\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     let mut iter = Utf8Lossy::from_bytes(b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF1\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF1\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF1\\x80\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF1\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF1\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF1\\x80\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     let mut iter = Utf8Lossy::from_bytes(b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF4\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF4\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF4\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF4\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF4\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF4\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     let mut iter = Utf8Lossy::from_bytes(b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF0\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\\u{10000}bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF0\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\\u{10000}bar\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n \n     // surrogates\n     let mut iter = Utf8Lossy::from_bytes(b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xED\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xA0\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xED\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xED\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xA0\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xED\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\" }), iter.next());\n     assert_eq!(None, iter.next());\n }\n \n #[test]\n fn display() {\n     assert_eq!(\n         \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n-        &Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string());\n+        &Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string()\n+    );\n }\n \n #[test]\n fn debug() {\n     assert_eq!(\n         \"\\\"Hello\\\\xc0\\\\x80 There\\\\xe6\\\\x83 Goodbye\\\\u{10d4ea}\\\"\",\n-        &format!(\"{:?}\", Utf8Lossy::from_bytes(\n-            b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\\xf4\\x8d\\x93\\xaa\")));\n+        &format!(\n+            \"{:?}\",\n+            Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\\xf4\\x8d\\x93\\xaa\")\n+        )\n+    );\n }"}, {"sha": "273f1258bb09075e07a25bb8aacc86f162a66698", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -3,10 +3,11 @@ use core::time::Duration;\n #[test]\n fn creation() {\n     assert_ne!(Duration::from_secs(1), Duration::from_secs(0));\n-    assert_eq!(Duration::from_secs(1) + Duration::from_secs(2),\n-               Duration::from_secs(3));\n-    assert_eq!(Duration::from_millis(10) + Duration::from_secs(4),\n-               Duration::new(4, 10 * 1_000_000));\n+    assert_eq!(Duration::from_secs(1) + Duration::from_secs(2), Duration::from_secs(3));\n+    assert_eq!(\n+        Duration::from_millis(10) + Duration::from_secs(4),\n+        Duration::new(4, 10 * 1_000_000)\n+    );\n     assert_eq!(Duration::from_millis(4000), Duration::new(4, 0));\n }\n \n@@ -68,29 +69,25 @@ fn nanos() {\n \n #[test]\n fn add() {\n-    assert_eq!(Duration::new(0, 0) + Duration::new(0, 1),\n-               Duration::new(0, 1));\n-    assert_eq!(Duration::new(0, 500_000_000) + Duration::new(0, 500_000_001),\n-               Duration::new(1, 1));\n+    assert_eq!(Duration::new(0, 0) + Duration::new(0, 1), Duration::new(0, 1));\n+    assert_eq!(Duration::new(0, 500_000_000) + Duration::new(0, 500_000_001), Duration::new(1, 1));\n }\n \n #[test]\n fn checked_add() {\n-    assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)),\n-               Some(Duration::new(0, 1)));\n-    assert_eq!(Duration::new(0, 500_000_000).checked_add(Duration::new(0, 500_000_001)),\n-               Some(Duration::new(1, 1)));\n+    assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n+    assert_eq!(\n+        Duration::new(0, 500_000_000).checked_add(Duration::new(0, 500_000_001)),\n+        Some(Duration::new(1, 1))\n+    );\n     assert_eq!(Duration::new(1, 0).checked_add(Duration::new(::core::u64::MAX, 0)), None);\n }\n \n #[test]\n fn sub() {\n-    assert_eq!(Duration::new(0, 1) - Duration::new(0, 0),\n-               Duration::new(0, 1));\n-    assert_eq!(Duration::new(0, 500_000_001) - Duration::new(0, 500_000_000),\n-               Duration::new(0, 1));\n-    assert_eq!(Duration::new(1, 0) - Duration::new(0, 1),\n-               Duration::new(0, 999_999_999));\n+    assert_eq!(Duration::new(0, 1) - Duration::new(0, 0), Duration::new(0, 1));\n+    assert_eq!(Duration::new(0, 500_000_001) - Duration::new(0, 500_000_000), Duration::new(0, 1));\n+    assert_eq!(Duration::new(1, 0) - Duration::new(0, 1), Duration::new(0, 999_999_999));\n }\n \n #[test]\n@@ -99,8 +96,7 @@ fn checked_sub() {\n     let one_nano = Duration::new(0, 1);\n     let one_sec = Duration::new(1, 0);\n     assert_eq!(one_nano.checked_sub(zero), Some(Duration::new(0, 1)));\n-    assert_eq!(one_sec.checked_sub(one_nano),\n-               Some(Duration::new(0, 999_999_999)));\n+    assert_eq!(one_sec.checked_sub(one_nano), Some(Duration::new(0, 999_999_999)));\n     assert_eq!(zero.checked_sub(one_nano), None);\n     assert_eq!(zero.checked_sub(one_sec), None);\n }\n@@ -122,26 +118,23 @@ fn mul() {\n     assert_eq!(Duration::new(0, 1) * 2, Duration::new(0, 2));\n     assert_eq!(Duration::new(1, 1) * 3, Duration::new(3, 3));\n     assert_eq!(Duration::new(0, 500_000_001) * 4, Duration::new(2, 4));\n-    assert_eq!(Duration::new(0, 500_000_001) * 4000,\n-               Duration::new(2000, 4000));\n+    assert_eq!(Duration::new(0, 500_000_001) * 4000, Duration::new(2000, 4000));\n }\n \n #[test]\n fn checked_mul() {\n     assert_eq!(Duration::new(0, 1).checked_mul(2), Some(Duration::new(0, 2)));\n     assert_eq!(Duration::new(1, 1).checked_mul(3), Some(Duration::new(3, 3)));\n     assert_eq!(Duration::new(0, 500_000_001).checked_mul(4), Some(Duration::new(2, 4)));\n-    assert_eq!(Duration::new(0, 500_000_001).checked_mul(4000),\n-               Some(Duration::new(2000, 4000)));\n+    assert_eq!(Duration::new(0, 500_000_001).checked_mul(4000), Some(Duration::new(2000, 4000)));\n     assert_eq!(Duration::new(::core::u64::MAX - 1, 0).checked_mul(2), None);\n }\n \n #[test]\n fn div() {\n     assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));\n     assert_eq!(Duration::new(1, 1) / 3, Duration::new(0, 333_333_333));\n-    assert_eq!(Duration::new(99, 999_999_000) / 100,\n-               Duration::new(0, 999_999_990));\n+    assert_eq!(Duration::new(99, 999_999_000) / 100, Duration::new(0, 999_999_990));\n }\n \n #[test]\n@@ -162,7 +155,7 @@ fn correct_sum() {\n         Duration::new(5, 0),\n     ];\n     let sum = durations.iter().sum::<Duration>();\n-    assert_eq!(sum, Duration::new(1+2+5+4, 1_000_000_000 - 5));\n+    assert_eq!(sum, Duration::new(1 + 2 + 5 + 4, 1_000_000_000 - 5));\n }\n \n #[test]\n@@ -286,9 +279,9 @@ fn debug_formatting_precision_two() {\n \n #[test]\n fn debug_formatting_precision_high() {\n-    assert_eq!(format!(\"{:.5?}\",  Duration::new(0, 23_678)), \"23.67800\u00b5s\");\n+    assert_eq!(format!(\"{:.5?}\", Duration::new(0, 23_678)), \"23.67800\u00b5s\");\n \n-    assert_eq!(format!(\"{:.9?}\",  Duration::new(1, 000_000_000)), \"1.000000000s\");\n+    assert_eq!(format!(\"{:.9?}\", Duration::new(1, 000_000_000)), \"1.000000000s\");\n     assert_eq!(format!(\"{:.10?}\", Duration::new(4, 001_000_000)), \"4.0010000000s\");\n     assert_eq!(format!(\"{:.20?}\", Duration::new(4, 001_000_000)), \"4.00100000000000000000s\");\n }"}, {"sha": "3a2914698cc269f2e14f5531f114ea749f7641b0", "filename": "src/libcore/tests/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibcore%2Ftests%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftuple.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1,4 +1,4 @@\n-use std::cmp::Ordering::{Equal, Less, Greater};\n+use std::cmp::Ordering::{Equal, Greater, Less};\n use std::f64::NAN;\n \n #[test]"}, {"sha": "a89bc28f40dd2aacf7644d41887ec9c796148324", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -278,15 +278,15 @@ impl<'tcx> Body<'tcx> {\n \n     /// Returns an iterator over all function arguments.\n     #[inline]\n-    pub fn args_iter(&self) -> impl Iterator<Item = Local> {\n+    pub fn args_iter(&self) -> impl Iterator<Item = Local> + ExactSizeIterator {\n         let arg_count = self.arg_count;\n-        (1..=arg_count).map(Local::new)\n+        (1..arg_count + 1).map(Local::new)\n     }\n \n     /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all\n     /// locals that are neither arguments nor the return place).\n     #[inline]\n-    pub fn vars_and_temps_iter(&self) -> impl Iterator<Item = Local> {\n+    pub fn vars_and_temps_iter(&self) -> impl Iterator<Item = Local> + ExactSizeIterator {\n         let arg_count = self.arg_count;\n         let local_count = self.local_decls.len();\n         (arg_count + 1..local_count).map(Local::new)\n@@ -2380,11 +2380,15 @@ impl<'tcx> UserTypeProjections {\n         UserTypeProjections { contents: projs.collect() }\n     }\n \n-    pub fn projections_and_spans(&self) -> impl Iterator<Item = &(UserTypeProjection, Span)> {\n+    pub fn projections_and_spans(&self)\n+        -> impl Iterator<Item = &(UserTypeProjection, Span)> + ExactSizeIterator\n+    {\n         self.contents.iter()\n     }\n \n-    pub fn projections(&self) -> impl Iterator<Item = &UserTypeProjection> {\n+    pub fn projections(&self)\n+        -> impl Iterator<Item = &UserTypeProjection> + ExactSizeIterator\n+    {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n "}, {"sha": "252b31e4d3c379152b7173bd1a4bfff8d2dbf53e", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -240,7 +240,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let tcx = self.infcx.tcx;\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n-                    if let Some(generics) = tcx.hir().get_generics(self.mir_def_id) {\n+                    if let Some(generics) =\n+                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id)) {\n                         suggest_constraining_type_param(\n                             generics,\n                             &mut err,"}, {"sha": "33ed69af6ba0273d045806eaff45425d27a50f31", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -304,7 +304,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if !self.stack.is_empty() {\n             // This should change *something*\n             debug_assert!(self.cur_frame() != old_stack || self.frame().block != old_bb);\n-            info!(\"// {:?}\", self.frame().block);\n+            if let Some(block) = self.frame().block {\n+                info!(\"// executing {:?}\", block);\n+            }\n         }\n         Ok(())\n     }"}, {"sha": "202b6ae2f94c470a8903fd2ceba820a2fe053d9a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -158,14 +158,14 @@ impl<'a> AstValidator<'a> {\n         err.emit();\n     }\n \n-    fn check_decl_no_pat<F: FnMut(Span, bool)>(decl: &FnDecl, mut report_err: F) {\n-        for arg in &decl.inputs {\n-            match arg.pat.kind {\n+    fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, bool)) {\n+        for Param { pat, .. } in &decl.inputs {\n+            match pat.kind {\n                 PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), _, None) |\n                 PatKind::Wild => {}\n                 PatKind::Ident(BindingMode::ByValue(Mutability::Mutable), _, None) =>\n-                    report_err(arg.pat.span, true),\n-                _ => report_err(arg.pat.span, false),\n+                    report_err(pat.span, true),\n+                _ => report_err(pat.span, false),\n             }\n         }\n     }"}, {"sha": "566ba129074370b0cba3dd10f151724577225fa2", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 73, "deletions": 88, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -12,7 +12,7 @@ use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleIm\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n+use crate::{ResolutionError, VisResolutionError, Determinacy, PathResult, CrateLint};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -32,8 +32,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind};\n use syntax::token::{self, Token};\n-use syntax::print::pprust;\n-use syntax::{span_err, struct_span_err};\n+use syntax::span_err;\n use syntax::source_map::{respan, Spanned};\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n@@ -192,14 +191,25 @@ impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n+        self.resolve_visibility_speculative(vis, false).unwrap_or_else(|err| {\n+            self.r.report_vis_error(err);\n+            ty::Visibility::Public\n+        })\n+    }\n+\n+    fn resolve_visibility_speculative<'ast>(\n+        &mut self,\n+        vis: &'ast ast::Visibility,\n+        speculative: bool,\n+    ) -> Result<ty::Visibility, VisResolutionError<'ast>> {\n         let parent_scope = &self.parent_scope;\n         match vis.node {\n-            ast::VisibilityKind::Public => ty::Visibility::Public,\n+            ast::VisibilityKind::Public => Ok(ty::Visibility::Public),\n             ast::VisibilityKind::Crate(..) => {\n-                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+                Ok(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)))\n             }\n             ast::VisibilityKind::Inherited => {\n-                ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id)\n+                Ok(ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id))\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n@@ -209,86 +219,67 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n                 let crate_root = if ident.is_path_segment_keyword() {\n                     None\n-                } else if ident.span.rust_2018() {\n-                    let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n-                    self.r.session.struct_span_err(ident.span, msg)\n-                        .span_suggestion(\n-                            path.span,\n-                            \"try\",\n-                            format!(\"crate::{}\", pprust::path_to_string(&path)),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n-                    return ty::Visibility::Public;\n-                } else {\n-                    let ctxt = ident.span.ctxt();\n+                } else if ident.span.rust_2015() {\n                     Some(Segment::from_ident(Ident::new(\n-                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ctxt)\n+                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ident.span.ctxt())\n                     )))\n+                } else {\n+                    return Err(VisResolutionError::Relative2018(ident.span, path));\n                 };\n \n                 let segments = crate_root.into_iter()\n                     .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n-                let expected_found_error = |this: &Self, res: Res| {\n-                    let path_str = Segment::names_to_string(&segments);\n-                    struct_span_err!(this.r.session, path.span, E0577,\n-                                     \"expected module, found {} `{}`\", res.descr(), path_str)\n-                        .span_label(path.span, \"not a module\").emit();\n-                };\n+                let expected_found_error = |res| Err(VisResolutionError::ExpectedFound(\n+                    path.span, Segment::names_to_string(&segments), res\n+                ));\n                 match self.r.resolve_path(\n                     &segments,\n                     Some(TypeNS),\n                     parent_scope,\n-                    true,\n+                    !speculative,\n                     path.span,\n                     CrateLint::SimplePath(id),\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n-                        self.r.record_partial_res(id, PartialRes::new(res));\n+                        if !speculative {\n+                            self.r.record_partial_res(id, PartialRes::new(res));\n+                        }\n                         if module.is_normal() {\n                             if res == Res::Err {\n-                                ty::Visibility::Public\n+                                Ok(ty::Visibility::Public)\n                             } else {\n                                 let vis = ty::Visibility::Restricted(res.def_id());\n                                 if self.r.is_accessible_from(vis, parent_scope.module) {\n-                                    vis\n+                                    Ok(vis)\n                                 } else {\n-                                    struct_span_err!(self.r.session, path.span, E0742,\n-                                        \"visibilities can only be restricted to ancestor modules\")\n-                                        .emit();\n-                                    ty::Visibility::Public\n+                                    Err(VisResolutionError::AncestorOnly(path.span))\n                                 }\n                             }\n                         } else {\n-                            expected_found_error(self, res);\n-                            ty::Visibility::Public\n+                            expected_found_error(res)\n                         }\n                     }\n-                    PathResult::Module(..) => {\n-                        self.r.session.span_err(path.span, \"visibility must resolve to a module\");\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::NonModule(partial_res) => {\n-                        expected_found_error(self, partial_res.base_res());\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Failed { span, label, suggestion, .. } => {\n-                        self.r.report_error(\n-                            span, ResolutionError::FailedToResolve { label, suggestion }\n-                        );\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Indeterminate => {\n-                        span_err!(self.r.session, path.span, E0578,\n-                                  \"cannot determine resolution for the visibility\");\n-                        ty::Visibility::Public\n-                    }\n+                    PathResult::Module(..) =>\n+                        Err(VisResolutionError::ModuleOnly(path.span)),\n+                    PathResult::NonModule(partial_res) =>\n+                        expected_found_error(partial_res.base_res()),\n+                    PathResult::Failed { span, label, suggestion, .. } =>\n+                        Err(VisResolutionError::FailedToResolve(span, label, suggestion)),\n+                    PathResult::Indeterminate =>\n+                        Err(VisResolutionError::Indeterminate(path.span)),\n                 }\n             }\n         }\n     }\n \n+    fn insert_field_names_local(&mut self, def_id: DefId, vdata: &ast::VariantData) {\n+        let field_names = vdata.fields().iter().map(|field| {\n+            respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name))\n+        }).collect();\n+        self.insert_field_names(def_id, field_names);\n+    }\n+\n     fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Spanned<Name>>) {\n         if !field_names.is_empty() {\n             self.r.field_names.insert(def_id, field_names);\n@@ -726,59 +717,52 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items live in both the type and value namespaces.\n-            ItemKind::Struct(ref struct_def, _) => {\n+            ItemKind::Struct(ref vdata, _) => {\n                 // Define a name in the type namespace.\n                 let def_id = self.r.definitions.local_def_id(item.id);\n                 let res = Res::Def(DefKind::Struct, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n-                let mut ctor_vis = vis;\n-\n-                let has_non_exhaustive = attr::contains_name(&item.attrs, sym::non_exhaustive);\n-\n-                // If the structure is marked as non_exhaustive then lower the visibility\n-                // to within the crate.\n-                if has_non_exhaustive && vis == ty::Visibility::Public {\n-                    ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                }\n-\n                 // Record field names for error reporting.\n-                let field_names = struct_def.fields().iter().map(|field| {\n-                    // NOTE: The field may be an expansion placeholder, but expansion sets correct\n-                    // visibilities for unnamed field placeholders specifically, so the constructor\n-                    // visibility should still be determined correctly.\n-                    let field_vis = self.resolve_visibility(&field.vis);\n-                    if ctor_vis.is_at_least(field_vis, &*self.r) {\n-                        ctor_vis = field_vis;\n-                    }\n-                    respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name))\n-                }).collect();\n-                let item_def_id = self.r.definitions.local_def_id(item.id);\n-                self.insert_field_names(item_def_id, field_names);\n+                self.insert_field_names_local(def_id, vdata);\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n-                if let Some(ctor_node_id) = struct_def.ctor_id() {\n+                if let Some(ctor_node_id) = vdata.ctor_id() {\n+                    let mut ctor_vis = vis;\n+                    // If the structure is marked as non_exhaustive then lower the visibility\n+                    // to within the crate.\n+                    if vis == ty::Visibility::Public &&\n+                       attr::contains_name(&item.attrs, sym::non_exhaustive) {\n+                        ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+                    }\n+                    for field in vdata.fields() {\n+                        // NOTE: The field may be an expansion placeholder, but expansion sets\n+                        // correct visibilities for unnamed field placeholders specifically, so the\n+                        // constructor visibility should still be determined correctly.\n+                        if let Ok(field_vis) =\n+                                self.resolve_visibility_speculative(&field.vis, true) {\n+                            if ctor_vis.is_at_least(field_vis, &*self.r) {\n+                                ctor_vis = field_vis;\n+                            }\n+                        }\n+                    }\n                     let ctor_res = Res::Def(\n-                        DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(struct_def)),\n+                        DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(vdata)),\n                         self.r.definitions.local_def_id(ctor_node_id),\n                     );\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n-                    self.r.struct_constructors.insert(res.def_id(), (ctor_res, ctor_vis));\n+                    self.r.struct_constructors.insert(def_id, (ctor_res, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let res = Res::Def(DefKind::Union, self.r.definitions.local_def_id(item.id));\n+                let def_id = self.r.definitions.local_def_id(item.id);\n+                let res = Res::Def(DefKind::Union, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n-                let field_names = vdata.fields().iter().map(|field| {\n-                    self.resolve_visibility(&field.vis);\n-                    respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name))\n-                }).collect();\n-                let item_def_id = self.r.definitions.local_def_id(item.id);\n-                self.insert_field_names(item_def_id, field_names);\n+                self.insert_field_names_local(def_id, vdata);\n             }\n \n             ItemKind::Impl(.., ref impl_items) => {\n@@ -1281,6 +1265,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         if sf.is_placeholder {\n             self.visit_invoc(sf.id);\n         } else {\n+            self.resolve_visibility(&sf.vis);\n             visit::walk_struct_field(self, sf);\n         }\n     }"}, {"sha": "f92415fc0521a2fd802754cb43ab876fd1f46199", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -11,6 +11,7 @@ use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::FxHashSet;\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use syntax::ast::{self, Ident, Path};\n+use syntax::print::pprust;\n use syntax::source_map::SourceMap;\n use syntax::struct_span_err;\n use syntax::symbol::{Symbol, kw};\n@@ -22,6 +23,7 @@ use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportRes\n use crate::path_names_to_string;\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n+use crate::VisResolutionError;\n \n use rustc_error_codes::*;\n \n@@ -357,6 +359,44 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    crate fn report_vis_error(&self, vis_resolution_error: VisResolutionError<'_>) {\n+        match vis_resolution_error {\n+            VisResolutionError::Relative2018(span, path) => {\n+                let mut err = self.session.struct_span_err(span,\n+                    \"relative paths are not supported in visibilities on 2018 edition\");\n+                err.span_suggestion(\n+                    path.span,\n+                    \"try\",\n+                    format!(\"crate::{}\", pprust::path_to_string(&path)),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err\n+            }\n+            VisResolutionError::AncestorOnly(span) => {\n+                struct_span_err!(self.session, span, E0742,\n+                    \"visibilities can only be restricted to ancestor modules\")\n+            }\n+            VisResolutionError::FailedToResolve(span, label, suggestion) => {\n+                self.into_struct_error(\n+                    span, ResolutionError::FailedToResolve { label, suggestion }\n+                )\n+            }\n+            VisResolutionError::ExpectedFound(span, path_str, res) => {\n+                let mut err = struct_span_err!(self.session, span, E0577,\n+                    \"expected module, found {} `{}`\", res.descr(), path_str);\n+                err.span_label(span, \"not a module\");\n+                err\n+            }\n+            VisResolutionError::Indeterminate(span) => {\n+                struct_span_err!(self.session, span, E0578,\n+                    \"cannot determine resolution for the visibility\")\n+            }\n+            VisResolutionError::ModuleOnly(span) => {\n+                self.session.struct_span_err(span, \"visibility must resolve to a module\")\n+            }\n+        }.emit()\n+    }\n+\n     /// Lookup typo candidate in scope for a macro or import.\n     fn early_lookup_typo_candidate(\n         &mut self,"}, {"sha": "9db89c8273d9c16b956d9a5a122efb95b1a3aa7f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -218,6 +218,15 @@ enum ResolutionError<'a> {\n     SelfInTyParamDefault,\n }\n \n+enum VisResolutionError<'a> {\n+    Relative2018(Span, &'a ast::Path),\n+    AncestorOnly(Span),\n+    FailedToResolve(Span, String, Option<Suggestion>),\n+    ExpectedFound(Span, String, Res),\n+    Indeterminate(Span),\n+    ModuleOnly(Span),\n+}\n+\n // A minimal representation of a path segment. We use this in resolve because\n // we synthesize 'path segments' which don't have the rest of an AST or HIR\n // `PathSegment`."}, {"sha": "b9cede7aa53baf005198eb4102a894fdc61ecde2", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -495,11 +495,13 @@ impl OsStr {\n     ///\n     /// let os_str = OsStr::new(\"foo\");\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr {\n         s.as_ref()\n     }\n \n+    #[inline]\n     fn from_inner(inner: &Slice) -> &OsStr {\n         unsafe { &*(inner as *const Slice as *const OsStr) }\n     }\n@@ -658,6 +660,7 @@ impl OsStr {\n     ///\n     /// Note: it is *crucial* that this API is private, to avoid\n     /// revealing the internal, platform-specific encodings.\n+    #[inline]\n     fn bytes(&self) -> &[u8] {\n         unsafe { &*(&self.inner as *const _ as *const [u8]) }\n     }\n@@ -797,20 +800,23 @@ impl Default for &OsStr {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for OsStr {\n+    #[inline]\n     fn eq(&self, other: &OsStr) -> bool {\n         self.bytes().eq(other.bytes())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<str> for OsStr {\n+    #[inline]\n     fn eq(&self, other: &str) -> bool {\n         *self == *OsStr::new(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<OsStr> for str {\n+    #[inline]\n     fn eq(&self, other: &OsStr) -> bool {\n         *other == *OsStr::new(self)\n     }\n@@ -944,13 +950,15 @@ impl AsRef<OsStr> for OsString {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for str {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         OsStr::from_inner(Slice::from_str(self))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for String {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         (&**self).as_ref()\n     }"}, {"sha": "ef260f9c5d21f57a15b46e58ed3ab613df4acc69", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -128,6 +128,7 @@ impl Buf {\n }\n \n impl Slice {\n+    #[inline]\n     pub fn from_str(s: &str) -> &Slice {\n         unsafe { mem::transmute(Wtf8::from_str(s)) }\n     }"}, {"sha": "eb8a881ec8881f522e75e852f785b0b2f982b291", "filename": "src/libstd/sys_common/os_str_bytes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -139,10 +139,12 @@ impl Buf {\n }\n \n impl Slice {\n+    #[inline]\n     fn from_u8_slice(s: &[u8]) -> &Slice {\n         unsafe { mem::transmute(s) }\n     }\n \n+    #[inline]\n     pub fn from_str(s: &str) -> &Slice {\n         Slice::from_u8_slice(s.as_bytes())\n     }"}, {"sha": "f0c5fb32fb16dbddc1dd733e5cc9e1b23dad323d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -1518,6 +1518,7 @@ impl<'a> State<'a> {\n \n     crate fn print_variant(&mut self, v: &ast::Variant) {\n         self.head(\"\");\n+        self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n         match v.disr_expr {"}, {"sha": "a3e8178aeb3ded4cd2a98ef3d8b7c1ed2ee679b5", "filename": "src/test/pretty/enum-variant-vis.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fpretty%2Fenum-variant-vis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fpretty%2Fenum-variant-vis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fenum-variant-vis.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -0,0 +1,8 @@\n+// pp-exact\n+\n+// Check that the visibility is printed on an enum variant.\n+\n+fn main() { }\n+\n+#[cfg(FALSE)]\n+enum Foo { pub V, }"}, {"sha": "d1bd2a1e7272416d95ad11145bb4151fdbf1f2c5", "filename": "src/test/ui/attributes/field-attributes-vis-unresolved.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -0,0 +1,25 @@\n+// Non-builtin attributes do not mess with field visibility resolution (issue #67006).\n+\n+mod internal {\n+    struct S {\n+        #[rustfmt::skip]\n+        pub(in crate::internal) field: u8 // OK\n+    }\n+\n+    struct Z(\n+        #[rustfmt::skip]\n+        pub(in crate::internal) u8 // OK\n+    );\n+}\n+\n+struct S {\n+    #[rustfmt::skip]\n+    pub(in nonexistent) field: u8 //~ ERROR failed to resolve\n+}\n+\n+struct Z(\n+    #[rustfmt::skip]\n+    pub(in nonexistent) u8 //~ ERROR failed to resolve\n+);\n+\n+fn main() {}"}, {"sha": "41c3cea3021354d56ba96a3a97adcd726fee0e50", "filename": "src/test/ui/attributes/field-attributes-vis-unresolved.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -0,0 +1,15 @@\n+error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n+  --> $DIR/field-attributes-vis-unresolved.rs:17:12\n+   |\n+LL |     pub(in nonexistent) field: u8\n+   |            ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n+\n+error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n+  --> $DIR/field-attributes-vis-unresolved.rs:22:12\n+   |\n+LL |     pub(in nonexistent) u8\n+   |            ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "014c530e6d7dc632ff625d87edf145f6cb8c5923", "filename": "src/test/ui/closures/issue-67123.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fclosures%2Fissue-67123.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fclosures%2Fissue-67123.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-67123.rs?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -0,0 +1,5 @@\n+fn foo<T>(t: T) {\n+    || { t; t; }; //~ ERROR: use of moved value\n+}\n+\n+fn main() {}"}, {"sha": "b2e875b8010efbd314980a2dd32993bc1c396f5d", "filename": "src/test/ui/closures/issue-67123.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fclosures%2Fissue-67123.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/975e83a32ad8c2c894391711d227786614d61a50/src%2Ftest%2Fui%2Fclosures%2Fissue-67123.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-67123.stderr?ref=975e83a32ad8c2c894391711d227786614d61a50", "patch": "@@ -0,0 +1,15 @@\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/issue-67123.rs:2:13\n+   |\n+LL | fn foo<T>(t: T) {\n+   |        - help: consider restricting this bound: `T: Copy`\n+LL |     || { t; t; };\n+   |          -  ^ value used here after move\n+   |          |\n+   |          value moved here\n+   |\n+   = note: move occurs because `t` has type `T`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}]}