{"sha": "6873b9fee4af732fe81d54fdcedbd31201e3edf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NzNiOWZlZTRhZjczMmZlODFkNTRmZGNlZGJkMzEyMDFlM2VkZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-13T23:09:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-13T23:09:27Z"}, "message": "Auto merge of #28357 - semmaz:libfmt-macros, r=alexcrichton\n\nThis changes libfmt_macros `CharIndices` iterator into `Peekable` so it can be used without `.clone()`.\r\n\r\nAlso changed some `loop match` and `match` to `while let` and `if let` respectively (mostly for readability).", "tree": {"sha": "c300338d7c2046314a4719cd2c488f2b88424b1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c300338d7c2046314a4719cd2c488f2b88424b1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6873b9fee4af732fe81d54fdcedbd31201e3edf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6873b9fee4af732fe81d54fdcedbd31201e3edf0", "html_url": "https://github.com/rust-lang/rust/commit/6873b9fee4af732fe81d54fdcedbd31201e3edf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6873b9fee4af732fe81d54fdcedbd31201e3edf0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "483600e65fa90bf62491e24ed88499fe4fee819a", "url": "https://api.github.com/repos/rust-lang/rust/commits/483600e65fa90bf62491e24ed88499fe4fee819a", "html_url": "https://github.com/rust-lang/rust/commit/483600e65fa90bf62491e24ed88499fe4fee819a"}, {"sha": "15d5c0878d93c553558bf23245c6be6f7ab65fab", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d5c0878d93c553558bf23245c6be6f7ab65fab", "html_url": "https://github.com/rust-lang/rust/commit/15d5c0878d93c553558bf23245c6be6f7ab65fab"}], "stats": {"total": 191, "additions": 79, "deletions": 112}, "files": [{"sha": "9c02ccb08acd84764f56d94a307842916b80e1e2", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 79, "deletions": 112, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/6873b9fee4af732fe81d54fdcedbd31201e3edf0/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6873b9fee4af732fe81d54fdcedbd31201e3edf0/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=6873b9fee4af732fe81d54fdcedbd31201e3edf0", "patch": "@@ -37,6 +37,7 @@ pub use self::Count::*;\n \n use std::str;\n use std::string;\n+use std::iter;\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n@@ -141,7 +142,7 @@ pub enum Count<'a> {\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'a> {\n     input: &'a str,\n-    cur: str::CharIndices<'a>,\n+    cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n     pub errors: Vec<string::String>,\n }\n@@ -150,28 +151,31 @@ impl<'a> Iterator for Parser<'a> {\n     type Item = Piece<'a>;\n \n     fn next(&mut self) -> Option<Piece<'a>> {\n-        match self.cur.clone().next() {\n-            Some((pos, '{')) => {\n-                self.cur.next();\n-                if self.consume('{') {\n-                    Some(String(self.string(pos + 1)))\n-                } else {\n-                    let ret = Some(NextArgument(self.argument()));\n-                    self.must_consume('}');\n-                    ret\n+        if let Some(&(pos, c)) = self.cur.peek() {\n+            match c {\n+                '{' => {\n+                    self.cur.next();\n+                    if self.consume('{') {\n+                        Some(String(self.string(pos + 1)))\n+                    } else {\n+                        let ret = Some(NextArgument(self.argument()));\n+                        self.must_consume('}');\n+                        ret\n+                    }\n                 }\n-            }\n-            Some((pos, '}')) => {\n-                self.cur.next();\n-                if self.consume('}') {\n-                    Some(String(self.string(pos + 1)))\n-                } else {\n-                    self.err(\"unmatched `}` found\");\n-                    None\n+                '}' => {\n+                    self.cur.next();\n+                    if self.consume('}') {\n+                        Some(String(self.string(pos + 1)))\n+                    } else {\n+                        self.err(\"unmatched `}` found\");\n+                        None\n+                    }\n                 }\n+                _ => Some(String(self.string(pos))),\n             }\n-            Some((pos, _)) => { Some(String(self.string(pos))) }\n-            None => None\n+        } else {\n+            None\n         }\n     }\n }\n@@ -181,7 +185,7 @@ impl<'a> Parser<'a> {\n     pub fn new(s: &'a str) -> Parser<'a> {\n         Parser {\n             input: s,\n-            cur: s.char_indices(),\n+            cur: s.char_indices().peekable(),\n             errors: vec!(),\n         }\n     }\n@@ -197,61 +201,47 @@ impl<'a> Parser<'a> {\n     /// the current position, then the current iterator isn't moved and false is\n     /// returned, otherwise the character is consumed and true is returned.\n     fn consume(&mut self, c: char) -> bool {\n-        match self.cur.clone().next() {\n-            Some((_, maybe)) if c == maybe => {\n-                self.cur.next();\n-                true\n-            }\n-            Some(..) | None => false,\n+        if let Some(&(_, maybe)) = self.cur.peek() {\n+            if c == maybe { self.cur.next(); true } else { false }\n+        } else {\n+            false\n         }\n     }\n \n     /// Forces consumption of the specified character. If the character is not\n     /// found, an error is emitted.\n     fn must_consume(&mut self, c: char) {\n         self.ws();\n-        match self.cur.clone().next() {\n-            Some((_, maybe)) if c == maybe => {\n+        if let Some(&(_, maybe)) = self.cur.peek() {\n+            if c == maybe {\n                 self.cur.next();\n+            } else {\n+                self.err(&format!(\"expected `{:?}`, found `{:?}`\", c, maybe));\n             }\n-            Some((_, other)) => {\n-                self.err(&format!(\"expected `{:?}`, found `{:?}`\", c,\n-                                  other));\n-            }\n-            None => {\n-                self.err(&format!(\"expected `{:?}` but string was terminated\",\n-                                  c));\n-            }\n+        } else {\n+            self.err(&format!(\"expected `{:?}` but string was terminated\", c));\n         }\n     }\n \n     /// Consumes all whitespace characters until the first non-whitespace\n     /// character\n     fn ws(&mut self) {\n-        loop {\n-            match self.cur.clone().next() {\n-                Some((_, c)) if c.is_whitespace() => { self.cur.next(); }\n-                Some(..) | None => { return }\n-            }\n+        while let Some(&(_, c)) = self.cur.peek() {\n+            if c.is_whitespace() { self.cur.next(); } else { break }\n         }\n     }\n \n     /// Parses all of a string which is to be considered a \"raw literal\" in a\n     /// format string. This is everything outside of the braces.\n     fn string(&mut self, start: usize) -> &'a str {\n-        loop {\n-            // we may not consume the character, so clone the iterator\n-            match self.cur.clone().next() {\n-                Some((pos, '}')) | Some((pos, '{')) => {\n-                    return &self.input[start..pos];\n-                }\n-                Some(..) => { self.cur.next(); }\n-                None => {\n-                    self.cur.next();\n-                    return &self.input[start..self.input.len()];\n-                }\n+        // we may not consume the character, peek the iterator\n+        while let Some(&(pos, c)) = self.cur.peek() {\n+            match c {\n+                '{' | '}' => { return &self.input[start..pos]; }\n+                _ => { self.cur.next(); }\n             }\n         }\n+        &self.input[start..self.input.len()]\n     }\n \n     /// Parses an Argument structure, or what's contained within braces inside\n@@ -266,15 +256,14 @@ impl<'a> Parser<'a> {\n     /// Parses a positional argument for a format. This could either be an\n     /// integer index of an argument, a named argument, or a blank string.\n     fn position(&mut self) -> Position<'a> {\n-        match self.integer() {\n-            Some(i) => { ArgumentIs(i) }\n-            None => {\n-                match self.cur.clone().next() {\n-                    Some((_, c)) if c.is_alphabetic() => {\n-                        ArgumentNamed(self.word())\n-                    }\n-                    _ => ArgumentNext\n+        if let Some(i) = self.integer() {\n+            ArgumentIs(i)\n+        } else {\n+            match self.cur.peek() {\n+                Some(&(_, c)) if c.is_alphabetic() => {\n+                    ArgumentNamed(self.word())\n                 }\n+                _ => ArgumentNext\n             }\n         }\n     }\n@@ -293,17 +282,14 @@ impl<'a> Parser<'a> {\n         if !self.consume(':') { return spec }\n \n         // fill character\n-        match self.cur.clone().next() {\n-            Some((_, c)) => {\n-                match self.cur.clone().skip(1).next() {\n-                    Some((_, '>')) | Some((_, '<')) | Some((_, '^')) => {\n-                        spec.fill = Some(c);\n-                        self.cur.next();\n-                    }\n-                    Some(..) | None => {}\n+        if let Some(&(_, c)) = self.cur.peek() {\n+            match self.cur.clone().skip(1).next() {\n+                Some((_, '>')) | Some((_, '<')) | Some((_, '^')) => {\n+                    spec.fill = Some(c);\n+                    self.cur.next();\n                 }\n+                _ => {}\n             }\n-            None => {}\n         }\n         // Alignment\n         if self.consume('<') {\n@@ -360,29 +346,20 @@ impl<'a> Parser<'a> {\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n     fn count(&mut self) -> Count<'a> {\n-        match self.integer() {\n-            Some(i) => {\n+        if let Some(i) = self.integer() {\n+            if self.consume('$') { CountIsParam(i) } else { CountIs(i) }\n+        } else {\n+            let tmp = self.cur.clone();\n+            let word = self.word();\n+            if word.is_empty() {\n+                self.cur = tmp;\n+                CountImplied\n+            } else {\n                 if self.consume('$') {\n-                    CountIsParam(i)\n+                    CountIsName(word)\n                 } else {\n-                    CountIs(i)\n-                }\n-            }\n-            None => {\n-                let tmp = self.cur.clone();\n-                match self.word() {\n-                    word if !word.is_empty() => {\n-                        if self.consume('$') {\n-                            CountIsName(word)\n-                        } else {\n-                            self.cur = tmp;\n-                            CountImplied\n-                        }\n-                    }\n-                    _ => {\n-                        self.cur = tmp;\n-                        CountImplied\n-                    }\n+                    self.cur = tmp;\n+                    CountImplied\n                 }\n             }\n         }\n@@ -392,32 +369,26 @@ impl<'a> Parser<'a> {\n     /// be an alphabetic character followed by any number of alphanumeric\n     /// characters.\n     fn word(&mut self) -> &'a str {\n-        let start = match self.cur.clone().next() {\n-            Some((pos, c)) if c.is_xid_start() => {\n-                self.cur.next();\n-                pos\n-            }\n-            Some(..) | None => { return &self.input[..0]; }\n+        let start = match self.cur.peek() {\n+            Some(&(pos, c)) if c.is_xid_start() => { self.cur.next(); pos }\n+            _ => { return &self.input[..0]; }\n         };\n-        let end;\n-        loop {\n-            match self.cur.clone().next() {\n-                Some((_, c)) if c.is_xid_continue() => {\n-                    self.cur.next();\n-                }\n-                Some((pos, _)) => { end = pos; break }\n-                None => { end = self.input.len(); break }\n+        while let Some(&(pos, c)) = self.cur.peek() {\n+            if c.is_xid_continue() {\n+                self.cur.next();\n+            } else {\n+                return &self.input[start..pos];\n             }\n         }\n-        &self.input[start..end]\n+        &self.input[start..self.input.len()]\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal\n     /// with overflow at all, it's just accumulating digits.\n     fn integer(&mut self) -> Option<usize> {\n         let mut cur = 0;\n         let mut found = false;\n-        while let Some((_, c)) = self.cur.clone().next() {\n+        while let Some(&(_, c)) = self.cur.peek() {\n             if let Some(i) = c.to_digit(10) {\n                 cur = cur * 10 + i as usize;\n                 found = true;\n@@ -426,11 +397,7 @@ impl<'a> Parser<'a> {\n                 break\n             }\n         }\n-        if found {\n-            Some(cur)\n-        } else {\n-            None\n-        }\n+        if found { Some(cur) } else { None }\n     }\n }\n "}]}