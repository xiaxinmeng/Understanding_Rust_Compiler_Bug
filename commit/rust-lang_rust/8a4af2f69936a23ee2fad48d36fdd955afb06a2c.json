{"sha": "8a4af2f69936a23ee2fad48d36fdd955afb06a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNGFmMmY2OTkzNmEyM2VlMmZhZDQ4ZDM2ZmRkOTU1YWZiMDZhMmM=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-09-30T00:06:00Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-09-30T00:15:24Z"}, "message": "Fixed weird non-sequential indices for serialisation of `SourceFile` type.", "tree": {"sha": "2019a7d6a472a60ce90625be49ca7a3692767fc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2019a7d6a472a60ce90625be49ca7a3692767fc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a4af2f69936a23ee2fad48d36fdd955afb06a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a4af2f69936a23ee2fad48d36fdd955afb06a2c", "html_url": "https://github.com/rust-lang/rust/commit/8a4af2f69936a23ee2fad48d36fdd955afb06a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a4af2f69936a23ee2fad48d36fdd955afb06a2c/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdd1a62a453dd41b75bc1b3a992c35292b853877", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd1a62a453dd41b75bc1b3a992c35292b853877", "html_url": "https://github.com/rust-lang/rust/commit/fdd1a62a453dd41b75bc1b3a992c35292b853877"}], "stats": {"total": 31, "additions": 15, "deletions": 16}, "files": [{"sha": "6e83e1d3f8d4fc178c422b91ae42f461d4a5a905", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a4af2f69936a23ee2fad48d36fdd955afb06a2c/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a4af2f69936a23ee2fad48d36fdd955afb06a2c/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=8a4af2f69936a23ee2fad48d36fdd955afb06a2c", "patch": "@@ -884,7 +884,7 @@ pub struct OffsetOverflowError;\n /// A single source in the `SourceMap`.\n #[derive(Clone)]\n pub struct SourceFile {\n-    /// The name of the file that the source came from, source that doesn't\n+    /// The name of the file that the source came from. Source that doesn't\n     /// originate from files has names between angle brackets by convention\n     /// (e.g., `<anon>`).\n     pub name: FileName,\n@@ -922,9 +922,9 @@ impl Encodable for SourceFile {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n             s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", 4, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", 5, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", 6, |s| {\n+            s.emit_struct_field(\"start_pos\", 3, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", 4, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", 5, |s| {\n                 let lines = &self.lines[..];\n                 // Store the length.\n                 s.emit_u32(lines.len() as u32)?;\n@@ -970,13 +970,13 @@ impl Encodable for SourceFile {\n \n                 Ok(())\n             })?;\n-            s.emit_struct_field(\"multibyte_chars\", 7, |s| {\n+            s.emit_struct_field(\"multibyte_chars\", 6, |s| {\n                 self.multibyte_chars.encode(s)\n             })?;\n-            s.emit_struct_field(\"non_narrow_chars\", 8, |s| {\n+            s.emit_struct_field(\"non_narrow_chars\", 7, |s| {\n                 self.non_narrow_chars.encode(s)\n             })?;\n-            s.emit_struct_field(\"name_hash\", 9, |s| {\n+            s.emit_struct_field(\"name_hash\", 8, |s| {\n                 self.name_hash.encode(s)\n             })\n         })\n@@ -985,17 +985,16 @@ impl Encodable for SourceFile {\n \n impl Decodable for SourceFile {\n     fn decode<D: Decoder>(d: &mut D) -> Result<SourceFile, D::Error> {\n-\n         d.read_struct(\"SourceFile\", 8, |d| {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n             let src_hash: u128 =\n                 d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n             let start_pos: BytePos =\n-                d.read_struct_field(\"start_pos\", 4, |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 5, |d| Decodable::decode(d))?;\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 6, |d| {\n+                d.read_struct_field(\"start_pos\", 3, |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 4, |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 5, |d| {\n                 let num_lines: u32 = Decodable::decode(d)?;\n                 let mut lines = Vec::with_capacity(num_lines as usize);\n \n@@ -1024,18 +1023,18 @@ impl Decodable for SourceFile {\n                 Ok(lines)\n             })?;\n             let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", 7, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"multibyte_chars\", 6, |d| Decodable::decode(d))?;\n             let non_narrow_chars: Vec<NonNarrowChar> =\n-                d.read_struct_field(\"non_narrow_chars\", 8, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n             let name_hash: u128 =\n-                d.read_struct_field(\"name_hash\", 9, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n                 unmapped_path: None,\n                 // `crate_of_origin` has to be set by the importer.\n-                // This value matches up with rustc::hir::def_id::INVALID_CRATE.\n-                // That constant is not available here unfortunately :(\n+                // This value matches up with `rustc::hir::def_id::INVALID_CRATE`.\n+                // That constant is not available here, unfortunately.\n                 crate_of_origin: std::u32::MAX - 1,\n                 start_pos,\n                 end_pos,"}]}