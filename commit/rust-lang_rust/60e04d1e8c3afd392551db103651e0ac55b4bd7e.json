{"sha": "60e04d1e8c3afd392551db103651e0ac55b4bd7e", "node_id": "C_kwDOAAsO6NoAKDYwZTA0ZDFlOGMzYWZkMzkyNTUxZGIxMDM2NTFlMGFjNTViNGJkN2U", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-01T13:57:22Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-27T20:10:06Z"}, "message": "Compute generator saved locals on MIR.", "tree": {"sha": "e5be864f6a864d59b04fca3a2124493a0809e601", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5be864f6a864d59b04fca3a2124493a0809e601"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60e04d1e8c3afd392551db103651e0ac55b4bd7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60e04d1e8c3afd392551db103651e0ac55b4bd7e", "html_url": "https://github.com/rust-lang/rust/commit/60e04d1e8c3afd392551db103651e0ac55b4bd7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60e04d1e8c3afd392551db103651e0ac55b4bd7e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "400cb9aa41815f874d7d29a545e6e6f8539459de", "url": "https://api.github.com/repos/rust-lang/rust/commits/400cb9aa41815f874d7d29a545e6e6f8539459de", "html_url": "https://github.com/rust-lang/rust/commit/400cb9aa41815f874d7d29a545e6e6f8539459de"}], "stats": {"total": 411, "additions": 392, "deletions": 19}, "files": [{"sha": "c89db538aa6d395e642a3e5a1bc983ae3b8a4f3c", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n-use rustc_infer::traits::Obligation;\n+use rustc_infer::traits::{Obligation, TraitEngineExt as _};\n use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::stability::EvalResult;\n@@ -28,7 +28,7 @@ use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCtxt};\n+use rustc_trait_selection::traits::{self, ObligationCtxt, TraitEngine, TraitEngineExt as _};\n \n use std::ops::ControlFlow;\n \n@@ -1460,7 +1460,8 @@ fn opaque_type_cycle_error(\n                 for def_id in visitor.opaques {\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n-                        err.span_label(ty_span, &format!(\"returning this opaque type `{ty}`\"));\n+                        let descr = if ty.is_impl_trait() { \"opaque \" } else { \"\" };\n+                        err.span_label(ty_span, &format!(\"returning this {descr}type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n                     err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n@@ -1507,3 +1508,34 @@ fn opaque_type_cycle_error(\n     }\n     err.emit()\n }\n+\n+pub(super) fn check_generator_obligations(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    debug_assert!(tcx.sess.opts.unstable_opts.drop_tracking_mir);\n+    debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Generator));\n+\n+    let typeck = tcx.typeck(def_id);\n+    let param_env = tcx.param_env(def_id);\n+\n+    let generator_interior_predicates = &typeck.generator_interior_predicates[&def_id];\n+    debug!(?generator_interior_predicates);\n+\n+    let infcx = tcx\n+        .infer_ctxt()\n+        // typeck writeback gives us predicates with their regions erased.\n+        // As borrowck already has checked lifetimes, we do not need to do it again.\n+        .ignoring_regions()\n+        // Bind opaque types to `def_id` as they should have been checked by borrowck.\n+        .with_opaque_type_inference(DefiningAnchor::Bind(def_id))\n+        .build();\n+\n+    let mut fulfillment_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+    for (predicate, cause) in generator_interior_predicates {\n+        let obligation = Obligation::new(tcx, cause.clone(), param_env, *predicate);\n+        fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n+    let errors = fulfillment_cx.select_all_or_error(&infcx);\n+    debug!(?errors);\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+    }\n+}"}, {"sha": "bec693439a46c1d26a3ec9ba2753d71d9f75fe64", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -105,6 +105,7 @@ pub fn provide(providers: &mut Providers) {\n         region_scope_tree,\n         collect_return_position_impl_trait_in_trait_tys,\n         compare_impl_const: compare_impl_item::compare_impl_const_raw,\n+        check_generator_obligations: check::check_generator_obligations,\n         ..*providers\n     };\n }"}, {"sha": "17f736475dd37e0d7e4d5d3599ae4d0a8e52888f", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -130,7 +130,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n         let interior = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n+        fcx.deferred_generator_interiors.borrow_mut().push((fn_id, body.id(), interior, gen_kind));\n \n         let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n         Some(GeneratorTypes {"}, {"sha": "126355c5bfa27bc105b91be13138029ca4cc7ffb", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -517,10 +517,67 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n+        if self.tcx.sess.opts.unstable_opts.drop_tracking_mir {\n+            self.save_generator_interior_predicates(def_id);\n+            return;\n+        }\n+\n+        self.select_obligations_where_possible(|_| {});\n+\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n-        for (body_id, interior, kind) in generators.drain(..) {\n-            self.select_obligations_where_possible(|_| {});\n+        for (_, body_id, interior, kind) in generators.drain(..) {\n             crate::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n+            self.select_obligations_where_possible(|_| {});\n+        }\n+    }\n+\n+    /// Unify the inference variables corresponding to generator witnesses, and save all the\n+    /// predicates that were stalled on those inference variables.\n+    ///\n+    /// This process allows to conservatively save all predicates that do depend on the generator\n+    /// interior types, for later processing by `check_generator_obligations`.\n+    ///\n+    /// We must not attempt to select obligations after this method has run, or risk query cycle\n+    /// ICE.\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn save_generator_interior_predicates(&self, def_id: DefId) {\n+        // Try selecting all obligations that are not blocked on inference variables.\n+        // Once we start unifying generator witnesses, trying to select obligations on them will\n+        // trigger query cycle ICEs, as doing so requires MIR.\n+        self.select_obligations_where_possible(|_| {});\n+\n+        let generators = std::mem::take(&mut *self.deferred_generator_interiors.borrow_mut());\n+        debug!(?generators);\n+\n+        for &(expr_hir_id, body_id, interior, _) in generators.iter() {\n+            let expr_def_id = self.tcx.hir().local_def_id(expr_hir_id);\n+            debug!(?expr_def_id);\n+\n+            // Create the `GeneratorWitness` type that we will unify with `interior`.\n+            let substs = ty::InternalSubsts::identity_for_item(\n+                self.tcx,\n+                self.tcx.typeck_root_def_id(expr_def_id.to_def_id()),\n+            );\n+            let witness = self.tcx.mk_generator_witness_mir(expr_def_id.to_def_id(), substs);\n+\n+            // Unify `interior` with `witness` and collect all the resulting obligations.\n+            let span = self.tcx.hir().body(body_id).value.span;\n+            let ok = self\n+                .at(&self.misc(span), self.param_env)\n+                .eq(interior, witness)\n+                .expect(\"Failed to unify generator interior type\");\n+            let mut obligations = ok.obligations;\n+\n+            // Also collect the obligations that were unstalled by this unification.\n+            obligations\n+                .extend(self.fulfillment_cx.borrow_mut().drain_unstalled_obligations(&self.infcx));\n+\n+            let obligations = obligations.into_iter().map(|o| (o.predicate, o.cause)).collect();\n+            debug!(?obligations);\n+            self.typeck_results\n+                .borrow_mut()\n+                .generator_interior_predicates\n+                .insert(expr_def_id, obligations);\n         }\n     }\n "}, {"sha": "c6ce2f450d915111ac72ef90bdbd3c1a4a002f7d", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -56,7 +56,7 @@ pub struct Inherited<'tcx> {\n     pub(super) deferred_asm_checks: RefCell<Vec<(&'tcx hir::InlineAsm<'tcx>, hir::HirId)>>,\n \n     pub(super) deferred_generator_interiors:\n-        RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n+        RefCell<Vec<(hir::HirId, hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n     pub(super) body_id: Option<hir::BodyId>,\n "}, {"sha": "323bacf70ab9ca911b5f34c5619eb6c41b0828d6", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -294,7 +294,6 @@ fn typeck_with_fallback<'tcx>(\n         // Before the generator analysis, temporary scopes shall be marked to provide more\n         // precise information on types to be captured.\n         fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n \n         for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n             let ty = fcx.normalize(span, ty);\n@@ -303,6 +302,13 @@ fn typeck_with_fallback<'tcx>(\n \n         fcx.select_obligations_where_possible(|_| {});\n \n+        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+\n+        // This must be the last thing before `report_ambiguity_errors`.\n+        fcx.resolve_generator_interiors(def_id.to_def_id());\n+\n+        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+\n         if let None = fcx.infcx.tainted_by_errors() {\n             fcx.report_ambiguity_errors();\n         }"}, {"sha": "20d6ce5ed516d684440630f7140a58475f0e3e95", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -545,6 +545,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         self.typeck_results.generator_interior_types =\n             fcx_typeck_results.generator_interior_types.clone();\n+        for (&expr_def_id, predicates) in fcx_typeck_results.generator_interior_predicates.iter() {\n+            let predicates = self.resolve(predicates.clone(), &self.fcx.tcx.def_span(expr_def_id));\n+            self.typeck_results.generator_interior_predicates.insert(expr_def_id, predicates);\n+        }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "ef2fee02e083eb81881f8ec623e06e2f5182263d", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -41,6 +41,14 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     fn collect_remaining_errors(&mut self) -> Vec<FulfillmentError<'tcx>>;\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n+\n+    /// Among all pending obligations, collect those are stalled on a inference variable which has\n+    /// changed since the last call to `select_where_possible`.  Those obligations are marked as\n+    /// successful and returned.\n+    fn drain_unstalled_obligations(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+    ) -> Vec<PredicateObligation<'tcx>>;\n }\n \n pub trait TraitEngineExt<'tcx> {"}, {"sha": "60b60edd2c8119a9a2cfb1d2377356a8e3fa0275", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -893,6 +893,15 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n         }\n     });\n \n+    if tcx.sess.opts.unstable_opts.drop_tracking_mir {\n+        tcx.hir().par_body_owners(|def_id| {\n+            if let rustc_hir::def::DefKind::Generator = tcx.def_kind(def_id) {\n+                tcx.ensure().mir_generator_witnesses(def_id);\n+                tcx.ensure().check_generator_obligations(def_id);\n+            }\n+        });\n+    }\n+\n     sess.time(\"layout_testing\", || layout_test::test_layout(tcx));\n \n     // Avoid overwhelming user with errors if borrow checking failed."}, {"sha": "e4df309e0089bb59eb4513264aeae2654ce8cecb", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -478,6 +478,10 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query check_generator_obligations(key: LocalDefId) {\n+        desc { |tcx| \"verify auto trait bounds for generator interior type `{}`\", tcx.def_path_str(key.to_def_id()) }\n+    }\n+\n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n     query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {"}, {"sha": "79a6c730d7159a5abcbf323ae029566c709952e6", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -1,6 +1,7 @@\n use crate::{\n     hir::place::Place as HirPlace,\n     infer::canonical::Canonical,\n+    traits::ObligationCause,\n     ty::{\n         self, tls, BindingMode, BoundVar, CanonicalPolyFnSig, ClosureSizeProfileData,\n         GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n@@ -193,6 +194,11 @@ pub struct TypeckResults<'tcx> {\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n \n+    /// Stores the predicates that apply on generator witness types.\n+    /// formatting modified file tests/ui/generator/retain-resume-ref.rs\n+    pub generator_interior_predicates:\n+        FxHashMap<LocalDefId, Vec<(ty::Predicate<'tcx>, ObligationCause<'tcx>)>>,\n+\n     /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n     /// as `&[u8]`, depending on the pattern in which they are used.\n     /// This hashset records all instances where we behave\n@@ -271,6 +277,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             closure_fake_reads: Default::default(),\n             rvalue_scopes: Default::default(),\n             generator_interior_types: ty::Binder::dummy(Default::default()),\n+            generator_interior_predicates: Default::default(),\n             treat_byte_string_as_slice: Default::default(),\n             closure_size_eval: Default::default(),\n         }"}, {"sha": "ce87931dbea02461dd0200edcc69c508512a320f", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -615,6 +615,36 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Return the set of types that should be taken into accound when checking\n+    /// trait bounds on a generator's internal state.\n+    pub fn generator_hidden_types(\n+        self,\n+        def_id: DefId,\n+    ) -> impl Iterator<Item = ty::EarlyBinder<Ty<'tcx>>> {\n+        let generator_layout = &self.mir_generator_witnesses(def_id);\n+        generator_layout\n+            .field_tys\n+            .iter()\n+            .filter(|decl| !decl.is_static_ptr)\n+            .map(|decl| ty::EarlyBinder(decl.ty))\n+    }\n+\n+    /// Normalizes all opaque types in the given value, replacing them\n+    /// with their underlying types.\n+    pub fn expand_opaque_types(self, val: Ty<'tcx>) -> Ty<'tcx> {\n+        let mut visitor = OpaqueTypeExpander {\n+            seen_opaque_tys: FxHashSet::default(),\n+            expanded_cache: FxHashMap::default(),\n+            primary_def_id: None,\n+            found_recursion: false,\n+            found_any_recursion: false,\n+            check_recursion: false,\n+            expand_generators: false,\n+            tcx: self,\n+        };\n+        val.fold_with(&mut visitor)\n+    }\n+\n     /// Expands the given impl trait type, stopping if the type is recursive.\n     #[instrument(skip(self), level = \"debug\", ret)]\n     pub fn try_expand_impl_trait_type(\n@@ -629,6 +659,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             found_recursion: false,\n             found_any_recursion: false,\n             check_recursion: true,\n+            expand_generators: true,\n             tcx: self,\n         };\n \n@@ -741,6 +772,7 @@ struct OpaqueTypeExpander<'tcx> {\n     primary_def_id: Option<DefId>,\n     found_recursion: bool,\n     found_any_recursion: bool,\n+    expand_generators: bool,\n     /// Whether or not to check for recursive opaque types.\n     /// This is `true` when we're explicitly checking for opaque type\n     /// recursion, and 'false' otherwise to avoid unnecessary work.\n@@ -777,6 +809,37 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n             None\n         }\n     }\n+\n+    fn expand_generator(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) -> Option<Ty<'tcx>> {\n+        if self.found_any_recursion {\n+            return None;\n+        }\n+        let substs = substs.fold_with(self);\n+        if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n+            let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n+                Some(expanded_ty) => *expanded_ty,\n+                None => {\n+                    for bty in self.tcx.generator_hidden_types(def_id) {\n+                        let hidden_ty = bty.subst(self.tcx, substs);\n+                        self.fold_ty(hidden_ty);\n+                    }\n+                    let expanded_ty = self.tcx.mk_generator_witness_mir(def_id, substs);\n+                    self.expanded_cache.insert((def_id, substs), expanded_ty);\n+                    expanded_ty\n+                }\n+            };\n+            if self.check_recursion {\n+                self.seen_opaque_tys.remove(&def_id);\n+            }\n+            Some(expanded_ty)\n+        } else {\n+            // If another opaque type that we contain is recursive, then it\n+            // will report the error, so we don't have to.\n+            self.found_any_recursion = true;\n+            self.found_recursion = def_id == *self.primary_def_id.as_ref().unwrap();\n+            None\n+        }\n+    }\n }\n \n impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n@@ -785,13 +848,19 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) = *t.kind() {\n+        let mut t = if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) = *t.kind() {\n             self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n-        } else if t.has_opaque_types() {\n+        } else if t.has_opaque_types() || t.has_generators() {\n             t.super_fold_with(self)\n         } else {\n             t\n+        };\n+        if self.expand_generators {\n+            if let ty::GeneratorWitnessMIR(def_id, substs) = *t.kind() {\n+                t = self.expand_generator(def_id, substs).unwrap_or(t);\n+            }\n         }\n+        t\n     }\n }\n \n@@ -1299,6 +1368,7 @@ pub fn reveal_opaque_types_in_bounds<'tcx>(\n         found_recursion: false,\n         found_any_recursion: false,\n         check_recursion: false,\n+        expand_generators: false,\n         tcx,\n     };\n     val.fold_with(&mut visitor)"}, {"sha": "a2c15123b4fbd7cbb7e818c0bf6859f76ee845cb", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -139,4 +139,11 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.clone()\n     }\n+\n+    fn drain_unstalled_obligations(\n+        &mut self,\n+        _: &InferCtxt<'tcx>,\n+    ) -> Vec<PredicateObligation<'tcx>> {\n+        unimplemented!()\n+    }\n }"}, {"sha": "e26bef0b8b7f5c11266b62ae0083304b82580d9a", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -135,6 +135,13 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         errors\n     }\n \n+    fn drain_unstalled_obligations(\n+        &mut self,\n+        _: &InferCtxt<'tcx>,\n+    ) -> Vec<PredicateObligation<'tcx>> {\n+        unimplemented!()\n+    }\n+\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.iter().cloned().collect()\n     }"}, {"sha": "827806442d2da2a3c2b0b9eb8eaa857c9f8f4078", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -2226,7 +2226,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     );\n \n                     match *ty.kind() {\n-                        ty::Generator(did, ..) => {\n+                        ty::Generator(did, ..) | ty::GeneratorWitnessMIR(did, _) => {\n                             generator = generator.or(Some(did));\n                             outer_generator = Some(did);\n                         }\n@@ -2256,7 +2256,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     );\n \n                     match *ty.kind() {\n-                        ty::Generator(did, ..) => {\n+                        ty::Generator(did, ..) | ty::GeneratorWitnessMIR(did, ..) => {\n                             generator = generator.or(Some(did));\n                             outer_generator = Some(did);\n                         }\n@@ -2345,6 +2345,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             _ => return false,\n         };\n \n+        let generator_within_in_progress_typeck = match &self.typeck_results {\n+            Some(t) => t.hir_owner.to_def_id() == generator_did_root,\n+            _ => false,\n+        };\n+\n         let mut interior_or_upvar_span = None;\n \n         let from_awaited_ty = generator_data.get_from_await_ty(visitor, hir, ty_matches);\n@@ -2364,6 +2369,35 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 *span,\n                 Some((*scope_span, *yield_span, *expr, from_awaited_ty)),\n             ));\n+\n+            if interior_or_upvar_span.is_none() && generator_data.is_foreign() {\n+                interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(*span, None));\n+            }\n+        } else if self.tcx.sess.opts.unstable_opts.drop_tracking_mir\n+            // Avoid disclosing internal information to downstream crates.\n+            && generator_did.is_local()\n+            // Try to avoid cycles.\n+            && !generator_within_in_progress_typeck\n+        {\n+            let generator_info = &self.tcx.mir_generator_witnesses(generator_did);\n+            debug!(?generator_info);\n+\n+            'find_source: for (variant, source_info) in\n+                generator_info.variant_fields.iter().zip(&generator_info.variant_source_info)\n+            {\n+                debug!(?variant);\n+                for &local in variant {\n+                    let decl = &generator_info.field_tys[local];\n+                    debug!(?decl);\n+                    if ty_matches(ty::Binder::dummy(decl.ty)) && !decl.is_static_ptr {\n+                        interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(\n+                            decl.source_info.span,\n+                            Some((None, source_info.span, None, from_awaited_ty)),\n+                        ));\n+                        break 'find_source;\n+                    }\n+                }\n+            }\n         }\n \n         if interior_or_upvar_span.is_none() {\n@@ -3012,6 +3046,20 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 }\n                                 err.note(msg.trim_end_matches(\", \"))\n                             }\n+                            ty::GeneratorWitnessMIR(def_id, substs) => {\n+                                use std::fmt::Write;\n+\n+                                // FIXME: this is kind of an unusual format for rustc, can we make it more clear?\n+                                // Maybe we should just remove this note altogether?\n+                                // FIXME: only print types which don't meet the trait requirement\n+                                let mut msg =\n+                                    \"required because it captures the following types: \".to_owned();\n+                                for bty in tcx.generator_hidden_types(*def_id) {\n+                                    let ty = bty.subst(tcx, substs);\n+                                    write!(msg, \"`{}`, \", ty).unwrap();\n+                                }\n+                                err.note(msg.trim_end_matches(\", \"))\n+                            }\n                             ty::Generator(def_id, _, _) => {\n                                 let sp = self.tcx.def_span(def_id);\n "}, {"sha": "6c18bf8d22df830235169bac1a2ca38614cf8ce4", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -141,6 +141,55 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         self.select(selcx)\n     }\n \n+    fn drain_unstalled_obligations(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+    ) -> Vec<PredicateObligation<'tcx>> {\n+        let mut processor = DrainProcessor { removed_predicates: Vec::new(), infcx };\n+        let outcome: Outcome<_, _> = self.predicates.process_obligations(&mut processor);\n+        assert!(outcome.errors.is_empty());\n+        return processor.removed_predicates;\n+\n+        struct DrainProcessor<'a, 'tcx> {\n+            infcx: &'a InferCtxt<'tcx>,\n+            removed_predicates: Vec<PredicateObligation<'tcx>>,\n+        }\n+\n+        impl<'tcx> ObligationProcessor for DrainProcessor<'_, 'tcx> {\n+            type Obligation = PendingPredicateObligation<'tcx>;\n+            type Error = !;\n+            type OUT = Outcome<Self::Obligation, Self::Error>;\n+\n+            fn needs_process_obligation(&self, pending_obligation: &Self::Obligation) -> bool {\n+                pending_obligation\n+                    .stalled_on\n+                    .iter()\n+                    .any(|&var| self.infcx.ty_or_const_infer_var_changed(var))\n+            }\n+\n+            fn process_obligation(\n+                &mut self,\n+                pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+            ) -> ProcessResult<PendingPredicateObligation<'tcx>, !> {\n+                assert!(self.needs_process_obligation(pending_obligation));\n+                self.removed_predicates.push(pending_obligation.obligation.clone());\n+                ProcessResult::Changed(vec![])\n+            }\n+\n+            fn process_backedge<'c, I>(\n+                &mut self,\n+                cycle: I,\n+                _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>,\n+            ) -> Result<(), !>\n+            where\n+                I: Clone + Iterator<Item = &'c PendingPredicateObligation<'tcx>>,\n+            {\n+                self.removed_predicates.extend(cycle.map(|c| c.obligation.clone()));\n+                Ok(())\n+            }\n+        }\n+    }\n+\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.predicates.map_pending_obligations(|o| o.obligation.clone())\n     }"}, {"sha": "61d3531cfc44e71d4008c900f4e665256e1f60ee", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -13,7 +13,7 @@ use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_middle::ty::{\n     self, Binder, GenericArg, GenericArgKind, GenericParamDefKind, InternalSubsts, SubstsRef,\n-    ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt,\n+    ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeVisitable,\n };\n use rustc_session::config::TraitSolver;\n use rustc_span::def_id::DefId;\n@@ -1285,8 +1285,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::GeneratorWitness(tys) => {\n                     stack.extend(tcx.erase_late_bound_regions(tys).to_vec());\n                 }\n-                ty::GeneratorWitnessMIR(..) => {\n-                    todo!()\n+                ty::GeneratorWitnessMIR(def_id, substs) => {\n+                    let tcx = self.tcx();\n+                    stack.extend(tcx.generator_hidden_types(def_id).map(|bty| {\n+                        let ty = bty.subst(tcx, substs);\n+                        debug_assert!(!ty.has_late_bound_regions());\n+                        ty\n+                    }))\n                 }\n \n                 // If we have a projection type, make sure to normalize it so we replace it"}, {"sha": "efd21b979ceb58289dfc7933dd5145841bda46d7", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e04d1e8c3afd392551db103651e0ac55b4bd7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=60e04d1e8c3afd392551db103651e0ac55b4bd7e", "patch": "@@ -2183,8 +2183,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Where(ty::Binder::bind_with_vars(witness_tys.to_vec(), all_vars))\n             }\n \n-            ty::GeneratorWitnessMIR(..) => {\n-                todo!()\n+            ty::GeneratorWitnessMIR(def_id, ref substs) => {\n+                let hidden_types = bind_generator_hidden_types_above(\n+                    self.infcx,\n+                    def_id,\n+                    substs,\n+                    obligation.predicate.bound_vars(),\n+                );\n+                Where(hidden_types)\n             }\n \n             ty::Closure(_, substs) => {\n@@ -2284,8 +2290,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 types.map_bound(|types| types.to_vec())\n             }\n \n-            ty::GeneratorWitnessMIR(..) => {\n-                todo!()\n+            ty::GeneratorWitnessMIR(def_id, ref substs) => {\n+                bind_generator_hidden_types_above(self.infcx, def_id, substs, t.bound_vars())\n             }\n \n             // For `PhantomData<T>`, we pass `T`.\n@@ -2930,3 +2936,56 @@ pub enum ProjectionMatchesProjection {\n     Ambiguous,\n     No,\n }\n+\n+/// Replace all regions inside the generator interior with late bound regions.\n+/// Note that each region slot in the types gets a new fresh late bound region, which means that\n+/// none of the regions inside relate to any other, even if typeck had previously found constraints\n+/// that would cause them to be related.\n+#[instrument(level = \"trace\", skip(infcx), ret)]\n+fn bind_generator_hidden_types_above<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: ty::SubstsRef<'tcx>,\n+    bound_vars: &ty::List<ty::BoundVariableKind>,\n+) -> ty::Binder<'tcx, Vec<Ty<'tcx>>> {\n+    let tcx = infcx.tcx;\n+    let mut seen_tys = FxHashSet::default();\n+\n+    let considering_regions = infcx.considering_regions;\n+\n+    let num_bound_variables = bound_vars.len() as u32;\n+    let mut counter = num_bound_variables;\n+\n+    let hidden_types: Vec<_> = tcx\n+        .generator_hidden_types(def_id)\n+        // Deduplicate tys to avoid repeated work.\n+        .filter(|bty| seen_tys.insert(*bty))\n+        .map(|bty| {\n+            let mut ty = bty.subst(tcx, substs);\n+\n+            // Only remap erased regions if we use them.\n+            if considering_regions {\n+                ty = tcx.fold_regions(ty, |mut r, current_depth| {\n+                    if let ty::ReErased = r.kind() {\n+                        let br = ty::BoundRegion {\n+                            var: ty::BoundVar::from_u32(counter),\n+                            kind: ty::BrAnon(counter, None),\n+                        };\n+                        counter += 1;\n+                        r = tcx.mk_region(ty::ReLateBound(current_depth, br));\n+                    }\n+                    r\n+                })\n+            }\n+\n+            ty\n+        })\n+        .collect();\n+    if considering_regions {\n+        debug_assert!(!hidden_types.has_erased_regions());\n+    }\n+    let bound_vars = tcx.mk_bound_variable_kinds(bound_vars.iter().chain(\n+        (num_bound_variables..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i, None))),\n+    ));\n+    ty::Binder::bind_with_vars(hidden_types, bound_vars)\n+}"}]}