{"sha": "698c6406ba0f132eb67ba210dac9c52e622742c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OGM2NDA2YmEwZjEzMmViNjdiYTIxMGRhYzljNTJlNjIyNzQyYzM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-11T02:12:42Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-11T02:17:15Z"}, "message": "Reject programs with unsatisfied predicate constraints\n\nGenerate appropriate constraints for calls to functions with\npreconditions, and reject calls where those constraints don't\nhold true in the prestate.\n\n...by which I mean that it works for one test case :-)", "tree": {"sha": "94777575279d2bd87ed5b3e938ffd6a5af43ba5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94777575279d2bd87ed5b3e938ffd6a5af43ba5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/698c6406ba0f132eb67ba210dac9c52e622742c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/698c6406ba0f132eb67ba210dac9c52e622742c3", "html_url": "https://github.com/rust-lang/rust/commit/698c6406ba0f132eb67ba210dac9c52e622742c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/698c6406ba0f132eb67ba210dac9c52e622742c3/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1bc2b17cc3cc8fcbcaff8bc7b552c93752af2b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1bc2b17cc3cc8fcbcaff8bc7b552c93752af2b2", "html_url": "https://github.com/rust-lang/rust/commit/a1bc2b17cc3cc8fcbcaff8bc7b552c93752af2b2"}], "stats": {"total": 509, "additions": 309, "deletions": 200}, "files": [{"sha": "8a2e638461837431a86a8100e26a252d18d94c9d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -355,14 +355,31 @@ tag ty_ {\n     ty_constr(@ty, vec[@constr]);\n }\n \n-tag constr_arg_ {\n+/*\n+A constraint arg that's a function argument is referred to by its position\n+rather than name.  This is so we could have higher-order functions that have\n+constraints (potentially -- right now there's no way to write that), and also\n+so that the typestate pass doesn't have to map a function name onto its decl.\n+So, the constr_arg type is parameterized: it's instantiated with uint for\n+declarations, and ident for uses.\n+*/\n+tag constr_arg_general_[T] {\n     carg_base;\n-    carg_ident(ident);\n+    carg_ident(T); \n     carg_lit(@lit);\n }\n-type constr_arg = spanned[constr_arg_];\n-type constr_ = rec(path path, vec[@constr_arg] args);\n-type constr = spanned[constr_];\n+type constr_arg = constr_arg_general[uint];\n+type constr_arg_use = constr_arg_general[ident];\n+type constr_arg_general[T] = spanned[constr_arg_general_[T]];\n+\n+// The ann field is there so that using the def_map in the type\n+// context, we can get the def_id for the path.\n+type constr_general[T] = rec(path path,\n+                             vec[@constr_arg_general[T]] args,\n+                             ann ann);\n+\n+type constr = spanned[constr_general[uint]];\n+type constr_use = spanned[constr_general[ident]];\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n type fn_decl = rec(vec[arg] inputs,"}, {"sha": "8d85714f7e408da798d9fb83f967910cf8af0aed", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -94,6 +94,9 @@ fn parse_constrs(@pstate st, str_def sd) -> vec[@ast::constr] {\n }\n \n fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n+    st.tcx.sess.unimpl(\"Reading constraints \"\n+                   + \" isn't implemented\");\n+    /*\n     let vec[@ast::constr_arg] args = [];\n     auto sp = rec(lo=0u,hi=0u); // FIXME\n     let vec[ast::ident] ids = [];\n@@ -105,6 +108,7 @@ fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n     log_err(p1);\n     let char ignore = next(st) as char;\n     assert(ignore as char == '(');\n+    auto def = parse_def(st, sd);\n     do {\n         alt (peek(st) as char) {\n             case ('*') {\n@@ -132,7 +136,7 @@ fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n         }\n     } while (next(st) as char == ',');\n     ignore = next(st) as char;\n-    ret @respan(sp, rec(path=pth, args=args));\n+    */\n }\n \n fn parse_ty(@pstate st, str_def sd) -> ty::t {"}, {"sha": "91d613a528304bd0bab03a29b8f6b38e6589706c", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -339,7 +339,7 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n     auto inputs = parse_seq(token::LPAREN, token::RPAREN,\n                             some(token::COMMA), parse_fn_input_ty, p);\n \n-    auto constrs = parse_constrs(p);\n+    auto constrs = parse_constrs([], p);\n \n     let @ast::ty output;\n     auto cf = ast::return;\n@@ -409,35 +409,57 @@ fn parse_ty_field(&parser p) -> ast::ty_field {\n     ret spanned(lo, mt.ty.span.hi, rec(ident=id, mt=mt));\n }\n \n-fn parse_constr_arg(&parser p) -> @ast::constr_arg {\n+// if i is the jth ident in args, return j\n+// otherwise, fail\n+fn ident_index(&parser p, &vec[ast::arg] args, &ast::ident i) -> uint {\n+    auto j = 0u;\n+    for (ast::arg a in args) {\n+        if (a.ident == i) {\n+            ret j;\n+        }\n+        j += 1u;\n+    }\n+    p.get_session().span_err(p.get_span(),\n+      \"Unbound variable \" + i + \" in constraint arg\");\n+}\n+\n+fn parse_constr_arg(vec[ast::arg] args, &parser p) -> @ast::constr_arg {\n     auto sp = p.get_span();\n     auto carg = ast::carg_base;\n     if (p.peek() == token::BINOP(token::STAR)) {\n         p.bump();\n     } else {\n-        carg = ast::carg_ident(parse_value_ident(p));\n+        let ast::ident i = parse_value_ident(p);\n+        carg = ast::carg_ident(ident_index(p, args, i));\n     }\n     ret @rec(node=carg, span=sp);\n }\n \n-fn parse_ty_constr(&parser p) -> @ast::constr {\n+fn parse_ty_constr(&vec[ast::arg] fn_args, &parser p) -> @ast::constr {\n     auto lo = p.get_lo_pos();\n     auto path = parse_path(p);\n-    auto pf = parse_constr_arg;\n-    auto args = parse_seq[@ast::constr_arg](token::LPAREN,\n+    auto pf = bind parse_constr_arg(fn_args, _);\n+    let rec(vec[@ast::constr_arg] node, span span) args =\n+         parse_seq[@ast::constr_arg](token::LPAREN,\n                                          token::RPAREN,\n                                          some(token::COMMA), pf, p);\n-    ret @spanned(lo, args.span.hi, rec(path=path, args=args.node));\n+    // FIXME fix the def_id\n+    ret @spanned(lo, args.span.hi,\n+                 rec(path=path, args=args.node, ann=p.get_ann()));\n }\n \n-fn parse_constrs(&parser p) -> common::spanned[vec[@ast::constr]] {\n+// Use the args list to translate each bound variable \n+// mentioned in a constraint to an arg index.\n+// Seems weird to do this in the parser, but I'm not sure how else to.\n+fn parse_constrs(&vec[ast::arg] args, \n+                 &parser p) -> common::spanned[vec[@ast::constr]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     let vec[@ast::constr] constrs = [];\n     if (p.peek() == token::COLON) {\n         p.bump();\n         while (true) {\n-            auto constr = parse_ty_constr(p);\n+            auto constr = parse_ty_constr(args, p);\n             hi = constr.span.hi;\n             vec::push[@ast::constr](constrs, constr);\n             if (p.peek() == token::COMMA) {\n@@ -452,7 +474,7 @@ fn parse_constrs(&parser p) -> common::spanned[vec[@ast::constr]] {\n \n fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n    if (p.peek() == token::COLON) {\n-       auto constrs = parse_constrs(p);\n+       auto constrs = parse_constrs([], p);\n        ret @spanned(t.span.lo, constrs.span.hi,\n                     ast::ty_constr(t, constrs.node));\n    }\n@@ -1768,7 +1790,7 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n \n     let ty_or_bang res;\n \n-    auto constrs = parse_constrs(p).node;\n+    auto constrs = parse_constrs(inputs.node, p).node;\n \n     if (p.peek() == token::RARROW) {\n         p.bump();"}, {"sha": "07293e0a306fa86932938a51705b00de7384ee9c", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -286,6 +286,8 @@ mod Encode {\n     fn enc_constr(&io::writer w, &@ctxt cx, &@ast::constr c) {\n         w.write_str(path_to_str(c.node.path));\n         w.write_char('(');\n+        // FIXME\n+        //   w.write_str(cx.ds(c.node.id));\n         auto comma = false;\n         for (@constr_arg a in c.node.args) {\n             if (comma) {\n@@ -299,7 +301,7 @@ mod Encode {\n                     w.write_char('*');\n                 }\n                 case (carg_ident(?i)) {\n-                    w.write_str(i);\n+                    w.write_uint(i);\n                 }\n                 case (carg_lit(?l)) {\n                     w.write_str(lit_to_str(l));"}, {"sha": "8d00c4b55529385b47e24e230bcafa667e0b2ec9", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -254,7 +254,8 @@ fn resolve_names(&@env e, &@ast::crate c) {\n                   visit_arm = bind walk_arm(e, _, _, _),\n                   visit_expr = bind walk_expr(e, _, _, _),\n                   visit_ty = bind walk_ty(e, _, _, _),\n-                  visit_fn = visit_fn_with_scope\n+                  visit_fn = visit_fn_with_scope,\n+                  visit_constr = bind walk_constr(e, _, _, _)\n                   with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil),\n                        visit::vtor(v));\n@@ -270,6 +271,14 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) {}\n         }\n     }\n+\n+    fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n+        auto new_def = lookup_path_strict(*e, sc, c.span,\n+                                          c.node.path.node.idents,\n+                                          ns_value);\n+        e.def_map.insert(c.node.ann.id, new_def);\n+    }\n+\n     fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {"}, {"sha": "d5d48bd67f8bf0e01528f8e2d1edc758a5d9d918", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 79, "deletions": 85, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -51,10 +51,10 @@ fn def_id_to_str(def_id d) -> str {\n    ret (istr(d._0) + \",\" + istr(d._1));\n }\n \n-fn comma_str(vec[@constr_arg] args) -> str {\n+fn comma_str(vec[@constr_arg_use] args) -> str {\n     auto res = \"\";\n     auto comma = false;\n-    for (@constr_arg a in args) {\n+    for (@constr_arg_use a in args) {\n         if (comma) {\n             res += \", \";\n         }\n@@ -78,10 +78,10 @@ fn comma_str(vec[@constr_arg] args) -> str {\n \n fn constraint_to_str(ty::ctxt tcx, constr c) -> str {\n     alt (c.node) {\n-        case (ninit(?i)) {\n+        case (ninit(?i, _)) {\n             ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n         }\n-        case (npred(?p, ?args)) {\n+        case (npred(?p, _, ?args)) {\n             ret path_to_str(p) + \"(\" + comma_str(args) + \")\"\n                 + \"[\" + tcx.sess.span_str(c.span) + \"]\";\n         }\n@@ -211,16 +211,18 @@ fn print_idents(vec[ident] idents) -> () {\n /* mapping from def_id to bit number and other data\n    (ident/path/span are there for error-logging purposes) */\n \n-type pred_desc_ = rec(vec[@constr_arg] args,\n+/* FIXME very confused about why we have all these different types. */\n+\n+type pred_desc_ = rec(vec[@constr_arg_use] args,\n                       uint bit_num);\n type pred_desc = spanned[pred_desc_];\n tag constraint {\n-    cinit(uint, span, ident);\n-    cpred(path, @mutable vec[pred_desc]);\n+    cinit(uint, span, def_id, ident);\n+    cpred(path, def_id, @mutable vec[pred_desc]);\n }\n tag constr_ {\n-    ninit(ident);\n-    npred(path, vec[@constr_arg]);\n+    ninit(ident, def_id);\n+    npred(path, def_id, vec[@constr_arg_use]);\n }\n type constr = spanned[constr_];\n type norm_constraint = rec(uint bit_num,\n@@ -231,11 +233,18 @@ type norm_constraint = rec(uint bit_num,\n    a pred. */\n tag constr_occ {\n     occ_init;\n-    occ_args(vec[@constr_arg]);\n+    occ_args(vec[@constr_arg_use]);\n }\n    \n type constr_map = @std::map::hashmap[def_id, constraint];\n \n+fn constr_id(&constr c) -> def_id {\n+    ret (alt (c.node) {\n+            case (ninit(_, ?i))    { i }\n+            case (npred(_, ?i, _)) { i }\n+        })\n+}\n+\n type fn_info  = rec(constr_map constrs, uint num_constraints, controlflow cf);\n \n /* mapping from node ID to typestate annotation */\n@@ -495,8 +504,8 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     }\n }\n \n-fn constraints_expr(&crate_ctxt ccx, @expr e) -> vec[@ast::constr] {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, expr_ann(e)))) {\n+fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ast::constr] {\n+    alt (ty::struct(cx, ty::ann_to_type(cx, expr_ann(e)))) {\n         case (ty::ty_fn(_,_,_,_,?cs)) {\n             ret cs;\n         }\n@@ -506,8 +515,8 @@ fn constraints_expr(&crate_ctxt ccx, @expr e) -> vec[@ast::constr] {\n     }\n }\n \n-fn ann_to_def_strict(&crate_ctxt ccx, &ann a) -> def {\n-    alt (ccx.tcx.def_map.find(a.id)) {\n+fn ann_to_def_strict(&ty::ctxt cx, &ann a) -> def {\n+    alt (cx.def_map.find(a.id)) {\n         case (none) { \n             log_err(\"ann_to_def: node_id \" + uistr(a.id) + \" has no def\");\n             fail;\n@@ -522,14 +531,14 @@ fn ann_to_def(&crate_ctxt ccx, &ann a) -> option::t[def] {\n \n fn norm_a_constraint(&constraint c) -> vec[norm_constraint] {\n     alt (c) {\n-        case (cinit(?n, ?sp, ?i)) {\n-            ret [rec(bit_num=n, c=respan(sp, ninit(i)))];\n+        case (cinit(?n, ?sp, ?id, ?i)) {\n+            ret [rec(bit_num=n, c=respan(sp, ninit(i, id)))];\n         }\n-        case (cpred(?p, ?descs)) {\n+        case (cpred(?p, ?id, ?descs)) {\n             let vec[norm_constraint] res = [];\n             for (pred_desc pd in *descs) {\n                 vec::push(res, rec(bit_num=pd.node.bit_num,\n-                  c=respan(pd.span, npred(p, pd.node.args))));\n+                  c=respan(pd.span, npred(p, id, pd.node.args))));\n             }\n             ret res;\n         }\n@@ -547,29 +556,26 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n     ret res;\n }\n \n-\n // FIXME:\n // this probably doesn't handle name shadowing well (or at all)\n // variables should really always be id'd by def_id and not ident\n fn match_args(&fn_ctxt fcx, vec[pred_desc] occs,\n-              vec[@constr_arg] occ) -> uint {\n-    log (\"match_args: looking at \" + constr_args_to_str(occ));\n+              vec[@constr_arg_use] occ) -> uint {\n+    log (\"match_args: looking at \" +\n+             pretty::ppaux::constr_args_to_str_1(occ));\n     for (pred_desc pd in occs) {\n         log (\"match_args: candidate \" + pred_desc_to_str(pd));\n-        if (ty::args_eq(pd.node.args, occ)) {\n+        if (ty::args_eq(str::eq, pd.node.args, occ)) {\n             ret pd.node.bit_num;\n         }\n     }\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");  \n }\n \n-\n-type constraint_info = rec(def_id id, constr c);\n-\n fn constr_to_constr_occ(&ty::ctxt tcx, &constr_ c) -> constr_occ {\n     alt (c) {\n-        case (ninit(_)) { ret occ_init; }\n-        case (npred(_, ?args)) { ret occ_args(args); }\n+        case (ninit(_, _)) { ret occ_init; }\n+        case (npred(_, _, ?args)) { ret occ_args(args); }\n     }\n }\n \n@@ -587,41 +593,42 @@ fn def_id_for_constr(ty::ctxt tcx, uint t) -> def_id {\n     }\n }\n \n-\n-fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args) -> vec[@constr_arg] {\n-    fn one(ty::ctxt tcx, &@expr e) -> @constr_arg {\n-        alt (e.node) {\n-            case (expr_path(?p, _)) {\n-                if (vec::len(p.node.idents) == 1u) {\n-                    ret @respan(p.span, carg_ident(p.node.idents.(0)));\n-                }\n-                else {\n-                    tcx.sess.bug(\"exprs_to_constr_args: non-local variable \"\n-                                 + \"as pred arg\");\n-                }\n-            }\n-            case (expr_lit(?l, _)) {\n-                ret @respan(e.span, carg_lit(l));\n+fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n+    alt (e.node) {\n+        case (expr_path(?p, _)) {\n+            if (vec::len(p.node.idents) == 1u) {\n+                ret @respan(p.span, carg_ident[ident](p.node.idents.(0)));\n             }\n-            case (_) {\n-                tcx.sess.bug(\"exprs_to_constr_args: ill-formed pred arg\");\n+            else {\n+                tcx.sess.bug(\"exprs_to_constr_args: non-local variable \"\n+                             + \"as pred arg\");\n             }\n         }\n+        case (expr_lit(?l, _)) {\n+            ret @respan(e.span, carg_lit(l));\n+        }\n+        case (_) {\n+            tcx.sess.bug(\"exprs_to_constr_args: ill-formed pred arg\");\n+        }\n     }\n-    auto f = bind one(tcx, _);\n+}\n+\n+fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args)\n+    -> vec[@constr_arg_use] {\n+    auto f = bind expr_to_constr_arg(tcx, _);\n     ret vec::map(f, args); \n }\n \n-fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constraint_info {\n+fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n     alt (e.node) {\n         // FIXME\n         // change the first pattern to expr_path to test a typechecker bug\n         case (expr_call(?operator, ?args, _)) {\n             alt (operator.node) {\n                 case (expr_path(?p, ?a)) {\n-                    ret rec(id=def_id_for_constr(tcx, a.id),\n-                            c=respan(e.span,\n-                                npred(p, exprs_to_constr_args(tcx, args)))); \n+                    ret respan(e.span,\n+                               npred(p, def_id_for_constr(tcx, a.id),\n+                                     exprs_to_constr_args(tcx, args))); \n                 }\n                 case (_) {\n                     tcx.sess.span_err(operator.span, \"Internal error: \" +\n@@ -638,55 +645,42 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constraint_info {\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n     ret (\"<\" + uistr(p.node.bit_num) + \", \" + \n-         constr_args_to_str(p.node.args) + \">\");\n+         pretty::ppaux::constr_args_to_str_1(p.node.args) + \">\");\n }\n \n-fn substitute_constr_args(&ty::ctxt cx,\n-                          &vec[@expr] actuals,\n-                          &vec[arg] formals, &@ast::constr c) -> constr_occ {\n-    let vec[@constr_arg] res = [];\n-    auto subst = vec::zip(formals, actuals);\n+fn substitute_constr_args_(&ty::ctxt cx,\n+                          &vec[@expr] actuals, &@ast::constr c)\n+    -> vec[@constr_arg_use] {\n+    let vec[@constr_arg_use] res = [];\n     for (@constr_arg a in c.node.args) {\n-        res += [substitute_arg(cx, subst, a)];\n+        res += [substitute_arg(cx, actuals, a)];\n     }\n-    ret occ_args(res);\n+    ret res;\n+\n+}\n+\n+fn substitute_constr_args(&ty::ctxt cx,\n+      &vec[@expr] actuals, &@ast::constr c) -> constr_occ {\n+    ret occ_args(substitute_constr_args_(cx, actuals, c));\n }\n \n type subst = vec[tup(arg, @expr)];\n \n-fn substitute_arg(&ty::ctxt cx, &subst subst, @ast::constr_arg a)\n-     -> @constr_arg {\n+fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a)\n+     -> @constr_arg_use {\n+    auto num_actuals = vec::len(actuals);\n     alt (a.node) {\n         case (carg_ident(?i)) {\n-            ret find_arg(a.span, cx, i, subst);\n-        }\n-        case (_) { ret a; }\n-    }\n-\n-}\n-\n-fn find_arg(&span sp, ty::ctxt cx, ident i, subst subst) -> @constr_arg {\n-    for (tup(arg, @expr) p in subst) {\n-        if (p._0.ident == i) {\n-            alt (p._1.node) {\n-                case (expr_path(?pt, _)) {\n-                    // ??? maybe should check that pt is a local?\n-                    let option::t[ident] thing = vec::last(pt.node.idents);\n-                    assert (! option::is_none(thing));\n-                    ret @respan(p._1.span, carg_ident(option::get(thing)));\n-                }\n-                case (expr_lit(?l, _)) {\n-                    ret @respan(p._1.span, carg_lit(l));\n-                }\n-                case (_) {\n-                    cx.sess.span_err(p._1.span,\n-                                     \"Unsupported form of argument \" +\n-                                     \"in a call to a constrained function\");\n-                }\n+            if (i < num_actuals) {\n+                ret expr_to_constr_arg(cx, actuals.(i));\n+            }\n+            else {\n+                cx.sess.span_err(a.span, \"Constraint argument out of bounds\");\n             }\n         }\n+        case (carg_base) { ret @respan(a.span, carg_base); }\n+        case (carg_lit(?l))  { ret @respan(a.span, carg_lit(l)); }\n     }\n-    cx.sess.span_err(sp, \"Constraint contains an unbound variable \" + i);\n }\n \n //"}, {"sha": "8ae65c5063fc38a820877fdc9e4fe2d986f9b649", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -41,7 +41,7 @@ fn bit_num(&fn_ctxt fcx, &def_id v, &constr_occ o) -> uint {\n     alt (o) {\n         case (occ_init) {\n             alt (res) {\n-                case (cinit(?n,_,_)) {\n+                case (cinit(?n,_,_,_)) {\n                     ret n;\n                 }\n                 case (_) {\n@@ -52,7 +52,7 @@ fn bit_num(&fn_ctxt fcx, &def_id v, &constr_occ o) -> uint {\n         }\n         case (occ_args(?args)) {\n             alt (res) {\n-                case (cpred(_, ?descs)) {\n+                case (cpred(_, _, ?descs)) {\n                     ret match_args(fcx, *descs, args);\n                 }\n                 case (_) {"}, {"sha": "1133596ffb770fd532f2e65ec970e7ffd6ac7d10", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -1,6 +1,7 @@\n import std::vec;\n import std::vec::plus_option;\n \n+import front::ast;\n import front::ast::*;\n import option::*;\n \n@@ -12,30 +13,30 @@ import aux::cinit;\n import aux::ninit;\n import aux::npred;\n import aux::cpred;\n+import aux::constr;\n import aux::constraint;\n import aux::fn_info;\n import aux::crate_ctxt;\n import aux::num_constraints;\n import aux::constr_map;\n-import aux::constraint_info;\n import aux::expr_to_constr;\n+import aux::constraints_expr;\n+import aux::ann_to_def_strict;\n \n import util::common::new_def_hash;\n import util::common::uistr;\n import util::common::span;\n import util::common::respan;\n \n-type ctxt = rec(@mutable vec[constraint_info] cs,\n+type ctxt = rec(@mutable vec[constr] cs,\n                 ty::ctxt tcx);\n \n fn collect_local(&ctxt cx, &@decl d) -> () {\n     alt (d.node) {\n       case (decl_local(?loc)) {\n         log(\"collect_local: pushing \" + loc.ident);\n-        vec::push[constraint_info](*cx.cs,\n-                                   rec(id=loc.id,\n-                                       c=respan(d.span,\n-                                                ninit(loc.ident))));\n+        vec::push[constr](*cx.cs, respan(d.span,\n+                                         ninit(loc.ident, loc.id)));\n       }\n       case (_) { ret; }\n     }\n@@ -44,15 +45,37 @@ fn collect_local(&ctxt cx, &@decl d) -> () {\n fn collect_pred(&ctxt cx, &@expr e) -> () {\n     alt (e.node) {\n         case (expr_check(?e, _)) {\n-            vec::push[constraint_info](*cx.cs, expr_to_constr(cx.tcx, e));\n+            vec::push[constr](*cx.cs, expr_to_constr(cx.tcx, e));\n+        }\n+        // If it's a call, generate appropriate instances of the\n+        // call's constraints.\n+        case (expr_call(?operator, ?operands, ?a)) {\n+            for (@ast::constr c in constraints_expr(cx.tcx, operator)) {\n+                auto d_id = ann_to_def_strict(cx.tcx, c.node.ann);\n+                alt (d_id) {\n+                    case (def_fn(?an_id)) {\n+                        let constr an_occ = respan(c.span,\n+                              npred(c.node.path, an_id, \n+                                    aux::substitute_constr_args_(cx.tcx,\n+                                                                 operands,\n+                                                                 c)));\n+                        vec::push[constr](*cx.cs, an_occ);\n+                    }\n+                    case (_) {\n+                        cx.tcx.sess.span_err(c.span,\n+                                             \"Non-pred in constraint\");\n+                    }\n+                }\n+            }\n+            // FIXME: constraints on result type\n         }\n         case (_) { }\n     }\n }\n \n fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, &def_id d, &ann a)\n     -> ctxt {\n-    let ctxt cx = rec(cs=@mutable vec::alloc[constraint_info](0u), tcx=tcx);\n+    let ctxt cx = rec(cs=@mutable vec::alloc[constr](0u), tcx=tcx);\n     auto visitor = walk::default_visitor();\n     visitor = rec(visit_decl_pre=bind collect_local(cx,_),\n                   visit_expr_pre=bind collect_pred(cx,_)\n@@ -61,32 +84,33 @@ fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, &def_id d, &ann a)\n     ret cx;\n }\n \n-fn add_constraint(&ty::ctxt tcx, constraint_info c, uint next, constr_map tbl)\n+fn add_constraint(&ty::ctxt tcx, constr c, uint next, constr_map tbl)\n     -> uint {\n-    log(aux::constraint_to_str(tcx, c.c) + \" |-> \"\n+    log(aux::constraint_to_str(tcx, c) + \" |-> \"\n         + util::common::uistr(next));\n-    let aux::constr cn = c.c;\n-    alt (cn.node) {\n-        case (ninit(?i)) {\n-            tbl.insert(c.id, cinit(next, cn.span, i));\n+    alt (c.node) {\n+        case (ninit(?i, ?id)) {\n+            tbl.insert(id, cinit(next, c.span, id, i));\n         }\n-        case (npred(?p, ?args)) {\n-            alt (tbl.find(c.id)) {\n+        case (npred(?p, ?id, ?args)) {\n+            alt (tbl.find(id)) {\n                 case (some[constraint](?ct)) {\n                     alt (ct) {\n-                        case (cinit(_,_,_)) {\n+                        case (cinit(_,_,_,_)) {\n                             tcx.sess.bug(\"add_constraint: same def_id used\"\n                                          + \" as a variable and a pred\");\n                         }\n-                        case (cpred(_, ?pds)) {\n-                             vec::push(*pds, respan(cn.span,\n+                        case (cpred(_, _, ?pds)) {\n+                             vec::push(*pds, respan(c.span,\n                               rec(args=args, bit_num=next)));\n                         }\n                     }\n                 }\n+                // FIXME: this suggests a cpred shouldn't really have a\n+                // def_id as a field...\n                 case (none[constraint]) {\n-                     tbl.insert(c.id, cpred(p,\n-                      @mutable [respan(cn.span, rec(args=args,\n+                    tbl.insert(id, cpred(p, id,\n+                      @mutable [respan(c.span, rec(args=args,\n                                                     bit_num=next))]));\n                 }\n             }\n@@ -111,13 +135,12 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp,\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    for (constraint_info c in {*cx.cs}) {\n+    for (constr c in {*cx.cs}) {\n         next = add_constraint(cx.tcx, c, next, res_map);\n     }\n     /* add a pseudo-entry for the function's return value\n        we can safely use the function's name itself for this purpose */\n-    add_constraint(cx.tcx, rec(id=f_id,\n-                               c=respan(f_sp, ninit(f_name))), next, res_map);\n+    add_constraint(cx.tcx, respan(f_sp, ninit(f_name, f_id)), next, res_map);\n     \n     auto res = rec(constrs=res_map,\n                             num_constraints=vec::len(*cx.cs) + 1u,"}, {"sha": "ec9371d09fbc692f2a768136873f7fb1b91c547a", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -46,10 +46,10 @@ import aux::ann_to_ts_ann;\n import aux::set_postcond_false;\n import aux::controlflow_expr;\n import aux::expr_to_constr;\n-import aux::constraint_info;\n import aux::constr_to_constr_occ;\n import aux::constraints_expr;\n import aux::substitute_constr_args;\n+import aux::constr_id;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -61,7 +61,6 @@ import bitvectors::gen;\n import front::ast::*;\n \n import middle::ty::expr_ann;\n-import middle::ty::lookup_fn_decl;\n \n import util::common::new_def_hash;\n import util::common::decl_lhs;\n@@ -220,36 +219,29 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n-            \n+          \n+            /* should test higher-order constrained functions */\n+            /* FIXME */\n+\n             /* see if the call has any constraints on its in type */\n-            let option::t[tup(fn_decl, def_id)] decl_and_id =\n-                lookup_fn_decl(fcx.ccx.tcx, expr_ann(operator));\n-            alt (decl_and_id) {\n-                case (some(?p)) {\n-                    log(\"known function: \" );\n-                    log_expr(*operator);\n-                    let def_id f_id = p._1;\n-                    let fn_decl f_decl = p._0;\n-                    auto pp = expr_pp(fcx.ccx, e);\n-                    for (@constr c in constraints_expr(fcx.ccx, operator)) {\n-                        auto i = bit_num(fcx, f_id,\n-                           substitute_constr_args(fcx.ccx.tcx, operands,\n-                                                  f_decl.inputs, c));\n+            log(\"a function: \" );\n+            log_expr(*operator);\n+            auto pp = expr_pp(fcx.ccx, e);\n+            for (@constr c in constraints_expr(fcx.ccx.tcx, operator)) {\n+                auto id = ann_to_def(fcx.ccx, c.node.ann);\n+                alt (id) {\n+                    case (some(def_fn(?d_id))) {\n+                        auto i = bit_num(fcx, d_id,\n+                          substitute_constr_args(fcx.ccx.tcx, operands, c));\n                         require(i, pp);\n                     }\n+                    case (_) {\n+                        fcx.ccx.tcx.sess.span_err(c.span, \"Unbound pred \"\n+                          + \" or pred that's not bound to a function\");\n+                    }\n                 }\n-                // FIXME: Soundness? If a function is constrained...\n-                // shouldn't be able to pass it as an argument\n-                // But typechecking guarantees that. However, we could\n-                // have an unknown function w/ a constrained type =>\n-                // no decl... but need to know the argument names.\n-                // Fix that and then make a test w/ a higher-order\n-                // constrained function.\n-                case (_) { \n-                    log(\"unknown function: \" );\n-                    log_expr(*operator);\n-                    /* unknown function -- do nothing */ }\n             }\n+             \n             // FIXME: constraints on result type\n             \n             /* if this is a failing call, its postcondition sets everything */\n@@ -275,7 +267,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             auto res = expr_pp(fcx.ccx, e);\n             clear_pp(res);\n \n-            auto df = ann_to_def_strict(fcx.ccx, a);\n+            auto df = ann_to_def_strict(fcx.ccx.tcx, a);\n             alt (df) {\n                 case (def_local(?d_id)) {\n                     auto i = bit_num(fcx, d_id, occ_init);\n@@ -518,9 +510,9 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             find_pre_post_expr(fcx, p);\n             copy_pre_post(fcx.ccx, a, p);\n             /* predicate p holds after this expression executes */\n-            let constraint_info c = expr_to_constr(fcx.ccx.tcx, p);\n-            let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.c.node);\n-            gen(fcx, a, c.id, o);\n+            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n+            let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.node);\n+            gen(fcx, a, constr_id(c), o);\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = vec::cat_options[@expr](maybe_args);"}, {"sha": "a3bfba992952a453d351a4d0a254ea08704325fa", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -50,9 +50,9 @@ import aux::controlflow_expr;\n import aux::ann_to_def;\n import aux::occ_init;\n import aux::expr_to_constr;\n-import aux::constraint_info;\n import aux::constr_to_constr_occ;\n import aux::constr_occ;\n+import aux::constr_id;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -527,9 +527,9 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n         changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n         /* predicate p holds after this expression executes */\n-        let constraint_info c = expr_to_constr(fcx.ccx.tcx, p);\n-        let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.c.node);\n-        changed = gen_poststate(fcx, a, c.id, o) || changed;\n+        let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n+        let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.node);\n+        changed = gen_poststate(fcx, a, constr_id(c), o) || changed;\n         ret changed;\n     }\n     case (expr_break(?a)) {"}, {"sha": "d9d15348f3650c0f2e41042579782e32ebcdd158", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -69,7 +69,7 @@ type ctxt = rec(@type_store ts,\n                 session::session sess,\n                 resolve::def_map def_map,\n                 node_type_table node_types,\n-                item_table items,\n+                item_table items, // Only contains type items\n                 type_cache tcache,\n                 creader_cache rcache,\n                 hashmap[t,str] short_names_cache,\n@@ -1100,7 +1100,11 @@ fn hash_ty(&t typ) -> uint { ret typ; }\n // Type equality. This function is private to this module (and slow); external\n // users should use `eq_ty()` instead.\n \n-fn arg_eq(@ast::constr_arg a, @ast::constr_arg b) -> bool {\n+fn eq_int(&uint x, &uint y) -> bool { ret x == y; }\n+\n+fn arg_eq[T](&fn (&T, &T) -> bool eq,\n+          @ast::constr_arg_general[T] a,\n+             @ast::constr_arg_general[T] b) -> bool {\n     alt (a.node) {\n         case (ast::carg_base) {\n             alt (b.node) {\n@@ -1115,7 +1119,7 @@ fn arg_eq(@ast::constr_arg a, @ast::constr_arg b) -> bool {\n         case (ast::carg_ident(?s)) {\n             alt (b.node) {\n                 case (ast::carg_ident(?t)) {\n-                    ret (s == t);\n+                    ret eq(s, t);\n                 }\n                 case (_) {\n                     ret false;\n@@ -1134,10 +1138,13 @@ fn arg_eq(@ast::constr_arg a, @ast::constr_arg b) -> bool {\n         }\n     }\n }\n-fn args_eq(vec[@ast::constr_arg] a, vec[@ast::constr_arg] b) -> bool {\n+\n+fn args_eq[T](fn (&T, &T) -> bool eq,\n+           vec[@ast::constr_arg_general[T]] a,\n+           vec[@ast::constr_arg_general[T]] b) -> bool {\n     let uint i = 0u;\n-    for (@ast::constr_arg arg in a) {\n-        if (!arg_eq(arg, b.(i))) {\n+    for (@ast::constr_arg_general[T] arg in a) {\n+        if (!arg_eq(eq, arg, b.(i))) {\n             ret false;\n         }\n         i += 1u;\n@@ -1148,7 +1155,7 @@ fn args_eq(vec[@ast::constr_arg] a, vec[@ast::constr_arg] b) -> bool {\n \n fn constr_eq(&@ast::constr c, &@ast::constr d) -> bool {\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) // FIXME: hack\n-        && args_eq(c.node.args, d.node.args);\n+        && args_eq(eq_int, c.node.args, d.node.args);\n }\n \n fn constrs_eq(&vec[@ast::constr] cs, &vec[@ast::constr] ds) -> bool {\n@@ -2660,6 +2667,7 @@ fn substitute_type_params(&ctxt cx, vec[ty::t] substs, t typ) -> t {\n     if (!type_contains_params(cx, typ)) { ret typ; }\n \n     fn substituter(ctxt cx, vec[ty::t] substs, uint idx) -> t {\n+        // FIXME: bounds check can fail\n         ret substs.(idx);\n     }\n \n@@ -2775,27 +2783,6 @@ fn ret_ty_of_fn(ctxt cx, ast::ann ann) -> t {\n     ret ret_ty_of_fn_ty(cx, ann_to_type(cx, ann));\n }\n \n-fn lookup_fn_decl(ty_ctxt tcx, ast::ann ann)\n-    -> option::t[tup(ast::fn_decl, ast::def_id)] {\n-    auto nada = none[tup(ast::fn_decl, ast::def_id)];\n-    alt (tcx.def_map.find(ann.id)) {\n-        case (some(ast::def_fn(?d))) {\n-            alt (tcx.items.find(d)) {\n-                case (some(any_item_rust(?it))) {\n-                    alt (it.node) {\n-                        case (ast::item_fn(_,?f,_,_,_)) {\n-                            ret some(tup(f.decl, d));\n-                        }\n-                        case (_) { ret nada; }\n-                    }\n-                }\n-                case (_) { ret nada; }\n-            }\n-        }\n-        case (_) { ret nada; }\n-    }\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "e0407c1ae68155069ea6052878ecc9783f22bae6", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -30,6 +30,7 @@ type visitor[E] =\n          fn(&@decl d, &E e, &vt[E] v)          visit_decl,\n          fn(&@expr ex, &E e, &vt[E] v)         visit_expr,\n          fn(&@ty t, &E e, &vt[E] v)            visit_ty,\n+         fn(&@constr c, &E e, &vt[E] v)        visit_constr,\n          fn(&_fn f, &vec[ty_param] tp, &span sp, &ident name, &def_id d_id,\n             &ann a, &E e, &vt[E] v)            visit_fn);\n \n@@ -45,6 +46,7 @@ fn default_visitor[E]() -> visitor[E] {\n              visit_decl = bind visit_decl[E](_, _, _),\n              visit_expr = bind visit_expr[E](_, _, _),\n              visit_ty = bind visit_ty[E](_, _, _),\n+             visit_constr = bind visit_constr[E](_, _, _),\n              visit_fn = bind visit_fn[E](_, _, _, _, _, _, _, _));\n }\n \n@@ -153,10 +155,13 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n                 vt(v).visit_ty(f.node.mt.ty, e, v);\n             }\n         }\n-        case (ty_fn(_, ?args, ?out, _, _)) {\n+        case (ty_fn(_, ?args, ?out, _, ?constrs)) {\n             for (ty_arg a in args) {\n                 vt(v).visit_ty(a.node.ty, e, v);\n             }\n+            for (@constr c in constrs) {\n+                vt(v).visit_constr(c, e, v);\n+            }\n             vt(v).visit_ty(out, e, v);\n         }\n         case (ty_obj(?tmeths)) {\n@@ -177,6 +182,10 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n     }\n }\n \n+fn visit_constr[E](&@constr c, &E e, &vt[E] v) {\n+    // default\n+}\n+\n fn visit_pat[E](&@pat p, &E e, &vt[E] v) {\n     alt (p.node) {\n         case (pat_tag(?path, ?children, _)) {\n@@ -200,6 +209,9 @@ fn visit_fn_decl[E](&fn_decl fd, &E e, &vt[E] v) {\n     for (arg a in fd.inputs) {\n         vt(v).visit_ty(a.ty, e, v);\n     }\n+    for (@constr c in fd.constraints) {\n+        vt(v).visit_constr(c, e, v);\n+    }\n     vt(v).visit_ty(fd.output, e, v);\n }\n "}, {"sha": "2d85f6ec68e8ef4b29bcda58223a16b94c39c83e", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -36,6 +36,7 @@ type ast_visitor =\n         fn (&@ast::expr e)              visit_expr_post,\n         fn (&@ast::ty t)                visit_ty_pre,\n         fn (&@ast::ty t)                visit_ty_post,\n+        fn (&@ast::constr c)            visit_constr,\n         fn (&ast::_fn f, &span sp, &ast::ident name, \n             &ast::def_id d_id, &ast::ann a)  visit_fn_pre,\n         fn (&ast::_fn f, &span sp, &ast::ident name,\n@@ -172,10 +173,13 @@ fn walk_ty(&ast_visitor v, @ast::ty t) {\n                 walk_ty(v, f.node.mt.ty);\n             }\n         }\n-        case (ast::ty_fn(_, ?args, ?out, _, _)) {\n+        case (ast::ty_fn(_, ?args, ?out, _, ?constrs)) {\n             for (ast::ty_arg a in args) {\n                 walk_ty(v, a.node.ty);\n             }\n+            for (@ast::constr c in constrs) {\n+                v.visit_constr(c);\n+            }\n             walk_ty(v, out);\n         }\n         case (ast::ty_obj(?tmeths)) {\n@@ -240,6 +244,9 @@ fn walk_fn_decl(&ast_visitor v, &ast::fn_decl fd) {\n     for (ast::arg a in fd.inputs) {\n         walk_ty(v, a.ty);\n     }\n+    for (@ast::constr c in fd.constraints) {\n+        v.visit_constr(c);\n+    }\n     walk_ty(v, fd.output);\n }\n \n@@ -511,6 +518,7 @@ fn def_visit_pat(&@ast::pat p) { }\n fn def_visit_decl(&@ast::decl d) { }\n fn def_visit_expr(&@ast::expr e) { }\n fn def_visit_ty(&@ast::ty t) { }\n+fn def_visit_constr(&@ast::constr c) { }\n fn def_visit_fn(&ast::_fn f, &span sp, &ast::ident i, &ast::def_id d,\n                 &ast::ann a) { }\n \n@@ -543,6 +551,7 @@ fn default_visitor() -> ast_visitor {\n             visit_expr_post=def_visit_expr,\n             visit_ty_pre=def_visit_ty,\n             visit_ty_post=def_visit_ty,\n+            visit_constr=def_visit_constr,\n             visit_fn_pre=def_visit_fn,\n             visit_fn_post=def_visit_fn);\n }"}, {"sha": "b7cc155a0d8c99bedf40373527e506bd22208eba", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698c6406ba0f132eb67ba210dac9c52e622742c3/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=698c6406ba0f132eb67ba210dac9c52e622742c3", "patch": "@@ -181,7 +181,22 @@ fn ty_to_short_str(&ctxt cx, t typ) -> str {\n     ret s;\n }\n \n-fn constr_arg_to_str(&ast::constr_arg_ c) -> str {\n+fn constr_arg_to_str[T](fn (&T) -> str f,\n+                        &ast::constr_arg_general_[T] c) -> str {\n+    alt (c) {\n+        case (ast::carg_base) {\n+            ret \"*\";\n+        }\n+        case (ast::carg_ident(?i)) {\n+            ret f(i);\n+        }\n+        case (ast::carg_lit(?l)) {\n+            ret lit_to_str(l);\n+        }\n+    }\n+}\n+\n+fn constr_arg_to_str_1(&ast::constr_arg_general_[str] c) -> str {\n     alt (c) {\n         case (ast::carg_base) {\n             ret \"*\";\n@@ -195,18 +210,34 @@ fn constr_arg_to_str(&ast::constr_arg_ c) -> str {\n     }\n }\n \n+fn constr_args_to_str[T](fn (&T) -> str f, \n+                         &vec[@ast::constr_arg_general[T]] args) -> str {\n+    auto comma = false;\n+    auto s   = \"(\";\n+    for (@ast::constr_arg_general[T] a in args) {\n+        if (comma) {\n+            s += \", \";\n+        }\n+        else {\n+            comma = true;\n+        }\n+        s += constr_arg_to_str[T](f, a.node);\n+    }\n+    s += \")\";\n+    ret s;\n+}\n \n-fn constr_args_to_str(&vec[@constr_arg] args) -> str {\n+fn constr_args_to_str_1(&vec[@ast::constr_arg_use] args) -> str {\n     auto comma = false;\n     auto s   = \"(\";\n-    for (@constr_arg a in args) {\n+    for (@ast::constr_arg_use a in args) {\n         if (comma) {\n             s += \", \";\n         }\n         else {\n             comma = true;\n         }\n-        s += constr_arg_to_str(a.node);\n+        s += constr_arg_to_str_1(a.node);\n     }\n     s += \")\";\n     ret s;\n@@ -410,9 +441,16 @@ fn rust_printer(io::writer writer) -> ps {\n const uint indent_unit = 4u;\n const uint default_columns = 78u;\n \n+// needed b/c constr_args_to_str needs\n+// something that takes an alias\n+// (argh)\n+fn uint_to_str(&uint i) -> str {\n+    ret util::common::uistr(i);\n+}\n+\n fn constr_to_str(&@ast::constr c) -> str {\n   ret path_to_str(c.node.path)\n-    + constr_args_to_str(c.node.args);\n+      + constr_args_to_str(uint_to_str, c.node.args);\n }\n \n fn constrs_str(&vec[@ast::constr] constrs) -> str {"}]}