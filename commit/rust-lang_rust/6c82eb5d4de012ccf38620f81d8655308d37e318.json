{"sha": "6c82eb5d4de012ccf38620f81d8655308d37e318", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjODJlYjVkNGRlMDEyY2NmMzg2MjBmODFkODY1NTMwOGQzN2UzMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T19:01:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T19:01:34Z"}, "message": "auto merge of #13667 : TeXitoi/rust/shootout-chameneos-redux-fix, r=alexcrichton\n\n* fix official shootout test (spacing)\r\n* use libgreen to improve performances\r\n* simplify and modernize code\r\n* remove warnings", "tree": {"sha": "4427de550c6e56b631db27c93d786379371ab611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4427de550c6e56b631db27c93d786379371ab611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c82eb5d4de012ccf38620f81d8655308d37e318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c82eb5d4de012ccf38620f81d8655308d37e318", "html_url": "https://github.com/rust-lang/rust/commit/6c82eb5d4de012ccf38620f81d8655308d37e318", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c82eb5d4de012ccf38620f81d8655308d37e318/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0966ee5285e9cfd26edf6a1e53bed5eeb8114374", "url": "https://api.github.com/repos/rust-lang/rust/commits/0966ee5285e9cfd26edf6a1e53bed5eeb8114374", "html_url": "https://github.com/rust-lang/rust/commit/0966ee5285e9cfd26edf6a1e53bed5eeb8114374"}, {"sha": "0a0e2c36aff801f648773596ece6aeaabb30f979", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a0e2c36aff801f648773596ece6aeaabb30f979", "html_url": "https://github.com/rust-lang/rust/commit/0a0e2c36aff801f648773596ece6aeaabb30f979"}], "stats": {"total": 178, "additions": 78, "deletions": 100}, "files": [{"sha": "7587a21a9df0d0d20aec525d0a18bea7e6b2293f", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 78, "deletions": 100, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/6c82eb5d4de012ccf38620f81d8655308d37e318/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c82eb5d4de012ccf38620f81d8655308d37e318/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=6c82eb5d4de012ccf38620f81d8655308d37e318", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,89 +8,87 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// chameneos\n+#![feature(phase)]\n+#[phase(syntax)] extern crate green;\n \n-use std::option;\n-use std::os;\n use std::strbuf::StrBuf;\n-use std::task;\n+use std::fmt;\n+\n+green_start!(main)\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n     for aa in all.iter() {\n         for bb in all.iter() {\n-            println!(\"{} + {} -> {}\", show_color(*aa), show_color(*bb),\n-                show_color(transform(*aa, *bb)));\n+            println!(\"{} + {} -> {}\", *aa, *bb, transform(*aa, *bb));\n         }\n     }\n }\n \n-enum color { Red, Yellow, Blue }\n+enum Color { Red, Yellow, Blue }\n+impl fmt::Show for Color {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let str = match *self {\n+            Red => \"red\",\n+            Yellow => \"yellow\",\n+            Blue => \"blue\",\n+        };\n+        f.buf.write(str.as_bytes())\n+    }\n+}\n \n struct CreatureInfo {\n     name: uint,\n-    color: color\n+    color: Color\n }\n \n-fn show_color(cc: color) -> &'static str {\n-    match cc {\n-        Red    => \"red\",\n-        Yellow => \"yellow\",\n-        Blue   => \"blue\"\n-    }\n-}\n-\n-fn show_color_list(set: Vec<color>) -> StrBuf {\n+fn show_color_list(set: Vec<Color>) -> StrBuf {\n     let mut out = StrBuf::new();\n     for col in set.iter() {\n         out.push_char(' ');\n-        out.push_str(show_color(*col));\n+        out.push_str(col.to_str());\n     }\n     out\n }\n \n fn show_digit(nn: uint) -> &'static str {\n     match nn {\n-        0 => {\"zero\"}\n-        1 => {\"one\"}\n-        2 => {\"two\"}\n-        3 => {\"three\"}\n-        4 => {\"four\"}\n-        5 => {\"five\"}\n-        6 => {\"six\"}\n-        7 => {\"seven\"}\n-        8 => {\"eight\"}\n-        9 => {\"nine\"}\n+        0 => {\" zero\"}\n+        1 => {\" one\"}\n+        2 => {\" two\"}\n+        3 => {\" three\"}\n+        4 => {\" four\"}\n+        5 => {\" five\"}\n+        6 => {\" six\"}\n+        7 => {\" seven\"}\n+        8 => {\" eight\"}\n+        9 => {\" nine\"}\n         _ => {fail!(\"expected digits from 0 to 9...\")}\n     }\n }\n \n-fn show_number(nn: uint) -> StrBuf {\n-    let mut out = vec![];\n-    let mut num = nn;\n-    let mut dig;\n-    let mut len = 0;\n-    if num == 0 { out.push(show_digit(0)) };\n-\n-    while num != 0 {\n-        dig = num % 10;\n-        num = num / 10;\n-        out.push(\" \");\n-        let s = show_digit(dig);\n-        out.push(s);\n-        len += 1 + s.len();\n-    }\n-    len += 1;\n-    out.push(\" \");\n+struct Number(uint);\n+impl fmt::Show for Number {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut out = vec![];\n+        let Number(mut num) = *self;\n+        if num == 0 { out.push(show_digit(0)) };\n+\n+        while num != 0 {\n+            let dig = num % 10;\n+            num = num / 10;\n+            let s = show_digit(dig);\n+            out.push(s);\n+        }\n \n-    let mut ret = StrBuf::with_capacity(len);\n-    for s in out.iter().rev() {\n-        ret.push_str(*s);\n+        for s in out.iter().rev() {\n+            try!(f.buf.write(s.as_bytes()));\n+        }\n+        Ok(())\n     }\n-    ret\n }\n \n-fn transform(aa: color, bb: color) -> color {\n+fn transform(aa: Color, bb: Color) -> Color {\n     match (aa, bb) {\n         (Red,    Red   ) => { Red    }\n         (Red,    Yellow) => { Blue   }\n@@ -106,23 +104,22 @@ fn transform(aa: color, bb: color) -> color {\n \n fn creature(\n     name: uint,\n-    color: color,\n-    from_rendezvous: Receiver<Option<CreatureInfo>>,\n+    mut color: Color,\n+    from_rendezvous: Receiver<CreatureInfo>,\n     to_rendezvous: Sender<CreatureInfo>,\n     to_rendezvous_log: Sender<~str>\n ) {\n-    let mut color = color;\n     let mut creatures_met = 0;\n     let mut evil_clones_met = 0;\n+    let mut rendezvous = from_rendezvous.iter();\n \n     loop {\n         // ask for a pairing\n         to_rendezvous.send(CreatureInfo {name: name, color: color});\n-        let resp = from_rendezvous.recv();\n \n-        // log and change, or print and quit\n-        match resp {\n-            option::Some(other_creature) => {\n+        // log and change, or quit\n+        match rendezvous.next() {\n+            Some(other_creature) => {\n                 color = transform(color, other_creature.color);\n \n                 // track some statistics\n@@ -131,41 +128,35 @@ fn creature(\n                    evil_clones_met += 1;\n                 }\n             }\n-            option::None => {\n-                // log creatures met and evil clones of self\n-                let report = format!(\"{} {}\",\n-                                     creatures_met, show_number(evil_clones_met).as_slice());\n-                to_rendezvous_log.send(report);\n-                break;\n-            }\n+            None => break\n         }\n     }\n+    // log creatures met and evil clones of self\n+    let report = format!(\"{}{}\", creatures_met, Number(evil_clones_met));\n+    to_rendezvous_log.send(report);\n }\n \n-fn rendezvous(nn: uint, set: Vec<color>) {\n-\n+fn rendezvous(nn: uint, set: Vec<Color>) {\n     // these ports will allow us to hear from the creatures\n     let (to_rendezvous, from_creatures) = channel::<CreatureInfo>();\n-    let (to_rendezvous_log, from_creatures_log) = channel::<~str>();\n \n     // these channels will be passed to the creatures so they can talk to us\n+    let (to_rendezvous_log, from_creatures_log) = channel::<~str>();\n \n     // these channels will allow us to talk to each creature by 'name'/index\n-    let mut to_creature: Vec<Sender<Option<CreatureInfo>>> =\n-        set.iter().enumerate().map(|(ii, col)| {\n+    let mut to_creature: Vec<Sender<CreatureInfo>> =\n+        set.iter().enumerate().map(|(ii, &col)| {\n             // create each creature as a listener with a port, and\n             // give us a channel to talk to each\n-            let ii = ii;\n-            let col = *col;\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (to_creature, from_rendezvous) = channel();\n-            task::spawn(proc() {\n+            spawn(proc() {\n                 creature(ii,\n                          col,\n                          from_rendezvous,\n-                         to_rendezvous.clone(),\n-                         to_rendezvous_log.clone());\n+                         to_rendezvous,\n+                         to_rendezvous_log);\n             });\n             to_creature\n         }).collect();\n@@ -174,55 +165,42 @@ fn rendezvous(nn: uint, set: Vec<color>) {\n \n     // set up meetings...\n     for _ in range(0, nn) {\n-        let mut fst_creature: CreatureInfo = from_creatures.recv();\n-        let mut snd_creature: CreatureInfo = from_creatures.recv();\n+        let fst_creature = from_creatures.recv();\n+        let snd_creature = from_creatures.recv();\n \n         creatures_met += 2;\n \n-        to_creature.get_mut(fst_creature.name).send(Some(snd_creature));\n-        to_creature.get_mut(snd_creature.name).send(Some(fst_creature));\n+        to_creature.get_mut(fst_creature.name).send(snd_creature);\n+        to_creature.get_mut(snd_creature.name).send(fst_creature);\n     }\n \n     // tell each creature to stop\n-    for to_one in to_creature.iter() {\n-        to_one.send(None);\n-    }\n-\n-    // save each creature's meeting stats\n-    let mut report = Vec::new();\n-    for _to_one in to_creature.iter() {\n-        report.push(from_creatures_log.recv());\n-    }\n+    drop(to_creature);\n \n     // print each color in the set\n     println!(\"{}\", show_color_list(set));\n \n     // print each creature's stats\n-    for rep in report.iter() {\n-        println!(\"{}\", *rep);\n+    drop(to_rendezvous_log);\n+    for rep in from_creatures_log.iter() {\n+        println!(\"{}\", rep);\n     }\n \n     // print the total number of creatures met\n-    println!(\"{}\", show_number(creatures_met));\n+    println!(\"{}\\n\", Number(creatures_met));\n }\n \n fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"200000\".to_owned())\n-    } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"600\".to_owned())\n+    let nn = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+        200000\n     } else {\n-        args.move_iter().collect()\n+        std::os::args().get(1).and_then(|arg| from_str(*arg)).unwrap_or(600)\n     };\n \n-    let nn = from_str::<uint>(*args.get(1)).unwrap();\n-\n     print_complements();\n     println!(\"\");\n \n     rendezvous(nn, vec!(Blue, Red, Yellow));\n-    println!(\"\");\n \n     rendezvous(nn,\n         vec!(Blue, Red, Yellow, Red, Yellow, Blue, Red, Yellow, Red, Blue));"}]}