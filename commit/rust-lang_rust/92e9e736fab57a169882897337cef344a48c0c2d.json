{"sha": "92e9e736fab57a169882897337cef344a48c0c2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZTllNzM2ZmFiNTdhMTY5ODgyODk3MzM3Y2VmMzQ0YTQ4YzBjMmQ=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-22T23:33:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:17Z"}, "message": "std: high-level libuv-leverage APIs now take a hl_loop as arg (tcp/timer)", "tree": {"sha": "ee0888e55efe52ee81814a56bfbc15a17e952de1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee0888e55efe52ee81814a56bfbc15a17e952de1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92e9e736fab57a169882897337cef344a48c0c2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92e9e736fab57a169882897337cef344a48c0c2d", "html_url": "https://github.com/rust-lang/rust/commit/92e9e736fab57a169882897337cef344a48c0c2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92e9e736fab57a169882897337cef344a48c0c2d/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0b175214a794a9f84f65ae8687522491f8b9c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b175214a794a9f84f65ae8687522491f8b9c4b", "html_url": "https://github.com/rust-lang/rust/commit/b0b175214a794a9f84f65ae8687522491f8b9c4b"}], "stats": {"total": 89, "additions": 55, "deletions": 34}, "files": [{"sha": "2fe2471508301ef24442d7e880e1d139fe08e021", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/92e9e736fab57a169882897337cef344a48c0c2d/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e9e736fab57a169882897337cef344a48c0c2d/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=92e9e736fab57a169882897337cef344a48c0c2d", "patch": "@@ -83,16 +83,18 @@ Initiate a client connection over TCP/IP\n \n # Arguments\n \n-* ip - The IP address (versions 4 or 6) of the remote host\n-* port - the unsigned integer of the desired remote host port\n+* `ip` - The IP address (versions 4 or 6) of the remote host\n+* `port` - the unsigned integer of the desired remote host port\n+* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n \n # Returns\n \n A `result` that, if the operation succeeds, contains a `tcp_socket` that\n can be used to send and receive data to/from the remote host. In the event\n of failure, a `tcp_err_data` will be returned\n \"]\n-fn connect(input_ip: ip::ip_addr, port: uint)\n+fn connect(input_ip: ip::ip_addr, port: uint,\n+           hl_loop: uv::hl::high_level_loop)\n     -> result::result<tcp_socket, tcp_err_data> unsafe {\n     let result_po = comm::port::<conn_attempt>();\n     let closed_signal_po = comm::port::<()>();\n@@ -101,7 +103,6 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n         closed_signal_ch: comm::chan(closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n-    let hl_loop = uv::global_loop::get();\n     let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n     let stream_handle_ptr = malloc_uv_tcp_t();\n     *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n@@ -343,18 +344,19 @@ Bind to a given IP/port and listen for new connections\n * `port` - a uint representing the port to listen on\n * `backlog` - a uint representing the number of incoming connections\n to cache in memory\n+* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n \n # Returns\n \n A `result` instance containing either a `tcp_conn_port` which can used\n to listen for, and accept, new connections, or a `tcp_err_data` if\n failure to create the tcp listener occurs\n \"]\n-fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint)\n+fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n+                hl_loop: uv::hl::high_level_loop)\n     -> result::result<tcp_conn_port, tcp_err_data> unsafe {\n     let stream_closed_po = comm::port::<()>();\n     let stream_closed_ch = comm::chan(stream_closed_po);\n-    let hl_loop = uv::global_loop::get();\n     let new_conn_po = comm::port::<result::result<*uv::ll::uv_tcp_t,\n                                                   tcp_err_data>>();\n     let new_conn_ch = comm::chan(new_conn_po);\n@@ -653,6 +655,7 @@ Bind to a given IP/port and listen for new connections\n * `port` - a uint representing the port to listen on\n * `backlog` - a uint representing the number of incoming connections\n to cache in memory\n+* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n * `on_establish_cb` - a callback that is evaluated if/when the listener\n is successfully established. it takes no parameters\n * `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n@@ -671,6 +674,7 @@ successful/normal shutdown, and a `tcp_err_data` record in the event\n of listen exiting because of an error\n \"]\n fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n+          hl_loop: uv::hl::high_level_loop,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n           new_connect_cb: fn~(tcp_new_connection,\n                               comm::chan<option<tcp_err_data>>))\n@@ -680,7 +684,6 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     let kill_ch = comm::chan(kill_po);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(server_stream);\n-    let hl_loop = uv::global_loop::get();\n     let server_data = {\n         server_stream_ptr: server_stream_ptr,\n         stream_closed_ch: comm::chan(stream_closed_po),\n@@ -804,8 +807,9 @@ impl sock_methods for tcp_socket {\n \n // shared implementation for tcp::read\n fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n-    -> result::result<[u8],tcp_err_data> {\n+    -> result::result<[u8],tcp_err_data> unsafe {\n     log(debug, \"starting tcp::read\");\n+    let hl_loop = (*socket_data).hl_loop;\n     let rs_result = read_start_common_impl(socket_data);\n     if result::is_failure(rs_result) {\n         let err_data = result::get_err(rs_result);\n@@ -815,7 +819,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n         log(debug, \"tcp::read before recv_timeout\");\n         let read_result = if timeout_msecs > 0u {\n             timer::recv_timeout(\n-                timeout_msecs, result::get(rs_result))\n+                hl_loop, timeout_msecs, result::get(rs_result))\n         } else {\n             some(comm::recv(result::get(rs_result)))\n         };\n@@ -1270,7 +1274,7 @@ fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n     }\n }\n \n-//#[cfg(test)]\n+#[cfg(test)]\n mod test {\n     // FIXME don't run on fbsd or linux 32 bit(#2064)\n     #[cfg(target_os=\"win32\")]\n@@ -1303,6 +1307,7 @@ mod test {\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_and_client() {\n+        let hl_loop = uv::global_loop::get();\n         let server_ip = \"127.0.0.1\";\n         let server_port = 8888u;\n         let expected_req = \"ping\";\n@@ -1321,7 +1326,8 @@ mod test {\n                     server_port,\n                     expected_resp,\n                     server_ch,\n-                    cont_ch)\n+                    cont_ch,\n+                    hl_loop)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1333,7 +1339,8 @@ mod test {\n                 server_ip,\n                 server_port,\n                 expected_req,\n-                client_ch)\n+                client_ch,\n+                hl_loop)\n         };\n         let actual_req = comm::recv(server_result_po);\n         log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n@@ -1344,6 +1351,7 @@ mod test {\n         assert str::contains(actual_resp, expected_resp);\n     }\n     fn impl_gl_tcp_ipv4_server_listener_and_client() {\n+        let hl_loop = uv::global_loop::get();\n         let server_ip = \"127.0.0.1\";\n         let server_port = 8889u;\n         let expected_req = \"ping\";\n@@ -1362,7 +1370,8 @@ mod test {\n                     server_port,\n                     expected_resp,\n                     server_ch,\n-                    cont_ch)\n+                    cont_ch,\n+                    hl_loop)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1374,7 +1383,8 @@ mod test {\n                 server_ip,\n                 server_port,\n                 expected_req,\n-                client_ch)\n+                client_ch,\n+                hl_loop)\n         };\n         let actual_req = comm::recv(server_result_po);\n         log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n@@ -1387,12 +1397,14 @@ mod test {\n \n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n                           server_ch: comm::chan<str>,\n-                          cont_ch: comm::chan<()>) -> str {\n+                          cont_ch: comm::chan<()>,\n+                          hl_loop: uv::hl::high_level_loop) -> str {\n \n         task::spawn_sched(task::manual_threads(1u)) {||\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let listen_result =\n                 listen_for_conn(server_ip_addr, server_port, 128u,\n+                hl_loop,\n                 // on_establish_cb -- called when listener is set up\n                 {|kill_ch|\n                     log(debug, #fmt(\"establish_cb %?\",\n@@ -1464,12 +1476,13 @@ mod test {\n     fn run_tcp_test_server_listener(server_ip: str,\n                                     server_port: uint, resp: str,\n                                     server_ch: comm::chan<str>,\n-                                    cont_ch: comm::chan<()>) -> str {\n+                                    cont_ch: comm::chan<()>,\n+                                    hl_loop: uv::hl::high_level_loop) -> str {\n \n         task::spawn_sched(task::manual_threads(1u)) {||\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let new_listener_result =\n-                new_listener(server_ip_addr, server_port, 128u);\n+                new_listener(server_ip_addr, server_port, 128u, hl_loop);\n             if result::is_failure(new_listener_result) {\n                 let err_data = result::get_err(new_listener_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n@@ -1512,12 +1525,13 @@ mod test {\n     }\n \n     fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n-                          client_ch: comm::chan<str>) -> str {\n+                          client_ch: comm::chan<str>,\n+                          hl_loop: uv::hl::high_level_loop) -> str {\n \n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         log(debug, \"CLIENT: starting..\");\n-        let connect_result = connect(server_ip_addr, server_port);\n+        let connect_result = connect(server_ip_addr, server_port, hl_loop);\n         if result::is_failure(connect_result) {\n             log(debug, \"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);"}, {"sha": "7e5a458a158b4f5e2a2d5c1cf76fad4e85c4c30f", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/92e9e736fab57a169882897337cef344a48c0c2d/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e9e736fab57a169882897337cef344a48c0c2d/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=92e9e736fab57a169882897337cef344a48c0c2d", "patch": "@@ -16,19 +16,20 @@ for *at least* that period of time.\n \n # Arguments\n \n+* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n * msecs - a timeout period, in milliseconds, to wait\n * ch - a channel of type T to send a `val` on\n * val - a value of type T to send over the provided `ch`\n \"]\n-fn delayed_send<T: copy send>(msecs: uint, ch: comm::chan<T>, val: T) {\n+fn delayed_send<T: send>(hl_loop: uv::hl::high_level_loop,\n+                         msecs: uint, ch: comm::chan<T>, val: T) {\n     task::spawn() {||\n         unsafe {\n             let timer_done_po = comm::port::<()>();\n             let timer_done_ch = comm::chan(timer_done_po);\n             let timer_done_ch_ptr = ptr::addr_of(timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(timer);\n-            let hl_loop = uv::global_loop::get();\n             uv::hl::interact(hl_loop) {|loop_ptr|\n                 let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n                 if (init_result == 0i32) {\n@@ -67,12 +68,13 @@ for *at least* that period of time.\n \n # Arguments\n \n+* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n * msecs - an amount of time, in milliseconds, for the current task to block\n \"]\n-fn sleep(msecs: uint) {\n+fn sleep(hl_loop: uv::hl::high_level_loop, msecs: uint) {\n     let exit_po = comm::port::<()>();\n     let exit_ch = comm::chan(exit_po);\n-    delayed_send(msecs, exit_ch, ());\n+    delayed_send(hl_loop, msecs, exit_ch, ());\n     comm::recv(exit_po);\n }\n \n@@ -85,6 +87,7 @@ timeout. Depending on whether the provided port receives in that time period,\n \n # Arguments\n \n+* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n * msecs - an mount of time, in milliseconds, to wait to receive\n * wait_port - a `comm::port<T>` to receive on\n \n@@ -94,12 +97,11 @@ An `option<T>` representing the outcome of the call. If the call `recv`'d on\n the provided port in the allotted timeout period, then the result will be a\n `some(T)`. If not, then `none` will be returned.\n \"]\n-fn recv_timeout<T: copy send>(msecs: uint, wait_po: comm::port<T>)\n-    -> option<T> {\n-\n+fn recv_timeout<T: send>(hl_loop: uv::hl::high_level_loop,\n+                         msecs: uint, wait_po: comm::port<T>) -> option<T> {\n     let timeout_po = comm::port::<()>();\n     let timeout_ch = comm::chan(timeout_po);\n-    delayed_send(msecs, timeout_ch, ());\n+    delayed_send(hl_loop, msecs, timeout_ch, ());\n     either::either(\n         {|left_val|\n             log(debug, #fmt(\"recv_time .. left_val %?\",\n@@ -140,20 +142,23 @@ crust fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n mod test {\n     #[test]\n     fn test_gl_timer_simple_sleep_test() {\n-        sleep(1u);\n+        let hl_loop = uv::global_loop::get();\n+        sleep(hl_loop, 1u);\n     }\n \n     #[test]\n     fn test_gl_timer_sleep_stress1() {\n+        let hl_loop = uv::global_loop::get();\n         iter::repeat(200u) {||\n-            sleep(1u);\n+            sleep(hl_loop, 1u);\n         }\n     }\n \n     #[test]\n     fn test_gl_timer_sleep_stress2() {\n         let po = comm::port();\n         let ch = comm::chan(po);\n+        let hl_loop = uv::global_loop::get();\n \n         let repeat = 20u;\n         let spec = {\n@@ -172,7 +177,7 @@ mod test {\n                     import rand::*;\n                     let rng = rng();\n                     iter::repeat(times) {||\n-                        sleep(rng.next() as uint % maxms);\n+                        sleep(hl_loop, rng.next() as uint % maxms);\n                     }\n                     comm::send(ch, ());\n                 }\n@@ -195,6 +200,7 @@ mod test {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;\n+        let hl_loop = uv::global_loop::get();\n \n         iter::repeat(times as uint) {||\n             task::yield();\n@@ -204,10 +210,10 @@ mod test {\n             let test_ch = comm::chan(test_po);\n \n             task::spawn() {||\n-                delayed_send(1u, test_ch, expected);\n+                delayed_send(hl_loop, 1u, test_ch, expected);\n             };\n \n-            alt recv_timeout(10u, test_po) {\n+            alt recv_timeout(hl_loop, 10u, test_po) {\n               some(val) { assert val == expected; successes += 1; }\n               _ { failures += 1; }\n             };\n@@ -221,17 +227,18 @@ mod test {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;\n+        let hl_loop = uv::global_loop::get();\n \n         iter::repeat(times as uint) {||\n             let expected = rand::rng().gen_str(16u);\n             let test_po = comm::port::<str>();\n             let test_ch = comm::chan(test_po);\n \n             task::spawn() {||\n-                delayed_send(1000u, test_ch, expected);\n+                delayed_send(hl_loop, 1000u, test_ch, expected);\n             };\n \n-            let actual = alt recv_timeout(1u, test_po) {\n+            let actual = alt recv_timeout(hl_loop, 1u, test_po) {\n               none { successes += 1; }\n               _ { failures += 1; }\n             };"}]}