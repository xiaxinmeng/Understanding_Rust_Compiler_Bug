{"sha": "e3c43e64eceb00e13b1932229aa9b2d774e6af96", "node_id": "C_kwDOAAsO6NoAKGUzYzQzZTY0ZWNlYjAwZTEzYjE5MzIyMjlhYTliMmQ3NzRlNmFmOTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T07:50:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T07:50:56Z"}, "message": "Auto merge of #94255 - b-naber:use-mir-constant-in-thir, r=oli-obk\n\nUse mir constant in thir instead of ty::Const\n\nThis is blocked on https://github.com/rust-lang/rust/pull/94059 (does include its changes, the first two commits in this PR correspond to those changes) and https://github.com/rust-lang/rust/pull/93800 being reinstated (which had to be reverted). Mainly opening since `@lcnr` offered to give some feedback and maybe also for a perf-run (if necessary).\n\nThis currently contains a lot of duplication since some of the logic of `ty::Const` had to be copied to `mir::ConstantKind`, but with the introduction of valtrees a lot of that functionality will disappear from `ty::Const`.\n\nOnly the last commit contains changes that need to be reviewed here. Did leave some `FIXME` comments regarding future implementation decisions and some things that might be incorrectly implemented.\n\nr? `@oli-obk`", "tree": {"sha": "201b9089a76e563c8cebee025338892fdcf6c82d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/201b9089a76e563c8cebee025338892fdcf6c82d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3c43e64eceb00e13b1932229aa9b2d774e6af96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3c43e64eceb00e13b1932229aa9b2d774e6af96", "html_url": "https://github.com/rust-lang/rust/commit/e3c43e64eceb00e13b1932229aa9b2d774e6af96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3c43e64eceb00e13b1932229aa9b2d774e6af96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b768f248e99688a2d7649731a99b2f2ad962abf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b768f248e99688a2d7649731a99b2f2ad962abf5", "html_url": "https://github.com/rust-lang/rust/commit/b768f248e99688a2d7649731a99b2f2ad962abf5"}, {"sha": "3be987e076ad6b90a3679036ff71f639e9553ffa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3be987e076ad6b90a3679036ff71f639e9553ffa", "html_url": "https://github.com/rust-lang/rust/commit/3be987e076ad6b90a3679036ff71f639e9553ffa"}], "stats": {"total": 282, "additions": 227, "deletions": 55}, "files": [{"sha": "db7e973fb62234f45dff13466d6e616fbc3b4b10", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 162, "deletions": 9, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -9,13 +9,13 @@ use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n-use crate::ty::subst::{Subst, SubstsRef};\n+use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, List, Ty, TyCtxt};\n use crate::ty::{AdtDef, InstanceDef, Region, ScalarInt, UserTypeAnnotationIndex};\n \n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::{CtorKind, Namespace};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, GeneratorKind};\n use rustc_hir::{self as hir, HirId};\n use rustc_session::Session;\n@@ -2921,6 +2921,16 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n     }\n \n+    pub fn try_val(&self) -> Option<ConstValue<'tcx>> {\n+        match self {\n+            ConstantKind::Ty(c) => match c.val() {\n+                ty::ConstKind::Value(v) => Some(v),\n+                _ => None,\n+            },\n+            ConstantKind::Val(v, _) => Some(*v),\n+        }\n+    }\n+\n     #[inline]\n     pub fn try_to_value(self) -> Option<interpret::ConstValue<'tcx>> {\n         match self {\n@@ -2949,6 +2959,32 @@ impl<'tcx> ConstantKind<'tcx> {\n         self.try_to_scalar_int()?.try_into().ok()\n     }\n \n+    #[inline]\n+    pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n+        match self {\n+            Self::Ty(c) => {\n+                // FIXME Need to use a different evaluation function that directly returns a `ConstValue`\n+                // if evaluation succeeds and does not create a ValTree first\n+                if let Some(val) = c.val().try_eval(tcx, param_env) {\n+                    match val {\n+                        Ok(val) => Self::Val(val, c.ty()),\n+                        Err(_) => Self::Ty(tcx.const_error(self.ty())),\n+                    }\n+                } else {\n+                    self\n+                }\n+            }\n+            Self::Val(_, _) => self,\n+        }\n+    }\n+\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n+    #[inline]\n+    pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n+        self.try_eval_bits(tcx, param_env, ty)\n+            .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n+    }\n+\n     #[inline]\n     pub fn try_eval_bits(\n         &self,\n@@ -2983,25 +3019,142 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n     }\n \n+    pub fn from_bits(\n+        tcx: TyCtxt<'tcx>,\n+        bits: u128,\n+        param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Self {\n+        let size = tcx\n+            .layout_of(param_env_ty)\n+            .unwrap_or_else(|e| {\n+                bug!(\"could not compute layout for {:?}: {:?}\", param_env_ty.value, e)\n+            })\n+            .size;\n+        let cv = ConstValue::Scalar(Scalar::from_uint(bits, size));\n+\n+        Self::Val(cv, param_env_ty.value)\n+    }\n+\n     pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> Self {\n         let cv = ConstValue::from_bool(v);\n         Self::Val(cv, tcx.types.bool)\n     }\n \n-    pub fn from_zero_sized(ty: Ty<'tcx>) -> Self {\n+    pub fn zero_sized(ty: Ty<'tcx>) -> Self {\n         let cv = ConstValue::Scalar(Scalar::ZST);\n         Self::Val(cv, ty)\n     }\n \n     pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> Self {\n         let ty = tcx.types.usize;\n-        let size = tcx\n-            .layout_of(ty::ParamEnv::empty().and(ty))\n-            .unwrap_or_else(|e| bug!(\"could not compute layout for {:?}: {:?}\", ty, e))\n-            .size;\n-        let cv = ConstValue::Scalar(Scalar::from_uint(n as u128, size));\n+        Self::from_bits(tcx, n as u128, ty::ParamEnv::empty().and(ty))\n+    }\n \n-        Self::Val(cv, ty)\n+    /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n+    /// converted to a constant, everything else becomes `Unevaluated`.\n+    pub fn from_anon_const(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: LocalDefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id), param_env)\n+    }\n+\n+    #[instrument(skip(tcx), level = \"debug\")]\n+    fn from_opt_const_arg_anon_const(\n+        tcx: TyCtxt<'tcx>,\n+        def: ty::WithOptConstParam<LocalDefId>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        let body_id = match tcx.hir().get_by_def_id(def.did) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def.did.to_def_id()),\n+                \"from_anon_const can only process anonymous constants\"\n+            ),\n+        };\n+\n+        let expr = &tcx.hir().body(body_id).value;\n+        debug!(?expr);\n+\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.kind {\n+            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n+                block.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n+        let ty = tcx.type_of(def.def_id_for_type_of());\n+\n+        // FIXME(const_generics): We currently have to special case parameters because `min_const_generics`\n+        // does not provide the parents generics to anonymous constants. We still allow generic const\n+        // parameters by themselves however, e.g. `N`.  These constants would cause an ICE if we were to\n+        // ever try to substitute the generic parameters in their bodies.\n+        //\n+        // While this doesn't happen as these constants are always used as `ty::ConstKind::Param`, it does\n+        // cause issues if we were to remove that special-case and try to evaluate the constant instead.\n+        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n+        match expr.kind {\n+            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n+                // Find the name and index of the const parameter by indexing the generics of\n+                // the parent item and construct a `ParamConst`.\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+                let item_id = tcx.hir().get_parent_node(hir_id);\n+                let item_def_id = tcx.hir().local_def_id(item_id);\n+                let generics = tcx.generics_of(item_def_id.to_def_id());\n+                let index = generics.param_def_id_to_index[&def_id];\n+                let name = tcx.hir().name(hir_id);\n+                let ty_const = tcx.mk_const(ty::ConstS {\n+                    val: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n+                    ty,\n+                });\n+\n+                return Self::Ty(ty_const);\n+            }\n+            _ => {}\n+        }\n+\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+        let parent_substs = if let Some(parent_hir_id) = tcx.hir().find_parent_node(hir_id) {\n+            if let Some(parent_did) = tcx.hir().opt_local_def_id(parent_hir_id) {\n+                InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n+            } else {\n+                tcx.mk_substs(Vec::<GenericArg<'tcx>>::new().into_iter())\n+            }\n+        } else {\n+            tcx.mk_substs(Vec::<GenericArg<'tcx>>::new().into_iter())\n+        };\n+        debug!(?parent_substs);\n+\n+        let did = def.did.to_def_id();\n+        let child_substs = InternalSubsts::identity_for_item(tcx, did);\n+        let substs = tcx.mk_substs(parent_substs.into_iter().chain(child_substs.into_iter()));\n+        debug!(?substs);\n+\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+        let span = tcx.hir().span(hir_id);\n+        let uneval = ty::Unevaluated::new(def.to_global(), substs);\n+        debug!(?span, ?param_env);\n+\n+        match tcx.const_eval_resolve(param_env, uneval, Some(span)) {\n+            Ok(val) => Self::Val(val, ty),\n+            Err(_) => {\n+                // Error was handled in `const_eval_resolve`. Here we just create a\n+                // new unevaluated const and error hard later in codegen\n+                let ty_const = tcx.mk_const(ty::ConstS {\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n+                        def: def.to_global(),\n+                        substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n+                        promoted: None,\n+                    }),\n+                    ty,\n+                });\n+\n+                Self::Ty(ty_const)\n+            }\n+        }\n     }\n }\n "}, {"sha": "b17343d7692f6644e7e3ad776157fc1e9576c8e9", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -19,11 +19,11 @@ use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::AllocId;\n use rustc_middle::mir::{\n-    BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp, UserTypeProjection,\n+    self, BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp, UserTypeProjection,\n };\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtDef, Const, Ty, UpvarSubsts, UserType};\n+use rustc_middle::ty::{self, AdtDef, Ty, UpvarSubsts, UserType};\n use rustc_middle::ty::{\n     CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n };\n@@ -375,7 +375,7 @@ pub enum ExprKind<'tcx> {\n     /// An array literal constructed from one repeated element, e.g. `[1; 5]`.\n     Repeat {\n         value: ExprId,\n-        count: Const<'tcx>,\n+        count: ty::Const<'tcx>,\n     },\n     /// An array, e.g. `[a, b, c, d]`.\n     Array {\n@@ -522,7 +522,7 @@ pub enum InlineAsmOperand<'tcx> {\n         out_expr: Option<ExprId>,\n     },\n     Const {\n-        value: Const<'tcx>,\n+        value: mir::ConstantKind<'tcx>,\n         span: Span,\n     },\n     SymFn {"}, {"sha": "ef7becde69a6673c4dbc6acbdf7be5143ccbe647", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -24,6 +24,15 @@ pub trait Visitor<'a, 'tcx: 'a>: Sized {\n     fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n         walk_pat(self, pat);\n     }\n+\n+    // Note: We don't have visitors for `ty::Const` and `mir::ConstantKind`\n+    // (even though these types occur in THIR) for consistency and to reduce confusion,\n+    // since the lazy creation of constants during thir construction causes most\n+    // 'constants' to not be of type `ty::Const` or `mir::ConstantKind` at that\n+    // stage (they are mostly still identified by `DefId` or `hir::Lit`, see\n+    // the variants `Literal`, `NonHirLiteral` and `NamedConst` in `thir::ExprKind`).\n+    // You have to manually visit `ty::Const` and `mir::ConstantKind` through the\n+    // other `visit*` functions.\n }\n \n pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {"}, {"sha": "35d286d2c5781e607a53004969fd7e9f6956f248", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -126,7 +126,8 @@ impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n     /// return `None`.\n-    pub(super) fn try_eval(\n+    // FIXME(@lcnr): Completely rework the evaluation/normalization system for `ty::Const` once valtrees are merged.\n+    pub fn try_eval(\n         self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,"}, {"sha": "ac92b03e5f38541252edf65b91ff69ffa93315ff", "filename": "compiler/rustc_mir_build/src/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> CFG<'tcx> {\n             Rvalue::Use(Operand::Constant(Box::new(Constant {\n                 span: source_info.span,\n                 user_ty: None,\n-                literal: ConstantKind::from_zero_sized(tcx.types.unit),\n+                literal: ConstantKind::zero_sized(tcx.types.unit),\n             }))),\n         );\n     }"}, {"sha": "8b9b1847e7f0eb179d86bb671275aa9de52647ac", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -2,11 +2,10 @@\n \n use crate::build::Builder;\n use crate::thir::constant::parse_float;\n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::mir::interpret::{\n-    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n-};\n+use rustc_middle::mir::interpret::Allocation;\n+use rustc_middle::mir::interpret::{ConstValue, LitToConstError, LitToConstInput, Scalar};\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::subst::SubstsRef;\n@@ -32,11 +31,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::Literal { lit, neg } => {\n                 let literal =\n-                    match lit_to_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n+                    match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n                         Ok(c) => c,\n                         Err(LitToConstError::Reported) => ConstantKind::Ty(tcx.const_error(ty)),\n                         Err(LitToConstError::TypeError) => {\n-                            bug!(\"encountered type error in `lit_to_constant\")\n+                            bug!(\"encountered type error in `lit_to_mir_constant\")\n                         }\n                     };\n \n@@ -90,7 +89,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n }\n \n-crate fn lit_to_constant<'tcx>(\n+#[instrument(skip(tcx, lit_input))]\n+fn lit_to_mir_constant<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n ) -> Result<ConstantKind<'tcx>, LitToConstError> {"}, {"sha": "be777418433a5cf04fc2ce3b7671363952879138", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::Use(Operand::Constant(Box::new(Constant {\n                     span: expr_span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(this.tcx, this.tcx.types.unit).into(),\n+                    literal: ConstantKind::zero_sized(this.tcx.types.unit),\n                 }))))\n             }\n             ExprKind::Yield { .. }\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(ty);\n         let size = self.tcx.layout_of(param_ty).unwrap().size;\n-        let literal = ty::Const::from_bits(self.tcx, size.unsigned_int_max(), param_ty);\n+        let literal = ConstantKind::from_bits(self.tcx, size.unsigned_int_max(), param_ty);\n \n         self.literal_operand(span, literal)\n     }\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(ty);\n         let bits = self.tcx.layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n-        let literal = ty::Const::from_bits(self.tcx, n, param_ty);\n+        let literal = ConstantKind::from_bits(self.tcx, n, param_ty);\n \n         self.literal_operand(span, literal)\n     }"}, {"sha": "806c260d110ea712e8a023b9dbd3d897069c755e", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                 } else if let [success, fail] = *make_target_blocks(self) {\n                     assert_eq!(value.ty(), ty);\n-                    let expect = self.literal_operand(test.span, value);\n+                    let expect = self.literal_operand(test.span, value.into());\n                     let val = Operand::Copy(place);\n                     self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                 } else {\n@@ -277,8 +277,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let target_blocks = make_target_blocks(self);\n \n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n-                let lo = self.literal_operand(test.span, lo);\n-                let hi = self.literal_operand(test.span, hi);\n+                let lo = self.literal_operand(test.span, lo.into());\n+                let hi = self.literal_operand(test.span, hi.into());\n                 let val = Operand::Copy(place);\n \n                 let [success, fail] = *target_blocks else {\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n-        let mut expect = self.literal_operand(source_info.span, value);\n+        let mut expect = self.literal_operand(source_info.span, value.into());\n         let mut val = Operand::Copy(place);\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n@@ -823,7 +823,7 @@ fn trait_method<'tcx>(\n     method_name: Symbol,\n     self_ty: Ty<'tcx>,\n     params: &[GenericArg<'tcx>],\n-) -> ty::Const<'tcx> {\n+) -> ConstantKind<'tcx> {\n     let substs = tcx.mk_substs_trait(self_ty, params);\n \n     // The unhygienic comparison here is acceptable because this is only\n@@ -836,5 +836,6 @@ fn trait_method<'tcx>(\n \n     let method_ty = tcx.type_of(item.def_id);\n     let method_ty = method_ty.subst(tcx, substs);\n-    ty::Const::zero_sized(tcx, method_ty)\n+\n+    ConstantKind::zero_sized(method_ty)\n }"}, {"sha": "84762d602f8db5030f46e9c4046ed9f3000bf833", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -3,6 +3,7 @@\n \n use crate::build::Builder;\n \n+use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, DUMMY_SP};\n@@ -25,16 +26,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    crate fn literal_operand(&mut self, span: Span, literal: ty::Const<'tcx>) -> Operand<'tcx> {\n-        let literal = literal.into();\n+    crate fn literal_operand(\n+        &mut self,\n+        span: Span,\n+        literal: mir::ConstantKind<'tcx>,\n+    ) -> Operand<'tcx> {\n         let constant = Box::new(Constant { span, user_ty: None, literal });\n         Operand::Constant(constant)\n     }\n \n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     crate fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = ty::Const::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n+        let literal = ConstantKind::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, literal)\n     }"}, {"sha": "7ef33011234fc4ff87cd426682c0b660e7769ef7", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::{BinOp, BorrowKind, Field, UnOp};\n+use rustc_middle::mir::{self, BinOp, BorrowKind, Field, UnOp};\n use rustc_middle::thir::*;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -491,7 +491,11 @@ impl<'tcx> Cx<'tcx> {\n                             hir::InlineAsmOperand::Const { ref anon_const } => {\n                                 let anon_const_def_id =\n                                     self.tcx.hir().local_def_id(anon_const.hir_id);\n-                                let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n+                                let value = mir::ConstantKind::from_anon_const(\n+                                    self.tcx,\n+                                    anon_const_def_id,\n+                                    self.param_env,\n+                                );\n                                 let span = self.tcx.hir().span(anon_const.hir_id);\n \n                                 InlineAsmOperand::Const { value, span }"}, {"sha": "72f0d07c260cac3aeb878d7949af6c08043d04a0", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -55,7 +55,7 @@ use rustc_hir::{HirId, RangeEnd};\n use rustc_middle::mir::Field;\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt, VariantDef};\n+use rustc_middle::ty::{self, Ty, TyCtxt, VariantDef};\n use rustc_middle::{middle::stability::EvalResult, mir::interpret::ConstValue};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n@@ -136,7 +136,7 @@ impl IntRange {\n     fn from_const<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: Const<'tcx>,\n+        value: ty::Const<'tcx>,\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n@@ -829,7 +829,8 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n             }\n             (Str(self_val), Str(other_val)) => {\n-                // FIXME: there's probably a more direct way of comparing for equality\n+                // FIXME Once valtrees are available we can directly use the bytes\n+                // in the `Str` variant of the valtree for the comparison here.\n                 match compare_const_vals(\n                     pcx.cx.tcx,\n                     *self_val,"}, {"sha": "dbcd701c1adddbecd8e9e4c4de7be5ab9efe3126", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -488,9 +488,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n             Ok(value) => {\n-                let const_ =\n-                    ty::Const::from_value(self.tcx, value, self.typeck_results.node_type(id));\n-\n+                let const_ = ty::Const::from_value(self.tcx, value, ty);\n                 let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n \n                 if !is_associated_const {\n@@ -585,7 +583,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n         match self.tcx.at(expr.span).lit_to_const(lit_input) {\n-            Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n+            Ok(constant) => *self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n             Err(LitToConstError::Reported) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n@@ -739,15 +737,14 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n crate fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     a: ty::Const<'tcx>,\n     b: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n-    trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n-\n     let from_bool = |v: bool| v.then_some(Ordering::Equal);\n \n     let fallback = || from_bool(a == b);"}, {"sha": "687b2e23c9fcb01cbf455addae52954f5a4955d2", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -765,10 +765,7 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-#[instrument(\n-    level = \"debug\",\n-    skip(cx, matrix, witness_preference, hir_id, is_under_guard, is_top_level)\n-)]\n+#[instrument(level = \"debug\", skip(cx, matrix, hir_id))]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n@@ -800,6 +797,7 @@ fn is_useful<'p, 'tcx>(\n \n     let ty = v.head().ty();\n     let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n+    debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n     let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n \n     // If the first pattern is an or-pattern, expand it.\n@@ -809,9 +807,11 @@ fn is_useful<'p, 'tcx>(\n         // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n         for v in v.expand_or_pat() {\n+            debug!(?v);\n             let usefulness = ensure_sufficient_stack(|| {\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false)\n             });\n+            debug!(?usefulness);\n             ret.extend(usefulness);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n@@ -822,6 +822,7 @@ fn is_useful<'p, 'tcx>(\n         }\n     } else {\n         let v_ctor = v.head().ctor();\n+        debug!(?v_ctor);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n             // Lint on likely incorrect range patterns (#63987)\n             ctor_range.lint_overlapping_range_endpoints(\n@@ -895,7 +896,7 @@ fn is_useful<'p, 'tcx>(\n }\n \n /// The arm of a match expression.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n crate struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n     crate pat: &'p DeconstructedPat<'p, 'tcx>,\n@@ -928,6 +929,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n ///\n /// Note: the input patterns must have been lowered through\n /// `check_match::MatchVisitor::lower_pattern`.\n+#[instrument(skip(cx, arms), level = \"debug\")]\n crate fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],\n@@ -939,6 +941,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         .iter()\n         .copied()\n         .map(|arm| {\n+            debug!(?arm);\n             let v = PatStack::from_pattern(arm.pat);\n             is_useful(cx, &matrix, &v, RealArm, arm.hir_id, arm.has_guard, true);\n             if !arm.has_guard {"}, {"sha": "5daa9796d12e4f615f6a0380b8dcfb7724123324", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -634,6 +634,7 @@ pub(super) fn thir_abstract_const<'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),"}, {"sha": "c0b3e95b18523fcbd40bb7523be6d0b96d6b6731", "filename": "src/tools/clippy/clippy_lints/src/matches/overlapping_arms.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -40,10 +40,8 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n-\n                     let lhs_val = lhs_const.int_value(cx, ty)?;\n                     let rhs_val = rhs_const.int_value(cx, ty)?;\n-\n                     let rhs_bound = match range_end {\n                         RangeEnd::Included => EndBound::Included(rhs_val),\n                         RangeEnd::Excluded => EndBound::Excluded(rhs_val),"}, {"sha": "6ba9ba0753d49f42e5ac974d10e7c8e0a9e5ce17", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.kind;\n-        if consts::lit_to_constant(&l.node, cx.typeck_results().expr_ty_opt(lit)) == Constant::Int(1);\n+        if consts::lit_to_mir_constant(&l.node, cx.typeck_results().expr_ty_opt(lit)) == Constant::Int(1);\n         if cx.typeck_results().expr_ty(exp).is_integral();\n \n         then {"}, {"sha": "be46b791aa4b656decb9406aeb5ee275136e8ce1", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c43e64eceb00e13b1932229aa9b2d774e6af96/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=e3c43e64eceb00e13b1932229aa9b2d774e6af96", "patch": "@@ -179,7 +179,7 @@ impl Constant {\n }\n \n /// Parses a `LitKind` to a `Constant`.\n-pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n+pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n     match *lit {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 if is_direct_expn_of(e.span, \"cfg\").is_some() {\n                     None\n                 } else {\n-                    Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e)))\n+                    Some(lit_to_mir_constant(&lit.node, self.typeck_results.expr_ty_opt(e)))\n                 }\n             },\n             ExprKind::Array(vec) => self.multi(vec).map(Constant::Vec),"}]}