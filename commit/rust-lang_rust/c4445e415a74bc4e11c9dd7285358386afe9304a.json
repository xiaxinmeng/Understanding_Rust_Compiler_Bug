{"sha": "c4445e415a74bc4e11c9dd7285358386afe9304a", "node_id": "C_kwDOAAsO6NoAKGM0NDQ1ZTQxNWE3NGJjNGUxMWM5ZGQ3Mjg1MzU4Mzg2YWZlOTMwNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-01T13:07:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-01T13:07:26Z"}, "message": "Auto merge of #13165 - Veykril:breakables, r=Veykril\n\nProperly handle break resolution inside non-breakable expressions\n\nWe now diagnose invalid `continue` expressions and properly handle things like `async` blocks which prevent labels from resolving further. Cleaned this up since `label_break_value` is on the way to stabilization in rust (\ud83c\udf89 finally) and we weren't handling breaks for blocks properly yet.", "tree": {"sha": "93ffa7d854f3f3a6f97b579869cda0e48d52167d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93ffa7d854f3f3a6f97b579869cda0e48d52167d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4445e415a74bc4e11c9dd7285358386afe9304a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4445e415a74bc4e11c9dd7285358386afe9304a", "html_url": "https://github.com/rust-lang/rust/commit/c4445e415a74bc4e11c9dd7285358386afe9304a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4445e415a74bc4e11c9dd7285358386afe9304a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "643c3a54de9da45f07ba9282c2ec7917d9ee7225", "url": "https://api.github.com/repos/rust-lang/rust/commits/643c3a54de9da45f07ba9282c2ec7917d9ee7225", "html_url": "https://github.com/rust-lang/rust/commit/643c3a54de9da45f07ba9282c2ec7917d9ee7225"}, {"sha": "c6b7f453088df08294372474085765e7c6361b9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b7f453088df08294372474085765e7c6361b9f", "html_url": "https://github.com/rust-lang/rust/commit/c6b7f453088df08294372474085765e7c6361b9f"}], "stats": {"total": 459, "additions": 312, "deletions": 147}, "files": [{"sha": "1563ee0b143851435a28597c8c088621e5c4a59b", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c4445e415a74bc4e11c9dd7285358386afe9304a/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/c4445e415a74bc4e11c9dd7285358386afe9304a/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=c4445e415a74bc4e11c9dd7285358386afe9304a", "patch": "@@ -6,15 +6,15 @@ on:\n   pull_request:\n   push:\n     branches:\n-    - auto\n-    - try\n+      - auto\n+      - try\n \n env:\n   CARGO_INCREMENTAL: 0\n   CARGO_NET_RETRY: 10\n   CI: 1\n   RUST_BACKTRACE: short\n-  RUSTFLAGS: \"-D warnings -W unreachable-pub -W rust-2021-compatibility\"\n+  RUSTFLAGS: \"-D warnings -W unreachable-pub -W bare-trait-objects\"\n   RUSTUP_MAX_RETRIES: 10\n \n jobs:\n@@ -31,25 +31,25 @@ jobs:\n         os: [ubuntu-latest, windows-latest, macos-latest]\n \n     steps:\n-    - name: Checkout repository\n-      uses: actions/checkout@v3\n-      with:\n-        ref: ${{ github.event.pull_request.head.sha }}\n-        fetch-depth: 20\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          ref: ${{ github.event.pull_request.head.sha }}\n+          fetch-depth: 20\n \n-    - name: Install Rust toolchain\n-      run: |\n-        rustup update --no-self-update stable\n-        rustup component add rustfmt rust-src\n+      - name: Install Rust toolchain\n+        run: |\n+          rustup update --no-self-update stable\n+          rustup component add rustfmt rust-src\n \n-    - name: Cache Dependencies\n-      uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+      - name: Cache Dependencies\n+        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n \n-    - name: Compile\n-      run: cargo test --no-run --locked\n+      - name: Compile\n+        run: cargo test --no-run --locked\n \n-    - name: Test\n-      run: cargo test -- --nocapture --quiet\n+      - name: Test\n+        run: cargo test -- --nocapture --quiet\n \n   # Weird targets to catch non-portable code\n   rust-cross:\n@@ -64,25 +64,25 @@ jobs:\n       targets_ide: \"wasm32-unknown-unknown\"\n \n     steps:\n-    - name: Checkout repository\n-      uses: actions/checkout@v3\n-\n-    - name: Install Rust toolchain\n-      run: |\n-        rustup update --no-self-update stable\n-        rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n-\n-    - name: Cache Dependencies\n-      uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n-\n-    - name: Check\n-      run: |\n-        for target in ${{ env.targets }}; do\n-          cargo check --target=$target --all-targets\n-        done\n-        for target in ${{ env.targets_ide }}; do\n-          cargo check -p ide --target=$target --all-targets\n-        done\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+\n+      - name: Install Rust toolchain\n+        run: |\n+          rustup update --no-self-update stable\n+          rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n+\n+      - name: Cache Dependencies\n+        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+\n+      - name: Check\n+        run: |\n+          for target in ${{ env.targets }}; do\n+            cargo check --target=$target --all-targets\n+          done\n+          for target in ${{ env.targets_ide }}; do\n+            cargo check -p ide --target=$target --all-targets\n+          done\n \n   typescript:\n     if: github.repository == 'rust-lang/rust-analyzer'\n@@ -95,47 +95,47 @@ jobs:\n     runs-on: ${{ matrix.os }}\n \n     steps:\n-    - name: Checkout repository\n-      uses: actions/checkout@v3\n-\n-    - name: Install Nodejs\n-      uses: actions/setup-node@v1\n-      with:\n-        node-version: 16.x\n-\n-    - name: Install xvfb\n-      if: matrix.os == 'ubuntu-latest'\n-      run: sudo apt-get install -y xvfb\n-\n-    - run: npm ci\n-      working-directory: ./editors/code\n-\n-#    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n-#      if: runner.os == 'Linux'\n-#      working-directory: ./editors/code\n-\n-    - run: npm run lint\n-      working-directory: ./editors/code\n-\n-    - name: Run VS Code tests (Linux)\n-      if: matrix.os == 'ubuntu-latest'\n-      env:\n-        VSCODE_CLI: 1\n-      run: xvfb-run npm test\n-      working-directory: ./editors/code\n-\n-    - name: Run VS Code tests (Windows)\n-      if: matrix.os == 'windows-latest'\n-      env:\n-        VSCODE_CLI: 1\n-      run: npm test\n-      working-directory: ./editors/code\n-\n-    - run: npm run pretest\n-      working-directory: ./editors/code\n-\n-    - run: npm run package --scripts-prepend-node-path\n-      working-directory: ./editors/code\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+\n+      - name: Install Nodejs\n+        uses: actions/setup-node@v1\n+        with:\n+          node-version: 16.x\n+\n+      - name: Install xvfb\n+        if: matrix.os == 'ubuntu-latest'\n+        run: sudo apt-get install -y xvfb\n+\n+      - run: npm ci\n+        working-directory: ./editors/code\n+\n+      #    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n+      #      if: runner.os == 'Linux'\n+      #      working-directory: ./editors/code\n+\n+      - run: npm run lint\n+        working-directory: ./editors/code\n+\n+      - name: Run VS Code tests (Linux)\n+        if: matrix.os == 'ubuntu-latest'\n+        env:\n+          VSCODE_CLI: 1\n+        run: xvfb-run npm test\n+        working-directory: ./editors/code\n+\n+      - name: Run VS Code tests (Windows)\n+        if: matrix.os == 'windows-latest'\n+        env:\n+          VSCODE_CLI: 1\n+        run: npm test\n+        working-directory: ./editors/code\n+\n+      - run: npm run pretest\n+        working-directory: ./editors/code\n+\n+      - run: npm run package --scripts-prepend-node-path\n+        working-directory: ./editors/code\n \n   end-success:\n     name: bors build finished"}, {"sha": "10ffde87eef1491b4c6777db2c19309ff6f36f4e", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=c4445e415a74bc4e11c9dd7285358386afe9304a", "patch": "@@ -182,7 +182,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n-    BreakOutsideOfLoop { expr: ExprId },\n+    BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n \n@@ -418,18 +418,45 @@ pub(crate) struct InferenceContext<'a> {\n \n #[derive(Clone, Debug)]\n struct BreakableContext {\n+    /// Whether this context contains at least one break expression.\n     may_break: bool,\n+    /// The coercion target of the context.\n     coerce: CoerceMany,\n+    /// The optional label of the context.\n     label: Option<name::Name>,\n+    kind: BreakableKind,\n+}\n+\n+#[derive(Clone, Debug)]\n+enum BreakableKind {\n+    Block,\n+    Loop,\n+    /// A border is something like an async block, closure etc. Anything that prevents\n+    /// breaking/continuing through\n+    Border,\n }\n \n fn find_breakable<'c>(\n     ctxs: &'c mut [BreakableContext],\n     label: Option<&name::Name>,\n+) -> Option<&'c mut BreakableContext> {\n+    let mut ctxs = ctxs\n+        .iter_mut()\n+        .rev()\n+        .take_while(|it| matches!(it.kind, BreakableKind::Block | BreakableKind::Loop));\n+    match label {\n+        Some(_) => ctxs.find(|ctx| ctx.label.as_ref() == label),\n+        None => ctxs.find(|ctx| matches!(ctx.kind, BreakableKind::Loop)),\n+    }\n+}\n+\n+fn find_continuable<'c>(\n+    ctxs: &'c mut [BreakableContext],\n+    label: Option<&name::Name>,\n ) -> Option<&'c mut BreakableContext> {\n     match label {\n-        Some(_) => ctxs.iter_mut().rev().find(|ctx| ctx.label.as_ref() == label),\n-        None => ctxs.last_mut(),\n+        Some(_) => find_breakable(ctxs, label).filter(|it| matches!(it.kind, BreakableKind::Loop)),\n+        None => find_breakable(ctxs, label),\n     }\n }\n "}, {"sha": "f3f4ee65bb2e18f5e3316765084fa602e9dd7594", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c4445e415a74bc4e11c9dd7285358386afe9304a", "patch": "@@ -10,7 +10,7 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Statement, UnaryOp},\n+    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, LabelId, Literal, Statement, UnaryOp},\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -23,7 +23,7 @@ use syntax::ast::RangeOp;\n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::coerce::CoerceMany,\n+    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n@@ -120,32 +120,37 @@ impl<'a> InferenceContext<'a> {\n                 let ty = match label {\n                     Some(_) => {\n                         let break_ty = self.table.new_type_var();\n-                        self.breakables.push(BreakableContext {\n-                            may_break: false,\n-                            coerce: CoerceMany::new(break_ty.clone()),\n-                            label: label.map(|label| self.body[label].name.clone()),\n-                        });\n-                        let ty = self.infer_block(\n-                            tgt_expr,\n-                            statements,\n-                            *tail,\n-                            &Expectation::has_type(break_ty),\n+                        let (breaks, ty) = self.with_breakable_ctx(\n+                            BreakableKind::Block,\n+                            break_ty.clone(),\n+                            *label,\n+                            |this| {\n+                                this.infer_block(\n+                                    tgt_expr,\n+                                    statements,\n+                                    *tail,\n+                                    &Expectation::has_type(break_ty),\n+                                )\n+                            },\n                         );\n-                        let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n-                        if ctxt.may_break {\n-                            ctxt.coerce.complete()\n-                        } else {\n-                            ty\n-                        }\n+                        breaks.unwrap_or(ty)\n                     }\n                     None => self.infer_block(tgt_expr, statements, *tail, expected),\n                 };\n                 self.resolver = old_resolver;\n                 ty\n             }\n-            Expr::Unsafe { body } | Expr::Const { body } => self.infer_expr(*body, expected),\n+            Expr::Unsafe { body } => self.infer_expr(*body, expected),\n+            Expr::Const { body } => {\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    this.infer_expr(*body, expected)\n+                })\n+                .1\n+            }\n             Expr::TryBlock { body } => {\n-                let _inner = self.infer_expr(*body, expected);\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    let _inner = this.infer_expr(*body, expected);\n+                });\n                 // FIXME should be std::result::Result<{inner}, _>\n                 self.err_ty()\n             }\n@@ -154,7 +159,10 @@ impl<'a> InferenceContext<'a> {\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n-                let inner_ty = self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                let (_, inner_ty) =\n+                    self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                        this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n+                    });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n@@ -166,54 +174,44 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n                     .intern(Interner)\n             }\n-            Expr::Loop { body, label } => {\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.table.new_type_var()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n-                });\n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-\n-                let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+            &Expr::Loop { body, label } => {\n+                let ty = self.table.new_type_var();\n+                let (breaks, ()) =\n+                    self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n+                        this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    });\n \n-                if ctxt.may_break {\n-                    self.diverges = Diverges::Maybe;\n-                    ctxt.coerce.complete()\n-                } else {\n-                    TyKind::Never.intern(Interner)\n+                match breaks {\n+                    Some(breaks) => {\n+                        self.diverges = Diverges::Maybe;\n+                        breaks\n+                    }\n+                    None => TyKind::Never.intern(Interner),\n                 }\n             }\n-            Expr::While { condition, body, label } => {\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.err_ty()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n+            &Expr::While { condition, body, label } => {\n+                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                    this.infer_expr(\n+                        condition,\n+                        &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                    );\n+                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n                 });\n-                self.infer_expr(\n-                    *condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n-                );\n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::For { iterable, body, pat, label } => {\n-                let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.err_ty()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n-                });\n+            &Expr::For { iterable, body, pat, label } => {\n+                let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n-                self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+                self.infer_pat(pat, &pat_ty, BindingMode::default());\n+                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                });\n \n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n@@ -269,7 +267,9 @@ impl<'a> InferenceContext<'a> {\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n-                self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n@@ -372,7 +372,15 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n             }\n-            Expr::Continue { .. } => TyKind::Never.intern(Interner),\n+            Expr::Continue { label } => {\n+                if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n+                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                        expr: tgt_expr,\n+                        is_break: false,\n+                    });\n+                };\n+                TyKind::Never.intern(Interner)\n+            }\n             Expr::Break { expr, label } => {\n                 let mut coerce = match find_breakable(&mut self.breakables, label.as_ref()) {\n                     Some(ctxt) => {\n@@ -400,6 +408,7 @@ impl<'a> InferenceContext<'a> {\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n+                        is_break: true,\n                     });\n                 };\n \n@@ -1472,4 +1481,20 @@ impl<'a> InferenceContext<'a> {\n             },\n         })\n     }\n+\n+    fn with_breakable_ctx<T>(\n+        &mut self,\n+        kind: BreakableKind,\n+        ty: Ty,\n+        label: Option<LabelId>,\n+        cb: impl FnOnce(&mut Self) -> T,\n+    ) -> (Option<Ty>, T) {\n+        self.breakables.push({\n+            let label = label.map(|label| self.body[label].name.clone());\n+            BreakableContext { kind, may_break: false, coerce: CoerceMany::new(ty), label }\n+        });\n+        let res = cb(self);\n+        let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n+        (ctx.may_break.then(|| ctx.coerce.complete()), res)\n+    }\n }"}, {"sha": "5edc16d8bce9060262914d14060b4bfd1cb3e6d2", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=c4445e415a74bc4e11c9dd7285358386afe9304a", "patch": "@@ -124,6 +124,7 @@ pub struct NoSuchField {\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub is_break: bool,\n }\n \n #[derive(Debug)]"}, {"sha": "e4bb63a864719956e4b31b76e8994852f3b3ca55", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c4445e415a74bc4e11c9dd7285358386afe9304a", "patch": "@@ -1216,11 +1216,11 @@ impl DefWithBody {\n                     let field = source_map.field_syntax(*expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n                     let expr = source_map\n-                        .expr_syntax(*expr)\n+                        .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n-                    acc.push(BreakOutsideOfLoop { expr }.into())\n+                    acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     match source_map.expr_syntax(*call_expr) {"}, {"sha": "0c92e706b3916f65c73df4b6e3945b4e6501a052", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 116, "deletions": 4, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4445e415a74bc4e11c9dd7285358386afe9304a/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=c4445e415a74bc4e11c9dd7285358386afe9304a", "patch": "@@ -7,9 +7,10 @@ pub(crate) fn break_outside_of_loop(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::BreakOutsideOfLoop,\n ) -> Diagnostic {\n+    let construct = if d.is_break { \"break\" } else { \"continue\" };\n     Diagnostic::new(\n         \"break-outside-of-loop\",\n-        \"break outside of loop\",\n+        format!(\"{construct} outside of loop\"),\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n }\n@@ -19,11 +20,122 @@ mod tests {\n     use crate::tests::check_diagnostics;\n \n     #[test]\n-    fn break_outside_of_loop() {\n+    fn outside_of_loop() {\n         check_diagnostics(\n             r#\"\n-fn foo() { break; }\n-         //^^^^^ error: break outside of loop\n+fn foo() {\n+    break;\n+  //^^^^^ error: break outside of loop\n+    break 'a;\n+  //^^^^^^^^ error: break outside of loop\n+    continue;\n+  //^^^^^^^^ error: continue outside of loop\n+    continue 'a;\n+  //^^^^^^^^^^^ error: continue outside of loop\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn async_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closures_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn blocks_pass_through() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        {\n+            break;\n+            break 'a;\n+            continue;\n+            continue 'a;\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn label_blocks() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: {\n+        break;\n+      //^^^^^ error: break outside of loop\n+        break 'a;\n+        continue;\n+      //^^^^^^^^ error: continue outside of loop\n+        continue 'a;\n+      //^^^^^^^^^^^ error: continue outside of loop\n+    }\n+}\n \"#,\n         );\n     }"}]}