{"sha": "a70babed03d58d042024e41f0a46f7e33e34d0d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MGJhYmVkMDNkNThkMDQyMDI0ZTQxZjBhNDZmN2UzM2UzNGQwZDE=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-04T12:45:36Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-06T16:24:36Z"}, "message": "Use a function to access the Hir map to be able to turn it into a query later", "tree": {"sha": "78f557eea7a424eba2c1fa75da9a6845c2607bd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78f557eea7a424eba2c1fa75da9a6845c2607bd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a70babed03d58d042024e41f0a46f7e33e34d0d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a70babed03d58d042024e41f0a46f7e33e34d0d1", "html_url": "https://github.com/rust-lang/rust/commit/a70babed03d58d042024e41f0a46f7e33e34d0d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a70babed03d58d042024e41f0a46f7e33e34d0d1/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "367e783e6f66a4dba32decdc68a262953d2f3f1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/367e783e6f66a4dba32decdc68a262953d2f3f1b", "html_url": "https://github.com/rust-lang/rust/commit/367e783e6f66a4dba32decdc68a262953d2f3f1b"}], "stats": {"total": 2430, "additions": 1220, "deletions": 1210}, "files": [{"sha": "457f33f8bd7b93485ad7ba22cc33f4fe9ad2f365", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -53,7 +53,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let body_exit;\n \n     // Find the tables for this body.\n-    let owner_def_id = tcx.hir.local_def_id(tcx.hir.body_owner(body.id()));\n+    let owner_def_id = tcx.hir().local_def_id(tcx.hir().body_owner(body.id()));\n     let tables = tcx.typeck_tables_of(owner_def_id);\n \n     let mut cfg_builder = CFGBuilder {\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let hir_id = self.tcx.hir.node_to_hir_id(stmt.node.id());\n+        let hir_id = self.tcx.hir().node_to_hir_id(stmt.node.id());\n         match stmt.node {\n             hir::StmtKind::Decl(ref decl, _) => {\n                 let exit = self.decl(&decl, pred);\n@@ -588,9 +588,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match destination.target_id {\n             Ok(loop_id) => {\n                 for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n+                    if b.block_expr_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {\n@@ -600,9 +600,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     }\n                 }\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n+                    if l.loop_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {"}, {"sha": "39810691df85527b059f1f0190b9e642c5c29cdd", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -32,11 +32,11 @@ pub struct LabelledCFG<'a, 'tcx: 'a> {\n impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n     fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n         assert!(self.cfg.owner_def_id.is_local());\n-        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n-            owner: self.tcx.hir.def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n+        let node_id = self.tcx.hir().hir_to_node_id(hir::HirId {\n+            owner: self.tcx.hir().def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n             local_id\n         });\n-        let s = self.tcx.hir.node_to_string(node_id);\n+        let s = self.tcx.hir().node_to_string(node_id);\n \n         // Replacing newlines with \\\\l causes each line to be left-aligned,\n         // improving presentation of (long) pretty-printed expressions."}, {"sha": "dd46dd3fd6461f8355c771120a6cb9faa694b51a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -449,10 +449,10 @@ define_dep_nodes!( <'tcx>\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n     // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.hir.krate()`), we will have to assume that any change\n+    // `tcx.hir().krate()`), we will have to assume that any change\n     // means that you need to be recompiled. This is because the\n     // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.hir.krate()`; instead, prefer\n+    // this fate, do not call `tcx.hir().krate()`; instead, prefer\n     // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n     // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n     // access to the krate, but you must remember to add suitable\n@@ -733,7 +733,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n-        tcx.hir.definitions().def_path_hash(*self).0\n+        tcx.hir().definitions().def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {"}, {"sha": "da7dabf6e1839f4a6bb6493a8e0c0d3d514ae253", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -65,7 +65,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     ///\n     /// ```\n     /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n-    ///     let item_def_id = ccx.tcx.hir.local_def_id(it.id);\n+    ///     let item_def_id = ccx.tcx.hir().local_def_id(it.id);\n     ///     ccx.tcx.item_types.memoized(item_def_id, || {\n     ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n     ///         compute_type_of_item(ccx, item)"}, {"sha": "5ff533fe34b2d91f327b57ebfc4dad4bcb343bb6", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir.local_def_id(item.id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.id));\n         } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut checker = CheckAttrVisitor { tcx };\n-    tcx.hir.krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n }\n \n fn is_c_like_enum(item: &hir::Item) -> bool {"}, {"sha": "f8bc764572f02b11a7cc0d3093fed33f66355412", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -19,7 +19,7 @@ use super::intravisit::Visitor;\n ///\n /// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n ///    - Example: find all items with a `#[foo]` attribute on them.\n-///    - How: Implement `ItemLikeVisitor` and call `tcx.hir.krate().visit_all_item_likes()`.\n+///    - How: Implement `ItemLikeVisitor` and call `tcx.hir().krate().visit_all_item_likes()`.\n ///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n ///    - Con: Don't get information about nesting\n ///    - Con: Don't have methods for specific bits of HIR, like \"on\n@@ -29,7 +29,7 @@ use super::intravisit::Visitor;\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n ///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.hir.krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n+///      `tcx.hir().krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n ///      your `intravisit::Visitor` impl, implement methods like\n ///      `visit_expr()`; don't forget to invoke\n ///      `intravisit::walk_visit_expr()` to keep walking the subparts.\n@@ -43,7 +43,7 @@ use super::intravisit::Visitor;\n ///    - How: Implement `intravisit::Visitor` and override the\n ///      `nested_visit_map()` methods to return\n ///      `NestedVisitorMap::All`. Walk your crate with\n-///      `intravisit::walk_crate()` invoked on `tcx.hir.krate()`.\n+///      `intravisit::walk_crate()` invoked on `tcx.hir().krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking."}, {"sha": "99c92e1e31db19eac169017a75687d22f9c94012", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -1258,8 +1258,8 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n }\n \n pub fn describe_def(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<Def> {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        tcx.hir.describe_def(node_id)\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+        tcx.hir().describe_def(node_id)\n     } else {\n         bug!(\"Calling local describe_def query provider for upstream DefId: {:?}\",\n              def_id)"}, {"sha": "7d997a01546002f8a6faa2ccbb0d7b5cb38c0230", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n-                let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n+                let tag = match self.hir().find(scope.node_id(self, region_scope_tree)) {\n                     Some(Node::Block(_)) => \"block\",\n                     Some(Node::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n@@ -190,8 +190,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let cm = self.sess.source_map();\n \n         let scope = region.free_region_binding_scope(self);\n-        let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n-        let tag = match self.hir.find(node) {\n+        let node = self.hir().as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n+        let tag = match self.hir().find(node) {\n             Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n             Some(Node::Item(it)) => Self::item_scope_tag(&it),\n             Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n@@ -200,8 +200,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir\n+                let mut sp = cm.def_span(self.hir().span(node));\n+                if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&br.name))\n                 {\n@@ -213,8 +213,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 bound_region: ty::BoundRegion::BrNamed(_, ref name),\n                 ..\n             }) => {\n-                let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir\n+                let mut sp = cm.def_span(self.hir().span(node));\n+                if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&name))\n                 {\n@@ -225,15 +225,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir.span(node),\n+                    self.hir().span(node),\n                 ),\n                 ty::BrFresh(_) => (\n                     \"an anonymous lifetime defined on\".to_owned(),\n-                    self.hir.span(node),\n+                    self.hir().span(node),\n                 ),\n                 _ => (\n                     format!(\"the lifetime {} as defined on\", fr.bound_region),\n-                    cm.def_span(self.hir.span(node)),\n+                    cm.def_span(self.hir().span(node)),\n                 ),\n             },\n             _ => bug!(),\n@@ -1083,7 +1083,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // the expected type argument.\n                     if !param.is_self() {\n                         let type_param = generics.type_param(param, self.tcx);\n-                        let hir = &self.tcx.hir;\n+                        let hir = &self.tcx.hir();\n                         hir.as_local_node_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n@@ -1315,8 +1315,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir.name(var_node_id);\n+                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(var_node_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),"}, {"sha": "4064df0a09d7ff13cf5b1bd46330b7d18f4cf28d", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -109,13 +109,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut local_visitor = FindLocalByTypeVisitor {\n             infcx: &self,\n             target_ty: &ty,\n-            hir_map: &self.tcx.hir,\n+            hir_map: &self.tcx.hir(),\n             found_local_pattern: None,\n             found_arg_pattern: None,\n         };\n \n         if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir.expect_expr(body_id.node_id);\n+            let expr = self.tcx.hir().expect_expr(body_id.node_id);\n             local_visitor.visit_expr(expr);\n         }\n "}, {"sha": "38363be48271506059840e85164266950e3892d4", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -38,8 +38,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n         if let Some(anon_reg) = self.tcx.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let fndecl = match self.tcx.hir.get(node_id) {\n+            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n+                let fndecl = match self.tcx.hir().get(node_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n@@ -104,7 +104,7 @@ struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n@@ -124,7 +124,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n             hir::TyKind::Rptr(ref lifetime, _) => {\n                 // the lifetime of the TyRptr\n-                let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(lifetime.id);\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n                     // Find the index of the anonymous region that was part of the\n                     // error. We will then search the function parameters for a bound\n@@ -150,7 +150,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     // region at the right depth with the same index\n                     (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n                         debug!(\n-                            \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                            \"EarlyBound self.infcx.tcx.hir().local_def_id(id)={:?} \\\n                              def_id={:?}\",\n                             id,\n                             def_id\n@@ -172,7 +172,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                             \"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n                             debruijn_index\n                         );\n-                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n+                        debug!(\"self.infcx.tcx.hir().local_def_id(id)={:?}\", id);\n                         debug!(\"def_id={:?}\", def_id);\n                         if debruijn_index == self.current_index && id == def_id {\n                             self.found_type = Some(arg);\n@@ -227,11 +227,11 @@ struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(lifetime.id);\n         match (self.tcx.named_region(hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n             (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n@@ -243,7 +243,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n \n             (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n                 debug!(\n-                    \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                    \"EarlyBound self.infcx.tcx.hir().local_def_id(id)={:?} \\\n                      def_id={:?}\",\n                     id,\n                     def_id"}, {"sha": "4c3fbc79646592b4767797273d92bf18ed188302", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             // closure, provide a specific message pointing this out.\n             if let (&SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n-                let hir = &self.tcx.hir;\n+                let hir = &self.tcx.hir();\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     if let Node::Expr(Expr {\n                         node: Closure(_, _, _, closure_span, None),"}, {"sha": "e5c2c75a3f3843c553fc64451a28cd3060d7a31d", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir = &self.tcx.hir;\n+        let hir = &self.tcx.hir();\n         if let Some(node_id) = hir.as_local_node_id(id) {\n             if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n                 let body = hir.body(body_id);"}, {"sha": "f5ac39ae838f6f0d23d1ae2f3c2ca580dd415640", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -41,8 +41,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir.name(var_node_id);\n+                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(var_node_id);\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\", var_name));\n             }\n@@ -61,7 +61,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               &format!(\"...so that captured variable `{}` does not outlive the \\\n                                         enclosing closure\",\n-                                       self.tcx.hir.name(id)));\n+                                       self.tcx.hir().name(id)));\n             }\n             infer::IndexSlice(span) => {\n                 err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n@@ -174,8 +174,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir.name(var_node_id);\n+                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(var_node_id);\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0313,\n@@ -232,7 +232,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0474,\n                                                \"captured variable `{}` does not outlive the \\\n                                                 enclosing closure\",\n-                                               self.tcx.hir.name(id));\n+                                               self.tcx.hir().name(id));\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"captured variable is valid for \", sup, \"\");\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err,"}, {"sha": "09053118f696123eef07da9b84882d77308aa27d", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -691,13 +691,13 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     //     let x = || foo(); // returns the Opaque assoc with `foo`\n                     // }\n                     // ```\n-                    if let Some(opaque_node_id) = tcx.hir.as_local_node_id(def_id) {\n+                    if let Some(opaque_node_id) = tcx.hir().as_local_node_id(def_id) {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n-                            let opaque_parent_node_id = tcx.hir.get_parent(opaque_node_id);\n-                            parent_def_id == tcx.hir.local_def_id(opaque_parent_node_id)\n+                            let opaque_parent_node_id = tcx.hir().get_parent(opaque_node_id);\n+                            parent_def_id == tcx.hir().local_def_id(opaque_parent_node_id)\n                         };\n-                        let in_definition_scope = match tcx.hir.find(opaque_node_id) {\n+                        let in_definition_scope = match tcx.hir().find(opaque_node_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -725,7 +725,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n-                                tcx.hir.node_to_string(opaque_node_id),\n+                                tcx.hir().node_to_string(opaque_node_id),\n                             ),\n                         };\n                         if in_definition_scope {\n@@ -848,16 +848,16 @@ pub fn may_define_existential_type(\n     opaque_node_id: ast::NodeId,\n ) -> bool {\n     let mut node_id = tcx\n-        .hir\n+        .hir()\n         .as_local_node_id(def_id)\n         .unwrap();\n     // named existential types can be defined by any siblings or\n     // children of siblings\n-    let mod_id = tcx.hir.get_parent(opaque_node_id);\n+    let mod_id = tcx.hir().get_parent(opaque_node_id);\n     // so we walk up the node tree until we hit the root or the parent\n     // of the opaque type\n     while node_id != mod_id && node_id != ast::CRATE_NODE_ID {\n-        node_id = tcx.hir.get_parent(node_id);\n+        node_id = tcx.hir().get_parent(node_id);\n     }\n     // syntactically we are allowed to define the concrete type\n     node_id == mod_id"}, {"sha": "c633c0fb0360af45a71c86c4c01f4a72172f636e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -774,7 +774,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         where F: FnOnce(&mut Self),\n     {\n         let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir.local_def_id(id));\n+        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id(id));\n         f(self);\n         self.param_env = old_param_env;\n     }\n@@ -797,13 +797,13 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.tcx.hir)\n+        hir_visit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -866,7 +866,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         // in order for `check_fn` to be able to use them.\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body_id);\n-        let body = self.tcx.hir.body(body_id);\n+        let body = self.tcx.hir().body(body_id);\n         run_lints!(self, check_fn, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, fk, decl, body, span, id);\n@@ -1191,7 +1191,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let passes = tcx.sess.lint_store.borrow_mut().late_passes.take();\n \n     let passes = {"}, {"sha": "f54fdf8b46875d1a7efd34e948431d45e6839de8", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -643,7 +643,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n         levels: LintLevelSets::builder(tcx.sess),\n         tcx: tcx,\n     };\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n \n     builder.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |builder| {\n         intravisit::walk_crate(builder, krate);\n@@ -665,15 +665,15 @@ impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n         where F: FnOnce(&mut Self)\n     {\n         let push = self.levels.push(attrs);\n-        self.levels.register_id(self.tcx.hir.definitions().node_to_hir_id(id));\n+        self.levels.register_id(self.tcx.hir().definitions().node_to_hir_id(id));\n         f(self);\n         self.levels.pop(push);\n     }\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {"}, {"sha": "807d5a31143d93407a70fbff9b55ed42a6fa39e8", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -35,7 +35,7 @@ use syntax_pos;\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n-    match tcx.hir.find(node_id) {\n+    match tcx.hir().find(node_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n@@ -59,7 +59,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n             if should_explore(self.tcx, node_id) {\n                 self.worklist.push(node_id);\n             }\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n             debug_assert!(!should_explore(self.tcx, node_id));\n             self.live_symbols.insert(node_id);\n         }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref node) = self.tcx.hir.find(id) {\n+            if let Some(ref node) = self.tcx.hir().find(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id(item.id);\n                         let def = self.tcx.adt_def(def_id);\n                         self.repr_has_repr_c = def.repr.c();\n \n@@ -206,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -307,7 +307,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n         return true;\n     }\n \n-    let def_id = tcx.hir.local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n     // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n@@ -469,7 +469,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n+        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n         !field.is_positional()\n             && !self.symbol_is_live(field.id, None)\n             && !field_type.is_phantom_data()\n@@ -510,11 +510,11 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = self.tcx.hir.local_def_id(id);\n+        let def_id = self.tcx.hir().local_def_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {\n+                if let Some(item_node_id) = self.tcx.hir().as_local_node_id(item_did) {\n                     if self.live_symbols.contains(&item_node_id) {\n                         return true;\n                     }\n@@ -547,7 +547,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -648,7 +648,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor {\n         tcx,"}, {"sha": "32e23a67bdc3b9cbb9664f4062fbf0a48e80d913", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -622,7 +622,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 local.pat.each_binding(|_, hir_id, span, _| {\n-                    let node_id = self.mc.tcx.hir.hir_to_node_id(hir_id);\n+                    let node_id = self.mc.tcx.hir().hir_to_node_id(hir_id);\n                     self.delegate.decl_without_init(node_id, span);\n                 })\n             }\n@@ -935,8 +935,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let var_hir_id = self.tcx().hir.node_to_hir_id(freevar.var_id());\n-                let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n+                let var_hir_id = self.tcx().hir().node_to_hir_id(freevar.var_id());\n+                let closure_def_id = self.tcx().hir().local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n@@ -973,7 +973,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_hir_id = self.tcx().hir.node_to_hir_id(upvar.var_id());\n+        let var_hir_id = self.tcx().hir().node_to_hir_id(upvar.var_id());\n         let var_ty = self.mc.node_ty(var_hir_id)?;\n         self.mc.cat_def(closure_hir_id, closure_span, var_ty, upvar.def)\n     }"}, {"sha": "fa34c2e63daa903997bfcdeb226147c53658c3e9", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -23,7 +23,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = ItemVisitor {\n         tcx,\n     };\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct ItemVisitor<'a, 'tcx: 'a> {\n@@ -134,8 +134,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        let owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n-        let body = self.tcx.hir.body(body_id);\n+        let owner_def_id = self.tcx.hir().body_owner_def_id(body_id);\n+        let body = self.tcx.hir().body(body_id);\n         let param_env = self.tcx.param_env(owner_def_id);\n         let tables = self.tcx.typeck_tables_of(owner_def_id);\n         ExprVisitor { tcx: self.tcx, param_env, tables }.visit_body(body);"}, {"sha": "f0f8124c076f6c7d5eef48fea000c333759857c5", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             match self.item_refs.get(&*value.as_str()).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir.local_def_id(item.id);\n+                    let def_id = self.tcx.hir().local_def_id(item.id);\n                     self.collect_item(item_index, def_id);\n                 },\n                 // Known lang item with attribute on incorrect target.\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n         if let Some(original_def_id) = self.items.items[item_index] {\n             if original_def_id != item_def_id {\n                 let name = LangItem::from_u32(item_index as u32).unwrap().name();\n-                let mut err = match self.tcx.hir.span_if_local(item_def_id) {\n+                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n                         self.tcx.sess,\n                         span,\n@@ -183,7 +183,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n                             self.tcx.crate_name(item_def_id.krate),\n                             name)),\n                 };\n-                if let Some(span) = self.tcx.hir.span_if_local(original_def_id) {\n+                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n                     span_note!(&mut err, span, \"first defined here.\");\n                 } else {\n                     err.note(&format!(\"first defined in crate `{}`.\",\n@@ -221,7 +221,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n             collector.collect_item(item_index, def_id);\n         }\n     }\n-    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n     let LanguageItemCollector { mut items, .. } = collector;\n     weak_lang_items::check_crate(tcx, &mut items);\n     items"}, {"sha": "a33ef10a27b76cf73a571ee5fa1f50a8dedbb7a3", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx Attribute) {\n@@ -152,6 +152,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n-    intravisit::walk_crate(&mut collector, tcx.hir.krate());\n+    intravisit::walk_crate(&mut collector, tcx.hir().krate());\n     collector.lib_features\n }"}, {"sha": "b7cea975e0a229f96e3ca15ba03ebe20d746d3e7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -176,7 +176,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> Strin\n \n impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir.krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -362,8 +362,8 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n-        let parent = ir.tcx.hir.get_parent(id);\n-        if let Some(Node::Item(i)) = ir.tcx.hir.find(parent) {\n+        let parent = ir.tcx.hir().get_parent(id);\n+        if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n             if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n                 return;\n             }\n@@ -372,7 +372,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps<'_, '_>);\n \n-    let body = ir.tcx.hir.body(body_id);\n+    let body = ir.tcx.hir().body(body_id);\n \n     for arg in &body.arguments {\n         arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n@@ -476,7 +476,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n             call_caps.extend(freevars.iter().filter_map(|fv| {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n-                    let var_hid = ir.tcx.hir.node_to_hir_id(rv);\n+                    let var_hid = ir.tcx.hir().node_to_hir_id(rv);\n                     Some(CaptureInfo { ln: fv_ln, var_hid })\n                 } else {\n                     None\n@@ -924,7 +924,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir.node_to_pretty_string(body.id));\n+        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir().node_to_pretty_string(body.id));\n \n         let exit_ln = self.s.exit_ln;\n \n@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().node_to_pretty_string(expr.id));\n \n         match expr.node {\n             // Interesting cases with control flow or which gen/kill\n@@ -1035,7 +1035,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Closure(.., blk_id, _, _) => {\n                 debug!(\"{} is an ExprKind::Closure\",\n-                       self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+                       self.ir.tcx.hir().node_to_pretty_string(expr.id));\n \n                 // The next-node for a break is the successor of the entire\n                 // loop. The next-node for a continue is the top of this loop.\n@@ -1356,7 +1356,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let ln = self.live_node(hir_id, span);\n         if acc != 0 {\n             self.init_from_succ(ln, succ);\n-            let var_hid = self.ir.tcx.hir.node_to_hir_id(nid);\n+            let var_hid = self.ir.tcx.hir().node_to_hir_id(nid);\n             let var = self.variable(var_hid, span);\n             self.acc(ln, var, acc);\n         }\n@@ -1413,7 +1413,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, self.ir.tcx.hir.node_to_pretty_string(body.id));\n+               expr.id, self.ir.tcx.hir().node_to_pretty_string(body.id));\n \n         let break_ln = succ;\n         let cont_ln = ln;\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n                     let ln = self.live_node(expr.hir_id, expr.span);\n-                    let var_hid = self.ir.tcx.hir.node_to_hir_id(nid);\n+                    let var_hid = self.ir.tcx.hir().node_to_hir_id(nid);\n                     let var = self.variable(var_hid, expr.span);\n                     self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n                 }"}, {"sha": "c8fd75a6ec9d8f8afb2c2e5ed8f9eeca74651ddc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -348,7 +348,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>,\n                   id: ast::NodeId) -> MutabilityCategory {\n-        let ret = match tcx.hir.get(id) {\n+        let ret = match tcx.hir().get(id) {\n             Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n@@ -362,7 +362,7 @@ impl MutabilityCategory {\n                 }\n                 _ => span_bug!(p.span, \"expected identifier pattern\")\n             },\n-            _ => span_bug!(tcx.hir.span(id), \"expected identifier pattern\")\n+            _ => span_bug!(tcx.hir().span(id), \"expected identifier pattern\")\n         };\n         debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n                \"from_local\", id, ret);\n@@ -495,9 +495,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // FIXME\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n-                let id = self.tcx.hir.hir_to_node_id(id);\n+                let id = self.tcx.hir().hir_to_node_id(id);\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n-                     id, self.tcx.hir.node_to_string(id));\n+                     id, self.tcx.hir().node_to_string(id));\n             }\n         }\n     }\n@@ -770,7 +770,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  fn_node_id: ast::NodeId)\n                  -> McResult<cmt_<'tcx>>\n     {\n-        let fn_hir_id = self.tcx.hir.node_to_hir_id(fn_node_id);\n+        let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_node_id);\n \n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n@@ -815,8 +815,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             ref t => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", t),\n         };\n \n-        let closure_expr_def_id = self.tcx.hir.local_def_id(fn_node_id);\n-        let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n+        let closure_expr_def_id = self.tcx.hir().local_def_id(fn_node_id);\n+        let var_hir_id = self.tcx.hir().node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n             var_path: ty::UpvarPath { hir_id: var_hir_id },\n             closure_expr_id: closure_expr_def_id.to_local(),\n@@ -1504,7 +1504,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {\n-                if tcx.hir.is_argument(vid) {\n+                if tcx.hir().is_argument(vid) {\n                     \"argument\"\n                 } else {\n                     \"local variable\""}, {"sha": "89814dde2623e6a2ca97b728f38638f74f8fef7c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -47,7 +47,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match item.node {\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n+            let generics = tcx.generics_of(tcx.hir().local_def_id(item.id));\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -58,12 +58,12 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n-    let generics = tcx.generics_of(tcx.hir.local_def_id(impl_item.id));\n+    let generics = tcx.generics_of(tcx.hir().local_def_id(impl_item.id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n-    if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n-        match tcx.hir.find(impl_node_id) {\n+    if let Some(impl_node_id) = tcx.hir().as_local_node_id(impl_src) {\n+        match tcx.hir().find(impl_node_id) {\n             Some(Node::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -118,7 +118,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n             }\n             Some(def) => {\n                 if let Some((node_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n-                    self.tcx.hir.as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n+                    self.tcx.hir().as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(node_id);\n@@ -151,12 +151,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let node_id = match self.tcx.hir.as_local_node_id(def_id) {\n+        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n             Some(node_id) => node_id,\n             None => { return false; }\n         };\n \n-        match self.tcx.hir.find(node_id) {\n+        match self.tcx.hir().find(node_id) {\n             Some(Node::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n@@ -182,13 +182,13 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n-                                               .hir\n+                                               .hir()\n                                                .get_parent_did(node_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_node_id = self.tcx.hir.as_local_node_id(impl_did).unwrap();\n-                            match self.tcx.hir.expect_item(impl_node_id).node {\n+                            let impl_node_id = self.tcx.hir().as_local_node_id(impl_did).unwrap();\n+                            match self.tcx.hir().expect_item(impl_node_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref item) = self.tcx.hir.find(search_item) {\n+            if let Some(ref item) = self.tcx.hir().find(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal = codegen_attrs.flags.contains(\n@@ -252,7 +252,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id(item.id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n                                                  self.tcx.codegen_fn_attrs(def_id)) {\n@@ -305,7 +305,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(_, body) => {\n-                        let did = self.tcx.hir.get_parent_did(search_item);\n+                        let did = self.tcx.hir().get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -326,7 +326,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::MacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n-                     self.tcx.hir.node_to_string(search_item))\n+                     self.tcx.hir().node_to_string(search_item))\n             }\n         }\n     }\n@@ -351,7 +351,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id(item.id);\n         let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if codegen_attrs.contains_extern_indicator() ||\n             codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n@@ -376,7 +376,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n                 self.worklist.reserve(provided_trait_methods.len());\n                 for default_method in provided_trait_methods {\n                     let node_id = self.tcx\n-                                      .hir\n+                                      .hir()\n                                       .as_local_node_id(default_method.def_id)\n                                       .unwrap();\n                     self.worklist.push(node_id);\n@@ -422,7 +422,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+            if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n                 reachable_context.worklist.push(node_id);\n             }\n         }\n@@ -433,7 +433,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n             access_levels,\n             worklist: &mut reachable_context.worklist,\n         };\n-        tcx.hir.krate().visit_all_item_likes(&mut collect_private_impl_items);\n+        tcx.hir().krate().visit_all_item_likes(&mut collect_private_impl_items);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "0a4ddf8b572fc5fc10a1059f8d402a3276755c47", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -181,7 +181,7 @@ impl Scope {\n     pub fn node_id(&self, tcx: TyCtxt<'_, '_, '_>, scope_tree: &ScopeTree) -> ast::NodeId {\n         match scope_tree.root_body {\n             Some(hir_id) => {\n-                tcx.hir.hir_to_node_id(hir::HirId {\n+                tcx.hir().hir_to_node_id(hir::HirId {\n                     owner: hir_id.owner,\n                     local_id: self.item_local_id()\n                 })\n@@ -198,9 +198,9 @@ impl Scope {\n         if node_id == ast::DUMMY_NODE_ID {\n             return DUMMY_SP;\n         }\n-        let span = tcx.hir.span(node_id);\n+        let span = tcx.hir().span(node_id);\n         if let ScopeData::Remainder(first_statement_index) = self.data {\n-            if let Node::Block(ref blk) = tcx.hir.get(node_id) {\n+            if let Node::Block(ref blk) = tcx.hir().get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -660,9 +660,9 @@ impl<'tcx> ScopeTree {\n                                       -> Scope {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n-        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let scope = tcx.hir.maybe_body_owned_by(param_owner_id).map(|body_id| {\n-            tcx.hir.body(body_id).value.hir_id.local_id\n+        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n+        let scope = tcx.hir().maybe_body_owned_by(param_owner_id).map(|body_id| {\n+            tcx.hir().body(body_id).value.hir_id.local_id\n         }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n             // which in practice can only mean a trait or an impl, that\n@@ -671,7 +671,7 @@ impl<'tcx> ScopeTree {\n                        \"free_scope: {:?} not recognized by the \\\n                         region scope tree for {:?} / {:?}\",\n                        param_owner,\n-                       self.root_parent.map(|id| tcx.hir.local_def_id(id)),\n+                       self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n                        self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n \n             // The trait/impl lifetime is in scope for the method's body.\n@@ -696,9 +696,9 @@ impl<'tcx> ScopeTree {\n         // on the same function that they ended up being freed in.\n         assert_eq!(param_owner, fr.scope);\n \n-        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let body_id = tcx.hir.body_owned_by(param_owner_id);\n-        Scope { id: tcx.hir.body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n+        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n+        let body_id = tcx.hir().body_owned_by(param_owner_id);\n+        Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }\n \n     /// Checks whether the given scope contains a `yield`. If so,\n@@ -845,7 +845,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = visitor.tcx.hir.node_to_hir_id(stmt.node.id()).local_id;\n+    let stmt_id = visitor.tcx.hir().node_to_hir_id(stmt.node.id()).local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during\n@@ -942,7 +942,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n         hir::ExprKind::Closure(.., body, _, _) => {\n-            let body = visitor.tcx.hir.body(body);\n+            let body = visitor.tcx.hir().body(body);\n             visitor.visit_body(body);\n         }\n \n@@ -1244,7 +1244,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         let body_id = body.id();\n-        let owner_id = self.tcx.hir.body_owner(body_id);\n+        let owner_id = self.tcx.hir().body_owner(body_id);\n \n         debug!(\"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n                owner_id,\n@@ -1273,7 +1273,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         // The body of the every fn is a root scope.\n         self.cx.parent = self.cx.var_parent;\n-        if let hir::BodyOwnerKind::Fn = self.tcx.hir.body_owner_kind(owner_id) {\n+        if let hir::BodyOwnerKind::Fn = self.tcx.hir().body_owner_kind(owner_id) {\n             self.visit_expr(&body.value);\n         } else {\n             // Only functions have an outer terminating (drop) scope, while\n@@ -1333,8 +1333,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let scope_tree = if let Some(body_id) = tcx.hir.maybe_body_owned_by(id) {\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n@@ -1347,16 +1347,16 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             terminating_scopes: Default::default(),\n         };\n \n-        let body = tcx.hir.body(body_id);\n+        let body = tcx.hir().body(body_id);\n         visitor.scope_tree.root_body = Some(body.value.hir_id);\n \n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n-        match tcx.hir.get(id) {\n+        match tcx.hir().get(id) {\n             Node::ImplItem(_) |\n             Node::TraitItem(_) => {\n-                visitor.scope_tree.root_parent = Some(tcx.hir.get_parent(id));\n+                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent(id));\n             }\n             _ => {}\n         }"}, {"sha": "54d8d169288d1541adcb7fa280185cc8a8dadc55", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -398,19 +398,19 @@ fn resolve_lifetimes<'tcx>(\n     let mut rl = ResolveLifetimes::default();\n \n     for (k, v) in named_region_map.defs {\n-        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let hir_id = tcx.hir().node_to_hir_id(k);\n         let map = rl.defs.entry(hir_id.owner_local_def_id()).or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n     }\n     for k in named_region_map.late_bound {\n-        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let hir_id = tcx.hir().node_to_hir_id(k);\n         let map = rl.late_bound\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n     }\n     for (k, v) in named_region_map.object_lifetime_defaults {\n-        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let hir_id = tcx.hir().node_to_hir_id(k);\n         let map = rl.object_lifetime_defaults\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n@@ -423,7 +423,7 @@ fn resolve_lifetimes<'tcx>(\n }\n \n fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let mut map = NamedRegionMap {\n         defs: Default::default(),\n         late_bound: Default::default(),\n@@ -460,7 +460,7 @@ fn sub_items_have_self_param(node: &hir::ItemKind) -> bool {\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     // We want to nest trait/impl items in their parent, but nothing else.\n@@ -469,7 +469,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         // Each body has their own set of labels, save labels.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         extract_labels(self, body);\n         self.with(\n             Scope::Body {\n@@ -545,7 +545,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             type_count += 1;\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         .iter()\n                         .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(&self.tcx.hir, param))\n+                                Some(Region::late(&self.tcx.hir(), param))\n                             }\n                             _ => None,\n                         })\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir.expect_item(item_id.id).node {\n+                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n                     hir::ItemKind::Existential(hir::ExistTy {\n@@ -689,12 +689,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // In the future, this should be fixed and this error should be removed.\n                         let def = self.map.defs.get(&lifetime.id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n-                            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n                                 // Ensure that the parent of the def is an item, not HRTB\n-                                let parent_id = self.tcx.hir.get_parent_node(node_id);\n+                                let parent_id = self.tcx.hir().get_parent_node(node_id);\n                                 let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n-                                let krate = self.tcx.hir.forest.krate();\n+                                let krate = self.tcx.hir().forest.krate();\n                                 if !(krate.items.contains_key(&parent_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)\n                                     || krate.trait_items.contains_key(&parent_trait_id))\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for param in &generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n+                            let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n                             if let hir::ParamName::Plain(param_name) = name {\n                                 if param_name.name == keywords::UnderscoreLifetime.name() {\n                                     // Pick the elided lifetime \"definition\" if one exists\n@@ -790,7 +790,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir.get_parent(trait_item.id)),\n+                    Some(tcx.hir().get_parent(trait_item.id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -806,7 +806,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             type_count += 1;\n@@ -845,7 +845,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir.get_parent(impl_item.id)),\n+                    Some(tcx.hir().get_parent(impl_item.id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -861,7 +861,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             next_early_index += 1;\n@@ -891,7 +891,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             next_early_index += 1;\n@@ -976,7 +976,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         .iter()\n                         .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(&self.tcx.hir, param))\n+                                Some(Region::late(&self.tcx.hir(), param))\n                             }\n                             _ => None,\n                         })\n@@ -1051,7 +1051,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::late(&self.tcx.hir, param))\n+                            Some(Region::late(&self.tcx.hir(), param))\n                         }\n                         _ => None,\n                     })\n@@ -1258,12 +1258,12 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n-                        let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n+                        let node_id = tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir.span(node_id)),\n+                            original_lifetime(tcx.hir().span(node_id)),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1279,7 +1279,7 @@ fn compute_object_lifetime_defaults(\n     tcx: TyCtxt<'_, '_, '_>,\n ) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = NodeMap::default();\n-    for item in tcx.hir.krate().items.values() {\n+    for item in tcx.hir().krate().items.values() {\n         match item.node {\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n@@ -1355,7 +1355,7 @@ fn object_lifetime_defaults_for_item(\n \n                 add_bounds(&mut set, &param.bounds);\n \n-                let param_def_id = tcx.hir.local_def_id(param.id);\n+                let param_def_id = tcx.hir().local_def_id(param.id);\n                 for predicate in &generics.where_clause.predicates {\n                     // Look for `type: ...` where clauses.\n                     let data = match *predicate {\n@@ -1399,7 +1399,7 @@ fn object_lifetime_defaults_for_item(\n                                 .enumerate()\n                                 .find(|&(_, (_, lt_name, _))| lt_name == name)\n                                 .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                                    let def_id = tcx.hir.local_def_id(id);\n+                                    let def_id = tcx.hir().local_def_id(id);\n                                     Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                                 })\n                         }\n@@ -1492,7 +1492,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let name = lifetime.name.ident();\n         let mut remove_decl = None;\n         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-            if let Some(generics) = self.tcx.hir.get_generics(parent_def_id) {\n+            if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n                 remove_decl = self.lifetime_deletion_span(name, generics);\n             }\n         }\n@@ -1513,8 +1513,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n         };\n-        if let Node::Lifetime(hir_lifetime) = self.tcx.hir.get(lifetime.id) {\n-            if let Some(parent) = self.tcx.hir.find(self.tcx.hir.get_parent(hir_lifetime.id)) {\n+        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.id) {\n+            if let Some(parent) = self.tcx.hir().find(self.tcx.hir().get_parent(hir_lifetime.id)) {\n                 match parent {\n                     Node::Item(item) => {\n                         if let hir::ItemKind::Fn(decl, _, _, _) = &item.node {\n@@ -1590,9 +1590,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n-                    if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n+                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.id,\n                             hir_lifetime.span,\n@@ -1631,8 +1631,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"Not one use lifetime\");\n                 }\n                 None => {\n-                    let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                    if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n+                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n+                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.id,\n                             hir_lifetime.span,\n@@ -1651,7 +1651,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             &format!(\"lifetime parameter `{}` never used\", name),\n                         );\n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                            if let Some(generics) = self.tcx.hir.get_generics(parent_def_id) {\n+                            if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n                                 let unused_lt_span = self.lifetime_deletion_span(name, generics);\n                                 if let Some(span) = unused_lt_span {\n                                     err.span_suggestion_with_applicability(\n@@ -1702,7 +1702,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Find the start of nested early scopes, e.g. in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir.expect_item(parent_id);\n+            let parent = self.tcx.hir().expect_item(parent_id);\n             if sub_items_have_self_param(&parent.node) {\n                 index += 1; // Self comes before lifetimes\n             }\n@@ -1722,9 +1722,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.map.late_bound.contains(&param.id) {\n-                        Some(Region::late(&self.tcx.hir, param))\n+                        Some(Region::late(&self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n                     }\n                 }\n                 GenericParamKind::Type { .. } => {\n@@ -1837,8 +1837,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let Region::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n-                let fn_id = self.tcx.hir.body_owner(body_id);\n-                match self.tcx.hir.get(fn_id) {\n+                let fn_id = self.tcx.hir().body_owner(body_id);\n+                match self.tcx.hir().get(fn_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n@@ -1851,7 +1851,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n-                        let scope = self.tcx.hir.local_def_id(fn_id);\n+                        let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n@@ -1967,7 +1967,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+            let unsubst = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n@@ -2061,8 +2061,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // and whether there's a `self` argument (treated specially).\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n-        let parent = self.tcx.hir.get_parent_node(output.id);\n-        let body = match self.tcx.hir.get(parent) {\n+        let parent = self.tcx.hir().get_parent_node(output.id);\n+        let body = match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n@@ -2074,8 +2074,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 ..\n             }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n-                    .hir\n-                    .expect_item(self.tcx.hir.get_parent(parent))\n+                    .hir()\n+                    .expect_item(self.tcx.hir().get_parent(parent))\n                     .node\n                 {\n                     assoc_item_kind = trait_items\n@@ -2094,8 +2094,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 ..\n             }) => {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n-                    .hir\n-                    .expect_item(self.tcx.hir.get_parent(parent))\n+                    .hir()\n+                    .expect_item(self.tcx.hir().get_parent(parent))\n                     .node\n                 {\n                     impl_self = Some(self_ty);\n@@ -2396,8 +2396,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } = info;\n \n             let help_name = if let Some(body) = parent {\n-                let arg = &self.tcx.hir.body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir.node_to_pretty_string(arg.pat.id))\n+                let arg = &self.tcx.hir().body(body).arguments[index];\n+                format!(\"`{}`\", self.tcx.hir().node_to_pretty_string(arg.pat.id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };\n@@ -2603,12 +2603,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes, s, ..\n                 } => {\n                     if let Some(&def) = lifetimes.get(&param.name.modern()) {\n-                        let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n+                        let node_id = self.tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir.span(node_id)),\n+                            original_lifetime(self.tcx.hir().span(node_id)),\n                             shadower_lifetime(&param),\n                         );\n                         return;\n@@ -2675,7 +2675,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.tcx.hir.node_to_string(lifetime_ref.id),\n+            self.tcx.hir().node_to_string(lifetime_ref.id),\n             def,\n             self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );"}, {"sha": "52a81d9a1c00993131876865aa4a11c226b6ff05", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.stab_map.insert(hir_id, stab);\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n@@ -198,7 +198,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                        let hir_id = self.tcx.hir().node_to_hir_id(id);\n                         self.index.stab_map.insert(hir_id, stab);\n                     }\n                 }\n@@ -219,7 +219,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let hir_id = self.tcx.hir().node_to_hir_id(id);\n                     self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n@@ -230,7 +230,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 let depr_entry = DeprecationEntry::local(depr, hir_id);\n                 self.index.depr_map.insert(hir_id, depr_entry.clone());\n \n@@ -239,7 +239,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n             } else if let Some(parent_depr) = self.parent_depr.clone() {\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.depr_map.insert(hir_id, parent_depr);\n                 visit_children(self);\n             } else {\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -333,7 +333,7 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, id: NodeId, span: Span) {\n-        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n@@ -346,7 +346,7 @@ impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let impl_def_id = self.tcx.hir.local_def_id(self.tcx.hir.get_parent(ii.id));\n+        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent(ii.id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n             self.check_missing_stability(ii.id, ii.span);\n         }\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> Index<'tcx> {\n         index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n \n         {\n-            let krate = tcx.hir.krate();\n+            let krate = tcx.hir().krate();\n             let mut annotator = Annotator {\n                 tcx,\n                 index: &mut index,\n@@ -470,7 +470,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut checker = Checker { tcx };\n-    tcx.hir.krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n }\n \n /// Check whether an item marked with `deprecated(since=\"X\")` is currently\n@@ -591,7 +591,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     false\n                 };\n \n-                let parent_def_id = self.hir.local_def_id(self.hir.get_parent(id));\n+                let parent_def_id = self.hir().local_def_id(self.hir().get_parent(id));\n                 let skip = deprecated_in_future_version ||\n                            self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n@@ -717,7 +717,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -726,7 +726,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }\n \n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n@@ -741,7 +741,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             hir::ItemKind::Impl(.., Some(ref t), _, ref impl_item_refs) => {\n                 if let Def::Trait(trait_did) = t.path.def {\n                     for impl_item_ref in impl_item_refs {\n-                        let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                        let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n                             .find(|item| item.ident.name == impl_item.ident.name)\n                             .map(|item| item.def_id);\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n \n@@ -780,7 +780,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n-        let id = self.tcx.hir.hir_to_node_id(id);\n+        let id = self.tcx.hir().hir_to_node_id(id);\n         if let Some(def_id) = path.def.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }\n@@ -801,7 +801,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n-        let krate = tcx.hir.krate();\n+        let krate = tcx.hir().krate();\n         let mut missing = MissingStabilityAnnotations {\n             tcx,\n             access_levels,"}, {"sha": "824ccda3dbd1af4431f8a2d81b545fef53dffd29", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -49,7 +49,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     {\n         let mut cx = Context { tcx, items };\n-        tcx.hir.krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n+        tcx.hir().krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n     }\n     verify(tcx, items);\n }"}, {"sha": "d8a445e8582c7d55307ba7fa6dba293a314068b8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -2376,17 +2376,17 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 format!(\"[closure@{:?}]\", node_id)\n                             } else {\n-                                format!(\"[closure@{:?}]\", tcx.hir.span(node_id))\n+                                format!(\"[closure@{:?}]\", tcx.hir().span(node_id))\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir.name(freevar.var_id());\n+                                    let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             });\n@@ -2398,13 +2398,13 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-                            let name = format!(\"[generator@{:?}]\", tcx.hir.span(node_id));\n+                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(node_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir.name(freevar.var_id());\n+                                    let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                                 struct_fmt.field(\"$state\", &places[freevars.len()]);"}, {"sha": "80634aa3066741a71bbbbb7f5e0fbafba4ed3d9f", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -580,7 +580,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n \n-        if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n+        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.source_map().def_span(trait_item_span);\n             err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n@@ -765,8 +765,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n                         let closure_span = self.tcx.sess.source_map()\n-                            .def_span(self.tcx.hir.span_if_local(closure_def_id).unwrap());\n-                        let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let node_id = self.tcx.hir().as_local_node_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n                             self.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, \\\n@@ -785,7 +785,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // a particular trait.\n                         if let Some(tables) = self.in_progress_tables {\n                             let tables = tables.borrow();\n-                            let closure_hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                            let closure_hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                             match (found_kind, tables.closure_kind_origins().get(closure_hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, name))) => {\n                                     err.span_label(*span, format!(\n@@ -841,7 +841,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 let found_span = found_did.and_then(|did|\n-                    self.tcx.hir.span_if_local(did)\n+                    self.tcx.hir().span_if_local(did)\n                 ).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n@@ -862,7 +862,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                      expected_trait_ref)\n                 } else {\n                     let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir.get_if_local(did))\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n                         .map(|node| {\n                             let (found_span, found) = self.get_fn_like_arguments(node);\n                             (Some(found_span), found)\n@@ -901,8 +901,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        code: &ObligationCauseCode<'tcx>,\n                                        err: &mut DiagnosticBuilder<'tcx>) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n-            let parent_node = self.tcx.hir.get_parent_node(node_id);\n-            if let Some(Node::Local(ref local)) = self.tcx.hir.find(parent_node) {\n+            let parent_node = self.tcx.hir().get_parent_node(node_id);\n+            if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n@@ -976,7 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.source_map().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(args, _),\n@@ -1037,7 +1037,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                  ).collect::<Vec<_>>())\n             }\n             Node::StructCtor(ref variant_data) => {\n-                (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n+                (self.tcx.sess.source_map().def_span(self.tcx.hir().span(variant_data.id())),\n                  vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n@@ -1236,7 +1236,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                    -> DiagnosticBuilder<'tcx>\n     {\n         assert!(type_def_id.is_local());\n-        let span = self.hir.span_if_local(type_def_id).unwrap();\n+        let span = self.hir().span_if_local(type_def_id).unwrap();\n         let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n@@ -1482,7 +1482,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let item_name = tcx.item_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n \n-                if let Some(sp) = tcx.hir.span_if_local(item_def_id) {\n+                if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n                     let sp = tcx.sess.source_map().def_span(sp);\n                     err.span_note(sp, &msg);\n                 } else {"}, {"sha": "50d2179c412aa5fac980686b88a85ff393724d15", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -337,7 +337,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                 let mut err = if used_to_be_allowed {\n                     tcx.struct_span_lint_node(\n                         lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                        tcx.hir.as_local_node_id(impl_def_id).unwrap(),\n+                        tcx.hir().as_local_node_id(impl_def_id).unwrap(),\n                         impl_span,\n                         &msg)\n                 } else {"}, {"sha": "6d3fc0d4fe405c57b340f8fe35e821521967b8d7", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -535,9 +535,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n-        match self.hir.as_local_node_id(node_item_def_id) {\n+        match self.hir().as_local_node_id(node_item_def_id) {\n             Some(node_id) => {\n-                let item = self.hir.expect_item(node_id);\n+                let item = self.hir().expect_item(node_id);\n                 if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n                     defaultness.is_default()\n                 } else {"}, {"sha": "3741f4051b896b2df72bed995c3359d3a297ddbc", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -67,10 +67,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n     /// only checks whether the function has a `const` modifier\n     fn is_const_fn_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n-        let node_id = tcx.hir.as_local_node_id(def_id)\n+        let node_id = tcx.hir().as_local_node_id(def_id)\n                              .expect(\"Non-local call to local provider is_const_fn\");\n \n-        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir().get(node_id)) {\n             fn_like.constness() == hir::Constness::Const\n         } else {\n             false"}, {"sha": "fd406b1380572bb5d4bd643ba8d1250886f8aef1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -250,11 +250,11 @@ fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n         if let Some(local_id_root) = local_id_root {\n             if hir_id.owner != local_id_root.index {\n                 ty::tls::with(|tcx| {\n-                    let node_id = tcx.hir.hir_to_node_id(hir_id);\n+                    let node_id = tcx.hir().hir_to_node_id(hir_id);\n \n                     bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n                           TypeckTables with local_id_root {:?}\",\n-                         tcx.hir.node_to_string(node_id),\n+                         tcx.hir().node_to_string(node_id),\n                          DefId::local(hir_id.owner),\n                          local_id_root)\n                 });\n@@ -530,8 +530,8 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_id_to_type_opt(id).unwrap_or_else(||\n             bug!(\"node_id_to_type: no type for node `{}`\",\n                  tls::with(|tcx| {\n-                     let id = tcx.hir.hir_to_node_id(id);\n-                     tcx.hir.node_to_string(id)\n+                     let id = tcx.hir().hir_to_node_id(id);\n+                     tcx.hir().node_to_string(id)\n                  }))\n         )\n     }\n@@ -903,7 +903,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Lrc<Vec<Export>>>,\n \n-    pub hir: hir_map::Map<'tcx>,\n+    hir_map: hir_map::Map<'tcx>,\n \n     /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n@@ -971,6 +971,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn hir(self) -> &'a hir_map::Map<'gcx> {\n+        &self.hir_map\n+    }\n+\n     pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }\n@@ -1186,7 +1191,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     .map(|(id, sp)| (hir.local_def_id(id), sp))\n                     .collect(),\n             extern_prelude: resolutions.extern_prelude,\n-            hir,\n+            hir_map: hir,\n             def_path_hash_to_def_id,\n             queries: query::Queries::new(\n                 providers,\n@@ -1272,7 +1277,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n         if id.is_local() {\n-            self.hir.def_key(id)\n+            self.hir().def_key(id)\n         } else {\n             self.cstore.def_key(id)\n         }\n@@ -1285,7 +1290,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n         if id.is_local() {\n-            self.hir.def_path(id)\n+            self.hir().def_path(id)\n         } else {\n             self.cstore.def_path(id)\n         }\n@@ -1294,7 +1299,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n         if def_id.is_local() {\n-            self.hir.definitions().def_path_hash(def_id.index)\n+            self.hir().definitions().def_path_hash(def_id.index)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n@@ -1332,11 +1337,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n-        let krate = self.dep_graph.with_ignore(|| self.gcx.hir.krate());\n+        let krate = self.dep_graph.with_ignore(|| self.hir().krate());\n \n         StableHashingContext::new(self.sess,\n                                   krate,\n-                                  self.hir.definitions(),\n+                                  self.hir().definitions(),\n                                   self.cstore)\n     }\n \n@@ -1524,10 +1529,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let node_id = self.hir\n+        let node_id = self.hir()\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n-        let is_impl_item = match self.hir.find(node_id) {\n+        let is_impl_item = match self.hir().find(node_id) {\n             Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n@@ -1547,8 +1552,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n-        let node_id = self.hir.as_local_node_id(scope_def_id).unwrap();\n-        match self.hir.get(node_id) {\n+        let node_id = self.hir().as_local_node_id(scope_def_id).unwrap();\n+        match self.hir().get(node_id) {\n             Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n@@ -2895,11 +2900,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.dep_graph.with_ignore(|| {\n             let sets = self.lint_levels(LOCAL_CRATE);\n             loop {\n-                let hir_id = self.hir.definitions().node_to_hir_id(id);\n+                let hir_id = self.hir().definitions().node_to_hir_id(id);\n                 if let Some(pair) = sets.level_and_source(lint, hir_id, self.sess) {\n                     return pair\n                 }\n-                let next = self.hir.get_parent_node(id);\n+                let next = self.hir().get_parent_node(id);\n                 if next == id {\n                     bug!(\"lint traversal reached the root of the crate\");\n                 }\n@@ -2915,7 +2920,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                     msg: &str)\n         -> DiagnosticBuilder<'tcx>\n     {\n-        let node_id = self.hir.hir_to_node_id(hir_id);\n+        let node_id = self.hir().hir_to_node_id(hir_id);\n         let (level, src) = self.lint_level_at_node(lint, node_id);\n         lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n     }\n@@ -3039,16 +3044,16 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.lookup_stability = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n         tcx.stability().local_stability(id)\n     };\n     providers.lookup_deprecation_entry = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n         tcx.stability().local_deprecation_entry(id)\n     };\n     providers.extern_mod_stmt_cnum = |tcx, id| {\n-        let id = tcx.hir.as_local_node_id(id).unwrap();\n+        let id = tcx.hir().as_local_node_id(id).unwrap();\n         tcx.cstore.extern_mod_stmt_cnum_untracked(id)\n     };\n     providers.all_crate_nums = |tcx, cnum| {\n@@ -3069,10 +3074,10 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir.krate_attrs(), \"panic_runtime\")\n+        attr::contains_name(tcx.hir().krate_attrs(), \"panic_runtime\")\n     };\n     providers.is_compiler_builtins = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir.krate_attrs(), \"compiler_builtins\")\n+        attr::contains_name(tcx.hir().krate_attrs(), \"compiler_builtins\")\n     };\n }"}, {"sha": "163263babf8999d7503bc7f2eaedf5af6f588c87", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n-        let crate_id = tcx.hir.local_def_id(CRATE_NODE_ID);\n+        let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n "}, {"sha": "e24f9094dd2f5a50824519f1a2b37a955e857e0f", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns a string identifying this local node-id.\n     pub fn node_path_str(self, id: ast::NodeId) -> String {\n-        self.item_path_str(self.hir.local_def_id(id))\n+        self.item_path_str(self.hir().local_def_id(id))\n     }\n \n     /// Returns a string identifying this def-id. This string is\n@@ -464,8 +464,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n         self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-        let node_id = self.hir.as_local_node_id(impl_def_id).unwrap();\n-        let item = self.hir.expect_item(node_id);\n+        let node_id = self.hir().as_local_node_id(impl_def_id).unwrap();\n+        let item = self.hir().expect_item(node_id);\n         let span_str = self.sess.source_map().span_to_string(item.span);\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }"}, {"sha": "7c819941173d706e88010811bef0a2f1bcfa311b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -289,7 +289,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::VisibilityKind::Inherited => {\n-                Visibility::Restricted(tcx.hir.get_module_parent(id))\n+                Visibility::Restricted(tcx.hir().get_module_parent(id))\n             }\n         }\n     }\n@@ -2619,29 +2619,29 @@ impl<'gcx> ::std::ops::Deref for Attributes<'gcx> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n-        self.typeck_tables_of(self.hir.body_owner_def_id(body))\n+        self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n \n     /// Returns an iterator of the def-ids for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n-    /// themselves, you can do `self.hir.krate().body_ids.iter()`.\n+    /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(\n         self,\n     ) -> impl Iterator<Item = DefId> + Captures<'tcx> + Captures<'gcx> + 'a {\n-        self.hir.krate()\n-                .body_ids\n-                .iter()\n-                .map(move |&body_id| self.hir.body_owner_def_id(body_id))\n+        self.hir().krate()\n+                  .body_ids\n+                  .iter()\n+                  .map(move |&body_id| self.hir().body_owner_def_id(body_id))\n     }\n \n     pub fn par_body_owners<F: Fn(DefId) + sync::Sync + sync::Send>(self, f: F) {\n-        par_iter(&self.hir.krate().body_ids).for_each(|&body_id| {\n-            f(self.hir.body_owner_def_id(body_id))\n+        par_iter(&self.hir().krate().body_ids).for_each(|&body_id| {\n+            f(self.hir().body_owner_def_id(body_id))\n         });\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n-        match self.hir.find(id) {\n+        match self.hir().find(id) {\n             Some(Node::Expr(e)) => {\n                 e.span\n             }\n@@ -2667,8 +2667,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n-        let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n-            match self.hir.get(node_id) {\n+        let is_associated_item = if let Some(node_id) = self.hir().as_local_node_id(def_id) {\n+            match self.hir().get(node_id) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -2691,7 +2691,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                            parent_vis: &hir::Visibility,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n-        let def_id = self.hir.local_def_id(trait_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id(trait_item_ref.id.node_id);\n         let (kind, has_self) = match trait_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2717,7 +2717,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           parent_def_id: DefId,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssociatedItem {\n-        let def_id = self.hir.local_def_id(impl_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id(impl_item_ref.id.node_id);\n         let (kind, has_self) = match impl_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2740,7 +2740,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn field_index(self, node_id: NodeId, tables: &TypeckTables<'_>) -> usize {\n-        let hir_id = self.hir.node_to_hir_id(node_id);\n+        let hir_id = self.hir().node_to_hir_id(node_id);\n         tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n \n@@ -2878,8 +2878,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n-        if let Some(id) = self.hir.as_local_node_id(did) {\n-            Attributes::Borrowed(self.hir.attrs(id))\n+        if let Some(id) = self.hir().as_local_node_id(did) {\n+            Attributes::Borrowed(self.hir().attrs(id))\n         } else {\n             Attributes::Owned(self.item_attrs(did))\n         }\n@@ -2930,8 +2930,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n-            let node_id = self.hir.as_local_node_id(impl_did).unwrap();\n-            Ok(self.hir.span(node_id))\n+            let node_id = self.hir().as_local_node_id(impl_did).unwrap();\n+            Ok(self.hir().span(node_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n         }\n@@ -2947,14 +2947,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n         ident = ident.modern();\n         let target_expansion = match scope.krate {\n-            LOCAL_CRATE => self.hir.definitions().expansion_that_defined(scope.index),\n+            LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n             _ => Mark::root(),\n         };\n         let scope = match ident.span.adjust(target_expansion) {\n             Some(actual_expansion) =>\n-                self.hir.definitions().parent_module_of_macro_def(actual_expansion),\n+                self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n             None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n-            None => self.hir.get_module_parent(block),\n+            None => self.hir().get_module_parent(block),\n         };\n         (ident, scope)\n     }\n@@ -2980,7 +2980,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n-        let def_id = self.hir.local_def_id(fid);\n+        let def_id = self.hir().local_def_id(fid);\n         match self.freevars(def_id) {\n             None => f(&[]),\n             Some(d) => f(&d),\n@@ -2989,10 +2989,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssociatedItem {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let parent_id = tcx.hir.get_parent(id);\n-    let parent_def_id = tcx.hir.local_def_id(parent_id);\n-    let parent_item = tcx.hir.expect_item(parent_id);\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let parent_id = tcx.hir().get_parent(id);\n+    let parent_def_id = tcx.hir().local_def_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_id);\n     match parent_item.node {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n@@ -3049,19 +3049,19 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> Lrc<Vec<DefId>> {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let item = tcx.hir.expect_item(id);\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(id);\n     let vec: Vec<_> = match item.node {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             trait_item_refs.iter()\n                            .map(|trait_item_ref| trait_item_ref.id)\n-                           .map(|id| tcx.hir.local_def_id(id.node_id))\n+                           .map(|id| tcx.hir().local_def_id(id.node_id))\n                            .collect()\n         }\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             impl_item_refs.iter()\n                           .map(|impl_item_ref| impl_item_ref.id)\n-                          .map(|id| tcx.hir.local_def_id(id.node_id))\n+                          .map(|id| tcx.hir().local_def_id(id.node_id))\n                           .collect()\n         }\n         hir::ItemKind::TraitAlias(..) => vec![],\n@@ -3071,7 +3071,7 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n-    tcx.hir.span_if_local(def_id).unwrap()\n+    tcx.hir().span_if_local(def_id).unwrap()\n }\n \n /// If the given def ID describes an item belonging to a trait,\n@@ -3089,8 +3089,8 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let Node::Item(item) = tcx.hir.get(node_id) {\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+        if let Node::Item(item) = tcx.hir().get(node_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }\n@@ -3101,8 +3101,8 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefI\n \n /// Returns `true` if `def_id` is a trait alias.\n pub fn is_trait_alias(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let Node::Item(item) = tcx.hir.get(node_id) {\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+        if let Node::Item(item) = tcx.hir().get(node_id) {\n             if let hir::ItemKind::TraitAlias(..) = item.node {\n                 return true;\n             }\n@@ -3140,8 +3140,8 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n                                              traits::Reveal::UserFacing);\n \n-    let body_id = tcx.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n-        tcx.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n+    let body_id = tcx.hir().as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n+        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n@@ -3163,7 +3163,7 @@ fn crate_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         crate_num: CrateNum)\n                         -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.hir.crate_hash\n+    tcx.hir().crate_hash\n }\n \n fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "fd9143be679a4ba6bcfdd23ba92aa934be83e235", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -227,9 +227,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n         format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir.ty_param_name(id)).into()\n+                tcx.hir().ty_param_name(id)).into()\n     }\n }\n "}, {"sha": "04c880826fe79c16bba2e093f775d8a7c4550ea0", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -725,7 +725,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx, 'x> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n         let hir_id = hir::HirId::decode(self)?;\n-        Ok(self.tcx().hir.hir_to_node_id(hir_id))\n+        Ok(self.tcx().hir().hir_to_node_id(hir_id))\n     }\n }\n \n@@ -926,7 +926,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a\n             local_id,\n         } = *id;\n \n-        let def_path_hash = self.tcx.hir.definitions().def_path_hash(owner);\n+        let def_path_hash = self.tcx.hir().definitions().def_path_hash(owner);\n \n         def_path_hash.encode(self)?;\n         local_id.encode(self)\n@@ -968,7 +968,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 't\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n-        let hir_id = self.tcx.hir.node_to_hir_id(*node_id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(*node_id);\n         hir_id.encode(self)\n     }\n }"}, {"sha": "fadb1a1cf6ee6b2c403647c93fe68e0e6dfd0054", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -189,8 +189,8 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        for &node_id in tcx.hir.trait_impls(trait_id) {\n-            add_impl(tcx.hir.local_def_id(node_id));\n+        for &node_id in tcx.hir().trait_impls(trait_id) {\n+            add_impl(tcx.hir().local_def_id(node_id));\n         }\n     }\n "}, {"sha": "2b9bd91e48a6c94d7e39dcf77ca167edc9b739d5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -601,7 +601,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Return whether the node pointed to by def_id is a static item, and its mutability\n     pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n-        if let Some(node) = self.hir.get_if_local(def_id) {\n+        if let Some(node) = self.hir().get_if_local(def_id) {\n             match node {\n                 Node::Item(&hir::Item {\n                     node: hir::ItemKind::Static(_, mutbl, _), ..\n@@ -711,7 +711,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     // Find non representable fields with their spans\n                     fold_repr(def.all_fields().map(|field| {\n                         let ty = field.ty(tcx, substs);\n-                        let span = tcx.hir.span_if_local(field.did).unwrap_or(sp);\n+                        let span = tcx.hir().span_if_local(field.did).unwrap_or(sp);\n                         match is_type_structurally_recursive(tcx, span, seen,\n                                                              representable_cache, ty)\n                         {"}, {"sha": "e248f6b42bea247e0dd3fa4ca88e1baf16e536bf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -523,7 +523,7 @@ impl PrintContext {\n                         }\n                     };\n                     let _ = write!(f, \"{}\", name);\n-                    ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID), name)\n+                    ty::BrNamed(tcx.hir().local_def_id(CRATE_NODE_ID), name)\n                 }\n             };\n             tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n@@ -679,7 +679,7 @@ impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"UpvarId({:?};`{}`;{:?})\",\n                self.var_path.hir_id,\n-               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_path.hir_id))),\n+               ty::tls::with(|tcx| tcx.hir().name(tcx.hir().hir_to_node_id(self.var_path.hir_id))),\n                self.closure_expr_id)\n     }\n }\n@@ -1208,15 +1208,15 @@ define_print! {\n                         write!(f, \"[static generator\")?;\n                     }\n \n-                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                        write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n+                        write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n                         let mut sep = \" \";\n                         tcx.with_freevars(node_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n                                              sep,\n-                                             tcx.hir.name(freevar.var_id())),\n+                                             tcx.hir().name(freevar.var_id())),\n                                        print(upvar_ty))?;\n                                 sep = \", \";\n                             }\n@@ -1244,19 +1244,19 @@ define_print! {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     write!(f, \"[closure\")?;\n \n-                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n                         if tcx.sess.opts.debugging_opts.span_free_formats {\n                             write!(f, \"@{:?}\", node_id)?;\n                         } else {\n-                            write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                            write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n                         }\n                         let mut sep = \" \";\n                         tcx.with_freevars(node_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n                                              sep,\n-                                             tcx.hir.name(freevar.var_id())),\n+                                             tcx.hir().name(freevar.var_id())),\n                                        print(upvar_ty))?;\n                                 sep = \", \";\n                             }"}, {"sha": "51afb43d973b724a2f4a32abc5f16cc5e25b7ab5", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        let hir_id = self.tcx().hir.node_to_hir_id(consume_id);\n+        let hir_id = self.tcx().hir().node_to_hir_id(consume_id);\n         self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n     }\n \n@@ -139,7 +139,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n-        let hir_id = self.tcx().hir.node_to_hir_id(borrow_id);\n+        let hir_id = self.tcx().hir().node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n@@ -185,7 +185,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-        self.check_assignment(self.tcx().hir.node_to_hir_id(assignment_id).local_id,\n+        self.check_assignment(self.tcx().hir().node_to_hir_id(assignment_id).local_id,\n                               assignment_span, assignee_cmt);\n     }\n \n@@ -199,10 +199,10 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n-    let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n+    let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n \n-    let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n-    let movable_generator = !match bccx.tcx.hir.get(node_id) {\n+    let node_id = bccx.tcx.hir().as_local_node_id(def_id).unwrap();\n+    let movable_generator = !match bccx.tcx.hir().get(node_id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n@@ -907,7 +907,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             let lp = opt_loan_path(assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n-                    let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                    let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                     self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable("}, {"sha": "9fa541cdd07b4f67b006f42196d5bf06f4a2380f", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -57,9 +57,9 @@ pub enum PatternSource<'tcx> {\n /// with a reference to the let\n fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n-    let parent = tcx.hir.get_parent_node(pat.id);\n+    let parent = tcx.hir().get_parent_node(pat.id);\n \n-    match tcx.hir.get(parent) {\n+    match tcx.hir().get(parent) {\n         Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n@@ -79,7 +79,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              var_id: ast::NodeId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    let hir_id = bccx.tcx.hir.node_to_hir_id(var_id);\n+    let hir_id = bccx.tcx.hir().node_to_hir_id(var_id);\n     move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n }\n "}, {"sha": "ccc091a6a1ce6e68860bc9432a98c535b62dc097", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n             Categorization::Local(local_id) => {\n-                let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                 self.bccx.tcx.mk_region(ty::ReScope(\n                     self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n             }"}, {"sha": "1a9672aa6ce5e6562179764e2780077f90a8391e", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -38,13 +38,13 @@ mod move_error;\n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     body: hir::BodyId)\n                                     -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n-    let def_id = bccx.tcx.hir.body_owner_def_id(body);\n+    let def_id = bccx.tcx.hir().body_owner_def_id(body);\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut glcx = GatherLoanCtxt {\n         bccx,\n         all_loans: Vec::new(),\n         item_ub: region::Scope {\n-            id: bccx.tcx.hir.body(body).value.hir_id.local_id,\n+            id: bccx.tcx.hir().body(body).value.hir_id.local_id,\n             data: region::ScopeData::Node\n         },\n         move_data: MoveData::default(),\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    self.bccx.tcx.hir.node_to_hir_id(consume_id).local_id, cmt, move_reason);\n+                    self.bccx.tcx.hir().node_to_hir_id(consume_id).local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        let hir_id = self.bccx.tcx.hir.node_to_hir_id(borrow_id);\n+        let hir_id = self.bccx.tcx.hir().node_to_hir_id(borrow_id);\n         self.guarantee_valid(hir_id.local_id,\n                              borrow_span,\n                              cmt,\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n         let ty = self.bccx\n                      .tables\n-                     .node_id_to_type(self.bccx.tcx.hir.node_to_hir_id(id));\n+                     .node_id_to_type(self.bccx.tcx.hir().node_to_hir_id(id));\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     self.mark_loan_path_as_mutated(&lp);\n                 }\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                self.bccx.tcx.hir.node_to_hir_id(assignment_id)\n+                                                self.bccx.tcx.hir().node_to_hir_id(assignment_id)\n                                                     .local_id,\n                                                 assignment_span,\n                                                 lp);\n@@ -448,7 +448,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             wrapped_path = match current_path.kind {\n                 LpVar(local_id) => {\n                     if !through_borrow {\n-                        let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                        let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                         self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     }\n                     None"}, {"sha": "08c5b247b2f65d74afb00ea75c6e01618c3a65e4", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -97,8 +97,8 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            let var_node_id = bccx.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-            err.span_label(bccx.tcx.hir.span(var_node_id),\n+            let var_node_id = bccx.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+            err.span_label(bccx.tcx.hir().span(var_node_id),\n                            \"captured outer variable\");\n         }\n         err.emit();"}, {"sha": "3a0d252137c22d78a869bb9d059e6219bba0a2c7", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -93,9 +93,9 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n-    let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n+    let owner_id = tcx.hir().as_local_node_id(owner_def_id).unwrap();\n \n-    match tcx.hir.get(owner_id) {\n+    match tcx.hir().get(owner_id) {\n         Node::StructCtor(_) |\n         Node::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n@@ -110,10 +110,10 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n         _ => { }\n     }\n \n-    let body_id = tcx.hir.body_owned_by(owner_id);\n+    let body_id = tcx.hir().body_owned_by(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir.body(body_id);\n+    let body = tcx.hir().body(body_id);\n     let mut bccx = BorrowckCtxt {\n         tcx,\n         tables,\n@@ -169,7 +169,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n     // Check the body of fn items.\n     let tcx = this.tcx;\n     let id_range = {\n-        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.hir);\n+        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.hir());\n         visitor.visit_body(this.body);\n         visitor.result()\n     };\n@@ -224,11 +224,11 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n-    let owner_id = tcx.hir.body_owner(body_id);\n-    let owner_def_id = tcx.hir.local_def_id(owner_id);\n+    let owner_id = tcx.hir().body_owner(body_id);\n+    let owner_def_id = tcx.hir().local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir.body(body_id);\n+    let body = tcx.hir().body(body_id);\n     let mut bccx = BorrowckCtxt {\n         tcx,\n         tables,\n@@ -418,8 +418,8 @@ pub enum LoanPathElem<'tcx> {\n \n fn closure_to_block(closure_id: LocalDefId,\n                     tcx: TyCtxt) -> ast::NodeId {\n-    let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n-    match tcx.hir.get(closure_id) {\n+    let closure_id = tcx.hir().local_def_id_to_node_id(closure_id);\n+    match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n@@ -436,12 +436,12 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n         match self.kind {\n             LpVar(local_id) => {\n-                let hir_id = bccx.tcx.hir.node_to_hir_id(local_id);\n+                let hir_id = bccx.tcx.hir().node_to_hir_id(local_id);\n                 bccx.region_scope_tree.var_scope(hir_id.local_id)\n             }\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                let hir_id = bccx.tcx.hir.node_to_hir_id(block_id);\n+                let hir_id = bccx.tcx.hir().node_to_hir_id(block_id);\n                 region::Scope { id: hir_id.local_id, data: region::ScopeData::Node }\n             }\n             LpDowncast(ref base, _) |\n@@ -700,8 +700,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                              Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::Closure(id, _) => {\n-                        let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n-                        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                        let node_id = self.tcx.hir().as_local_node_id(id).unwrap();\n+                        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                         if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {\n                             err.span_note(*span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n@@ -721,7 +721,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         // Get type of value and span where it was previously\n         // moved.\n-        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+        let node_id = self.tcx.hir().hir_to_node_id(hir::HirId {\n             owner: self.body.value.hir_id.owner,\n             local_id: the_move.id\n         });\n@@ -731,10 +731,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat => (self.tcx.hir.span(node_id), \"\"),\n+            move_data::MovePat => (self.tcx.hir().span(node_id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.hir.expect_expr(node_id).node {\n+                (match self.tcx.hir().expect_expr(node_id).node {\n                     hir::ExprKind::Closure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n@@ -846,8 +846,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     MutabilityViolation => {\n                         let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n                         if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n-                            let node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                            let sp = self.tcx.hir.span(node_id);\n+                            let node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                            let sp = self.tcx.hir().span(node_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n                             match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n@@ -916,8 +916,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 // to implement two traits for \"one operator\" is not very intuitive for\n                 // many programmers.\n                 if err.cmt.note == mc::NoteIndex {\n-                    let node_id = self.tcx.hir.hir_to_node_id(err.cmt.hir_id);\n-                    let node =  self.tcx.hir.get(node_id);\n+                    let node_id = self.tcx.hir().hir_to_node_id(err.cmt.hir_id);\n+                    let node =  self.tcx.hir().get(node_id);\n \n                     // This pattern probably always matches.\n                     if let Node::Expr(\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.note_immutability_blame(\n                     &mut db,\n                     err.cmt.immutability_blame(),\n-                    self.tcx.hir.hir_to_node_id(err.cmt.hir_id)\n+                    self.tcx.hir().hir_to_node_id(err.cmt.hir_id)\n                 );\n                 db.emit();\n                 self.signal_error();\n@@ -1043,7 +1043,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let ty::ReScope(scope) = *super_scope {\n                     let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n-                    match self.tcx.hir.find(node_id) {\n+                    match self.tcx.hir().find(node_id) {\n                         Some(Node::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n@@ -1138,8 +1138,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n-                let node_id = self.tcx.hir.local_def_id_to_node_id(id);\n-                let help_span = self.tcx.hir.span(node_id);\n+                let node_id = self.tcx.hir().local_def_id_to_node_id(id);\n+                let help_span = self.tcx.hir().span(node_id);\n                 self.cannot_act_on_capture_in_sharable_fn(span,\n                                                           prefix,\n                                                           (help_span, help_msg),\n@@ -1153,7 +1153,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.note_immutability_blame(\n             &mut err,\n             blame,\n-            self.tcx.hir.hir_to_node_id(cmt.hir_id)\n+            self.tcx.hir().hir_to_node_id(cmt.hir_id)\n         );\n \n         if is_closure {\n@@ -1194,7 +1194,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n-        let pat = match self.tcx.hir.get(node_id) {\n+        let pat = match self.tcx.hir().get(node_id) {\n             Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n@@ -1211,13 +1211,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn local_ty(&self, node_id: ast::NodeId) -> (Option<&hir::Ty>, bool) {\n-        let parent = self.tcx.hir.get_parent_node(node_id);\n-        let parent_node = self.tcx.hir.get(parent);\n+        let parent = self.tcx.hir().get_parent_node(node_id);\n+        let parent_node = self.tcx.hir().get(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n             // `nid`'s parent's `Body`\n-            let fn_body = self.tcx.hir.body(fn_like.body());\n+            let fn_body = self.tcx.hir().body(fn_like.body());\n             // Get the position of `node_id` in the arguments list\n             let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == node_id);\n             if let Some(i) = arg_pos {\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n                 match self.local_binding_mode(node_id) {\n                     ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir.span(node_id);\n+                        let let_span = self.tcx.hir().span(node_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n                             db.span_suggestion_with_applicability(\n@@ -1272,12 +1272,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             Some(ImmutabilityBlame::AdtFieldDeref(_, field)) => {\n-                let node_id = match self.tcx.hir.as_local_node_id(field.did) {\n+                let node_id = match self.tcx.hir().as_local_node_id(field.did) {\n                     Some(node_id) => node_id,\n                     None => return\n                 };\n \n-                if let Node::Field(ref field) = self.tcx.hir.get(node_id) {\n+                if let Node::Field(ref field) = self.tcx.hir().get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }\n@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             db: &mut DiagnosticBuilder,\n                             borrowed_node_id: ast::NodeId,\n                             binding_node_id: ast::NodeId) {\n-        let let_span = self.tcx.hir.span(binding_node_id);\n+        let let_span = self.tcx.hir().span(binding_node_id);\n         if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n                 let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n@@ -1309,9 +1309,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     },\n                 )) = ty.map(|t| &t.node)\n                 {\n-                    let borrow_expr_id = self.tcx.hir.get_parent_node(borrowed_node_id);\n+                    let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_node_id);\n                     db.span_suggestion_with_applicability(\n-                        self.tcx.hir.span(borrow_expr_id),\n+                        self.tcx.hir().span(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n@@ -1381,8 +1381,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 if *kind == ty::ClosureKind::Fn {\n                     let closure_node_id =\n-                        self.tcx.hir.local_def_id_to_node_id(upvar_id.closure_expr_id);\n-                    db.span_help(self.tcx.hir.span(closure_node_id),\n+                        self.tcx.hir().local_def_id_to_node_id(upvar_id.closure_expr_id);\n+                    db.span_help(self.tcx.hir().span(closure_node_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1391,7 +1391,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir.span(local_id);\n+                    let span = self.tcx.hir().span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n@@ -1416,10 +1416,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       out: &mut String) {\n         match loan_path.kind {\n             LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id}, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.hir.name(self.tcx.hir.hir_to_node_id(id)).as_str());\n+                out.push_str(&self.tcx.hir().name(self.tcx.hir().hir_to_node_id(id)).as_str());\n             }\n             LpVar(id) => {\n-                out.push_str(&self.tcx.hir.name(id).as_str());\n+                out.push_str(&self.tcx.hir().name(id).as_str());\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n@@ -1530,13 +1530,13 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir.hir_to_node_id(var_id);\n-                    tcx.hir.node_to_string(var_node_id)\n+                    let var_node_id = tcx.hir().hir_to_node_id(var_id);\n+                    tcx.hir().node_to_string(var_node_id)\n                 });\n                 write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n             }\n@@ -1565,13 +1565,13 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_user_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir.hir_to_node_id(hir_id);\n-                    tcx.hir.node_to_string(var_node_id)\n+                    let var_node_id = tcx.hir().hir_to_node_id(hir_id);\n+                    tcx.hir().node_to_string(var_node_id)\n                 });\n                 write!(f, \"$({} captured by closure)\", s)\n             }"}, {"sha": "a9a33f35842ce43b0276d6f9e1006a61123a811f", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UnusedMutCx<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir())\n     }\n \n     fn visit_arm(&mut self, arm: &hir::Arm) {\n@@ -114,12 +114,12 @@ impl<'a, 'tcx> Visitor<'tcx> for UnusedMutCx<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UsedMutFinder<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, id: hir::BodyId) {\n-        let def_id = self.bccx.tcx.hir.body_owner_def_id(id);\n+        let def_id = self.bccx.tcx.hir().body_owner_def_id(id);\n         self.set.extend(self.bccx.tcx.borrowck(def_id).used_mut_nodes.iter().cloned());\n-        self.visit_body(self.bccx.tcx.hir.body(id));\n+        self.visit_body(self.bccx.tcx.hir().body(id));\n     }\n }"}, {"sha": "99df0fa5e471f6b0c3f4f5a34611273c54e40c37", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n     fn nested(&self, state: &mut pprust::State, nested: pprust::Nested) -> io::Result<()> {\n-        pprust::PpAnn::nested(&self.tcx.hir, state, nested)\n+        pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n     }\n     fn pre(&self,\n            ps: &mut pprust::State,"}, {"sha": "a4baa332fe2a740dfb11f329307926b0cc592f17", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -223,10 +223,10 @@ impl CodegenCx<'ll, 'tcx> {\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n-        let g = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+        let g = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n \n             let llty = self.layout_of(ty).llvm_type(self);\n-            let (g, attrs) = match self.tcx.hir.get(id) {\n+            let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {"}, {"sha": "ff5ec20254ea197162b597fc7d429e523c37be23", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -76,7 +76,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&cx.tcx.hir.krate_attrs(),\n+        attr::contains_name(&cx.tcx.hir().krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&"}, {"sha": "e54e180224eec9d2634a861e7eafd132bd8035de", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -300,7 +300,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         let mut flags = DIFlags::FlagPrototyped;\n \n-        let local_id = self.tcx().hir.as_local_node_id(def_id);\n+        let local_id = self.tcx().hir().as_local_node_id(def_id);\n         if let Some((id, _, _)) = *self.sess().entry_fn.borrow() {\n             if local_id == Some(id) {\n                 flags |= DIFlags::FlagMainSubprogram;"}, {"sha": "84b17e31dd4eb479e8e01b7c86a413dc4cec25e7", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -93,9 +93,9 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir.get(node_id) {\n+            match tcx.hir().get(node_id) {\n                 Node::ForeignItem(..) => {\n-                    let def_id = tcx.hir.local_def_id(node_id);\n+                    let def_id = tcx.hir().local_def_id(node_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n                     } else {\n@@ -115,7 +115,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {\n-                    let def_id = tcx.hir.local_def_id(node_id);\n+                    let def_id = tcx.hir().local_def_id(node_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever codegened\n@@ -158,12 +158,12 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .collect();\n \n     if let Some(id) = *tcx.sess.proc_macro_decls_static.get() {\n-        let def_id = tcx.hir.local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }\n \n     if let Some(id) = *tcx.sess.plugin_registrar_fn.get() {\n-        let def_id = tcx.hir.local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }\n \n@@ -355,7 +355,7 @@ fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n }\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\",\n@@ -393,7 +393,7 @@ fn symbol_export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n             if let Some(Node::Item(&hir::Item {\n                 node: hir::ItemKind::Static(..),\n                 ..\n-            })) = tcx.hir.get_if_local(sym_def_id) {\n+            })) = tcx.hir().get_if_local(sym_def_id) {\n                 return SymbolExportLevel::Rust;\n             }\n         }"}, {"sha": "2300b3e8c9b2d48c9e65beffda301363d45d9b0d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -313,8 +313,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n-    let no_builtins = attr::contains_name(&tcx.hir.krate().attrs, \"no_builtins\");\n-    let subsystem = attr::first_attr_value_str_by_name(&tcx.hir.krate().attrs,\n+    let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, \"no_builtins\");\n+    let subsystem = attr::first_attr_value_str_by_name(&tcx.hir().krate().attrs,\n                                                        \"windows_subsystem\");\n     let windows_subsystem = subsystem.map(|subsystem| {\n         if subsystem != \"windows\" && subsystem != \"console\" {"}, {"sha": "76d699d1736926fbd11394627eac2ad4547dba80", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -453,7 +453,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n         Some((id, span, _)) => {\n-            (cx.tcx().hir.local_def_id(id), span)\n+            (cx.tcx().hir().local_def_id(id), span)\n         }\n         None => return,\n     };"}, {"sha": "26f8a9a5dd4a08bf6f24e032e1cad5480384fbc6", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -42,7 +42,7 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 cx.codegen_static(def_id, is_mutable);\n             }\n             MonoItem::GlobalAsm(node_id) => {\n-                let item = cx.tcx().hir.expect_item(node_id);\n+                let item = cx.tcx().hir().expect_item(node_id);\n                 if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n                     cx.codegen_global_asm(ga);\n                 } else {"}, {"sha": "cbef3ff5b92869e9028cb2f3da0cc175942ec223", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -53,7 +53,7 @@ pub mod symbol_names_test;\n /// reporting an error.\n pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n     if let Some((id, span, _)) = *tcx.sess.entry_fn.borrow() {\n-        let main_def_id = tcx.hir.local_def_id(id);\n+        let main_def_id = tcx.hir().local_def_id(id);\n \n         if tcx.has_attr(main_def_id, \"rustc_error\") {\n             tcx.sess.span_fatal(span, \"compilation successful\");"}, {"sha": "305c718ff0636557d0cab98ace7a8f0b8cf37ddd", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -250,7 +250,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     debug!(\"symbol_name(def_id={:?}, substs={:?})\", def_id, substs);\n \n-    let node_id = tcx.hir.as_local_node_id(def_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id);\n \n     if let Some(id) = node_id {\n         if *tcx.sess.plugin_registrar_fn.get() == Some(id) {\n@@ -265,7 +265,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n     let is_foreign = if let Some(id) = node_id {\n-        match tcx.hir.get(id) {\n+        match tcx.hir().get(id) {\n             Node::ForeignItem(_) => true,\n             _ => false,\n         }"}, {"sha": "c4ad31ab021983bc743281f0427c9f6b7b5d135a", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -33,7 +33,7 @@ pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     tcx.dep_graph.with_ignore(|| {\n         let mut visitor = SymbolNamesTest { tcx };\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir().krate().visit_all_item_likes(&mut visitor);\n     })\n }\n \n@@ -45,7 +45,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n                      node_id: ast::NodeId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir.local_def_id(node_id);\n+        let def_id = tcx.hir().local_def_id(node_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names"}, {"sha": "8130f31a6954d495251200c7da22f5c5c4a3204b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -305,7 +305,7 @@ pub fn compile_input(\n                             outdir,\n                             output,\n                             opt_crate,\n-                            tcx.hir.krate(),\n+                            tcx.hir().krate(),\n                             &analysis,\n                             tcx,\n                             &crate_name,"}, {"sha": "b89c4262024d1deed97558444c15ea8840851ee5", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -495,7 +495,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n \n     fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'tcx>> {\n-        Some(&self.tcx.hir)\n+        Some(&self.tcx.hir())\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn {\n@@ -514,7 +514,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(&self.tcx.hir, state, nested)?;\n+        pprust_hir::PpAnn::nested(self.tcx.hir(), state, nested)?;\n         self.tables.set(old_tables);\n         Ok(())\n     }\n@@ -851,18 +851,18 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n             // Find the function this expression is from.\n             let mut node_id = expr.id;\n             loop {\n-                let node = tcx.hir.get(node_id);\n+                let node = tcx.hir().get(node_id);\n                 if let Some(n) = hir::map::blocks::FnLikeNode::from_node(node) {\n                     break n.body();\n                 }\n-                let parent = tcx.hir.get_parent_node(node_id);\n+                let parent = tcx.hir().get_parent_node(node_id);\n                 assert_ne!(node_id, parent);\n                 node_id = parent;\n             }\n         }\n         blocks::Code::FnLike(fn_like) => fn_like.body(),\n     };\n-    let body = tcx.hir.body(body_id);\n+    let body = tcx.hir().body(body_id);\n     let cfg = cfg::CFG::new(tcx, &body);\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n@@ -1164,7 +1164,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(nodeid) = nodeid {\n-                    let def_id = tcx.hir.local_def_id(nodeid);\n+                    let def_id = tcx.hir().local_def_id(nodeid);\n                     match ppm {\n                         PpmMir => write_mir_pretty(tcx, Some(def_id), &mut out),\n                         PpmMirCFG => write_mir_graphviz(tcx, Some(def_id), &mut out),\n@@ -1183,11 +1183,11 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 let nodeid =\n                     nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n                                    suffix (b::c::d)\");\n-                let node = tcx.hir.find(nodeid).unwrap_or_else(|| {\n+                let node = tcx.hir().find(nodeid).unwrap_or_else(|| {\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n \n-                match blocks::Code::from_node(&tcx.hir, nodeid) {\n+                match blocks::Code::from_node(&tcx.hir(), nodeid) {\n                     Some(code) => {\n                         let variants = gather_flowgraph_variants(tcx.sess);\n \n@@ -1200,7 +1200,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                got {:?}\",\n                                               node);\n \n-                        tcx.sess.span_fatal(tcx.hir.span(nodeid), &message)\n+                        tcx.sess.span_fatal(tcx.hir().span(nodeid), &message)\n                     }\n                 }\n             }"}, {"sha": "912371714e39d5ea9ecdf9851e7d5659d541d77a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -186,7 +186,7 @@ fn test_env_with_pool<F>(\n                     param_env: param_env,\n                 });\n                 let outlives_env = OutlivesEnvironment::new(param_env);\n-                let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n+                let def_id = tcx.hir().local_def_id(ast::CRATE_NODE_ID);\n                 infcx.resolve_regions_and_report_errors(\n                     def_id,\n                     &region_scope_tree,\n@@ -256,7 +256,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n     pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n-        return match search_mod(self, &self.infcx.tcx.hir.krate().module, 0, names) {\n+        return match search_mod(self, &self.infcx.tcx.hir().krate().module, 0, names) {\n             Some(id) => id,\n             None => {\n                 panic!(\"no item found: `{}`\", names.join(\"::\"));\n@@ -271,7 +271,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         ) -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.item_ids {\n-                let item = this.infcx.tcx.hir.expect_item(item.id);\n+                let item = this.infcx.tcx.hir().expect_item(item.id);\n                 if item.name.to_string() == names[idx] {\n                     return search(this, item, idx + 1, names);\n                 }\n@@ -364,7 +364,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx\n             .tcx\n             .mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+                def_id: self.infcx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n                 index,\n                 name,\n             }))\n@@ -410,7 +410,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n         self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-            scope: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+            scope: self.infcx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n             bound_region: ty::BrAnon(id),\n         }))\n     }"}, {"sha": "15c0dbabd0c90be1626db64de96a23d3a31acb47", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -79,8 +79,8 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             let mut visitor = IfThisChanged { tcx,\n                                             if_this_changed: vec![],\n                                             then_this_would_need: vec![] };\n-            visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);\n-            tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+            visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir().krate().attrs);\n+            tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n \n@@ -121,7 +121,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n \n     fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir.local_def_id(node_id);\n+        let def_id = self.tcx.hir().local_def_id(node_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id);\n         for attr in attrs {\n             if attr.check_name(ATTR_IF_THIS_CHANGED) {\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {"}, {"sha": "8c562ff24fd6d59ab37bc5e5cae538cb5bc431be", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -62,7 +62,7 @@ pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             available_cgus\n         };\n \n-        for attr in &tcx.hir.krate().attrs {\n+        for attr in &tcx.hir().krate().attrs {\n             ams.check_attr(attr);\n         }\n     })"}, {"sha": "55a4a63c8f3d5c9c9a266150e326d5d8800316b8", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -223,7 +223,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n \n     tcx.dep_graph.with_ignore(|| {\n-        let krate = tcx.hir.krate();\n+        let krate = tcx.hir().krate();\n         let mut dirty_clean_visitor = DirtyCleanVisitor {\n             tcx,\n             checked_attrs: Default::default(),\n@@ -333,7 +333,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n     fn auto_labels(&mut self, item_id: ast::NodeId, attr: &Attribute) -> (&'static str, Labels) {\n-        let node = self.tcx.hir.get(item_id);\n+        let node = self.tcx.hir().get(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.node {\n@@ -511,7 +511,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     }\n \n     fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n-        let def_id = self.tcx.hir.local_def_id(item_id);\n+        let def_id = self.tcx.hir().local_def_id(item_id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> FindAllAttrs<'a, 'tcx> {\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for FindAllAttrs<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx Attribute) {"}, {"sha": "9d3dc97552f966fe75cfc12e44c1611bf61d377f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) => {\n-                let def_id = cx.tcx.hir.local_def_id(it.id);\n+                let def_id = cx.tcx.hir().local_def_id(it.id);\n                 self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n             }\n             _ => ()\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    let def_id = cx.tcx.hir.local_def_id(struct_field.id);\n+                    let def_id = cx.tcx.hir().local_def_id(struct_field.id);\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.type_of(def_id));\n                 }\n@@ -424,8 +424,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.def.def_id();\n-                if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n-                    match cx.tcx.hir.find(node_id) {\n+                if let Some(node_id) = cx.tcx.hir().as_local_node_id(real_trait) {\n+                    match cx.tcx.hir().find(node_id) {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n@@ -527,21 +527,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -606,7 +606,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             let mut impls = NodeSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def.did) {\n+                    if let Some(node_id) = cx.tcx.hir().as_local_node_id(ty_def.did) {\n                         impls.insert(node_id);\n                     }\n                 }\n@@ -871,7 +871,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             _ => return,\n         };\n \n-        let def_id = cx.tcx.hir.local_def_id(it.id);\n+        let def_id = cx.tcx.hir().local_def_id(it.id);\n         let prfn = match cx.tcx.extern_mod_stmt_cnum(def_id) {\n             Some(cnum) => cx.tcx.plugin_registrar_fn(cnum),\n             None => {\n@@ -1073,7 +1073,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n         if let hir::ItemKind::Union(ref vdata, _) = item.node {\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.type_of(ctx.tcx.hir.local_def_id(field.id));\n+                let field_ty = ctx.tcx.type_of(ctx.tcx.hir().local_def_id(field.id));\n                 if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,\n@@ -1275,7 +1275,7 @@ impl LintPass for UnusedBrokenConst {\n     }\n }\n fn check_const(cx: &LateContext, body_id: hir::BodyId) {\n-    let def_id = cx.tcx.hir.body_owner_def_id(body_id);\n+    let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n     let is_static = cx.tcx.is_static(def_id).is_some();\n     let param_env = if is_static {\n         // Use the same param_env as `codegen_static_initializer`, to reuse the cache.\n@@ -1332,7 +1332,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n \n \n         if cx.tcx.features().trivial_bounds {\n-            let def_id = cx.tcx.hir.local_def_id(item.id);\n+            let def_id = cx.tcx.hir().local_def_id(item.id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in &predicates.predicates {\n                 let predicate_kind_name = match predicate {\n@@ -1746,7 +1746,7 @@ impl ExplicitOutlivesRequirements {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n-        let def_id = cx.tcx.hir.local_def_id(item.id);\n+        let def_id = cx.tcx.hir().local_def_id(item.id);\n         if let hir::ItemKind::Struct(_, ref generics) = item.node {\n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();"}, {"sha": "33250475d10d4fd84a16680acd2a94b6f05ea113", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -29,7 +29,7 @@ pub enum MethodLateContext {\n }\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId) -> MethodLateContext {\n-    let def_id = cx.tcx.hir.local_def_id(id);\n+    let def_id = cx.tcx.hir().local_def_id(id);\n     let item = cx.tcx.associated_item(def_id);\n     match item.container {\n         ty::TraitContainer(..) => MethodLateContext::TraitAutoImpl,"}, {"sha": "e225e642e72e7c4d409fc76d983426f3a12763f0", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -139,8 +139,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n-                            let parent_id = cx.tcx.hir.get_parent_node(e.id);\n-                            if let Node::Expr(parent_expr) = cx.tcx.hir.get(parent_id) {\n+                            let parent_id = cx.tcx.hir().get_parent_node(e.id);\n+                            if let Node::Expr(parent_expr) = cx.tcx.hir().get(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint(\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     diag.help(s);\n                 }\n                 if let ty::Adt(def, _) = unsafe_ty.sty {\n-                    if let Some(sp) = self.cx.tcx.hir.span_if_local(def.did) {\n+                    if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n                         diag.span_note(sp, \"type defined here\");\n                     }\n                 }\n@@ -766,7 +766,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n-        let def_id = self.cx.tcx.hir.local_def_id(id);\n+        let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n@@ -783,7 +783,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n-        let def_id = self.cx.tcx.hir.local_def_id(id);\n+        let def_id = self.cx.tcx.hir().local_def_id(id);\n         let ty = self.cx.tcx.type_of(def_id);\n         self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n@@ -801,7 +801,7 @@ impl LintPass for ImproperCTypes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_foreign_item(&mut self, cx: &LateContext, it: &hir::ForeignItem) {\n         let mut vis = ImproperCTypesVisitor { cx };\n-        let abi = cx.tcx.hir.get_foreign_abi(it.id);\n+        let abi = cx.tcx.hir().get_foreign_abi(it.id);\n         if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n             match it.node {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {\n@@ -827,7 +827,7 @@ impl LintPass for VariantSizeDifferences {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n-            let item_def_id = cx.tcx.hir.local_def_id(it.id);\n+            let item_def_id = cx.tcx.hir().local_def_id(it.id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);\n             match cx.layout_of(ty) {"}, {"sha": "d3e1af70c21da478159212ad742917ff0529a68f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let t = cx.tables.expr_ty(&expr);\n         let type_permits_lack_of_use = if t.is_unit()\n-            || cx.tcx.is_ty_uninhabited_from(cx.tcx.hir.get_module_parent(expr.id), t) {\n+            || cx.tcx.is_ty_uninhabited_from(cx.tcx.hir().get_module_parent(expr.id), t) {\n             true\n         } else {\n             match t.sty {"}, {"sha": "329e2dbdd9502b3638ad6081762a05417c34205d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -318,7 +318,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_items(&mut self) -> Index {\n-        let krate = self.tcx.hir.krate();\n+        let krate = self.tcx.hir().krate();\n         let mut index = IndexBuilder::new(self);\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n         index.record(DefId::local(CRATE_DEF_INDEX),\n@@ -333,7 +333,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n-        let definitions = self.tcx.hir.definitions();\n+        let definitions = self.tcx.hir().definitions();\n         self.lazy(definitions.def_path_table())\n     }\n \n@@ -475,7 +475,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let index = items.write_index(&mut self.opaque);\n         let index_bytes = self.position() - i;\n \n-        let attrs = tcx.hir.krate_attrs();\n+        let attrs = tcx.hir().krate_attrs();\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         let has_default_lib_allocator = attr::contains_name(&attrs, \"default_lib_allocator\");\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n@@ -495,10 +495,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn\n                 .get()\n-                .map(|id| tcx.hir.local_def_id(id).index),\n+                .map(|id| tcx.hir().local_def_id(id).index),\n             proc_macro_decls_static: if is_proc_macro {\n                 let id = tcx.sess.proc_macro_decls_static.get().unwrap();\n-                Some(tcx.hir.local_def_id(id).index)\n+                Some(tcx.hir().local_def_id(id).index)\n             } else {\n                 None\n             },\n@@ -600,8 +600,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             }\n         };\n \n-        let enum_id = tcx.hir.as_local_node_id(enum_did).unwrap();\n-        let enum_vis = &tcx.hir.expect_item(enum_id).vis;\n+        let enum_id = tcx.hir().as_local_node_id(enum_did).unwrap();\n+        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n@@ -636,7 +636,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                                                                  &hir::Visibility)>)\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir.local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n@@ -652,7 +652,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n-                tcx.hir.local_def_id(item_id.id).index\n+                tcx.hir().local_def_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -686,8 +686,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let def_id = field.did;\n         debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir.as_local_node_id(variant.did).unwrap();\n-        let variant_data = tcx.hir.expect_variant_data(variant_id);\n+        let variant_id = tcx.hir().as_local_node_id(variant.did).unwrap();\n+        let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         Entry {\n             kind: EntryKind::Field,\n@@ -726,8 +726,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             }\n         };\n \n-        let struct_id = tcx.hir.as_local_node_id(adt_def_id).unwrap();\n-        let struct_vis = &tcx.hir.expect_item(struct_id).vis;\n+        let struct_id = tcx.hir().as_local_node_id(adt_def_id).unwrap();\n+        let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n             if ctor_vis.is_at_least(field.vis, tcx) {\n@@ -791,8 +791,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let ast_item = tcx.hir.expect_trait_item(node_id);\n+        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let ast_item = tcx.hir().expect_trait_item(node_id);\n         let trait_item = tcx.associated_item(def_id);\n \n         let container = match trait_item.defaultness {\n@@ -814,7 +814,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     };\n \n                 let rendered =\n-                    hir::print::to_string(&self.tcx.hir, |s| s.print_trait_item(ast_item));\n+                    hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n                 let rendered_const = self.lazy(&RenderedConst(rendered));\n \n                 EntryKind::AssociatedConst(container, const_qualif, rendered_const)\n@@ -891,7 +891,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn const_qualif(&self, mir: u8, body_id: hir::BodyId) -> ConstQualif {\n-        let body_owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n+        let body_owner_def_id = self.tcx.hir().body_owner_def_id(body_id);\n         let ast_promotable = self.tcx.const_is_rvalue_promotable_to_static(body_owner_def_id);\n \n         ConstQualif { mir, ast_promotable }\n@@ -901,8 +901,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-        let ast_item = self.tcx.hir.expect_impl_item(node_id);\n+        let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n+        let ast_item = self.tcx.hir().expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n \n         let container = match impl_item.defaultness {\n@@ -987,7 +987,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n                                     -> LazySeq<ast::Name> {\n         self.tcx.dep_graph.with_ignore(|| {\n-            let body = self.tcx.hir.body(body_id);\n+            let body = self.tcx.hir().body(body_id);\n             self.lazy_seq(body.arguments.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n@@ -1036,8 +1036,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n-        let body = self.tcx.hir.body(body_id);\n-        let rendered = hir::print::to_string(&self.tcx.hir, |s| s.print_expr(&body.value));\n+        let body = self.tcx.hir().body(body_id);\n+        let rendered = hir::print::to_string(self.tcx.hir(), |s| s.print_expr(&body.value));\n         let rendered_const = &RenderedConst(rendered);\n         self.lazy(rendered_const)\n     }\n@@ -1081,7 +1081,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n                 let struct_ctor = if !struct_def.is_struct() {\n-                    Some(tcx.hir.local_def_id(struct_def.id()).index)\n+                    Some(tcx.hir().local_def_id(struct_def.id()).index)\n                 } else {\n                     None\n                 };\n@@ -1167,7 +1167,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n                     self.lazy_seq(fm.items\n                         .iter()\n-                        .map(|foreign_item| tcx.hir.local_def_id(foreign_item.id).index))\n+                        .map(|foreign_item| tcx.hir().local_def_id(foreign_item.id).index))\n                 }\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n@@ -1282,7 +1282,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n         use syntax::print::pprust;\n-        let def_id = self.tcx.hir.local_def_id(macro_def.id);\n+        let def_id = self.tcx.hir().local_def_id(macro_def.id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: pprust::tts_to_string(&macro_def.body.trees().collect::<Vec<_>>()),\n@@ -1339,8 +1339,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let tcx = self.tcx;\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n-        let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n+        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n         let kind = match tables.node_id_to_type(hir_id).sty {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n@@ -1382,8 +1382,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_anon_const({:?})\", def_id);\n         let tcx = self.tcx;\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let body_id = tcx.hir.body_owned_by(id);\n+        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let body_id = tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let mir = tcx.mir_const_qualif(def_id).0;\n \n@@ -1491,7 +1491,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             tcx,\n             impls: FxHashMap::default(),\n         };\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir().krate().visit_all_item_likes(&mut visitor);\n \n         let mut all_impls: Vec<_> = visitor.impls.into_iter().collect();\n \n@@ -1505,7 +1505,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             .map(|(trait_def_id, mut impls)| {\n                 // Bring everything into deterministic order for hashing\n                 impls.sort_by_cached_key(|&def_index| {\n-                    tcx.hir.definitions().def_path_hash(def_index)\n+                    tcx.hir().definitions().def_path_hash(def_index)\n                 });\n \n                 TraitImpls {\n@@ -1617,15 +1617,15 @@ struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir())\n     }\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n         self.index.encode_info_for_expr(ex);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.index.tcx.hir.local_def_id(item.id);\n+        let def_id = self.index.tcx.hir().local_def_id(item.id);\n         match item.node {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => (), // ignore these\n@@ -1635,7 +1635,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.tcx.hir.local_def_id(ni.id);\n+        let def_id = self.index.tcx.hir().local_def_id(ni.id);\n         self.index.record(def_id,\n                           IsolatedEncoder::encode_info_for_foreign_item,\n                           (def_id, ni));\n@@ -1647,7 +1647,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_variant(self, v, g, id);\n \n         if let Some(ref discr) = v.node.disr_expr {\n-            let def_id = self.index.tcx.hir.local_def_id(discr.id);\n+            let def_id = self.index.tcx.hir().local_def_id(discr.id);\n             self.index.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n         }\n     }\n@@ -1660,7 +1660,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         self.index.encode_info_for_ty(ty);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n+        let def_id = self.index.tcx.hir().local_def_id(macro_def.id);\n         self.index.record(def_id, IsolatedEncoder::encode_info_for_macro_def, macro_def);\n     }\n }\n@@ -1682,7 +1682,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n                 hir::GenericParamKind::Type { ref default, .. } => {\n-                    let def_id = self.tcx.hir.local_def_id(param.id);\n+                    let def_id = self.tcx.hir().local_def_id(param.id);\n                     let has_default = Untracked(default.is_some());\n                     let encode_info = IsolatedEncoder::encode_info_for_ty_param;\n                     self.record(def_id, encode_info, (def_id, has_default));\n@@ -1694,7 +1694,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n             hir::TyKind::Array(_, ref length) => {\n-                let def_id = self.tcx.hir.local_def_id(length.id);\n+                let def_id = self.tcx.hir().local_def_id(length.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n             }\n             _ => {}\n@@ -1704,7 +1704,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprKind::Closure(..) => {\n-                let def_id = self.tcx.hir.local_def_id(expr.id);\n+                let def_id = self.tcx.hir().local_def_id(expr.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n             }\n             _ => {}\n@@ -1716,7 +1716,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id(item.id);\n         match item.node {\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n@@ -1746,7 +1746,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n                 // If the struct has a constructor, encode it.\n                 if !struct_def.is_struct() {\n-                    let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n+                    let ctor_def_id = self.tcx.hir().local_def_id(struct_def.id());\n                     self.record(ctor_def_id,\n                                 IsolatedEncoder::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n@@ -1781,7 +1781,7 @@ struct ImplVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Impl(..) = item.node {\n-            let impl_id = self.tcx.hir.local_def_id(item.id);\n+            let impl_id = self.tcx.hir().local_def_id(item.id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls\n                     .entry(trait_ref.def_id)"}, {"sha": "5b2002f2a9683d0073e2e68b8dfdc109530ae49f", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -18,7 +18,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<ForeignModule> {\n         tcx,\n         modules: Vec::new(),\n     };\n-    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n     return collector.modules\n }\n \n@@ -35,11 +35,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n         };\n \n         let foreign_items = fm.items.iter()\n-            .map(|it| self.tcx.hir.local_def_id(it.id))\n+            .map(|it| self.tcx.hir().local_def_id(it.id))\n             .collect();\n         self.modules.push(ForeignModule {\n             foreign_items,\n-            def_id: self.tcx.hir.local_def_id(it.id),\n+            def_id: self.tcx.hir().local_def_id(it.id),\n         });\n     }\n "}, {"sha": "aea3ac1be8188bca4d4165ed3a823192b1012274", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n-            items: Index::new(ecx.tcx.hir.definitions().def_index_counts_lo_hi()),\n+            items: Index::new(ecx.tcx.hir().definitions().def_index_counts_lo_hi()),\n             ecx,\n         }\n     }\n@@ -195,7 +195,7 @@ macro_rules! read_hir {\n     ($t:ty) => {\n         impl<'tcx> DepGraphRead for &'tcx $t {\n             fn read(&self, tcx: TyCtxt) {\n-                tcx.hir.read(self.id);\n+                tcx.hir().read(self.id);\n             }\n         }\n     }\n@@ -229,6 +229,6 @@ pub struct FromId<T>(pub ast::NodeId, pub T);\n \n impl<T> DepGraphRead for FromId<T> {\n     fn read(&self, tcx: TyCtxt) {\n-        tcx.hir.read(self.0);\n+        tcx.hir().read(self.0);\n     }\n }"}, {"sha": "decd85c507e250b09542922bee9f984a94dbfcbb", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -17,9 +17,9 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };\n-    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n-    for attr in tcx.hir.krate().attrs.iter() {\n+    for attr in tcx.hir().krate().attrs.iter() {\n         if attr.path == \"link_args\" {\n             if let Some(linkarg) = attr.value_str() {\n                 collector.add_link_args(&linkarg.as_str());"}, {"sha": "6f85418b297ed39b85b26681a6cf6de2b66a0e3d", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -25,7 +25,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n         tcx,\n         libs: Vec::new(),\n     };\n-    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n     collector.process_command_line();\n     return collector.libs\n }\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                 name: None,\n                 kind: cstore::NativeUnknown,\n                 cfg: None,\n-                foreign_module: Some(self.tcx.hir.local_def_id(it.id)),\n+                foreign_module: Some(self.tcx.hir().local_def_id(it.id)),\n                 wasm_import_module: None,\n             };\n             let mut kind_specified = false;"}, {"sha": "b8d0c0b348ffae042e5c922ed85311f098108090", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -195,8 +195,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let needs_note = match ty.sty {\n                     ty::Closure(id, _) => {\n                         let tables = self.infcx.tcx.typeck_tables_of(id);\n-                        let node_id = self.infcx.tcx.hir.as_local_node_id(id).unwrap();\n-                        let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n+                        let node_id = self.infcx.tcx.hir().as_local_node_id(id).unwrap();\n+                        let hir_id = self.infcx.tcx.hir().node_to_hir_id(node_id);\n \n                         tables.closure_kind_origins().get(hir_id).is_none()\n                     }\n@@ -720,13 +720,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            if let Some(fn_node_id) = self.infcx.tcx.hir.as_local_node_id(self.mir_def_id) {\n+            if let Some(fn_node_id) = self.infcx.tcx.hir().as_local_node_id(self.mir_def_id) {\n                 err.span_label(\n                     drop_span,\n                     format!(\n                         \"...but `{}` will be dropped here, when the function `{}` returns\",\n                         name,\n-                        self.infcx.tcx.hir.name(fn_node_id),\n+                        self.infcx.tcx.hir().name(fn_node_id),\n                     ),\n                 );\n \n@@ -1064,7 +1064,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let escapes_from = if tcx.is_closure(self.mir_def_id) {\n             let tables = tcx.typeck_tables_of(self.mir_def_id);\n-            let mir_hir_id = tcx.hir.def_index_to_hir_id(self.mir_def_id.index);\n+            let mir_hir_id = tcx.hir().def_index_to_hir_id(self.mir_def_id.index);\n             match tables.node_id_to_type(mir_hir_id).sty {\n                 ty::Closure(..) => \"closure\",\n                 ty::Generator(..) => \"generator\",\n@@ -1412,11 +1412,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n \n                 if let ty::TyKind::Closure(did, _substs) = self.mir.local_decls[closure].ty.sty {\n-                    let node_id = match self.infcx.tcx.hir.as_local_node_id(did) {\n+                    let node_id = match self.infcx.tcx.hir().as_local_node_id(did) {\n                         Some(node_id) => node_id,\n                         _ => return,\n                     };\n-                    let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n+                    let hir_id = self.infcx.tcx.hir().node_to_hir_id(node_id);\n \n                     if let Some((\n                         span, name\n@@ -1654,12 +1654,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // the local code in the current crate, so this returns an `Option` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let node_id = self.infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                    let node_id = self.infcx.tcx.hir().as_local_node_id(def_id).unwrap();\n                     let freevar = self.infcx\n                         .tcx\n                         .with_freevars(node_id, |fv| fv[field.index()]);\n \n-                    self.infcx.tcx.hir.name(freevar.var_id()).to_string()\n+                    self.infcx.tcx.hir().name(freevar.var_id()).to_string()\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n@@ -1980,8 +1980,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_node_id = self.infcx.tcx.hir.as_local_node_id(did)?;\n-        let fn_decl = self.infcx.tcx.hir.fn_decl(fn_node_id)?;\n+        let fn_node_id = self.infcx.tcx.hir().as_local_node_id(did)?;\n+        let fn_decl = self.infcx.tcx.hir().fn_decl(fn_node_id)?;\n \n         // We need to work out which arguments to highlight. We do this by looking\n         // at the return type, where there are three cases:\n@@ -2423,8 +2423,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let node_id = self.infcx.tcx.hir.as_local_node_id(def_id)?;\n-        let expr = &self.infcx.tcx.hir.expect_expr(node_id).node;\n+        let node_id = self.infcx.tcx.hir().as_local_node_id(def_id)?;\n+        let expr = &self.infcx.tcx.hir().expect_expr(node_id).node;\n         debug!(\"closure_span: node_id={:?} expr={:?}\", node_id, expr);\n         if let hir::ExprKind::Closure(\n             .., args_span, _"}, {"sha": "14c366b76283231cc6ad9d5619269d0a5ab6a17c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -137,7 +137,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n     let id = tcx\n-        .hir\n+        .hir()\n         .as_local_node_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n@@ -173,7 +173,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n-    let locals_are_invalidated_at_exit = match tcx.hir.body_owner_kind(id) {\n+    let locals_are_invalidated_at_exit = match tcx.hir().body_owner_kind(id) {\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => false,\n             hir::BodyOwnerKind::Fn => true,\n     };\n@@ -229,7 +229,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n-    let movable_generator = match tcx.hir.get(id) {\n+    let movable_generator = match tcx.hir().get(id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             .."}, {"sha": "1811333e445b637443ff28327a9785beb6572186", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -319,8 +319,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                         let upvar_hir_id =\n                                             upvar_decl.var_hir_id.assert_crate_local();\n                                         let upvar_node_id =\n-                                            self.infcx.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                                        let upvar_span = self.infcx.tcx.hir.span(upvar_node_id);\n+                                            self.infcx.tcx.hir().hir_to_node_id(upvar_hir_id);\n+                                        let upvar_span = self.infcx.tcx.hir().span(upvar_node_id);\n                                         diag.span_label(upvar_span, \"captured outer variable\");\n                                         break;\n                                     }"}, {"sha": "ab819aafc47c7a3b4ea4661f53275f45c46ac257", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -317,8 +317,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n                     .var_hir_id\n                     .assert_crate_local();\n-                let upvar_node_id = self.infcx.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir.find(upvar_node_id) {\n+                let upvar_node_id = self.infcx.tcx.hir().hir_to_node_id(upvar_hir_id);\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,\n@@ -641,8 +641,8 @@ fn annotate_struct_field(\n         if let ty::TyKind::Adt(def, _) = ty.sty {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let node_id = tcx.hir.as_local_node_id(field.did)?;\n-            let node = tcx.hir.find(node_id)?;\n+            let node_id = tcx.hir().as_local_node_id(field.did)?;\n+            let node = tcx.hir().find(node_id)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {"}, {"sha": "cd4694351ad0eef51843a7b9213858be4c679db1", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -176,7 +176,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // Dump facts if requested.\n     let polonius_output = all_facts.and_then(|all_facts| {\n         if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n-            let def_path = infcx.tcx.hir.def_path(def_id);\n+            let def_path = infcx.tcx.hir().def_path(def_id);\n             let dir_path =\n                 PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n             all_facts.write_to_dir(dir_path, location_table).unwrap();"}, {"sha": "655704ec06529fbaf372f7f30d5ec54d6b6dd613", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -226,12 +226,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 },\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n+                    let mir_node_id = tcx.hir()\n+                                         .as_local_node_id(mir_def_id)\n+                                         .expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir.expect_expr(mir_node_id).node\n+                            tcx.hir().expect_expr(mir_node_id).node\n                         {\n                             span\n                         } else {\n@@ -302,10 +304,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         name: &InternedString,\n     ) -> Span {\n         let scope = error_region.free_region_binding_scope(tcx);\n-        let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n+        let node = tcx.hir().as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n \n-        let span = tcx.sess.source_map().def_span(tcx.hir.span(node));\n-        if let Some(param) = tcx.hir\n+        let span = tcx.sess.source_map().def_span(tcx.hir().span(node));\n+        if let Some(param) = tcx.hir()\n             .get_generics(scope)\n             .and_then(|generics| generics.get_named(name))\n         {\n@@ -361,8 +363,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_index: usize,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let mir_node_id = infcx.tcx.hir.as_local_node_id(mir_def_id)?;\n-        let fn_decl = infcx.tcx.hir.fn_decl(mir_node_id)?;\n+        let mir_node_id = infcx.tcx.hir().as_local_node_id(mir_def_id)?;\n+        let fn_decl = infcx.tcx.hir().fn_decl(mir_node_id)?;\n         let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n         match argument_hir_ty.node {\n             // This indicates a variable with no type annotation, like\n@@ -685,9 +687,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let type_name = with_highlight_region_for_regionvid(\n             fr, *counter, || infcx.extract_type_name(&return_ty));\n \n-        let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n+        let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n \n-        let (return_span, mir_description) = match tcx.hir.get(mir_node_id) {\n+        let (return_span, mir_description) = match tcx.hir().get(mir_node_id) {\n             hir::Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Closure(_, _, _, span, gen_move),\n                 .."}, {"sha": "5cd3d5fbc73a17d243a86e2fd795092f16665733", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -81,11 +81,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n         let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n-        let upvar_node_id = tcx.hir.hir_to_node_id(upvar_hir_id);\n+        let upvar_node_id = tcx.hir().hir_to_node_id(upvar_hir_id);\n         debug!(\"get_upvar_name_and_span_for_region: upvar_node_id={:?}\", upvar_node_id);\n \n-        let upvar_name = tcx.hir.name(upvar_node_id);\n-        let upvar_span = tcx.hir.span(upvar_node_id);\n+        let upvar_name = tcx.hir().name(upvar_node_id);\n+        let upvar_span = tcx.hir().span(upvar_node_id);\n         debug!(\"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n                upvar_name, upvar_span);\n "}, {"sha": "97fdb80cc78a54bbf537329d19a0bfe60771f0ca", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -210,8 +210,8 @@ impl<'tcx> UniversalRegions<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let tcx = infcx.tcx;\n-        let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).unwrap();\n-        let mir_hir_id = tcx.hir.node_to_hir_id(mir_node_id);\n+        let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).unwrap();\n+        let mir_hir_id = tcx.hir().node_to_hir_id(mir_node_id);\n         UniversalRegionsBuilder {\n             infcx,\n             mir_def_id,\n@@ -485,7 +485,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n \n-        match tcx.hir.body_owner_kind(self.mir_node_id) {\n+        match tcx.hir().body_owner_kind(self.mir_node_id) {\n             BodyOwnerKind::Fn => {\n                 let defining_ty = if self.mir_def_id == closure_base_def_id {\n                     tcx.type_of(closure_base_def_id)\n@@ -780,9 +780,9 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n                 owner: fn_def_id.index,\n                 local_id: *late_bound,\n             };\n-            let region_node_id = tcx.hir.hir_to_node_id(hir_id);\n-            let name = tcx.hir.name(region_node_id).as_interned_str();\n-            let region_def_id = tcx.hir.local_def_id(region_node_id);\n+            let region_node_id = tcx.hir().hir_to_node_id(hir_id);\n+            let name = tcx.hir().name(region_node_id).as_interned_str();\n+            let region_def_id = tcx.hir().local_def_id(region_node_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,\n                 bound_region: ty::BoundRegion::BrNamed(region_def_id, name),"}, {"sha": "69473ab20918454391be072a005ceed860799986", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -470,7 +470,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n         let place = Place::Local(local_id);\n         let var_ty = self.local_decls[local_id].ty;\n-        let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n+        let hir_id = self.hir.tcx().hir().node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n         self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n         place\n@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n-        let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n+        let hir_id = self.hir.tcx().hir().node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n         self.schedule_drop(\n             span,"}, {"sha": "b0601b3bbefb172e70a98355a142c929deef6f71", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -39,10 +39,10 @@ use super::lints;\n \n /// Construct the MIR for a given def-id.\n pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'tcx> {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n-    let (body_id, return_ty_span) = match tcx.hir.get(id) {\n+    let (body_id, return_ty_span) = match tcx.hir().get(id) {\n         Node::Variant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n         Node::StructCtor(ctor) =>\n@@ -76,10 +76,10 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             (*body_id, ty.span)\n         }\n         Node::AnonConst(hir::AnonConst { body, id, .. }) => {\n-            (*body, tcx.hir.span(*id))\n+            (*body, tcx.hir().span(*id))\n         }\n \n-        _ => span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id),\n+        _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def_id),\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n@@ -89,9 +89,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n         } else if let hir::BodyOwnerKind::Fn = cx.body_owner_kind {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_hir_id = tcx.hir.node_to_hir_id(id);\n+            let fn_hir_id = tcx.hir().node_to_hir_id(id);\n             let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n-            let fn_def_id = tcx.hir.local_def_id(id);\n+            let fn_def_id = tcx.hir().local_def_id(id);\n \n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n@@ -121,18 +121,18 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 hir::Unsafety::Unsafe => Safety::FnUnsafe,\n             };\n \n-            let body = tcx.hir.body(body_id);\n+            let body = tcx.hir().body(body_id);\n             let explicit_arguments =\n                 body.arguments\n                     .iter()\n                     .enumerate()\n                     .map(|(index, arg)| {\n-                        let owner_id = tcx.hir.body_owner(body_id);\n+                        let owner_id = tcx.hir().body_owner(body_id);\n                         let opt_ty_info;\n                         let self_arg;\n-                        if let Some(ref fn_decl) = tcx.hir.fn_decl(owner_id) {\n+                        if let Some(ref fn_decl) = tcx.hir().fn_decl(owner_id) {\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let ty_span = tcx.hir.span(tcx.hir.hir_to_node_id(ty_hir_id));\n+                            let ty_span = tcx.hir().span(tcx.hir().hir_to_node_id(ty_hir_id));\n                             opt_ty_info = Some(ty_span);\n                             self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n                                 match fn_decl.implicit_self {\n@@ -159,7 +159,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n-                        span_bug!(tcx.hir.span(id), \"generator w/o generator type: {:?}\", ty),\n+                        span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n                 };\n                 (Some(gen_sig.yield_ty), gen_sig.return_ty)\n             } else {\n@@ -246,7 +246,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      v: &'tcx hir::VariantData)\n                                      -> Mir<'tcx>\n {\n-    let span = tcx.hir.span(ctor_id);\n+    let span = tcx.hir().span(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n         tcx.infer_ctxt().enter(|infcx| {\n             let mut mir = shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n@@ -263,7 +263,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n \n             mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n-                               MirSource::item(tcx.hir.local_def_id(ctor_id)),\n+                               MirSource::item(tcx.hir().local_def_id(ctor_id)),\n                                &mir, |_, _| Ok(()) );\n \n             mir\n@@ -280,7 +280,7 @@ fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                             closure_expr_id: ast::NodeId,\n                                             body_id: hir::BodyId)\n                                             -> Ty<'tcx> {\n-    let closure_expr_hir_id = tcx.hir.node_to_hir_id(closure_expr_id);\n+    let closure_expr_hir_id = tcx.hir().node_to_hir_id(closure_expr_id);\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.sty {\n@@ -662,14 +662,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let arguments: Vec<_> = arguments.collect();\n \n     let tcx = hir.tcx();\n-    let span = tcx.hir.span(fn_id);\n+    let span = tcx.hir().span(fn_id);\n \n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = fv.var_id();\n-            let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n-            let closure_expr_id = tcx.hir.local_def_id(fn_id);\n+            let var_hir_id = tcx.hir().node_to_hir_id(var_id);\n+            let closure_expr_id = tcx.hir().local_def_id(fn_id);\n             let capture = hir.tables().upvar_capture(ty::UpvarId {\n                 var_path: ty::UpvarPath {hir_id: var_hir_id},\n                 closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n@@ -684,7 +684,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref,\n                 mutability: Mutability::Not,\n             };\n-            if let Some(Node::Binding(pat)) = tcx.hir.find(var_id) {\n+            if let Some(Node::Binding(pat)) = tcx.hir().find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n \n@@ -711,7 +711,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         return_ty_span,\n         upvar_decls);\n \n-    let fn_def_id = tcx.hir.local_def_id(fn_id);\n+    let fn_def_id = tcx.hir().local_def_id(fn_id);\n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n         data: region::ScopeData::CallSite\n@@ -754,7 +754,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         // RustCall pseudo-ABI untuples the last argument.\n         spread_arg = Some(Local::new(arguments.len()));\n     }\n-    let closure_expr_id = tcx.hir.local_def_id(fn_id);\n+    let closure_expr_id = tcx.hir().local_def_id(fn_id);\n     info!(\"fn_id {:?} has attrs {:?}\", closure_expr_id,\n           tcx.get_attrs(closure_expr_id));\n \n@@ -769,10 +769,10 @@ fn construct_const<'a, 'gcx, 'tcx>(\n     ty_span: Span,\n ) -> Mir<'tcx> {\n     let tcx = hir.tcx();\n-    let ast_expr = &tcx.hir.body(body_id).value;\n+    let ast_expr = &tcx.hir().body(body_id).value;\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n-    let owner_id = tcx.hir.body_owner(body_id);\n-    let span = tcx.hir.span(owner_id);\n+    let owner_id = tcx.hir().body_owner(body_id);\n+    let span = tcx.hir().span(owner_id);\n     let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, ty_span,vec![]);\n \n     let mut block = START_BLOCK;\n@@ -798,8 +798,8 @@ fn construct_const<'a, 'gcx, 'tcx>(\n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    body_id: hir::BodyId)\n                                    -> Mir<'tcx> {\n-    let owner_id = hir.tcx().hir.body_owner(body_id);\n-    let span = hir.tcx().hir.span(owner_id);\n+    let owner_id = hir.tcx().hir().body_owner(body_id);\n+    let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n     let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![]);\n     let source_info = builder.source_info(span);"}, {"sha": "7388d11ed6c508db9ff78d8a8ea0d3d5f1d6f069", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -322,11 +322,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let same_lint_scopes = tcx.dep_graph.with_ignore(|| {\n                 let sets = tcx.lint_levels(LOCAL_CRATE);\n                 let parent_hir_id =\n-                    tcx.hir.definitions().node_to_hir_id(\n+                    tcx.hir().definitions().node_to_hir_id(\n                         self.source_scope_local_data[source_scope].lint_root\n                     );\n                 let current_hir_id =\n-                    tcx.hir.definitions().node_to_hir_id(node_id);\n+                    tcx.hir().definitions().node_to_hir_id(node_id);\n                 sets.lint_level_set(parent_hir_id) ==\n                     sets.lint_level_set(current_hir_id)\n             });"}, {"sha": "248c5d2db491748426dc7cedc48c3cc7e3c806cc", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -664,15 +664,15 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n \n-    if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+    if let Some(id) = tcx.hir().as_local_node_id(def_id) {\n         let tables = tcx.typeck_tables_of(def_id);\n \n         // Do match-check before building MIR\n         if let Err(ErrorReported) = tcx.check_match(def_id) {\n             return Err(ErrorHandled::Reported)\n         }\n \n-        if let hir::BodyOwnerKind::Const = tcx.hir.body_owner_kind(id) {\n+        if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(id) {\n             tcx.mir_const_qualif(def_id);\n         }\n \n@@ -708,7 +708,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                 // because any code that existed before validation could not have failed validation\n                 // thus preventing such a hard error from being a backwards compatibility hazard\n                 Some(Def::Const(_)) | Some(Def::AssociatedConst(_)) => {\n-                    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n                     err.report_as_lint(\n                         tcx.at(tcx.def_span(def_id)),\n                         \"any use of this value will cause an error\",\n@@ -728,7 +728,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                         err.report_as_lint(\n                             tcx.at(span),\n                             \"reaching this expression at runtime will panic or abort\",\n-                            tcx.hir.as_local_node_id(def_id).unwrap(),\n+                            tcx.hir().as_local_node_id(def_id).unwrap(),\n                         )\n                     }\n                 // anything else (array lengths, enum initializers, constant patterns) are reported"}, {"sha": "beb035d82b1c81baa0acce9310665df7dd28ffd5", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -55,9 +55,9 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n-        let hir_id = cx.tcx.hir.node_to_hir_id(stmt.node.id());\n+        let hir_id = cx.tcx.hir().node_to_hir_id(stmt.node.id());\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        let stmt_span = StatementSpan(cx.tcx.hir.span(stmt.node.id()));\n+        let stmt_span = StatementSpan(cx.tcx.hir().span(stmt.node.id()));\n         match stmt.node {\n             hir::StmtKind::Expr(ref expr, _) |\n             hir::StmtKind::Semi(ref expr, _) => {"}, {"sha": "a772f44673035166aa47d0f090717117833983fe", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -556,7 +556,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n-            let def_id = cx.tcx.hir.local_def_id(count.id);\n+            let def_id = cx.tcx.hir().local_def_id(count.id);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let instance = ty::Instance::resolve(\n                 cx.tcx.global_tcx(),\n@@ -588,7 +588,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 Ok(target_id) => ExprKind::Break {\n                     label: region::Scope {\n-                        id: cx.tcx.hir.node_to_hir_id(target_id).local_id,\n+                        id: cx.tcx.hir().node_to_hir_id(target_id).local_id,\n                         data: region::ScopeData::Node\n                     },\n                     value: value.to_ref(),\n@@ -600,7 +600,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 Ok(loop_id) => ExprKind::Continue {\n                     label: region::Scope {\n-                        id: cx.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                        id: cx.tcx.hir().node_to_hir_id(loop_id).local_id,\n                         data: region::ScopeData::Node\n                     },\n                 },\n@@ -974,17 +974,17 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                    var_id,\n                    index,\n                    closure_expr_id);\n-            let var_hir_id = cx.tcx.hir.node_to_hir_id(var_id);\n+            let var_hir_id = cx.tcx.hir().node_to_hir_id(var_id);\n             let var_ty = cx.tables().node_id_to_type(var_hir_id);\n \n             // FIXME free regions in closures are not right\n             let closure_ty = cx.tables()\n-                               .node_id_to_type(cx.tcx.hir.node_to_hir_id(closure_expr_id));\n+                               .node_id_to_type(cx.tcx.hir().node_to_hir_id(closure_expr_id));\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n-            let closure_def_id = cx.tcx.hir.local_def_id(closure_expr_id);\n+            let closure_def_id = cx.tcx.hir().local_def_id(closure_expr_id);\n             let region = ty::ReFree(ty::FreeRegion {\n                 scope: closure_def_id,\n                 bound_region: ty::BoundRegion::BrAnon(0),\n@@ -1176,10 +1176,10 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    freevar: &hir::Freevar,\n                                    freevar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let var_hir_id = cx.tcx.hir.node_to_hir_id(freevar.var_id());\n+    let var_hir_id = cx.tcx.hir().node_to_hir_id(freevar.var_id());\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).to_local(),\n+        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.id).to_local(),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);"}, {"sha": "a0b2d99dfd30531cbb2f0cfc2f0cce6c38b9566e", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -62,16 +62,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                src_id: ast::NodeId) -> Cx<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n-        let src_def_id = tcx.hir.local_def_id(src_id);\n-        let body_owner_kind = tcx.hir.body_owner_kind(src_id);\n+        let src_def_id = tcx.hir().local_def_id(src_id);\n+        let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n \n         let constness = match body_owner_kind {\n             hir::BodyOwnerKind::Const |\n             hir::BodyOwnerKind::Static(_) => hir::Constness::Const,\n             hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n         };\n \n-        let attrs = tcx.hir.attrs(src_id);\n+        let attrs = tcx.hir().attrs(src_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -157,7 +157,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n-        let p = match tcx.hir.get(p.id) {\n+        let p = match tcx.hir().get(p.id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     fn lint_level_of(&self, node_id: ast::NodeId) -> LintLevel {\n-        let hir_id = self.tcx.hir.definitions().node_to_hir_id(node_id);\n+        let hir_id = self.tcx.hir().definitions().node_to_hir_id(node_id);\n         let has_lint_level = self.tcx.dep_graph.with_ignore(|| {\n             self.tcx.lint_levels(LOCAL_CRATE).lint_level_set(hir_id).is_some()\n         });\n@@ -253,11 +253,11 @@ fn lint_level_for_hir_id(tcx: TyCtxt, mut id: ast::NodeId) -> ast::NodeId {\n     tcx.dep_graph.with_ignore(|| {\n         let sets = tcx.lint_levels(LOCAL_CRATE);\n         loop {\n-            let hir_id = tcx.hir.definitions().node_to_hir_id(id);\n+            let hir_id = tcx.hir().definitions().node_to_hir_id(id);\n             if sets.lint_level_set(hir_id).is_some() {\n                 return id\n             }\n-            let next = tcx.hir.get_parent_node(id);\n+            let next = tcx.hir().get_parent_node(id);\n             if next == id {\n                 bug!(\"lint traversal reached the root of the crate\");\n             }"}, {"sha": "4d38d207c478664985f9e4f71b81ca9c5172e455", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -41,27 +41,27 @@ struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         intravisit::walk_body(self, body);\n-        let def_id = self.tcx.hir.body_owner_def_id(body.id());\n+        let def_id = self.tcx.hir().body_owner_def_id(body.id());\n         let _ = self.tcx.check_match(def_id);\n     }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir.krate().visit_all_item_likes(&mut OuterVisitor { tcx }.as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut OuterVisitor { tcx }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n \n pub(crate) fn check_match<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Result<(), ErrorReported> {\n-    let body_id = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-        tcx.hir.body_owned_by(id)\n+    let body_id = if let Some(id) = tcx.hir().as_local_node_id(def_id) {\n+        tcx.hir().body_owned_by(id)\n     } else {\n         return Ok(());\n     };\n@@ -73,7 +73,7 @@ pub(crate) fn check_match<'a, 'tcx>(\n             region_scope_tree: &tcx.region_scope_tree(def_id),\n             param_env: tcx.param_env(def_id),\n             identity_substs: Substs::identity_for_item(tcx, def_id),\n-        }.visit_body(tcx.hir.body(body_id));\n+        }.visit_body(tcx.hir().body(body_id));\n     })\n }\n \n@@ -192,7 +192,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.hir.get_module_parent(scrut.id);\n+        let module = self.tcx.hir().get_module_parent(scrut.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -224,7 +224,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n             let pat_ty = self.tables.node_id_to_type(scrut.hir_id);\n-            let module = self.tcx.hir.get_module_parent(scrut.id);\n+            let module = self.tcx.hir().get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.features().exhaustive_patterns {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n@@ -267,7 +267,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n-        let module = self.tcx.hir.get_module_parent(pat.id);\n+        let module = self.tcx.hir().get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),"}, {"sha": "5d2f7ec507b7a31e4546530c3e84101107e58b99", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -954,7 +954,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         };\n         let kind = match cv.ty.sty {\n             ty::Float(_) => {\n-                let id = self.tcx.hir.hir_to_node_id(id);\n+                let id = self.tcx.hir().hir_to_node_id(id);\n                 self.tcx.lint_node(\n                     ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,"}, {"sha": "232468fefe201fce051957bd9c48e7eb5a6e111e", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -20,9 +20,9 @@ use rustc::ty::subst::Substs;\n pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n              mir: &Mir<'tcx>,\n              def_id: DefId) {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n \n-    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(node_id)) {\n         check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), mir, def_id);\n     }\n }\n@@ -139,8 +139,8 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // no break */ }`) shouldn't be linted unless it actually\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n-        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let sp = tcx.sess.source_map().def_span(tcx.hir.span(node_id));\n+        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let sp = tcx.sess.source_map().def_span(tcx.hir().span(node_id));\n         let mut db = tcx.struct_span_lint_node(UNCONDITIONAL_RECURSION,\n                                                 node_id,\n                                                 sp,"}, {"sha": "7890b926948c22b779eea88be3720b4e07a1b553", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -332,7 +332,7 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     {\n         let entry_fn = tcx.sess.entry_fn.borrow().map(|(node_id, _, _)| {\n-            tcx.hir.local_def_id(node_id)\n+            tcx.hir().local_def_id(node_id)\n         });\n \n         debug!(\"collect_roots: entry_fn = {:?}\", entry_fn);\n@@ -344,7 +344,7 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             output: &mut roots,\n         };\n \n-        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir().krate().visit_all_item_likes(&mut visitor);\n \n         visitor.push_extra_entry_roots();\n     }\n@@ -462,8 +462,8 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if recursion_depth > *tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n-        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-            tcx.sess.span_fatal(tcx.hir.span(node_id), &error);\n+        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+            tcx.sess.span_fatal(tcx.hir().span(node_id), &error);\n         } else {\n             tcx.sess.fatal(&error);\n         }\n@@ -494,8 +494,8 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let instance_name = instance.to_string();\n         let msg = format!(\"reached the type-length limit while instantiating `{:.64}...`\",\n                           instance_name);\n-        let mut diag = if let Some(node_id) = tcx.hir.as_local_node_id(instance.def_id()) {\n-            tcx.sess.struct_span_fatal(tcx.hir.span(node_id), &msg)\n+        let mut diag = if let Some(node_id) = tcx.hir().as_local_node_id(instance.def_id()) {\n+            tcx.sess.struct_span_fatal(tcx.hir().span(node_id), &msg)\n         } else {\n             tcx.sess.struct_fatal(&msg)\n         };\n@@ -961,7 +961,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemKind::Union(_, ref generics) => {\n                 if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n-                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.tcx, def_id));\n \n@@ -973,11 +973,11 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemKind::GlobalAsm(..) => {\n                 debug!(\"RootCollector: ItemKind::GlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n-                                        self.tcx.hir.local_def_id(item.id)));\n+                                        self.tcx.hir().local_def_id(item.id)));\n                 self.output.push(MonoItem::GlobalAsm(item.id));\n             }\n             hir::ItemKind::Static(..) => {\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 debug!(\"RootCollector: ItemKind::Static({})\",\n                        def_id_to_string(self.tcx, def_id));\n                 self.output.push(MonoItem::Static(def_id));\n@@ -987,7 +987,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n \n                 let instance = Instance::mono(self.tcx, def_id);\n                 let cid = GlobalId {\n@@ -1001,7 +1001,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 self.push_if_root(def_id);\n             }\n         }\n@@ -1015,7 +1015,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n-                let def_id = self.tcx.hir.local_def_id(ii.id);\n+                let def_id = self.tcx.hir().local_def_id(ii.id);\n                 self.push_if_root(def_id);\n             }\n             _ => { /* Nothing to do here */ }\n@@ -1108,7 +1108,7 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             }\n \n-            let impl_def_id = tcx.hir.local_def_id(item.id);\n+            let impl_def_id = tcx.hir().local_def_id(item.id);\n \n             debug!(\"create_mono_items_for_default_impls(item={})\",\n                    def_id_to_string(tcx, impl_def_id));"}, {"sha": "2bc6e93c8c1a9cb61a428836d38c48a7cba16978", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -68,7 +68,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n                 tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n             MonoItem::GlobalAsm(node_id) => {\n-                let def_id = tcx.hir.local_def_id(node_id);\n+                let def_id = tcx.hir().local_def_id(node_id);\n                 ty::SymbolName {\n                     name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_interned_str()\n                 }\n@@ -86,7 +86,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => {\n                 let entry_def_id =\n-                    tcx.sess.entry_fn.borrow().map(|(id, _, _)| tcx.hir.local_def_id(id));\n+                    tcx.sess.entry_fn.borrow().map(|(id, _, _)| tcx.hir().local_def_id(id));\n                 // If this function isn't inlined or otherwise has explicit\n                 // linkage, then we'll be creating a globally shared version.\n                 if self.explicit_linkage(tcx).is_some() ||\n@@ -199,15 +199,15 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n         match *self.as_mono_item() {\n             MonoItem::Fn(Instance { def, .. }) => {\n-                tcx.hir.as_local_node_id(def.def_id())\n+                tcx.hir().as_local_node_id(def.def_id())\n             }\n             MonoItem::Static(def_id) => {\n-                tcx.hir.as_local_node_id(def_id)\n+                tcx.hir().as_local_node_id(def_id)\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 Some(node_id)\n             }\n-        }.map(|node_id| tcx.hir.span(node_id))\n+        }.map(|node_id| tcx.hir().span(node_id))\n     }\n }\n "}, {"sha": "efe6f6dd6fefac9eb68a56c547c6d762580f6550", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -184,7 +184,7 @@ pub trait CodegenUnitExt<'tcx> {\n                         // the codegen tests and can even make item order\n                         // unstable.\n                         InstanceDef::Item(def_id) => {\n-                            tcx.hir.as_local_node_id(def_id)\n+                            tcx.hir().as_local_node_id(def_id)\n                         }\n                         InstanceDef::VtableShim(..) |\n                         InstanceDef::Intrinsic(..) |\n@@ -198,7 +198,7 @@ pub trait CodegenUnitExt<'tcx> {\n                     }\n                 }\n                 MonoItem::Static(def_id) => {\n-                    tcx.hir.as_local_node_id(def_id)\n+                    tcx.hir().as_local_node_id(def_id)\n                 }\n                 MonoItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n@@ -415,7 +415,7 @@ fn mono_item_visibility(\n             };\n         }\n         MonoItem::GlobalAsm(node_id) => {\n-            let def_id = tcx.hir.local_def_id(*node_id);\n+            let def_id = tcx.hir().local_def_id(*node_id);\n             return if tcx.is_reachable_non_generic(def_id) {\n                 *can_be_internalized = false;\n                 default_visibility(tcx, def_id, false)\n@@ -799,7 +799,7 @@ fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(node_id) => Some(tcx.hir.local_def_id(node_id)),\n+        MonoItem::GlobalAsm(node_id) => Some(tcx.hir().local_def_id(node_id)),\n     }\n }\n "}, {"sha": "114162946051ea71cf6657a1f8a9c758acf1b8d0", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -860,7 +860,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let gcx = tcx.global_tcx();\n-    let def_id = tcx.hir.local_def_id(ctor_id);\n+    let def_id = tcx.hir().local_def_id(ctor_id);\n     let param_env = gcx.param_env(def_id);\n \n     // Normalize the sig."}, {"sha": "660892c0a5f889aee832c1347e475ee498b46952", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -473,8 +473,8 @@ fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  unsafe_blocks: &'a mut Vec<(ast::NodeId, bool)>)\n {\n     let body_id =\n-        tcx.hir.as_local_node_id(def_id).and_then(|node_id| {\n-            tcx.hir.maybe_body_owned_by(node_id)\n+        tcx.hir().as_local_node_id(def_id).and_then(|node_id| {\n+            tcx.hir().maybe_body_owned_by(node_id)\n         });\n \n     let body_id = match body_id {\n@@ -484,7 +484,7 @@ fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             return\n         }\n     };\n-    let body = tcx.hir.body(body_id);\n+    let body = tcx.hir().body(body_id);\n     debug!(\"check_unused_unsafe({:?}, body={:?}, used_unsafe={:?})\",\n            def_id, body, used_unsafe);\n \n@@ -526,7 +526,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n }\n \n fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let lint_node_id = match tcx.hir.as_local_node_id(def_id) {\n+    let lint_node_id = match tcx.hir().as_local_node_id(def_id) {\n         Some(node_id) => node_id,\n         None => bug!(\"checking unsafety for non-local def id {:?}\", def_id)\n     };\n@@ -550,14 +550,14 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n fn is_enclosed(tcx: TyCtxt,\n                used_unsafe: &FxHashSet<ast::NodeId>,\n                id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n-    let parent_id = tcx.hir.get_parent_node(id);\n+    let parent_id = tcx.hir().get_parent_node(id);\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n-        })) = tcx.hir.find(parent_id) {\n+        })) = tcx.hir().find(parent_id) {\n             match header.unsafety {\n                 hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n                 hir::Unsafety::Normal => None,\n@@ -571,12 +571,12 @@ fn is_enclosed(tcx: TyCtxt,\n }\n \n fn report_unused_unsafe(tcx: TyCtxt, used_unsafe: &FxHashSet<ast::NodeId>, id: ast::NodeId) {\n-    let span = tcx.sess.source_map().def_span(tcx.hir.span(id));\n+    let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_node(UNUSED_UNSAFE, id, span, msg);\n     db.span_label(span, msg);\n     if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(tcx.sess.source_map().def_span(tcx.hir.span(id)),\n+        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span(id)),\n                       format!(\"because it's nested under this `unsafe` {}\", kind));\n     }\n     db.emit();"}, {"sha": "5e00dea5a0562b625c4c2765f9127fae8320e3f7", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -47,10 +47,10 @@ impl MirPass for ConstProp {\n         }\n \n         use rustc::hir::map::blocks::FnLikeNode;\n-        let node_id = tcx.hir.as_local_node_id(source.def_id)\n+        let node_id = tcx.hir().as_local_node_id(source.def_id)\n                              .expect(\"Non-local call to local provider is_const_fn\");\n \n-        let is_fn_like = FnLikeNode::from_node(tcx.hir.get(node_id)).is_some();\n+        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(node_id)).is_some();\n         let is_assoc_const = match tcx.describe_def(source.def_id) {\n             Some(Def::AssociatedConst(_)) => true,\n             _ => false,\n@@ -618,7 +618,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         .span;\n                     let node_id = self\n                         .tcx\n-                        .hir\n+                        .hir()\n                         .as_local_node_id(self.source.def_id)\n                         .expect(\"some part of a failing const eval must be local\");\n                     use rustc::mir::interpret::EvalErrorKind::*;"}, {"sha": "c8056ea3e1f94fd5f2c55e97b907c7ba46815dca", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -38,7 +38,7 @@ impl MirPass for ElaborateDrops {\n     {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n \n-        let id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n+        let id = tcx.hir().as_local_node_id(src.def_id).unwrap();\n         let param_env = tcx.param_env(src.def_id).with_reveal_all();\n         let move_data = match MoveData::gather_moves(mir, tcx) {\n             Ok(move_data) => move_data,"}, {"sha": "f870e4a2a422701e247c5411e6ea1d9c78eb57e7", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -379,7 +379,7 @@ fn locals_live_across_suspend_points(\n     FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n ) {\n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n-    let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n+    let node_id = tcx.hir().as_local_node_id(source.def_id).unwrap();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes."}, {"sha": "0348ea5b81976645b30256cf0a6cdc1b8a91e902", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -83,8 +83,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         let param_env = self.tcx.param_env(self.source.def_id);\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir.as_local_node_id(self.source.def_id).unwrap();\n-        let body_owner_kind = self.tcx.hir.body_owner_kind(id);\n+        let id = self.tcx.hir().as_local_node_id(self.source.def_id).unwrap();\n+        let body_owner_kind = self.tcx.hir().body_owner_kind(id);\n \n         if let (hir::BodyOwnerKind::Fn, None) = (body_owner_kind, self.source.promoted) {\n "}, {"sha": "005c1a08affd5aabafc5df88c75abc36d26cc5c7", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -91,15 +91,15 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n                               _: ast::NodeId,\n                               _: Span) {\n             if let hir::VariantData::Tuple(_, node_id) = *v {\n-                self.set.insert(self.tcx.hir.local_def_id(node_id));\n+                self.set.insert(self.tcx.hir().local_def_id(node_id));\n             }\n             intravisit::walk_struct_def(self, v)\n         }\n         fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n             NestedVisitorMap::None\n         }\n     }\n-    tcx.hir.krate().visit_all_item_likes(&mut GatherCtors {\n+    tcx.hir().krate().visit_all_item_likes(&mut GatherCtors {\n         tcx,\n         set: &mut set,\n     }.as_deep_visitor());\n@@ -219,8 +219,8 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n }\n \n fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    if let hir::BodyOwnerKind::Const = tcx.hir.body_owner_kind(node_id) {\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(node_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n         // this point, before we steal the mir-const result.\n         let _ = tcx.mir_const_qualif(def_id);"}, {"sha": "034096fe889a3c11116cc1278f6bf711cea43c5d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -1293,9 +1293,9 @@ impl MirPass for QualifyAndPromoteConstants {\n         }\n \n         let def_id = src.def_id;\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n-        let mode = match tcx.hir.body_owner_kind(id) {\n+        let mode = match tcx.hir().body_owner_kind(id) {\n             hir::BodyOwnerKind::Fn => {\n                 if tcx.is_const_fn(def_id) {\n                     Mode::ConstFn"}, {"sha": "c996dc285f7e77f71c1dc7cceb7ea0179fc2538e", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -34,7 +34,7 @@ impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id;\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n         if !tcx.has_attr(def_id, \"rustc_mir\") {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n             return;"}, {"sha": "58963a40ad09ebf3bb27caae0dee45c04615e13d", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -38,7 +38,7 @@ pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n                                       w: &mut W) -> io::Result<()>\n     where W: Write\n {\n-    writeln!(w, \"digraph Mir_{} {{\", tcx.hir.as_local_node_id(def_id).unwrap())?;\n+    writeln!(w, \"digraph Mir_{} {{\", tcx.hir().as_local_node_id(def_id).unwrap())?;\n \n     // Global graph properties\n     writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#)?;"}, {"sha": "22cc8ead478a92d0b6d74385df5e730df7782816", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -343,7 +343,7 @@ fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n+    let item_id = tcx.hir().as_local_node_id(source.def_id).unwrap();\n     let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|mut file| {"}, {"sha": "0db9b23925a1fb2fb48ae0acae54b0f2884492d4", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -193,7 +193,7 @@ fn dump_path(\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n \n-    let item_name = tcx.hir\n+    let item_name = tcx.hir()\n         .def_path(source.def_id)\n         .to_filename_friendly_no_crate();\n \n@@ -569,8 +569,8 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n }\n \n fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n-    let id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n-    let body_owner_kind = tcx.hir.body_owner_kind(id);\n+    let id = tcx.hir().as_local_node_id(src.def_id).unwrap();\n+    let body_owner_kind = tcx.hir().body_owner_kind(id);\n     match (body_owner_kind, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in\", i)?,\n         (hir::BodyOwnerKind::Fn, _) => write!(w, \"fn\")?,"}, {"sha": "b41a04e354d27fbc3dc8b669306b1f2f8b7cda66", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -50,8 +50,8 @@ pub fn provide(providers: &mut Providers) {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &body_id in &tcx.hir.krate().body_ids {\n-        let def_id = tcx.hir.body_owner_def_id(body_id);\n+    for &body_id in &tcx.hir().krate().body_ids {\n+        let def_id = tcx.hir().body_owner_def_id(body_id);\n         tcx.const_is_rvalue_promotable_to_static(def_id);\n     }\n     tcx.sess.abort_if_errors();\n@@ -63,10 +63,10 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     assert!(def_id.is_local());\n \n-    let node_id = tcx.hir.as_local_node_id(def_id)\n+    let node_id = tcx.hir().as_local_node_id(def_id)\n         .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir.body_owned_by(node_id);\n-    let body_hir_id = tcx.hir.node_to_hir_id(body_id.node_id);\n+    let body_id = tcx.hir().body_owned_by(node_id);\n+    let body_hir_id = tcx.hir().node_to_hir_id(body_id.node_id);\n     tcx.rvalue_promotable_map(def_id).contains(&body_hir_id.local_id)\n }\n \n@@ -91,9 +91,9 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     // `def_id` should be a `Body` owner\n-    let node_id = tcx.hir.as_local_node_id(def_id)\n+    let node_id = tcx.hir().as_local_node_id(def_id)\n         .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir.body_owned_by(node_id);\n+    let body_id = tcx.hir().body_owned_by(node_id);\n     let _ = visitor.check_nested_body(body_id);\n \n     Lrc::new(visitor.result)\n@@ -189,8 +189,8 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_nested_body(&mut self, body_id: hir::BodyId) -> Promotability {\n-        let item_id = self.tcx.hir.body_owner(body_id);\n-        let item_def_id = self.tcx.hir.local_def_id(item_id);\n+        let item_id = self.tcx.hir().body_owner(body_id);\n+        let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         let outer_in_fn = self.in_fn;\n         let outer_tables = self.tables;\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         self.in_fn = false;\n         self.in_static = false;\n \n-        match self.tcx.hir.body_owner_kind(item_id) {\n+        match self.tcx.hir().body_owner_kind(item_id) {\n             hir::BodyOwnerKind::Fn => self.in_fn = true,\n             hir::BodyOwnerKind::Static(_) => self.in_static = true,\n             _ => {}\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         self.param_env = self.tcx.param_env(item_def_id);\n         self.identity_substs = Substs::identity_for_item(self.tcx, item_def_id);\n \n-        let body = self.tcx.hir.body(body_id);\n+        let body = self.tcx.hir().body(body_id);\n \n         let tcx = self.tcx;\n         let param_env = self.param_env;"}, {"sha": "ccdcfe322b1c246c8c752b9f5dd078cf31285fe8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -60,7 +60,7 @@ struct PubRestrictedVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n     fn visit_vis(&mut self, vis: &'tcx hir::Visibility) {\n         self.has_pub_restricted = self.has_pub_restricted || vis.node.is_pub_restricted();\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n             ty::Projection(ref proj) => proj.trait_ref(self.tcx).def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(ty_def_id) {\n+        if let Some(node_id) = self.tcx.hir().as_local_node_id(ty_def_id) {\n             self.get(node_id)\n         } else {\n             Some(AccessLevel::Public)\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n \n     fn impl_trait_level(&self, impl_def_id: DefId) -> Option<AccessLevel> {\n         if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_def_id) {\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(trait_ref.def_id) {\n+            if let Some(node_id) = self.tcx.hir().as_local_node_id(trait_ref.def_id) {\n                 return self.get(node_id);\n             }\n         }\n@@ -134,7 +134,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n                  -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: self.prev_level.map(|l| l.min(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir.local_def_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id),\n             ev: self,\n         }\n     }\n@@ -144,14 +144,14 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n             hir::ItemKind::Impl(..) => {\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n             }\n             // Foreign mods inherit level from parents\n@@ -220,7 +220,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             // It (and its children) are revisited if the change applies.\n             hir::ItemKind::Existential(ref ty_data) => {\n                 if let Some(impl_trait_fn) = ty_data.impl_trait_fn {\n-                    if let Some(node_id) = self.tcx.hir.as_local_node_id(impl_trait_fn) {\n+                    if let Some(node_id) = self.tcx.hir().as_local_node_id(impl_trait_fn) {\n                         self.update(node_id, Some(AccessLevel::ReachableFromImplTrait));\n                     }\n                 }\n@@ -358,12 +358,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n-            let def_id = self.tcx.hir.local_def_id(id);\n+            let def_id = self.tcx.hir().local_def_id(id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n                         if let Some(def_id) = export.def.opt_def_id() {\n-                            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n                                 self.update(node_id, Some(AccessLevel::Exported));\n                             }\n                         }\n@@ -381,8 +381,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             return\n         }\n \n-        let module_did = ty::DefIdTree::parent(self.tcx, self.tcx.hir.local_def_id(md.id)).unwrap();\n-        let mut module_id = self.tcx.hir.as_local_node_id(module_did).unwrap();\n+        let module_did = ty::DefIdTree::parent(\n+            self.tcx,\n+            self.tcx.hir().local_def_id(md.id)\n+        ).unwrap();\n+        let mut module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n         let level = self.update(md.id, level);\n         if level.is_none() {\n@@ -391,20 +394,20 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n         loop {\n             let module = if module_id == ast::CRATE_NODE_ID {\n-                &self.tcx.hir.krate().module\n-            } else if let hir::ItemKind::Mod(ref module) = self.tcx.hir.expect_item(module_id).node\n-            {\n+                &self.tcx.hir().krate().module\n+            } else if let hir::ItemKind::Mod(ref module) =\n+                          self.tcx.hir().expect_item(module_id).node {\n                 module\n             } else {\n                 unreachable!()\n             };\n             for id in &module.item_ids {\n                 self.update(id.id, level);\n             }\n-            let def_id = self.tcx.hir.local_def_id(module_id);\n+            let def_id = self.tcx.hir().local_def_id(module_id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n-                    if let Some(node_id) = self.tcx.hir.as_local_node_id(export.def.def_id()) {\n+                    if let Some(node_id) = self.tcx.hir().as_local_node_id(export.def.def_id()) {\n                         self.update(node_id, level);\n                     }\n                 }\n@@ -413,7 +416,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             if module_id == ast::CRATE_NODE_ID {\n                 break\n             }\n-            module_id = self.tcx.hir.get_parent_node(module_id);\n+            module_id = self.tcx.hir().get_parent_node(module_id);\n         }\n     }\n }\n@@ -473,8 +476,8 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n-        if let Some(node_id) = self.ev.tcx.hir.as_local_node_id(trait_ref.def_id) {\n-            let item = self.ev.tcx.hir.expect_item(node_id);\n+        if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(trait_ref.def_id) {\n+            let item = self.ev.tcx.hir().expect_item(node_id);\n             self.ev.update(item.id, self.access_level);\n         }\n     }\n@@ -495,7 +498,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n         };\n \n         if let Some(def_id) = ty_def_id {\n-            if let Some(node_id) = self.ev.tcx.hir.as_local_node_id(def_id) {\n+            if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(def_id) {\n                 self.ev.update(node_id, self.access_level);\n             }\n         }\n@@ -543,7 +546,7 @@ fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            tables: &mut &'a ty::TypeckTables<'tcx>,\n                            empty_tables: &'a ty::TypeckTables<'tcx>)\n                            -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir.local_def_id(item_id);\n+    let def_id = tcx.hir().local_def_id(item_id);\n \n     if tcx.has_typeck_tables(def_id) {\n         replace(tables, tcx.typeck_tables_of(def_id))\n@@ -556,12 +559,12 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n     }\n@@ -657,19 +660,19 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     fn def_id_visibility(&self, did: DefId) -> ty::Visibility {\n-        match self.tcx.hir.as_local_node_id(did) {\n+        match self.tcx.hir().as_local_node_id(did) {\n             Some(node_id) => {\n-                let vis = match self.tcx.hir.get(node_id) {\n+                let vis = match self.tcx.hir().get(node_id) {\n                     Node::Item(item) => &item.vis,\n                     Node::ForeignItem(foreign_item) => &foreign_item.vis,\n                     Node::ImplItem(impl_item) => &impl_item.vis,\n                     Node::TraitItem(..) |\n                     Node::Variant(..) => {\n-                        return self.def_id_visibility(self.tcx.hir.get_parent_did(node_id));\n+                        return self.def_id_visibility(self.tcx.hir().get_parent_did(node_id));\n                     }\n                     Node::StructCtor(vdata) => {\n-                        let struct_node_id = self.tcx.hir.get_parent(node_id);\n-                        let struct_vis = match self.tcx.hir.get(struct_node_id) {\n+                        let struct_node_id = self.tcx.hir().get_parent(node_id);\n+                        let struct_vis = match self.tcx.hir().get(struct_node_id) {\n                             Node::Item(item) => &item.vis,\n                             node => bug!(\"unexpected node kind: {:?}\", node),\n                         };\n@@ -684,7 +687,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n \n                         // If the structure is marked as non_exhaustive then lower the\n                         // visibility to within the crate.\n-                        let struct_def_id = self.tcx.hir.get_parent_did(node_id);\n+                        let struct_def_id = self.tcx.hir().get_parent_did(node_id);\n                         let adt_def = self.tcx.adt_def(struct_def_id);\n                         if adt_def.non_enum_variant().is_field_list_non_exhaustive()\n                             && ctor_vis == ty::Visibility::Public\n@@ -741,13 +744,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n         let orig_in_body = replace(&mut self.in_body, true);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n         self.in_body = orig_in_body;\n@@ -888,7 +891,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                                         &mut self.tables,\n                                         self.empty_tables);\n         let orig_in_body = replace(&mut self.in_body, false);\n-        self.current_item = self.tcx.hir.local_def_id(item.id);\n+        self.current_item = self.tcx.hir().local_def_id(item.id);\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n         self.in_body = orig_in_body;\n@@ -1036,10 +1039,10 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n         // A path can only be private if:\n         // it's in this crate...\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(did) {\n+        if let Some(node_id) = self.tcx.hir().as_local_node_id(did) {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n-            match self.tcx.hir.find(node_id) {\n+            match self.tcx.hir().find(node_id) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n@@ -1098,7 +1101,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -1154,7 +1157,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                               |tr| {\n                         let did = tr.path.def.def_id();\n \n-                        if let Some(node_id) = self.tcx.hir.as_local_node_id(did) {\n+                        if let Some(node_id) = self.tcx.hir().as_local_node_id(did) {\n                             self.trait_is_public(node_id)\n                         } else {\n                             true // external traits must be public\n@@ -1173,7 +1176,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     trait_ref.is_some() ||\n                     impl_item_refs.iter()\n                                  .any(|impl_item_ref| {\n-                                     let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                                     let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                      match impl_item.node {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n@@ -1198,7 +1201,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // should only walk into public items so that we\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n-                                let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                                let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n@@ -1231,7 +1234,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item_ref in impl_item_refs {\n-                                let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                                let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n                                     self.visit_ty(ty);\n                                 }\n@@ -1244,7 +1247,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_item_refs {\n                         if self.item_is_public(&impl_item_ref.id.node_id, &impl_item_ref.vis) {\n-                            let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                            let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n                                 hir::AssociatedItemKind::Const => {\n                                     found_pub_static = true;\n@@ -1427,8 +1430,8 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n \n     fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(trait_ref.def_id) {\n-            let item = self.tcx.hir.expect_item(node_id);\n+        if let Some(node_id) = self.tcx.hir().as_local_node_id(trait_ref.def_id) {\n+            let item = self.tcx.hir().expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n             if !vis.is_at_least(self.min_visibility, self.tcx) {\n                 self.min_visibility = vis;\n@@ -1476,8 +1479,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n \n         if let Some(def_id) = ty_def_id {\n             // Non-local means public (private items can't leave their crate, modulo bugs)\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let hir_vis = match self.tcx.hir.find(node_id) {\n+            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n+                let hir_vis = match self.tcx.hir().find(node_id) {\n                     Some(Node::Item(item)) => &item.vis,\n                     Some(Node::ForeignItem(item)) => &item.vis,\n                     _ => bug!(\"expected item of foreign item\"),\n@@ -1537,7 +1540,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n                     has_old_errors = true;\n                     break;\n                 }\n-                let parent = self.tcx.hir.get_parent_node(id);\n+                let parent = self.tcx.hir().get_parent_node(id);\n                 if parent == id {\n                     break;\n                 }\n@@ -1551,8 +1554,8 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n \n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n-            item_def_id: self.tcx.hir.local_def_id(item_id),\n-            span: self.tcx.hir.span(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id),\n+            span: self.tcx.hir().span(item_id),\n             min_visibility: ty::Visibility::Public,\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n@@ -1564,7 +1567,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -1656,7 +1659,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.id, ty_vis).generics().predicates();\n \n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                    let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                     let impl_item_vis = ty::Visibility::from_hir(&impl_item.vis, item.id, tcx);\n                     let mut check = self.check(impl_item.id, min(impl_item_vis, ty_vis));\n                     check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n@@ -1674,7 +1677,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                               .ty().impl_trait_ref().min_visibility;\n                 self.check(item.id, vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                    let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                     let mut check = self.check(impl_item.id, vis);\n                     check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n                     check.generics().predicates().ty();\n@@ -1713,7 +1716,7 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    -> Lrc<AccessLevels> {\n     assert_eq!(krate, LOCAL_CRATE);\n \n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages."}, {"sha": "b1c1c9635bfa65babc19cb82114a324915ced93a", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -126,7 +126,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     where\n         F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>),\n     {\n-        let item_def_id = self.tcx.hir.local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id(item_id);\n         if self.tcx.has_typeck_tables(item_def_id) {\n             let tables = self.tcx.typeck_tables_of(item_def_id);\n             let old_tables = self.save_ctxt.tables;\n@@ -249,7 +249,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             collector.visit_pat(&arg.pat);\n \n             for (id, ident, ..) in collector.collected_idents {\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n@@ -673,7 +673,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n         self.process_generic_params(type_parameters, \"\", item.id);\n         for impl_item in impl_items {\n-            let map = &self.tcx.hir;\n+            let map = &self.tcx.hir();\n             self.process_impl_item(impl_item, map.local_def_id(item.id));\n         }\n     }\n@@ -752,7 +752,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         // walk generics and methods\n         self.process_generic_params(generics, &qualname, item.id);\n         for method in methods {\n-            let map = &self.tcx.hir;\n+            let map = &self.tcx.hir();\n             self.process_trait_item(method, map.local_def_id(item.id))\n         }\n     }\n@@ -866,7 +866,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         match p.node {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n-                let hir_id = self.tcx.hir.node_to_hir_id(p.id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(p.id);\n                 let adt = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n@@ -911,7 +911,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     } else {\n                         \"<mutable>\".to_owned()\n                     };\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let hir_id = self.tcx.hir().node_to_hir_id(id);\n                     let typ = self.save_ctxt\n                         .tables\n                         .node_id_to_type_opt(hir_id)\n@@ -982,7 +982,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let hir_id = self.tcx.hir().node_to_hir_id(id);\n             let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n@@ -1204,7 +1204,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let access = access_from!(self.save_ctxt, root_item.vis, id);\n \n         // The parent def id of a given use tree is always the enclosing item.\n-        let parent = self.save_ctxt.tcx.hir.opt_local_def_id(id)\n+        let parent = self.save_ctxt.tcx.hir().opt_local_def_id(id)\n             .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n             .map(::id_from_def_id);\n \n@@ -1357,7 +1357,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n-                    let parent = self.save_ctxt.tcx.hir.opt_local_def_id(item.id)\n+                    let parent = self.save_ctxt.tcx.hir().opt_local_def_id(item.id)\n                         .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n                         .map(::id_from_def_id);\n                     self.dumper.import(\n@@ -1510,7 +1510,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         self.process_macro_use(ex.span);\n         match ex.node {\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                let hir_expr = self.save_ctxt.tcx.hir.expect_expr(ex.id);\n+                let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.id);\n                 let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {"}, {"sha": "85ffd3eb1c277737663bb5c31434c178391d7e46", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -383,7 +383,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             let name = ident.to_string();\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n             filter!(self.span_utils, ident.span);\n-            let def_id = self.tcx.hir.local_def_id(field.id);\n+            let def_id = self.tcx.hir().local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n \n \n@@ -415,18 +415,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n-            match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n-                Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n+            match self.tcx.impl_of_method(self.tcx.hir().local_def_id(id)) {\n+                Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n                     Some(Node::Item(item)) => match item.node {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n-                            qualname.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n+                            qualname.push_str(&self.tcx.hir().node_to_pretty_string(ty.id));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut decl_id = None;\n                             let mut docs = String::new();\n                             let mut attrs = vec![];\n-                            if let Some(Node::ImplItem(item)) = self.tcx.hir.find(id) {\n+                            if let Some(Node::ImplItem(item)) = self.tcx.hir().find(id) {\n                                 docs = self.docs_for_attrs(&item.attrs);\n                                 attrs = item.attrs.to_vec();\n                             }\n@@ -463,12 +463,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         );\n                     }\n                 },\n-                None => match self.tcx.trait_of_item(self.tcx.hir.local_def_id(id)) {\n+                None => match self.tcx.trait_of_item(self.tcx.hir().local_def_id(id)) {\n                     Some(def_id) => {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n \n-                        if let Some(Node::TraitItem(item)) = self.tcx.hir.find(id) {\n+                        if let Some(Node::TraitItem(item)) = self.tcx.hir().find(id) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n@@ -529,14 +529,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n-        let hir_node = self.tcx.hir.expect_expr(expr.id);\n+        let hir_node = self.tcx.hir().expect_expr(expr.id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::Error {\n             return None;\n         }\n         match expr.node {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n-                let hir_node = match self.tcx.hir.find(sub_ex.id) {\n+                let hir_node = match self.tcx.hir().find(sub_ex.id) {\n                     Some(Node::Expr(expr)) => expr,\n                     _ => {\n                         debug!(\n@@ -587,7 +587,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(ref seg, ..) => {\n-                let expr_hir_id = self.tcx.hir.definitions().node_to_hir_id(expr.id);\n+                let expr_hir_id = self.tcx.hir().definitions().node_to_hir_id(expr.id);\n                 let method_id = match self.tables.type_dependent_defs().get(expr_hir_id) {\n                     Some(id) => id.def_id(),\n                     None => {\n@@ -622,7 +622,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_def(&self, id: NodeId) -> HirDef {\n-        match self.tcx.hir.get(id) {\n+        match self.tcx.hir().get(id) {\n             Node::TraitRef(tr) => tr.path.def,\n \n             Node::Item(&hir::Item {\n@@ -656,7 +656,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 node: hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             }) => {\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.tables.qpath_def(qpath, hir_id)\n             }\n \n@@ -1183,7 +1183,7 @@ fn id_from_def_id(id: DefId) -> rls_data::Id {\n }\n \n fn id_from_node_id(id: NodeId, scx: &SaveContext) -> rls_data::Id {\n-    let def_id = scx.tcx.hir.opt_local_def_id(id);\n+    let def_id = scx.tcx.hir().opt_local_def_id(id);\n     def_id.map(|id| id_from_def_id(id)).unwrap_or_else(|| {\n         // Create a *fake* `DefId` out of a `NodeId` by subtracting the `NodeId`\n         // out of the maximum u32 value. This will work unless you have *billions*"}, {"sha": "ad034bfff5a328c0bc29c0af02888e190056ca9b", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -228,8 +228,8 @@ crate fn environment<'a, 'tcx>(\n         // could bound lifetimes.\n         .map(Clause::ForAll);\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let node = tcx.hir.get(node_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let node = tcx.hir().get(node_id);\n \n     let mut is_fn = false;\n     let mut is_impl = false;"}, {"sha": "8024ec96db0501917fe05c1f61a17f37bb38a1ca", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -615,7 +615,7 @@ pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n \n     let mut visitor = ClauseDumper { tcx };\n-    tcx.hir\n+    tcx.hir()\n         .krate()\n         .visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n@@ -626,7 +626,7 @@ struct ClauseDumper<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n     fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir.local_def_id(node_id);\n+        let def_id = self.tcx.hir().local_def_id(node_id);\n         for attr in attrs {\n             let mut clauses = None;\n \n@@ -664,7 +664,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ClauseDumper<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {"}, {"sha": "752e0a5fac68bbac9705b6bf2acbc8629aab8963", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -114,10 +114,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| {\n-            tcx.hir.name(tcx.hir.as_local_node_id(def_id).unwrap()).as_interned_str()\n+            tcx.hir().name(tcx.hir().as_local_node_id(def_id).unwrap()).as_interned_str()\n         };\n \n-        let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n+        let hir_id = tcx.hir().node_to_hir_id(lifetime.id);\n         let r = match tcx.named_region(hir_id) {\n             Some(rl::Region::Static) => {\n                 tcx.types.re_static\n@@ -1135,7 +1135,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n+                let hir_id = tcx.hir().node_to_hir_id(lifetime.id);\n                 if tcx.named_region(hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n@@ -1190,8 +1190,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let suitable_bounds = traits::transitive_bounds(tcx, bounds)\n             .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n-        let param_node_id = tcx.hir.as_local_node_id(ty_param_def_id).unwrap();\n-        let param_name = tcx.hir.ty_param_name(param_node_id);\n+        let param_node_id = tcx.hir().as_local_node_id(ty_param_def_id).unwrap();\n+        let param_name = tcx.hir().ty_param_name(param_node_id);\n         self.one_bound_for_assoc_type(suitable_bounds,\n                                       &param_name.as_str(),\n                                       assoc_name,\n@@ -1235,7 +1235,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     item.kind == ty::AssociatedKind::Type &&\n                         self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n                 })\n-                .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n+                .and_then(|item| self.tcx().hir().span_if_local(item.def_id));\n \n                 if let Some(span) = bound_span {\n                     err.span_label(span, format!(\"ambiguous `{}` from `{}`\",\n@@ -1485,12 +1485,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n-                let node_id = tcx.hir.as_local_node_id(did).unwrap();\n-                let item_id = tcx.hir.get_parent_node(node_id);\n-                let item_def_id = tcx.hir.local_def_id(item_id);\n+                let node_id = tcx.hir().as_local_node_id(did).unwrap();\n+                let item_id = tcx.hir().get_parent_node(node_id);\n+                let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&tcx.hir.local_def_id(node_id)];\n-                tcx.mk_ty_param(index, tcx.hir.name(node_id).as_interned_str())\n+                let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n+                tcx.mk_ty_param(index, tcx.hir().name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type)\n@@ -1579,7 +1579,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 self.def_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n-                let did = tcx.hir.local_def_id(item_id.id);\n+                let did = tcx.hir().local_def_id(item_id.id);\n                 self.impl_trait_ty_to_ty(did, lifetimes)\n             },\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n@@ -1594,7 +1594,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length_def_id = tcx.hir.local_def_id(length.id);\n+                let length_def_id = tcx.hir().local_def_id(length.id);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n                 let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));"}, {"sha": "bc9ba0e0054647712dc04ef491595aa56d22466a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -750,7 +750,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             span_err!(tcx.sess, pat.span, E0533,\n                       \"expected unit struct/variant or constant, found {} `{}`\",\n                       def.kind_name(),\n-                      hir::print::to_string(&tcx.hir, |s| s.print_qpath(qpath, false)));\n+                      hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -794,7 +794,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let report_unexpected_def = |def: Def| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n                               def.kind_name(),\n-                              hir::print::to_string(&tcx.hir, |s| s.print_qpath(qpath, false)));\n+                              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, \"not a tuple variant or struct\").emit();\n             on_error();"}, {"sha": "ad4afb0d1a37b001d8eb9cdddc60e9dbea157c4c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -206,15 +206,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n             ty::FnDef(def_id, _) => {\n-                (callee_ty.fn_sig(self.tcx), self.tcx.hir.span_if_local(def_id))\n+                (callee_ty.fn_sig(self.tcx), self.tcx.hir().span_if_local(def_id))\n             }\n             ty::FnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n                 if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n-                            unit_variant = Some(self.tcx.hir.node_to_pretty_string(expr.id))\n+                            unit_variant = Some(self.tcx.hir().node_to_pretty_string(expr.id))\n                         }\n                     }\n                 }\n@@ -278,9 +278,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let def_span = match def {\n                         Def::Err => None,\n                         Def::Local(id) | Def::Upvar(id, ..) => {\n-                            Some(self.tcx.hir.span(id))\n+                            Some(self.tcx.hir().span(id))\n                         }\n-                        _ => self.tcx.hir.span_if_local(def.def_id())\n+                        _ => self.tcx.hir().span_if_local(def.def_id())\n                     };\n                     if let Some(span) = def_span {\n                         let label = match (unit_variant, inner_callee_path) {"}, {"sha": "629a31a7e1f85a80ca121252164a65910d4f7d64", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n             None => (None, None),\n         };\n-        let body = self.tcx.hir.body(body_id);\n+        let body = self.tcx.hir().body(body_id);\n         self.check_closure(expr, expected_kind, decl, body, gen, expected_sig)\n     }\n \n@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             opt_kind, expected_sig\n         );\n \n-        let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n+        let expr_def_id = self.tcx.hir().local_def_id(expr.id);\n \n         let ClosureSignatures {\n             bound_sig,\n@@ -496,7 +496,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         body: &hir::Body,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let expr_map_node = self.tcx.hir.get_if_local(expr_def_id).unwrap();\n+        let expr_map_node = self.tcx.hir().get_if_local(expr_def_id).unwrap();\n         let expected_args: Vec<_> = expected_sig\n             .sig\n             .inputs()"}, {"sha": "f7072a6395b8c089cb982130f3da83a1e6a5eb80", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -696,7 +696,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let b = self.shallow_resolve(b);\n \n-        let node_id_a = self.tcx.hir.as_local_node_id(def_id_a).unwrap();\n+        let node_id_a = self.tcx.hir().as_local_node_id(def_id_a).unwrap();\n         match b.sty {\n             ty::FnPtr(_) if self.tcx.with_freevars(node_id_a, |v| v.is_empty()) => {\n                 // We coerce the closure, which has fn type"}, {"sha": "a8291b5ddb15c64d99617c7f47c8db989514b429", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -93,7 +93,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // This node-id should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n+    let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n \n     let cause = ObligationCause {\n         span: impl_m_span,\n@@ -391,7 +391,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // the moment, give a kind of vague error message.\n     if trait_params != impl_params {\n         let def_span = tcx.sess.source_map().def_span(span);\n-        let span = tcx.hir.get_generics_span(impl_m.def_id).unwrap_or(def_span);\n+        let span = tcx.hir().get_generics_span(impl_m.def_id).unwrap_or(def_span);\n         let mut err = struct_span_err!(\n             tcx.sess,\n             span,\n@@ -400,9 +400,9 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             impl_m.ident,\n         );\n         err.span_label(span, \"lifetimes do not match method in trait\");\n-        if let Some(sp) = tcx.hir.span_if_local(trait_m.def_id) {\n+        if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n             let def_sp = tcx.sess.source_map().def_span(sp);\n-            let sp = tcx.hir.get_generics_span(trait_m.def_id).unwrap_or(def_sp);\n+            let sp = tcx.hir().get_generics_span(trait_m.def_id).unwrap_or(def_sp);\n             err.span_label(sp, \"lifetimes in impl do not match this method in trait\");\n         }\n         err.emit();\n@@ -422,8 +422,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                                                      trait_sig: ty::FnSig<'tcx>)\n                                                      -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n-    let (impl_m_output, impl_m_iter) = match tcx.hir.expect_impl_item(impl_m_node_id).node {\n+    let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n+    let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_node_id).node {\n         ImplItemKind::Method(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n         }\n@@ -432,8 +432,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n \n     match *terr {\n         TypeError::Mutability => {\n-            if let Some(trait_m_node_id) = tcx.hir.as_local_node_id(trait_m.def_id) {\n-                let trait_m_iter = match tcx.hir.expect_trait_item(trait_m_node_id).node {\n+            if let Some(trait_m_node_id) = tcx.hir().as_local_node_id(trait_m.def_id) {\n+                let trait_m_iter = match tcx.hir().expect_trait_item(trait_m_node_id).node {\n                     TraitItemKind::Method(ref trait_m_sig, _) => {\n                         trait_m_sig.decl.inputs.iter()\n                     }\n@@ -451,15 +451,15 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                 }).map(|(ref impl_arg, ref trait_arg)| {\n                     (impl_arg.span, Some(trait_arg.span))\n                 })\n-                .unwrap_or_else(|| (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id)))\n+                .unwrap_or_else(|| (cause.span(&tcx), tcx.hir().span_if_local(trait_m.def_id)))\n             } else {\n-                (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id))\n+                (cause.span(&tcx), tcx.hir().span_if_local(trait_m.def_id))\n             }\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n-            if let Some(trait_m_node_id) = tcx.hir.as_local_node_id(trait_m.def_id) {\n+            if let Some(trait_m_node_id) = tcx.hir().as_local_node_id(trait_m.def_id) {\n                 let (trait_m_output, trait_m_iter) =\n-                    match tcx.hir.expect_trait_item(trait_m_node_id).node {\n+                    match tcx.hir().expect_trait_item(trait_m_node_id).node {\n                         TraitItemKind::Method(ref trait_m_sig, _) => {\n                             (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n                         }\n@@ -486,14 +486,14 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                              {\n                                  (impl_m_output.span(), Some(trait_m_output.span()))\n                              } else {\n-                                 (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id))\n+                                 (cause.span(&tcx), tcx.hir().span_if_local(trait_m.def_id))\n                              }\n                          )\n             } else {\n-                (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id))\n+                (cause.span(&tcx), tcx.hir().span_if_local(trait_m.def_id))\n             }\n         }\n-        _ => (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id)),\n+        _ => (cause.span(&tcx), tcx.hir().span_if_local(trait_m.def_id)),\n     }\n }\n \n@@ -548,7 +548,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            trait_m.ident,\n                                            self_descr);\n             err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n-            if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n+            if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"trait method declared without `{}`\", self_descr));\n             } else {\n                 err.note_trait_signature(trait_m.ident.to_string(),\n@@ -568,7 +568,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            trait_m.ident,\n                                            self_descr);\n             err.span_label(impl_m_span, format!(\"expected `{}` in impl\", self_descr));\n-            if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n+            if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n             } else {\n                 err.note_trait_signature(trait_m.ident.to_string(),\n@@ -594,8 +594,8 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let num_trait_m_type_params = trait_m_generics.own_counts().types;\n \n     if num_impl_m_type_params != num_trait_m_type_params {\n-        let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n-        let impl_m_item = tcx.hir.expect_impl_item(impl_m_node_id);\n+        let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n+        let impl_m_item = tcx.hir().expect_impl_item(impl_m_node_id);\n         let span = if impl_m_item.generics.params.is_empty()\n             || impl_m_item.generics.span.is_dummy()  // impl Trait in argument position (#55374)\n         {\n@@ -644,9 +644,9 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n-        let trait_m_node_id = tcx.hir.as_local_node_id(trait_m.def_id);\n+        let trait_m_node_id = tcx.hir().as_local_node_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n-            match tcx.hir.expect_trait_item(trait_id).node {\n+            match tcx.hir().expect_trait_item(trait_id).node {\n                 TraitItemKind::Method(ref trait_m_sig, _) => {\n                     if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n                         trait_number_args - 1\n@@ -663,8 +663,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         } else {\n             trait_item_span\n         };\n-        let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n-        let impl_span = match tcx.hir.expect_impl_item(impl_m_node_id).node {\n+        let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n+        let impl_span = match tcx.hir().expect_impl_item(impl_m_node_id).node {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n                 if let Some(arg) = impl_m_sig.decl.inputs.get(if impl_number_args > 0 {\n                     impl_number_args - 1\n@@ -729,8 +729,8 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in impl_m_type_params.zip(trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n-            let impl_node_id = tcx.hir.as_local_node_id(impl_def_id).unwrap();\n-            let impl_span = tcx.hir.span(impl_node_id);\n+            let impl_node_id = tcx.hir().as_local_node_id(impl_def_id).unwrap();\n+            let impl_span = tcx.hir().span(impl_node_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_span,\n@@ -752,11 +752,11 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             .source_map()\n                             .span_to_snippet(trait_span)\n                             .ok()?;\n-                        let trait_m = tcx.hir.as_local_node_id(trait_m.def_id)?;\n-                        let trait_m = tcx.hir.trait_item(hir::TraitItemId { node_id: trait_m });\n+                        let trait_m = tcx.hir().as_local_node_id(trait_m.def_id)?;\n+                        let trait_m = tcx.hir().trait_item(hir::TraitItemId { node_id: trait_m });\n \n-                        let impl_m = tcx.hir.as_local_node_id(impl_m.def_id)?;\n-                        let impl_m = tcx.hir.impl_item(hir::ImplItemId { node_id: impl_m });\n+                        let impl_m = tcx.hir().as_local_node_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { node_id: impl_m });\n \n                         // in case there are no generics, take the spot between the function name\n                         // and the opening paren of the argument list\n@@ -797,8 +797,8 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n-                        let impl_m = tcx.hir.as_local_node_id(impl_m.def_id)?;\n-                        let impl_m = tcx.hir.impl_item(hir::ImplItemId { node_id: impl_m });\n+                        let impl_m = tcx.hir().as_local_node_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { node_id: impl_m });\n                         let input_tys = match impl_m.node {\n                             hir::ImplItemKind::Method(ref sig, _) => &sig.decl.inputs,\n                             _ => unreachable!(),\n@@ -895,7 +895,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_node_id = tcx.hir.as_local_node_id(impl_c.def_id).unwrap();\n+        let impl_c_node_id = tcx.hir().as_local_node_id(impl_c.def_id).unwrap();\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n@@ -927,7 +927,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    trait_ty);\n \n             // Locate the Span containing just the type of the offending impl\n-            match tcx.hir.expect_impl_item(impl_c_node_id).node {\n+            match tcx.hir().expect_impl_item(impl_c_node_id).node {\n                 ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n                 _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n@@ -939,10 +939,10 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trait\",\n                                             trait_c.ident);\n \n-            let trait_c_node_id = tcx.hir.as_local_node_id(trait_c.def_id);\n+            let trait_c_node_id = tcx.hir().as_local_node_id(trait_c.def_id);\n             let trait_c_span = trait_c_node_id.map(|trait_c_node_id| {\n                 // Add a label to the Span containing just the type of the const\n-                match tcx.hir.expect_trait_item(trait_c_node_id).node {\n+                match tcx.hir().expect_trait_item(trait_c_node_id).node {\n                     TraitItemKind::Const(ref ty, _) => ty.span,\n                     _ => bug!(\"{:?} is not a trait const\", trait_c),\n                 }"}, {"sha": "fb83d169d39a55d53697eb214043a8b93b48e603", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -203,17 +203,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn can_use_as_ref(&self, expr: &hir::Expr) -> Option<(Span, &'static str, String)> {\n         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Def::Local(id) = path.def {\n-                let parent = self.tcx.hir.get_parent_node(id);\n+                let parent = self.tcx.hir().get_parent_node(id);\n                 if let Some(Node::Expr(hir::Expr {\n                     id,\n                     node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n-                })) = self.tcx.hir.find(parent) {\n-                    let parent = self.tcx.hir.get_parent_node(*id);\n+                })) = self.tcx.hir().find(parent) {\n+                    let parent = self.tcx.hir().get_parent_node(*id);\n                     if let (Some(Node::Expr(hir::Expr {\n                         node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n-                    })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n+                    })), 1) = (self.tcx.hir().find(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_id_to_type(expr[0].hir_id);\n                         let self_ty = format!(\"{:?}\", self_ty);\n                         let name = path.ident.as_str();\n@@ -450,8 +450,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       checked_ty: Ty<'tcx>,\n                       expected_ty: Ty<'tcx>)\n                       -> bool {\n-        let parent_id = self.tcx.hir.get_parent_node(expr.id);\n-        if let Some(parent) = self.tcx.hir.find(parent_id) {\n+        let parent_id = self.tcx.hir().get_parent_node(expr.id);\n+        if let Some(parent) = self.tcx.hir().find(parent_id) {\n             // Shouldn't suggest `.into()` on `const`s.\n             if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                 // FIXME(estebank): modify once we decide to suggest `as` casts"}, {"sha": "aae99addfcd769e713c1313dc5a2ac1dd088bd49", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -80,7 +80,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n ) -> Result<(), ErrorReported> {\n-    let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n+    let drop_impl_node_id = tcx.hir().as_local_node_id(drop_impl_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n@@ -194,7 +194,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n+    let self_type_node_id = tcx.hir().as_local_node_id(self_type_did).unwrap();\n \n     let drop_impl_span = tcx.def_span(drop_impl_did);\n \n@@ -226,7 +226,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n         // repeated `contains` calls.\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n-            let item_span = tcx.hir.span(self_type_node_id);\n+            let item_span = tcx.hir().span(self_type_node_id);\n             struct_span_err!(\n                 tcx.sess,\n                 drop_impl_span,"}, {"sha": "55fceda1a51513dcf0375920f69ff6c057522930", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -86,7 +86,7 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                                         def_id: DefId,\n                                         body_id: hir::BodyId,\n                                         interior: Ty<'tcx>) {\n-    let body = fcx.tcx.hir.body(body_id);\n+    let body = fcx.tcx.hir().body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap::default(),"}, {"sha": "b1382057c5262fc221d19cca4356e37fe6e72fc0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -36,7 +36,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n     inputs: Vec<Ty<'tcx>>,\n     output: Ty<'tcx>,\n ) {\n-    let def_id = tcx.hir.local_def_id(it.id);\n+    let def_id = tcx.hir().local_def_id(it.id);\n \n     match it.node {\n         hir::ForeignItemKind::Fn(..) => {}\n@@ -401,7 +401,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.mk_ty_param(n, name)\n     };\n \n-    let def_id = tcx.hir.local_def_id(it.id);\n+    let def_id = tcx.hir().local_def_id(it.id);\n     let i_n_tps = tcx.generics_of(def_id).own_counts().types;\n     let name = it.name.as_str();\n "}, {"sha": "209ad45ff34f6d5a4d87c4284bfe8c3050d4e1cf", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         )?;\n \n         if let Some(import_id) = pick.import_id {\n-            let import_def_id = self.tcx.hir.local_def_id(import_id);\n+            let import_def_id = self.tcx.hir().local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                                         .unwrap().insert(import_def_id);\n@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        self_ty, expr_id, ProbeScope::TraitsInScope)?;\n \n         if let Some(import_id) = pick.import_id {\n-            let import_def_id = self.tcx.hir.local_def_id(import_id);\n+            let import_def_id = self.tcx.hir().local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                                         .unwrap().insert(import_def_id);"}, {"sha": "c794910e6ef9cb7da76f98dfeb60456cb782c9d6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -720,7 +720,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return Ok(())\n         }\n         let mut duplicates = FxHashSet::default();\n-        let expr_hir_id = self.tcx.hir.node_to_hir_id(expr_id);\n+        let expr_hir_id = self.tcx.hir().node_to_hir_id(expr_id);\n         let opt_applicable_traits = self.tcx.in_scope_traits(expr_hir_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits.iter() {"}, {"sha": "ab7e71a2870a1e410c21ef095b68da1085c78c8a", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -107,8 +107,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     Namespace::Value,\n                                 )\n                             }).unwrap();\n-                        let note_span = self.tcx.hir.span_if_local(item.def_id).or_else(|| {\n-                            self.tcx.hir.span_if_local(impl_did)\n+                        let note_span = self.tcx.hir().span_if_local(item.def_id).or_else(|| {\n+                            self.tcx.hir().span_if_local(impl_did)\n                         });\n \n                         let impl_ty = self.impl_self_ty(span, impl_did).ty;\n@@ -265,13 +265,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::ExprKind::Path(ref qpath) => {  // local binding\n                                 if let &hir::QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n-                                        let span = tcx.hir.span(node_id);\n+                                        let span = tcx.hir().span(node_id);\n                                         let snippet = tcx.sess.source_map().span_to_snippet(span)\n                                             .unwrap();\n                                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n-                                        let parent_node = self.tcx.hir.get(\n-                                            self.tcx.hir.get_parent_node(node_id),\n+                                        let parent_node = self.tcx.hir().get(\n+                                            self.tcx.hir().get_parent_node(node_id),\n                                         );\n                                         let msg = format!(\n                                             \"you must specify a type for this binding, like `{}`\",\n@@ -325,7 +325,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 if let Some(def) = actual.ty_adt_def() {\n-                    if let Some(full_sp) = tcx.hir.span_if_local(def.did) {\n+                    if let Some(full_sp) = tcx.hir().span_if_local(def.did) {\n                         let def_sp = tcx.sess.source_map().def_span(full_sp);\n                         err.span_label(def_sp, format!(\"{} `{}` not found {}\",\n                                                        item_kind,\n@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     };\n \n                                     let field_ty = field.ty(tcx, substs);\n-                                    let scope = self.tcx.hir.get_module_parent(self.body_id);\n+                                    let scope = self.tcx.hir().get_module_parent(self.body_id);\n                                     if field.vis.is_accessible_from(scope, self.tcx) {\n                                         if self.is_fn_ty(&field_ty, span) {\n                                             err.help(&format!(\"use `({0}.{1})(...)` if you \\\n@@ -503,9 +503,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               err: &mut DiagnosticBuilder,\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n-        let module_did = self.tcx.hir.get_module_parent(self.body_id);\n-        let module_id = self.tcx.hir.as_local_node_id(module_did).unwrap();\n-        let krate = self.tcx.hir.krate();\n+        let module_did = self.tcx.hir().get_module_parent(self.body_id);\n+        let module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n+        let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {\n             let path_strings = candidates.iter().map(|did| {\n@@ -744,8 +744,8 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n             fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n             }\n         }\n-        tcx.hir.krate().visit_all_item_likes(&mut Visitor {\n-            map: &tcx.hir,\n+        tcx.hir().krate().visit_all_item_likes(&mut Visitor {\n+            map: &tcx.hir(),\n             traits: &mut traits,\n         });\n \n@@ -829,7 +829,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n         }\n         // find a use statement\n         for item_id in &module.item_ids {\n-            let item = self.tcx.hir.expect_item(item_id.id);\n+            let item = self.tcx.hir().expect_item(item_id.id);\n             match item.node {\n                 hir::ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude"}, {"sha": "01fb52bd8ac2c65d18b50f7adb9d5e65f2a99488", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -605,8 +605,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let hir_id_root = if def_id.is_local() {\n-            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let hir_id = tcx.hir.definitions().node_to_hir_id(node_id);\n+            let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+            let hir_id = tcx.hir().definitions().node_to_hir_id(node_id);\n             DefId::local(hir_id.owner)\n         } else {\n             def_id\n@@ -631,10 +631,10 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> Self {\n         let tcx = infcx.tcx;\n-        let item_id = tcx.hir.as_local_node_id(def_id);\n-        let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n+        let item_id = tcx.hir().as_local_node_id(def_id);\n+        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by(id));\n         let implicit_region_bound = body_id.map(|body_id| {\n-            let body = tcx.hir.body(body_id);\n+            let body = tcx.hir().body(body_id);\n             tcx.mk_region(ty::ReScope(region::Scope {\n                 id: body.value.hir_id.local_id,\n                 data: region::ScopeData::CallSite\n@@ -707,13 +707,13 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n-        tcx.hir.krate().visit_all_item_likes(&mut visit.as_deep_visitor());\n+        tcx.hir().krate().visit_all_item_likes(&mut visit.as_deep_visitor());\n     })\n }\n \n pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n-        tcx.hir.krate().visit_all_item_likes(&mut CheckItemTypesVisitor { tcx });\n+        tcx.hir().krate().visit_all_item_likes(&mut CheckItemTypesVisitor { tcx });\n     })\n }\n \n@@ -778,7 +778,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              id: ast::NodeId)\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n-    match tcx.hir.get(id) {\n+    match tcx.hir().get(id) {\n         Node::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n@@ -825,7 +825,7 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return tcx.has_typeck_tables(outer_def_id);\n     }\n \n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n     primary_body_of(tcx, id).is_some()\n }\n \n@@ -845,14 +845,14 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return tcx.typeck_tables_of(outer_def_id);\n     }\n \n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let span = tcx.hir.span(id);\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n     let (body_id, fn_decl) = primary_body_of(tcx, id).unwrap_or_else(|| {\n         span_bug!(span, \"can't type-check body of {:?}\", def_id);\n     });\n-    let body = tcx.hir.body(body_id);\n+    let body = tcx.hir().body(body_id);\n \n     let tables = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n@@ -930,7 +930,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n     assert_eq!(tables.local_id_root,\n-               Some(DefId::local(tcx.hir.definitions().node_to_hir_id(id).owner)));\n+               Some(DefId::local(tcx.hir().definitions().node_to_hir_id(id).owner)));\n     tables\n }\n \n@@ -1087,8 +1087,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir.local_def_id(fn_id));\n-    let outer_node_id = fcx.tcx.hir.as_local_node_id(outer_def_id).unwrap();\n+    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id(fn_id));\n+    let outer_node_id = fcx.tcx.hir().as_local_node_id(outer_def_id).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_node_id, }.visit_body(body);\n \n     // Add formal parameters.\n@@ -1108,7 +1108,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.write_ty(arg.hir_id, arg_ty);\n     }\n \n-    let fn_hir_id = fcx.tcx.hir.node_to_hir_id(fn_id);\n+    let fn_hir_id = fcx.tcx.hir().node_to_hir_id(fn_id);\n     inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n@@ -1180,7 +1180,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n-        if panic_impl_did == fcx.tcx.hir.local_def_id(fn_id) {\n+        if panic_impl_did == fcx.tcx.hir().local_def_id(fn_id) {\n             if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n                 // at this point we don't care if there are duplicate handlers or if the handler has\n                 // the wrong signature as this value we'll be used when writing metadata and that\n@@ -1195,7 +1195,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir.span(fn_id);\n+                let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].sty {\n                         ty::Ref(region, ty, mutbl) => match ty.sty {\n@@ -1216,7 +1216,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1238,7 +1238,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n-        if alloc_error_handler_did == fcx.tcx.hir.local_def_id(fn_id) {\n+        if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n             if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n@@ -1248,7 +1248,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir.span(fn_id);\n+                let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].sty {\n                         ty::Adt(ref adt, _) => {\n@@ -1264,7 +1264,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1291,7 +1291,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           id: ast::NodeId,\n                           span: Span) {\n-    let def_id = tcx.hir.local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -1307,7 +1307,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          id: ast::NodeId,\n                          span: Span) {\n-    let def_id = tcx.hir.local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -1319,26 +1319,26 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n     debug!(\n         \"check_item_type(it.id={}, it.name={})\",\n         it.id,\n-        tcx.item_path_str(tcx.hir.local_def_id(it.id))\n+        tcx.item_path_str(tcx.hir().local_def_id(it.id))\n     );\n     let _indenter = indenter();\n     match it.node {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n-            let def_id = tcx.hir.local_def_id(it.id);\n+            let def_id = tcx.hir().local_def_id(it.id);\n             tcx.typeck_tables_of(def_id);\n             maybe_check_static_with_link_section(tcx, def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n-            tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n+            tcx.typeck_tables_of(tcx.hir().local_def_id(it.id));\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n             check_enum(tcx, it.span, &enum_definition.variants, it.id);\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n-            let impl_def_id = tcx.hir.local_def_id(it.id);\n+            let impl_def_id = tcx.hir().local_def_id(it.id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n@@ -1352,7 +1352,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n             }\n         }\n         hir::ItemKind::Trait(..) => {\n-            let def_id = tcx.hir.local_def_id(it.id);\n+            let def_id = tcx.hir().local_def_id(it.id);\n             check_on_unimplemented(tcx, def_id, it);\n         }\n         hir::ItemKind::Struct(..) => {\n@@ -1362,7 +1362,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n             check_union(tcx, it.id, it.span);\n         }\n         hir::ItemKind::Existential(..) | hir::ItemKind::Ty(..) => {\n-            let def_id = tcx.hir.local_def_id(it.id);\n+            let def_id = tcx.hir().local_def_id(it.id);\n             let pty_ty = tcx.type_of(def_id);\n             let generics = tcx.generics_of(def_id);\n             check_bounds_are_used(tcx, &generics, pty_ty);\n@@ -1380,7 +1380,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n                 }\n             } else {\n                 for item in &m.items {\n-                    let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n+                    let generics = tcx.generics_of(tcx.hir().local_def_id(item.id));\n                     if generics.params.len() - generics.own_counts().lifetimes != 0 {\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n@@ -1449,7 +1449,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     trait_def_id: DefId,\n                                     item: &hir::Item) {\n-    let item_def_id = tcx.hir.local_def_id(item.id);\n+    let item_def_id = tcx.hir().local_def_id(item.id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n@@ -1522,12 +1522,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n-    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir.impl_item(iiref.id));\n+    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items() {\n-        let ty_impl_item = tcx.associated_item(tcx.hir.local_def_id(impl_item.id));\n+        let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| Namespace::from(&impl_item.node) == Namespace::from(ac.kind) &&\n                        tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n@@ -1557,14 +1557,14 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n-                         if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Method(..) => {\n-                    let trait_span = tcx.hir.span_if_local(ty_trait_item.def_id);\n+                    let trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         compare_impl_method(tcx,\n                                             &ty_impl_item,\n@@ -1579,7 +1579,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty_impl_item.ident,\n                             impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n-                         if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n@@ -1598,7 +1598,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty_impl_item.ident,\n                             impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n-                         if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n@@ -1641,7 +1641,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     .map(|trait_item| trait_item.ident.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n-            if let Some(span) = tcx.hir.span_if_local(trait_item.def_id) {\n+            if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n                 err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n             } else {\n                 err.note_trait_signature(trait_item.ident.to_string(),\n@@ -1786,7 +1786,7 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n         let param_env = tcx.param_env(field.did);\n         let layout = tcx.layout_of(param_env.and(ty));\n         // We are currently checking the type this field came from, so it must be local\n-        let span = tcx.hir.span_if_local(field.did).unwrap();\n+        let span = tcx.hir().span_if_local(field.did).unwrap();\n         let zst = layout.map(|layout| layout.is_zst()).unwrap_or(false);\n         let align1 = layout.map(|layout| layout.align.abi.bytes() == 1).unwrap_or(false);\n         (span, zst, align1)\n@@ -1815,7 +1815,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             sp: Span,\n                             vs: &'tcx [hir::Variant],\n                             id: ast::NodeId) {\n-    let def_id = tcx.hir.local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n@@ -1843,7 +1843,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for v in vs {\n         if let Some(ref e) = v.node.disr_expr {\n-            tcx.typeck_tables_of(tcx.hir.local_def_id(e.id));\n+            tcx.typeck_tables_of(tcx.hir().local_def_id(e.id));\n         }\n     }\n \n@@ -1852,14 +1852,14 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_did = def.variants[VariantIdx::new(i)].did;\n-            let variant_i_node_id = tcx.hir.as_local_node_id(variant_did).unwrap();\n-            let variant_i = tcx.hir.expect_variant(variant_i_node_id);\n+            let variant_i_node_id = tcx.hir().as_local_node_id(variant_did).unwrap();\n+            let variant_i = tcx.hir().expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(ref expr) => tcx.hir.span(expr.id),\n-                None => tcx.hir.span(variant_i_node_id)\n+                Some(ref expr) => tcx.hir().span(expr.id),\n+                None => tcx.hir().span(variant_i_node_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(ref expr) => tcx.hir.span(expr.id),\n+                Some(ref expr) => tcx.hir().span(expr.id),\n                 None => v.span\n             };\n             struct_span_err!(tcx.sess, span, E0081,\n@@ -1881,9 +1881,9 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                  -> Lrc<ty::GenericPredicates<'tcx>>\n     {\n         let tcx = self.tcx;\n-        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let item_id = tcx.hir.ty_param_owner(node_id);\n-        let item_def_id = tcx.hir.local_def_id(item_id);\n+        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let item_id = tcx.hir().ty_param_owner(node_id);\n+        let item_def_id = tcx.hir().local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n         let index = generics.param_def_id_to_index[&def_id];\n         Lrc::new(ty::GenericPredicates {\n@@ -2089,7 +2089,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> LocalTy<'tcx> {\n         self.locals.borrow().get(&nid).cloned().unwrap_or_else(||\n             span_bug!(span, \"no type for local variable {}\",\n-                      self.tcx.hir.node_to_string(nid))\n+                      self.tcx.hir().node_to_string(nid))\n         )\n     }\n \n@@ -2106,7 +2106,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn write_field_index(&self, node_id: ast::NodeId, index: usize) {\n-        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n         self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n@@ -2294,7 +2294,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         parent_id: ast::NodeId,\n         value: &T,\n     ) -> T {\n-        let parent_def_id = self.tcx.hir.local_def_id(parent_id);\n+        let parent_def_id = self.tcx.hir().local_def_id(parent_id);\n         debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n                parent_def_id,\n                value);\n@@ -2400,9 +2400,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(&t) => t,\n             None if self.is_tainted_by_errors() => self.tcx.types.err,\n             None => {\n-                let node_id = self.tcx.hir.hir_to_node_id(id);\n+                let node_id = self.tcx.hir().hir_to_node_id(id);\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     node_id, self.tcx.hir.node_to_string(node_id),\n+                     node_id, self.tcx.hir().node_to_string(node_id),\n                      self.tag());\n             }\n         }\n@@ -2730,7 +2730,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n         self.check_argument_types(sp, expr_sp, &method.sig.inputs()[1..], &expected_arg_tys[..],\n                                   args_no_rcvr, method.sig.variadic, tuple_arguments,\n-                                  self.tcx.hir.span_if_local(method.def_id));\n+                                  self.tcx.hir().span_if_local(method.def_id));\n         method.sig.output()\n     }\n \n@@ -3375,7 +3375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             len.assert_usize(self.tcx),\n                             field.as_str().parse::<u64>()\n                         ) {\n-                            let base = self.tcx.hir.node_to_pretty_string(base.id);\n+                            let base = self.tcx.hir().node_to_pretty_string(base.id);\n                             let help = \"instead of using tuple indexing, use array indexing\";\n                             let suggestion = format!(\"{}[{}]\", base, field);\n                             let applicability = if len < user_index {\n@@ -3389,7 +3389,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     ty::RawPtr(..) => {\n-                        let base = self.tcx.hir.node_to_pretty_string(base.id);\n+                        let base = self.tcx.hir().node_to_pretty_string(base.id);\n                         let msg = format!(\"`{}` is a native pointer; try dereferencing it\", base);\n                         let suggestion = format!(\"(*{}).{}\", base, field);\n                         err.span_suggestion_with_applicability(\n@@ -3665,7 +3665,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n-            let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+            let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n             self.write_user_substs_from_substs(hir_id, substs, None);\n \n             // Check bounds on type arguments used in the path.\n@@ -3796,7 +3796,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of {} is...\", self.tcx.hir.node_to_string(expr.id));\n+        debug!(\"type of {} is...\", self.tcx.hir().node_to_string(expr.id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         ty\n@@ -4267,7 +4267,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_array(element_ty, args.len() as u64)\n             }\n             hir::ExprKind::Repeat(ref element, ref count) => {\n-                let count_def_id = tcx.hir.local_def_id(count.id);\n+                let count_def_id = tcx.hir().local_def_id(count.id);\n                 let param_env = ty::ParamEnv::empty();\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n                 let instance = ty::Instance::resolve(\n@@ -4450,7 +4450,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    ty, def, segment);\n \n                 // Write back the new resolution.\n-                let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                 self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n \n                 (def, ty)\n@@ -4476,7 +4476,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (self.to_ty(qself), segment)\n             }\n         };\n-        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n         if let Some(cached_def) = self.tables.borrow().type_dependent_defs().get(hir_id) {\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n@@ -4717,8 +4717,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn get_fn_decl(&self, blk_id: ast::NodeId) -> Option<(hir::FnDecl, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n-        if let Some(fn_id) = self.tcx.hir.get_return_block(blk_id) {\n-            let parent = self.tcx.hir.get(fn_id);\n+        if let Some(fn_id) = self.tcx.hir().get_return_block(blk_id) {\n+            let parent = self.tcx.hir().get(fn_id);\n \n             if let Node::Item(&hir::Item {\n                 name, node: hir::ItemKind::Fn(ref decl, ..), ..\n@@ -5109,7 +5109,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n                 let ty = self.local_ty(span, nid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(self.tcx.hir.node_to_hir_id(node_id), ty);\n+                self.write_ty(self.tcx.hir().node_to_hir_id(node_id), ty);\n                 return (ty, def);\n             }\n             _ => {}\n@@ -5237,7 +5237,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!ty.has_escaping_bound_vars());\n \n         // Write the \"user substs\" down first thing for later.\n-        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n         self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n@@ -5292,7 +5292,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n-        if let Node::Expr(expr) = self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n+        if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(node_id)) {\n             if let hir::ExprKind::Call(ref callee, ..) = expr.node {\n                 if callee.id == node_id {\n                     return\n@@ -5373,8 +5373,8 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n     for (&used, param) in types_used.iter().zip(types) {\n         if !used {\n-            let id = tcx.hir.as_local_node_id(param.def_id).unwrap();\n-            let span = tcx.hir.span(id);\n+            let id = tcx.hir().as_local_node_id(param.def_id).unwrap();\n+            let span = tcx.hir().span(id);\n             struct_span_err!(tcx.sess, span, E0091, \"type parameter `{}` is unused\", param.name)\n                 .span_label(span, \"unused type parameter\")\n                 .emit();"}, {"sha": "7960d743de5e487b443bca7b004c0996ec2f8557", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -121,7 +121,7 @@ macro_rules! ignore_err {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n-        let subject = self.tcx.hir.body_owner_def_id(body.id());\n+        let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let id = body.value.id;\n         let mut rcx = RegionCtxt::new(\n             self,\n@@ -150,7 +150,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// types from which we should derive implied bounds, if any.\n     pub fn regionck_item(&self, item_id: ast::NodeId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n-        let subject = self.tcx.hir.local_def_id(item_id);\n+        let subject = self.tcx.hir().local_def_id(item_id);\n         let mut rcx = RegionCtxt::new(\n             self,\n             RepeatingScope(item_id),\n@@ -175,7 +175,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// constraints to add.\n     pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let subject = self.tcx.hir.body_owner_def_id(body.id());\n+        let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let node_id = body.value.id;\n         let mut rcx = RegionCtxt::new(\n             self,\n@@ -187,7 +187,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body, self.tcx.hir.span(fn_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n         }\n \n         rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n@@ -328,7 +328,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.call_site_scope = Some(call_site);\n \n         let fn_sig = {\n-            let fn_hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let fn_hir_id = self.tcx.hir().node_to_hir_id(id);\n             match self.tables.borrow().liberated_fn_sigs().get(fn_hir_id) {\n                 Some(f) => f.clone(),\n                 None => {\n@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         );\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n \n-        let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n+        let body_hir_id = self.tcx.hir().node_to_hir_id(body_id.node_id);\n         self.type_of_node_must_outlive(infer::CallReturn(span), body_hir_id, call_site_region);\n \n         self.constrain_opaque_types(\n@@ -483,7 +483,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let old_call_site_scope = self.call_site_scope;\n         let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n-        let body = self.tcx.hir.body(body_id);\n+        let body = self.tcx.hir().body(body_id);\n         self.visit_fn_body(id, body, span);\n \n         // Restore state from previous function."}, {"sha": "562022cefa806e8797130ce53157e47044ac77a9", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.node {\n-            let body = self.fcx.tcx.hir.body(body_id);\n+            let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);\n             self.fcx\n                 .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n@@ -135,7 +135,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for freevar in freevars {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath {\n-                        hir_id : self.tcx.hir.node_to_hir_id(freevar.var_id()),\n+                        hir_id : self.tcx.hir().node_to_hir_id(freevar.var_id()),\n                     },\n                     closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                 };\n@@ -161,7 +161,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        let body_owner_def_id = self.tcx.hir.body_owner_def_id(body.id());\n+        let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n         let region_scope_tree = &self.tcx.region_scope_tree(body_owner_def_id);\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n@@ -240,14 +240,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n-        let closure_def_index = tcx.hir.local_def_id(closure_id);\n+        let closure_def_index = tcx.hir().local_def_id(closure_id);\n \n         tcx.with_freevars(closure_id, |freevars| {\n             freevars\n                 .iter()\n                 .map(|freevar| {\n                     let var_node_id = freevar.var_id();\n-                    let var_hir_id = tcx.hir.node_to_hir_id(var_node_id);\n+                    let var_hir_id = tcx.hir().node_to_hir_id(var_node_id);\n                     let freevar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n                         var_path: ty::UpvarPath {\n@@ -647,6 +647,6 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n }\n \n fn var_name(tcx: TyCtxt, var_hir_id: hir::HirId) -> ast::Name {\n-    let var_node_id = tcx.hir.hir_to_node_id(var_hir_id);\n-    tcx.hir.name(var_node_id)\n+    let var_node_id = tcx.hir().hir_to_node_id(var_hir_id);\n+    tcx.hir().name(var_node_id)\n }"}, {"sha": "6471e745aa6fd50dbf6414d7254813ea4424db50", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -73,8 +73,8 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let item = tcx.hir.expect_item(node_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(node_id);\n \n     debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n            item.id,\n@@ -99,7 +99,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n         hir::ItemKind::Impl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n-            let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n+            let is_auto = tcx.impl_trait_ref(tcx.hir().local_def_id(item.id))\n                                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n                 tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n@@ -161,8 +161,8 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n }\n \n pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let trait_item = tcx.hir.expect_trait_item(node_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let trait_item = tcx.hir().expect_trait_item(node_id);\n \n     let method_sig = match trait_item.node {\n         hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n@@ -172,8 +172,8 @@ pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n }\n \n pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let impl_item = tcx.hir.expect_impl_item(node_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let impl_item = tcx.hir().expect_impl_item(node_id);\n \n     let method_sig = match impl_item.node {\n         hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n@@ -190,7 +190,7 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n-        let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n+        let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n             ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n@@ -236,7 +236,7 @@ fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n \n fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n                           -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-    let def_id = tcx.hir.local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n         id,\n@@ -252,7 +252,7 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n         let variants = lookup_fields(fcx);\n-        let def_id = fcx.tcx.hir.local_def_id(item.id);\n+        let def_id = fcx.tcx.hir().local_def_id(item.id);\n         let packed = fcx.tcx.adt_def(def_id).repr.packed();\n \n         for variant in &variants {\n@@ -315,7 +315,7 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     debug!(\"check_trait: {:?}\", item.id);\n \n-    let trait_def_id = tcx.hir.local_def_id(item.id);\n+    let trait_def_id = tcx.hir().local_def_id(item.id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n     if trait_def.is_marker {\n@@ -337,7 +337,7 @@ fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n \n fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let def_id = fcx.tcx.hir.local_def_id(item.id);\n+        let def_id = fcx.tcx.hir().local_def_id(item.id);\n         let sig = fcx.tcx.fn_sig(def_id);\n         let sig = fcx.normalize_associated_types_in(item.span, &sig);\n         let mut implied_bounds = vec![];\n@@ -356,7 +356,7 @@ fn check_item_type<'a, 'tcx>(\n     debug!(\"check_item_type: {:?}\", item_id);\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx, gcx| {\n-        let ty = gcx.type_of(gcx.hir.local_def_id(item_id));\n+        let ty = gcx.type_of(gcx.hir().local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n         let mut forbid_unsized = true;\n@@ -387,7 +387,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"check_impl: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n+        let item_def_id = fcx.tcx.hir().local_def_id(item.id);\n \n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n@@ -621,7 +621,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                 let generics = tcx.generics_of(def_id);\n                 // only check named existential types\n                 if generics.parent.is_none() {\n-                    let opaque_node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                    let opaque_node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n                     if may_define_existential_type(tcx, fn_def_id, opaque_node_id) {\n                         trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n@@ -821,7 +821,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            item: &hir::Item,\n                                            hir_generics: &hir::Generics)\n {\n-    let item_def_id = tcx.hir.local_def_id(item.id);\n+    let item_def_id = tcx.hir().local_def_id(item.id);\n     let ty = tcx.type_of(item_def_id);\n     if tcx.has_error_field(ty) {\n         return;\n@@ -908,7 +908,7 @@ fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n \n     let empty_env = ty::ParamEnv::empty();\n \n-    let def_id = fcx.tcx.hir.local_def_id(id);\n+    let def_id = fcx.tcx.hir().local_def_id(id);\n     let predicates = fcx.tcx.predicates_of(def_id).predicates\n         .iter()\n         .map(|(p, _)| *p)\n@@ -956,21 +956,21 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, i: &hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n-        let def_id = self.tcx.hir.local_def_id(i.id);\n+        let def_id = self.tcx.hir().local_def_id(i.id);\n         ty::query::queries::check_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_item(self, i);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        let def_id = self.tcx.hir.local_def_id(trait_item.id);\n+        let def_id = self.tcx.hir().local_def_id(trait_item.id);\n         ty::query::queries::check_trait_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'v hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        let def_id = self.tcx.hir.local_def_id(impl_item.id);\n+        let def_id = self.tcx.hir().local_def_id(impl_item.id);\n         ty::query::queries::check_impl_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n@@ -991,7 +991,7 @@ struct AdtField<'tcx> {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn non_enum_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n         let fields = struct_def.fields().iter().map(|field| {\n-            let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n+            let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n             let field_ty = self.normalize_associated_types_in(field.span,\n                                                               &field_ty);\n             AdtField { ty: field_ty, span: field.span }"}, {"sha": "8d7fc008fb0d0fce51a730ff2c028bbb7724dc29", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -32,8 +32,8 @@ use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) -> &'gcx ty::TypeckTables<'gcx> {\n-        let item_id = self.tcx.hir.body_owner(body.id());\n-        let item_def_id = self.tcx.hir.local_def_id(item_id);\n+        let item_id = self.tcx.hir().body_owner(body.id());\n+        let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is used for unit tests.\n@@ -99,7 +99,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         body: &'gcx hir::Body,\n         rustc_dump_user_substs: bool,\n     ) -> WritebackCx<'cx, 'gcx, 'tcx> {\n-        let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n+        let owner = fcx.tcx.hir().definitions().node_to_hir_id(body.id().node_id);\n \n         WritebackCx {\n             fcx,\n@@ -233,7 +233,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         match e.node {\n             hir::ExprKind::Closure(_, _, body, _, _) => {\n-                let body = self.fcx.tcx.hir.body(body);\n+                let body = self.fcx.tcx.hir().body(body);\n                 for arg in &body.arguments {\n                     self.visit_node_id(e.span, arg.hir_id);\n                 }\n@@ -398,7 +398,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 c_sig\n             } else {\n                 span_bug!(\n-                    self.fcx.tcx.hir.span_if_local(def_id).unwrap(),\n+                    self.fcx.tcx.hir().span_if_local(def_id).unwrap(),\n                     \"writeback: `{:?}` missing from the global type context\",\n                     c_sig\n                 );\n@@ -412,7 +412,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n-            let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+            let node_id = self.tcx().hir().as_local_node_id(def_id).unwrap();\n             let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &node_id);\n \n             let generics = self.tcx().generics_of(def_id);\n@@ -545,7 +545,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_field_id(&mut self, node_id: ast::NodeId) {\n-        let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n+        let hir_id = self.tcx().hir().node_to_hir_id(node_id);\n         if let Some(index) = self.fcx\n             .tables\n             .borrow_mut()\n@@ -591,8 +591,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             // Unit-testing mechanism:\n             if self.rustc_dump_user_substs {\n-                let node_id = self.tcx().hir.hir_to_node_id(hir_id);\n-                let span = self.tcx().hir.span(node_id);\n+                let node_id = self.tcx().hir().hir_to_node_id(hir_id);\n+                let span = self.tcx().hir().span(node_id);\n                 self.tcx().sess.span_err(\n                     span,\n                     &format!(\"user substs: {:?}\", user_substs),\n@@ -710,21 +710,21 @@ impl Locatable for Span {\n \n impl Locatable for ast::NodeId {\n     fn to_span(&self, tcx: &TyCtxt) -> Span {\n-        tcx.hir.span(*self)\n+        tcx.hir().span(*self)\n     }\n }\n \n impl Locatable for DefIndex {\n     fn to_span(&self, tcx: &TyCtxt) -> Span {\n-        let node_id = tcx.hir.def_index_to_node_id(*self);\n-        tcx.hir.span(node_id)\n+        let node_id = tcx.hir().def_index_to_node_id(*self);\n+        tcx.hir().span(node_id)\n     }\n }\n \n impl Locatable for hir::HirId {\n     fn to_span(&self, tcx: &TyCtxt) -> Span {\n-        let node_id = tcx.hir.hir_to_node_id(*self);\n-        tcx.hir.span(node_id)\n+        let node_id = tcx.hir().hir_to_node_id(*self);\n+        tcx.hir().span(node_id)\n     }\n }\n "}, {"sha": "e6171e9da3bd5349fa9cf8ec224148c8090e94b2", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -25,15 +25,15 @@ use rustc_data_structures::fx::FxHashMap;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut used_trait_imports = DefIdSet::default();\n-    for &body_id in tcx.hir.krate().bodies.keys() {\n-        let item_def_id = tcx.hir.body_owner_def_id(body_id);\n+    for &body_id in tcx.hir().krate().bodies.keys() {\n+        let item_def_id = tcx.hir().body_owner_def_id(body_id);\n         let imports = tcx.used_trait_imports(item_def_id);\n         debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n         used_trait_imports.extend(imports.iter());\n     }\n \n     let mut visitor = CheckVisitor { tcx, used_trait_imports };\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+    tcx.hir().krate().visit_all_item_likes(&mut visitor);\n \n     unused_crates_lint(tcx);\n }\n@@ -62,12 +62,12 @@ struct CheckVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n     fn check_import(&self, id: ast::NodeId, span: Span) {\n-        let def_id = self.tcx.hir.local_def_id(id);\n+        let def_id = self.tcx.hir().local_def_id(id);\n         if !self.tcx.maybe_unused_trait_import(def_id) {\n             return;\n         }\n \n-        let import_def_id = self.tcx.hir.local_def_id(id);\n+        let import_def_id = self.tcx.hir().local_def_id(id);\n         if self.used_trait_imports.contains(&import_def_id) {\n             return;\n         }\n@@ -105,8 +105,8 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             // Note that if we carry through to the `extern_mod_stmt_cnum` query\n             // below it'll cause a panic because `def_id` is actually bogus at this\n             // point in time otherwise.\n-            if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-                if tcx.hir.find(id).is_none() {\n+            if let Some(id) = tcx.hir().as_local_node_id(def_id) {\n+                if tcx.hir().find(id).is_none() {\n                     return false;\n                 }\n             }\n@@ -125,14 +125,14 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n \n     // Collect all the extern crates (in a reliable order).\n     let mut crates_to_lint = vec![];\n-    tcx.hir.krate().visit_all_item_likes(&mut CollectExternCrateVisitor {\n+    tcx.hir().krate().visit_all_item_likes(&mut CollectExternCrateVisitor {\n         tcx,\n         crates_to_lint: &mut crates_to_lint,\n     });\n \n     for extern_crate in &crates_to_lint {\n-        let id = tcx.hir.as_local_node_id(extern_crate.def_id).unwrap();\n-        let item = tcx.hir.expect_item(id);\n+        let id = tcx.hir().as_local_node_id(extern_crate.def_id).unwrap();\n+        let item = tcx.hir().expect_item(id);\n \n         // If the crate is fully unused, we suggest removing it altogether.\n         // We do this in any edition.\n@@ -223,7 +223,7 @@ struct ExternCrateToLint {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.node {\n-            let extern_crate_def_id = self.tcx.hir.local_def_id(item.id);\n+            let extern_crate_def_id = self.tcx.hir().local_def_id(item.id);\n             self.crates_to_lint.push(\n                 ExternCrateToLint {\n                     def_id: extern_crate_def_id,"}, {"sha": "bdb2a9a8af13482e612e92891d0812ed734fb8da", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -46,8 +46,8 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId)\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n-            for &impl_id in self.tcx.hir.trait_impls(self.trait_def_id) {\n-                let impl_def_id = self.tcx.hir.local_def_id(impl_id);\n+            for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n+                let impl_def_id = self.tcx.hir().local_def_id(impl_id);\n                 f(self.tcx, impl_def_id);\n             }\n         }\n@@ -60,8 +60,8 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n         /* do nothing */\n     } else {\n         // Destructors only work on nominal types.\n-        if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n-            if let Some(Node::Item(item)) = tcx.hir.find(impl_node_id) {\n+        if let Some(impl_node_id) = tcx.hir().as_local_node_id(impl_did) {\n+            if let Some(Node::Item(item)) = tcx.hir().find(impl_node_id) {\n                 let span = match item.node {\n                     ItemKind::Impl(.., ref ty, _) => ty.span,\n                     _ => item.span,\n@@ -86,7 +86,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_node_id = if let Some(n) = tcx.hir.as_local_node_id(impl_did) {\n+    let impl_node_id = if let Some(n) = tcx.hir().as_local_node_id(impl_did) {\n         n\n     } else {\n         debug!(\"visit_implementation_of_copy(): impl not in this crate\");\n@@ -97,7 +97,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n            self_type);\n \n-    let span = tcx.hir.span(impl_node_id);\n+    let span = tcx.hir().span(impl_node_id);\n     let param_env = tcx.param_env(impl_did);\n     assert!(!self_type.has_escaping_bound_vars());\n \n@@ -107,7 +107,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n     match param_env.can_type_implement_copy(tcx, self_type) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n-            let item = tcx.hir.expect_item(impl_node_id);\n+            let item = tcx.hir().expect_item(impl_node_id);\n             let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.node {\n                 tr.path.span\n             } else {\n@@ -124,7 +124,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n             err.emit()\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n-            let item = tcx.hir.expect_item(impl_node_id);\n+            let item = tcx.hir().expect_item(impl_node_id);\n             let span = if let ItemKind::Impl(.., ref ty, _) = item.node {\n                 ty.span\n             } else {\n@@ -172,8 +172,8 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n     if impl_did.is_local() {\n         let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-        let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap();\n-        let span = tcx.hir.span(impl_node_id);\n+        let impl_node_id = tcx.hir().as_local_node_id(impl_did).unwrap();\n+        let span = tcx.hir().span(impl_node_id);\n \n         let source = tcx.type_of(impl_did);\n         assert!(!source.has_escaping_bound_vars());\n@@ -342,7 +342,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_node_id = gcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n+    let impl_node_id = gcx.hir().as_local_node_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n@@ -354,7 +354,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n            source,\n            target);\n \n-    let span = gcx.hir.span(impl_node_id);\n+    let span = gcx.hir().span(impl_node_id);\n     let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n@@ -491,11 +491,11 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir.expect_item(impl_node_id);\n+                    let item = gcx.hir().expect_item(impl_node_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        gcx.hir.span(impl_node_id)\n+                        gcx.hir().span(impl_node_id)\n                     };\n \n                     let mut err = struct_span_err!(gcx.sess,"}, {"sha": "59989a65d4f91aa5df3d2cbd3f5c9e3f06b2d0e3", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -33,7 +33,7 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       -> Lrc<CrateInherentImpls> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let mut collect = InherentCollect {\n         tcx,\n         impls_map: Default::default(),\n@@ -95,7 +95,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             _ => return\n         };\n \n-        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id(item.id);\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();\n         match self_ty.sty {\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+            let impl_def_id = self.tcx.hir().local_def_id(item.id);\n             let mut rc_vec = self.impls_map.inherent_impls\n                                            .entry(def_id)\n                                            .or_default();"}, {"sha": "ec1a43991f6aaa158d1f04e08a0dca7438beee1a", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -20,7 +20,7 @@ use lint;\n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n }\n \n@@ -46,7 +46,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let node_id = self.tcx.hir.as_local_node_id(impl1);\n+                    let node_id = self.tcx.hir().as_local_node_id(impl1);\n                     let mut err = if used_to_be_allowed && node_id.is_some() {\n                         self.tcx.struct_span_lint_node(\n                             lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n@@ -126,7 +126,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::Union(..) => {\n-                let type_def_id = self.tcx.hir.local_def_id(item.id);\n+                let type_def_id = self.tcx.hir().local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }\n             _ => {}"}, {"sha": "b92916d9c81c19acf91b8541604c8d6512e6b090", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -29,7 +29,7 @@ mod orphan;\n mod unsafety;\n \n fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n-    let impl_def_id = tcx.hir.local_def_id(node_id);\n+    let impl_def_id = tcx.hir().local_def_id(node_id);\n \n     // If there are no traits, then this implementation must have a\n     // base type.\n@@ -135,7 +135,7 @@ pub fn provide(providers: &mut Providers) {\n }\n \n fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let impls = tcx.hir.trait_impls(def_id);\n+    let impls = tcx.hir().trait_impls(def_id);\n     for &impl_id in impls {\n         check_impl(tcx, impl_id);\n     }\n@@ -146,7 +146,7 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n }\n \n pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &trait_def_id in tcx.hir.krate().trait_impls.keys() {\n+    for &trait_def_id in tcx.hir().krate().trait_impls.keys() {\n         ty::query::queries::coherent_trait::ensure(tcx, trait_def_id);\n     }\n \n@@ -162,7 +162,7 @@ pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n /// same type. Likewise, no two inherent impls for a given type\n /// constructor provide a method with the same name.\n fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n-    let impl_def_id = tcx.hir.local_def_id(node_id);\n+    let impl_def_id = tcx.hir().local_def_id(node_id);\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n     let trait_def_id = trait_ref.def_id;\n "}, {"sha": "47edf59f0ad9845896c5dba4631d23ea40dd91e6", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -18,7 +18,7 @@ use rustc::hir;\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut orphan = OrphanChecker { tcx };\n-    tcx.hir.krate().visit_all_item_likes(&mut orphan);\n+    tcx.hir().krate().visit_all_item_likes(&mut orphan);\n }\n \n struct OrphanChecker<'cx, 'tcx: 'cx> {\n@@ -32,11 +32,11 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id(item.id);\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n             debug!(\"coherence2::orphan check: trait impl {}\",\n-                   self.tcx.hir.node_to_string(item.id));\n+                   self.tcx.hir().node_to_string(item.id));\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let cm = self.tcx.sess.source_map();"}, {"sha": "b4196b572b4b235c9923f8a92e226629238bc42a", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::{self, Unsafety};\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut unsafety = UnsafetyChecker { tcx };\n-    tcx.hir.krate().visit_all_item_likes(&mut unsafety);\n+    tcx.hir().krate().visit_all_item_likes(&mut unsafety);\n }\n \n struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n@@ -31,7 +31,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity)\n     {\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(self.tcx.hir.local_def_id(item.id)) {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(self.tcx.hir().local_def_id(item.id)) {\n             let trait_def = self.tcx.trait_def(trait_ref.def_id);\n             let unsafe_attr = impl_generics.and_then(|generics| {\n                 generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")"}, {"sha": "9104c15bdd5a25559089d6a59aad3ad8945b9333", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -66,7 +66,7 @@ struct OnlySelfBounds(bool);\n \n pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = CollectItemTypesVisitor { tcx };\n-    tcx.hir\n+    tcx.hir()\n        .krate()\n        .visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n@@ -115,7 +115,7 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n                 hir::GenericParamKind::Type {\n                     default: Some(_), ..\n                 } => {\n-                    let def_id = self.tcx.hir.local_def_id(param.id);\n+                    let def_id = self.tcx.hir().local_def_id(param.id);\n                     self.tcx.type_of(def_id);\n                 }\n                 hir::GenericParamKind::Type { .. } => {}\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprKind::Closure(..) = expr.node {\n-            let def_id = self.tcx.hir.local_def_id(expr.id);\n+            let def_id = self.tcx.hir().local_def_id(expr.id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n         }\n@@ -252,12 +252,12 @@ fn type_param_predicates<'a, 'tcx>(\n     // written inline like `<T : Foo>` or in a where clause like\n     // `where T : Foo`.\n \n-    let param_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let param_owner = tcx.hir.ty_param_owner(param_id);\n-    let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n+    let param_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let param_owner = tcx.hir().ty_param_owner(param_id);\n+    let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.param_def_id_to_index[&def_id];\n-    let ty = tcx.mk_ty_param(index, tcx.hir.ty_param_name(param_id).as_interned_str());\n+    let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id).as_interned_str());\n \n     // Don't look for bounds where the type parameter isn't in scope.\n     let parent = if item_def_id == param_owner_def_id {\n@@ -277,8 +277,8 @@ fn type_param_predicates<'a, 'tcx>(\n         },\n     );\n \n-    let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n-    let ast_generics = match tcx.hir.get(item_node_id) {\n+    let item_node_id = tcx.hir().as_local_node_id(item_def_id).unwrap();\n+    let ast_generics = match tcx.hir().get(item_node_id) {\n         Node::TraitItem(item) => &item.generics,\n \n         Node::ImplItem(item) => &item.generics,\n@@ -384,7 +384,7 @@ fn is_param<'a, 'tcx>(\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.def {\n             Def::SelfTy(Some(def_id), None) | Def::TyParam(def_id) => {\n-                def_id == tcx.hir.local_def_id(param_id)\n+                def_id == tcx.hir().local_def_id(param_id)\n             }\n             _ => false,\n         }\n@@ -394,9 +394,9 @@ fn is_param<'a, 'tcx>(\n }\n \n fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n-    let it = tcx.hir.expect_item(item_id);\n+    let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n-    let def_id = tcx.hir.local_def_id(item_id);\n+    let def_id = tcx.hir().local_def_id(item_id);\n     match it.node {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n@@ -405,7 +405,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n-                let def_id = tcx.hir.local_def_id(item.id);\n+                let def_id = tcx.hir().local_def_id(item.id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n@@ -443,7 +443,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             tcx.predicates_of(def_id);\n \n             for f in struct_def.fields() {\n-                let def_id = tcx.hir.local_def_id(f.id);\n+                let def_id = tcx.hir().local_def_id(f.id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n@@ -476,8 +476,8 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n }\n \n fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast::NodeId) {\n-    let trait_item = tcx.hir.expect_trait_item(trait_item_id);\n-    let def_id = tcx.hir.local_def_id(trait_item.id);\n+    let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n+    let def_id = tcx.hir().local_def_id(trait_item.id);\n     tcx.generics_of(def_id);\n \n     match trait_item.node {\n@@ -497,17 +497,17 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast:\n }\n \n fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::NodeId) {\n-    let def_id = tcx.hir.local_def_id(impl_item_id);\n+    let def_id = tcx.hir().local_def_id(impl_item_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n-    if let hir::ImplItemKind::Method(..) = tcx.hir.expect_impl_item(impl_item_id).node {\n+    if let hir::ImplItemKind::Method(..) = tcx.hir().expect_impl_item(impl_item_id).node {\n         tcx.fn_sig(def_id);\n     }\n }\n \n fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ctor_id: ast::NodeId) {\n-    let def_id = tcx.hir.local_def_id(ctor_id);\n+    let def_id = tcx.hir().local_def_id(ctor_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n@@ -528,7 +528,7 @@ fn convert_enum_variant_types<'a, 'tcx>(\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n             if let Some(ref e) = variant.node.disr_expr {\n-                let expr_did = tcx.hir.local_def_id(e.id);\n+                let expr_did = tcx.hir().local_def_id(e.id);\n                 def.eval_explicit_discr(tcx, expr_did)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n@@ -551,7 +551,7 @@ fn convert_enum_variant_types<'a, 'tcx>(\n         );\n \n         for f in variant.node.data.fields() {\n-            let def_id = tcx.hir.local_def_id(f.id);\n+            let def_id = tcx.hir().local_def_id(f.id);\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n@@ -573,12 +573,12 @@ fn convert_variant<'a, 'tcx>(\n     attribute_def_id: DefId\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let node_id = tcx.hir.as_local_node_id(did).unwrap();\n+    let node_id = tcx.hir().as_local_node_id(did).unwrap();\n     let fields = def\n         .fields()\n         .iter()\n         .map(|f| {\n-            let fid = tcx.hir.local_def_id(f.id);\n+            let fid = tcx.hir().local_def_id(f.id);\n             let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n             if let Some(prev_span) = dup_span {\n                 struct_span_err!(\n@@ -614,8 +614,8 @@ fn convert_variant<'a, 'tcx>(\n fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n     use rustc::hir::*;\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let item = match tcx.hir.get(node_id) {\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let item = match tcx.hir().get(node_id) {\n         Node::Item(item) => item,\n         _ => bug!(),\n     };\n@@ -629,10 +629,10 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n                 def.variants\n                     .iter()\n                     .map(|v| {\n-                        let did = tcx.hir.local_def_id(v.node.data.id());\n+                        let did = tcx.hir().local_def_id(v.node.data.id());\n                         let discr = if let Some(ref e) = v.node.disr_expr {\n                             distance_from_explicit = 0;\n-                            ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.id))\n+                            ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.id))\n                         } else {\n                             ty::VariantDiscr::Relative(distance_from_explicit)\n                         };\n@@ -647,7 +647,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n         ItemKind::Struct(ref def, _) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n             let ctor_id = if !def.is_struct() {\n-                Some(tcx.hir.local_def_id(def.id()))\n+                Some(tcx.hir().local_def_id(def.id()))\n             } else {\n                 None\n             };\n@@ -689,9 +689,9 @@ fn super_predicates_of<'a, 'tcx>(\n     trait_def_id: DefId,\n ) -> Lrc<ty::GenericPredicates<'tcx>> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n+    let trait_node_id = tcx.hir().as_local_node_id(trait_def_id).unwrap();\n \n-    let item = match tcx.hir.get(trait_node_id) {\n+    let item = match tcx.hir().get(trait_node_id) {\n         Node::Item(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_node_id),\n     };\n@@ -738,8 +738,8 @@ fn super_predicates_of<'a, 'tcx>(\n }\n \n fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let item = tcx.hir.expect_item(node_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(node_id);\n \n     let (is_auto, unsafety) = match item.node {\n         hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n@@ -815,7 +815,7 @@ fn has_late_bound_regions<'a, 'tcx>(\n                 return;\n             }\n \n-            let hir_id = self.tcx.hir.node_to_hir_id(lt.id);\n+            let hir_id = self.tcx.hir().node_to_hir_id(lt.id);\n             match self.tcx.named_region(hir_id) {\n                 Some(rl::Region::Static) | Some(rl::Region::EarlyBound(..)) => {}\n                 Some(rl::Region::LateBound(debruijn, _, _))\n@@ -842,7 +842,7 @@ fn has_late_bound_regions<'a, 'tcx>(\n         };\n         for param in &generics.params {\n             if let GenericParamKind::Lifetime { .. } = param.kind {\n-                let hir_id = tcx.hir.node_to_hir_id(param.id);\n+                let hir_id = tcx.hir().node_to_hir_id(param.id);\n                 if tcx.is_late_bound(hir_id) {\n                     return Some(param.span);\n                 }\n@@ -884,14 +884,14 @@ fn has_late_bound_regions<'a, 'tcx>(\n fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n     use rustc::hir::*;\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n \n-    let node = tcx.hir.get(node_id);\n+    let node = tcx.hir().get(node_id);\n     let parent_def_id = match node {\n         Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_)\n         | Node::StructCtor(_) | Node::Field(_) => {\n-            let parent_id = tcx.hir.get_parent(node_id);\n-            Some(tcx.hir.local_def_id(parent_id))\n+            let parent_id = tcx.hir().get_parent(node_id);\n+            Some(tcx.hir().local_def_id(parent_id))\n         }\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n@@ -939,7 +939,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: keywords::SelfUpper.name().as_interned_str(),\n-                        def_id: tcx.hir.local_def_id(param_id),\n+                        def_id: tcx.hir().local_def_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n@@ -985,13 +985,13 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n             .map(|(i, param)| ty::GenericParamDef {\n                 name: param.name.ident().as_interned_str(),\n                 index: own_start + i as u32,\n-                def_id: tcx.hir.local_def_id(param.id),\n+                def_id: tcx.hir().local_def_id(param.id),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Lifetime,\n             }),\n     );\n \n-    let hir_id = tcx.hir.node_to_hir_id(node_id);\n+    let hir_id = tcx.hir().node_to_hir_id(node_id);\n     let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n@@ -1031,7 +1031,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     let ty_param = ty::GenericParamDef {\n                         index: type_start + i as u32,\n                         name: param.name.ident().as_interned_str(),\n-                        def_id: tcx.hir.local_def_id(param.id),\n+                        def_id: tcx.hir().local_def_id(param.id),\n                         pure_wrt_drop: param.pure_wrt_drop,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: default.is_some(),\n@@ -1123,11 +1123,11 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     use rustc::hir::*;\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir.get(node_id) {\n+    match tcx.hir().get(node_id) {\n         Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n@@ -1147,7 +1147,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n             ImplItemKind::Existential(_) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir.get_parent_did(node_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did(node_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1157,7 +1157,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n             ImplItemKind::Type(ref ty) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir.get_parent_did(node_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did(node_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1240,7 +1240,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ..\n         }) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir.get_parent_did(node_id))\n+                tcx.type_of(tcx.hir().get_parent_did(node_id))\n             }\n             VariantData::Tuple(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n@@ -1255,7 +1255,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ..\n         }) => {\n             if gen.is_some() {\n-                let hir_id = tcx.hir.node_to_hir_id(node_id);\n+                let hir_id = tcx.hir().node_to_hir_id(node_id);\n                 return tcx.typeck_tables_of(def_id).node_id_to_type(hir_id);\n             }\n \n@@ -1266,7 +1266,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        Node::AnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n+        Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(node_id)) {\n             Node::Ty(&hir::Ty {\n                 node: hir::TyKind::Array(_, ref constant),\n                 ..\n@@ -1292,7 +1292,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                 ..\n             }) if e.id == node_id =>\n             {\n-                tcx.adt_def(tcx.hir.get_parent_did(node_id))\n+                tcx.adt_def(tcx.hir().get_parent_did(node_id))\n                     .repr\n                     .discr_type()\n                     .to_ty(tcx)\n@@ -1365,26 +1365,26 @@ fn find_existential_constraints<'a, 'tcx>(\n \n     impl<'a, 'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'a, 'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-            intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+            intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n-            let def_id = self.tcx.hir.local_def_id(it.id);\n+            let def_id = self.tcx.hir().local_def_id(it.id);\n             // the existential type itself or its children are not within its reveal scope\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n-            let def_id = self.tcx.hir.local_def_id(it.id);\n+            let def_id = self.tcx.hir().local_def_id(it.id);\n             // the existential type itself or its children are not within its reveal scope\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n-            let def_id = self.tcx.hir.local_def_id(it.id);\n+            let def_id = self.tcx.hir().local_def_id(it.id);\n             self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -1395,16 +1395,16 @@ fn find_existential_constraints<'a, 'tcx>(\n         tcx,\n         found: None,\n     };\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let parent = tcx.hir.get_parent(node_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let parent = tcx.hir().get_parent(node_id);\n \n     trace!(\"parent_id: {:?}\", parent);\n \n     if parent == ast::CRATE_NODE_ID {\n-        intravisit::walk_crate(&mut locator, tcx.hir.krate());\n+        intravisit::walk_crate(&mut locator, tcx.hir().krate());\n     } else {\n-        trace!(\"parent: {:?}\", tcx.hir.get(parent));\n-        match tcx.hir.get(parent) {\n+        trace!(\"parent: {:?}\", tcx.hir().get(parent));\n+        match tcx.hir().get(parent) {\n             Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n@@ -1429,11 +1429,11 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n     use rustc::hir::*;\n     use rustc::hir::Node::*;\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir.get(node_id) {\n+    match tcx.hir().get(node_id) {\n         TraitItem(hir::TraitItem {\n             node: TraitItemKind::Method(sig, _),\n             ..\n@@ -1452,7 +1452,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             node: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n-            let abi = tcx.hir.get_foreign_abi(node_id);\n+            let abi = tcx.hir().get_foreign_abi(node_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n@@ -1465,10 +1465,10 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n                 },\n             ..\n         }) => {\n-            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n+            let ty = tcx.type_of(tcx.hir().get_parent_did(node_id));\n             let inputs = fields\n                 .iter()\n-                .map(|f| tcx.type_of(tcx.hir.local_def_id(f.id)));\n+                .map(|f| tcx.type_of(tcx.hir().local_def_id(f.id)));\n             ty::Binder::bind(tcx.mk_fn_sig(\n                 inputs,\n                 ty,\n@@ -1512,8 +1512,8 @@ fn impl_trait_ref<'a, 'tcx>(\n ) -> Option<ty::TraitRef<'tcx>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    match tcx.hir.expect_item(node_id).node {\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    match tcx.hir().expect_item(node_id).node {\n         hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 let selfty = tcx.type_of(def_id);\n@@ -1525,8 +1525,8 @@ fn impl_trait_ref<'a, 'tcx>(\n }\n \n fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::ImplPolarity {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    match tcx.hir.expect_item(node_id).node {\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    match tcx.hir().expect_item(node_id).node {\n         hir::ItemKind::Impl(_, polarity, ..) => polarity,\n         ref item => bug!(\"impl_polarity: {:?} not an impl\", item),\n     }\n@@ -1597,7 +1597,7 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n         .iter()\n         .filter(move |param| match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n-                let hir_id = tcx.hir.node_to_hir_id(param.id);\n+                let hir_id = tcx.hir().node_to_hir_id(param.id);\n                 !tcx.is_late_bound(hir_id)\n             }\n             _ => false,\n@@ -1695,8 +1695,8 @@ fn explicit_predicates_of<'a, 'tcx>(\n         }\n     }\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let node = tcx.hir.get(node_id);\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let node = tcx.hir().get(node_id);\n \n     let mut is_trait = None;\n     let mut is_default_impl_trait = None;\n@@ -1825,7 +1825,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir.local_def_id(param.id),\n+            def_id: tcx.hir().local_def_id(param.id),\n             index,\n             name: param.name.ident().as_interned_str(),\n         }));\n@@ -1938,14 +1938,14 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // Add predicates from associated type bounds.\n     if let Some((self_trait_ref, trait_items)) = is_trait {\n         predicates.extend(trait_items.iter().flat_map(|trait_item_ref| {\n-            let trait_item = tcx.hir.trait_item(trait_item_ref.id);\n+            let trait_item = tcx.hir().trait_item(trait_item_ref.id);\n             let bounds = match trait_item.node {\n                 hir::TraitItemKind::Type(ref bounds, _) => bounds,\n                 _ => return vec![].into_iter()\n             };\n \n             let assoc_ty =\n-                tcx.mk_projection(tcx.hir.local_def_id(trait_item.id), self_trait_ref.substs);\n+                tcx.mk_projection(tcx.hir().local_def_id(trait_item.id), self_trait_ref.substs);\n \n             let bounds = compute_bounds(\n                 &ItemCtxt::new(tcx, def_id),\n@@ -2108,7 +2108,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n                        &format!(\n                            \"use of SIMD type `{}` in FFI is highly experimental and \\\n                             may result in invalid code\",\n-                           tcx.hir.node_to_pretty_string(ast_ty.id)\n+                           tcx.hir().node_to_pretty_string(ast_ty.id)\n                        ),\n                    )\n                    .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n@@ -2127,7 +2127,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n }\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n-    match tcx.hir.get_if_local(def_id) {\n+    match tcx.hir().get_if_local(def_id) {\n         Some(Node::ForeignItem(..)) => true,\n         Some(_) => false,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n@@ -2249,7 +2249,7 @@ fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &\n         \"weak\" => WeakAny,\n         \"weak_odr\" => WeakODR,\n         _ => {\n-            let span = tcx.hir.span_if_local(def_id);\n+            let span = tcx.hir().span_if_local(def_id);\n             if let Some(span) = span {\n                 tcx.sess.span_fatal(span, \"invalid linkage specified\")\n             } else {"}, {"sha": "a2071fd6d47e0d91e8b35e341fd6512ac66e8a03", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -62,7 +62,7 @@ pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // We will tag this as part of the WF check -- logically, it is,\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n-    tcx.hir.krate().visit_all_item_likes(&mut ImplWfCheck { tcx });\n+    tcx.hir().krate().visit_all_item_likes(&mut ImplWfCheck { tcx });\n }\n \n struct ImplWfCheck<'a, 'tcx: 'a> {\n@@ -72,7 +72,7 @@ struct ImplWfCheck<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n-            let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+            let impl_def_id = self.tcx.hir().local_def_id(item.id);\n             enforce_impl_params_are_constrained(self.tcx,\n                                                 impl_def_id,\n                                                 impl_item_refs);\n@@ -101,7 +101,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n-        .map(|item_ref| tcx.hir.local_def_id(item_ref.id.node_id))\n+        .map(|item_ref| tcx.hir().local_def_id(item_ref.id.node_id))\n         .filter(|&def_id| {\n             let item = tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n@@ -176,7 +176,7 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {\n-        let impl_item = tcx.hir.impl_item(impl_item_ref.id);\n+        let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n         let seen_items = match impl_item.node {\n             hir::ImplItemKind::Type(_) => &mut seen_type_items,\n             _                          => &mut seen_value_items,"}, {"sha": "ae3cfbb9b3716799460cf3b5ee1ab89bcb6bcfa4", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -182,11 +182,11 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               main_id: ast::NodeId,\n                               main_span: Span) {\n-    let main_def_id = tcx.hir.local_def_id(main_id);\n+    let main_def_id = tcx.hir().local_def_id(main_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir.find(main_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n@@ -248,11 +248,11 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                start_id: ast::NodeId,\n                                start_span: Span) {\n-    let start_def_id = tcx.hir.local_def_id(start_id);\n+    let start_def_id = tcx.hir().local_def_id(start_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir.find(start_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n@@ -373,8 +373,8 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n     // In case there are any projections etc, find the \"environment\"\n     // def-id that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n-    let env_node_id = tcx.hir.get_parent(hir_ty.id);\n-    let env_def_id = tcx.hir.local_def_id(env_node_id);\n+    let env_node_id = tcx.hir().get_parent(hir_ty.id);\n+    let env_def_id = tcx.hir().local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n \n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n@@ -385,8 +385,8 @@ pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait:\n     // In case there are any projections etc, find the \"environment\"\n     // def-id that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n-    let env_node_id = tcx.hir.get_parent(hir_trait.ref_id);\n-    let env_def_id = tcx.hir.local_def_id(env_node_id);\n+    let env_node_id = tcx.hir().get_parent(hir_trait.ref_id);\n+    let env_def_id = tcx.hir().local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n     let mut projections = Vec::new();\n     let (principal, _) = astconv::AstConv::instantiate_poly_trait_ref_inner("}, {"sha": "5f010875842869e287f757efcf7f832fb6493e9c", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -48,7 +48,7 @@ pub fn infer_predicates<'tcx>(\n         };\n \n         // Visit all the crates and infer predicates\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir().krate().visit_all_item_likes(&mut visitor);\n     }\n \n     global_inferred_outlives\n@@ -63,16 +63,16 @@ pub struct InferVisitor<'cx, 'tcx: 'cx> {\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let item_did = self.tcx.hir.local_def_id(item.id);\n+        let item_did = self.tcx.hir().local_def_id(item.id);\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n         let node_id = self\n             .tcx\n-            .hir\n+            .hir()\n             .as_local_node_id(item_did)\n             .expect(\"expected local def-id\");\n-        let item = match self.tcx.hir.get(node_id) {\n+        let item = match self.tcx.hir().get(node_id) {\n             Node::Item(item) => item,\n             _ => bug!(),\n         };"}, {"sha": "5796df2744b2b80558be9ac4aa54243e40482550", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -35,11 +35,11 @@ fn inferred_outlives_of<'a, 'tcx>(\n     item_def_id: DefId,\n ) -> Lrc<Vec<ty::Predicate<'tcx>>> {\n     let id = tcx\n-        .hir\n+        .hir()\n         .as_local_node_id(item_def_id)\n         .expect(\"expected local def-id\");\n \n-    match tcx.hir.get(id) {\n+    match tcx.hir().get(id) {\n         Node::Item(item) => match item.node {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);"}, {"sha": "d855675d3901906a613bdf3d11f354471b422e4f", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n \n pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir\n+    tcx.hir()\n        .krate()\n        .visit_all_item_likes(&mut OutlivesTest { tcx });\n }\n@@ -24,7 +24,7 @@ struct OutlivesTest<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir.local_def_id(item.id);\n+        let item_def_id = self.tcx.hir().local_def_id(item.id);\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found."}, {"sha": "ee554ee684d128caa978a7877fcbd02d1959ff45", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -72,7 +72,7 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n         constraints: Vec::new(),\n     };\n \n-    tcx.hir.krate().visit_all_item_likes(&mut constraint_cx);\n+    tcx.hir().krate().visit_all_item_likes(&mut constraint_cx);\n \n     constraint_cx\n }\n@@ -131,7 +131,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn visit_node_helper(&mut self, id: ast::NodeId) {\n         let tcx = self.terms_cx.tcx;\n-        let def_id = tcx.hir.local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         self.build_constraints_for_item(def_id);\n     }\n \n@@ -148,7 +148,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).sty {\n@@ -365,7 +365,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let (local, remote) = if let Some(id) = self.tcx().hir.as_local_node_id(def_id) {\n+        let (local, remote) = if let Some(id) = self.tcx().hir().as_local_node_id(def_id) {\n             (Some(self.terms_cx.inferred_starts[&id]), None)\n         } else {\n             (None, Some(self.tcx().variances_of(def_id)))"}, {"sha": "4039281ffb7801643752e22a59359089be90c194", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -56,12 +56,12 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n                           -> Lrc<Vec<ty::Variance>> {\n-    let id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let id = tcx.hir().as_local_node_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant.\n-        span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n+        span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")\n     };\n-    match tcx.hir.get(id) {\n+    match tcx.hir().get(id) {\n         Node::Item(item) => match item.node {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |"}, {"sha": "365c65bc04888303c4acd7dc793b7dfda1c0bec4", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let solutions = &self.solutions;\n         self.terms_cx.inferred_starts.iter().map(|(&id, &InferredIndex(start))| {\n-            let def_id = tcx.hir.local_def_id(id);\n+            let def_id = tcx.hir().local_def_id(id);\n             let generics = tcx.generics_of(def_id);\n \n             let mut variances = solutions[start..start+generics.count()].to_vec();"}, {"sha": "6d45b1876244eade5820e9b22ed3de022608d3e2", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -91,7 +91,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     //\n     // - https://rust-lang.github.io/rustc-guide/query.html\n     // - https://rust-lang.github.io/rustc-guide/variance.html\n-    tcx.hir.krate().visit_all_item_likes(&mut terms_cx);\n+    tcx.hir().krate().visit_all_item_likes(&mut terms_cx);\n \n     terms_cx\n }\n@@ -106,14 +106,14 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n        .filter(|&(ref d,_)| d.is_some())\n        .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-       .filter_map(|(d, v)| tcx.hir.as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n+       .filter_map(|(d, v)| tcx.hir().as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n        .collect()\n }\n \n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferreds_for_item(&mut self, id: ast::NodeId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir.local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         let count = tcx.generics_of(def_id).count();\n \n         if count == 0 {\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         debug!(\"add_inferreds for item {}\",\n-               self.tcx.hir.node_to_string(item.id));\n+               self.tcx.hir().node_to_string(item.id));\n \n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |"}, {"sha": "7ae90e953e474562f949afc4d8154503ddcf5fad", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n \n pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir.krate().visit_all_item_likes(&mut VarianceTest { tcx });\n+    tcx.hir().krate().visit_all_item_likes(&mut VarianceTest { tcx });\n }\n \n struct VarianceTest<'a, 'tcx: 'a> {\n@@ -22,7 +22,7 @@ struct VarianceTest<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir.local_def_id(item.id);\n+        let item_def_id = self.tcx.hir().local_def_id(item.id);\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found."}, {"sha": "543df844cb86ec217fb555fb34568d4ec3b1428d", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n \n     pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n         get_def_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir.local_def_id(id);\n+            let did = self.cx.tcx.hir().local_def_id(id);\n             self.get_auto_trait_impls(did, &def_ctor, Some(name))\n         })\n     }"}, {"sha": "ed0056ed262515ec532b5de698995bb6f07c52ee", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n \n     pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n         get_def_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir.local_def_id(id);\n+            let did = self.cx.tcx.hir().local_def_id(id);\n             self.get_blanket_impls(did, &def_ctor, Some(name))\n         })\n     }"}, {"sha": "b14c36a59e84428fa2e51029a3d99dad5a894419", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -54,7 +54,7 @@ pub fn get_def_from_node_id<F>(cx: &DocContext,\n                                callback: &F,\n ) -> Vec<Item>\n where F: Fn(& dyn Fn(DefId) -> Def, String) -> Vec<Item> {\n-    let item = &cx.tcx.hir.expect_item(id).node;\n+    let item = &cx.tcx.hir().expect_item(id).node;\n \n     callback(&match *item {\n         hir::ItemKind::Struct(_, _) => Def::Struct,"}, {"sha": "217345548c8c943cb68fede8b9d9b60625eda71e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -303,8 +303,8 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n         }\n     }\n \n-    let for_ = if let Some(nodeid) = tcx.hir.as_local_node_id(did) {\n-        match tcx.hir.expect_item(nodeid).node {\n+    let for_ = if let Some(nodeid) = tcx.hir().as_local_node_id(did) {\n+        match tcx.hir().expect_item(nodeid).node {\n             hir::ItemKind::Impl(.., ref t, _) => {\n                 t.clean(cx)\n             }\n@@ -325,12 +325,12 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     }\n \n     let predicates = tcx.predicates_of(did);\n-    let (trait_items, generics) = if let Some(nodeid) = tcx.hir.as_local_node_id(did) {\n-        match tcx.hir.expect_item(nodeid).node {\n+    let (trait_items, generics) = if let Some(nodeid) = tcx.hir().as_local_node_id(did) {\n+        match tcx.hir().expect_item(nodeid).node {\n             hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {\n                 (\n                     item_ids.iter()\n-                            .map(|ii| tcx.hir.impl_item(ii.id).clean(cx))\n+                            .map(|ii| tcx.hir().impl_item(ii.id).clean(cx))\n                             .collect::<Vec<_>>(),\n                     gen.clean(cx),\n                 )\n@@ -420,8 +420,8 @@ fn build_module(cx: &DocContext, did: DefId, visited: &mut FxHashSet<DefId>) ->\n }\n \n pub fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    if let Some(node_id) = cx.tcx.hir.as_local_node_id(did) {\n-        cx.tcx.hir.node_to_pretty_string(node_id)\n+    if let Some(node_id) = cx.tcx.hir().as_local_node_id(did) {\n+        cx.tcx.hir().node_to_pretty_string(node_id)\n     } else {\n         cx.tcx.rendered_const(did)\n     }"}, {"sha": "ce7de0e3128549a09d3475fd8d3539aabe28be47", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -282,17 +282,17 @@ impl Clean<ExternalCrate> for CrateNum {\n             None\n         };\n         let primitives = if root.is_local() {\n-            cx.tcx.hir.krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir.expect_item(id.id);\n+            cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n+                let item = cx.tcx.hir().expect_item(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_primitive(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n+                        as_primitive(Def::Mod(cx.tcx.hir().local_def_id(id.id)))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n-                            (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -324,16 +324,16 @@ impl Clean<ExternalCrate> for CrateNum {\n             None\n         };\n         let keywords = if root.is_local() {\n-            cx.tcx.hir.krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir.expect_item(id.id);\n+            cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n+                let item = cx.tcx.hir().expect_item(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_keyword(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n+                        as_keyword(Def::Mod(cx.tcx.hir().local_def_id(id.id)))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_keyword(path.def).map(|(_, prim, attrs)| {\n-                            (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -629,7 +629,7 @@ impl Clean<Item> for doctree::Module {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items,\n@@ -1215,7 +1215,7 @@ impl Lifetime {\n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n         if self.id != ast::DUMMY_NODE_ID {\n-            let hir_id = cx.tcx.hir.node_to_hir_id(self.id);\n+            let hir_id = cx.tcx.hir().node_to_hir_id(self.id);\n             let def = cx.tcx.named_region(hir_id);\n             match def {\n                 Some(rl::Region::EarlyBound(_, node_id, _)) |\n@@ -1473,7 +1473,7 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n             }\n             hir::GenericParamKind::Type { ref default, synthetic, .. } => {\n                 (self.name.ident().name.clean(cx), GenericParamDefKind::Type {\n-                    did: cx.tcx.hir.local_def_id(self.id),\n+                    did: cx.tcx.hir().local_def_id(self.id),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),\n                     synthetic: synthetic,\n@@ -1684,7 +1684,7 @@ impl Clean<Item> for doctree::Function {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             inner: FunctionItem(Function {\n                 decl,\n                 generics,\n@@ -1733,7 +1733,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n     fn clean(&self, cx: &DocContext) -> Arguments {\n-        let body = cx.tcx.hir.body(self.1);\n+        let body = cx.tcx.hir().body(self.1);\n \n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n@@ -1762,7 +1762,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if cx.tcx.hir.as_local_node_id(did).is_some() {\n+        let mut names = if cx.tcx.hir().as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n             cx.tcx.fn_arg_names(did).into_iter()\n@@ -1857,7 +1857,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -1926,10 +1926,10 @@ impl Clean<Item> for hir::TraitItem {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: None,\n-            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n             inner,\n         }\n     }\n@@ -1958,10 +1958,10 @@ impl Clean<Item> for hir::ImplItem {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n             inner,\n         }\n     }\n@@ -2411,7 +2411,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n             TyKind::Array(ref ty, ref length) => {\n-                let def_id = cx.tcx.hir.local_def_id(length.id);\n+                let def_id = cx.tcx.hir().local_def_id(length.id);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = Substs::identity_for_item(cx.tcx, def_id);\n                 let cid = GlobalId {\n@@ -2426,7 +2426,7 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n-                let item = cx.tcx.hir.expect_item(item_id.id);\n+                let item = cx.tcx.hir().expect_item(item_id.id);\n                 if let hir::ItemKind::Existential(ref ty) = item.node {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n@@ -2447,9 +2447,9 @@ impl Clean<Type> for hir::Ty {\n                 let mut alias = None;\n                 if let Def::TyAlias(def_id) = path.def {\n                     // Substitute private type aliases\n-                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n+                    if let Some(node_id) = cx.tcx.hir().as_local_node_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n-                            alias = Some(&cx.tcx.hir.expect_item(node_id).node);\n+                            alias = Some(&cx.tcx.hir().expect_item(node_id).node);\n                         }\n                     }\n                 };\n@@ -2479,15 +2479,15 @@ impl Clean<Type> for hir::Ty {\n                                     if let Some(lt) = lifetime.cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id =\n-                                                cx.tcx.hir.local_def_id(param.id);\n+                                                cx.tcx.hir().local_def_id(param.id);\n                                             lt_substs.insert(lt_def_id, lt.clean(cx));\n                                         }\n                                     }\n                                     indices.lifetimes += 1;\n                                 }\n                                 hir::GenericParamKind::Type { ref default, .. } => {\n                                     let ty_param_def =\n-                                        Def::TyParam(cx.tcx.hir.local_def_id(param.id));\n+                                        Def::TyParam(cx.tcx.hir().local_def_id(param.id));\n                                     let mut j = 0;\n                                     let type_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2608,7 +2608,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n                     generic_params: Vec::new(),\n-                    decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n+                    decl: (cx.tcx.hir().local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n                     abi: sig.abi(),\n                 })\n             }\n@@ -2760,9 +2760,9 @@ impl Clean<Item> for hir::StructField {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n@@ -2834,7 +2834,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2854,7 +2854,7 @@ impl Clean<Item> for doctree::Union {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2901,7 +2901,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2928,7 +2928,7 @@ impl Clean<Item> for doctree::Variant {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.def.id()),\n+            def_id: cx.tcx.hir().local_def_id(self.def.id()),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -3205,7 +3205,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id.clone()),\n+            def_id: cx.tcx.hir().local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3229,7 +3229,7 @@ impl Clean<Item> for doctree::Existential {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id.clone()),\n+            def_id: cx.tcx.hir().local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3280,7 +3280,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3305,7 +3305,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3405,7 +3405,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3548,7 +3548,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+            def_id: cx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n@@ -3617,10 +3617,10 @@ impl Clean<Item> for hir::ForeignItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n             inner,\n         }\n     }\n@@ -3683,8 +3683,8 @@ fn name_from_pat(p: &hir::Pat) -> String {\n fn print_const(cx: &DocContext, n: &ty::Const) -> String {\n     match n.val {\n         ConstValue::Unevaluated(def_id, _) => {\n-            if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n-                print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n+            if let Some(node_id) = cx.tcx.hir().as_local_node_id(def_id) {\n+                print_const_expr(cx, cx.tcx.hir().body_owned_by(node_id))\n             } else {\n                 inline::print_inlined_const(cx, def_id)\n             }\n@@ -3703,7 +3703,7 @@ fn print_const(cx: &DocContext, n: &ty::Const) -> String {\n }\n \n fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n-    cx.tcx.hir.node_to_pretty_string(body.node_id)\n+    cx.tcx.hir().node_to_pretty_string(body.node_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n@@ -3829,7 +3829,7 @@ impl Clean<Item> for doctree::ProcMacro {\n             visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir.local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id),\n             inner: ProcMacroItem(ProcMacro {\n                 kind: self.kind,\n                 helpers: self.helpers.clean(cx),\n@@ -3943,18 +3943,18 @@ where\n // Start of code copied from rust-clippy\n \n pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let mut items = krate.module.item_ids.clone();\n     let mut path_it = path.iter().peekable();\n \n     loop {\n         let segment = path_it.next()?;\n \n         for item_id in mem::replace(&mut items, HirVec::new()).iter() {\n-            let item = tcx.hir.expect_item(item_id.id);\n+            let item = tcx.hir().expect_item(item_id.id);\n             if item.name == *segment {\n                 if path_it.peek().is_none() {\n-                    return Some(tcx.hir.local_def_id(item_id.id))\n+                    return Some(tcx.hir().local_def_id(item_id.id))\n                 }\n \n                 items = match &item.node {"}, {"sha": "047d35579444f643a6cbc75368aae1509eb513f0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocContext<'a, 'tcx, 'rcx, 'cstore> {\n         let start_def_id = {\n             let next_id = if crate_num == LOCAL_CRATE {\n                 self.tcx\n-                    .hir\n+                    .hir()\n                     .definitions()\n                     .def_path_table()\n                     .next_id(DefIndexAddressSpace::Low)\n@@ -168,7 +168,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocContext<'a, 'tcx, 'rcx, 'cstore> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n-            self.tcx.hir.as_local_node_id(def_id)\n+            self.tcx.hir().as_local_node_id(def_id)\n         }\n     }\n \n@@ -515,7 +515,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             // to the map from defid -> nodeid\n             let access_levels = AccessLevels {\n                 map: access_levels.map.iter()\n-                                    .map(|(&k, &v)| (tcx.hir.local_def_id(k), v))\n+                                    .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n                                     .collect()\n             };\n \n@@ -545,11 +545,11 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 generated_synthetics: Default::default(),\n                 all_traits: tcx.all_traits(LOCAL_CRATE).to_vec(),\n             };\n-            debug!(\"crate: {:?}\", tcx.hir.krate());\n+            debug!(\"crate: {:?}\", tcx.hir().krate());\n \n             let mut krate = {\n                 let mut v = RustdocVisitor::new(&ctxt);\n-                v.visit(tcx.hir.krate());\n+                v.visit(tcx.hir().krate());\n                 v.clean(&ctxt)\n             };\n "}, {"sha": "cbbcf92c6aa9e3ee06c76a062c0208f759a8b408", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_node_id = if item.is_mod() {\n-            if let Some(id) = self.cx.tcx.hir.as_local_node_id(item.def_id) {\n+            if let Some(id) = self.cx.tcx.hir().as_local_node_id(item.def_id) {\n                 Some(id)\n             } else {\n                 debug!(\"attempting to fold on a non-local item: {:?}\", item);\n@@ -231,7 +231,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n         let parent_node = self.cx.as_local_node_id(item.def_id).and_then(|node_id| {\n             // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n             // current resolve() implementation\n-            match self.cx.tcx.hir.get_module_parent_node(node_id) {\n+            match self.cx.tcx.hir().get_module_parent_node(node_id) {\n                 id if id != node_id => Some(id),\n                 _ => None,\n             }\n@@ -253,7 +253,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                     match parent_node.or(self.mod_ids.last().cloned()) {\n                         Some(parent) if parent != NodeId::from_u32(0) => {\n                             //FIXME: can we pull the parent module's name from elsewhere?\n-                            Some(self.cx.tcx.hir.name(parent).to_string())\n+                            Some(self.cx.tcx.hir().name(parent).to_string())\n                         }\n                         _ => None,\n                     }"}, {"sha": "8847fb8128eecacd69d7bdd02448018b23b551c7", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -127,8 +127,8 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext) -> Crate {\n     // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n     // doesn't work with it anyway, so pull them from the HIR map instead\n     for &trait_did in cx.all_traits.iter() {\n-        for &impl_node in cx.tcx.hir.trait_impls(trait_did) {\n-            let impl_did = cx.tcx.hir.local_def_id(impl_node);\n+        for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n+            let impl_did = cx.tcx.hir().local_def_id(impl_node);\n             inline::build_impl(cx, impl_did, &mut new_items);\n         }\n     }\n@@ -165,7 +165,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for SyntheticImplCollector<'a, 'tcx, 'rc\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             if let (Some(node_id), Some(name)) =\n-                (self.cx.tcx.hir.as_local_node_id(i.def_id), i.name.clone())\n+                (self.cx.tcx.hir().as_local_node_id(i.def_id), i.name.clone())\n             {\n                 self.impls.extend(get_auto_traits_with_node_id(self.cx, node_id, name.clone()));\n                 self.impls.extend(get_blanket_impls_with_node_id(self.cx, node_id, name));"}, {"sha": "fc7e8d72d6997f045176258bb3bd8ca6b6405d71", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -79,12 +79,12 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx.hir.opt_local_def_id(id)\n+        self.cx.tcx.hir().opt_local_def_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_stability(def_id)).cloned()\n     }\n \n     fn deprecation(&self, id: ast::NodeId) -> Option<attr::Deprecation> {\n-        self.cx.tcx.hir.opt_local_def_id(id)\n+        self.cx.tcx.hir().opt_local_def_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n@@ -257,7 +257,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n         for i in &m.item_ids {\n-            let item = self.cx.tcx.hir.expect_item(i.id);\n+            let item = self.cx.tcx.hir().expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -282,9 +282,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                           please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n-            while let Some(id) = cx.tcx.hir.get_enclosing_scope(node) {\n+            while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir.attrs(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.hir().attrs(node).lists(\"doc\").has_word(\"hidden\") {\n                     return true;\n                 }\n                 if node == ast::CRATE_NODE_ID {\n@@ -302,7 +302,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         }\n         let def_did = def.def_id();\n \n-        let use_attrs = tcx.hir.attrs(id);\n+        let use_attrs = tcx.hir().attrs(id);\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n                            use_attrs.lists(\"doc\").has_word(\"hidden\");\n@@ -335,7 +335,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             return false\n         }\n \n-        let def_node_id = match tcx.hir.as_local_node_id(def_did) {\n+        let def_node_id = match tcx.hir().as_local_node_id(def_did) {\n             Some(n) => n, None => return false\n         };\n \n@@ -349,11 +349,11 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n \n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n-        let ret = match tcx.hir.get(def_node_id) {\n+        let ret = match tcx.hir().get(def_node_id) {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n-                    let i = self.cx.tcx.hir.expect_item(i.id);\n+                    let i = self.cx.tcx.hir().expect_item(i.id);\n                     self.visit_item(i, None, om);\n                 }\n                 self.inlining = prev;\n@@ -368,7 +368,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             Node::ForeignItem(it) if !glob => {\n                 // generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n-                    abi: tcx.hir.get_foreign_abi(it.id),\n+                    abi: tcx.hir().get_foreign_abi(it.id),\n                     items: vec![hir::ForeignItem {\n                         name: renamed.unwrap_or(it.name),\n                         .. it.clone()\n@@ -392,7 +392,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         let name = renamed.unwrap_or(item.name);\n \n         if item.vis.node.is_pub() {\n-            let def_id = self.cx.tcx.hir.local_def_id(item.id);\n+            let def_id = self.cx.tcx.hir().local_def_id(item.id);\n             self.store_path(def_id);\n         }\n \n@@ -412,7 +412,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::ExternCrate(orig_name) => {\n-                let def_id = self.cx.tcx.hir.local_def_id(item.id);\n+                let def_id = self.cx.tcx.hir().local_def_id(item.id);\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n                                 .unwrap_or(LOCAL_CRATE),\n@@ -540,7 +540,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             },\n             hir::ItemKind::Trait(is_auto, unsafety, ref gen, ref b, ref item_ids) => {\n                 let items = item_ids.iter()\n-                                    .map(|ti| self.cx.tcx.hir.trait_item(ti.id).clone())\n+                                    .map(|ti| self.cx.tcx.hir().trait_item(ti.id).clone())\n                                     .collect();\n                 let t = Trait {\n                     is_auto,\n@@ -573,7 +573,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 // them up regardless of where they're located.\n                 if !self.inlining && tr.is_none() {\n                     let items = item_ids.iter()\n-                                        .map(|ii| self.cx.tcx.hir.impl_item(ii.id).clone())\n+                                        .map(|ii| self.cx.tcx.hir().impl_item(ii.id).clone())\n                                         .collect();\n                     let i = Impl {\n                         unsafety,\n@@ -608,7 +608,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         let matchers = tts.chunks(4).map(|arm| arm[0].span()).collect();\n \n         Macro {\n-            def_id: self.cx.tcx.hir.local_def_id(def.id),\n+            def_id: self.cx.tcx.hir().local_def_id(def.id),\n             attrs: def.attrs.clone(),\n             name: renamed.unwrap_or(def.name),\n             whence: def.span,"}, {"sha": "7a7dd963e0d2340336647f4c6343a352a7c67cbc", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70babed03d58d042024e41f0a46f7e33e34d0d1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=a70babed03d58d042024e41f0a46f7e33e34d0d1", "patch": "@@ -56,9 +56,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 span: source_map::Span,\n                 id: ast::NodeId) {\n \n-        let item = match cx.tcx.hir.get(id) {\n+        let item = match cx.tcx.hir().get(id) {\n             Node::Item(item) => item,\n-            _ => cx.tcx.hir.expect_item(cx.tcx.hir.get_parent(id)),\n+            _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent(id)),\n         };\n \n         if !attr::contains_name(&item.attrs, \"whitelisted_attr\") {"}]}