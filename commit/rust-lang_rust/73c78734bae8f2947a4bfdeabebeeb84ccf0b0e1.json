{"sha": "73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYzc4NzM0YmFlOGYyOTQ3YTRiZmRlYWJlYmVlYjg0Y2NmMGIwZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-05T18:45:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-05T18:45:01Z"}, "message": "Auto merge of #52800 - QuietMisdreavus:do-not-pass-go, r=GuillaumeGomez\n\nrustdoc: refactor how passes are structured, and turn intra-doc-link collection into a pass\n\nThis builds on https://github.com/rust-lang/rust/pull/52751 and should not be merged until that finally finishes the bors queue\n\nPart 2 of my passes refactor. This introduces the concept of an \"early pass\", which is run right before exiting the compiler context. This is important for passes that may want to ask the compiler about things. For example, i took out the intra-doc-link collection and turned it into a early pass. I also made the `strip-hidden`, `strip-private` and `strip-priv-imports` passes occur as early passes, so that intra-doc-link collection wouldn't run on docs that weren't getting printed.\n\nFixes https://github.com/rust-lang/rust/issues/51684, technically https://github.com/rust-lang/rust/issues/51468 too but that version of `h2` hits a legit intra-link error after that `>_>`\n\nr? @rust-lang/rustdoc", "tree": {"sha": "ba666b97c4fb190ee2bff2ff7662913f748c99ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba666b97c4fb190ee2bff2ff7662913f748c99ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "html_url": "https://github.com/rust-lang/rust/commit/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93a4cab45ad119003c9749861eb7ac749eb334e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/93a4cab45ad119003c9749861eb7ac749eb334e2", "html_url": "https://github.com/rust-lang/rust/commit/93a4cab45ad119003c9749861eb7ac749eb334e2"}, {"sha": "e332985c03e583cb0e28f576af3102cc69ddec5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e332985c03e583cb0e28f576af3102cc69ddec5b", "html_url": "https://github.com/rust-lang/rust/commit/e332985c03e583cb0e28f576af3102cc69ddec5b"}], "stats": {"total": 1571, "additions": 899, "deletions": 672}, "files": [{"sha": "ad774f9860264b1f035c250779ae9afb3f1fdbbe", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 551, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -19,14 +19,12 @@ pub use self::FunctionRetTy::*;\n pub use self::Visibility::{Public, Inherited};\n \n use rustc_target::spec::abi::Abi;\n-use syntax;\n-use syntax::ast::{self, AttrStyle, Name, NodeId, Ident};\n+use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n use syntax::codemap::{dummy_spanned, Spanned};\n-use syntax::feature_gate::UnstableFeatures;\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n \n use rustc::mir::interpret::ConstValue;\n@@ -38,14 +36,12 @@ use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n-use rustc::lint as lint;\n \n use std::collections::hash_map::Entry;\n use std::fmt;\n@@ -59,14 +55,12 @@ use std::str::FromStr;\n use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n-use std::ops::Range;\n \n use core::{self, DocContext};\n use doctree;\n use visit_ast;\n use html::render::{cache, ExternalLocation};\n use html::item_type::ItemType;\n-use html::markdown::markdown_links;\n \n pub mod inline;\n pub mod cfg;\n@@ -580,32 +574,7 @@ impl Clean<Item> for doctree::Module {\n         // maintain a stack of mod ids, for doc comment path resolution\n         // but we also need to resolve the module's own docs based on whether its docs were written\n         // inside or outside the module, so check for that\n-        let attrs = if self.attrs.iter()\n-                                 .filter(|a| a.check_name(\"doc\"))\n-                                 .next()\n-                                 .map_or(true, |a| a.style == AttrStyle::Inner) {\n-            // inner doc comment, use the module's own scope for resolution\n-            if self.id != NodeId::new(0) {\n-                *cx.current_item_name.borrow_mut() = Some(cx.tcx.hir.name(self.id));\n-            } else {\n-                *cx.current_item_name.borrow_mut() = None;\n-            }\n-            cx.mod_ids.borrow_mut().push(self.id);\n-            self.attrs.clean(cx)\n-        } else {\n-            // outer doc comment, use its parent's scope\n-            match cx.mod_ids.borrow().last() {\n-                Some(parent) if *parent != NodeId::new(0) => {\n-                    *cx.current_item_name.borrow_mut() = Some(cx.tcx.hir.name(*parent));\n-                }\n-                _ => {\n-                    *cx.current_item_name.borrow_mut() = None;\n-                }\n-            }\n-            let attrs = self.attrs.clean(cx);\n-            cx.mod_ids.borrow_mut().push(self.id);\n-            attrs\n-        };\n+        let attrs = self.attrs.clean(cx);\n \n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n@@ -624,8 +593,6 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n \n-        cx.mod_ids.borrow_mut().pop();\n-\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n@@ -785,6 +752,7 @@ pub struct Attributes {\n     pub span: Option<syntax_pos::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n     pub links: Vec<(String, Option<DefId>, Option<String>)>,\n+    pub inner_docs: bool,\n }\n \n impl Attributes {\n@@ -929,12 +897,18 @@ impl Attributes {\n             }\n         }\n \n+        let inner_docs = attrs.iter()\n+                              .filter(|a| a.check_name(\"doc\"))\n+                              .next()\n+                              .map_or(true, |a| a.style == AttrStyle::Inner);\n+\n         Attributes {\n             doc_strings,\n             other_attrs,\n             cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n             span: sp,\n             links: vec![],\n+            inner_docs,\n         }\n     }\n \n@@ -1027,487 +1001,9 @@ impl AttributesExt for Attributes {\n     }\n }\n \n-/// Given a def, returns its name and disambiguator\n-/// for a value namespace\n-///\n-/// Returns None for things which cannot be ambiguous since\n-/// they exist in both namespaces (structs and modules)\n-fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n-    match def {\n-        // structs, variants, and mods exist in both namespaces. skip them\n-        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) | Def::VariantCtor(..) => None,\n-        Def::Fn(..)\n-            => Some((\"function\", format!(\"{}()\", path_str))),\n-        Def::Method(..)\n-            => Some((\"method\", format!(\"{}()\", path_str))),\n-        Def::Const(..)\n-            => Some((\"const\", format!(\"const@{}\", path_str))),\n-        Def::Static(..)\n-            => Some((\"static\", format!(\"static@{}\", path_str))),\n-        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n-    }\n-}\n-\n-/// Given a def, returns its name, the article to be used, and a disambiguator\n-/// for the type namespace\n-fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n-    let (kind, article) = match def {\n-        // we can still have non-tuple structs\n-        Def::Struct(..) => (\"struct\", \"a\"),\n-        Def::Enum(..) => (\"enum\", \"an\"),\n-        Def::Trait(..) => (\"trait\", \"a\"),\n-        Def::Union(..) => (\"union\", \"a\"),\n-        _ => (\"type\", \"a\"),\n-    };\n-    (kind, article, format!(\"{}@{}\", kind, path_str))\n-}\n-\n-fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n-    if attrs.doc_strings.is_empty() {\n-        return DUMMY_SP;\n-    }\n-    let start = attrs.doc_strings[0].span();\n-    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n-    start.to(end)\n-}\n-\n-fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n-                   path_str: &str,\n-                   article1: &str, kind1: &str, disambig1: &str,\n-                   article2: &str, kind2: &str, disambig2: &str) {\n-    let sp = span_of_attrs(attrs);\n-    cx.sess()\n-      .struct_span_warn(sp,\n-                        &format!(\"`{}` is both {} {} and {} {}\",\n-                                 path_str, article1, kind1,\n-                                 article2, kind2))\n-      .help(&format!(\"try `{}` if you want to select the {}, \\\n-                      or `{}` if you want to \\\n-                      select the {}\",\n-                      disambig1, kind1, disambig2,\n-                      kind2))\n-      .emit();\n-}\n-\n-/// Given an enum variant's def, return the def of its enum and the associated fragment\n-fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n-    use rustc::ty::DefIdTree;\n-\n-    let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n-        parent\n-    } else {\n-        return Err(())\n-    };\n-    let parent_def = Def::Enum(parent);\n-    let variant = cx.tcx.expect_variant_def(def);\n-    Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n-}\n-\n-const PRIMITIVES: &[(&str, Def)] = &[\n-    (\"u8\",    Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U8))),\n-    (\"u16\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U16))),\n-    (\"u32\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U32))),\n-    (\"u64\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U64))),\n-    (\"u128\",  Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U128))),\n-    (\"usize\", Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::Usize))),\n-    (\"i8\",    Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I8))),\n-    (\"i16\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I16))),\n-    (\"i32\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I32))),\n-    (\"i64\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I64))),\n-    (\"i128\",  Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I128))),\n-    (\"isize\", Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::Isize))),\n-    (\"f32\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F32))),\n-    (\"f64\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F64))),\n-    (\"str\",   Def::PrimTy(hir::PrimTy::TyStr)),\n-    (\"bool\",  Def::PrimTy(hir::PrimTy::TyBool)),\n-    (\"char\",  Def::PrimTy(hir::PrimTy::TyChar)),\n-];\n-\n-fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n-    if is_val {\n-        None\n-    } else {\n-        PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n-    }\n-}\n-\n-/// Resolve a given string as a path, along with whether or not it is\n-/// in the value namespace. Also returns an optional URL fragment in the case\n-/// of variants and methods\n-fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option<String>), ()> {\n-    // In case we're in a module, try to resolve the relative\n-    // path\n-    if let Some(id) = cx.mod_ids.borrow().last() {\n-        let result = cx.resolver.borrow_mut()\n-                                .with_scope(*id,\n-            |resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP,\n-                                                &path_str, is_val)\n-        });\n-\n-        if let Ok(result) = result {\n-            // In case this is a trait item, skip the\n-            // early return and try looking for the trait\n-            let value = match result.def {\n-                Def::Method(_) | Def::AssociatedConst(_) => true,\n-                Def::AssociatedTy(_) => false,\n-                Def::Variant(_) => return handle_variant(cx, result.def),\n-                // not a trait item, just return what we found\n-                _ => return Ok((result.def, None))\n-            };\n-\n-            if value != is_val {\n-                return Err(())\n-            }\n-        } else if let Some(prim) = is_primitive(path_str, is_val) {\n-            return Ok((prim, Some(path_str.to_owned())))\n-        } else {\n-            // If resolution failed, it may still be a method\n-            // because methods are not handled by the resolver\n-            // If so, bail when we're not looking for a value\n-            if !is_val {\n-                return Err(())\n-            }\n-        }\n-\n-        // Try looking for methods and associated items\n-        let mut split = path_str.rsplitn(2, \"::\");\n-        let item_name = if let Some(first) = split.next() {\n-            first\n-        } else {\n-            return Err(())\n-        };\n-\n-        let mut path = if let Some(second) = split.next() {\n-            second.to_owned()\n-        } else {\n-            return Err(())\n-        };\n-\n-        if path == \"self\" || path == \"Self\" {\n-            if let Some(name) = *cx.current_item_name.borrow() {\n-                path = name.to_string();\n-            }\n-        }\n-\n-        let ty = cx.resolver.borrow_mut()\n-                            .with_scope(*id,\n-            |resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n-        })?;\n-        match ty.def {\n-            Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n-                let item = cx.tcx.inherent_impls(did)\n-                                 .iter()\n-                                 .flat_map(|imp| cx.tcx.associated_items(*imp))\n-                                 .find(|item| item.ident.name == item_name);\n-                if let Some(item) = item {\n-                    let out = match item.kind {\n-                        ty::AssociatedKind::Method if is_val => \"method\",\n-                        ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n-                        _ => return Err(())\n-                    };\n-                    Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n-                } else {\n-                    match cx.tcx.type_of(did).sty {\n-                        ty::TyAdt(def, _) => {\n-                            if let Some(item) = if def.is_enum() {\n-                                def.all_fields().find(|item| item.ident.name == item_name)\n-                            } else {\n-                                def.non_enum_variant()\n-                                   .fields\n-                                   .iter()\n-                                   .find(|item| item.ident.name == item_name)\n-                            } {\n-                                Ok((ty.def,\n-                                    Some(format!(\"{}.{}\",\n-                                                 if def.is_enum() {\n-                                                     \"variant\"\n-                                                 } else {\n-                                                     \"structfield\"\n-                                                 },\n-                                                 item.ident))))\n-                            } else {\n-                                Err(())\n-                            }\n-                        }\n-                        _ => Err(()),\n-                    }\n-                }\n-            }\n-            Def::Trait(did) => {\n-                let item = cx.tcx.associated_item_def_ids(did).iter()\n-                             .map(|item| cx.tcx.associated_item(*item))\n-                             .find(|item| item.ident.name == item_name);\n-                if let Some(item) = item {\n-                    let kind = match item.kind {\n-                        ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n-                        ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n-                        ty::AssociatedKind::Method if is_val => {\n-                            if item.defaultness.has_value() {\n-                                \"method\"\n-                            } else {\n-                                \"tymethod\"\n-                            }\n-                        }\n-                        _ => return Err(())\n-                    };\n-\n-                    Ok((ty.def, Some(format!(\"{}.{}\", kind, item_name))))\n-                } else {\n-                    Err(())\n-                }\n-            }\n-            _ => Err(())\n-        }\n-    } else {\n-        Err(())\n-    }\n-}\n-\n-/// Resolve a string as a macro\n-fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n-    use syntax::ext::base::{MacroKind, SyntaxExtension};\n-    use syntax::ext::hygiene::Mark;\n-    let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n-    let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n-    let mut resolver = cx.resolver.borrow_mut();\n-    let mark = Mark::root();\n-    let res = resolver\n-        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n-    if let Ok(def) = res {\n-        if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n-            return Some(def);\n-        }\n-    }\n-    if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n-        return Some(*def);\n-    }\n-    None\n-}\n-\n-#[derive(Debug)]\n-enum PathKind {\n-    /// can be either value or type, not a macro\n-    Unknown,\n-    /// macro\n-    Macro,\n-    /// values, functions, consts, statics, everything in the value namespace\n-    Value,\n-    /// types, traits, everything in the type namespace\n-    Type,\n-}\n-\n-fn resolution_failure(\n-    cx: &DocContext,\n-    attrs: &Attributes,\n-    path_str: &str,\n-    dox: &str,\n-    link_range: Option<Range<usize>>,\n-) {\n-    let sp = span_of_attrs(attrs);\n-    let msg = format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str);\n-\n-    let code_dox = sp.to_src(cx);\n-\n-    let doc_comment_padding = 3;\n-    let mut diag = if let Some(link_range) = link_range {\n-        // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-        //                       ^    ~~~~~~\n-        //                       |    link_range\n-        //                       last_new_line_offset\n-\n-        let mut diag;\n-        if dox.lines().count() == code_dox.lines().count() {\n-            let line_offset = dox[..link_range.start].lines().count();\n-            // The span starts in the `///`, so we don't have to account for the leading whitespace\n-            let code_dox_len = if line_offset <= 1 {\n-                doc_comment_padding\n-            } else {\n-                // The first `///`\n-                doc_comment_padding +\n-                    // Each subsequent leading whitespace and `///`\n-                    code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {\n-                        sum + doc_comment_padding + line.len() - line.trim().len()\n-                    })\n-            };\n-\n-            // Extract the specific span\n-            let sp = sp.from_inner_byte_pos(\n-                link_range.start + code_dox_len,\n-                link_range.end + code_dox_len,\n-            );\n-\n-            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                                NodeId::new(0),\n-                                                sp,\n-                                                &msg);\n-            diag.span_label(sp, \"cannot be resolved, ignoring\");\n-        } else {\n-            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                                NodeId::new(0),\n-                                                sp,\n-                                                &msg);\n-\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-            // Print the line containing the `link_range` and manually mark it with '^'s\n-            diag.note(&format!(\n-                \"the link appears in this line:\\n\\n{line}\\n\\\n-                 {indicator: <before$}{indicator:^<found$}\",\n-                line=line,\n-                indicator=\"\",\n-                before=link_range.start - last_new_line_offset,\n-                found=link_range.len(),\n-            ));\n-        }\n-        diag\n-    } else {\n-        cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                     NodeId::new(0),\n-                                     sp,\n-                                     &msg)\n-    };\n-    diag.help(\"to escape `[` and `]` characters, just add '\\\\' before them like \\\n-               `\\\\[` or `\\\\]`\");\n-    diag.emit();\n-}\n-\n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext) -> Attributes {\n-        let mut attrs = Attributes::from_ast(cx.sess().diagnostic(), self);\n-\n-        if UnstableFeatures::from_environment().is_nightly_build() {\n-            let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n-            for (ori_link, link_range) in markdown_links(&dox) {\n-                // bail early for real links\n-                if ori_link.contains('/') {\n-                    continue;\n-                }\n-                let link = ori_link.replace(\"`\", \"\");\n-                let (def, fragment) = {\n-                    let mut kind = PathKind::Unknown;\n-                    let path_str = if let Some(prefix) =\n-                        [\"struct@\", \"enum@\", \"type@\",\n-                         \"trait@\", \"union@\"].iter()\n-                                          .find(|p| link.starts_with(**p)) {\n-                        kind = PathKind::Type;\n-                        link.trim_left_matches(prefix)\n-                    } else if let Some(prefix) =\n-                        [\"const@\", \"static@\",\n-                         \"value@\", \"function@\", \"mod@\",\n-                         \"fn@\", \"module@\", \"method@\"]\n-                            .iter().find(|p| link.starts_with(**p)) {\n-                        kind = PathKind::Value;\n-                        link.trim_left_matches(prefix)\n-                    } else if link.ends_with(\"()\") {\n-                        kind = PathKind::Value;\n-                        link.trim_right_matches(\"()\")\n-                    } else if link.starts_with(\"macro@\") {\n-                        kind = PathKind::Macro;\n-                        link.trim_left_matches(\"macro@\")\n-                    } else if link.ends_with('!') {\n-                        kind = PathKind::Macro;\n-                        link.trim_right_matches('!')\n-                    } else {\n-                        &link[..]\n-                    }.trim();\n-\n-                    if path_str.contains(|ch: char| !(ch.is_alphanumeric() ||\n-                                                      ch == ':' || ch == '_')) {\n-                        continue;\n-                    }\n-\n-                    match kind {\n-                        PathKind::Value => {\n-                            if let Ok(def) = resolve(cx, path_str, true) {\n-                                def\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                // this could just be a normal link or a broken link\n-                                // we could potentially check if something is\n-                                // \"intra-doc-link-like\" and warn in that case\n-                                continue;\n-                            }\n-                        }\n-                        PathKind::Type => {\n-                            if let Ok(def) = resolve(cx, path_str, false) {\n-                                def\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                // this could just be a normal link\n-                                continue;\n-                            }\n-                        }\n-                        PathKind::Unknown => {\n-                            // try everything!\n-                            if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                                if let Ok(type_def) = resolve(cx, path_str, false) {\n-                                    let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_def.0, path_str);\n-                                    ambiguity_error(cx, &attrs, path_str,\n-                                                    article, type_kind, &type_disambig,\n-                                                    \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                                    continue;\n-                                } else if let Ok(value_def) = resolve(cx, path_str, true) {\n-                                    let (value_kind, value_disambig)\n-                                        = value_ns_kind(value_def.0, path_str)\n-                                            .expect(\"struct and mod cases should have been \\\n-                                                     caught in previous branch\");\n-                                    ambiguity_error(cx, &attrs, path_str,\n-                                                    \"a\", value_kind, &value_disambig,\n-                                                    \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                                }\n-                                (macro_def, None)\n-                            } else if let Ok(type_def) = resolve(cx, path_str, false) {\n-                                // It is imperative we search for not-a-value first\n-                                // Otherwise we will find struct ctors for when we are looking\n-                                // for structs, and the link won't work.\n-                                // if there is something in both namespaces\n-                                if let Ok(value_def) = resolve(cx, path_str, true) {\n-                                    let kind = value_ns_kind(value_def.0, path_str);\n-                                    if let Some((value_kind, value_disambig)) = kind {\n-                                        let (type_kind, article, type_disambig)\n-                                            = type_ns_kind(type_def.0, path_str);\n-                                        ambiguity_error(cx, &attrs, path_str,\n-                                                        article, type_kind, &type_disambig,\n-                                                        \"a\", value_kind, &value_disambig);\n-                                        continue;\n-                                    }\n-                                }\n-                                type_def\n-                            } else if let Ok(value_def) = resolve(cx, path_str, true) {\n-                                value_def\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                // this could just be a normal link\n-                                continue;\n-                            }\n-                        }\n-                        PathKind::Macro => {\n-                            if let Some(def) = macro_resolve(cx, path_str) {\n-                                (def, None)\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                continue\n-                            }\n-                        }\n-                    }\n-                };\n-\n-                if let Def::PrimTy(_) = def {\n-                    attrs.links.push((ori_link, None, fragment));\n-                } else {\n-                    let id = register_def(cx, def);\n-                    attrs.links.push((ori_link, Some(id), fragment));\n-                }\n-            }\n-\n-            cx.sess().abort_if_errors();\n-        }\n-\n-        attrs\n+        Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n \n@@ -2165,7 +1661,6 @@ impl Clean<Item> for doctree::Function {\n             (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n         });\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2340,7 +1835,6 @@ pub struct Trait {\n \n impl Clean<Item> for doctree::Trait {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n         Item {\n@@ -2412,7 +1906,6 @@ impl Clean<Item> for hir::TraitItem {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n-        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2445,7 +1938,6 @@ impl Clean<Item> for hir::ImplItem {\n                 generics: Generics::default(),\n             }, true),\n         };\n-        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n@@ -3239,7 +2731,6 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n@@ -3319,7 +2810,6 @@ impl Clean<Vec<Item>> for doctree::Struct {\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n         ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3346,7 +2836,6 @@ impl Clean<Vec<Item>> for doctree::Union {\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n         ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3400,7 +2889,6 @@ impl Clean<Vec<Item>> for doctree::Enum {\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n         ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3427,7 +2915,6 @@ pub struct Variant {\n \n impl Clean<Item> for doctree::Variant {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3708,7 +3195,6 @@ pub struct Typedef {\n \n impl Clean<Item> for doctree::Typedef {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3784,7 +3270,6 @@ pub struct Static {\n impl Clean<Item> for doctree::Static {\n     fn clean(&self, cx: &DocContext) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3810,7 +3295,6 @@ pub struct Constant {\n \n impl Clean<Item> for doctree::Constant {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3892,23 +3376,6 @@ pub fn get_blanket_impls_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n     finder.get_with_def_id(id)\n }\n \n-fn get_name_if_possible(cx: &DocContext, node: NodeId) -> Option<Name> {\n-    match cx.tcx.hir.get(node) {\n-        Node::NodeItem(_) |\n-        Node::NodeForeignItem(_) |\n-        Node::NodeImplItem(_) |\n-        Node::NodeTraitItem(_) |\n-        Node::NodeVariant(_) |\n-        Node::NodeField(_) |\n-        Node::NodeLifetime(_) |\n-        Node::NodeGenericParam(_) |\n-        Node::NodeBinding(&hir::Pat { node: hir::PatKind::Binding(_,_,_,_), .. }) |\n-        Node::NodeStructCtor(_) => {}\n-        _ => return None,\n-    }\n-    Some(cx.tcx.hir.name(node))\n-}\n-\n impl Clean<Vec<Item>> for doctree::Impl {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let mut ret = Vec::new();\n@@ -3928,7 +3395,6 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                   .collect()\n         }).unwrap_or(FxHashSet());\n \n-        *cx.current_item_name.borrow_mut() = get_name_if_possible(cx, self.for_.id);\n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -4016,7 +3482,6 @@ fn build_deref_target_impls(cx: &DocContext,\n \n impl Clean<Item> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -4064,7 +3529,6 @@ impl Clean<Vec<Item>> for doctree::Import {\n             Import::Simple(name.clean(cx), resolve_use_source(cx, path))\n         };\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         vec![Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -4134,7 +3598,6 @@ impl Clean<Item> for hir::ForeignItem {\n             }\n         };\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -4150,7 +3613,7 @@ impl Clean<Item> for hir::ForeignItem {\n \n // Utilities\n \n-trait ToSource {\n+pub trait ToSource {\n     fn to_src(&self, cx: &DocContext) -> String;\n }\n \n@@ -4260,7 +3723,7 @@ fn resolve_type(cx: &DocContext,\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n-fn register_def(cx: &DocContext, def: Def) -> DefId {\n+pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n     let (did, kind) = match def {\n@@ -4311,7 +3774,6 @@ pub struct Macro {\n impl Clean<Item> for doctree::Macro {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let name = self.name.clean(cx);\n-        *cx.current_item_name.borrow_mut() = None;\n         Item {\n             name: Some(name.clone()),\n             attrs: self.attrs.clean(cx),"}, {"sha": "86e5bbeab706a2dafa72c089270bd171ec9373df", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -26,7 +26,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{self, Ident, Name, NodeId};\n+use syntax::ast::{self, Ident};\n use syntax::codemap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n@@ -45,8 +45,9 @@ use std::path::PathBuf;\n \n use visit_ast::RustdocVisitor;\n use clean;\n-use clean::{get_path_for_type, Clean, MAX_DEF_ID};\n+use clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n use html::render::RenderInfo;\n+use passes;\n \n pub use rustc::session::config::{Input, Options, CodegenOptions};\n pub use rustc::session::search_paths::SearchPaths;\n@@ -57,7 +58,6 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub resolver: &'a RefCell<resolve::Resolver<'rcx, 'cstore>>,\n     /// The stack of module NodeIds up till this point\n-    pub mod_ids: RefCell<Vec<NodeId>>,\n     pub crate_name: Option<String>,\n     pub cstore: Rc<CStore>,\n     pub populated_all_crate_impls: Cell<bool>,\n@@ -87,7 +87,6 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n     /// Maps (type_id, trait_id) -> auto trait impl\n     pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>,\n-    pub current_item_name: RefCell<Option<Name>>,\n     pub all_traits: Vec<DefId>,\n }\n \n@@ -322,7 +321,10 @@ pub fn run_core(search_paths: SearchPaths,\n                 error_format: ErrorOutputType,\n                 cmd_lints: Vec<(String, lint::Level)>,\n                 lint_cap: Option<lint::Level>,\n-                describe_lints: bool) -> (clean::Crate, RenderInfo)\n+                describe_lints: bool,\n+                mut manual_passes: Vec<String>,\n+                mut default_passes: passes::DefaultPassOption)\n+    -> (clean::Crate, RenderInfo, Vec<String>)\n {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -517,23 +519,86 @@ pub fn run_core(search_paths: SearchPaths,\n                 ty_substs: Default::default(),\n                 lt_substs: Default::default(),\n                 impl_trait_bounds: Default::default(),\n-                mod_ids: Default::default(),\n                 send_trait: send_trait,\n                 fake_def_ids: RefCell::new(FxHashMap()),\n                 all_fake_def_ids: RefCell::new(FxHashSet()),\n                 generated_synthetics: RefCell::new(FxHashSet()),\n-                current_item_name: RefCell::new(None),\n                 all_traits: tcx.all_traits(LOCAL_CRATE).to_vec(),\n             };\n             debug!(\"crate: {:?}\", tcx.hir.krate());\n \n-            let krate = {\n+            let mut krate = {\n                 let mut v = RustdocVisitor::new(&ctxt);\n                 v.visit(tcx.hir.krate());\n                 v.clean(&ctxt)\n             };\n \n-            (krate, ctxt.renderinfo.into_inner())\n+            fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n+                let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\\n+                                                         considered deprecated\", name));\n+                msg.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n+\n+                if name == \"no_default_passes\" {\n+                    msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n+                }\n+\n+                msg.emit();\n+            }\n+\n+            // Process all of the crate attributes, extracting plugin metadata along\n+            // with the passes which we are supposed to run.\n+            for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n+                let diag = ctxt.sess().diagnostic();\n+\n+                let name = attr.name().map(|s| s.as_str());\n+                let name = name.as_ref().map(|s| &s[..]);\n+                if attr.is_word() {\n+                    if name == Some(\"no_default_passes\") {\n+                        report_deprecated_attr(\"no_default_passes\", diag);\n+                        if default_passes == passes::DefaultPassOption::Default {\n+                            default_passes = passes::DefaultPassOption::None;\n+                        }\n+                    }\n+                } else if let Some(value) = attr.value_str() {\n+                    let sink = match name {\n+                        Some(\"passes\") => {\n+                            report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n+                            &mut manual_passes\n+                        },\n+                        Some(\"plugins\") => {\n+                            report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n+                            eprintln!(\"WARNING: #![doc(plugins = \\\"...\\\")] no longer functions; \\\n+                                      see CVE-2018-1000622\");\n+                            continue\n+                        },\n+                        _ => continue,\n+                    };\n+                    for p in value.as_str().split_whitespace() {\n+                        sink.push(p.to_string());\n+                    }\n+                }\n+\n+                if attr.is_word() && name == Some(\"document_private_items\") {\n+                    if default_passes == passes::DefaultPassOption::Default {\n+                        default_passes = passes::DefaultPassOption::Private;\n+                    }\n+                }\n+            }\n+\n+            let mut passes: Vec<String> =\n+                passes::defaults(default_passes).iter().map(|p| p.to_string()).collect();\n+            passes.extend(manual_passes);\n+\n+            for pass in &passes {\n+                // the \"unknown pass\" error will be reported when late passes are run\n+                if let Some(pass) = passes::find_pass(pass).and_then(|p| p.early_fn()) {\n+                    krate = pass(krate, &ctxt);\n+                }\n+            }\n+\n+            ctxt.sess().abort_if_errors();\n+\n+            (krate, ctxt.renderinfo.into_inner(), passes)\n         }), &sess)\n     })\n }"}, {"sha": "bd7f7386fd14b6aa7ce56898ee182dd592460d81", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 15, "deletions": 63, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -26,6 +26,7 @@\n #![feature(entry_and_modify)]\n #![feature(ptr_offset_from)]\n #![feature(crate_visibility_modifier)]\n+#![feature(const_fn)]\n \n #![recursion_limit=\"256\"]\n \n@@ -96,8 +97,6 @@ mod visit_lib;\n mod test;\n mod theme;\n \n-use clean::AttributesExt;\n-\n struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n@@ -367,8 +366,8 @@ fn main_args(args: &[String]) -> isize {\n \n     if matches.opt_strs(\"passes\") == [\"list\"] {\n         println!(\"Available passes for running rustdoc:\");\n-        for &(name, _, description) in passes::PASSES {\n-            println!(\"{:>20} - {}\", name, description);\n+        for pass in passes::PASSES {\n+            println!(\"{:>20} - {}\", pass.name(), pass.description());\n         }\n         println!(\"\\nDefault passes for rustdoc:\");\n         for &name in passes::DEFAULT_PASSES {\n@@ -630,16 +629,16 @@ fn rust_input<R, F>(cratefile: PathBuf,\n where R: 'static + Send,\n       F: 'static + Send + FnOnce(Output) -> R\n {\n-    let mut default_passes = if matches.opt_present(\"no-defaults\") {\n+    let default_passes = if matches.opt_present(\"no-defaults\") {\n         passes::DefaultPassOption::None\n     } else if matches.opt_present(\"document-private-items\") {\n         passes::DefaultPassOption::Private\n     } else {\n         passes::DefaultPassOption::Default\n     };\n \n-    let mut manual_passes = matches.opt_strs(\"passes\");\n-    let mut plugins = matches.opt_strs(\"plugins\");\n+    let manual_passes = matches.opt_strs(\"passes\");\n+    let plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n     let mut paths = SearchPaths::new();\n@@ -673,11 +672,11 @@ where R: 'static + Send,\n     let result = rustc_driver::monitor(move || syntax::with_globals(move || {\n         use rustc::session::config::Input;\n \n-        let (mut krate, renderinfo) =\n+        let (mut krate, renderinfo, passes) =\n             core::run_core(paths, cfgs, externs, Input::File(cratefile), triple, maybe_sysroot,\n                            display_warnings, crate_name.clone(),\n                            force_unstable_if_unmarked, edition, cg, error_format,\n-                           lint_opts, lint_cap, describe_lints);\n+                           lint_opts, lint_cap, describe_lints, manual_passes, default_passes);\n \n         info!(\"finished with rustc\");\n \n@@ -687,58 +686,6 @@ where R: 'static + Send,\n \n         krate.version = crate_version;\n \n-        let diag = core::new_handler(error_format, None);\n-\n-        fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n-            let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\\n-                                                     considered deprecated\", name));\n-            msg.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n-\n-            if name == \"no_default_passes\" {\n-                msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n-            }\n-\n-            msg.emit();\n-        }\n-\n-        // Process all of the crate attributes, extracting plugin metadata along\n-        // with the passes which we are supposed to run.\n-        for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n-            let name = attr.name().map(|s| s.as_str());\n-            let name = name.as_ref().map(|s| &s[..]);\n-            if attr.is_word() {\n-                if name == Some(\"no_default_passes\") {\n-                    report_deprecated_attr(\"no_default_passes\", &diag);\n-                    if default_passes == passes::DefaultPassOption::Default {\n-                        default_passes = passes::DefaultPassOption::None;\n-                    }\n-                }\n-            } else if let Some(value) = attr.value_str() {\n-                let sink = match name {\n-                    Some(\"passes\") => {\n-                        report_deprecated_attr(\"passes = \\\"...\\\"\", &diag);\n-                        &mut manual_passes\n-                    },\n-                    Some(\"plugins\") => {\n-                        report_deprecated_attr(\"plugins = \\\"...\\\"\", &diag);\n-                        &mut plugins\n-                    },\n-                    _ => continue,\n-                };\n-                sink.extend(value.as_str().split_whitespace().map(|p| p.to_string()));\n-            }\n-\n-            if attr.is_word() && name == Some(\"document_private_items\") {\n-                if default_passes == passes::DefaultPassOption::Default {\n-                    default_passes = passes::DefaultPassOption::Private;\n-                }\n-            }\n-        }\n-\n-        let mut passes: Vec<String> =\n-            passes::defaults(default_passes).iter().map(|p| p.to_string()).collect();\n-        passes.extend(manual_passes);\n-\n         if !plugins.is_empty() {\n             eprintln!(\"WARNING: --plugins no longer functions; see CVE-2018-1000622\");\n         }\n@@ -751,8 +698,13 @@ where R: 'static + Send,\n \n         for pass in &passes {\n             // determine if we know about this pass\n-            let pass = match passes::PASSES.iter().find(|(p, ..)| p == pass) {\n-                Some(pass) => pass.1,\n+            let pass = match passes::find_pass(pass) {\n+                Some(pass) => if let Some(pass) = pass.late_fn() {\n+                    pass\n+                } else {\n+                    // not a late pass, but still valid so don't report the error\n+                    continue\n+                }\n                 None => {\n                     error!(\"unknown pass {}, skipping\", *pass);\n "}, {"sha": "33d052775ba76d3af28bdbe16769878dc83b27c9", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -11,8 +11,13 @@\n use clean::{self, DocFragment, Item};\n use fold;\n use fold::DocFolder;\n+use passes::Pass;\n use std::mem::replace;\n \n+pub const COLLAPSE_DOCS: Pass =\n+    Pass::late(\"collapse-docs\", collapse_docs,\n+        \"concatenates all document attributes into one document attribute\");\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum DocFragmentKind {\n     Sugared,"}, {"sha": "28d504c2ee0c8b259094dfcf29402476422d5599", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -0,0 +1,597 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean::*;\n+\n+use rustc::lint as lint;\n+use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::ty;\n+use syntax;\n+use syntax::ast::{self, Ident, NodeId};\n+use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::Symbol;\n+use syntax_pos::{self, DUMMY_SP};\n+\n+use std::ops::Range;\n+\n+use core::DocContext;\n+use fold::DocFolder;\n+use html::markdown::markdown_links;\n+use passes::Pass;\n+\n+pub const COLLECT_INTRA_DOC_LINKS: Pass =\n+    Pass::early(\"collect-intra-doc-links\", collect_intra_doc_links,\n+                \"reads a crate's documentation to resolve intra-doc-links\");\n+\n+pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext) -> Crate {\n+    if !UnstableFeatures::from_environment().is_nightly_build() {\n+        krate\n+    } else {\n+        let mut coll = LinkCollector::new(cx);\n+\n+        coll.fold_crate(krate)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum PathKind {\n+    /// can be either value or type, not a macro\n+    Unknown,\n+    /// macro\n+    Macro,\n+    /// values, functions, consts, statics, everything in the value namespace\n+    Value,\n+    /// types, traits, everything in the type namespace\n+    Type,\n+}\n+\n+struct LinkCollector<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n+    cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>,\n+    mod_ids: Vec<NodeId>,\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n+    fn new(cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>) -> Self {\n+        LinkCollector {\n+            cx,\n+            mod_ids: Vec::new(),\n+        }\n+    }\n+\n+    /// Resolve a given string as a path, along with whether or not it is\n+    /// in the value namespace. Also returns an optional URL fragment in the case\n+    /// of variants and methods\n+    fn resolve(&self, path_str: &str, is_val: bool, current_item: &Option<String>)\n+        -> Result<(Def, Option<String>), ()>\n+    {\n+        let cx = self.cx;\n+\n+        // In case we're in a module, try to resolve the relative\n+        // path\n+        if let Some(id) = self.mod_ids.last() {\n+            let result = cx.resolver.borrow_mut()\n+                                    .with_scope(*id,\n+                |resolver| {\n+                    resolver.resolve_str_path_error(DUMMY_SP,\n+                                                    &path_str, is_val)\n+            });\n+\n+            if let Ok(result) = result {\n+                // In case this is a trait item, skip the\n+                // early return and try looking for the trait\n+                let value = match result.def {\n+                    Def::Method(_) | Def::AssociatedConst(_) => true,\n+                    Def::AssociatedTy(_) => false,\n+                    Def::Variant(_) => return handle_variant(cx, result.def),\n+                    // not a trait item, just return what we found\n+                    _ => return Ok((result.def, None))\n+                };\n+\n+                if value != is_val {\n+                    return Err(())\n+                }\n+            } else if let Some(prim) = is_primitive(path_str, is_val) {\n+                return Ok((prim, Some(path_str.to_owned())))\n+            } else {\n+                // If resolution failed, it may still be a method\n+                // because methods are not handled by the resolver\n+                // If so, bail when we're not looking for a value\n+                if !is_val {\n+                    return Err(())\n+                }\n+            }\n+\n+            // Try looking for methods and associated items\n+            let mut split = path_str.rsplitn(2, \"::\");\n+            let item_name = if let Some(first) = split.next() {\n+                first\n+            } else {\n+                return Err(())\n+            };\n+\n+            let mut path = if let Some(second) = split.next() {\n+                second.to_owned()\n+            } else {\n+                return Err(())\n+            };\n+\n+            if path == \"self\" || path == \"Self\" {\n+                if let Some(name) = current_item.as_ref() {\n+                    path = name.clone();\n+                }\n+            }\n+\n+            let ty = cx.resolver.borrow_mut()\n+                                .with_scope(*id,\n+                |resolver| {\n+                    resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n+            })?;\n+            match ty.def {\n+                Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n+                    let item = cx.tcx.inherent_impls(did)\n+                                     .iter()\n+                                     .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                                     .find(|item| item.ident.name == item_name);\n+                    if let Some(item) = item {\n+                        let out = match item.kind {\n+                            ty::AssociatedKind::Method if is_val => \"method\",\n+                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                            _ => return Err(())\n+                        };\n+                        Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n+                    } else {\n+                        match cx.tcx.type_of(did).sty {\n+                            ty::TyAdt(def, _) => {\n+                                if let Some(item) = if def.is_enum() {\n+                                    def.all_fields().find(|item| item.ident.name == item_name)\n+                                } else {\n+                                    def.non_enum_variant()\n+                                       .fields\n+                                       .iter()\n+                                       .find(|item| item.ident.name == item_name)\n+                                } {\n+                                    Ok((ty.def,\n+                                        Some(format!(\"{}.{}\",\n+                                                     if def.is_enum() {\n+                                                         \"variant\"\n+                                                     } else {\n+                                                         \"structfield\"\n+                                                     },\n+                                                     item.ident))))\n+                                } else {\n+                                    Err(())\n+                                }\n+                            }\n+                            _ => Err(()),\n+                        }\n+                    }\n+                }\n+                Def::Trait(did) => {\n+                    let item = cx.tcx.associated_item_def_ids(did).iter()\n+                                 .map(|item| cx.tcx.associated_item(*item))\n+                                 .find(|item| item.ident.name == item_name);\n+                    if let Some(item) = item {\n+                        let kind = match item.kind {\n+                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                            ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n+                            ty::AssociatedKind::Method if is_val => {\n+                                if item.defaultness.has_value() {\n+                                    \"method\"\n+                                } else {\n+                                    \"tymethod\"\n+                                }\n+                            }\n+                            _ => return Err(())\n+                        };\n+\n+                        Ok((ty.def, Some(format!(\"{}.{}\", kind, item_name))))\n+                    } else {\n+                        Err(())\n+                    }\n+                }\n+                _ => Err(())\n+            }\n+        } else {\n+            Err(())\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n+    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n+        let item_node_id = if item.is_mod() {\n+            if let Some(id) = self.cx.tcx.hir.as_local_node_id(item.def_id) {\n+                Some(id)\n+            } else {\n+                debug!(\"attempting to fold on a non-local item: {:?}\", item);\n+                return self.fold_item_recur(item);\n+            }\n+        } else {\n+            None\n+        };\n+\n+        let current_item = match item.inner {\n+            ModuleItem(..) => {\n+                if item.attrs.inner_docs {\n+                    if item_node_id.unwrap() != NodeId::new(0) {\n+                        item.name.clone()\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    match self.mod_ids.last() {\n+                        Some(parent) if *parent != NodeId::new(0) => {\n+                            //FIXME: can we pull the parent module's name from elsewhere?\n+                            Some(self.cx.tcx.hir.name(*parent).to_string())\n+                        }\n+                        _ => None,\n+                    }\n+                }\n+            }\n+            ImplItem(Impl { ref for_, .. }) => {\n+                for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n+            }\n+            // we don't display docs on `extern crate` items anyway, so don't process them\n+            ExternCrateItem(..) => return self.fold_item_recur(item),\n+            ImportItem(Import::Simple(ref name, ..)) => Some(name.clone()),\n+            MacroItem(..) => None,\n+            _ => item.name.clone(),\n+        };\n+\n+        if item.is_mod() && item.attrs.inner_docs {\n+            self.mod_ids.push(item_node_id.unwrap());\n+        }\n+\n+        let cx = self.cx;\n+        let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n+\n+        for (ori_link, link_range) in markdown_links(&dox) {\n+            // bail early for real links\n+            if ori_link.contains('/') {\n+                continue;\n+            }\n+            let link = ori_link.replace(\"`\", \"\");\n+            let (def, fragment) = {\n+                let mut kind = PathKind::Unknown;\n+                let path_str = if let Some(prefix) =\n+                    [\"struct@\", \"enum@\", \"type@\",\n+                     \"trait@\", \"union@\"].iter()\n+                                      .find(|p| link.starts_with(**p)) {\n+                    kind = PathKind::Type;\n+                    link.trim_left_matches(prefix)\n+                } else if let Some(prefix) =\n+                    [\"const@\", \"static@\",\n+                     \"value@\", \"function@\", \"mod@\",\n+                     \"fn@\", \"module@\", \"method@\"]\n+                        .iter().find(|p| link.starts_with(**p)) {\n+                    kind = PathKind::Value;\n+                    link.trim_left_matches(prefix)\n+                } else if link.ends_with(\"()\") {\n+                    kind = PathKind::Value;\n+                    link.trim_right_matches(\"()\")\n+                } else if link.starts_with(\"macro@\") {\n+                    kind = PathKind::Macro;\n+                    link.trim_left_matches(\"macro@\")\n+                } else if link.ends_with('!') {\n+                    kind = PathKind::Macro;\n+                    link.trim_right_matches('!')\n+                } else {\n+                    &link[..]\n+                }.trim();\n+\n+                if path_str.contains(|ch: char| !(ch.is_alphanumeric() ||\n+                                                  ch == ':' || ch == '_')) {\n+                    continue;\n+                }\n+\n+                match kind {\n+                    PathKind::Value => {\n+                        if let Ok(def) = self.resolve(path_str, true, &current_item) {\n+                            def\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            // this could just be a normal link or a broken link\n+                            // we could potentially check if something is\n+                            // \"intra-doc-link-like\" and warn in that case\n+                            continue;\n+                        }\n+                    }\n+                    PathKind::Type => {\n+                        if let Ok(def) = self.resolve(path_str, false, &current_item) {\n+                            def\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            // this could just be a normal link\n+                            continue;\n+                        }\n+                    }\n+                    PathKind::Unknown => {\n+                        // try everything!\n+                        if let Some(macro_def) = macro_resolve(cx, path_str) {\n+                            if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                                let (type_kind, article, type_disambig)\n+                                    = type_ns_kind(type_def.0, path_str);\n+                                ambiguity_error(cx, &item.attrs, path_str,\n+                                                article, type_kind, &type_disambig,\n+                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n+                                continue;\n+                            } else if let Ok(value_def) = self.resolve(path_str,\n+                                                                       true,\n+                                                                       &current_item) {\n+                                let (value_kind, value_disambig)\n+                                    = value_ns_kind(value_def.0, path_str)\n+                                        .expect(\"struct and mod cases should have been \\\n+                                                 caught in previous branch\");\n+                                ambiguity_error(cx, &item.attrs, path_str,\n+                                                \"a\", value_kind, &value_disambig,\n+                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n+                            }\n+                            (macro_def, None)\n+                        } else if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                            // It is imperative we search for not-a-value first\n+                            // Otherwise we will find struct ctors for when we are looking\n+                            // for structs, and the link won't work.\n+                            // if there is something in both namespaces\n+                            if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                                let kind = value_ns_kind(value_def.0, path_str);\n+                                if let Some((value_kind, value_disambig)) = kind {\n+                                    let (type_kind, article, type_disambig)\n+                                        = type_ns_kind(type_def.0, path_str);\n+                                    ambiguity_error(cx, &item.attrs, path_str,\n+                                                    article, type_kind, &type_disambig,\n+                                                    \"a\", value_kind, &value_disambig);\n+                                    continue;\n+                                }\n+                            }\n+                            type_def\n+                        } else if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                            value_def\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            // this could just be a normal link\n+                            continue;\n+                        }\n+                    }\n+                    PathKind::Macro => {\n+                        if let Some(def) = macro_resolve(cx, path_str) {\n+                            (def, None)\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            continue\n+                        }\n+                    }\n+                }\n+            };\n+\n+            if let Def::PrimTy(_) = def {\n+                item.attrs.links.push((ori_link, None, fragment));\n+            } else {\n+                let id = register_def(cx, def);\n+                item.attrs.links.push((ori_link, Some(id), fragment));\n+            }\n+        }\n+\n+        if item.is_mod() && !item.attrs.inner_docs {\n+            self.mod_ids.push(item_node_id.unwrap());\n+        }\n+\n+        if item.is_mod() {\n+            let ret = self.fold_item_recur(item);\n+\n+            self.mod_ids.pop();\n+\n+            ret\n+        } else {\n+            self.fold_item_recur(item)\n+        }\n+    }\n+}\n+\n+/// Resolve a string as a macro\n+fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n+    use syntax::ext::base::{MacroKind, SyntaxExtension};\n+    use syntax::ext::hygiene::Mark;\n+    let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n+    let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n+    let mut resolver = cx.resolver.borrow_mut();\n+    let mark = Mark::root();\n+    let res = resolver\n+        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n+    if let Ok(def) = res {\n+        if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n+            return Some(def);\n+        }\n+    }\n+    if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n+        return Some(*def);\n+    }\n+    None\n+}\n+\n+fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n+    if attrs.doc_strings.is_empty() {\n+        return DUMMY_SP;\n+    }\n+    let start = attrs.doc_strings[0].span();\n+    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n+    start.to(end)\n+}\n+\n+fn resolution_failure(\n+    cx: &DocContext,\n+    attrs: &Attributes,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+) {\n+    let sp = span_of_attrs(attrs);\n+    let msg = format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str);\n+\n+    let code_dox = sp.to_src(cx);\n+\n+    let doc_comment_padding = 3;\n+    let mut diag = if let Some(link_range) = link_range {\n+        // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+        //                       ^    ~~~~~~\n+        //                       |    link_range\n+        //                       last_new_line_offset\n+\n+        let mut diag;\n+        if dox.lines().count() == code_dox.lines().count() {\n+            let line_offset = dox[..link_range.start].lines().count();\n+            // The span starts in the `///`, so we don't have to account for the leading whitespace\n+            let code_dox_len = if line_offset <= 1 {\n+                doc_comment_padding\n+            } else {\n+                // The first `///`\n+                doc_comment_padding +\n+                    // Each subsequent leading whitespace and `///`\n+                    code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {\n+                        sum + doc_comment_padding + line.len() - line.trim().len()\n+                    })\n+            };\n+\n+            // Extract the specific span\n+            let sp = sp.from_inner_byte_pos(\n+                link_range.start + code_dox_len,\n+                link_range.end + code_dox_len,\n+            );\n+\n+            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+                                                NodeId::new(0),\n+                                                sp,\n+                                                &msg);\n+            diag.span_label(sp, \"cannot be resolved, ignoring\");\n+        } else {\n+            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+                                                NodeId::new(0),\n+                                                sp,\n+                                                &msg);\n+\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n+                 {indicator: <before$}{indicator:^<found$}\",\n+                line=line,\n+                indicator=\"\",\n+                before=link_range.start - last_new_line_offset,\n+                found=link_range.len(),\n+            ));\n+        }\n+        diag\n+    } else {\n+        cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+                                     NodeId::new(0),\n+                                     sp,\n+                                     &msg)\n+    };\n+    diag.help(\"to escape `[` and `]` characters, just add '\\\\' before them like \\\n+               `\\\\[` or `\\\\]`\");\n+    diag.emit();\n+}\n+\n+fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n+                   path_str: &str,\n+                   article1: &str, kind1: &str, disambig1: &str,\n+                   article2: &str, kind2: &str, disambig2: &str) {\n+    let sp = span_of_attrs(attrs);\n+    cx.sess()\n+      .struct_span_warn(sp,\n+                        &format!(\"`{}` is both {} {} and {} {}\",\n+                                 path_str, article1, kind1,\n+                                 article2, kind2))\n+      .help(&format!(\"try `{}` if you want to select the {}, \\\n+                      or `{}` if you want to \\\n+                      select the {}\",\n+                      disambig1, kind1, disambig2,\n+                      kind2))\n+      .emit();\n+}\n+\n+/// Given a def, returns its name and disambiguator\n+/// for a value namespace\n+///\n+/// Returns None for things which cannot be ambiguous since\n+/// they exist in both namespaces (structs and modules)\n+fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n+    match def {\n+        // structs, variants, and mods exist in both namespaces. skip them\n+        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) | Def::VariantCtor(..) => None,\n+        Def::Fn(..)\n+            => Some((\"function\", format!(\"{}()\", path_str))),\n+        Def::Method(..)\n+            => Some((\"method\", format!(\"{}()\", path_str))),\n+        Def::Const(..)\n+            => Some((\"const\", format!(\"const@{}\", path_str))),\n+        Def::Static(..)\n+            => Some((\"static\", format!(\"static@{}\", path_str))),\n+        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n+    }\n+}\n+\n+/// Given a def, returns its name, the article to be used, and a disambiguator\n+/// for the type namespace\n+fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n+    let (kind, article) = match def {\n+        // we can still have non-tuple structs\n+        Def::Struct(..) => (\"struct\", \"a\"),\n+        Def::Enum(..) => (\"enum\", \"an\"),\n+        Def::Trait(..) => (\"trait\", \"a\"),\n+        Def::Union(..) => (\"union\", \"a\"),\n+        _ => (\"type\", \"a\"),\n+    };\n+    (kind, article, format!(\"{}@{}\", kind, path_str))\n+}\n+\n+/// Given an enum variant's def, return the def of its enum and the associated fragment\n+fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n+    use rustc::ty::DefIdTree;\n+\n+    let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n+        parent\n+    } else {\n+        return Err(())\n+    };\n+    let parent_def = Def::Enum(parent);\n+    let variant = cx.tcx.expect_variant_def(def);\n+    Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n+}\n+\n+const PRIMITIVES: &[(&str, Def)] = &[\n+    (\"u8\",    Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U8))),\n+    (\"u16\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U16))),\n+    (\"u32\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U32))),\n+    (\"u64\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U64))),\n+    (\"u128\",  Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U128))),\n+    (\"usize\", Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::Usize))),\n+    (\"i8\",    Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I8))),\n+    (\"i16\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I16))),\n+    (\"i32\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I32))),\n+    (\"i64\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I64))),\n+    (\"i128\",  Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I128))),\n+    (\"isize\", Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::Isize))),\n+    (\"f32\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F32))),\n+    (\"f64\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F64))),\n+    (\"str\",   Def::PrimTy(hir::PrimTy::TyStr)),\n+    (\"bool\",  Def::PrimTy(hir::PrimTy::TyBool)),\n+    (\"char\",  Def::PrimTy(hir::PrimTy::TyChar)),\n+];\n+\n+fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n+    if is_val {\n+        None\n+    } else {\n+        PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n+    }\n+}"}, {"sha": "16251877bb10637faa7a993d5a012ea8f4e08ca4", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 113, "deletions": 42, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -8,95 +8,161 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Contains information about \"passes\", used to modify crate information during the documentation\n+//! process.\n+\n use rustc::hir::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n+use std::fmt;\n \n use clean::{self, GetDefId, Item};\n+use core::DocContext;\n use fold;\n use fold::StripItem;\n \n mod collapse_docs;\n-pub use self::collapse_docs::collapse_docs;\n+pub use self::collapse_docs::COLLAPSE_DOCS;\n \n mod strip_hidden;\n-pub use self::strip_hidden::strip_hidden;\n+pub use self::strip_hidden::STRIP_HIDDEN;\n \n mod strip_private;\n-pub use self::strip_private::strip_private;\n+pub use self::strip_private::STRIP_PRIVATE;\n \n mod strip_priv_imports;\n-pub use self::strip_priv_imports::strip_priv_imports;\n+pub use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n \n mod unindent_comments;\n-pub use self::unindent_comments::unindent_comments;\n+pub use self::unindent_comments::UNINDENT_COMMENTS;\n \n mod propagate_doc_cfg;\n-pub use self::propagate_doc_cfg::propagate_doc_cfg;\n+pub use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n+\n+mod collect_intra_doc_links;\n+pub use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n+\n+/// Represents a single pass.\n+#[derive(Copy, Clone)]\n+pub enum Pass {\n+    /// An \"early pass\" is run in the compiler context, and can gather information about types and\n+    /// traits and the like.\n+    EarlyPass {\n+        name: &'static str,\n+        pass: fn(clean::Crate, &DocContext) -> clean::Crate,\n+        description: &'static str,\n+    },\n+    /// A \"late pass\" is run between crate cleaning and page generation.\n+    LatePass {\n+        name: &'static str,\n+        pass: fn(clean::Crate) -> clean::Crate,\n+        description: &'static str,\n+    },\n+}\n+\n+impl fmt::Debug for Pass {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut dbg = match *self {\n+            Pass::EarlyPass { .. } => f.debug_struct(\"EarlyPass\"),\n+            Pass::LatePass { .. } => f.debug_struct(\"LatePass\"),\n+        };\n+\n+        dbg.field(\"name\", &self.name())\n+           .field(\"pass\", &\"...\")\n+           .field(\"description\", &self.description())\n+           .finish()\n+    }\n+}\n \n-type Pass = (\n-    &'static str,                     // name\n-    fn(clean::Crate) -> clean::Crate, // fn\n-    &'static str,\n-); // description\n+impl Pass {\n+    /// Constructs a new early pass.\n+    pub const fn early(name: &'static str,\n+                       pass: fn(clean::Crate, &DocContext) -> clean::Crate,\n+                       description: &'static str) -> Pass {\n+        Pass::EarlyPass { name, pass, description }\n+    }\n \n+    /// Constructs a new late pass.\n+    pub const fn late(name: &'static str,\n+                      pass: fn(clean::Crate) -> clean::Crate,\n+                      description: &'static str) -> Pass {\n+        Pass::LatePass { name, pass, description }\n+    }\n+\n+    /// Returns the name of this pass.\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            Pass::EarlyPass { name, .. } |\n+                Pass::LatePass { name, .. } => name,\n+        }\n+    }\n+\n+    /// Returns the description of this pass.\n+    pub fn description(self) -> &'static str {\n+        match self {\n+            Pass::EarlyPass { description, .. } |\n+                Pass::LatePass { description, .. } => description,\n+        }\n+    }\n+\n+    /// If this pass is an early pass, returns the pointer to its function.\n+    pub fn early_fn(self) -> Option<fn(clean::Crate, &DocContext) -> clean::Crate> {\n+        match self {\n+            Pass::EarlyPass { pass, .. } => Some(pass),\n+            _ => None,\n+        }\n+    }\n+\n+    /// If this pass is a late pass, returns the pointer to its function.\n+    pub fn late_fn(self) -> Option<fn(clean::Crate) -> clean::Crate> {\n+        match self {\n+            Pass::LatePass { pass, .. } => Some(pass),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// The full list of passes.\n pub const PASSES: &'static [Pass] = &[\n-    (\n-        \"strip-hidden\",\n-        strip_hidden,\n-        \"strips all doc(hidden) items from the output\",\n-    ),\n-    (\n-        \"unindent-comments\",\n-        unindent_comments,\n-        \"removes excess indentation on comments in order for markdown to like it\",\n-    ),\n-    (\n-        \"collapse-docs\",\n-        collapse_docs,\n-        \"concatenates all document attributes into one document attribute\",\n-    ),\n-    (\n-        \"strip-private\",\n-        strip_private,\n-        \"strips all private items from a crate which cannot be seen externally, \\\n-         implies strip-priv-imports\",\n-    ),\n-    (\n-        \"strip-priv-imports\",\n-        strip_priv_imports,\n-        \"strips all private import statements (`use`, `extern crate`) from a crate\",\n-    ),\n-    (\n-        \"propagate-doc-cfg\",\n-        propagate_doc_cfg,\n-        \"propagates `#[doc(cfg(...))]` to child items\",\n-    ),\n+    STRIP_HIDDEN,\n+    UNINDENT_COMMENTS,\n+    COLLAPSE_DOCS,\n+    STRIP_PRIVATE,\n+    STRIP_PRIV_IMPORTS,\n+    PROPAGATE_DOC_CFG,\n+    COLLECT_INTRA_DOC_LINKS,\n ];\n \n+/// The list of passes run by default.\n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"strip-hidden\",\n     \"strip-private\",\n+    \"collect-intra-doc-links\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n     \"propagate-doc-cfg\",\n ];\n \n+/// The list of default passes run with `--document-private-items` is passed to rustdoc.\n pub const DEFAULT_PRIVATE_PASSES: &'static [&'static str] = &[\n     \"strip-priv-imports\",\n+    \"collect-intra-doc-links\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n     \"propagate-doc-cfg\",\n ];\n \n+/// A shorthand way to refer to which set of passes to use, based on the presence of\n+/// `--no-defaults` or `--document-private-items`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DefaultPassOption {\n     Default,\n     Private,\n     None,\n }\n \n+/// Returns the given default set of passes.\n pub fn defaults(default_set: DefaultPassOption) -> &'static [&'static str] {\n     match default_set {\n         DefaultPassOption::Default => DEFAULT_PASSES,\n@@ -105,6 +171,11 @@ pub fn defaults(default_set: DefaultPassOption) -> &'static [&'static str] {\n     }\n }\n \n+/// If the given name matches a known pass, returns its information.\n+pub fn find_pass(pass_name: &str) -> Option<Pass> {\n+    PASSES.iter().find(|p| p.name() == pass_name).cloned()\n+}\n+\n struct Stripper<'a> {\n     retained: &'a mut DefIdSet,\n     access_levels: &'a AccessLevels<DefId>,"}, {"sha": "69093846302a7c65da5f60b6811aebcf240860a8", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -13,6 +13,11 @@ use std::sync::Arc;\n use clean::{Crate, Item};\n use clean::cfg::Cfg;\n use fold::DocFolder;\n+use passes::Pass;\n+\n+pub const PROPAGATE_DOC_CFG: Pass =\n+    Pass::late(\"propagate-doc-cfg\", propagate_doc_cfg,\n+        \"propagates `#[doc(cfg(...))]` to child items\");\n \n pub fn propagate_doc_cfg(cr: Crate) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)"}, {"sha": "cc0b6fb6d67053b16219e896f9209920177e395b", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -13,13 +13,18 @@ use std::mem;\n \n use clean::{self, AttributesExt, NestedAttributesExt};\n use clean::Item;\n+use core::DocContext;\n use fold;\n use fold::DocFolder;\n use fold::StripItem;\n-use passes::ImplStripper;\n+use passes::{ImplStripper, Pass};\n+\n+pub const STRIP_HIDDEN: Pass =\n+    Pass::early(\"strip-hidden\", strip_hidden,\n+                \"strips all doc(hidden) items from the output\");\n \n /// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate) -> clean::Crate {\n+pub fn strip_hidden(krate: clean::Crate, _: &DocContext) -> clean::Crate {\n     let mut retained = DefIdSet();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "f01c333d742d380fa1f3b2591267ba5933ffd62d", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -9,9 +9,13 @@\n // except according to those terms.\n \n use clean;\n+use core::DocContext;\n use fold::DocFolder;\n-use passes::ImportStripper;\n+use passes::{ImportStripper, Pass};\n \n-pub fn strip_priv_imports(krate: clean::Crate)  -> clean::Crate {\n+pub const STRIP_PRIV_IMPORTS: Pass = Pass::early(\"strip-priv-imports\", strip_priv_imports,\n+     \"strips all private import statements (`use`, `extern crate`) from a crate\");\n+\n+pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext)  -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "3b17a768ffdee6fd6ca8d5bb0a0d91a9dfa86c9c", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -11,12 +11,18 @@\n use rustc::util::nodemap::DefIdSet;\n \n use clean;\n+use core::DocContext;\n use fold::DocFolder;\n-use passes::{ImplStripper, ImportStripper, Stripper};\n+use passes::{ImplStripper, ImportStripper, Stripper, Pass};\n+\n+pub const STRIP_PRIVATE: Pass =\n+    Pass::early(\"strip-private\", strip_private,\n+        \"strips all private items from a crate which cannot be seen externally, \\\n+         implies strip-priv-imports\");\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate) -> clean::Crate {\n+pub fn strip_private(mut krate: clean::Crate, _: &DocContext) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet();\n     let access_levels = krate.access_levels.clone();"}, {"sha": "6d875c107c874f2f719aab039f6f8fba791be90b", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -14,6 +14,11 @@ use std::usize;\n \n use clean::{self, DocFragment, Item};\n use fold::{self, DocFolder};\n+use passes::Pass;\n+\n+pub const UNINDENT_COMMENTS: Pass =\n+    Pass::late(\"unindent-comments\", unindent_comments,\n+        \"removes excess indentation on comments in order for markdown to like it\");\n \n pub fn unindent_comments(krate: clean::Crate) -> clean::Crate {\n     CommentCleaner.fold_crate(krate)"}, {"sha": "910abfd5d7ee52aaf72296d33a20bf80d49d0ae8", "filename": "src/test/run-make-fulldeps/exit-code/lint-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frun-make-fulldeps%2Fexit-code%2Flint-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frun-make-fulldeps%2Fexit-code%2Flint-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fexit-code%2Flint-failure.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -11,6 +11,6 @@\n #![deny(intra_doc_link_resolution_failure)]\n \n /// [intradoc::failure]\n-fn main() {\n+pub fn main() {\n     println!(\"Hello, world!\");\n }"}, {"sha": "e4a194466cc3fdc60af3fc51c72eb3e45eccd924", "filename": "src/test/rustdoc/auxiliary/intra-link-extern-crate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-extern-crate.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name=\"inner\"]\n+\n+//! ooh, i'm a rebel just for [kicks]"}, {"sha": "5666f3bd2f2b0e6ae83409596f6f7459d15d9661", "filename": "src/test/rustdoc/intra-link-extern-crate.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frustdoc%2Fintra-link-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frustdoc%2Fintra-link-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-extern-crate.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:intra-link-extern-crate.rs\n+\n+// When loading `extern crate` statements, we would pull in their docs at the same time, even\n+// though they would never actually get displayed. This tripped intra-doc-link resolution failures,\n+// for items that aren't under our control, and not actually getting documented!\n+\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+extern crate inner;"}, {"sha": "dbdfbc4e5adcaa6af50f4ed7472ac5d520b25ba3", "filename": "src/test/rustdoc/intra-link-private.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frustdoc%2Fintra-link-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1/src%2Ftest%2Frustdoc%2Fintra-link-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-private.rs?ref=73c78734bae8f2947a4bfdeabebeeb84ccf0b0e1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Rustdoc would previously report resolution failures on items that weren't in the public docs.\n+// These failures were legitimate, but not truly relevant - the docs in question couldn't be\n+// checked for accuracy anyway.\n+\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+/// ooh, i'm a [rebel] just for kicks\n+struct SomeStruct;"}]}