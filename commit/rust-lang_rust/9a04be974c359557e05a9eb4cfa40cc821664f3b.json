{"sha": "9a04be974c359557e05a9eb4cfa40cc821664f3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMDRiZTk3NGMzNTk1NTdlMDVhOWViNGNmYTQwY2M4MjE2NjRmM2I=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-04T07:50:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-04T07:50:54Z"}, "message": "Merge pull request #232 from oli-obk/master\n\nOnly check pointers when dereferencing", "tree": {"sha": "3bc8e5e310a22c124dd54303956d93305bf395db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bc8e5e310a22c124dd54303956d93305bf395db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a04be974c359557e05a9eb4cfa40cc821664f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a04be974c359557e05a9eb4cfa40cc821664f3b", "html_url": "https://github.com/rust-lang/rust/commit/9a04be974c359557e05a9eb4cfa40cc821664f3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a04be974c359557e05a9eb4cfa40cc821664f3b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10ec543b9e056269d4b439dc8a6f48f11151c936", "url": "https://api.github.com/repos/rust-lang/rust/commits/10ec543b9e056269d4b439dc8a6f48f11151c936", "html_url": "https://github.com/rust-lang/rust/commit/10ec543b9e056269d4b439dc8a6f48f11151c936"}, {"sha": "823b952ef26ad0a6c44d8eb234888bc23cdbc752", "url": "https://api.github.com/repos/rust-lang/rust/commits/823b952ef26ad0a6c44d8eb234888bc23cdbc752", "html_url": "https://github.com/rust-lang/rust/commit/823b952ef26ad0a6c44d8eb234888bc23cdbc752"}], "stats": {"total": 210, "additions": 104, "deletions": 106}, "files": [{"sha": "14639ac9e20c8ef101e1b05a0821cdb5dc3980e2", "filename": "src/eval_context.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=9a04be974c359557e05a9eb4cfa40cc821664f3b", "patch": "@@ -351,7 +351,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let global_value = self.globals.get_mut(&id)\n                     .expect(\"global should have been cached (static)\");\n                 match global_value.value {\n-                    Value::ByRef(ptr) => self.memory.mark_static_initalized(ptr.alloc_id, mutable)?,\n+                    // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n+                    Value::ByRef(ptr) => self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n                         self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                     },\n@@ -409,6 +410,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n         if let Some(Value::ByRef(ptr)) = local {\n             trace!(\"deallocating local\");\n+            let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n             match self.memory.deallocate(ptr) {\n                 // We could alternatively check whether the alloc_id is static before calling\n@@ -693,26 +695,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 // Check alignment and non-NULLness.\n                 let (_, align) = self.size_and_align_of_dst(ty, val)?;\n-                match ptr {\n-                    PrimVal::Ptr(ptr) => {\n-                        self.memory.check_align(ptr, align, 0)?;\n-                    }\n-                    PrimVal::Bytes(bytes) => {\n-                        let v = ((bytes as u128) % (1 << self.memory.pointer_size())) as u64;\n-                        if v == 0 {\n-                            return Err(EvalError::InvalidNullPointerUsage);\n-                        }\n-                        if v % align != 0 {\n-                            return Err(EvalError::AlignmentCheckFailed {\n-                                has: v % align,\n-                                required: align,\n-                            });\n-                        }\n-                    }\n-                    PrimVal::Undef => {\n-                        return Err(EvalError::ReadUndefBytes);\n-                    }\n-                }\n+                self.memory.check_align(ptr, align, 0)?;\n \n                 self.write_value(val, dest, dest_ty)?;\n             }\n@@ -1036,14 +1019,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return Err(EvalError::DeadLocal),\n                     Some(Value::ByRef(ptr)) => {\n-                        Lvalue::from_ptr(ptr)\n+                        Lvalue::from_primval_ptr(ptr)\n                     },\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr)); // it stays live\n+                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(PrimVal::Ptr(ptr))); // it stays live\n                         self.write_value_to_ptr(val, PrimVal::Ptr(ptr), ty)?;\n                         Lvalue::from_ptr(ptr)\n                     }\n@@ -1053,7 +1036,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Global(cid) => {\n                 let global_val = *self.globals.get(&cid).expect(\"global not cached\");\n                 match global_val.value {\n-                    Value::ByRef(ptr) => Lvalue::from_ptr(ptr),\n+                    Value::ByRef(ptr) => Lvalue::from_primval_ptr(ptr),\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n@@ -1064,7 +1047,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n-                            value: Value::ByRef(ptr),\n+                            value: Value::ByRef(PrimVal::Ptr(ptr)),\n                             .. global_val\n                         };\n                         Lvalue::from_ptr(ptr)\n@@ -1164,7 +1147,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_value_to_ptr(src_val, PrimVal::Ptr(dest_ptr), dest_ty)?;\n+            self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n \n         } else if let Value::ByRef(src_ptr) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n@@ -1182,8 +1165,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 write_dest(self, src_val)?;\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?;\n-                self.copy(PrimVal::Ptr(src_ptr), PrimVal::Ptr(dest_ptr), dest_ty)?;\n-                write_dest(self, Value::ByRef(dest_ptr))?;\n+                self.copy(src_ptr, PrimVal::Ptr(dest_ptr), dest_ty)?;\n+                write_dest(self, Value::ByRef(PrimVal::Ptr(dest_ptr)))?;\n             }\n \n         } else {\n@@ -1201,7 +1184,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef(ptr) => self.copy(PrimVal::Ptr(ptr), dest, dest_ty),\n+            Value::ByRef(ptr) => self.copy(ptr, dest, dest_ty),\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n                 self.memory.write_primval(dest, primval, size)\n@@ -1331,7 +1314,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn read_value(&mut self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {\n@@ -1356,13 +1339,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn try_read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    fn try_read_value(&mut self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n         let val = match ty.sty {\n-            ty::TyBool => PrimVal::from_bool(self.memory.read_bool(ptr)?),\n+            ty::TyBool => PrimVal::from_bool(self.memory.read_bool(ptr.to_ptr()?)?),\n             ty::TyChar => {\n-                let c = self.memory.read_uint(ptr, 4)? as u32;\n+                let c = self.memory.read_uint(ptr.to_ptr()?, 4)? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n                     None => return Err(EvalError::InvalidChar(c as u128)),\n@@ -1381,8 +1364,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 // if we transmute a ptr to an isize, reading it back into a primval shouldn't panic\n                 // Due to read_ptr ignoring the sign, we need to jump around some hoops\n-                match self.memory.read_int(ptr, size) {\n-                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr)?,\n+                match self.memory.read_int(ptr.to_ptr()?, size) {\n+                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?,\n                     other => PrimVal::from_i128(other?),\n                 }\n             }\n@@ -1399,30 +1382,30 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 if size == self.memory.pointer_size() {\n                     // if we transmute a ptr to an usize, reading it back into a primval shouldn't panic\n-                    self.memory.read_ptr(ptr)?\n+                    self.memory.read_ptr(ptr.to_ptr()?)?\n                 } else {\n-                    PrimVal::from_u128(self.memory.read_uint(ptr, size)?)\n+                    PrimVal::from_u128(self.memory.read_uint(ptr.to_ptr()?, size)?)\n                 }\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n-            ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n+            ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr.to_ptr()?)?),\n+            ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr.to_ptr()?)?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr.to_ptr()?)?,\n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, tam.ty).map(Some),\n+            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr.to_ptr()?, tam.ty).map(Some),\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n-                    return self.read_ptr(ptr, ty.boxed_ty()).map(Some);\n+                    return self.read_ptr(ptr.to_ptr()?, ty.boxed_ty()).map(Some);\n                 }\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes();\n                     if signed {\n-                        PrimVal::from_i128(self.memory.read_int(ptr, size)?)\n+                        PrimVal::from_i128(self.memory.read_int(ptr.to_ptr()?, size)?)\n                     } else {\n-                        PrimVal::from_u128(self.memory.read_uint(ptr, size)?)\n+                        PrimVal::from_u128(self.memory.read_uint(ptr.to_ptr()?, size)?)\n                     }\n                 } else {\n                     return Ok(None);\n@@ -1541,7 +1524,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n                     let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n                     if src_fty == dst_fty {\n-                        self.copy(PrimVal::Ptr(src_f_ptr), PrimVal::Ptr(dst_f_ptr), src_fty)?;\n+                        self.copy(src_f_ptr, PrimVal::Ptr(dst_f_ptr), src_fty)?;\n                     } else {\n                         self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }\n@@ -1570,10 +1553,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Err(err) => {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n-                Ok(Value::ByRef(ptr)) => {\n+                Ok(Value::ByRef(PrimVal::Ptr(ptr))) => {\n                     write!(msg, \" by ref:\").unwrap();\n                     allocs.push(ptr.alloc_id);\n                 }\n+                Ok(Value::ByRef(ptr)) => {\n+                    write!(msg, \" integral by ref: {:?}\", ptr).unwrap();\n+                }\n                 Ok(Value::ByVal(val)) => {\n                     write!(msg, \" {:?}\", val).unwrap();\n                     if let PrimVal::Ptr(ptr) = val { allocs.push(ptr.alloc_id); }"}, {"sha": "df048d08cfae40296dad6daf221ca0a897b84287", "filename": "src/lvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=9a04be974c359557e05a9eb4cfa40cc821664f3b", "patch": "@@ -67,11 +67,11 @@ impl<'tcx> Lvalue<'tcx> {\n         Self::from_primval_ptr(PrimVal::Undef)\n     }\n \n-    fn from_primval_ptr(ptr: PrimVal) -> Self {\n+    pub(crate) fn from_primval_ptr(ptr: PrimVal) -> Self {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n-    pub fn from_ptr(ptr: Pointer) -> Self {\n+    pub(crate) fn from_ptr(ptr: Pointer) -> Self {\n         Self::from_primval_ptr(PrimVal::Ptr(ptr))\n     }\n \n@@ -192,7 +192,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match lvalue {\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef(ptr.to_ptr()?))\n+                Ok(Value::ByRef(ptr))\n             }\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local)"}, {"sha": "29bc6c682cdc5962dd0949ca04cec2d0be06bba6", "filename": "src/memory.rs", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=9a04be974c359557e05a9eb4cfa40cc821664f3b", "patch": "@@ -189,7 +189,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n \n         let ptr = self.allocate(bytes.len() as u64, 1)?;\n-        self.write_bytes(ptr, bytes)?;\n+        self.write_bytes(PrimVal::Ptr(ptr), bytes)?;\n         self.mark_static_initalized(ptr.alloc_id, false)?;\n         self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n         Ok(ptr)\n@@ -288,39 +288,52 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.layout.endian\n     }\n \n-    pub fn check_align(&self, ptr: Pointer, align: u64, len: u64) -> EvalResult<'tcx> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        // check whether the memory was marked as packed\n-        // we select all elements that have the correct alloc_id and are within\n-        // the range given by the offset into the allocation and the length\n-        let start = Entry {\n-            alloc_id: ptr.alloc_id,\n-            packed_start: 0,\n-            packed_end: ptr.offset + len,\n-        };\n-        let end = Entry {\n-            alloc_id: ptr.alloc_id,\n-            packed_start: ptr.offset + len,\n-            packed_end: 0,\n+    pub fn check_align(&self, ptr: PrimVal, align: u64, len: u64) -> EvalResult<'tcx> {\n+        let offset = match ptr {\n+            PrimVal::Ptr(ptr) => {\n+                let alloc = self.get(ptr.alloc_id)?;\n+                // check whether the memory was marked as packed\n+                // we select all elements that have the correct alloc_id and are within\n+                // the range given by the offset into the allocation and the length\n+                let start = Entry {\n+                    alloc_id: ptr.alloc_id,\n+                    packed_start: 0,\n+                    packed_end: ptr.offset + len,\n+                };\n+                let end = Entry {\n+                    alloc_id: ptr.alloc_id,\n+                    packed_start: ptr.offset + len,\n+                    packed_end: 0,\n+                };\n+                for &Entry { packed_start, packed_end, .. } in self.packed.range(start..end) {\n+                    // if the region we are checking is covered by a region in `packed`\n+                    // ignore the actual alignment\n+                    if packed_start <= ptr.offset && (ptr.offset + len) <= packed_end {\n+                        return Ok(());\n+                    }\n+                }\n+                if alloc.align < align {\n+                    return Err(EvalError::AlignmentCheckFailed {\n+                        has: alloc.align,\n+                        required: align,\n+                    });\n+                }\n+                ptr.offset\n+            },\n+            PrimVal::Bytes(bytes) => {\n+                let v = ((bytes as u128) % (1 << self.pointer_size())) as u64;\n+                if v == 0 {\n+                    return Err(EvalError::InvalidNullPointerUsage);\n+                }\n+                v\n+            },\n+            PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n         };\n-        for &Entry { packed_start, packed_end, .. } in self.packed.range(start..end) {\n-            // if the region we are checking is covered by a region in `packed`\n-            // ignore the actual alignment\n-            if packed_start <= ptr.offset && (ptr.offset + len) <= packed_end {\n-                return Ok(());\n-            }\n-        }\n-        if alloc.align < align {\n-            return Err(EvalError::AlignmentCheckFailed {\n-                has: alloc.align,\n-                required: align,\n-            });\n-        }\n-        if ptr.offset % align == 0 {\n+        if offset % align == 0 {\n             Ok(())\n         } else {\n             Err(EvalError::AlignmentCheckFailed {\n-                has: ptr.offset % align,\n+                has: offset % align,\n                 required: align,\n             })\n         }\n@@ -572,7 +585,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.check_align(ptr, align, size)?;\n+        self.check_align(PrimVal::Ptr(ptr), align, size)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -585,7 +598,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n-        self.check_align(ptr, align, size)?;\n+        self.check_align(PrimVal::Ptr(ptr), align, size)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -716,20 +729,20 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.get_bytes(ptr.to_ptr()?, size, 1)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n+    pub fn write_bytes(&mut self, ptr: PrimVal, src: &[u8]) -> EvalResult<'tcx> {\n         if src.is_empty() {\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr, src.len() as u64, 1)?;\n+        let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, 1)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n+    pub fn write_repeat(&mut self, ptr: PrimVal, val: u8, count: u64) -> EvalResult<'tcx> {\n         if count == 0 {\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr, count, 1)?;\n+        let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, 1)?;\n         for b in bytes { *b = val; }\n         Ok(())\n     }"}, {"sha": "dbfd8f1d952fe953fdb3aef3a57b1f49613dd5a2", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=9a04be974c359557e05a9eb4cfa40cc821664f3b", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value(Value::ByRef(ptr), dest, ty)?;\n             }\n \n@@ -79,7 +79,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -88,12 +88,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n+                self.write_primval(Lvalue::from_primval_ptr(ptr), change, ty)?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n                 let dest = self.force_allocation(dest)?.to_ptr()?;\n                 self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n+                self.write_primval(Lvalue::from_primval_ptr(ptr), change, ty)?;\n             }\n \n             \"atomic_or\" | \"atomic_or_acq\" | \"atomic_or_rel\" | \"atomic_or_acqrel\" | \"atomic_or_relaxed\" |\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -133,7 +133,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 // FIXME: what do atomics do on overflow?\n                 let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n+                self.write_primval(Lvalue::from_primval_ptr(ptr), val, ty)?;\n             },\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -257,8 +257,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n                             Err(_) => {\n                                 let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n-                                this.memory.write_repeat(ptr, 0, size)?;\n-                                Value::ByRef(ptr)\n+                                this.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n+                                Value::ByRef(PrimVal::Ptr(ptr))\n                             }\n                         },\n                         Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr.to_ptr()?, 0, size)?,\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, init)?,\n                 }\n@@ -439,7 +439,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n                         Value::ByRef(ptr) => {\n-                            this.memory.mark_definedness(PrimVal::Ptr(ptr), size, false)?;\n+                            this.memory.mark_definedness(ptr, size, false)?;\n                             Ok(Value::ByRef(ptr))\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n@@ -463,7 +463,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n-                    let ptr = ptr.to_ptr()?;\n                     self.memory.check_align(ptr, ty_align, size * count)?;\n                     self.memory.write_repeat(ptr, val_byte, size * count)?;\n                 }"}, {"sha": "62446cbfa39d3c1428916dfadeedabfa3b3c3eb4", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=9a04be974c359557e05a9eb4cfa40cc821664f3b", "patch": "@@ -632,7 +632,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = self.memory.allocate(size, align)?;\n-                self.memory.write_repeat(ptr, 0, size)?;\n+                self.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n \n@@ -792,8 +792,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n                     let value_copy = self.memory.allocate((value.len() + 1) as u64, 1)?;\n-                    self.memory.write_bytes(value_copy, &value)?;\n-                    self.memory.write_bytes(value_copy.offset(value.len() as u64, self.memory.layout)?, &[0])?;\n+                    self.memory.write_bytes(PrimVal::Ptr(value_copy), &value)?;\n+                    self.memory.write_bytes(PrimVal::Ptr(value_copy.offset(value.len() as u64, self.memory.layout)?), &[0])?;\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n                         self.memory.deallocate(var)?;\n                     }"}, {"sha": "6f531b126483ad358956ed817d318f3cb7018036", "filename": "src/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a04be974c359557e05a9eb4cfa40cc821664f3b/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=9a04be974c359557e05a9eb4cfa40cc821664f3b", "patch": "@@ -33,7 +33,7 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(Pointer),\n+    ByRef(PrimVal),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n@@ -72,7 +72,7 @@ impl<'a, 'tcx: 'a> Value {\n     pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr) => mem.read_ptr(ptr),\n+            ByRef(ptr) => mem.read_ptr(ptr.to_ptr()?),\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr),\n         }\n     }\n@@ -84,8 +84,8 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n-                let ptr = mem.read_ptr(ref_ptr)?;\n-                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?)?;\n+                let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n+                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n                 Ok((ptr, vtable.to_ptr()?))\n             }\n \n@@ -99,8 +99,8 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n-                let ptr = mem.read_ptr(ref_ptr)?;\n-                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?)?;\n+                let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n+                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n                 Ok((ptr, len))\n             },\n             ByValPair(ptr, val) => {"}]}