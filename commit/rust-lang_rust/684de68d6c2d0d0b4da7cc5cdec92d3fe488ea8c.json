{"sha": "684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NGRlNjhkNmMyZDBkMGI0ZGE3Y2M1Y2RlYzkyZDNmZTQ4OGVhOGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-06T01:07:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-06T01:07:26Z"}, "message": "properly wrap pointer offsets at pointer size", "tree": {"sha": "da26ee038c0f774b6fdbe8c67d85f143edd5483a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da26ee038c0f774b6fdbe8c67d85f143edd5483a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "html_url": "https://github.com/rust-lang/rust/commit/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bfda59fe274035bd9cb393da9a285c40f306dea", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfda59fe274035bd9cb393da9a285c40f306dea", "html_url": "https://github.com/rust-lang/rust/commit/7bfda59fe274035bd9cb393da9a285c40f306dea"}], "stats": {"total": 76, "additions": 40, "deletions": 36}, "files": [{"sha": "d45c419c78a9a1d35582fb951b9df4576eb5682b", "filename": "src/eval_context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "patch": "@@ -391,7 +391,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr();\n \n-        let discr_dest = dest_ptr.offset(discr_offset)?;\n+        let discr_dest = dest_ptr.offset(discr_offset, self.memory.layout)?;\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr();\n \n-                                let dest = dest.offset(offset.bytes())?;\n+                                let dest = dest.offset(offset.bytes(), self.memory.layout)?;\n                                 let dest_size = self.type_size(ty)?\n                                     .expect(\"bad StructWrappedNullablePointer discrfield\");\n                                 self.memory.write_int(dest, 0, dest_size)?;\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest = self.force_allocation(dest)?.to_ptr();\n \n                 for i in 0..length {\n-                    let elem_dest = dest.offset(i * elem_size)?;\n+                    let elem_dest = dest.offset(i * elem_size, self.memory.layout)?;\n                     self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n                 }\n             }\n@@ -854,7 +854,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n-        Ok(ptr.wrapping_signed_offset(offset))\n+        Ok(ptr.wrapping_signed_offset(offset, self.memory.layout))\n     }\n \n     pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n@@ -865,7 +865,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n-            let ptr = ptr.signed_offset(offset)?;\n+            let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n             self.memory.check_bounds(ptr, false)?;\n             Ok(ptr)\n         } else {\n@@ -1124,8 +1124,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(ptr.offset(field_0)?, a, field_0_size)?;\n-        self.memory.write_primval(ptr.offset(field_1)?, b, field_1_size)?;\n+        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?, a, field_0_size)?;\n+        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?, b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1242,7 +1242,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Ok(Value::ByVal(PrimVal::Ptr(p)))\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(self.memory.pointer_size())?;\n+            let extra = ptr.offset(self.memory.pointer_size(), self.memory.layout)?;\n             let extra = match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n                 ty::TySlice(..) |\n@@ -1427,8 +1427,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes();\n                     let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes();\n-                    let src_f_ptr = src_ptr.offset(src_field_offset)?;\n-                    let dst_f_ptr = dest.offset(dst_field_offset)?;\n+                    let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n+                    let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n                     if src_fty == dst_fty {\n                         self.copy(src_f_ptr, dst_f_ptr, src_fty)?;\n                     } else {"}, {"sha": "c5811774e941e653797393b84d2d3b59f5bc620e", "filename": "src/lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => offset.bytes(),\n         };\n \n-        let ptr = base_ptr.offset(offset)?;\n+        let ptr = base_ptr.offset(offset, self.memory.layout)?;\n \n         let field_ty = self.monomorphize(field_ty, self.substs());\n \n@@ -363,7 +363,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n                 assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n-                let ptr = base_ptr.offset(n * elem_size)?;\n+                let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -384,7 +384,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(index * elem_size)?;\n+                let ptr = base_ptr.offset(index * elem_size, self.memory.layout)?;\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -398,7 +398,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(u64::from(from) * elem_size)?;\n+                let ptr = base_ptr.offset(u64::from(from) * elem_size, self.memory.layout)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n                 (ptr, extra)\n             }"}, {"sha": "18f757a6bd6c0f50ed6cecaccc623370f7fb4d65", "filename": "src/memory.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "patch": "@@ -60,11 +60,11 @@ impl Pointer {\n         Pointer { alloc_id, offset }\n     }\n \n-    pub fn wrapping_signed_offset<'tcx>(self, i: i64) -> Self {\n-        Pointer::new(self.alloc_id, self.offset.wrapping_add(i as u64))\n+    pub fn wrapping_signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> Self {\n+        Pointer::new(self.alloc_id, (self.offset.wrapping_add(i as u64) as u128 % (1u128 << layout.pointer_size.bits())) as u64)\n     }\n \n-    pub fn signed_offset<'tcx>(self, i: i64) -> EvalResult<'tcx, Self> {\n+    pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n             // trickery to ensure that i64::min_value() works fine\n@@ -76,13 +76,17 @@ impl Pointer {\n                 Err(EvalError::OverflowingPointerMath)\n             }\n         } else {\n-            self.offset(i as u64)\n+            self.offset(i as u64, layout)\n         }\n     }\n \n-    pub fn offset<'tcx>(self, i: u64) -> EvalResult<'tcx, Self> {\n+    pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         if let Some(res) = self.offset.checked_add(i) {\n-            Ok(Pointer::new(self.alloc_id, res))\n+            if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n+                Err(EvalError::OverflowingPointerMath)\n+            } else {\n+                Ok(Pointer::new(self.alloc_id, res))\n+            }\n         } else {\n             Err(EvalError::OverflowingPointerMath)\n         }\n@@ -283,7 +287,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n             self.memory_usage -= size - new_size;\n-            self.clear_relocations(ptr.offset(new_size)?, size - new_size)?;\n+            self.clear_relocations(ptr.offset(new_size, self.layout)?, size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n             alloc.bytes.truncate(new_size as usize);\n@@ -595,7 +599,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(&[]);\n         }\n         self.check_align(ptr, align, size)?;\n-        self.check_bounds(ptr.offset(size)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         assert_eq!(size as usize as u64, size);\n@@ -608,7 +612,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(&mut []);\n         }\n         self.check_align(ptr, align, size)?;\n-        self.check_bounds(ptr.offset(size)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         assert_eq!(size as usize as u64, size);\n@@ -930,7 +934,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n-        let overlapping_end = self.relocations(ptr.offset(size)?, 0)?.count();\n+        let overlapping_end = self.relocations(ptr.offset(size, self.layout)?, 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }"}, {"sha": "afc3bf1c37feb421257a5d5835f4292441b2042c", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 match arg_val {\n                                     Value::ByRef(ptr) => {\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef(ptr.offset(offset)?);\n+                                            let arg = Value::ByRef(ptr.offset(offset, self.memory.layout)?);\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;\n@@ -387,7 +387,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let (_, vtable) = self.eval_operand(&arg_operands[0])?.expect_ptr_vtable_pair(&self.memory)?;\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3))?)?;\n+                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), self.memory.layout)?)?;\n                 let instance = self.memory.get_fn(fn_ptr.alloc_id)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n-                let nonnull = adt_ptr.offset(offset.bytes())?;\n+                let nonnull = adt_ptr.offset(offset.bytes(), self.memory.layout)?;\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n@@ -654,7 +654,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1)?;\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1, self.memory.layout)?;\n                     self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n@@ -666,7 +666,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(idx as u64)?;\n+                    let new_ptr = ptr.offset(idx as u64, self.memory.layout)?;\n                     self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;"}, {"sha": "322ebc1981b488f9409395705a536e2fae8f8da0", "filename": "src/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "patch": "@@ -56,14 +56,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let drop = self.memory.create_fn_alloc(drop);\n         self.memory.write_ptr(vtable, drop)?;\n \n-        self.memory.write_usize(vtable.offset(ptr_size)?, size)?;\n-        self.memory.write_usize(vtable.offset(ptr_size * 2)?, align)?;\n+        self.memory.write_usize(vtable.offset(ptr_size, self.memory.layout)?, size)?;\n+        self.memory.write_usize(vtable.offset(ptr_size * 2, self.memory.layout)?, align)?;\n \n         for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n             if let Some((def_id, substs)) = method {\n                 let instance = ::eval_context::resolve(self.tcx, def_id, substs);\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n-                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64))?, fn_ptr)?;\n+                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64), self.memory.layout)?, fn_ptr)?;\n             }\n         }\n \n@@ -88,8 +88,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn read_size_and_align_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_usize(vtable.offset(pointer_size)?)?;\n-        let align = self.memory.read_usize(vtable.offset(pointer_size * 2)?)?;\n+        let size = self.memory.read_usize(vtable.offset(pointer_size, self.memory.layout)?)?;\n+        let align = self.memory.read_usize(vtable.offset(pointer_size * 2, self.memory.layout)?)?;\n         Ok((size, align))\n     }\n "}, {"sha": "387002eee7bc2d243b387b25ef923dde9c925c27", "filename": "src/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=684de68d6c2d0d0b4da7cc5cdec92d3fe488ea8c", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size())?)?;\n+                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?)?;\n                 Ok((ptr, vtable))\n             }\n \n@@ -105,7 +105,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size())?)?;\n+                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?)?;\n                 Ok((ptr, len))\n             },\n             ByValPair(ptr, val) => {"}]}