{"sha": "693582946fae1813627ad59f60a31c9237e98744", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MzU4Mjk0NmZhZTE4MTM2MjdhZDU5ZjYwYTMxYzkyMzdlOTg3NDQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-01T19:53:10Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:48:33Z"}, "message": "Rewrite coercion using the new unification", "tree": {"sha": "7c546542a5e76b8e1a958f867faddd1c04b05d07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c546542a5e76b8e1a958f867faddd1c04b05d07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/693582946fae1813627ad59f60a31c9237e98744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/693582946fae1813627ad59f60a31c9237e98744", "html_url": "https://github.com/rust-lang/rust/commit/693582946fae1813627ad59f60a31c9237e98744", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/693582946fae1813627ad59f60a31c9237e98744/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84074cb1852aa702e1307e9533e1fa3448e3e04f", "url": "https://api.github.com/repos/rust-lang/rust/commits/84074cb1852aa702e1307e9533e1fa3448e3e04f", "html_url": "https://github.com/rust-lang/rust/commit/84074cb1852aa702e1307e9533e1fa3448e3e04f"}], "stats": {"total": 476, "additions": 371, "deletions": 105}, "files": [{"sha": "49d06954156cea63222c50ae77eebaf5c8905c92", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=693582946fae1813627ad59f60a31c9237e98744", "patch": "@@ -77,15 +77,7 @@ impl TyBuilder<()> {\n     }\n \n     pub fn fn_ptr(sig: CallableSig) -> Ty {\n-        TyKind::Function(FnPointer {\n-            num_binders: 0,\n-            sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n-            substitution: FnSubst(Substitution::from_iter(\n-                &Interner,\n-                sig.params_and_return.iter().cloned(),\n-            )),\n-        })\n-        .intern(&Interner)\n+        TyKind::Function(sig.to_fn_ptr()).intern(&Interner)\n     }\n \n     pub fn builtin(builtin: BuiltinType) -> Ty {"}, {"sha": "df340a6ca17abb61326472a3d5f28a1c2c633c72", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=693582946fae1813627ad59f60a31c9237e98744", "patch": "@@ -18,6 +18,7 @@ pub trait TyExt {\n     fn is_unit(&self) -> bool;\n     fn is_never(&self) -> bool;\n     fn is_unknown(&self) -> bool;\n+    fn is_ty_var(&self) -> bool;\n \n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n     fn as_builtin(&self) -> Option<BuiltinType>;\n@@ -55,6 +56,10 @@ impl TyExt for Ty {\n         matches!(self.kind(&Interner), TyKind::Error)\n     }\n \n+    fn is_ty_var(&self) -> bool {\n+        matches!(self.kind(&Interner), TyKind::InferenceVar(_, _))\n+    }\n+\n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)> {\n         match self.kind(&Interner) {\n             TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),"}, {"sha": "603068ab53195f4dd0ae9e2ac64868033bce9400", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=693582946fae1813627ad59f60a31c9237e98744", "patch": "@@ -106,6 +106,14 @@ impl Default for BindingMode {\n     }\n }\n \n+#[derive(Debug)]\n+pub(crate) struct InferOk {\n+    // obligations\n+}\n+#[derive(Debug)]\n+pub(crate) struct TypeError;\n+pub(crate) type InferResult = Result<InferOk, TypeError>;\n+\n /// A mismatch between an expected and an inferred type.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TypeMismatch {\n@@ -390,6 +398,10 @@ impl<'a> InferenceContext<'a> {\n         self.table.unify(ty1, ty2)\n     }\n \n+    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty) -> InferResult {\n+        self.table.unify_inner(ty1, ty2)\n+    }\n+\n     // FIXME get rid of this, instead resolve shallowly where necessary\n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should"}, {"sha": "86a7cd4c24bd6984a190816adc589596a508b4a3", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 317, "deletions": 84, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=693582946fae1813627ad59f60a31c9237e98744", "patch": "@@ -2,22 +2,35 @@\n //! happen in certain places, e.g. weakening `&mut` to `&` or deref coercions\n //! like going from `&Vec<T>` to `&[T]`.\n //!\n-//! See: https://doc.rust-lang.org/nomicon/coercions.html\n+//! See https://doc.rust-lang.org/nomicon/coercions.html and\n+//! librustc_typeck/check/coercion.rs.\n \n use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n \n-use crate::{autoderef, Canonical, DomainGoal, Interner, Solution, Ty, TyBuilder, TyExt, TyKind};\n+use crate::{\n+    autoderef, static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Interner, Solution,\n+    Substitution, Ty, TyBuilder, TyExt, TyKind,\n+};\n \n-use super::{InEnvironment, InferenceContext};\n+use super::{InEnvironment, InferOk, InferResult, InferenceContext, TypeError};\n \n impl<'a> InferenceContext<'a> {\n     /// Unify two types, but may coerce the first one to the second one\n     /// using \"implicit coercion rules\" if needed.\n     pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n         let from_ty = self.resolve_ty_shallow(from_ty).into_owned();\n         let to_ty = self.resolve_ty_shallow(to_ty);\n-        self.coerce_inner(from_ty, &to_ty)\n+        match self.coerce_inner(from_ty, &to_ty) {\n+            Ok(_result) => {\n+                // TODO deal with goals\n+                true\n+            }\n+            Err(_) => {\n+                // FIXME deal with error\n+                false\n+            }\n+        }\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n@@ -52,101 +65,320 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n-        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            // Never type will make type variable to fallback to Never Type instead of Unknown.\n-            (TyKind::Never, TyKind::InferenceVar(tv, TyVariableKind::General)) => {\n-                self.table.type_variable_table.set_diverging(*tv, true);\n-                return true;\n+    fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> InferResult {\n+        if from_ty.is_never() {\n+            // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n+            // type variable, we want `?T` to fallback to `!` if not\n+            // otherwise constrained. An example where this arises:\n+            //\n+            //     let _: Option<?T> = Some({ return; });\n+            //\n+            // here, we would coerce from `!` to `?T`.\n+            match to_ty.kind(&Interner) {\n+                TyKind::InferenceVar(tv, TyVariableKind::General) => {\n+                    self.table.type_variable_table.set_diverging(*tv, true);\n+                }\n+                _ => {}\n             }\n-            (TyKind::Never, _) => return true,\n+            return Ok(InferOk {});\n+        }\n \n-            // Trivial cases, this should go after `never` check to\n-            // avoid infer result type to be never\n-            _ => {\n-                if self.table.unify_inner_trivial(&from_ty, &to_ty, 0) {\n-                    return true;\n-                }\n+        // Consider coercing the subtype to a DST\n+        if let Ok(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n+            return Ok(ret);\n+        }\n+\n+        // Examine the supertype and consider auto-borrowing.\n+        match to_ty.kind(&Interner) {\n+            TyKind::Raw(mt, _) => {\n+                return self.coerce_ptr(from_ty, to_ty, *mt);\n+            }\n+            TyKind::Ref(mt, _, _) => {\n+                return self.coerce_ref(from_ty, to_ty, *mt);\n             }\n+            _ => {}\n         }\n \n-        // Pointer weakening and function to pointer\n-        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            // `*mut T` -> `*const T`\n-            (TyKind::Raw(_, inner), TyKind::Raw(m2 @ Mutability::Not, ..)) => {\n-                from_ty = TyKind::Raw(*m2, inner.clone()).intern(&Interner);\n+        match from_ty.kind(&Interner) {\n+            TyKind::FnDef(..) => {\n+                // Function items are coercible to any closure\n+                // type; function pointers are not (that would\n+                // require double indirection).\n+                // Additionally, we permit coercion of function\n+                // items to drop the unsafe qualifier.\n+                self.coerce_from_fn_item(from_ty, to_ty)\n+            }\n+            TyKind::Function(from_fn_ptr) => {\n+                // We permit coercion of fn pointers to drop the\n+                // unsafe qualifier.\n+                self.coerce_from_fn_pointer(from_ty.clone(), from_fn_ptr, to_ty)\n             }\n-            // `&mut T` -> `&T`\n-            (TyKind::Ref(_, lt, inner), TyKind::Ref(m2 @ Mutability::Not, ..)) => {\n-                from_ty = TyKind::Ref(*m2, lt.clone(), inner.clone()).intern(&Interner);\n+            TyKind::Closure(_, from_substs) => {\n+                // Non-capturing closures are coercible to\n+                // function pointers or unsafe function pointers.\n+                // It cannot convert closures that require unsafe.\n+                self.coerce_closure_to_fn(from_ty.clone(), from_substs, to_ty)\n             }\n-            // `&T` -> `*const T`\n-            // `&mut T` -> `*mut T`/`*const T`\n-            (TyKind::Ref(.., substs), &TyKind::Raw(m2 @ Mutability::Not, ..))\n-            | (TyKind::Ref(Mutability::Mut, _, substs), &TyKind::Raw(m2, ..)) => {\n-                from_ty = TyKind::Raw(m2, substs.clone()).intern(&Interner);\n+            _ => {\n+                // Otherwise, just use unification rules.\n+                self.unify_inner(&from_ty, to_ty)\n             }\n+        }\n+    }\n \n-            // Illegal mutability conversion\n-            (TyKind::Raw(Mutability::Not, ..), TyKind::Raw(Mutability::Mut, ..))\n-            | (TyKind::Ref(Mutability::Not, ..), TyKind::Ref(Mutability::Mut, ..)) => return false,\n+    fn coerce_ptr(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n+        let (_is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n+            TyKind::Ref(mt, _, ty) => (true, mt, ty),\n+            TyKind::Raw(mt, ty) => (false, mt, ty),\n+            _ => return self.unify_inner(&from_ty, to_ty),\n+        };\n \n-            // `{function_type}` -> `fn()`\n-            (TyKind::FnDef(..), TyKind::Function { .. }) => match from_ty.callable_sig(self.db) {\n-                None => return false,\n-                Some(sig) => {\n-                    from_ty = TyBuilder::fn_ptr(sig);\n-                }\n+        coerce_mutabilities(*from_mt, to_mt)?;\n+\n+        // Check that the types which they point at are compatible.\n+        let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner);\n+        // FIXME: behavior differs based on is_ref once we're computing adjustments\n+        self.unify_inner(&from_raw, to_ty)\n+    }\n+\n+    /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n+    /// To match `A` with `B`, autoderef will be performed,\n+    /// calling `deref`/`deref_mut` where necessary.\n+    fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n+        let (from_mt, from_inner) = match from_ty.kind(&Interner) {\n+            TyKind::Ref(mt, _, ty) => {\n+                coerce_mutabilities(*mt, to_mt)?;\n+                (*mt, ty.clone())\n+            }\n+            _ => return self.unify_inner(&from_ty, to_ty),\n+        };\n+\n+        // NOTE: this code is mostly copied and adapted from rustc, and\n+        // currently more complicated than necessary, carrying errors around\n+        // etc.. This complication will become necessary when we actually track\n+        // details of coercion errors though, so I think it's useful to leave\n+        // the structure like it is.\n+\n+        let canonicalized = self.canonicalize(from_ty.clone());\n+        let mut autoderef = autoderef::autoderef(\n+            self.db,\n+            self.resolver.krate(),\n+            InEnvironment {\n+                goal: canonicalized.value.clone(),\n+                environment: self.trait_env.env.clone(),\n             },\n+        );\n+        let mut first_error = None;\n+        let mut found = None;\n \n-            (TyKind::Closure(.., substs), TyKind::Function { .. }) => {\n-                from_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n+        for (autoderefs, referent_ty) in autoderef.enumerate() {\n+            if autoderefs == 0 {\n+                // Don't let this pass, otherwise it would cause\n+                // &T to autoref to &&T.\n+                continue;\n             }\n \n-            _ => {}\n+            let referent_ty = canonicalized.decanonicalize_ty(referent_ty.value);\n+\n+            // At this point, we have deref'd `a` to `referent_ty`.  So\n+            // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`.\n+            // In the autoderef loop for `&'a mut Vec<T>`, we would get\n+            // three callbacks:\n+            //\n+            // - `&'a mut Vec<T>` -- 0 derefs, just ignore it\n+            // - `Vec<T>` -- 1 deref\n+            // - `[T]` -- 2 deref\n+            //\n+            // At each point after the first callback, we want to\n+            // check to see whether this would match out target type\n+            // (`&'b mut [T]`) if we autoref'd it. We can't just\n+            // compare the referent types, though, because we still\n+            // have to consider the mutability. E.g., in the case\n+            // we've been considering, we have an `&mut` reference, so\n+            // the `T` in `[T]` needs to be unified with equality.\n+            //\n+            // Therefore, we construct reference types reflecting what\n+            // the types will be after we do the final auto-ref and\n+            // compare those. Note that this means we use the target\n+            // mutability [1], since it may be that we are coercing\n+            // from `&mut T` to `&U`.\n+            let lt = static_lifetime(); // FIXME: handle lifetimes correctly, see rustc\n+            let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(&Interner);\n+            match self.unify_inner(&derefd_from_ty, to_ty) {\n+                Ok(result) => {\n+                    found = Some(result);\n+                    break;\n+                }\n+                Err(err) => {\n+                    if first_error.is_none() {\n+                        first_error = Some(err);\n+                    }\n+                }\n+            }\n         }\n \n-        if let Some(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n-            return ret;\n+        // Extract type or return an error. We return the first error\n+        // we got, which should be from relating the \"base\" type\n+        // (e.g., in example above, the failure from relating `Vec<T>`\n+        // to the target type), since that should be the least\n+        // confusing.\n+        let result = match found {\n+            Some(d) => d,\n+            None => {\n+                let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n+                return Err(err);\n+            }\n+        };\n+\n+        Ok(result)\n+    }\n+\n+    /// Attempts to coerce from the type of a Rust function item into a closure\n+    /// or a function pointer.\n+    fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> InferResult {\n+        match to_ty.kind(&Interner) {\n+            TyKind::Function(b_sig) => {\n+                let from_sig = from_ty.callable_sig(self.db).expect(\"FnDef had no sig\");\n+\n+                // FIXME check ABI: Intrinsics are not coercible to function pointers\n+                // FIXME Safe `#[target_feature]` functions are not assignable to safe fn pointers (RFC 2396)\n+\n+                // FIXME rustc normalizes assoc types in the sig here, not sure if necessary\n+\n+                let from_sig = from_sig.to_fn_ptr();\n+                let from_fn_pointer = TyKind::Function(from_sig.clone()).intern(&Interner);\n+                let ok = self.coerce_from_safe_fn(from_fn_pointer, &from_sig, to_ty)?;\n+\n+                Ok(ok)\n+            }\n+            _ => self.unify_inner(&from_ty, to_ty),\n         }\n+    }\n \n-        // Auto Deref if cannot coerce\n-        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            // FIXME: DerefMut\n-            (TyKind::Ref(.., st1), TyKind::Ref(.., st2)) => {\n-                self.unify_autoderef_behind_ref(st1, st2)\n+    fn coerce_from_fn_pointer(\n+        &mut self,\n+        from_ty: Ty,\n+        from_f: &FnPointer,\n+        to_ty: &Ty,\n+    ) -> InferResult {\n+        self.coerce_from_safe_fn(from_ty, from_f, to_ty)\n+    }\n+\n+    fn coerce_from_safe_fn(\n+        &mut self,\n+        from_ty: Ty,\n+        from_fn_ptr: &FnPointer,\n+        to_ty: &Ty,\n+    ) -> InferResult {\n+        if let TyKind::Function(to_fn_ptr) = to_ty.kind(&Interner) {\n+            if let (chalk_ir::Safety::Safe, chalk_ir::Safety::Unsafe) =\n+                (from_fn_ptr.sig.safety, to_fn_ptr.sig.safety)\n+            {\n+                let from_unsafe =\n+                    TyKind::Function(safe_to_unsafe_fn_ty(from_fn_ptr.clone())).intern(&Interner);\n+                return self.unify_inner(&from_unsafe, to_ty);\n             }\n+        }\n+        self.unify_inner(&from_ty, to_ty)\n+    }\n \n-            // Otherwise, normal unify\n-            _ => self.unify(&from_ty, to_ty),\n+    /// Attempts to coerce from the type of a non-capturing closure into a\n+    /// function pointer.\n+    fn coerce_closure_to_fn(\n+        &mut self,\n+        from_ty: Ty,\n+        from_substs: &Substitution,\n+        to_ty: &Ty,\n+    ) -> InferResult {\n+        match to_ty.kind(&Interner) {\n+            TyKind::Function(fn_ty) /* if from_substs is non-capturing (FIXME) */ => {\n+                // We coerce the closure, which has fn type\n+                //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n+                // to\n+                //     `fn(arg0,arg1,...) -> _`\n+                // or\n+                //     `unsafe fn(arg0,arg1,...) -> _`\n+                let safety = fn_ty.sig.safety;\n+                let pointer_ty = coerce_closure_fn_ty(from_substs, safety);\n+                self.unify_inner(&pointer_ty, to_ty)\n+            }\n+            _ => self.unify_inner(&from_ty, to_ty),\n         }\n     }\n \n     /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n     ///\n     /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n-    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> InferResult {\n+        // These 'if' statements require some explanation.\n+        // The `CoerceUnsized` trait is special - it is only\n+        // possible to write `impl CoerceUnsized<B> for A` where\n+        // A and B have 'matching' fields. This rules out the following\n+        // two types of blanket impls:\n+        //\n+        // `impl<T> CoerceUnsized<T> for SomeType`\n+        // `impl<T> CoerceUnsized<SomeType> for T`\n+        //\n+        // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n+        //\n+        // We can take advantage of this fact to avoid performing unecessary work.\n+        // If either `source` or `target` is a type variable, then any applicable impl\n+        // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n+        // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for\n+        // SomeType`).\n+        //\n+        // However, these are exactly the kinds of impls which are forbidden by\n+        // the compiler! Therefore, we can be sure that coercion will always fail\n+        // when either the source or target type is a type variable. This allows us\n+        // to skip performing any trait selection, and immediately bail out.\n+        if from_ty.is_ty_var() {\n+            return Err(TypeError);\n+        }\n+        if to_ty.is_ty_var() {\n+            return Err(TypeError);\n+        }\n+\n+        // Handle reborrows before trying to solve `Source: CoerceUnsized<Target>`.\n+        let coerce_from = match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n+            (TyKind::Ref(from_mt, _, from_inner), TyKind::Ref(to_mt, _, _)) => {\n+                coerce_mutabilities(*from_mt, *to_mt)?;\n+\n+                let lt = static_lifetime();\n+                TyKind::Ref(*to_mt, lt, from_inner.clone()).intern(&Interner)\n+            }\n+            (TyKind::Ref(from_mt, _, from_inner), TyKind::Raw(to_mt, _)) => {\n+                coerce_mutabilities(*from_mt, *to_mt)?;\n+\n+                TyKind::Raw(*to_mt, from_inner.clone()).intern(&Interner)\n+            }\n+            _ => from_ty.clone(),\n+        };\n+\n         let krate = self.resolver.krate().unwrap();\n         let coerce_unsized_trait = match self.db.lang_item(krate, \"coerce_unsized\".into()) {\n             Some(LangItemTarget::TraitId(trait_)) => trait_,\n-            _ => return None,\n+            _ => return Err(TypeError),\n         };\n \n         let trait_ref = {\n             let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);\n             if b.remaining() != 2 {\n                 // The CoerceUnsized trait should have two generic params: Self and T.\n-                return None;\n+                return Err(TypeError);\n             }\n-            b.push(from_ty.clone()).push(to_ty.clone()).build()\n+            b.push(coerce_from.clone()).push(to_ty.clone()).build()\n         };\n \n         let goal: InEnvironment<DomainGoal> =\n             InEnvironment::new(&self.trait_env.env, trait_ref.cast(&Interner));\n \n         let canonicalized = self.canonicalize(goal);\n \n-        let solution = self.db.trait_solve(krate, canonicalized.value.clone())?;\n+        // FIXME: rustc's coerce_unsized is more specialized -- it only tries to\n+        // solve `CoerceUnsized` and `Unsize` goals at this point and leaves the\n+        // rest for later. Also, there's some logic about sized type variables.\n+        // Need to find out in what cases this is necessary\n+        let solution = self.db.trait_solve(krate, canonicalized.value.clone()).ok_or(TypeError)?;\n \n         match solution {\n             Solution::Unique(v) => {\n@@ -159,38 +391,39 @@ impl<'a> InferenceContext<'a> {\n                     },\n                 );\n             }\n-            _ => return None,\n+            _ => return Err(TypeError),\n         };\n \n-        Some(true)\n+        Ok(InferOk {})\n     }\n+}\n \n-    /// Unify `from_ty` to `to_ty` with optional auto Deref\n-    ///\n-    /// Note that the parameters are already stripped the outer reference.\n-    fn unify_autoderef_behind_ref(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        let canonicalized = self.canonicalize(from_ty.clone());\n-        let to_ty = self.resolve_ty_shallow(&to_ty);\n-        // FIXME: Auto DerefMut\n-        for derefed_ty in autoderef::autoderef(\n-            self.db,\n-            self.resolver.krate(),\n-            InEnvironment {\n-                goal: canonicalized.value.clone(),\n-                environment: self.trait_env.env.clone(),\n-            },\n-        ) {\n-            let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n-            let from_ty = self.resolve_ty_shallow(&derefed_ty);\n-            // Stop when constructor matches.\n-            if from_ty.equals_ctor(&to_ty) {\n-                // It will not recurse to `coerce`.\n-                return self.table.unify(&from_ty, &to_ty);\n-            } else if self.table.unify_inner_trivial(&derefed_ty, &to_ty, 0) {\n-                return true;\n-            }\n-        }\n+fn coerce_closure_fn_ty(closure_substs: &Substitution, safety: chalk_ir::Safety) -> Ty {\n+    let closure_sig = closure_substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n+    match closure_sig.kind(&Interner) {\n+        TyKind::Function(fn_ty) => TyKind::Function(FnPointer {\n+            num_binders: fn_ty.num_binders,\n+            sig: FnSig { safety, ..fn_ty.sig },\n+            substitution: fn_ty.substitution.clone(),\n+        })\n+        .intern(&Interner),\n+        _ => TyKind::Error.intern(&Interner),\n+    }\n+}\n+\n+fn safe_to_unsafe_fn_ty(fn_ty: FnPointer) -> FnPointer {\n+    FnPointer {\n+        num_binders: fn_ty.num_binders,\n+        sig: FnSig { safety: chalk_ir::Safety::Unsafe, ..fn_ty.sig },\n+        substitution: fn_ty.substitution,\n+    }\n+}\n \n-        false\n+fn coerce_mutabilities(from: Mutability, to: Mutability) -> InferResult {\n+    match (from, to) {\n+        (Mutability::Mut, Mutability::Mut)\n+        | (Mutability::Mut, Mutability::Not)\n+        | (Mutability::Not, Mutability::Not) => Ok(InferOk {}),\n+        (Mutability::Not, Mutability::Mut) => Err(TypeError),\n     }\n }"}, {"sha": "3a4258e86cd11634c98f4cf97fc98e870a6f7b17", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=693582946fae1813627ad59f60a31c9237e98744", "patch": "@@ -9,7 +9,7 @@ use chalk_ir::{\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n \n-use super::InferenceContext;\n+use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n     db::HirDatabase, fold_tys, static_lifetime, BoundVar, Canonical, DebruijnIndex, GenericArg,\n     InferenceVar, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyKind,\n@@ -45,7 +45,7 @@ where\n impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n         crate::fold_free_vars(ty, |bound, _binders| {\n-            let var = self.free_vars[bound.index];\n+            let var = self.free_vars[bound.index].clone();\n             var.assert_ty_ref(&Interner).clone()\n         })\n     }\n@@ -76,7 +76,7 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n         for (i, ty) in solution.value.iter(&Interner).enumerate() {\n             // FIXME: deal with non-type vars here -- the only problematic part is the normalization\n             // and maybe we don't need that with lazy normalization?\n-            let var = self.free_vars[i];\n+            let var = self.free_vars[i].clone();\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n             let ty = ctx.normalize_associated_types_in(\n@@ -218,16 +218,10 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_ty_as_possible_inner(&mut Vec::new(), ty)\n     }\n \n+    /// Unify two types and register new trait goals that arise from that.\n+    // TODO give these two functions better names\n     pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        let result = self.var_unification_table.relate(\n-            &Interner,\n-            &self.db,\n-            &self.trait_env.env,\n-            chalk_ir::Variance::Invariant,\n-            ty1,\n-            ty2,\n-        );\n-        let result = if let Ok(r) = result {\n+        let result = if let Ok(r) = self.unify_inner(ty1, ty2) {\n             r\n         } else {\n             return false;\n@@ -236,6 +230,25 @@ impl<'a> InferenceTable<'a> {\n         true\n     }\n \n+    /// Unify two types and return new trait goals arising from it, so the\n+    /// caller needs to deal with them.\n+    pub(crate) fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty) -> InferResult {\n+        match self.var_unification_table.relate(\n+            &Interner,\n+            &self.db,\n+            &self.trait_env.env,\n+            chalk_ir::Variance::Invariant,\n+            ty1,\n+            ty2,\n+        ) {\n+            Ok(result) => {\n+                // TODO deal with new goals\n+                Ok(InferOk {})\n+            }\n+            Err(NoSolution) => Err(TypeError),\n+        }\n+    }\n+\n     /// If `ty` is a type variable with known type, returns that type;\n     /// otherwise, return ty.\n     // FIXME this could probably just return Ty"}, {"sha": "179a27763bfa39b182bb9c70c2ce4a14ece5d242", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693582946fae1813627ad59f60a31c9237e98744/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=693582946fae1813627ad59f60a31c9237e98744", "patch": "@@ -203,6 +203,17 @@ impl CallableSig {\n         }\n     }\n \n+    pub fn to_fn_ptr(&self) -> FnPointer {\n+        FnPointer {\n+            num_binders: 0,\n+            sig: FnSig { abi: (), safety: Safety::Safe, variadic: self.is_varargs },\n+            substitution: FnSubst(Substitution::from_iter(\n+                &Interner,\n+                self.params_and_return.iter().cloned(),\n+            )),\n+        }\n+    }\n+\n     pub fn params(&self) -> &[Ty] {\n         &self.params_and_return[0..self.params_and_return.len() - 1]\n     }"}]}