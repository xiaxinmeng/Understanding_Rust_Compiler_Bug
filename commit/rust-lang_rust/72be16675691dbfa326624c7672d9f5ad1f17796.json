{"sha": "72be16675691dbfa326624c7672d9f5ad1f17796", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYmUxNjY3NTY5MWRiZmEzMjY2MjRjNzY3MmQ5ZjVhZDFmMTc3OTY=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-09-16T07:10:26Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-09-16T07:10:26Z"}, "message": "add suggestions for .clone() in ptr_arg fns", "tree": {"sha": "f02c77f368c7b53183537fdee720b5856cb128f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f02c77f368c7b53183537fdee720b5856cb128f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72be16675691dbfa326624c7672d9f5ad1f17796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72be16675691dbfa326624c7672d9f5ad1f17796", "html_url": "https://github.com/rust-lang/rust/commit/72be16675691dbfa326624c7672d9f5ad1f17796", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72be16675691dbfa326624c7672d9f5ad1f17796/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f64bae4ae385172fd27ce03e74e0c0f2bf738159", "url": "https://api.github.com/repos/rust-lang/rust/commits/f64bae4ae385172fd27ce03e74e0c0f2bf738159", "html_url": "https://github.com/rust-lang/rust/commit/f64bae4ae385172fd27ce03e74e0c0f2bf738159"}], "stats": {"total": 234, "additions": 189, "deletions": 45}, "files": [{"sha": "58f1227d91ede9fd66289a6caa0b5928b9cf1f24", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=72be16675691dbfa326624c7672d9f5ad1f17796", "patch": "@@ -2,7 +2,8 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n use syntax::ast::{Name, UintTy};\n-use utils::{contains_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use utils::{contains_name, get_pat_name, match_type, paths, single_segment_path,\n+            snippet, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for naive byte counts\n ///\n@@ -93,15 +94,6 @@ fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n     name == arg && !contains_name(name, needle)\n }\n \n-fn get_pat_name(pat: &Pat) -> Option<Name> {\n-    match pat.node {\n-        PatKind::Binding(_, _, ref spname, _) => Some(spname.node),\n-        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n-        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n-        _ => None,\n-    }\n-}\n-\n fn get_path_name(expr: &Expr) -> Option<Name> {\n     match expr.node {\n         ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),"}, {"sha": "3d6f7d56808d72b3ef71d6ebe8200159ff914e7d", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=72be16675691dbfa326624c7672d9f5ad1f17796", "patch": "@@ -16,7 +16,7 @@ use utils::sugg;\n use utils::const_to_u64;\n \n use utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n-            last_path_segment, match_trait_method, match_type, multispan_sugg, snippet, snippet_opt,\n+            last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n             span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then};\n use utils::paths;\n \n@@ -1271,15 +1271,6 @@ fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n     }\n }\n \n-fn match_var(expr: &Expr, var: Name) -> bool {\n-    if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n-        if path.segments.len() == 1 && path.segments[0].name == var {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n struct UsedVisitor {\n     var: ast::Name, // var to look for\n     used: bool,     // has the var been used otherwise?"}, {"sha": "cbba4ad26108482192a01eace7236af74f6db3f2", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 101, "deletions": 22, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=72be16675691dbfa326624c7672d9f5ad1f17796", "patch": "@@ -1,26 +1,42 @@\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n use rustc::hir::*;\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::map::NodeItem;\n use rustc::lint::*;\n use rustc::ty;\n-use syntax::ast::NodeId;\n+use syntax::ast::{Name, NodeId};\n use syntax::codemap::Span;\n use syntax_pos::MultiSpan;\n-use utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then,\n-            span_lint_and_sugg, walk_ptrs_hir_ty};\n+use utils::{get_pat_name, match_qpath, match_type, match_var, paths,\n+            snippet, snippet_opt, span_lint, span_lint_and_then,\n+            walk_ptrs_hir_ty};\n \n /// **What it does:** This lint checks for function arguments of type `&String`\n-/// or `&Vec` unless\n-/// the references are mutable.\n+/// or `&Vec` unless the references are mutable. It will also suggest you\n+/// replace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\n+/// calls.\n ///\n /// **Why is this bad?** Requiring the argument to be of the specific size\n-/// makes the function less\n-/// useful for no benefit; slices in the form of `&[T]` or `&str` usually\n-/// suffice and can be\n-/// obtained from other types, too.\n+/// makes the function less useful for no benefit; slices in the form of `&[T]`\n+/// or `&str` usually suffice and can be obtained from other types, too.\n ///\n-/// **Known problems:** None.\n+/// **Known problems:** The lint does not follow data. So if you have an\n+/// argument `x` and write `let y = x; y.clone()` the lint will not suggest\n+/// changing that `.clone()` to `.to_owned()`.\n+///\n+/// Other functions called from this function taking a `&String` or `&Vec`\n+/// argument may also fail to compile if you change the argument. Applying\n+/// this lint on them will fix the problem, but they may be in other crates.\n+///\n+/// Also there may be `fn(&Vec)`-typed references pointing to your function.\n+/// If you have them, you will get a compiler error after applying this lint's\n+/// suggestions. You then have the choice to undo your changes or change the\n+/// type of the reference.\n+///\n+/// Note that if the function is part of your public interface, there may be\n+/// other crates referencing it you may not be aware. Carefully deprecate the\n+/// function before applying the lint suggestions in this case.\n ///\n /// **Example:**\n /// ```rust\n@@ -87,25 +103,26 @@ impl LintPass for PointerPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n-            check_fn(cx, decl, item.id);\n+        if let ItemFn(ref decl, _, _, _, _, body_id) = item.node {\n+            check_fn(cx, decl, item.id, Some(body_id));\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        if let ImplItemKind::Method(ref sig, _) = item.node {\n+        if let ImplItemKind::Method(ref sig, body_id) = item.node {\n             if let Some(NodeItem(it)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(item.id)) {\n                 if let ItemImpl(_, _, _, _, Some(_), _, _) = it.node {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl, item.id);\n+            check_fn(cx, &sig.decl, item.id, Some(body_id));\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let TraitItemKind::Method(ref sig, _) = item.node {\n-            check_fn(cx, &sig.decl, item.id);\n+        if let TraitItemKind::Method(ref sig, ref trait_method) = item.node {\n+            let body_id = if let TraitMethod::Provided(b) = *trait_method { Some(b) } else { None };\n+            check_fn(cx, &sig.decl, item.id, body_id);\n         }\n     }\n \n@@ -123,12 +140,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n+fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();\n \n-    for (arg, ty) in decl.inputs.iter().zip(fn_ty.inputs()) {\n+    for (idx, (arg, ty)) in decl.inputs.iter().zip(fn_ty.inputs()).enumerate() {\n         if let ty::TyRef(\n             _,\n             ty::TypeAndMut {\n@@ -146,7 +163,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n                 ], {\n                     ty_snippet = snippet_opt(cx, parameters.types[0].span);\n                 });\n-                //TODO: Suggestion\n+                let spans = get_spans(cx, opt_body_id, idx, \"to_owned\");\n                 span_lint_and_then(\n                     cx,\n                     PTR_ARG,\n@@ -159,16 +176,30 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n                                                \"change this to\",\n                                                format!(\"&[{}]\", snippet));\n                         }\n+                        for (clonespan, suggestion) in spans {\n+                            db.span_suggestion(clonespan,\n+                                               \"change the `.clone()` to\",\n+                                               suggestion);\n+                        }\n                     }\n                 );\n             } else if match_type(cx, ty, &paths::STRING) {\n-                span_lint_and_sugg(\n+                let spans = get_spans(cx, opt_body_id, idx, \"to_string\");\n+                span_lint_and_then(\n                     cx,\n                     PTR_ARG,\n                     arg.span,\n                     \"writing `&String` instead of `&str` involves a new object where a slice will do.\",\n-                    \"change this to\",\n-                    \"&str\".to_string()\n+                    |db| {\n+                        db.span_suggestion(arg.span,\n+                                           \"change this to\",\n+                                           \"&str\".into());\n+                        for (clonespan, suggestion) in spans {\n+                            db.span_suggestion_short(clonespan,\n+                                               \"change the `.clone` to \",\n+                                               suggestion);\n+                        }\n+                    }\n                 );\n             }\n         }\n@@ -198,6 +229,54 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     }\n }\n \n+fn get_spans(cx: &LateContext, opt_body_id: Option<BodyId>, idx: usize, fn_name: &'static str) -> Vec<(Span, String)> {\n+    if let Some(body) = opt_body_id.map(|id| cx.tcx.hir.body(id)) {\n+        get_binding_name(&body.arguments[idx]).map_or_else(Vec::new,\n+                                                |name| extract_clone_suggestions(cx, name, fn_name, body))\n+    } else {\n+        vec![]\n+    }\n+}\n+\n+fn extract_clone_suggestions<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, name: Name, fn_name: &'static str, body: &'tcx Body) -> Vec<(Span, String)> {\n+    let mut visitor = PtrCloneVisitor {\n+        cx,\n+        name,\n+        fn_name,\n+        spans: vec![]\n+    };\n+    visitor.visit_body(body);\n+    visitor.spans\n+}\n+\n+struct PtrCloneVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    name: Name,\n+    fn_name: &'static str,\n+    spans: Vec<(Span, String)>,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n+            if args.len() == 1 && match_var(&args[0], self.name) && seg.name == \"clone\" {\n+                self.spans.push((expr.span, format!(\"{}.{}()\", snippet(self.cx, args[0].span, \"_\"), self.fn_name)));\n+            }\n+            return;\n+        }\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+}\n+\n+fn get_binding_name(arg: &Arg) -> Option<Name> {\n+    get_pat_name(&arg.pat)\n+}\n+\n fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n     if let Ty_::TyRptr(ref lt, ref m) = ty.node {\n         Some((lt, m.mutbl, ty.span))"}, {"sha": "ec0521ce4f2df88c3b95cc241a741815ce13f8f9", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72be16675691dbfa326624c7672d9f5ad1f17796/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=72be16675691dbfa326624c7672d9f5ad1f17796", "patch": "@@ -218,6 +218,17 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n     }\n }\n \n+/// Check if an expression references a variable of the given name.\n+pub fn match_var(expr: &Expr, var: Name) -> bool {\n+    if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n+        if path.segments.len() == 1 && path.segments[0].name == var {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+\n pub fn last_path_segment(path: &QPath) -> &PathSegment {\n     match *path {\n         QPath::Resolved(_, ref path) => path.segments\n@@ -393,6 +404,16 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     }\n }\n \n+/// Get the name of a `Pat`, if any\n+pub fn get_pat_name(pat: &Pat) -> Option<Name> {\n+    match pat.node {\n+        PatKind::Binding(_, _, ref spname, _) => Some(spname.node),\n+        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n+        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        _ => None,\n+    }\n+}\n+\n struct ContainsName {\n     name: Name,\n     result: bool,"}, {"sha": "a386fcf82df7bea7190eeaffd874530a185ede44", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72be16675691dbfa326624c7672d9f5ad1f17796/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72be16675691dbfa326624c7672d9f5ad1f17796/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=72be16675691dbfa326624c7672d9f5ad1f17796", "patch": "@@ -1,6 +1,6 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n-#![allow(unused)]\n+#![allow(unused, many_single_char_names)]\n #![warn(ptr_arg)]\n \n fn do_vec(x: &Vec<i64>) {\n@@ -34,5 +34,24 @@ struct Bar;\n impl Foo for Bar {\n     type Item = Vec<u8>;\n     fn do_vec(x: &Vec<i64>) {}\n-    fn do_item(x: &Vec<u8>) {}  \n+    fn do_item(x: &Vec<u8>) {}\n+}\n+\n+fn cloned(x: &Vec<u8>) -> Vec<u8> {\n+    let e = x.clone();\n+    let f = e.clone(); // OK\n+    let g = x;\n+    let h = g.clone(); // Alas, we cannot reliably detect this without following data.\n+    let i = (e).clone();\n+    x.clone()\n+}\n+\n+fn str_cloned(x: &String) -> String {\n+    let a = x.clone();\n+    let b = x.clone();\n+    let c = b.clone();\n+    let d = a.clone()\n+             .clone()\n+             .clone();\n+    x.clone()\n }"}, {"sha": "46d7cbdb0310d0113001209e1d6af3eaa24cf8d7", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/72be16675691dbfa326624c7672d9f5ad1f17796/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72be16675691dbfa326624c7672d9f5ad1f17796/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=72be16675691dbfa326624c7672d9f5ad1f17796", "patch": "@@ -18,5 +18,47 @@ error: writing `&Vec<_>` instead of `&[_]` involves one more reference and canno\n 27 |     fn do_vec(x: &Vec<i64>);\n    |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n-error: aborting due to 3 previous errors\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n+  --> $DIR/ptr_arg.rs:40:14\n+   |\n+40 | fn cloned(x: &Vec<u8>) -> Vec<u8> {\n+   |              ^^^^^^^^\n+   |\n+help: change this to\n+   |\n+40 | fn cloned(x: &[u8]) -> Vec<u8> {\n+   |              ^^^^^\n+help: change the `.clone()` to\n+   |\n+41 |     let e = x.to_owned();\n+   |             ^^^^^^^^^^^^\n+help: change the `.clone()` to\n+   |\n+46 |     x.to_owned()\n+   |     ^^^^^^^^^^^^\n+\n+error: writing `&String` instead of `&str` involves a new object where a slice will do.\n+  --> $DIR/ptr_arg.rs:49:18\n+   |\n+49 | fn str_cloned(x: &String) -> String {\n+   |                  ^^^^^^^\n+   |\n+help: change this to\n+   |\n+49 | fn str_cloned(x: &str) -> String {\n+   |                  ^^^^\n+help: change the `.clone` to \n+   |\n+50 |     let a = x.to_string();\n+   |             ^^^^^^^^^^^^^\n+help: change the `.clone` to \n+   |\n+51 |     let b = x.to_string();\n+   |             ^^^^^^^^^^^^^\n+help: change the `.clone` to \n+   |\n+56 |     x.to_string()\n+   |     ^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n "}]}