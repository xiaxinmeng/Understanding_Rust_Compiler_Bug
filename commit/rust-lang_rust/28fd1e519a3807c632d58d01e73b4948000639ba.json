{"sha": "28fd1e519a3807c632d58d01e73b4948000639ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZmQxZTUxOWEzODA3YzYzMmQ1OGQwMWU3M2I0OTQ4MDAwNjM5YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-27T20:35:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-27T20:35:25Z"}, "message": "Auto merge of #42137 - nical:doc-clone, r=BurntSushi\n\nUpdate to Rc and Arc documentation to favor the Rc::clone(&ptr) syntax.\n\nThis is a followup of the discussion in https://github.com/rust-lang/rfcs/pull/1954.\n\nThe solution chosen by the core team to address the problem tackled by the [the RFC](https://github.com/rust-lang/rfcs/pull/1954) was to make the function call syntax Rc::clone(&foo) the idiomatic way to clone a reference counted pointer (over the method call syntax foo.clone()).\nThis change updates the documentation of Rc, Arc and their respective Weak pointers to reflect this decision and bring more exposure to the existence of the function call syntax.", "tree": {"sha": "2b280cbdbd9967997780bc73dfdaa84e6a1968f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b280cbdbd9967997780bc73dfdaa84e6a1968f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28fd1e519a3807c632d58d01e73b4948000639ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28fd1e519a3807c632d58d01e73b4948000639ba", "html_url": "https://github.com/rust-lang/rust/commit/28fd1e519a3807c632d58d01e73b4948000639ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28fd1e519a3807c632d58d01e73b4948000639ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9337ad5baec6e63ac6231193b2c0a4d810198b1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9337ad5baec6e63ac6231193b2c0a4d810198b1d", "html_url": "https://github.com/rust-lang/rust/commit/9337ad5baec6e63ac6231193b2c0a4d810198b1d"}, {"sha": "dec23d41a607b78c590ab9672815ff53c1e282a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec23d41a607b78c590ab9672815ff53c1e282a7", "html_url": "https://github.com/rust-lang/rust/commit/dec23d41a607b78c590ab9672815ff53c1e282a7"}], "stats": {"total": 92, "additions": 64, "deletions": 28}, "files": [{"sha": "5faf4dcccaf9134a0b01d3ceb4313818359603cf", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1e519a3807c632d58d01e73b4948000639ba/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1e519a3807c632d58d01e73b4948000639ba/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=28fd1e519a3807c632d58d01e73b4948000639ba", "patch": "@@ -91,6 +91,24 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n /// pointers from children back to their parents.\n ///\n+/// # Cloning references\n+///\n+/// Creating a new reference from an existing reference counted pointer is done using the\n+/// `Clone` trait implemented for [`Arc<T>`][`arc`] and [`Weak<T>`][`weak`].\n+///\n+/// ```\n+/// use std::sync::Arc;\n+/// let foo = Arc::new(vec![1.0, 2.0, 3.0]);\n+/// // The two syntaxes below are equivalent.\n+/// let a = foo.clone();\n+/// let b = Arc::clone(&foo);\n+/// // a and b both point to the same memory location as foo.\n+/// ```\n+///\n+/// The `Arc::clone(&from)` syntax is the most idiomatic because it conveys more explicitly\n+/// the meaning of the code. In the example above, this syntax makes it easier to see that\n+/// this code is creating a new reference rather than copying the whole content of foo.\n+///\n /// ## `Deref` behavior\n ///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n@@ -138,7 +156,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// let five = Arc::new(5);\n ///\n /// for _ in 0..10 {\n-///     let five = five.clone();\n+///     let five = Arc::clone(&five);\n ///\n ///     thread::spawn(move || {\n ///         println!(\"{:?}\", five);\n@@ -158,7 +176,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// let val = Arc::new(AtomicUsize::new(5));\n ///\n /// for _ in 0..10 {\n-///     let val = val.clone();\n+///     let val = Arc::clone(&val);\n ///\n ///     thread::spawn(move || {\n ///         let v = val.fetch_add(1, Ordering::SeqCst);\n@@ -282,7 +300,7 @@ impl<T> Arc<T> {\n     /// assert_eq!(Arc::try_unwrap(x), Ok(3));\n     ///\n     /// let x = Arc::new(4);\n-    /// let _y = x.clone();\n+    /// let _y = Arc::clone(&x);\n     /// assert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[inline]\n@@ -451,7 +469,7 @@ impl<T: ?Sized> Arc<T> {\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n-    /// let _also_five = five.clone();\n+    /// let _also_five = Arc::clone(&five);\n     ///\n     /// // This assertion is deterministic because we haven't shared\n     /// // the `Arc` between threads.\n@@ -499,7 +517,7 @@ impl<T: ?Sized> Arc<T> {\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n-    /// let same_five = five.clone();\n+    /// let same_five = Arc::clone(&five);\n     /// let other_five = Arc::new(5);\n     ///\n     /// assert!(Arc::ptr_eq(&five, &same_five));\n@@ -524,7 +542,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five.clone();\n+    /// Arc::clone(&five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Arc<T> {\n@@ -591,7 +609,7 @@ impl<T: Clone> Arc<T> {\n     /// let mut data = Arc::new(5);\n     ///\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n-    /// let mut other_data = data.clone();      // Won't clone inner data\n+    /// let mut other_data = Arc::clone(&data); // Won't clone inner data\n     /// *Arc::make_mut(&mut data) += 1;         // Clones inner data\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n@@ -679,7 +697,7 @@ impl<T: ?Sized> Arc<T> {\n     /// *Arc::get_mut(&mut x).unwrap() = 4;\n     /// assert_eq!(*x, 4);\n     ///\n-    /// let _y = x.clone();\n+    /// let _y = Arc::clone(&x);\n     /// assert!(Arc::get_mut(&mut x).is_none());\n     /// ```\n     #[inline]\n@@ -751,7 +769,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n     /// }\n     ///\n     /// let foo  = Arc::new(Foo);\n-    /// let foo2 = foo.clone();\n+    /// let foo2 = Arc::clone(&foo);\n     ///\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n@@ -903,11 +921,11 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::Arc;\n+    /// use std::sync::{Arc, Weak};\n     ///\n     /// let weak_five = Arc::downgrade(&Arc::new(5));\n     ///\n-    /// weak_five.clone();\n+    /// Weak::clone(&weak_five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n@@ -956,7 +974,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::Arc;\n+    /// use std::sync::{Arc, Weak};\n     ///\n     /// struct Foo;\n     ///\n@@ -968,7 +986,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     ///\n     /// let foo = Arc::new(Foo);\n     /// let weak_foo = Arc::downgrade(&foo);\n-    /// let other_weak_foo = weak_foo.clone();\n+    /// let other_weak_foo = Weak::clone(&weak_foo);\n     ///\n     /// drop(weak_foo);   // Doesn't print anything\n     /// drop(foo);        // Prints \"dropped!\""}, {"sha": "33951b911dd51b469903fbfcd8b1b8b69ea86fea", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1e519a3807c632d58d01e73b4948000639ba/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1e519a3807c632d58d01e73b4948000639ba/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=28fd1e519a3807c632d58d01e73b4948000639ba", "patch": "@@ -55,6 +55,24 @@\n //! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n //! already been destroyed.\n //!\n+//! # Cloning references\n+//!\n+//! Creating a new reference from an existing reference counted pointer is done using the\n+//! `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n+//!\n+//! ```\n+//! use std::rc::Rc;\n+//! let foo = Rc::new(vec![1.0, 2.0, 3.0]);\n+//! // The two syntaxes below are equivalent.\n+//! let a = foo.clone();\n+//! let b = Rc::clone(&foo);\n+//! // a and b both point to the same memory location as foo.\n+//! ```\n+//!\n+//! The `Rc::clone(&from)` syntax is the most idiomatic because it conveys more explicitly\n+//! the meaning of the code. In the example above, this syntax makes it easier to see that\n+//! this code is creating a new reference rather than copying the whole content of foo.\n+//!\n //! # Examples\n //!\n //! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n@@ -90,11 +108,11 @@\n //!     // the reference count in the process.\n //!     let gadget1 = Gadget {\n //!         id: 1,\n-//!         owner: gadget_owner.clone(),\n+//!         owner: Rc::clone(&gadget_owner),\n //!     };\n //!     let gadget2 = Gadget {\n //!         id: 2,\n-//!         owner: gadget_owner.clone(),\n+//!         owner: Rc::clone(&gadget_owner),\n //!     };\n //!\n //!     // Dispose of our local variable `gadget_owner`.\n@@ -163,13 +181,13 @@\n //!     let gadget1 = Rc::new(\n //!         Gadget {\n //!             id: 1,\n-//!             owner: gadget_owner.clone(),\n+//!             owner: Rc::clone(&gadget_owner),\n //!         }\n //!     );\n //!     let gadget2 = Rc::new(\n //!         Gadget {\n //!             id: 2,\n-//!             owner: gadget_owner.clone(),\n+//!             owner: Rc::clone(&gadget_owner),\n //!         }\n //!     );\n //!\n@@ -316,7 +334,7 @@ impl<T> Rc<T> {\n     /// assert_eq!(Rc::try_unwrap(x), Ok(3));\n     ///\n     /// let x = Rc::new(4);\n-    /// let _y = x.clone();\n+    /// let _y = Rc::clone(&x);\n     /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[inline]\n@@ -508,7 +526,7 @@ impl<T: ?Sized> Rc<T> {\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n-    /// let _also_five = five.clone();\n+    /// let _also_five = Rc::clone(&five);\n     ///\n     /// assert_eq!(2, Rc::strong_count(&five));\n     /// ```\n@@ -550,7 +568,7 @@ impl<T: ?Sized> Rc<T> {\n     /// *Rc::get_mut(&mut x).unwrap() = 4;\n     /// assert_eq!(*x, 4);\n     ///\n-    /// let _y = x.clone();\n+    /// let _y = Rc::clone(&x);\n     /// assert!(Rc::get_mut(&mut x).is_none());\n     /// ```\n     #[inline]\n@@ -576,7 +594,7 @@ impl<T: ?Sized> Rc<T> {\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n-    /// let same_five = five.clone();\n+    /// let same_five = Rc::clone(&five);\n     /// let other_five = Rc::new(5);\n     ///\n     /// assert!(Rc::ptr_eq(&five, &same_five));\n@@ -608,7 +626,7 @@ impl<T: Clone> Rc<T> {\n     /// let mut data = Rc::new(5);\n     ///\n     /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n-    /// let mut other_data = data.clone();    // Won't clone inner data\n+    /// let mut other_data = Rc::clone(&data);    // Won't clone inner data\n     /// *Rc::make_mut(&mut data) += 1;        // Clones inner data\n     /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n     /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n@@ -680,7 +698,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// }\n     ///\n     /// let foo  = Rc::new(Foo);\n-    /// let foo2 = foo.clone();\n+    /// let foo2 = Rc::clone(&foo);\n     ///\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n@@ -720,7 +738,7 @@ impl<T: ?Sized> Clone for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five.clone();\n+    /// Rc::clone(&five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n@@ -1050,7 +1068,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::rc::Rc;\n+    /// use std::rc::{Rc, Weak};\n     ///\n     /// struct Foo;\n     ///\n@@ -1062,7 +1080,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     ///\n     /// let foo = Rc::new(Foo);\n     /// let weak_foo = Rc::downgrade(&foo);\n-    /// let other_weak_foo = weak_foo.clone();\n+    /// let other_weak_foo = Weak::clone(&weak_foo);\n     ///\n     /// drop(weak_foo);   // Doesn't print anything\n     /// drop(foo);        // Prints \"dropped!\"\n@@ -1090,11 +1108,11 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::rc::Rc;\n+    /// use std::rc::{Rc, Weak};\n     ///\n     /// let weak_five = Rc::downgrade(&Rc::new(5));\n     ///\n-    /// weak_five.clone();\n+    /// Weak::clone(&weak_five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {"}]}