{"sha": "8bea334a266dcf439ca2f61f448a15770a3766b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZWEzMzRhMjY2ZGNmNDM5Y2EyZjYxZjQ0OGExNTc3MGEzNzY2Yjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-03T12:07:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-04T06:12:24Z"}, "message": "don't rely on spans when checking tokens for jointness", "tree": {"sha": "76765106d83b1a4bebf9a6583664186cb3990cc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76765106d83b1a4bebf9a6583664186cb3990cc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bea334a266dcf439ca2f61f448a15770a3766b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bea334a266dcf439ca2f61f448a15770a3766b7", "html_url": "https://github.com/rust-lang/rust/commit/8bea334a266dcf439ca2f61f448a15770a3766b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bea334a266dcf439ca2f61f448a15770a3766b7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c6eb19d2fd9be130b6265f6bdbf8da3ba49c513", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c6eb19d2fd9be130b6265f6bdbf8da3ba49c513", "html_url": "https://github.com/rust-lang/rust/commit/1c6eb19d2fd9be130b6265f6bdbf8da3ba49c513"}], "stats": {"total": 76, "additions": 29, "deletions": 47}, "files": [{"sha": "f9b9c85fb56021ae3a0ee91348f2d4291bf8f03f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8bea334a266dcf439ca2f61f448a15770a3766b7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bea334a266dcf439ca2f61f448a15770a3766b7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=8bea334a266dcf439ca2f61f448a15770a3766b7", "patch": "@@ -123,54 +123,30 @@ impl<'a> StringReader<'a> {\n     /// `Err(())` means that some errors were encountered, which can be\n     /// retrieved using `buffer_fatal_errors`.\n     pub fn try_next_token(&mut self) -> Result<Token, ()> {\n-        let (token, _raw_span) = self.try_next_token_with_raw_span()?;\n-        Ok(token)\n-    }\n-\n-    /// Returns the next token, including trivia like whitespace or comments.\n-    ///\n-    /// Aborts in case of an error.\n-    pub fn next_token(&mut self) -> Token {\n-        let res = self.try_next_token();\n-        self.unwrap_or_abort(res)\n-    }\n-\n-    /// Returns the next token, skipping over trivia.\n-    /// Also returns an unoverriden span which can be used to check tokens\n-    fn real_token(&mut self) -> (Token, Span) {\n-        let res = try {\n-            loop {\n-                let t = self.try_next_token_with_raw_span()?;\n-                match t.0.kind {\n-                    token::Whitespace | token::Comment | token::Shebang(_) => continue,\n-                    _ => break t,\n-                }\n-            }\n-        };\n-\n-        self.unwrap_or_abort(res)\n-    }\n-\n-    fn try_next_token_with_raw_span(&mut self) -> Result<(Token, Span), ()> {\n         assert!(self.fatal_errs.is_empty());\n         match self.scan_whitespace_or_comment() {\n-            Some(comment) => {\n-                let raw_span = comment.span;\n-                Ok((comment, raw_span))\n-            }\n+            Some(comment) => Ok(comment),\n             None => {\n                 let (kind, start_pos, end_pos) = if self.is_eof() {\n                     (token::Eof, self.source_file.end_pos, self.source_file.end_pos)\n                 } else {\n                     let start_pos = self.pos;\n                     (self.next_token_inner()?, start_pos, self.pos)\n                 };\n-                let (real, raw) = self.mk_sp_and_raw(start_pos, end_pos);\n-                Ok((Token::new(kind, real), raw))\n+                let (real, _raw) = self.mk_sp_and_raw(start_pos, end_pos);\n+                Ok(Token::new(kind, real))\n             }\n         }\n     }\n \n+    /// Returns the next token, including trivia like whitespace or comments.\n+    ///\n+    /// Aborts in case of an error.\n+    pub fn next_token(&mut self) -> Token {\n+        let res = self.try_next_token();\n+        self.unwrap_or_abort(res)\n+    }\n+\n     #[inline]\n     fn is_eof(&self) -> bool {\n         self.ch.is_none()"}, {"sha": "830fbec58ded952c109184007741491d7a17aaa2", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8bea334a266dcf439ca2f61f448a15770a3766b7/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bea334a266dcf439ca2f61f448a15770a3766b7/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=8bea334a266dcf439ca2f61f448a15770a3766b7", "patch": "@@ -1,17 +1,17 @@\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use crate::print::pprust::token_to_string;\n use crate::parse::lexer::{StringReader, UnmatchedBrace};\n use crate::parse::token::{self, Token};\n use crate::parse::PResult;\n-use crate::tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree, TreeAndJoint};\n+use crate::tokenstream::{DelimSpan, IsJoint::{self, *}, TokenStream, TokenTree, TreeAndJoint};\n \n impl<'a> StringReader<'a> {\n     crate fn into_token_trees(self) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n         let mut tt_reader = TokenTreesReader {\n             string_reader: self,\n             token: Token::dummy(),\n-            raw_span: DUMMY_SP,\n+            joint_to_prev: Joint,\n             open_braces: Vec::new(),\n             unmatched_braces: Vec::new(),\n             matching_delim_spans: Vec::new(),\n@@ -25,7 +25,7 @@ impl<'a> StringReader<'a> {\n struct TokenTreesReader<'a> {\n     string_reader: StringReader<'a>,\n     token: Token,\n-    raw_span: Span,\n+    joint_to_prev: IsJoint,\n     /// Stack of open delimiters and their spans. Used for error message.\n     open_braces: Vec<(token::DelimToken, Span)>,\n     unmatched_braces: Vec<UnmatchedBrace>,\n@@ -205,20 +205,26 @@ impl<'a> TokenTreesReader<'a> {\n             },\n             _ => {\n                 let tt = TokenTree::Token(self.token.take());\n-                // Note that testing for joint-ness here is done via the raw\n-                // source span as the joint-ness is a property of the raw source\n-                // rather than wanting to take `override_span` into account.\n-                let raw_span = self.raw_span;\n                 self.real_token();\n-                let is_joint = raw_span.hi() == self.raw_span.lo() && self.token.is_op();\n+                let is_joint = self.joint_to_prev == Joint && self.token.is_op();\n                 Ok((tt, if is_joint { Joint } else { NonJoint }))\n             }\n         }\n     }\n \n     fn real_token(&mut self) {\n-        let (token, raw_span) = self.string_reader.real_token();\n-        self.token = token;\n-        self.raw_span = raw_span;\n+        self.joint_to_prev = Joint;\n+        loop {\n+            let token = self.string_reader.next_token();\n+            match token.kind {\n+                token::Whitespace | token::Comment | token::Shebang(_) => {\n+                    self.joint_to_prev = NonJoint;\n+                }\n+                _ => {\n+                    self.token = token;\n+                    return;\n+                },\n+            }\n+        }\n     }\n }"}]}