{"sha": "ab2d7e9a50746cdc21c78336c5e868b6ab834588", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMmQ3ZTlhNTA3NDZjZGMyMWM3ODMzNmM1ZTg2OGI2YWI4MzQ1ODg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-12T08:58:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-12T08:58:15Z"}, "message": "Rollup merge of #63406 - jakubadamw:resolve-inconsistent-names-suggest-qualified-path, r=petrochenkov\n\nSuggest using a qualified path in patterns with inconsistent bindings\n\nA program like the following one:\n\n```rust\nenum E { A, B, C }\nfn f(x: E) -> bool {\n    match x {\n        A | B => false,\n        C => true\n    }\n}\n```\n\nis rejected by the compiler due to `E` variant paths not being in scope.\nIn this case `A`, `B` are resolved as pattern bindings and consequently\nthe pattern is considered invalid as the inner or-patterns do not bind\nto the same set of identifiers.\n\nThis is expected but the compiler errors that follow could be surprising\nor confusing to some users. This commit adds a help note explaining that\nif the user desired to match against variants or consts, they should use\na qualified path. The help note is restricted to cases where the identifier\nstarts with an upper-case sequence so as to reduce the false negatives.\n\nSince this happens during resolution, there's no clean way to check what\nit is the patterns match against. The syntactic criterium, however, is in line\nwith the convention that's assumed by the `non-camel-case-types` lint.\n\nFixes #50831.", "tree": {"sha": "a2ae50dda1e6258b66846c35946a1eaf9fad40a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2ae50dda1e6258b66846c35946a1eaf9fad40a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab2d7e9a50746cdc21c78336c5e868b6ab834588", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdUSonCRBK7hj4Ov3rIwAAdHIIAA+cZruEHKVdavC7A9gmk03l\ncJHviXVSf8FppJyQxAa3j+Hzp0W5XQvN24Jxk9kCEL6IzN0I/X0MNLgzw8G7i8X6\n6jL58e971zz5O2UiQ2yKAetlhxU880eBrdovs4ulyS4uX47B3Z2J+GGnQQhX3pez\nL1gSqe3C/yU/1CDxxWah5NH04atw0fDSLx7oDUkrxTbSnNeEhJ/kE8rvYn708sck\nsS+los7L4mAPGVQonn6bnanGHxvabOMelysglE2jeMGkzmPSIXw6+9KdpnsVcjJ5\n+pmxqDx5leQkCkEG1AOMtqmLG4tZ6S0PSEz7vKnnh2ePQmI4xQTDsFbkj9w9gC0=\n=WbXU\n-----END PGP SIGNATURE-----\n", "payload": "tree a2ae50dda1e6258b66846c35946a1eaf9fad40a3\nparent e9615f2487dc2acdad2d1dd7668808728f99e310\nparent 30db4ebdc225521853889b50cc5164646bbe66ed\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565600295 +0200\ncommitter GitHub <noreply@github.com> 1565600295 +0200\n\nRollup merge of #63406 - jakubadamw:resolve-inconsistent-names-suggest-qualified-path, r=petrochenkov\n\nSuggest using a qualified path in patterns with inconsistent bindings\n\nA program like the following one:\n\n```rust\nenum E { A, B, C }\nfn f(x: E) -> bool {\n    match x {\n        A | B => false,\n        C => true\n    }\n}\n```\n\nis rejected by the compiler due to `E` variant paths not being in scope.\nIn this case `A`, `B` are resolved as pattern bindings and consequently\nthe pattern is considered invalid as the inner or-patterns do not bind\nto the same set of identifiers.\n\nThis is expected but the compiler errors that follow could be surprising\nor confusing to some users. This commit adds a help note explaining that\nif the user desired to match against variants or consts, they should use\na qualified path. The help note is restricted to cases where the identifier\nstarts with an upper-case sequence so as to reduce the false negatives.\n\nSince this happens during resolution, there's no clean way to check what\nit is the patterns match against. The syntactic criterium, however, is in line\nwith the convention that's assumed by the `non-camel-case-types` lint.\n\nFixes #50831.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2d7e9a50746cdc21c78336c5e868b6ab834588", "html_url": "https://github.com/rust-lang/rust/commit/ab2d7e9a50746cdc21c78336c5e868b6ab834588", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab2d7e9a50746cdc21c78336c5e868b6ab834588/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9615f2487dc2acdad2d1dd7668808728f99e310", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9615f2487dc2acdad2d1dd7668808728f99e310", "html_url": "https://github.com/rust-lang/rust/commit/e9615f2487dc2acdad2d1dd7668808728f99e310"}, {"sha": "30db4ebdc225521853889b50cc5164646bbe66ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/30db4ebdc225521853889b50cc5164646bbe66ed", "html_url": "https://github.com/rust-lang/rust/commit/30db4ebdc225521853889b50cc5164646bbe66ed"}], "stats": {"total": 226, "additions": 168, "deletions": 58}, "files": [{"sha": "1de67edb95c087285faea77b3cd1e2e4ceaa6133", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ab2d7e9a50746cdc21c78336c5e868b6ab834588", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{path_names_to_string, KNOWN_TOOLS};\n-use crate::{CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{BindingError, CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -207,21 +207,32 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::VariableNotBoundInPattern(binding_error) => {\n-                let target_sp = binding_error.target.iter().cloned().collect::<Vec<_>>();\n+                let BindingError { name, target, origin, could_be_path } = binding_error;\n+\n+                let target_sp = target.iter().copied().collect::<Vec<_>>();\n+                let origin_sp = origin.iter().copied().collect::<Vec<_>>();\n+\n                 let msp = MultiSpan::from_spans(target_sp.clone());\n-                let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n+                let msg = format!(\"variable `{}` is not bound in all patterns\", name);\n                 let mut err = self.session.struct_span_err_with_code(\n                     msp,\n                     &msg,\n                     DiagnosticId::Error(\"E0408\".into()),\n                 );\n                 for sp in target_sp {\n-                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n+                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", name));\n                 }\n-                let origin_sp = binding_error.origin.iter().cloned();\n                 for sp in origin_sp {\n                     err.span_label(sp, \"variable not in all patterns\");\n                 }\n+                if *could_be_path {\n+                    let help_msg = format!(\n+                        \"if you meant to match on a variant or a `const` item, consider \\\n+                         making the path in the pattern qualified: `?::{}`\",\n+                         name,\n+                     );\n+                    err.span_help(span, &help_msg);\n+                }\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name,"}, {"sha": "358eaae11e71275d860bcf74bb46a931f10b9b8d", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=ab2d7e9a50746cdc21c78336c5e868b6ab834588", "patch": "@@ -1136,65 +1136,53 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // Checks that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n-        if pats.is_empty() {\n-            return;\n-        }\n-\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n-        for (i, p) in pats.iter().enumerate() {\n-            let map_i = self.binding_mode_map(&p);\n-\n-            for (j, q) in pats.iter().enumerate() {\n-                if i == j {\n-                    continue;\n-                }\n \n-                let map_j = self.binding_mode_map(&q);\n-                for (&key, &binding_i) in &map_i {\n-                    if map_j.is_empty() {                   // Account for missing bindings when\n-                        let binding_error = missing_vars    // `map_j` has none.\n-                            .entry(key.name)\n-                            .or_insert(BindingError {\n-                                name: key.name,\n-                                origin: BTreeSet::new(),\n-                                target: BTreeSet::new(),\n-                            });\n-                        binding_error.origin.insert(binding_i.span);\n-                        binding_error.target.insert(q.span);\n-                    }\n-                    for (&key_j, &binding_j) in &map_j {\n-                        match map_i.get(&key_j) {\n-                            None => {  // missing binding\n-                                let binding_error = missing_vars\n-                                    .entry(key_j.name)\n-                                    .or_insert(BindingError {\n-                                        name: key_j.name,\n-                                        origin: BTreeSet::new(),\n-                                        target: BTreeSet::new(),\n-                                    });\n-                                binding_error.origin.insert(binding_j.span);\n-                                binding_error.target.insert(p.span);\n-                            }\n-                            Some(binding_i) => {  // check consistent binding\n-                                if binding_i.binding_mode != binding_j.binding_mode {\n-                                    inconsistent_vars\n-                                        .entry(key.name)\n-                                        .or_insert((binding_j.span, binding_i.span));\n-                                }\n+        for pat_outer in pats.iter() {\n+            let map_outer = self.binding_mode_map(&pat_outer);\n+\n+            for pat_inner in pats.iter().filter(|pat| pat.id != pat_outer.id) {\n+                let map_inner = self.binding_mode_map(&pat_inner);\n+\n+                for (&key_inner, &binding_inner) in map_inner.iter() {\n+                    match map_outer.get(&key_inner) {\n+                        None => {  // missing binding\n+                            let binding_error = missing_vars\n+                                .entry(key_inner.name)\n+                                .or_insert(BindingError {\n+                                    name: key_inner.name,\n+                                    origin: BTreeSet::new(),\n+                                    target: BTreeSet::new(),\n+                                    could_be_path:\n+                                        key_inner.name.as_str().starts_with(char::is_uppercase)\n+                                });\n+                            binding_error.origin.insert(binding_inner.span);\n+                            binding_error.target.insert(pat_outer.span);\n+                        }\n+                        Some(binding_outer) => {  // check consistent binding\n+                            if binding_outer.binding_mode != binding_inner.binding_mode {\n+                                inconsistent_vars\n+                                    .entry(key_inner.name)\n+                                    .or_insert((binding_inner.span, binding_outer.span));\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n-        let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n+\n+        let mut missing_vars = missing_vars.iter_mut().collect::<Vec<_>>();\n         missing_vars.sort();\n-        for (_, v) in missing_vars {\n+        for (name, mut v) in missing_vars {\n+            if inconsistent_vars.contains_key(name) {\n+                v.could_be_path = false;\n+            }\n             self.r.report_error(\n-                *v.origin.iter().next().unwrap(), ResolutionError::VariableNotBoundInPattern(v)\n-            );\n+                *v.origin.iter().next().unwrap(),\n+                ResolutionError::VariableNotBoundInPattern(v));\n         }\n+\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n@@ -1222,7 +1210,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.resolve_pattern(pat, source, &mut bindings_list);\n         }\n         // This has to happen *after* we determine which pat_idents are variants\n-        self.check_consistent_bindings(pats);\n+        if pats.len() > 1 {\n+            self.check_consistent_bindings(pats);\n+        }\n     }\n \n     fn resolve_block(&mut self, block: &Block) {"}, {"sha": "00f779afd0457eb588ff4b241fb621fc3d5dbe19", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ab2d7e9a50746cdc21c78336c5e868b6ab834588", "patch": "@@ -135,6 +135,7 @@ struct BindingError {\n     name: Name,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n+    could_be_path: bool\n }\n \n impl PartialOrd for BindingError {"}, {"sha": "2fb803c4b2ad429dbefb667dbd6f55688c67146b", "filename": "src/test/ui/resolve/resolve-inconsistent-names.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs?ref=ab2d7e9a50746cdc21c78336c5e868b6ab834588", "patch": "@@ -1,7 +1,36 @@\n+#![allow(non_camel_case_types)]\n+\n+enum E { A, B, c }\n+\n+mod m {\n+    const CONST1: usize = 10;\n+    const Const2: usize = 20;\n+}\n+\n fn main() {\n     let y = 1;\n     match y {\n        a | b => {} //~  ERROR variable `a` is not bound in all patterns\n-                   //~^ ERROR variable `b` is not bound in all patterns\n+                   //~| ERROR variable `b` is not bound in all patterns\n+    }\n+\n+    let x = (E::A, E::B);\n+    match x {\n+        (A, B) | (ref B, c) | (c, A) => ()\n+        //~^ ERROR variable `A` is not bound in all patterns\n+        //~| ERROR variable `B` is not bound in all patterns\n+        //~| ERROR variable `B` is bound in inconsistent ways\n+        //~| ERROR mismatched types\n+        //~| ERROR variable `c` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::A`\n+    }\n+\n+    let z = (10, 20);\n+    match z {\n+        (CONST1, _) | (_, Const2) => ()\n+        //~^ ERROR variable `CONST1` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::CONST1`\n+        //~| ERROR variable `Const2` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::Const2`\n     }\n }"}, {"sha": "f02867a0024b558d78b95be8e9e19235c42f8ca1", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab2d7e9a50746cdc21c78336c5e868b6ab834588/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=ab2d7e9a50746cdc21c78336c5e868b6ab834588", "patch": "@@ -1,19 +1,98 @@\n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:4:12\n+  --> $DIR/resolve-inconsistent-names.rs:13:12\n    |\n LL |        a | b => {}\n    |        -   ^ pattern doesn't bind `a`\n    |        |\n    |        variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:4:8\n+  --> $DIR/resolve-inconsistent-names.rs:13:8\n    |\n LL |        a | b => {}\n    |        ^   - variable not in all patterns\n    |        |\n    |        pattern doesn't bind `b`\n \n-error: aborting due to 2 previous errors\n+error[E0408]: variable `A` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:18\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |          -       ^^^^^^^^^^       - variable not in all patterns\n+   |          |       |\n+   |          |       pattern doesn't bind `A`\n+   |          variable not in all patterns\n+   |\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::A`\n+  --> $DIR/resolve-inconsistent-names.rs:19:10\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |          ^\n+\n+error[E0408]: variable `B` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:31\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |             -         -       ^^^^^^ pattern doesn't bind `B`\n+   |             |         |\n+   |             |         variable not in all patterns\n+   |             variable not in all patterns\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:9\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |         ^^^^^^           -     - variable not in all patterns\n+   |         |                |\n+   |         |                variable not in all patterns\n+   |         pattern doesn't bind `c`\n+\n+error[E0409]: variable `B` is bound in inconsistent ways within the same match arm\n+  --> $DIR/resolve-inconsistent-names.rs:19:23\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |             -         ^ bound in different ways\n+   |             |\n+   |             first binding\n+\n+error[E0408]: variable `CONST1` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:30:23\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |          ------       ^^^^^^^^^^^ pattern doesn't bind `CONST1`\n+   |          |\n+   |          variable not in all patterns\n+   |\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::CONST1`\n+  --> $DIR/resolve-inconsistent-names.rs:30:10\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |          ^^^^^^\n+\n+error[E0408]: variable `Const2` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:30:9\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |         ^^^^^^^^^^^       ------ variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `Const2`\n+   |\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::Const2`\n+  --> $DIR/resolve-inconsistent-names.rs:30:27\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |                           ^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/resolve-inconsistent-names.rs:19:19\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |                   ^^^^^ expected enum `E`, found &E\n+   |\n+   = note: expected type `E`\n+              found type `&E`\n+\n+error: aborting due to 9 previous errors\n \n-For more information about this error, try `rustc --explain E0408`.\n+Some errors have detailed explanations: E0308, E0408, E0409.\n+For more information about an error, try `rustc --explain E0308`."}]}