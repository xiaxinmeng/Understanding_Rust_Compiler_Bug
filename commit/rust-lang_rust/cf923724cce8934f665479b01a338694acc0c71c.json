{"sha": "cf923724cce8934f665479b01a338694acc0c71c", "node_id": "C_kwDOAAsO6NoAKGNmOTIzNzI0Y2NlODkzNGY2NjU0NzliMDFhMzM4Njk0YWNjMGM3MWM", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-11-21T16:29:09Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-11-21T16:29:09Z"}, "message": "Fix discriminant handling", "tree": {"sha": "56c2d77dc93ab636ad616803e08fd551f25a6c4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56c2d77dc93ab636ad616803e08fd551f25a6c4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf923724cce8934f665479b01a338694acc0c71c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf923724cce8934f665479b01a338694acc0c71c", "html_url": "https://github.com/rust-lang/rust/commit/cf923724cce8934f665479b01a338694acc0c71c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf923724cce8934f665479b01a338694acc0c71c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9723c79af7baa9f778566058aa1d50a8e2711b96", "url": "https://api.github.com/repos/rust-lang/rust/commits/9723c79af7baa9f778566058aa1d50a8e2711b96", "html_url": "https://github.com/rust-lang/rust/commit/9723c79af7baa9f778566058aa1d50a8e2711b96"}], "stats": {"total": 198, "additions": 153, "deletions": 45}, "files": [{"sha": "6a3ab8881bb6695c09f9e02d0bb1f5d344ce48b8", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf923724cce8934f665479b01a338694acc0c71c/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf923724cce8934f665479b01a338694acc0c71c/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=cf923724cce8934f665479b01a338694acc0c71c", "patch": "@@ -162,7 +162,7 @@ pub(crate) fn codegen_icmp_imm(\n             }\n         }\n     } else {\n-        let rhs = i64::try_from(rhs).expect(\"codegen_icmp_imm rhs out of range for <128bit int\");\n+        let rhs = rhs as i64; // Truncates on purpose in case rhs is actually an unsigned value\n         fx.bcx.ins().icmp_imm(intcc, lhs, rhs)\n     }\n }"}, {"sha": "11aa52a332c18b72e774df6a56a012562477c25d", "filename": "src/discriminant.rs", "status": "modified", "additions": 152, "deletions": 44, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/cf923724cce8934f665479b01a338694acc0c71c/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf923724cce8934f665479b01a338694acc0c71c/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=cf923724cce8934f665479b01a338694acc0c71c", "patch": "@@ -1,6 +1,7 @@\n //! Handling of enum discriminants\n //!\n-//! Adapted from <https://github.com/rust-lang/rust/blob/d760df5aea483aae041c9a241e7acacf48f75035/src/librustc_codegen_ssa/mir/place.rs>\n+//! Adapted from <https://github.com/rust-lang/rust/blob/31c0645b9d2539f47eecb096142474b29dc542f7/compiler/rustc_codegen_ssa/src/mir/place.rs>\n+//! (<https://github.com/rust-lang/rust/pull/104535>)\n \n use rustc_target::abi::{Int, TagEncoding, Variants};\n \n@@ -47,13 +48,18 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         } => {\n             if variant_index != untagged_variant {\n                 let niche = place.place_field(fx, mir::Field::new(tag_field));\n+                let niche_type = fx.clif_type(niche.layout().ty).unwrap();\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n-                let niche_value = ty::ScalarInt::try_from_uint(\n-                    u128::from(niche_value).wrapping_add(niche_start),\n-                    niche.layout().size,\n-                )\n-                .unwrap();\n-                let niche_llval = CValue::const_val(fx, niche.layout(), niche_value);\n+                let niche_value = (niche_value as u128).wrapping_add(niche_start);\n+                let niche_value = match niche_type {\n+                    types::I128 => {\n+                        let lsb = fx.bcx.ins().iconst(types::I64, niche_value as u64 as i64);\n+                        let msb = fx.bcx.ins().iconst(types::I64, (niche_value >> 64) as u64 as i64);\n+                        fx.bcx.ins().iconcat(lsb, msb)\n+                    }\n+                    ty => fx.bcx.ins().iconst(ty, niche_value as i64),\n+                };\n+                let niche_llval = CValue::by_val(niche_value, niche.layout());\n                 niche.write_cvalue(fx, niche_llval);\n             }\n         }\n@@ -96,6 +102,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         }\n     };\n \n+    let cast_to_size = dest_layout.layout.size();\n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n@@ -114,21 +121,128 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-            // Rebase from niche values to discriminants, and check\n-            // whether the result is in range for the niche variants.\n-\n-            // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n-            // that is, if `n = niche_variants.end() - niche_variants.start()`,\n-            // we remap `niche_start..=niche_start + n` (which may wrap around)\n-            // to (non-wrap-around) `0..=n`, to be able to check whether the\n-            // discriminant corresponds to a niche variant with one comparison.\n-            // We also can't go directly to the (variant index) discriminant\n-            // and check that it is in the range `niche_variants`, because\n-            // that might not fit in the same type, on top of needing an extra\n-            // comparison (see also the comment on `let niche_discr`).\n-            let relative_discr = if niche_start == 0 {\n-                tag\n+            let tag_size = tag_scalar.size(fx);\n+            let max_unsigned = tag_size.unsigned_int_max();\n+            let max_signed = tag_size.signed_int_max() as u128;\n+            let min_signed = max_signed + 1;\n+            let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n+            let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n+            let range = tag_scalar.valid_range(fx);\n+\n+            let sle = |lhs: u128, rhs: u128| -> bool {\n+                // Signed and unsigned comparisons give the same results,\n+                // except that in signed comparisons an integer with the\n+                // sign bit set is less than one with the sign bit clear.\n+                // Toggle the sign bit to do a signed comparison.\n+                (lhs ^ min_signed) <= (rhs ^ min_signed)\n+            };\n+\n+            // We have a subrange `niche_start..=niche_end` inside `range`.\n+            // If the value of the tag is inside this subrange, it's a\n+            // \"niche value\", an increment of the discriminant. Otherwise it\n+            // indicates the untagged variant.\n+            // A general algorithm to extract the discriminant from the tag\n+            // is:\n+            // relative_tag = tag - niche_start\n+            // is_niche = relative_tag <= (ule) relative_max\n+            // discr = if is_niche {\n+            //     cast(relative_tag) + niche_variants.start()\n+            // } else {\n+            //     untagged_variant\n+            // }\n+            // However, we will likely be able to emit simpler code.\n+\n+            // Find the least and greatest values in `range`, considered\n+            // both as signed and unsigned.\n+            let (low_unsigned, high_unsigned) =\n+                if range.start <= range.end { (range.start, range.end) } else { (0, max_unsigned) };\n+            let (low_signed, high_signed) = if sle(range.start, range.end) {\n+                (range.start, range.end)\n+            } else {\n+                (min_signed, max_signed)\n+            };\n+\n+            let niches_ule = niche_start <= niche_end;\n+            let niches_sle = sle(niche_start, niche_end);\n+            let cast_smaller = cast_to_size <= tag_size;\n+\n+            // In the algorithm above, we can change\n+            // cast(relative_tag) + niche_variants.start()\n+            // into\n+            // cast(tag + (niche_variants.start() - niche_start))\n+            // if either the casted type is no larger than the original\n+            // type, or if the niche values are contiguous (in either the\n+            // signed or unsigned sense).\n+            let can_incr = cast_smaller || niches_ule || niches_sle;\n+\n+            let data_for_boundary_niche = || -> Option<(IntCC, u128)> {\n+                if !can_incr {\n+                    None\n+                } else if niche_start == low_unsigned {\n+                    Some((IntCC::UnsignedLessThanOrEqual, niche_end))\n+                } else if niche_end == high_unsigned {\n+                    Some((IntCC::UnsignedGreaterThanOrEqual, niche_start))\n+                } else if niche_start == low_signed {\n+                    Some((IntCC::SignedLessThanOrEqual, niche_end))\n+                } else if niche_end == high_signed {\n+                    Some((IntCC::SignedGreaterThanOrEqual, niche_start))\n+                } else {\n+                    None\n+                }\n+            };\n+\n+            let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n+                // Best case scenario: only one tagged variant. This will\n+                // likely become just a comparison and a jump.\n+                // The algorithm is:\n+                // is_niche = tag == niche_start\n+                // discr = if is_niche {\n+                //     niche_start\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                let is_niche = codegen_icmp_imm(fx, IntCC::Equal, tag, niche_start as i128);\n+                let tagged_discr =\n+                    fx.bcx.ins().iconst(cast_to, niche_variants.start().as_u32() as i64);\n+                (is_niche, tagged_discr, 0)\n+            } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n+                // The niche values are either the lowest or the highest in\n+                // `range`. We can avoid the first subtraction in the\n+                // algorithm.\n+                // The algorithm is now this:\n+                // is_niche = tag <= niche_end\n+                // discr = if is_niche {\n+                //     cast(tag + (niche_variants.start() - niche_start))\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                // (the first line may instead be tag >= niche_start,\n+                // and may be a signed or unsigned comparison)\n+                // The arithmetic must be done before the cast, so we can\n+                // have the correct wrapping behavior. See issue #104519 for\n+                // the consequences of getting this wrong.\n+                let is_niche = codegen_icmp_imm(fx, predicate, tag, constant as i128);\n+                let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n+                let incr_tag = if delta == 0 {\n+                    tag\n+                } else {\n+                    let delta = match fx.bcx.func.dfg.value_type(tag) {\n+                        types::I128 => {\n+                            let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n+                            let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n+                            fx.bcx.ins().iconcat(lsb, msb)\n+                        }\n+                        ty => fx.bcx.ins().iconst(ty, delta as i64),\n+                    };\n+                    fx.bcx.ins().iadd(tag, delta)\n+                };\n+\n+                let cast_tag = clif_intcast(fx, incr_tag, cast_to, !niches_ule);\n+\n+                (is_niche, cast_tag, 0)\n             } else {\n+                // The special cases don't apply, so we'll have to go with\n+                // the general algorithm.\n                 let niche_start = match fx.bcx.func.dfg.value_type(tag) {\n                     types::I128 => {\n                         let lsb = fx.bcx.ins().iconst(types::I64, niche_start as u64 as i64);\n@@ -138,40 +252,34 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                     }\n                     ty => fx.bcx.ins().iconst(ty, niche_start as i64),\n                 };\n-                fx.bcx.ins().isub(tag, niche_start)\n-            };\n-            let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-            let is_niche = {\n-                codegen_icmp_imm(\n+                let relative_discr = fx.bcx.ins().isub(tag, niche_start);\n+                let cast_tag = clif_intcast(fx, relative_discr, cast_to, false);\n+                let is_niche = crate::common::codegen_icmp_imm(\n                     fx,\n                     IntCC::UnsignedLessThanOrEqual,\n                     relative_discr,\n                     i128::from(relative_max),\n-                )\n+                );\n+                (is_niche, cast_tag, niche_variants.start().as_u32() as u128)\n             };\n \n-            // NOTE(eddyb) this addition needs to be performed on the final\n-            // type, in case the niche itself can't represent all variant\n-            // indices (e.g. `u8` niche with more than `256` variants,\n-            // but enough uninhabited variants so that the remaining variants\n-            // fit in the niche).\n-            // In other words, `niche_variants.end - niche_variants.start`\n-            // is representable in the niche, but `niche_variants.end`\n-            // might not be, in extreme cases.\n-            let niche_discr = {\n-                let relative_discr = if relative_max == 0 {\n-                    // HACK(eddyb) since we have only one niche, we know which\n-                    // one it is, and we can avoid having a dynamic value here.\n-                    fx.bcx.ins().iconst(cast_to, 0)\n-                } else {\n-                    clif_intcast(fx, relative_discr, cast_to, false)\n+            let tagged_discr = if delta == 0 {\n+                tagged_discr\n+            } else {\n+                let delta = match cast_to {\n+                    types::I128 => {\n+                        let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n+                        let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n+                        fx.bcx.ins().iconcat(lsb, msb)\n+                    }\n+                    ty => fx.bcx.ins().iconst(ty, delta as i64),\n                 };\n-                fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+                fx.bcx.ins().iadd(tagged_discr, delta)\n             };\n \n             let untagged_variant =\n                 fx.bcx.ins().iconst(cast_to, i64::from(untagged_variant.as_u32()));\n-            let discr = fx.bcx.ins().select(is_niche, niche_discr, untagged_variant);\n+            let discr = fx.bcx.ins().select(is_niche, tagged_discr, untagged_variant);\n             let res = CValue::by_val(discr, dest_layout);\n             dest.write_cvalue(fx, res);\n         }"}]}