{"sha": "5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMWE2OTExMjU4NDM0MTUyMmUyY2MwMGJmYzZkZDFkYjZlMGVjM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-30T07:31:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-30T07:31:23Z"}, "message": "auto merge of #9613 : jld/rust/enum-discrim-size.r0, r=alexcrichton\n\nAllows an enum with a discriminant to use any of the primitive integer types to store it.  By default the smallest usable type is chosen, but this can be overridden with an attribute: `#[repr(int)]` etc., or `#[repr(C)]` to match the target's C ABI for the equivalent C enum.\r\n\r\nAlso adds a lint pass for using non-FFI safe enums in extern declarations, checks that specified discriminants can be stored in the specified type if any, and fixes assorted code that was assuming int.", "tree": {"sha": "bc856e4b2bd4ac269cbfe593c190cd77beaa1dbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc856e4b2bd4ac269cbfe593c190cd77beaa1dbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "html_url": "https://github.com/rust-lang/rust/commit/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42e378f32e212997fc42281112b1c9c4c247de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42e378f32e212997fc42281112b1c9c4c247de0", "html_url": "https://github.com/rust-lang/rust/commit/e42e378f32e212997fc42281112b1c9c4c247de0"}, {"sha": "86a710e4545a383513c1247e48421142f3741984", "url": "https://api.github.com/repos/rust-lang/rust/commits/86a710e4545a383513c1247e48421142f3741984", "html_url": "https://github.com/rust-lang/rust/commit/86a710e4545a383513c1247e48421142f3741984"}], "stats": {"total": 1165, "additions": 967, "deletions": 198}, "files": [{"sha": "bf2e878f7f5b3f185049caf5eb2b23a902577197", "filename": "mk/tests.mk", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -465,6 +465,17 @@ $(foreach host,$(CFG_HOST_TRIPLES), \\\n       $(eval $(call DEF_TEST_CRATE_RULES,$(stage),$(target),$(host),$(crate))) \\\n      ))))))\n \n+# FIXME (#10104): Raise the stack size to work around rustpkg bypassing\n+# the code in rustc that would take care of it.\n+define DEF_RUSTPKG_STACK_FIX\n+$$(call TEST_OK_FILE,$(1),$(2),$(3),rustpkg): export RUST_MIN_STACK=8000000\n+endef\n+\n+$(foreach host,$(CFG_HOST_TRIPLES), \\\n+ $(foreach target,$(CFG_TARGET_TRIPLES), \\\n+  $(foreach stage,$(STAGES), \\\n+   $(eval $(call DEF_RUSTPKG_STACK_FIX,$(stage),$(target),$(host))))))\n+\n \n ######################################################################\n # Rules for the compiletest tests (rpass, rfail, etc.)"}, {"sha": "13c4c7948b803c9a69f64ab914a88836fd3981b7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -281,7 +281,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     };\n     let config = &mut config;\n     let cmds = props.debugger_cmds.connect(\"\\n\");\n-    let check_lines = props.check_lines.clone();\n+    let check_lines = &props.check_lines;\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let mut ProcRes = compile_test(config, props, testfile);\n@@ -315,11 +315,34 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     let num_check_lines = check_lines.len();\n     if num_check_lines > 0 {\n+        // Allow check lines to leave parts unspecified (e.g., uninitialized\n+        // bits in the wrong case of an enum) with the notation \"[...]\".\n+        let check_fragments: ~[~[&str]] = check_lines.map(|s| s.split_str_iter(\"[...]\").collect());\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n         for line in ProcRes.stdout.line_iter() {\n-            if check_lines[i].trim() == line.trim() {\n+            let mut rest = line.trim();\n+            let mut first = true;\n+            let mut failed = false;\n+            for &frag in check_fragments[i].iter() {\n+                let found = if first {\n+                    if rest.starts_with(frag) { Some(0) } else { None }\n+                } else {\n+                    rest.find_str(frag)\n+                };\n+                match found {\n+                    None => {\n+                        failed = true;\n+                        break;\n+                    }\n+                    Some(i) => {\n+                        rest = rest.slice_from(i + frag.len());\n+                    }\n+                }\n+                first = false;\n+            }\n+            if !failed && rest.len() == 0 {\n                 i += 1u;\n             }\n             if i == num_check_lines {"}, {"sha": "75611f88b6384eefe5cea9885a5fec5393b2eb8a", "filename": "src/libextra/enum_set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibextra%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibextra%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fenum_set.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -140,6 +140,7 @@ mod test {\n     use enum_set::*;\n \n     #[deriving(Eq)]\n+    #[repr(uint)]\n     enum Foo {\n         A, B, C\n     }"}, {"sha": "4eb8a0b8fa644c6d924082fab3ce4b1f621064be", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -147,6 +147,7 @@ pub static Vector: TypeKind    = 13;\n pub static Metadata: TypeKind  = 14;\n pub static X86_MMX: TypeKind   = 15;\n \n+#[repr(C)]\n pub enum AtomicBinOp {\n     Xchg = 0,\n     Add  = 1,\n@@ -161,6 +162,7 @@ pub enum AtomicBinOp {\n     UMin = 10,\n }\n \n+#[repr(C)]\n pub enum AtomicOrdering {\n     NotAtomic = 0,\n     Unordered = 1,\n@@ -173,6 +175,7 @@ pub enum AtomicOrdering {\n }\n \n // Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n+#[repr(C)]\n pub enum FileType {\n     AssemblyFile = 0,\n     ObjectFile = 1\n@@ -194,20 +197,23 @@ pub enum AsmDialect {\n }\n \n #[deriving(Eq)]\n+#[repr(C)]\n pub enum CodeGenOptLevel {\n     CodeGenLevelNone = 0,\n     CodeGenLevelLess = 1,\n     CodeGenLevelDefault = 2,\n     CodeGenLevelAggressive = 3,\n }\n \n+#[repr(C)]\n pub enum RelocMode {\n     RelocDefault = 0,\n     RelocStatic = 1,\n     RelocPIC = 2,\n     RelocDynamicNoPic = 3,\n }\n \n+#[repr(C)]\n pub enum CodeGenModel {\n     CodeModelDefault = 0,\n     CodeModelJITDefault = 1,"}, {"sha": "6294b6cb6e3128f6cfa400187cb1f8161266c6d4", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -112,6 +112,7 @@ pub static tag_items_data_item_reexport_name: uint = 0x4f;\n \n // used to encode crate_ctxt side tables\n #[deriving(Eq)]\n+#[repr(uint)]\n pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,\n \n@@ -143,7 +144,7 @@ impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n         if !is_a_tag { None } else {\n-            Some(unsafe { cast::transmute(value as int) })\n+            Some(unsafe { cast::transmute(value) })\n         }\n     }\n }"}, {"sha": "86c4ca0158f19c8d25a8f888acced425a8a698c8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -989,6 +989,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 't');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n+        encode_attributes(ebml_w, item.attrs);\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }"}, {"sha": "e8f9dad65851beab32e35424518e4cedc13c323d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -34,6 +34,7 @@\n //! Context itself, span_lint should be used instead of add_lint.\n \n use driver::session;\n+use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::ty;\n use middle::pat_util;\n use metadata::csearch;\n@@ -627,6 +628,14 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n                                 \"found rust type `uint` in foreign module, while \\\n                                 libc::c_uint or libc::c_ulong should be used\");\n                     }\n+                    ast::DefTy(def_id) => {\n+                        if !adt::is_ffi_safe(cx.tcx, def_id) {\n+                            cx.span_lint(ctypes, ty.span,\n+                                         \"found enum type without foreign-function-safe \\\n+                                          representation annotation in foreign module\");\n+                            // NOTE this message could be more helpful\n+                        }\n+                    }\n                     _ => ()\n                 }\n             }"}, {"sha": "997bcbca9ce0b33b245b81d70f00589ae8c331a8", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 280, "deletions": 96, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -14,7 +14,8 @@\n  * This module determines how to represent enums, structs, and tuples\n  * based on their monomorphized types; it is responsible both for\n  * choosing a representation and translating basic operations on\n- * values of those types.\n+ * values of those types.  (Note: exporting the representations for\n+ * debuggers is handled in debuginfo.rs, not here.)\n  *\n  * Note that the interface treats everything as a general case of an\n  * enum, so structs/tuples/etc. have one pseudo-variant with\n@@ -29,8 +30,6 @@\n  *   that might contain one and adjust GEP indices accordingly.  See\n  *   issue #4578.\n  *\n- * - Using smaller integer types for discriminants.\n- *\n  * - Store nested enums' discriminants in the same word.  Rather, if\n  *   some variants start with enums, and those enums representations\n  *   have unused alignment padding between discriminant and body, the\n@@ -56,16 +55,21 @@ use middle::trans::machine;\n use middle::trans::type_of;\n use middle::ty;\n use middle::ty::Disr;\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::ast;\n+use syntax::attr;\n+use syntax::attr::IntType;\n use util::ppaux::ty_to_str;\n \n use middle::trans::type_::Type;\n \n+type Hint = attr::ReprAttr;\n+\n \n /// Representations.\n pub enum Repr {\n     /// C-like enums; basically an int.\n-    CEnum(Disr, Disr), // discriminant range\n+    CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /**\n      * Single-case variants, and structs/tuples/records.\n      *\n@@ -78,7 +82,7 @@ pub enum Repr {\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n      */\n-    General(~[Struct]),\n+    General(IntType, ~[Struct]),\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n@@ -141,38 +145,26 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            struct Case { discr: Disr, tys: ~[ty::t] };\n-            impl Case {\n-                fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n-                    mk_struct(cx, self.tys, false).size == 0\n-                }\n-                fn find_ptr(&self) -> Option<uint> {\n-                    self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n-                }\n-            }\n-\n-            let cases = do ty::enum_variants(cx.tcx, def_id).map |vi| {\n-                let arg_tys = do vi.args.map |&raw_ty| {\n-                    ty::subst(cx.tcx, substs, raw_ty)\n-                };\n-                Case { discr: vi.disr_val, tys: arg_tys }\n-            };\n+            let cases = get_cases(cx.tcx, def_id, substs);\n+            let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n \n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n+                // (Typechecking will reject discriminant-sizing attrs.)\n+                assert_eq!(hint, attr::ReprAny);\n                 return Univariant(mk_struct(cx, [], false), false);\n             }\n \n             if cases.iter().all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n-                return CEnum(*discrs.iter().min().unwrap(), *discrs.iter().max().unwrap());\n-            }\n-\n-            if cases.len() == 1 {\n-                // Equivalent to a struct/tuple/newtype.\n-                assert_eq!(cases[0].discr, 0);\n-                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n+                let bounds = IntBounds {\n+                    ulo: *discrs.iter().min().unwrap(),\n+                    uhi: *discrs.iter().max().unwrap(),\n+                    slo: discrs.iter().map(|n| *n as i64).min().unwrap(),\n+                    shi: discrs.iter().map(|n| *n as i64).max().unwrap()\n+                };\n+                return mk_cenum(cx, hint, &bounds);\n             }\n \n             // Since there's at least one\n@@ -184,7 +176,15 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                                  ty::item_path_str(cx.tcx, def_id)))\n             }\n \n-            if cases.len() == 2 {\n+            if cases.len() == 1 {\n+                // Equivalent to a struct/tuple/newtype.\n+                // (Typechecking will reject discriminant-sizing attrs.)\n+                assert_eq!(hint, attr::ReprAny);\n+                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n+            }\n+\n+            if cases.len() == 2 && hint == attr::ReprAny {\n+                // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx) {\n@@ -207,13 +207,67 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             }\n \n             // The general case.\n-            let discr = ~[ty::mk_uint()];\n-            return General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n+            assert!((cases.len() - 1) as i64 >= 0);\n+            let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n+                                     slo: 0, shi: (cases.len() - 1) as i64 };\n+            let ity = range_to_inttype(cx, hint, &bounds);\n+            let discr = ~[ty_of_inttype(ity)];\n+            return General(ity, cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n         _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n     }\n }\n \n+/// Determine, without doing translation, whether an ADT must be FFI-safe.\n+/// For use in lint or similar, where being sound but slightly incomplete is acceptable.\n+pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n+    match ty::get(ty::lookup_item_type(tcx, def_id).ty).sty {\n+        ty::ty_enum(def_id, _) => {\n+            let variants = ty::enum_variants(tcx, def_id);\n+            // Univariant => like struct/tuple.\n+            if variants.len() <= 1 {\n+                return true;\n+            }\n+            let hint = ty::lookup_repr_hint(tcx, def_id);\n+            // Appropriate representation explicitly selected?\n+            if hint.is_ffi_safe() {\n+                return true;\n+            }\n+            // Option<~T> and similar are used in FFI.  Rather than try to resolve type parameters\n+            // and recognize this case exactly, this overapproximates -- assuming that if a\n+            // non-C-like enum is being used in FFI then the user knows what they're doing.\n+            if variants.iter().any(|vi| !vi.args.is_empty()) {\n+                return true;\n+            }\n+            false\n+        }\n+        // struct, tuple, etc.\n+        // (is this right in the present of typedefs?)\n+        _ => true\n+    }\n+}\n+\n+// NOTE this should probably all be in ty\n+struct Case { discr: Disr, tys: ~[ty::t] }\n+impl Case {\n+    fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n+        mk_struct(cx, self.tys, false).size == 0\n+    }\n+    fn find_ptr(&self) -> Option<uint> {\n+        self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n+    }\n+}\n+\n+fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case] {\n+    do ty::enum_variants(tcx, def_id).map |vi| {\n+        let arg_tys = do vi.args.map |&raw_ty| {\n+            ty::subst(tcx, substs, raw_ty)\n+        };\n+        Case { discr: vi.disr_val, tys: arg_tys }\n+    }\n+}\n+\n+\n fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n     let llty_rec = Type::struct_(lltys, packed);\n@@ -225,6 +279,92 @@ fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     }\n }\n \n+struct IntBounds {\n+    slo: i64,\n+    shi: i64,\n+    ulo: u64,\n+    uhi: u64\n+}\n+\n+fn mk_cenum(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n+    let it = range_to_inttype(cx, hint, bounds);\n+    match it {\n+        attr::SignedInt(_) => CEnum(it, bounds.slo as Disr, bounds.shi as Disr),\n+        attr::UnsignedInt(_) => CEnum(it, bounds.ulo, bounds.uhi)\n+    }\n+}\n+\n+fn range_to_inttype(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n+    debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n+    // Lists of sizes to try.  u64 is always allowed as a fallback.\n+    static choose_shortest: &'static[IntType] = &[\n+        attr::UnsignedInt(ast::ty_u8), attr::SignedInt(ast::ty_i8),\n+        attr::UnsignedInt(ast::ty_u16), attr::SignedInt(ast::ty_i16),\n+        attr::UnsignedInt(ast::ty_u32), attr::SignedInt(ast::ty_i32)];\n+    static at_least_32: &'static[IntType] = &[\n+        attr::UnsignedInt(ast::ty_u32), attr::SignedInt(ast::ty_i32)];\n+\n+    let attempts;\n+    match hint {\n+        attr::ReprInt(span, ity) => {\n+            if !bounds_usable(cx, ity, bounds) {\n+                cx.sess.span_bug(span, \"representation hint insufficient for discriminant range\")\n+            }\n+            return ity;\n+        }\n+        attr::ReprExtern => {\n+            attempts = match cx.sess.targ_cfg.arch {\n+                X86 | X86_64 => at_least_32,\n+                // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n+                // appears to be used on Linux and NetBSD, but some systems may use the variant\n+                // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n+                Arm => at_least_32,\n+                Mips => at_least_32,\n+            }\n+        }\n+        attr::ReprAny => {\n+            attempts = choose_shortest;\n+        }\n+    }\n+    for &ity in attempts.iter() {\n+        if bounds_usable(cx, ity, bounds) {\n+            return ity;\n+        }\n+    }\n+    return attr::UnsignedInt(ast::ty_u64);\n+}\n+\n+pub fn ll_inttype(cx: &mut CrateContext, ity: IntType) -> Type {\n+    match ity {\n+        attr::SignedInt(t) => Type::int_from_ty(cx, t),\n+        attr::UnsignedInt(t) => Type::uint_from_ty(cx, t)\n+    }\n+}\n+\n+fn bounds_usable(cx: &mut CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n+    debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n+    match ity {\n+        attr::SignedInt(_) => {\n+            let lllo = C_integral(ll_inttype(cx, ity), bounds.slo as u64, true);\n+            let llhi = C_integral(ll_inttype(cx, ity), bounds.shi as u64, true);\n+            bounds.slo == const_to_int(lllo) as i64 && bounds.shi == const_to_int(llhi) as i64\n+        }\n+        attr::UnsignedInt(_) => {\n+            let lllo = C_integral(ll_inttype(cx, ity), bounds.ulo, false);\n+            let llhi = C_integral(ll_inttype(cx, ity), bounds.uhi, false);\n+            bounds.ulo == const_to_uint(lllo) as u64 && bounds.uhi == const_to_uint(llhi) as u64\n+        }\n+    }\n+}\n+\n+pub fn ty_of_inttype(ity: IntType) -> ty::t {\n+    match ity {\n+        attr::SignedInt(t) => ty::mk_mach_int(t),\n+        attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n+    }\n+}\n+\n+\n /**\n  * Returns the fields of a struct for the given representation.\n  * All nominal types are LLVM structs, in order to be able to use\n@@ -239,33 +379,41 @@ pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n }\n fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n     match *r {\n-        CEnum(*) => ~[Type::enum_discrim(cx)],\n+        CEnum(ity, _, _) => ~[ll_inttype(cx, ity)],\n         Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n         NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n-        General(ref sts) => {\n-            // To get \"the\" type of a general enum, we pick the case\n-            // with the largest alignment (so it will always align\n-            // correctly in containing structures) and pad it out.\n-            assert!(sts.len() >= 1);\n-            let mut most_aligned = None;\n-            let mut largest_align = 0;\n-            let mut largest_size = 0;\n-            for st in sts.iter() {\n-                if largest_size < st.size {\n-                    largest_size = st.size;\n-                }\n-                if largest_align < st.align {\n-                    // Clang breaks ties by size; it is unclear if\n-                    // that accomplishes anything important.\n-                    largest_align = st.align;\n-                    most_aligned = Some(st);\n-                }\n-            }\n-            let most_aligned = most_aligned.unwrap();\n-            let padding = largest_size - most_aligned.size;\n-\n-            struct_llfields(cx, most_aligned, sizing)\n-                + &[Type::array(&Type::i8(), padding)]\n+        General(ity, ref sts) => {\n+            // We need a representation that has:\n+            // * The alignment of the most-aligned field\n+            // * The size of the largest variant (rounded up to that alignment)\n+            // * No alignment padding anywhere any variant has actual data\n+            //   (currently matters only for enums small enough to be immediate)\n+            // * The discriminant in an obvious place.\n+            //\n+            // So we start with the discriminant, pad it up to the alignment with\n+            // more of its own type, then use alignment-sized ints to get the rest\n+            // of the size.\n+            //\n+            // Note: if/when we start exposing SIMD vector types (or f80, on some\n+            // platforms that have it), this will need some adjustment.\n+            let size = sts.iter().map(|st| st.size).max().unwrap();\n+            let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n+            let align = most_aligned.align;\n+            let discr_ty = ll_inttype(cx, ity);\n+            let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n+            let pad_ty = match align {\n+                1 => Type::i8(),\n+                2 => Type::i16(),\n+                4 => Type::i32(),\n+                8 if machine::llalign_of_min(cx, Type::i64()) == 8 => Type::i64(),\n+                _ => fail!(\"Unsupported enum alignment: {:?}\", align)\n+            };\n+            assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n+            let align_units = (size + align - 1) / align;\n+            assert_eq!(align % discr_size, 0);\n+            ~[discr_ty,\n+              Type::array(&discr_ty, align / discr_size - 1),\n+              Type::array(&pad_ty, align_units - 1)]\n         }\n     }\n }\n@@ -288,7 +436,7 @@ pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n         CEnum(*) | General(*) => {\n-            (_match::switch, Some(trans_get_discr(bcx, r, scrutinee)))\n+            (_match::switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n@@ -302,17 +450,32 @@ pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n+    let signed;\n+    let val;\n     match *r {\n-        CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n-        Univariant(*) => C_disr(bcx.ccx(), 0),\n-        General(ref cases) => load_discr(bcx, scrutinee, 0, (cases.len() - 1) as Disr),\n+        CEnum(ity, min, max) => {\n+            val = load_discr(bcx, ity, scrutinee, min, max);\n+            signed = ity.is_signed();\n+        }\n+        General(ity, ref cases) => {\n+            val = load_discr(bcx, ity, scrutinee, 0, (cases.len() - 1) as Disr);\n+            signed = ity.is_signed();\n+        }\n+        Univariant(*) => {\n+            val = C_u8(0);\n+            signed = false;\n+        }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n-            ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n-                 Type::enum_discrim(bcx.ccx()))\n+            val = nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n+            signed = false;\n         }\n     }\n+    match cast_to {\n+        None => val,\n+        Some(llty) => if signed { SExt(bcx, val, llty) } else { ZExt(bcx, val, llty) }\n+    }\n }\n \n fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n@@ -324,10 +487,15 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: @mut Block, ity: IntType, scrutinee: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let ptr = GEPi(bcx, scrutinee, [0, 0]);\n-    if max + 1 == min {\n+    let llty = ll_inttype(bcx.ccx(), ity);\n+    assert_eq!(val_ty(ptr), llty.ptr_to());\n+    let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n+    assert!(bits <= 64);\n+    let mask = (-1u64 >> (64 - bits)) as Disr;\n+    if (max + 1) & mask == min & mask {\n         // i.e., if the range is everything.  The lo==hi case would be\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n@@ -350,15 +518,17 @@ fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: Disr, max: Disr)\n  */\n pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result {\n     match *r {\n-        CEnum(*) => {\n-            _match::single_result(rslt(bcx, C_disr(bcx.ccx(), discr)))\n+        CEnum(ity, _, _) => {\n+            _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n+                                                       discr as u64, true)))\n+        }\n+        General(ity, _) => {\n+            _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n+                                                       discr as u64, true)))\n         }\n         Univariant(*) => {\n             bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n         }\n-        General(*) => {\n-            _match::single_result(rslt(bcx, C_disr(bcx.ccx(), discr)))\n-        }\n         NullablePointer{ _ } => {\n             assert!(discr == 0 || discr == 1);\n             _match::single_result(rslt(bcx, C_i1(discr != 0)))\n@@ -373,9 +543,14 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result\n  */\n pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n-        CEnum(min, max) => {\n-            assert!(min <= discr && discr <= max);\n-            Store(bcx, C_disr(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+        CEnum(ity, min, max) => {\n+            assert_discr_in_range(ity, min, max, discr);\n+            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n+                  GEPi(bcx, val, [0, 0]))\n+        }\n+        General(ity, _) => {\n+            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n+                  GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n@@ -385,9 +560,6 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n         Univariant(*) => {\n             assert_eq!(discr, 0);\n         }\n-        General(*) => {\n-            Store(bcx, C_disr(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n-        }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n@@ -398,6 +570,13 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n     }\n }\n \n+fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n+    match ity {\n+        attr::UnsignedInt(_) => assert!(min <= discr && discr <= max),\n+        attr::SignedInt(_) => assert!(min as i64 <= discr as i64 && discr as i64 <= max as i64)\n+    }\n+}\n+\n /**\n  * The number of fields in a given case; for use when obtaining this\n  * information from the type or definition is less convenient.\n@@ -409,7 +588,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(ref cases) => cases[discr].fields.len() - 1,\n+        General(_, ref cases) => cases[discr].fields.len() - 1,\n         NullablePointer{ nonnull: ref nonnull, nndiscr, nullfields: ref nullfields, _ } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n@@ -430,7 +609,7 @@ pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n             assert_eq!(discr, 0);\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n-        General(ref cases) => {\n+        General(_, ref cases) => {\n             struct_field_ptr(bcx, &cases[discr], val, ix + 1, true)\n         }\n         NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields, nndiscr, _ } => {\n@@ -498,24 +677,23 @@ pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef\n pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n-        CEnum(min, max) => {\n+        CEnum(ity, min, max) => {\n             assert_eq!(vals.len(), 0);\n-            assert!(min <= discr && discr <= max);\n-            C_disr(ccx, discr)\n+            assert_discr_in_range(ity, min, max, discr);\n+            C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n-        Univariant(ref st, _dro) => {\n-            assert_eq!(discr, 0);\n-            let contents = build_const_struct(ccx, st, vals);\n-            C_struct(contents, st.packed)\n-        }\n-        General(ref cases) => {\n+        General(ity, ref cases) => {\n             let case = &cases[discr];\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n-            let discr_ty = C_disr(ccx, discr);\n-            let contents = build_const_struct(ccx, case,\n-                                              ~[discr_ty] + vals);\n+            let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n+            let contents = build_const_struct(ccx, case, ~[lldiscr] + vals);\n             C_struct(contents + &[padding(max_sz - case.size)], false)\n         }\n+        Univariant(ref st, _dro) => {\n+            assert!(discr == 0);\n+            let contents = build_const_struct(ccx, st, vals);\n+            C_struct(contents, st.packed)\n+        }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr == nndiscr {\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n@@ -585,9 +763,19 @@ fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n     -> Disr {\n     match *r {\n-        CEnum(*) => const_to_uint(val) as Disr,\n+        CEnum(ity, _, _) => {\n+            match ity {\n+                attr::SignedInt(*) => const_to_int(val) as Disr,\n+                attr::UnsignedInt(*) => const_to_uint(val) as Disr\n+            }\n+        }\n+        General(ity, _) => {\n+            match ity {\n+                attr::SignedInt(*) => const_to_int(const_get_elt(ccx, val, [0])) as Disr,\n+                attr::UnsignedInt(*) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr\n+            }\n+        }\n         Univariant(*) => 0,\n-        General(*) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr,\n         NullablePointer{ nndiscr, ptrfield, _ } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n@@ -646,7 +834,3 @@ pub fn is_newtypeish(r: &Repr) -> bool {\n         _ => false\n     }\n }\n-\n-fn C_disr(cx: &CrateContext, i: Disr) -> ValueRef {\n-    return C_integral(cx.int_type, i, false);\n-}"}, {"sha": "c002584a7fff93e1bd51e7fd8d9530461eef9420", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -868,6 +868,10 @@ pub fn C_i64(i: i64) -> ValueRef {\n     return C_integral(Type::i64(), i as u64, true);\n }\n \n+pub fn C_u64(i: u64) -> ValueRef {\n+    return C_integral(Type::i64(), i, false);\n+}\n+\n pub fn C_int(cx: &CrateContext, i: int) -> ValueRef {\n     return C_integral(cx.int_type, i as u64, true);\n }"}, {"sha": "0a5a9b3b5c18338f5c5d61697093f3ccc5a97247", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -1251,7 +1251,7 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n                                   -> ~[MemberDescription] {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n-            adt::General(ref struct_defs) => struct_defs,\n+            adt::General(_, ref struct_defs) => struct_defs,\n             _ => cx.sess.bug(\"unreachable\")\n         };\n \n@@ -1400,14 +1400,6 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n         return FinalMetadata(empty_type_metadata);\n     }\n \n-    // Prepare some data (llvm type, size, align, etc) about the discriminant. This data will be\n-    // needed in all of the following cases.\n-    let discriminant_llvm_type = Type::enum_discrim(cx);\n-    let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n-\n-    assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminant_base_type_metadata = type_metadata(cx, ty::mk_int(), codemap::dummy_sp());\n-\n     let variants = ty::enum_variants(cx.tcx, enum_def_id);\n \n     let enumerators_metadata: ~[DIDescriptor] = variants\n@@ -1427,26 +1419,32 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = do enum_name.with_c_str |enum_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateEnumerationType(\n-                DIB(cx),\n-                containing_scope,\n-                enum_name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(discriminant_size),\n-                bytes_to_bits(discriminant_align),\n-                create_DIArray(DIB(cx), enumerators_metadata),\n-                discriminant_base_type_metadata)\n+    let discriminant_type_metadata = |inttype| {\n+        let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n+        let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n+        let discriminant_base_type_metadata = type_metadata(cx, adt::ty_of_inttype(inttype),\n+                                                            codemap::dummy_sp());\n+        do enum_name.with_c_str |enum_name| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateEnumerationType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    enum_name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(discriminant_size),\n+                    bytes_to_bits(discriminant_align),\n+                    create_DIArray(DIB(cx), enumerators_metadata),\n+                    discriminant_base_type_metadata)\n+            }\n         }\n     };\n \n     let type_rep = adt::represent_type(cx, enum_type);\n \n     return match *type_rep {\n-        adt::CEnum(*) => {\n-            FinalMetadata(discriminant_type_metadata)\n+        adt::CEnum(inttype, _, _) => {\n+            FinalMetadata(discriminant_type_metadata(inttype))\n         }\n         adt::Univariant(ref struct_def, _) => {\n             assert!(variants.len() == 1);\n@@ -1467,7 +1465,8 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                 member_description_factory: member_description_factory\n             }\n         }\n-        adt::General(_) => {\n+        adt::General(inttype, _) => {\n+            let discriminant_type_metadata = discriminant_type_metadata(inttype);\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n "}, {"sha": "f291f088dec6c04a3fdbd6c7b18596776592ca64", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -1727,9 +1727,14 @@ fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n             (cast_enum, cast_float) => {\n                 let bcx = bcx;\n                 let repr = adt::represent_type(ccx, t_in);\n-                let slot = Alloca(bcx, ll_t_in, \"\");\n-                Store(bcx, llexpr, slot);\n-                let lldiscrim_a = adt::trans_get_discr(bcx, repr, slot);\n+                let llexpr_ptr;\n+                if type_is_immediate(ccx, t_in) {\n+                    llexpr_ptr = Alloca(bcx, ll_t_in, \"\");\n+                    Store(bcx, llexpr, llexpr_ptr);\n+                } else {\n+                    llexpr_ptr = llexpr;\n+                }\n+                let lldiscrim_a = adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64()));\n                 match k_out {\n                     cast_integral => int_cast(bcx, ll_t_out,\n                                               val_ty(lldiscrim_a),"}, {"sha": "7e875243fd0832b2aece2333eb740733ca0ce1e2", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -25,7 +25,7 @@ use middle::ty;\n use util::ppaux::ty_to_str;\n \n use std::libc::c_uint;\n-use std::option::None;\n+use std::option::{Some,None};\n use std::vec;\n use syntax::ast::DefId;\n use syntax::ast;\n@@ -292,11 +292,11 @@ impl Reflector {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfdecl = decl_internal_rust_fn(ccx, [opaqueptrty], ty::mk_int(), sym);\n+                let llfdecl = decl_internal_rust_fn(ccx, [opaqueptrty], ty::mk_u64(), sym);\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],\n                                       llfdecl,\n-                                      ty::mk_uint(),\n+                                      ty::mk_u64(),\n                                       None);\n                 let arg = unsafe {\n                     //\n@@ -308,7 +308,7 @@ impl Reflector {\n                 };\n                 let mut bcx = fcx.entry_bcx.unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, repr, arg);\n+                let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64()));\n                 Store(bcx, ret, fcx.llretptr.unwrap());\n                 match fcx.llreturn {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n@@ -324,7 +324,7 @@ impl Reflector {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n-                                         C_integral(self.bcx.ccx().int_type, v.disr_val, false),\n+                                         C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n                     do this.bracketed(\"enum_variant\", variant_args) |this| {"}, {"sha": "3f12f563bc47fe16af1765f513dd6271b110302f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -38,6 +38,7 @@ use syntax::ast::*;\n use syntax::ast_util::is_local;\n use syntax::ast_util;\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -715,6 +716,7 @@ pub struct ParamBounds {\n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n #[deriving(Clone, Eq, IterBytes, ToStr)]\n+#[repr(uint)]\n pub enum BuiltinBound {\n     BoundStatic,\n     BoundSend,\n@@ -4102,27 +4104,42 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n     }\n }\n \n-/// Determine whether an item is annotated with an attribute\n-pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n+/// Iterate over meta_items of a definition.\n+// (This should really be an iterator, but that would require csearch and\n+// decoder to use iterators instead of higher-order functions.)\n+pub fn each_attr(tcx: ctxt, did: DefId, f: &fn(@MetaItem) -> bool) -> bool {\n     if is_local(did) {\n         match tcx.items.find(&did.node) {\n-            Some(\n-                &ast_map::node_item(@ast::item {\n-                    attrs: ref attrs,\n-                    _\n-                }, _)) => attr::contains_name(*attrs, attr),\n+            Some(&ast_map::node_item(@ast::item {attrs: ref attrs, _}, _)) =>\n+                attrs.iter().advance(|attr| f(attr.node.value)),\n             _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n-                                   did))\n+                                      did))\n         }\n     } else {\n-        let mut ret = false;\n+        let mut cont = true;\n         do csearch::get_item_attrs(tcx.cstore, did) |meta_items| {\n-            ret = ret || attr::contains_name(meta_items, attr);\n+            if cont {\n+                cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n+            }\n         }\n-        ret\n+        return cont;\n     }\n }\n \n+/// Determine whether an item is annotated with an attribute\n+pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n+    let mut found = false;\n+    each_attr(tcx, did, |item| {\n+        if attr == item.name() {\n+            found = true;\n+            false\n+        } else {\n+            true\n+        }\n+    });\n+    return found;\n+}\n+\n /// Determine whether an item is annotated with `#[packed]`\n pub fn lookup_packed(tcx: ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"packed\")\n@@ -4133,6 +4150,16 @@ pub fn lookup_simd(tcx: ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"simd\")\n }\n \n+// Obtain the the representation annotation for a definition.\n+pub fn lookup_repr_hint(tcx: ctxt, did: DefId) -> attr::ReprAttr {\n+    let mut acc = attr::ReprAny;\n+    ty::each_attr(tcx, did, |meta| {\n+        acc = attr::find_repr_attr(tcx.sess.diagnostic(), meta, acc);\n+        true\n+    });\n+    return acc;\n+}\n+\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type(tcx: ctxt,"}, {"sha": "b3600158892adaef166ad246d116bfbaec8c288c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -121,6 +121,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n use syntax::ast_util;\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::opt_vec::OptVec;\n@@ -3169,9 +3170,38 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            sp: Span,\n                            vs: &[ast::variant],\n                            id: ast::NodeId) {\n+\n+    fn disr_in_range(ccx: @mut CrateCtxt,\n+                     ty: attr::IntType,\n+                     disr: ty::Disr) -> bool {\n+        fn uint_in_range(ccx: @mut CrateCtxt, ty: ast::uint_ty, disr: ty::Disr) -> bool {\n+            match ty {\n+                ast::ty_u8 => disr as u8 as Disr == disr,\n+                ast::ty_u16 => disr as u16 as Disr == disr,\n+                ast::ty_u32 => disr as u32 as Disr == disr,\n+                ast::ty_u64 => disr as u64 as Disr == disr,\n+                ast::ty_u => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n+            }\n+        }\n+        fn int_in_range(ccx: @mut CrateCtxt, ty: ast::int_ty, disr: ty::Disr) -> bool {\n+            match ty {\n+                ast::ty_i8 => disr as i8 as Disr == disr,\n+                ast::ty_i16 => disr as i16 as Disr == disr,\n+                ast::ty_i32 => disr as i32 as Disr == disr,\n+                ast::ty_i64 => disr as i64 as Disr == disr,\n+                ast::ty_i => int_in_range(ccx, ccx.tcx.sess.targ_cfg.int_type, disr)\n+            }\n+        }\n+        match ty {\n+            attr::UnsignedInt(ty) => uint_in_range(ccx, ty, disr),\n+            attr::SignedInt(ty) => int_in_range(ccx, ty, disr)\n+        }\n+    }\n+\n     fn do_check(ccx: @mut CrateCtxt,\n                 vs: &[ast::variant],\n-                id: ast::NodeId)\n+                id: ast::NodeId,\n+                hint: attr::ReprAttr)\n                 -> ~[@ty::VariantInfo] {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n@@ -3213,9 +3243,20 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 None => ()\n             };\n \n-            // Check for duplicate discriminator values\n+            // Check for duplicate discriminant values\n             if disr_vals.contains(&current_disr_val) {\n-                ccx.tcx.sess.span_err(v.span, \"discriminator value already exists\");\n+                ccx.tcx.sess.span_err(v.span, \"discriminant value already exists\");\n+            }\n+            // Check for unrepresentable discriminant values\n+            match hint {\n+                attr::ReprAny | attr::ReprExtern => (),\n+                attr::ReprInt(sp, ity) => {\n+                    if !disr_in_range(ccx, ity, current_disr_val) {\n+                        ccx.tcx.sess.span_err(v.span,\n+                                              \"discriminant value outside specified type\");\n+                        ccx.tcx.sess.span_note(sp, \"discriminant type specified here\");\n+                    }\n+                }\n             }\n             disr_vals.push(current_disr_val);\n \n@@ -3229,8 +3270,13 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     }\n \n     let rty = ty::node_id_to_type(ccx.tcx, id);\n+    let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { crate: ast::LOCAL_CRATE, node: id });\n+    if hint != attr::ReprAny && vs.len() <= 1 {\n+        ccx.tcx.sess.span_err(sp, format!(\"unsupported representation for {}variant enum\",\n+                                          if vs.len() == 1 { \"uni\" } else { \"zero-\" }))\n+    }\n \n-    let variants = do_check(ccx, vs, id);\n+    let variants = do_check(ccx, vs, id, hint);\n \n     // cache so that ty::enum_variants won't repeat this work\n     ccx.tcx.enum_var_cache.insert(local_def(id), @variants);"}, {"sha": "ba1a7a4f912b8c6ea38dec45ab1b0cddd81414bb", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -29,7 +29,8 @@ pub static bits : uint = $bits;\n pub static bytes : uint = ($bits / 8);\n \n pub static min_value: $T = (-1 as $T) << (bits - 1);\n-pub static max_value: $T = min_value - 1 as $T;\n+// FIXME(#9837): Compute min_value like this so the high bits that shouldn't exist are 0.\n+pub static max_value: $T = !min_value;\n \n impl CheckedDiv for $T {\n     #[inline]"}, {"sha": "19fa9abc0da55013e539ee3475b1bd39f60aef80", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -16,7 +16,7 @@ Runtime type reflection\n \n #[allow(missing_doc)];\n \n-use unstable::intrinsics::{Opaque, TyDesc, TyVisitor};\n+use unstable::intrinsics::{Disr, Opaque, TyDesc, TyVisitor};\n use libc::c_void;\n use mem;\n use unstable::raw;\n@@ -396,7 +396,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         sz: uint, align: uint)\n                      -> bool {\n         self.align(align);\n@@ -407,7 +407,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: int,\n+                                disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n         if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n@@ -426,7 +426,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: int,\n+                                disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n         if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n@@ -437,7 +437,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n             return false;"}, {"sha": "dd68c57e37e9763f896ca75a10a7827aad31c9c2", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -29,7 +29,7 @@ use reflect::{MovePtr, align};\n use str::StrSlice;\n use to_str::ToStr;\n use vec::OwnedVector;\n-use unstable::intrinsics::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n+use unstable::intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use unstable::raw;\n \n /// Representations\n@@ -92,7 +92,7 @@ num_repr!(f64, \"f64\")\n // New implementation using reflect::MovePtr\n \n enum VariantState {\n-    SearchingFor(int),\n+    SearchingFor(Disr),\n     Matched,\n     AlreadyFound\n }\n@@ -473,7 +473,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n \n     fn visit_enter_enum(&mut self,\n                         _n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         _sz: uint,\n                         _align: uint) -> bool {\n         let disr = unsafe {\n@@ -484,7 +484,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     }\n \n     fn visit_enter_enum_variant(&mut self, _variant: uint,\n-                                disr_val: int,\n+                                disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n         let mut write = false;\n@@ -531,7 +531,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     }\n \n     fn visit_leave_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: int,\n+                                _disr_val: Disr,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n         match self.var_stk[self.var_stk.len() - 1] {\n@@ -547,7 +547,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n \n     fn visit_leave_enum(&mut self,\n                         _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         _sz: uint,\n                         _align: uint)\n                         -> bool {"}, {"sha": "b782d713950d90c36e70ec31a37f08cdaa07d029", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -26,6 +26,7 @@ use result::{Err, Ok};\n use rt::io::io_error;\n use rt::rtio::{IoFactory, RtioSignal, with_local_io};\n \n+#[repr(int)]\n #[deriving(Eq, IterBytes)]\n pub enum Signum {\n     /// Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break."}, {"sha": "20563718a6c1fdd42cb0c647797c411990448c5c", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -75,6 +75,11 @@ pub struct TyDesc {\n #[cfg(not(test))]\n pub enum Opaque { }\n \n+#[cfg(stage0)]\n+pub type Disr = int;\n+#[cfg(not(stage0))]\n+pub type Disr = u64;\n+\n #[lang=\"ty_visitor\"]\n #[cfg(not(test))]\n pub trait TyVisitor {\n@@ -140,19 +145,19 @@ pub trait TyVisitor {\n                        sz: uint, align: uint) -> bool;\n \n     fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool;\n     fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: int,\n+                                disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool;\n     fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n     fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: int,\n+                                disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool;\n     fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool;\n \n     fn visit_enter_fn(&mut self, purity: uint, proto: uint,"}, {"sha": "7a5a326add40f8ac2010d48b188ede7a31d80e81", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 113, "deletions": 1, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -14,7 +14,7 @@ use extra;\n \n use ast;\n use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n-use codemap::{Spanned, spanned, dummy_spanned};\n+use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -363,3 +363,115 @@ pub fn require_unique_names(diagnostic: @mut span_handler,\n         }\n     }\n }\n+\n+\n+/**\n+ * Fold this over attributes to parse #[repr(...)] forms.\n+ *\n+ * Valid repr contents: any of the primitive integral type names (see\n+ * `int_type_of_word`, below) to specify the discriminant type; and `C`, to use\n+ * the same discriminant size that the corresponding C enum would.  These are\n+ * not allowed on univariant or zero-variant enums, which have no discriminant.\n+ *\n+ * If a discriminant type is so specified, then the discriminant will be\n+ * present (before fields, if any) with that type; reprensentation\n+ * optimizations which would remove it will not be done.\n+ */\n+pub fn find_repr_attr(diagnostic: @mut span_handler, attr: @ast::MetaItem, acc: ReprAttr)\n+    -> ReprAttr {\n+    let mut acc = acc;\n+    match attr.node {\n+        ast::MetaList(s, ref items) if \"repr\" == s => {\n+            for item in items.iter() {\n+                match item.node {\n+                    ast::MetaWord(word) => {\n+                        let hint = match word.as_slice() {\n+                            // Can't use \"extern\" because it's not a lexical identifier.\n+                            \"C\" => ReprExtern,\n+                            _ => match int_type_of_word(word) {\n+                                Some(ity) => ReprInt(item.span, ity),\n+                                None => {\n+                                    // Not a word we recognize\n+                                    diagnostic.span_err(item.span,\n+                                                        \"unrecognized representation hint\");\n+                                    ReprAny\n+                                }\n+                            }\n+                        };\n+                        if hint != ReprAny {\n+                            if acc == ReprAny {\n+                                acc = hint;\n+                            } else if acc != hint {\n+                                diagnostic.span_warn(item.span,\n+                                                     \"conflicting representation hint ignored\")\n+                            }\n+                        }\n+                    }\n+                    // Not a word:\n+                    _ => diagnostic.span_err(item.span, \"unrecognized representation hint\")\n+                }\n+            }\n+        }\n+        // Not a \"repr\" hint: ignore.\n+        _ => { }\n+    }\n+    return acc;\n+}\n+\n+fn int_type_of_word(s: &str) -> Option<IntType> {\n+    match s {\n+        \"i8\" => Some(SignedInt(ast::ty_i8)),\n+        \"u8\" => Some(UnsignedInt(ast::ty_u8)),\n+        \"i16\" => Some(SignedInt(ast::ty_i16)),\n+        \"u16\" => Some(UnsignedInt(ast::ty_u16)),\n+        \"i32\" => Some(SignedInt(ast::ty_i32)),\n+        \"u32\" => Some(UnsignedInt(ast::ty_u32)),\n+        \"i64\" => Some(SignedInt(ast::ty_i64)),\n+        \"u64\" => Some(UnsignedInt(ast::ty_u64)),\n+        \"int\" => Some(SignedInt(ast::ty_i)),\n+        \"uint\" => Some(UnsignedInt(ast::ty_u)),\n+        _ => None\n+    }\n+}\n+\n+#[deriving(Eq)]\n+pub enum ReprAttr {\n+    ReprAny,\n+    ReprInt(Span, IntType),\n+    ReprExtern\n+}\n+\n+impl ReprAttr {\n+    pub fn is_ffi_safe(&self) -> bool {\n+        match *self {\n+            ReprAny => false,\n+            ReprInt(_sp, ity) => ity.is_ffi_safe(),\n+            ReprExtern => true\n+        }\n+    }\n+}\n+\n+#[deriving(Eq)]\n+pub enum IntType {\n+    SignedInt(ast::int_ty),\n+    UnsignedInt(ast::uint_ty)\n+}\n+\n+impl IntType {\n+    #[inline]\n+    pub fn is_signed(self) -> bool {\n+        match self {\n+            SignedInt(*) => true,\n+            UnsignedInt(*) => false\n+        }\n+    }\n+    fn is_ffi_safe(self) -> bool {\n+        match self {\n+            SignedInt(ast::ty_i8) | UnsignedInt(ast::ty_u8) |\n+            SignedInt(ast::ty_i16) | UnsignedInt(ast::ty_u16) |\n+            SignedInt(ast::ty_i32) | UnsignedInt(ast::ty_u32) |\n+            SignedInt(ast::ty_i64) | UnsignedInt(ast::ty_u64) => true,\n+            _ => false\n+        }\n+    }\n+}"}, {"sha": "2de50ad1d1d0d4f887bcc037b2b120cc737fabba", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(u8)] //~ NOTE discriminant type specified here\n+enum Eu8 {\n+    Au8 = 23,\n+    Bu8 = 223,\n+    Cu8 = -23, //~ ERROR discriminant value outside specified type\n+}\n+\n+#[repr(i8)] //~ NOTE discriminant type specified here\n+enum Ei8 {\n+    Ai8 = 23,\n+    Bi8 = -23,\n+    Ci8 = 223, //~ ERROR discriminant value outside specified type\n+}\n+\n+#[repr(u16)] //~ NOTE discriminant type specified here\n+enum Eu16 {\n+    Au16 = 23,\n+    Bu16 = 55555,\n+    Cu16 = -22333, //~ ERROR discriminant value outside specified type\n+}\n+\n+#[repr(i16)] //~ NOTE discriminant type specified here\n+enum Ei16 {\n+    Ai16 = 23,\n+    Bi16 = -22333,\n+    Ci16 = 55555, //~ ERROR discriminant value outside specified type\n+}\n+\n+#[repr(u32)] //~ NOTE discriminant type specified here\n+enum Eu32 {\n+    Au32 = 23,\n+    Bu32 = 3_000_000_000,\n+    Cu32 = -2_000_000_000, //~ ERROR discriminant value outside specified type\n+}\n+\n+#[repr(i32)] //~ NOTE discriminant type specified here\n+enum Ei32 {\n+    Ai32 = 23,\n+    Bi32 = -2_000_000_000,\n+    Ci32 = 3_000_000_000, //~ ERROR discriminant value outside specified type\n+}\n+\n+// u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a\n+// little counterintuitive, but since the discriminant can store all the bits, and extracting it\n+// with a cast requires specifying the signedness, there is no loss of information in those cases.\n+// This also applies to int and uint on 64-bit targets.\n+\n+pub fn main() { }"}, {"sha": "857e3bb4b8d83658571792eb73cd8a6ede7f4aa8", "filename": "src/test/compile-fail/lint-ctypes-enum.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deny(ctypes)];\n+\n+enum Z { }\n+enum U { A }\n+enum B { C, D }\n+enum T { E, F, G }\n+\n+extern {\n+   fn zf(x: Z);\n+   fn uf(x: U);\n+   fn bf(x: B); //~ ERROR found enum type without foreign-function-safe\n+   fn tf(x: T); //~ ERROR found enum type without foreign-function-safe\n+}\n+\n+pub fn main() { }"}, {"sha": "d0608ec4c19273db2eab7f7c85ad94260e77b03d", "filename": "src/test/compile-fail/tag-variant-disr-dup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern:discriminator value already exists\n+//error-pattern:discriminant value already exists\n \n // black and white have the same discriminator value ...\n "}, {"sha": "a6aacdf8e665ab59cbf3654db4f2386c2724f394", "filename": "src/test/debug-info/method-on-enum.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -15,7 +15,7 @@\n // STACK BY REF\n // debugger:finish\n // debugger:print *self\n-// check:$1 = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// check:$1 = {{Variant2, [...]}, {Variant2, 117901063}}\n // debugger:print arg1\n // check:$2 = -1\n // debugger:print arg2\n@@ -25,7 +25,7 @@\n // STACK BY VAL\n // debugger:finish\n // d ebugger:print self -- ignored for now because of issue #8512\n-// c heck:$X = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// c heck:$X = {{Variant2, [...]}, {Variant2, 117901063}}\n // debugger:print arg1\n // check:$4 = -3\n // debugger:print arg2\n@@ -35,7 +35,7 @@\n // OWNED BY REF\n // debugger:finish\n // debugger:print *self\n-// check:$6 = {{Variant1, x = 1799, y = 1799}, {Variant1, 117901063}}\n+// check:$6 = {{Variant1, x = 1799, y = 1799}, {Variant1, [...]}}\n // debugger:print arg1\n // check:$7 = -5\n // debugger:print arg2\n@@ -45,7 +45,7 @@\n // OWNED BY VAL\n // debugger:finish\n // d ebugger:print self -- ignored for now because of issue #8512\n-// c heck:$X = {{Variant1, x = 1799, y = 1799}, {Variant1, 117901063}}\n+// c heck:$X = {{Variant1, x = 1799, y = 1799}, {Variant1, [...]}}\n // debugger:print arg1\n // check:$9 = -7\n // debugger:print arg2\n@@ -55,7 +55,7 @@\n // OWNED MOVED\n // debugger:finish\n // debugger:print *self\n-// check:$11 = {{Variant1, x = 1799, y = 1799}, {Variant1, 117901063}}\n+// check:$11 = {{Variant1, x = 1799, y = 1799}, {Variant1, [...]}}\n // debugger:print arg1\n // check:$12 = -9\n // debugger:print arg2\n@@ -65,7 +65,7 @@\n // MANAGED BY REF\n // debugger:finish\n // debugger:print *self\n-// check:$14 = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// check:$14 = {{Variant2, [...]}, {Variant2, 117901063}}\n // debugger:print arg1\n // check:$15 = -11\n // debugger:print arg2\n@@ -75,7 +75,7 @@\n // MANAGED BY VAL\n // debugger:finish\n // d ebugger:print self -- ignored for now because of issue #8512\n-// c heck:$X = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// c heck:$X = {{Variant2, [...]}, {Variant2, 117901063}}\n // debugger:print arg1\n // check:$17 = -13\n // debugger:print arg2\n@@ -85,7 +85,7 @@\n // MANAGED SELF\n // debugger:finish\n // debugger:print self->val\n-// check:$19 = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// check:$19 = {{Variant2, [...]}, {Variant2, 117901063}}\n // debugger:print arg1\n // check:$20 = -15\n // debugger:print arg2"}, {"sha": "ef34115739dd47c7a456ffd11ae86df73d64255c", "filename": "src/test/run-pass/enum-discrim-autosizing.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem::size_of;\n+\n+enum Ei8 {\n+    Ai8 = -1,\n+    Bi8 = 0\n+}\n+\n+enum Eu8 {\n+    Au8 = 0,\n+    Bu8 = 0x80\n+}\n+\n+enum Ei16 {\n+    Ai16 = -1,\n+    Bi16 = 0x80\n+}\n+\n+enum Eu16 {\n+    Au16 = 0,\n+    Bu16 = 0x8000\n+}\n+\n+enum Ei32 {\n+    Ai32 = -1,\n+    Bi32 = 0x8000\n+}\n+\n+enum Eu32 {\n+    Au32 = 0,\n+    Bu32 = 0x8000_0000\n+}\n+\n+enum Ei64 {\n+    Ai64 = -1,\n+    Bi64 = 0x8000_0000\n+}\n+\n+enum Eu64 {\n+    Au64 = 0,\n+    Bu64 = 0x8000_0000_0000_0000\n+}\n+\n+pub fn main() {\n+    assert_eq!(size_of::<Ei8>(), 1);\n+    assert_eq!(size_of::<Eu8>(), 1);\n+    assert_eq!(size_of::<Ei16>(), 2);\n+    assert_eq!(size_of::<Eu16>(), 2);\n+    assert_eq!(size_of::<Ei32>(), 4);\n+    assert_eq!(size_of::<Eu32>(), 4);\n+    assert_eq!(size_of::<Ei64>(), 8);\n+    assert_eq!(size_of::<Eu64>(), 8);\n+}"}, {"sha": "16eaac082abac25da57db21d0b938dda526ae8ff", "filename": "src/test/run-pass/enum-discrim-manual-sizing.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-manual-sizing.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem::size_of;\n+\n+#[repr(i8)]\n+enum Ei8 {\n+    Ai8 = 0,\n+    Bi8 = 1\n+}\n+\n+#[repr(u8)]\n+enum Eu8 {\n+    Au8 = 0,\n+    Bu8 = 1\n+}\n+\n+#[repr(i16)]\n+enum Ei16 {\n+    Ai16 = 0,\n+    Bi16 = 1\n+}\n+\n+#[repr(u16)]\n+enum Eu16 {\n+    Au16 = 0,\n+    Bu16 = 1\n+}\n+\n+#[repr(i32)]\n+enum Ei32 {\n+    Ai32 = 0,\n+    Bi32 = 1\n+}\n+\n+#[repr(u32)]\n+enum Eu32 {\n+    Au32 = 0,\n+    Bu32 = 1\n+}\n+\n+#[repr(i64)]\n+enum Ei64 {\n+    Ai64 = 0,\n+    Bi64 = 1\n+}\n+\n+#[repr(u64)]\n+enum Eu64 {\n+    Au64 = 0,\n+    Bu64 = 1\n+}\n+\n+#[repr(int)]\n+enum Eint {\n+    Aint = 0,\n+    Bint = 1\n+}\n+\n+#[repr(uint)]\n+enum Euint {\n+    Auint = 0,\n+    Buint = 1\n+}\n+\n+pub fn main() {\n+    assert_eq!(size_of::<Ei8>(), 1);\n+    assert_eq!(size_of::<Eu8>(), 1);\n+    assert_eq!(size_of::<Ei16>(), 2);\n+    assert_eq!(size_of::<Eu16>(), 2);\n+    assert_eq!(size_of::<Ei32>(), 4);\n+    assert_eq!(size_of::<Eu32>(), 4);\n+    assert_eq!(size_of::<Ei64>(), 8);\n+    assert_eq!(size_of::<Eu64>(), 8);\n+    assert_eq!(size_of::<Eint>(), size_of::<int>());\n+    assert_eq!(size_of::<Euint>(), size_of::<uint>());\n+}"}, {"sha": "6a0110436b3c86a9e99082cd72990908cfab8eda", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -8,18 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mem;\n+#[feature(macro_rules)];\n+\n+macro_rules! check {\n+    ($m:ident, $t:ty, $v:expr) => {{\n+        mod $m {\n+            use std::mem::size_of;\n+            enum E {\n+                V = $v,\n+                A = 0\n+            }\n+            static C: E = V;\n+            pub fn check() {\n+                assert_eq!(size_of::<E>(), size_of::<$t>());\n+                assert_eq!(V as $t, $v);\n+                assert_eq!(C as $t, $v);\n+                assert_eq!(format!(\"{:?}\", V), ~\"V\");\n+                assert_eq!(format!(\"{:?}\", C), ~\"V\");\n+            }\n+        }\n+        $m::check();\n+    }}\n+}\n \n pub fn main() {\n-    enum E { V = 0x1717171717171717 }\n-    static C: E = V;\n-    let expected: u64 = if mem::size_of::<uint>() < 8 {\n-        0x17171717\n-    } else {\n-        0x1717171717171717\n-    };\n-    assert_eq!(expected, V as u64);\n-    assert_eq!(expected, C as u64);\n-    assert_eq!(format!(\"{:?}\", V), ~\"V\");\n-    assert_eq!(format!(\"{:?}\", C), ~\"V\");\n+    check!(a, u8, 0x17);\n+    check!(b, u8, 0xe8);\n+    check!(c, u16, 0x1727);\n+    check!(d, u16, 0xe8d8);\n+    check!(e, u32, 0x17273747);\n+    check!(f, u32, 0xe8d8c8b8);\n+    check!(g, u64, 0x1727374757677787u64);\n+    check!(h, u64, 0xe8d8c8b8a8988878u64);\n+\n+    check!(z, i8, 0x17);\n+    check!(y, i8, -0x17);\n+    check!(x, i16, 0x1727);\n+    check!(w, i16, -0x1727);\n+    check!(v, i32, 0x17273747);\n+    check!(u, i32, -0x17273747);\n+    check!(t, i64, 0x1727374757677787);\n+    check!(s, i64, -0x1727374757677787);\n+\n+    enum Simple { A, B }\n+    assert_eq!(::std::mem::size_of::<Simple>(), 1);\n }"}, {"sha": "3bedbfa27b7cae332b7f52d400877dd3dc6342d5", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -27,6 +27,7 @@ pub mod pipes {\n     }\n \n     #[deriving(Eq)]\n+    #[repr(int)]\n     pub enum state {\n         empty,\n         full,"}, {"sha": "de8d9470f102716f0d7957d2f436db20b7b59fdc", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -15,7 +15,7 @@\n use std::libc::c_void;\n use std::ptr;\n use std::mem;\n-use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Opaque};\n+use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n use std::unstable::raw::Vec;\n \n #[doc = \"High-level interfaces to `std::unstable::intrinsics::visit_ty` reflection system.\"]\n@@ -380,7 +380,7 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         sz: uint, align: uint)\n                      -> bool {\n         self.align(align);\n@@ -389,7 +389,7 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: int,\n+                                disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n         if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n@@ -405,7 +405,7 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: int,\n+                                disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n         if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n@@ -416,7 +416,7 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         sz: uint, align: uint)\n                      -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) { return false; }\n@@ -578,24 +578,24 @@ impl TyVisitor for my_visitor {\n                        _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_enum(&mut self, _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         _sz: uint, _align: uint) -> bool {\n         // FIXME (#3732): this needs to rewind between enum variants, or something.\n         true\n     }\n     fn visit_enter_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: int,\n+                                _disr_val: Disr,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n     fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, inner: *TyDesc) -> bool {\n         self.visit_inner(inner)\n     }\n     fn visit_leave_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: int,\n+                                _disr_val: Disr,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n     fn visit_leave_enum(&mut self, _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,"}, {"sha": "e77cb432c3ad0c7567a601a55b38b2df67740832", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(managed_boxes)];\n \n-use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Opaque};\n+use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n \n struct MyVisitor {\n     types: @mut ~[~str],\n@@ -114,22 +114,22 @@ impl TyVisitor for MyVisitor {\n                        _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_enum(&mut self, _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         _sz: uint, _align: uint) -> bool { true }\n     fn visit_enter_enum_variant(&mut self,\n                                 _variant: uint,\n-                                _disr_val: int,\n+                                _disr_val: Disr,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n     fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_leave_enum_variant(&mut self,\n                                 _variant: uint,\n-                                _disr_val: int,\n+                                _disr_val: Disr,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n     fn visit_leave_enum(&mut self,\n                         _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,"}, {"sha": "a9fc13437abb49365c0569ba5b037f72842936b6", "filename": "src/test/run-pass/small-enum-range-edge.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Tests the range assertion wraparound case in trans::middle::adt::load_discr.\n+ */\n+\n+#[repr(u8)]\n+enum Eu { Lu = 0, Hu = 255 }\n+static CLu: Eu = Lu;\n+static CHu: Eu = Hu;\n+\n+#[repr(i8)]\n+enum Es { Ls = -128, Hs = 127 }\n+static CLs: Es = Ls;\n+static CHs: Es = Hs;\n+\n+pub fn main() {\n+    assert_eq!((Hu as u8) + 1, Lu as u8);\n+    assert_eq!((Hs as i8) + 1, Ls as i8);\n+    assert_eq!(CLu as u8, Lu as u8);\n+    assert_eq!(CHu as u8, Hu as u8);\n+    assert_eq!(CLs as i8, Ls as i8);\n+    assert_eq!(CHs as i8, Hs as i8);\n+}"}, {"sha": "c4f4b5e4e37f2014f510cba2f6e1d52635a83bd8", "filename": "src/test/run-pass/small-enums-with-fields.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1a69112584341522e2cc00bfc6dd1db6e0ec3a/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs?ref=5e1a69112584341522e2cc00bfc6dd1db6e0ec3a", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(macro_rules)];\n+\n+use std::mem::size_of;\n+\n+macro_rules! check {\n+    ($t:ty, $sz:expr, $($e:expr, $s:expr),*) => {{\n+        assert_eq!(size_of::<$t>(), $sz);\n+        $({\n+            static S: $t = $e;\n+            let v: $t = $e;\n+            assert_eq!(S, v);\n+            assert_eq!(format!(\"{:?}\", v), ~$s);\n+            assert_eq!(format!(\"{:?}\", S), ~$s);\n+        });*\n+    }}\n+}\n+\n+pub fn main() {\n+    check!(Option<u8>, 2,\n+           None, \"None\",\n+           Some(129u8), \"Some(129u8)\");\n+    check!(Option<i16>, 4,\n+           None, \"None\",\n+           Some(-20000i16), \"Some(-20000i16)\");\n+    check!(Either<u8, i8>, 2,\n+           Left(132u8), \"Left(132u8)\",\n+           Right(-32i8), \"Right(-32i8)\");\n+    check!(Either<u8, i16>, 4,\n+           Left(132u8), \"Left(132u8)\",\n+           Right(-20000i16), \"Right(-20000i16)\");\n+}"}]}