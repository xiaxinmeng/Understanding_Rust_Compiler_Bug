{"sha": "a871da36937f427624883860eafb580d6349f8da", "node_id": "C_kwDOAAsO6NoAKGE4NzFkYTM2OTM3ZjQyNzYyNDg4Mzg2MGVhZmI1ODBkNjM0OWY4ZGE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-12T17:32:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-12T17:32:58Z"}, "message": "Merge #10529\n\n10529: Generate `PartialOrd` implementations r=Veykril a=yoshuawuyts\n\n_co-authored with `@rylev_`\r\n\r\nThis closes #5946 (which should've been closed already, lol). This PR makes it so we generate `PartialOrd` code implementations where possible. This is the last of Rust's built-in traits that was missing codegen.\r\n\r\nAfter this has been merged we should look at moving the tests to a better spot, and maybe cleaning up the implementation somewhat (it's rather copy-pasty at the moment).\r\n\r\nEither way, this finishes up the functionality. Thanks heaps!\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>", "tree": {"sha": "3af854868c6ca4494d3ee2b298bea3913e0f71f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3af854868c6ca4494d3ee2b298bea3913e0f71f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a871da36937f427624883860eafb580d6349f8da", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhZcbKCRBK7hj4Ov3rIwAAA5oIACCIGmeod4XWojOwMejjNdJF\nJcdWFWUuYrOnyFvzM/GJI/TPvr/FlJqNbMwNbBYTKNudGTOoMOuL2Qy3GFY2dF5o\nv3NZ1ZXDAWFOVt/Zn3gLQd683rvOl8Tp4UrSqYcbiebudRMBK8U9aB62tS5/ylgT\ncs4GuRJ3QIyF9lVaKqbIdpqBpXaGbI/52DesdNXarwPTsRs8Je5IyjOZW4y7i3Sd\nOTJ2gNBYwFrs2Dri32hYjgNHUQd5Ki12l/CwRVslFLxu6S7gBRm2sWFa21qJwsvy\nlPMrEdPF3g8D7XoNNO3Tc3K+XPmUbJVmj72v+d3eq5BugXtgYTAvOjAhFuTUj/0=\n=GJz/\n-----END PGP SIGNATURE-----\n", "payload": "tree 3af854868c6ca4494d3ee2b298bea3913e0f71f0\nparent d56c8796d6521cfacb10d31c09fcc246cf511dbd\nparent 601ed3a10dacc2ba2ee0ca436c23529ae7fde292\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634059978 +0000\ncommitter GitHub <noreply@github.com> 1634059978 +0000\n\nMerge #10529\n\n10529: Generate `PartialOrd` implementations r=Veykril a=yoshuawuyts\n\n_co-authored with `@rylev_`\r\n\r\nThis closes #5946 (which should've been closed already, lol). This PR makes it so we generate `PartialOrd` code implementations where possible. This is the last of Rust's built-in traits that was missing codegen.\r\n\r\nAfter this has been merged we should look at moving the tests to a better spot, and maybe cleaning up the implementation somewhat (it's rather copy-pasty at the moment).\r\n\r\nEither way, this finishes up the functionality. Thanks heaps!\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a871da36937f427624883860eafb580d6349f8da", "html_url": "https://github.com/rust-lang/rust/commit/a871da36937f427624883860eafb580d6349f8da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a871da36937f427624883860eafb580d6349f8da/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d56c8796d6521cfacb10d31c09fcc246cf511dbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d56c8796d6521cfacb10d31c09fcc246cf511dbd", "html_url": "https://github.com/rust-lang/rust/commit/d56c8796d6521cfacb10d31c09fcc246cf511dbd"}, {"sha": "601ed3a10dacc2ba2ee0ca436c23529ae7fde292", "url": "https://api.github.com/repos/rust-lang/rust/commits/601ed3a10dacc2ba2ee0ca436c23529ae7fde292", "html_url": "https://github.com/rust-lang/rust/commit/601ed3a10dacc2ba2ee0ca436c23529ae7fde292"}], "stats": {"total": 383, "additions": 383, "deletions": 0}, "files": [{"sha": "b04bd6ba09845165cbb439acc3006849b3da3fe0", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/a871da36937f427624883860eafb580d6349f8da/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a871da36937f427624883860eafb580d6349f8da/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=a871da36937f427624883860eafb580d6349f8da", "patch": "@@ -675,6 +675,194 @@ impl Clone for Foo {\n         )\n     }\n \n+    #[test]\n+    fn add_custom_impl_partial_ord_record_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: ord\n+#[derive(Partial$0Ord)]\n+struct Foo {\n+    bin: usize,\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    bin: usize,\n+}\n+\n+impl PartialOrd for Foo {\n+    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.bin.partial_cmp(other.bin)\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_ord_record_struct_multi_field() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: ord\n+#[derive(Partial$0Ord)]\n+struct Foo {\n+    bin: usize,\n+    bar: usize,\n+    baz: usize,\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    bin: usize,\n+    bar: usize,\n+    baz: usize,\n+}\n+\n+impl PartialOrd for Foo {\n+    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        (self.bin, self.bar, self.baz).partial_cmp((other.bin, other.bar, other.baz))\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_ord_tuple_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: ord\n+#[derive(Partial$0Ord)]\n+struct Foo(usize, usize, usize);\n+\"#,\n+            r#\"\n+struct Foo(usize, usize, usize);\n+\n+impl PartialOrd for Foo {\n+    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        (self.0, self.1, self.2).partial_cmp((other.0, other.1, other.2))\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_ord_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: ord\n+#[derive(Partial$0Ord)]\n+enum Foo {\n+    Bin,\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bin,\n+    Bar,\n+    Baz,\n+}\n+\n+impl PartialOrd for Foo {\n+    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        core::mem::discriminant(self).partial_cmp(core::mem::discriminant(other))\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_ord_record_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: ord\n+#[derive(Partial$0Ord)]\n+enum Foo {\n+    Bar {\n+        bin: String,\n+    },\n+    Baz {\n+        qux: String,\n+        fez: String,\n+    },\n+    Qux {},\n+    Bin,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar {\n+        bin: String,\n+    },\n+    Baz {\n+        qux: String,\n+        fez: String,\n+    },\n+    Qux {},\n+    Bin,\n+}\n+\n+impl PartialOrd for Foo {\n+    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        match (self, other) {\n+            (Self::Bar { bin: l_bin }, Self::Bar { bin: r_bin }) => l_bin.partial_cmp(r_bin),\n+            (Self::Baz { qux: l_qux, fez: l_fez }, Self::Baz { qux: r_qux, fez: r_fez }) => {\n+                (l_qux, l_fez).partial_cmp((r_qux, r_fez))\n+            }\n+            _ => core::mem::discriminant(self).partial_cmp(core::mem::discriminant(other)),\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_ord_tuple_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: ord\n+#[derive(Partial$0Ord)]\n+enum Foo {\n+    Bar(String),\n+    Baz(String, String),\n+    Qux(),\n+    Bin,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar(String),\n+    Baz(String, String),\n+    Qux(),\n+    Bin,\n+}\n+\n+impl PartialOrd for Foo {\n+    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        match (self, other) {\n+            (Self::Bar(l0), Self::Bar(r0)) => l0.partial_cmp(r0),\n+            (Self::Baz(l0, l1), Self::Baz(r0, r1)) => {\n+                (l0, l1).partial_cmp((r0, r1))\n+            }\n+            _ => core::mem::discriminant(self).partial_cmp(core::mem::discriminant(other)),\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn add_custom_impl_partial_eq_record_struct() {\n         check_assist("}, {"sha": "c883e6fb11ba947b04f9e5dcb332a28f173520be", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/a871da36937f427624883860eafb580d6349f8da/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a871da36937f427624883860eafb580d6349f8da/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=a871da36937f427624883860eafb580d6349f8da", "patch": "@@ -21,6 +21,7 @@ pub(crate) fn gen_trait_fn_body(\n         \"Default\" => gen_default_impl(adt, func),\n         \"Hash\" => gen_hash_impl(adt, func),\n         \"PartialEq\" => gen_partial_eq(adt, func),\n+        \"PartialOrd\" => gen_partial_ord(adt, func),\n         _ => None,\n     }\n }\n@@ -572,6 +573,200 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     Some(())\n }\n \n+fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    fn gen_partial_cmp_call(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n+        let method = make::name_ref(\"partial_cmp\");\n+        make::expr_method_call(lhs, method, make::arg_list(Some(rhs)))\n+    }\n+    fn gen_partial_cmp_call2(mut lhs: Vec<ast::Expr>, mut rhs: Vec<ast::Expr>) -> ast::Expr {\n+        let (lhs, rhs) = match (lhs.len(), rhs.len()) {\n+            (1, 1) => (lhs.pop().unwrap(), rhs.pop().unwrap()),\n+            _ => (make::expr_tuple(lhs.into_iter()), make::expr_tuple(rhs.into_iter())),\n+        };\n+        let method = make::name_ref(\"partial_cmp\");\n+        make::expr_method_call(lhs, method, make::arg_list(Some(rhs)))\n+    }\n+\n+    fn gen_record_pat_field(field_name: &str, pat_name: &str) -> ast::RecordPatField {\n+        let pat = make::ext::simple_ident_pat(make::name(&pat_name));\n+        let name_ref = make::name_ref(field_name);\n+        make::record_pat_field(name_ref, pat.into())\n+    }\n+\n+    fn gen_record_pat(record_name: ast::Path, fields: Vec<ast::RecordPatField>) -> ast::RecordPat {\n+        let list = make::record_pat_field_list(fields);\n+        make::record_pat_with_fields(record_name, list)\n+    }\n+\n+    fn gen_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n+        make::ext::path_from_idents([\"Self\", &variant.name()?.to_string()])\n+    }\n+\n+    fn gen_tuple_field(field_name: &String) -> ast::Pat {\n+        ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n+    }\n+\n+    // FIXME: return `None` if the trait carries a generic type; we can only\n+    // generate this code `Self` for the time being.\n+\n+    let body = match adt {\n+        // `Hash` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => return None,\n+\n+        ast::Adt::Enum(enum_) => {\n+            // => std::mem::discriminant(self) == std::mem::discriminant(other)\n+            let lhs_name = make::expr_path(make::ext::ident_path(\"self\"));\n+            let lhs = make::expr_call(make_discriminant()?, make::arg_list(Some(lhs_name.clone())));\n+            let rhs_name = make::expr_path(make::ext::ident_path(\"other\"));\n+            let rhs = make::expr_call(make_discriminant()?, make::arg_list(Some(rhs_name.clone())));\n+            let ord_check = gen_partial_cmp_call(lhs, rhs);\n+\n+            let mut case_count = 0;\n+            let mut arms = vec![];\n+            for variant in enum_.variant_list()?.variants() {\n+                case_count += 1;\n+                match variant.field_list() {\n+                    // => (Self::Bar { bin: l_bin }, Self::Bar { bin: r_bin }) => l_bin == r_bin,\n+                    Some(ast::FieldList::RecordFieldList(list)) => {\n+                        let mut l_pat_fields = vec![];\n+                        let mut r_pat_fields = vec![];\n+                        let mut l_fields = vec![];\n+                        let mut r_fields = vec![];\n+\n+                        for field in list.fields() {\n+                            let field_name = field.name()?.to_string();\n+\n+                            let l_name = &format!(\"l_{}\", field_name);\n+                            l_pat_fields.push(gen_record_pat_field(&field_name, &l_name));\n+\n+                            let r_name = &format!(\"r_{}\", field_name);\n+                            r_pat_fields.push(gen_record_pat_field(&field_name, &r_name));\n+\n+                            let lhs = make::expr_path(make::ext::ident_path(l_name));\n+                            let rhs = make::expr_path(make::ext::ident_path(r_name));\n+                            l_fields.push(lhs);\n+                            r_fields.push(rhs);\n+                        }\n+\n+                        let left_pat = gen_record_pat(gen_variant_path(&variant)?, l_pat_fields);\n+                        let right_pat = gen_record_pat(gen_variant_path(&variant)?, r_pat_fields);\n+                        let tuple_pat = make::tuple_pat(vec![left_pat.into(), right_pat.into()]);\n+\n+                        let len = l_fields.len();\n+                        if len != 0 {\n+                            let mut expr = gen_partial_cmp_call2(l_fields, r_fields);\n+                            if len >= 2 {\n+                                expr = make::block_expr(None, Some(expr))\n+                                    .indent(ast::edit::IndentLevel(1))\n+                                    .into();\n+                            }\n+                            arms.push(make::match_arm(Some(tuple_pat.into()), None, expr));\n+                        }\n+                    }\n+\n+                    Some(ast::FieldList::TupleFieldList(list)) => {\n+                        let mut l_pat_fields = vec![];\n+                        let mut r_pat_fields = vec![];\n+                        let mut l_fields = vec![];\n+                        let mut r_fields = vec![];\n+\n+                        for (i, _) in list.fields().enumerate() {\n+                            let field_name = format!(\"{}\", i);\n+\n+                            let l_name = format!(\"l{}\", field_name);\n+                            l_pat_fields.push(gen_tuple_field(&l_name));\n+\n+                            let r_name = format!(\"r{}\", field_name);\n+                            r_pat_fields.push(gen_tuple_field(&r_name));\n+\n+                            let lhs = make::expr_path(make::ext::ident_path(&l_name));\n+                            let rhs = make::expr_path(make::ext::ident_path(&r_name));\n+                            l_fields.push(lhs);\n+                            r_fields.push(rhs);\n+                        }\n+\n+                        let left_pat =\n+                            make::tuple_struct_pat(gen_variant_path(&variant)?, l_pat_fields);\n+                        let right_pat =\n+                            make::tuple_struct_pat(gen_variant_path(&variant)?, r_pat_fields);\n+                        let tuple_pat = make::tuple_pat(vec![left_pat.into(), right_pat.into()]);\n+\n+                        let len = l_fields.len();\n+                        if len != 0 {\n+                            let mut expr = gen_partial_cmp_call2(l_fields, r_fields);\n+                            if len >= 2 {\n+                                expr = make::block_expr(None, Some(expr))\n+                                    .indent(ast::edit::IndentLevel(1))\n+                                    .into();\n+                            }\n+                            arms.push(make::match_arm(Some(tuple_pat.into()), None, expr));\n+                        }\n+                    }\n+                    None => continue,\n+                }\n+            }\n+\n+            let expr = match arms.len() {\n+                0 => ord_check,\n+                _ => {\n+                    if case_count > arms.len() {\n+                        let lhs = make::wildcard_pat().into();\n+                        arms.push(make::match_arm(Some(lhs), None, ord_check));\n+                    }\n+\n+                    let match_target = make::expr_tuple(vec![lhs_name, rhs_name]);\n+                    let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n+                    make::expr_match(match_target, list)\n+                }\n+            };\n+\n+            make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n+        }\n+        ast::Adt::Struct(strukt) => match strukt.field_list() {\n+            Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                let mut l_fields = vec![];\n+                let mut r_fields = vec![];\n+                for field in field_list.fields() {\n+                    let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n+                    let lhs = make::expr_field(lhs, &field.name()?.to_string());\n+                    let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n+                    let rhs = make::expr_field(rhs, &field.name()?.to_string());\n+                    l_fields.push(lhs);\n+                    r_fields.push(rhs);\n+                }\n+\n+                let expr = gen_partial_cmp_call2(l_fields, r_fields);\n+                make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n+            }\n+\n+            Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                let mut l_fields = vec![];\n+                let mut r_fields = vec![];\n+                for (i, _) in field_list.fields().enumerate() {\n+                    let idx = format!(\"{}\", i);\n+                    let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n+                    let lhs = make::expr_field(lhs, &idx);\n+                    let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n+                    let rhs = make::expr_field(rhs, &idx);\n+                    l_fields.push(lhs);\n+                    r_fields.push(rhs);\n+                }\n+                let expr = gen_partial_cmp_call2(l_fields, r_fields);\n+                make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n+            }\n+\n+            // No fields in the body means there's nothing to hash.\n+            None => {\n+                let expr = make::expr_literal(\"true\").into();\n+                make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n+            }\n+        },\n+    };\n+\n+    ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+    Some(())\n+}\n+\n fn make_discriminant() -> Option<ast::Expr> {\n     Some(make::expr_path(make::ext::path_from_idents([\"core\", \"mem\", \"discriminant\"])?))\n }"}]}