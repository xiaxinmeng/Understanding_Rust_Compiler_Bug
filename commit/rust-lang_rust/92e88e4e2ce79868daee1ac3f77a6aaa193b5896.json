{"sha": "92e88e4e2ce79868daee1ac3f77a6aaa193b5896", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZTg4ZTRlMmNlNzk4NjhkYWVlMWFjM2Y3N2E2YWFhMTkzYjU4OTY=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-28T04:42:04Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-28T05:19:30Z"}, "message": "std: another stab at a race-free global loop implementation\n\nseems to hold up pretty well.\n\nuv::hl API is affected.. had to do work on tests and std::timer code that\nleverages the global loop/high_level_loop API.\n\nsee test_stress_gl_uv_global_loop_high_level_global_timer for a stress\nexample.. it takes a while to run, but it exits cleanly (something I could\nnever accomplish with earlier iterations of the global loop)", "tree": {"sha": "4f4f88e251751cc32dd6bd60992714a24493acc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f4f88e251751cc32dd6bd60992714a24493acc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92e88e4e2ce79868daee1ac3f77a6aaa193b5896", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92e88e4e2ce79868daee1ac3f77a6aaa193b5896", "html_url": "https://github.com/rust-lang/rust/commit/92e88e4e2ce79868daee1ac3f77a6aaa193b5896", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92e88e4e2ce79868daee1ac3f77a6aaa193b5896/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "577b888e4b87437a37903abb5b70b113a9df059d", "url": "https://api.github.com/repos/rust-lang/rust/commits/577b888e4b87437a37903abb5b70b113a9df059d", "html_url": "https://github.com/rust-lang/rust/commit/577b888e4b87437a37903abb5b70b113a9df059d"}], "stats": {"total": 703, "additions": 188, "deletions": 515}, "files": [{"sha": "1c646f61d6a4c48c1f7481446e726a488f22efab", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92e88e4e2ce79868daee1ac3f77a6aaa193b5896/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e88e4e2ce79868daee1ac3f77a6aaa193b5896/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=92e88e4e2ce79868daee1ac3f77a6aaa193b5896", "patch": "@@ -30,7 +30,6 @@ fn delayed_send<T: send>(msecs: uint, ch: comm::chan<T>, val: T) {\n             let timer_ptr = ptr::addr_of(timer);\n             let hl_loop = uv::global_loop::get();\n             uv::hl::interact(hl_loop) {|loop_ptr|\n-                uv::hl::ref(hl_loop, timer_ptr);\n                 let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n                 if (init_result == 0i32) {\n                     let start_result = uv::ll::timer_start(\n@@ -54,9 +53,6 @@ fn delayed_send<T: send>(msecs: uint, ch: comm::chan<T>, val: T) {\n             comm::recv(timer_done_po);\n             // notify the caller immediately\n             comm::send(ch, copy(val));\n-            // then clean up our handle\n-            uv::hl::unref_and_close(hl_loop, timer_ptr,\n-                                    delayed_send_close_cb);\n             // uv_close for this timer has been processed\n             comm::recv(timer_done_po);\n         }\n@@ -122,6 +118,7 @@ crust fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n     let stop_result = uv::ll::timer_stop(handle);\n     if (stop_result == 0i32) {\n         comm::send(timer_done_ch, ());\n+        uv::ll::close(handle, delayed_send_close_cb);\n     }\n     else {\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n@@ -140,14 +137,12 @@ crust fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n #[cfg(test)]\n mod test {\n     #[test]\n-    #[ignore]\n-    fn test_timer_simple_sleep_test() {\n+    fn test_gl_timer_simple_sleep_test() {\n         sleep(1u);\n     }\n \n     #[test]\n-    #[ignore]\n-    fn test_timer_recv_timeout_before_time_passes() {\n+    fn test_gl_timer_recv_timeout_before_time_passes() {\n         let expected = rand::rng().gen_str(16u);\n         let test_po = comm::port::<str>();\n         let test_ch = comm::chan(test_po);\n@@ -165,8 +160,7 @@ mod test {\n     }\n \n     #[test]\n-    #[ignore]\n-    fn test_timer_recv_timeout_after_time_passes() {\n+    fn test_gl_timer_recv_timeout_after_time_passes() {\n         let expected = rand::rng().gen_str(16u);\n         let fail_msg = rand::rng().gen_str(16u);\n         let test_po = comm::port::<str>();"}, {"sha": "46d73867285a84f12b83d252276debea295c7b45", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 116, "deletions": 255, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/92e88e4e2ce79868daee1ac3f77a6aaa193b5896/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e88e4e2ce79868daee1ac3f77a6aaa193b5896/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=92e88e4e2ce79868daee1ac3f77a6aaa193b5896", "patch": "@@ -6,7 +6,7 @@ import ll = uv_ll;\n import hl = uv_hl;\n import get_gl = get;\n \n-export get, get_single_task_gl, get_monitor_task_gl;\n+export get, get_monitor_task_gl;\n \n native mod rustrt {\n     fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n@@ -16,8 +16,7 @@ native mod rustrt {\n Race-free helper to get access to a global task where a libuv\n loop is running.\n \n-Use `uv::hl::interact`, `uv::hl::ref`, `uv::hl::unref` and\n-uv `uv::hl::unref_and_close` to do operations against the global\n+Use `uv::hl::interact` to do operations against the global\n loop that this function returns.\n \n # Return\n@@ -32,61 +31,10 @@ fn get() -> hl::high_level_loop {\n // WARNING: USE ONLY ONE get_*_task_gl fn in the scope of a process lifetime.\n #[doc(hidden)]\n fn get_monitor_task_gl() -> hl::high_level_loop {\n-    let monitor_loop_chan =\n-        rustrt::rust_uv_get_kernel_monitor_global_chan_ptr();\n-    ret spawn_global_weak_task(\n-        monitor_loop_chan,\n-        {|weak_exit_po, msg_po, loop_ptr, first_msg|\n-            log(debug, \"monitor gl: entering inner loop\");\n-            unsafe {\n-                monitor_task_loop_body(weak_exit_po, msg_po, loop_ptr,\n-                                       copy(first_msg))\n-            }\n-        },\n-        {|msg_ch|\n-            hl::monitor_task_loop({op_chan: msg_ch})\n-        });\n-}\n-\n-// WARNING: USE ONLY ONE get_*_task_gl fn in the scope of a process lifetime.\n-#[doc(hidden)]\n-fn get_single_task_gl() -> hl::high_level_loop {\n-    let global_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n-    ret spawn_global_weak_task(\n-        global_loop_chan_ptr,\n-        {|weak_exit_po, msg_po, loop_ptr, first_msg|\n-            log(debug, \"single-task gl: about to enter inner loop\");\n-            unsafe {\n-                single_task_loop_body(weak_exit_po, msg_po, loop_ptr,\n-                                      copy(first_msg))\n-            }\n-        },\n-        {|msg_ch|\n-            log(debug, \"after priv::chan_from_global_ptr\");\n-            unsafe {\n-                let handle = get_global_async_handle_native_representation()\n-                    as **ll::uv_async_t;\n-                hl::single_task_loop(\n-                    { async_handle: handle, op_chan: msg_ch })\n-            }\n-        }\n-    );\n-}\n-\n-// INTERNAL API\n-\n-fn spawn_global_weak_task(\n-        global_loop_chan_ptr: *libc::uintptr_t,\n-        weak_task_body_cb: fn~(\n-            comm::port<()>,\n-            comm::port<hl::high_level_msg>,\n-            *libc::c_void,\n-            hl::high_level_msg) -> bool,\n-        after_task_spawn_cb: fn~(comm::chan<hl::high_level_msg>)\n-          -> hl::high_level_loop) -> hl::high_level_loop {\n+    let monitor_loop_chan_ptr =\n+        rustrt::rust_uv_get_kernel_global_chan_ptr();\n     log(debug, #fmt(\"ENTERING global_loop::get() loop chan: %?\",\n-       global_loop_chan_ptr));\n-\n+       monitor_loop_chan_ptr));\n     let builder_fn = {||\n         let builder = task::builder();\n         let opts = {\n@@ -101,206 +49,95 @@ fn spawn_global_weak_task(\n     };\n     unsafe {\n         log(debug, \"before priv::chan_from_global_ptr\");\n-        let msg_ch = priv::chan_from_global_ptr::<hl::high_level_msg>(\n-            global_loop_chan_ptr,\n-            builder_fn) {|port|\n-\n-            // the actual body of our global loop lives here\n-            log(debug, \"initialized global port task!\");\n-            log(debug, \"GLOBAL initialized global port task!\");\n-            outer_global_loop_body(port, weak_task_body_cb);\n+        type hl_loop_req_ch = comm::chan<hl::high_level_loop>;\n+        let msg_ch = priv::chan_from_global_ptr::<hl_loop_req_ch>(\n+            monitor_loop_chan_ptr,\n+            builder_fn) {|msg_po|\n+            log(debug, \"global monitor task starting\");\n+            priv::weaken_task() {|weak_exit_po|\n+                log(debug, \"global monitor task is now weak\");\n+                let hl_loop_data = spawn_libuv_weak_task();\n+                let hl_loop = alt hl_loop_data {\n+                  (async, msg_ch) {\n+                    hl::simple_task_loop({async_handle:async, op_chan:msg_ch})\n+                  }\n+                };\n+                loop {\n+                    log(debug, \"in outer_loop...\");\n+                    let continue = either::either(\n+                        {|weak_exit|\n+                            // all normal tasks have ended, tell the\n+                            // libuv loop to tear_down, then exit\n+                            log(debug, #fmt(\"weak_exit_po recv'd msg: %?\",\n+                                           weak_exit));\n+                            let ( a, loop_msg_ch )= hl_loop_data;\n+                            comm::send(loop_msg_ch, hl::teardown_loop);\n+                            ll::async_send(a);\n+                            false\n+                        }, {|fetch_ch|\n+                            log(debug, #fmt(\"hl_loop req recv'd: %?\",\n+                                           fetch_ch));\n+                            comm::send(fetch_ch, copy(hl_loop));\n+                            true\n+                        }, comm::select2(weak_exit_po, msg_po));\n+                    if !continue { break; }\n+                }\n+                log(debug, \"global monitor task is leaving weakend state\");\n+            };\n+            log(debug, \"global monitor task exiting\");\n         };\n-        ret after_task_spawn_cb(msg_ch);\n+        // once we have a chan to the monitor loop, we ask it for\n+        // the libuv loop's async handle\n+        let fetch_po = comm::port::<hl::high_level_loop>();\n+        let fetch_ch = comm::chan(fetch_po);\n+        comm::send(msg_ch, fetch_ch);\n+        comm::recv(fetch_po)\n     }\n }\n \n-unsafe fn outer_global_loop_body(\n-    msg_po: comm::port<hl::high_level_msg>,\n-    weak_task_body_cb: fn~(\n-        comm::port<()>,\n-        comm::port<hl::high_level_msg>,\n-        *libc::c_void,\n-        hl::high_level_msg) -> bool) {\n-    // we're going to use a single libuv-generated loop ptr\n-    // for the duration of the process\n-    let loop_ptr = ll::loop_new();\n-\n-    // data structure for loop goes here..\n-\n-    // immediately weaken the task this is running in.\n-    priv::weaken_task() {|weak_exit_po|\n-        // when we first enter this loop, we're going\n-        // to wait on stand-by to receive a request to\n-        // fire-up the libuv loop\n-        let mut continue = true;\n-        while continue {\n-            log(debug, \"in outer_loop...\");\n-            continue = either::either(\n-                {|left_val|\n-                    // bail out..\n-                    // if we catch this msg at this point,\n-                    // we should just be able to exit because\n-                    // the loop isn't active\n-                    log(debug, #fmt(\"weak_exit_po recv'd msg: %?\",\n-                                   left_val));\n-                    false\n-                }, {|right_val|\n-                    weak_task_body_cb(weak_exit_po, msg_po, loop_ptr,\n-                                      right_val)\n-                }, comm::select2(weak_exit_po, msg_po));\n-            log(debug,#fmt(\"GLOBAL LOOP EXITED, WAITING TO RESTART? %?\",\n-                       continue));\n-        }\n-    };\n-\n-    ll::loop_delete(loop_ptr);\n-}\n-\n-unsafe fn monitor_task_loop_body(weak_exit_po_in: comm::port<()>,\n-                          msg_po_in: comm::port<hl::high_level_msg>,\n-                          loop_ptr: *libc::c_void,\n-                          -first_interaction: hl::high_level_msg) -> bool {\n-    // resend the msg to be handled in the select2 loop below..\n-    comm::send(comm::chan(msg_po_in), first_interaction);\n-\n-    // our async_handle\n-    let async_handle_po = comm::port::<*ll::uv_async_t>();\n-    let async_handle_ch = comm::chan(async_handle_po);\n-\n-    // the msg_po that libuv will be receiving on..\n-    let loop_msg_po = comm::port::<hl::high_level_msg>();\n-    let loop_msg_po_ptr = ptr::addr_of(loop_msg_po);\n-    let loop_msg_ch = comm::chan(loop_msg_po);\n-\n-    // the question of whether unsupervising this will even do any\n-    // good is there.. but since this'll go into blocking in libuv with\n-    // a quickness.. any errors that occur (including inside crust) will\n-    // be segfaults.. so yeah.\n+unsafe fn spawn_libuv_weak_task() -> (*ll::uv_async_t,\n+                                      comm::chan<hl::high_level_msg>){\n+    let exit_po = comm::port::<(*ll::uv_async_t,\n+                              comm::chan<hl::high_level_msg>)>();\n+    let exit_ch = comm::chan(exit_po);\n+    \n     task::spawn_sched(task::manual_threads(1u)) {||\n-        let loop_msg_po_in = *loop_msg_po_ptr;\n-        hl::run_high_level_loop(\n-            loop_ptr,\n-            loop_msg_po_in, // here the loop gets handed a different message\n-                            // port, as we'll be receiving all of the messages\n-                            // initially and then passing them on..\n-            // before_run\n-            {|async_handle|\n-                log(debug,#fmt(\"monitor gl: before_run: async_handle %?\",\n-                              async_handle));\n-                // when this is ran, our async_handle is set up, so let's\n-                // do an async_send with it.. letting the loop know, once it\n-                // starts, that is has work\n-                ll::async_send(async_handle);\n-                comm::send(async_handle_ch, copy(async_handle));\n-            },\n-            // before_msg_drain\n-            {|async_handle|\n-                log(debug,#fmt(\"monitor gl: b4_msg_drain: async_handle %?\",\n-                              async_handle));\n-                true\n-            },\n-            // before_tear_down\n-            {|async_handle|\n-                log(debug,#fmt(\"monitor gl: b4_tear_down: async_handle %?\",\n-                              async_handle));\n-            });\n+        log(debug, \"entering global libuv task\");\n+        let loop_ptr = ll::loop_new();\n+        priv::weaken_task() {|weak_exit_po|\n+            log(debug, #fmt(\"global libuv task is now weak %?\",\n+                            weak_exit_po));\n+            let loop_msg_po = comm::port::<hl::high_level_msg>();\n+            let loop_msg_ch = comm::chan(loop_msg_po);\n+            hl::run_high_level_loop(\n+                loop_ptr,\n+                loop_msg_po,\n+                // before_run\n+                {|async_handle|\n+                    log(debug,#fmt(\"global libuv: before_run %?\",\n+                                  async_handle));\n+                    let out_data = (async_handle, loop_msg_ch);\n+                    comm::send(exit_ch, out_data);\n+                },\n+                // before_msg_process\n+                {|async_handle, loop_active|\n+                    log(debug,#fmt(\"global libuv: before_msg_drain %? %?\",\n+                                  async_handle, loop_active));\n+                    true\n+                },\n+                // before_tear_down\n+                {|async_handle|\n+                    log(debug,#fmt(\"libuv task: before_tear_down %?\",\n+                                  async_handle));\n+                }\n+            );\n+            log(debug, \"global libuv task is leaving weakened state\");\n+        };\n+        ll::loop_delete(loop_ptr);\n+        log(debug, \"global libuv task exiting\");\n     };\n \n-    // our loop is set up, so let's emit the handle back out to our users..\n-    let async_handle = comm::recv(async_handle_po);\n-    // supposed to return a bool to indicate to the enclosing loop whether\n-    // it should continue or not..\n-    let mut continue_inner_loop = true;\n-    let mut didnt_get_hl_bailout = true;\n-    while continue_inner_loop {\n-        log(debug, \"monitor task inner loop.. about to block on select2\");\n-        continue_inner_loop = either::either(\n-            {|left_val|\n-                // bail out..\n-                log(debug, #fmt(\"monitor inner weak_exit_po recv'd msg: %?\",\n-                               left_val));\n-                // TODO: make loop bail out\n-                didnt_get_hl_bailout = false;\n-                false\n-            }, {|right_val|\n-                // wake up our inner loop and pass it a msg..\n-                comm::send(loop_msg_ch, copy(right_val));\n-                ll::async_send(async_handle);\n-                true\n-            }, comm::select2(weak_exit_po_in, msg_po_in)\n-        )\n-    }\n-    didnt_get_hl_bailout\n-}\n-\n-unsafe fn single_task_loop_body(weak_exit_po_in: comm::port<()>,\n-                          msg_po_in: comm::port<hl::high_level_msg>,\n-                          loop_ptr: *libc::c_void,\n-                          -first_interaction: hl::high_level_msg) -> bool {\n-    // resend the msg\n-    comm::send(comm::chan(msg_po_in), first_interaction);\n-\n-    // black magic\n-    let weak_exit_po_ptr = ptr::addr_of(weak_exit_po_in);\n-    hl::run_high_level_loop(\n-        loop_ptr,\n-        msg_po_in,\n-        // before_run\n-        {|async_handle|\n-            log(debug,#fmt(\"global_loop before_run: async_handle %?\",\n-                          async_handle));\n-            // set the handle as the global\n-            set_global_async_handle(0u as *ll::uv_async_t,\n-                                    async_handle);\n-            // when this is ran, our async_handle is set up, so let's\n-            // do an async_send with it\n-            ll::async_send(async_handle);\n-        },\n-        // before_msg_drain\n-        {|async_handle|\n-            log(debug,#fmt(\"global_loop before_msg_drain: async_handle %?\",\n-                          async_handle));\n-            let weak_exit_po = *weak_exit_po_ptr;\n-            if(comm::peek(weak_exit_po)) {\n-                // if this is true, immediately bail and return false, causing\n-                // the libuv loop to start tearing down\n-                log(debug,\"got weak_exit meg inside libuv loop\");\n-                comm::recv(weak_exit_po);\n-                false\n-            }\n-            // if no weak_exit_po msg is received, then we'll let the\n-            // loop continue\n-            else {\n-                true\n-            }\n-        },\n-        // before_tear_down\n-        {|async_handle|\n-            log(debug,#fmt(\"global_loop before_tear_down: async_handle %?\",\n-                          async_handle));\n-            set_global_async_handle(async_handle,\n-                                    0 as *ll::uv_async_t);\n-        });\n-    // supposed to return a bool to indicate to the enclosing loop whether\n-    // it should continue or not..\n-    ret true;\n-}\n-\n-unsafe fn get_global_async_handle_native_representation()\n-    -> *libc::uintptr_t {\n-    ret rustrt::rust_uv_get_kernel_global_async_handle();\n-}\n-\n-unsafe fn get_global_async_handle() -> *ll::uv_async_t {\n-    ret (*get_global_async_handle_native_representation()) as *ll::uv_async_t;\n-}\n-\n-unsafe fn set_global_async_handle(old: *ll::uv_async_t,\n-                           new_ptr: *ll::uv_async_t) {\n-    rustrt::rust_compare_and_swap_ptr(\n-        get_global_async_handle_native_representation(),\n-        old as libc::uintptr_t,\n-        new_ptr as libc::uintptr_t);\n+    comm::recv(exit_po)\n }\n \n #[cfg(test)]\n@@ -320,8 +157,7 @@ mod test {\n         let hl_loop = get_gl();\n         hl::interact(hl_loop) {|loop_ptr|\n             log(debug, \"closing timer\");\n-            //ll::close(timer_ptr as *libc::c_void, simple_timer_close_cb);\n-            hl::unref_and_close(hl_loop, timer_ptr, simple_timer_close_cb);\n+            ll::close(timer_ptr, simple_timer_close_cb);\n             log(debug, \"about to deref exit_ch_ptr\");\n             log(debug, \"after msg sent on deref'd exit_ch\");\n         };\n@@ -340,7 +176,6 @@ mod test {\n             log(debug, \"user code inside interact loop!!!\");\n             let init_status = ll::timer_init(loop_ptr, timer_ptr);\n             if(init_status == 0i32) {\n-                hl::ref(hl_loop, timer_ptr);\n                 ll::set_data_for_uv_handle(\n                     timer_ptr as *libc::c_void,\n                     exit_ch_ptr as *libc::c_void);\n@@ -359,13 +194,39 @@ mod test {\n         comm::recv(exit_po);\n         log(debug, \"global_loop timer test: msg recv on exit_po, done..\");\n     }\n+\n     #[test]\n-    #[ignore]\n-    fn test_uv_global_loop_high_level_global_timer() unsafe {\n+    fn test_gl_uv_global_loop_high_level_global_timer() unsafe {\n         let hl_loop = get_gl();\n+        let exit_po = comm::port::<()>();\n+        let exit_ch = comm::chan(exit_po);\n         task::spawn_sched(task::manual_threads(1u), {||\n             impl_uv_hl_simple_timer(hl_loop);\n+            comm::send(exit_ch, ());\n         });\n         impl_uv_hl_simple_timer(hl_loop);\n+        comm::recv(exit_po);\n+    }\n+\n+    // keeping this test ignored until some kind of stress-test-harness\n+    // is set up for the build bots\n+    #[test]\n+    #[ignore]\n+    fn test_stress_gl_uv_global_loop_high_level_global_timer() unsafe {\n+        let hl_loop = get_gl();\n+        let exit_po = comm::port::<()>();\n+        let exit_ch = comm::chan(exit_po);\n+        let cycles = 5000u;\n+        iter::repeat(cycles) {||\n+            task::spawn_sched(task::manual_threads(1u), {||\n+                impl_uv_hl_simple_timer(hl_loop);\n+                comm::send(exit_ch, ());\n+            });\n+        };\n+        iter::repeat(cycles) {||\n+            comm::recv(exit_po);\n+        };\n+        log(debug, \"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n+            \" exiting sucessfully!\");\n     }\n }\n\\ No newline at end of file"}, {"sha": "75c5c6ebea40af36ec046440ec99030590e12f39", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 68, "deletions": 250, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/92e88e4e2ce79868daee1ac3f77a6aaa193b5896/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e88e4e2ce79868daee1ac3f77a6aaa193b5896/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=92e88e4e2ce79868daee1ac3f77a6aaa193b5896", "patch": "@@ -6,8 +6,8 @@ provide a high-level, abstracted interface to some set of\n libuv functionality.\n \"];\n \n-export high_level_loop, hl_loop_ext, high_level_msg;\n-export run_high_level_loop, interact, ref, unref, unref_and_close;\n+export high_level_loop, high_level_msg;\n+export run_high_level_loop, interact;\n \n import ll = uv_ll;\n \n@@ -26,51 +26,15 @@ enum high_level_loop {\n     simple_task_loop({\n         async_handle: *ll::uv_async_t,\n         op_chan: comm::chan<high_level_msg>\n-    }),\n-    single_task_loop({\n-        async_handle: **ll::uv_async_t,\n-        op_chan: comm::chan<high_level_msg>\n-    }),\n-    monitor_task_loop({\n-        op_chan: comm::chan<high_level_msg>\n     })\n }\n \n-impl hl_loop_ext for high_level_loop {\n-    fn async_handle() -> **ll::uv_async_t {\n-        alt self {\n-          single_task_loop({async_handle, op_chan}) {\n-            ret async_handle;\n-          }\n-          _ {\n-            fail \"variant of hl::high_level_loop that doesn't include\" +\n-                \"an async_handle field\";\n-          }\n-        }\n-    }\n-    fn op_chan() -> comm::chan<high_level_msg> {\n-        alt self {\n-          single_task_loop({async_handle, op_chan}) {\n-            ret op_chan;\n-          }\n-          monitor_task_loop({op_chan}) {\n-            ret op_chan;\n-          }\n-          simple_task_loop({async_handle, op_chan}) {\n-            ret op_chan;\n-          }\n-        }\n-    }\n-}\n-\n #[doc=\"\n Represents the range of interactions with a `high_level_loop`\n \"]\n enum high_level_msg {\n     interaction (fn~(*libc::c_void)),\n-    ref_handle (*libc::c_void),\n-    manual_unref_handle (*libc::c_void, option<*u8>),\n-    tear_down\n+    teardown_loop\n }\n \n #[doc = \"\n@@ -93,7 +57,8 @@ provided `async_handle`. `uv_run` should return shortly after\n unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n                               msg_po: comm::port<high_level_msg>,\n                               before_run: fn~(*ll::uv_async_t),\n-                              before_msg_drain: fn~(*ll::uv_async_t) -> bool,\n+                              before_msg_process:\n+                                fn~(*ll::uv_async_t, bool) -> bool,\n                               before_tear_down: fn~(*ll::uv_async_t)) {\n     // set up the special async handle we'll use to allow multi-task\n     // communication with this loop\n@@ -106,11 +71,9 @@ unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n     let data: hl_loop_data = default_gl_data({\n         async_handle: async_handle,\n         mut active: true,\n-        before_msg_drain: before_msg_drain,\n+        before_msg_process: before_msg_process,\n         before_tear_down: before_tear_down,\n-        msg_po_ptr: ptr::addr_of(msg_po),\n-        mut refd_handles: [mut],\n-        mut unrefd_handles: [mut]\n+        msg_po_ptr: ptr::addr_of(msg_po)\n     });\n     let data_ptr = ptr::addr_of(data);\n     ll::set_data_for_uv_handle(async_handle, data_ptr);\n@@ -143,81 +106,33 @@ unsafe fn interact(a_loop: high_level_loop,\n     send_high_level_msg(a_loop, interaction(cb));\n }\n \n-iface uv_handle_manager<T> {\n-    fn init() -> T;\n-}\n-\n-type safe_handle_fields<T> = {\n-    hl_loop: high_level_loop,\n-    handle: T,\n-    close_cb: *u8\n-};\n-\n-/*fn safe_handle<T>(a_loop: high_level_loop,\n-                  handle_val: T,\n-                  handle_init_cb: fn~(*libc::c_void, *T),\n-                  close_cb: *u8) {\n-\n-resource safe_handle_container<T>(handle_fields: safe_handle_fields<T>) {\n-}\n-}*/\n-\n-\n-#[doc=\"\n-Needs to be encapsulated within `safe_handle`\n-\"]\n-fn ref<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n-    send_high_level_msg(hl_loop, ref_handle(handle as *libc::c_void));\n-}\n-#[doc=\"\n-Needs to be encapsulated within `safe_handle`\n-\"]\n-fn unref<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n-    send_high_level_msg(hl_loop, manual_unref_handle(handle as *libc::c_void,\n-                                                   none));\n-}\n-fn unref_and_close<T>(hl_loop: high_level_loop, handle: *T, cb: *u8) unsafe {\n-    send_high_level_msg(hl_loop, manual_unref_handle(handle as *libc::c_void,\n-                                                   some(cb)));\n-}\n-\n // INTERNAL API\n \n // data that lives for the lifetime of the high-evel oo\n enum hl_loop_data {\n     default_gl_data({\n         async_handle: *ll::uv_async_t,\n         mut active: bool,\n-        before_msg_drain: fn~(*ll::uv_async_t) -> bool,\n+        before_msg_process: fn~(*ll::uv_async_t, bool) -> bool,\n         before_tear_down: fn~(*ll::uv_async_t),\n-        msg_po_ptr: *comm::port<high_level_msg>,\n-        mut refd_handles: [mut *libc::c_void],\n-        mut unrefd_handles: [mut *libc::c_void]})\n+        msg_po_ptr: *comm::port<high_level_msg>})\n }\n \n unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n-                              -msg: high_level_msg) unsafe {\n-    comm::send(hl_loop.op_chan(), msg);\n+                              -msg: high_level_msg) {\n+    let op_chan = alt hl_loop{simple_task_loop({async_handle, op_chan}){\n+      op_chan}};\n+    comm::send(op_chan, msg);\n \n     // if the global async handle == 0, then that means\n     // the loop isn't active, so we don't need to wake it up,\n     // (the loop's enclosing task should be blocking on a message\n     // receive on this port)\n     alt hl_loop {\n-      single_task_loop({async_handle, op_chan}) {\n-        if ((*async_handle) != 0 as *ll::uv_async_t) {\n-            log(debug,\"global async handle != 0, waking up loop..\");\n-            ll::async_send((*async_handle));\n-        }\n-        else {\n-            log(debug,\"GLOBAL ASYNC handle == 0\");\n-        }\n-      }\n       simple_task_loop({async_handle, op_chan}) {\n         log(debug,\"simple async handle != 0, waking up loop..\");\n         ll::async_send((async_handle));\n       }\n-      _ {}\n     }\n }\n \n@@ -228,162 +143,64 @@ unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n // data member\n crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n                                status: int) unsafe {\n-    // nothing here, yet.\n     log(debug, #fmt(\"high_level_wake_up_cb crust.. handle: %? status: %?\",\n                      async_handle, status));\n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n     let data = ll::get_data_for_uv_handle(async_handle) as *hl_loop_data;\n-    // we check to see if the loop is \"active\" (the loop is set to\n-    // active = false the first time we realize we need to 'tear down',\n-    // set subsequent calls to the global async handle may be triggered\n-    // before all of the uv_close() calls are processed and loop exits\n-    // on its own. So if the loop isn't active, we won't run the user's\n-    // on_wake callback (and, consequently, let messages pile up, probably\n-    // in the loops msg_po)\n-    if (*data).active {\n-        log(debug, \"before on_wake\");\n-        let mut do_msg_drain = (*data).before_msg_drain(async_handle);\n-        let mut continue = true;\n-        if do_msg_drain {\n-            let msg_po = *((*data).msg_po_ptr);\n-            if comm::peek(msg_po) {\n-                // if this is true, we'll iterate over the\n-                // msgs waiting in msg_po until there's no more\n-                log(debug,\"got msg_po\");\n-                while(continue) {\n-                    log(debug,\"before alt'ing on high_level_msg\");\n-                    alt comm::recv(msg_po) {\n+    alt (*data).active {\n+      true {\n+        let msg_po = *((*data).msg_po_ptr);\n+        alt comm::peek(msg_po) {\n+          true {\n+            loop {\n+                let msg = comm::recv(msg_po);\n+                alt (*data).active {\n+                  true {\n+                    alt msg {\n                       interaction(cb) {\n-                        log(debug,\"got interaction, before cb..\");\n-                        // call it..\n+                        (*data).before_msg_process(async_handle,\n+                                                   (*data).active);\n                         cb(loop_ptr);\n-                        log(debug,\"after calling cb\");\n                       }\n-                      ref_handle(handle) {\n-                        high_level_ref(data, handle);\n-                      }\n-                      manual_unref_handle(handle, user_close_cb) {\n-                        high_level_unref(data, handle, true, user_close_cb);\n-                      }\n-                      tear_down {\n-                        log(debug,\"incoming hl_msg: got tear_down\");\n+                      teardown_loop {\n+                        begin_teardown(data);\n                       }\n                     }\n-                    continue = comm::peek(msg_po);\n+                  }\n+                  false {\n+                    // drop msg ?\n+                  }\n                 }\n+                if !comm::peek(msg_po) { break; }\n             }\n-            else {\n-                log(debug, \"in hl wake_cb, no pending messages\");\n-            }\n-        }\n-        log(debug, #fmt(\"after on_wake, continue? %?\", continue));\n-        if !do_msg_drain {\n-            high_level_tear_down(data);\n+          }\n+          false {\n+            // no pending msgs\n+          }\n         }\n+      }\n+      false {\n+        // loop not active\n+      }\n     }\n }\n \n crust fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n-    log(debug, #fmt(\"tear_down_close_cb called, closing handle at %?\",\n-                    handle));\n-    let data = ll::get_data_for_uv_handle(handle) as *hl_loop_data;\n-    if vec::len((*data).refd_handles) > 0u {\n-        fail \"Didn't unref all high-level handles\";\n-    }\n+    let loop_ptr = ll::get_loop_for_uv_handle(handle);\n+    let loop_refs = ll::loop_refcount(loop_ptr);\n+    log(debug, #fmt(\"tear_down_close_cb called, closing handle at %? refs %?\",\n+                    handle, loop_refs));\n+    assert loop_refs == 1i32;\n }\n \n-fn high_level_tear_down(data: *hl_loop_data) unsafe {\n+fn begin_teardown(data: *hl_loop_data) unsafe {\n     log(debug, \"high_level_tear_down() called, close async_handle\");\n     // call user-suppled before_tear_down cb\n     let async_handle = (*data).async_handle;\n     (*data).before_tear_down(async_handle);\n     ll::close(async_handle as *libc::c_void, tear_down_close_cb);\n }\n \n-unsafe fn high_level_ref(data: *hl_loop_data, handle: *libc::c_void) {\n-    log(debug,\"incoming hl_msg: got ..ref_handle\");\n-    let mut refd_handles = (*data).refd_handles;\n-    let mut unrefd_handles = (*data).unrefd_handles;\n-    let handle_already_refd = refd_handles.contains(handle);\n-    if handle_already_refd {\n-        fail \"attempt to do a high-level ref an already ref'd handle\";\n-    }\n-    let handle_already_unrefd = unrefd_handles.contains(handle);\n-    // if we are ref'ing a handle (by ptr) that was already unref'd,\n-    // probably\n-    if handle_already_unrefd {\n-        let last_idx = vec::len(unrefd_handles) - 1u;\n-        let handle_idx = vec::position_elem(unrefd_handles, handle);\n-        alt handle_idx {\n-          none {\n-            fail \"trying to remove handle that isn't in unrefd_handles\";\n-          }\n-          some(idx) {\n-            unrefd_handles[idx] <-> unrefd_handles[last_idx];\n-            vec::pop(unrefd_handles);\n-          }\n-        }\n-        (*data).unrefd_handles = unrefd_handles;\n-    }\n-    refd_handles += [handle];\n-    (*data).refd_handles = refd_handles;\n-}\n-\n-unsafe fn high_level_unref(data: *hl_loop_data, handle: *libc::c_void,\n-                   manual_unref: bool, user_close_cb: option<*u8>) {\n-    log(debug,\"incoming hl_msg: got auto_unref_handle\");\n-    let mut refd_handles = (*data).refd_handles;\n-    let mut unrefd_handles = (*data).unrefd_handles;\n-    log(debug, #fmt(\"refs: %?, unrefs %? handle %?\", vec::len(refd_handles),\n-                    vec::len(unrefd_handles), handle));\n-    let handle_already_refd = refd_handles.contains(handle);\n-    if !handle_already_refd {\n-        fail \"attempting to high-level unref an untracked handle\";\n-    }\n-    let double_unref = unrefd_handles.contains(handle);\n-    if double_unref {\n-        log(debug, \"double unref encountered\");\n-        if manual_unref {\n-            // will allow a user to manual unref, but only signal\n-            // a fail when a double-unref is caused by a user\n-            fail \"attempting to high-level unref an unrefd handle\";\n-        }\n-        else {\n-            log(debug, \"not failing...\");\n-        }\n-    }\n-    else {\n-        log(debug, \"attempting to unref handle\");\n-        alt user_close_cb {\n-          some(cb) {\n-            ll::close(handle, cb);\n-          }\n-          none { }\n-        }\n-        let last_idx = vec::len(refd_handles) - 1u;\n-        let handle_idx = vec::position_elem(refd_handles, handle);\n-        alt handle_idx {\n-          none {\n-            fail \"trying to remove handle that isn't in refd_handles\";\n-          }\n-          some(idx) {\n-            refd_handles[idx] <-> refd_handles[last_idx];\n-            vec::pop(refd_handles);\n-          }\n-        }\n-        (*data).refd_handles = refd_handles;\n-        unrefd_handles += [handle];\n-        (*data).unrefd_handles = unrefd_handles;\n-        if vec::len(refd_handles) == 0u {\n-            log(debug, \"0 referenced handles, start loop teardown\");\n-            high_level_tear_down(data);\n-        }\n-        else {\n-            log(debug, \"more than 0 referenced handles\");\n-        }\n-    }\n-\n-}\n #[cfg(test)]\n mod test {\n     crust fn async_close_cb(handle: *ll::uv_async_t) unsafe {\n@@ -397,7 +214,7 @@ mod test {\n         log(debug, #fmt(\"async_handle_cb handle %? status %?\",handle,status));\n         let hl_loop = (*(ll::get_data_for_uv_handle(handle)\n                         as *ah_data)).hl_loop;\n-        unref_and_close(hl_loop, handle, async_close_cb);\n+        ll::close(handle, async_close_cb);\n     }\n     type ah_data = {\n         hl_loop: high_level_loop,\n@@ -414,7 +231,6 @@ mod test {\n         };\n         let ah_data_ptr = ptr::addr_of(ah_data);\n         interact(hl_loop) {|loop_ptr|\n-            ref(hl_loop, ah_ptr);\n             ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n             ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n             ll::async_send(ah_ptr);\n@@ -446,9 +262,9 @@ mod test {\n                     }));\n                 },\n                 // before_msg_drain\n-                {|async_handle|\n-                    log(debug,#fmt(\"hltest before_msg_drain: async_handle %?\",\n-                                  async_handle));\n+                {|async_handle, status|\n+                    log(debug,#fmt(\"hltest before_msg_drain: handle %? %?\",\n+                                  async_handle, status));\n                     true\n                 },\n                 // before_tear_down\n@@ -473,7 +289,6 @@ mod test {\n     }\n \n     #[test]\n-    #[ignore]\n     fn test_uv_hl_async() unsafe {\n         let exit_po = comm::port::<()>();\n         let exit_ch = comm::chan(exit_po);\n@@ -485,27 +300,30 @@ mod test {\n         // under race-condition type situations.. this ensures that the loop\n         // lives until, at least, all of the impl_uv_hl_async() runs have been\n         // called, at least.\n-        let lifetime_handle = ll::async_t();\n-        let lifetime_handle_ptr = ptr::addr_of(lifetime_handle);\n-        interact(hl_loop) {|loop_ptr|\n-            ref(hl_loop, lifetime_handle_ptr);\n-            ll::async_init(loop_ptr, lifetime_handle_ptr,\n-                          lifetime_async_callback);\n-        };\n-\n+        let work_exit_po = comm::port::<()>();\n+        let work_exit_ch = comm::chan(work_exit_po);\n         iter::repeat(7u) {||\n             task::spawn_sched(task::manual_threads(1u), {||\n                 impl_uv_hl_async(hl_loop);\n+                comm::send(work_exit_ch, ());\n             });\n         };\n-        impl_uv_hl_async(hl_loop);\n-        impl_uv_hl_async(hl_loop);\n-        impl_uv_hl_async(hl_loop);\n-        interact(hl_loop) {|loop_ptr|\n-            ll::close(lifetime_handle_ptr, lifetime_handle_close);\n-            unref(hl_loop, lifetime_handle_ptr);\n-            log(debug, \"close and unref lifetime handle\");\n+        iter::repeat(7u) {||\n+            comm::recv(work_exit_po);\n         };\n+        log(debug, \"sending teardown_loop msg..\");\n+        // the teardown msg usually comes, in the case of the global loop,\n+        // as a result of receiving a msg on the weaken_task port. but,\n+        // anyone rolling their own high_level_loop can decide when to\n+        // send the msg. it's assert and barf, though, if all of your\n+        // handles aren't uv_close'd first\n+        alt hl_loop {\n+          simple_task_loop({async_handle, op_chan}) {\n+            comm::send(op_chan, teardown_loop);\n+            ll::async_send(async_handle);\n+          }\n+        }\n         comm::recv(exit_po);\n+        log(debug, \"after recv on exit_po.. exiting..\");\n     }\n }"}]}