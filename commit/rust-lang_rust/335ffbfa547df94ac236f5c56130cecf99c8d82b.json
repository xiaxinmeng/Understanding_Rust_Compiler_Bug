{"sha": "335ffbfa547df94ac236f5c56130cecf99c8d82b", "node_id": "C_kwDOAAsO6NoAKDMzNWZmYmZhNTQ3ZGY5NGFjMjM2ZjVjNTYxMzBjZWNmOTljOGQ4MmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-11T19:23:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-11T19:23:55Z"}, "message": "Auto merge of #94472 - JmPotato:use_maybeuninit_for_vecdeque, r=m-ou-se\n\nUse MaybeUninit in VecDeque to remove the undefined behavior of slice\n\nSigned-off-by: JmPotato <ghzpotato@gmail.com>\n\nRef https://github.com/rust-lang/rust/issues/74189. Adjust the code to follow the [doc.rust-lang.org/reference/behavior-considered-undefined.html](https://doc.rust-lang.org/reference/behavior-considered-undefined.html).\n\n* Change the return type of `buffer_as_slice` from `&[T]` to `&[MaybeUninit<T>]`.\n* Add some corresponding safety comments.\n\nBenchmark results:\n\nmaster 8d6f527530f4ba974d922269267fe89050188789\n\n```rust\ntest collections::vec_deque::tests::bench_pop_back_100       ... bench:          47 ns/iter (+/- 1)\ntest collections::vec_deque::tests::bench_pop_front_100      ... bench:          50 ns/iter (+/- 4)\ntest collections::vec_deque::tests::bench_push_back_100      ... bench:          69 ns/iter (+/- 10)\ntest collections::vec_deque::tests::bench_push_front_100     ... bench:          72 ns/iter (+/- 6)\ntest collections::vec_deque::tests::bench_retain_half_10000  ... bench:     145,891 ns/iter (+/- 7,975)\ntest collections::vec_deque::tests::bench_retain_odd_10000   ... bench:     141,647 ns/iter (+/- 3,711)\ntest collections::vec_deque::tests::bench_retain_whole_10000 ... bench:     120,132 ns/iter (+/- 4,078)\n```\n\nThis PR\n\n```rust\ntest collections::vec_deque::tests::bench_pop_back_100       ... bench:          48 ns/iter (+/- 2)\ntest collections::vec_deque::tests::bench_pop_front_100      ... bench:          51 ns/iter (+/- 3)\ntest collections::vec_deque::tests::bench_push_back_100      ... bench:          73 ns/iter (+/- 2)\ntest collections::vec_deque::tests::bench_push_front_100     ... bench:          73 ns/iter (+/- 2)\ntest collections::vec_deque::tests::bench_retain_half_10000  ... bench:     131,796 ns/iter (+/- 5,440)\ntest collections::vec_deque::tests::bench_retain_odd_10000   ... bench:     137,563 ns/iter (+/- 3,349)\ntest collections::vec_deque::tests::bench_retain_whole_10000 ... bench:     128,815 ns/iter (+/- 3,289)\n```", "tree": {"sha": "01a88b422c236a89c46590a3a3eadec1935560a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01a88b422c236a89c46590a3a3eadec1935560a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/335ffbfa547df94ac236f5c56130cecf99c8d82b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/335ffbfa547df94ac236f5c56130cecf99c8d82b", "html_url": "https://github.com/rust-lang/rust/commit/335ffbfa547df94ac236f5c56130cecf99c8d82b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/335ffbfa547df94ac236f5c56130cecf99c8d82b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b45e601065c3fb71a4f67481e912391d075621", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b45e601065c3fb71a4f67481e912391d075621", "html_url": "https://github.com/rust-lang/rust/commit/c9b45e601065c3fb71a4f67481e912391d075621"}, {"sha": "2f18fa801b783fe9b7c896af40f27d1b5be8da9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f18fa801b783fe9b7c896af40f27d1b5be8da9a", "html_url": "https://github.com/rust-lang/rust/commit/2f18fa801b783fe9b7c896af40f27d1b5be8da9a"}], "stats": {"total": 125, "additions": 95, "deletions": 30}, "files": [{"sha": "e8290809276fbf031ad414615f4e1814edbff0f5", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/335ffbfa547df94ac236f5c56130cecf99c8d82b/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335ffbfa547df94ac236f5c56130cecf99c8d82b/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=335ffbfa547df94ac236f5c56130cecf99c8d82b", "patch": "@@ -1,5 +1,6 @@\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n+use core::mem::MaybeUninit;\n use core::ops::Try;\n \n use super::{count, wrap_index, RingSlices};\n@@ -12,7 +13,7 @@ use super::{count, wrap_index, RingSlices};\n /// [`iter`]: super::VecDeque::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    pub(crate) ring: &'a [T],\n+    pub(crate) ring: &'a [MaybeUninit<T>],\n     pub(crate) tail: usize,\n     pub(crate) head: usize,\n }\n@@ -21,7 +22,15 @@ pub struct Iter<'a, T: 'a> {\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n+        // Safety:\n+        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n+        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n+        unsafe {\n+            f.debug_tuple(\"Iter\")\n+                .field(&MaybeUninit::slice_assume_init_ref(front))\n+                .field(&MaybeUninit::slice_assume_init_ref(back))\n+                .finish()\n+        }\n     }\n }\n \n@@ -44,7 +53,10 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         }\n         let tail = self.tail;\n         self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-        unsafe { Some(self.ring.get_unchecked(tail)) }\n+        // Safety:\n+        // - `self.tail` in a ring buffer is always a valid index.\n+        // - `self.head` and `self.tail` equality is checked above.\n+        unsafe { Some(self.ring.get_unchecked(tail).assume_init_ref()) }\n     }\n \n     #[inline]\n@@ -58,8 +70,13 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        accum = front.iter().fold(accum, &mut f);\n-        back.iter().fold(accum, &mut f)\n+        // Safety:\n+        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n+        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n+        unsafe {\n+            accum = MaybeUninit::slice_assume_init_ref(front).iter().fold(accum, &mut f);\n+            MaybeUninit::slice_assume_init_ref(back).iter().fold(accum, &mut f)\n+        }\n     }\n \n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n@@ -70,17 +87,19 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     {\n         let (mut iter, final_res);\n         if self.tail <= self.head {\n-            // single slice self.ring[self.tail..self.head]\n-            iter = self.ring[self.tail..self.head].iter();\n+            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n+            iter = unsafe { MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]) }\n+                .iter();\n             final_res = iter.try_fold(init, &mut f);\n         } else {\n-            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n             let (front, back) = self.ring.split_at(self.tail);\n-            let mut back_iter = back.iter();\n+\n+            let mut back_iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n             let res = back_iter.try_fold(init, &mut f);\n             let len = self.ring.len();\n             self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n-            iter = front[..self.head].iter();\n+            iter = unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };\n             final_res = iter.try_fold(res?, &mut f);\n         }\n         self.tail = self.head - iter.len();\n@@ -109,7 +128,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         // that is in bounds.\n         unsafe {\n             let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n-            self.ring.get_unchecked(idx)\n+            self.ring.get_unchecked(idx).assume_init_ref()\n         }\n     }\n }\n@@ -122,16 +141,24 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n             return None;\n         }\n         self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-        unsafe { Some(self.ring.get_unchecked(self.head)) }\n+        // Safety:\n+        // - `self.head` in a ring buffer is always a valid index.\n+        // - `self.head` and `self.tail` equality is checked above.\n+        unsafe { Some(self.ring.get_unchecked(self.head).assume_init_ref()) }\n     }\n \n     fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        accum = back.iter().rfold(accum, &mut f);\n-        front.iter().rfold(accum, &mut f)\n+        // Safety:\n+        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n+        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n+        unsafe {\n+            accum = MaybeUninit::slice_assume_init_ref(back).iter().rfold(accum, &mut f);\n+            MaybeUninit::slice_assume_init_ref(front).iter().rfold(accum, &mut f)\n+        }\n     }\n \n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n@@ -142,16 +169,20 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     {\n         let (mut iter, final_res);\n         if self.tail <= self.head {\n-            // single slice self.ring[self.tail..self.head]\n-            iter = self.ring[self.tail..self.head].iter();\n+            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n+            iter = unsafe {\n+                MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]).iter()\n+            };\n             final_res = iter.try_rfold(init, &mut f);\n         } else {\n-            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n             let (front, back) = self.ring.split_at(self.tail);\n-            let mut front_iter = front[..self.head].iter();\n+\n+            let mut front_iter =\n+                unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };\n             let res = front_iter.try_rfold(init, &mut f);\n             self.head = front_iter.len();\n-            iter = back.iter();\n+            iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n             final_res = iter.try_rfold(res?, &mut f);\n         }\n         self.head = self.tail + iter.len();"}, {"sha": "63280e56332cb367da63e8a1a48a659b2d0ceb2f", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/335ffbfa547df94ac236f5c56130cecf99c8d82b/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335ffbfa547df94ac236f5c56130cecf99c8d82b/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=335ffbfa547df94ac236f5c56130cecf99c8d82b", "patch": "@@ -12,7 +12,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{repeat_with, FromIterator};\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::{Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice;\n@@ -181,16 +181,28 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Turn ptr into a slice\n+    /// Turn ptr into a slice, since the elements of the backing buffer may be uninitialized,\n+    /// we will return a slice of [`MaybeUninit<T>`].\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n     #[inline]\n-    unsafe fn buffer_as_slice(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.ptr(), self.cap()) }\n+    unsafe fn buffer_as_slice(&self) -> &[MaybeUninit<T>] {\n+        unsafe { slice::from_raw_parts(self.ptr() as *mut MaybeUninit<T>, self.cap()) }\n     }\n \n-    /// Turn ptr into a mut slice\n+    /// Turn ptr into a mut slice, since the elements of the backing buffer may be uninitialized,\n+    /// we will return a slice of [`MaybeUninit<T>`].\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n     #[inline]\n-    unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr(), self.cap()) }\n+    unsafe fn buffer_as_mut_slice(&mut self) -> &mut [MaybeUninit<T>] {\n+        unsafe { slice::from_raw_parts_mut(self.ptr() as *mut MaybeUninit<T>, self.cap()) }\n     }\n \n     /// Moves an element out of the buffer\n@@ -1055,9 +1067,13 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n+        // Safety:\n+        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n+        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n         unsafe {\n             let buf = self.buffer_as_slice();\n-            RingSlices::ring_slices(buf, self.head, self.tail)\n+            let (front, back) = RingSlices::ring_slices(buf, self.head, self.tail);\n+            (MaybeUninit::slice_assume_init_ref(front), MaybeUninit::slice_assume_init_ref(back))\n         }\n     }\n \n@@ -1089,11 +1105,15 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n+        // Safety:\n+        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n+        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n         unsafe {\n             let head = self.head;\n             let tail = self.tail;\n             let buf = self.buffer_as_mut_slice();\n-            RingSlices::ring_slices(buf, head, tail)\n+            let (front, back) = RingSlices::ring_slices(buf, head, tail);\n+            (MaybeUninit::slice_assume_init_mut(front), MaybeUninit::slice_assume_init_mut(back))\n         }\n     }\n \n@@ -2327,7 +2347,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         if self.is_contiguous() {\n             let tail = self.tail;\n             let head = self.head;\n-            return unsafe { RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0 };\n+            // Safety:\n+            // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n+            // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n+            return unsafe {\n+                MaybeUninit::slice_assume_init_mut(\n+                    RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0,\n+                )\n+            };\n         }\n \n         let buf = self.buf.ptr();\n@@ -2413,7 +2440,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n \n         let tail = self.tail;\n         let head = self.head;\n-        unsafe { RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0 }\n+        // Safety:\n+        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n+        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n+        unsafe {\n+            MaybeUninit::slice_assume_init_mut(\n+                RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0,\n+            )\n+        }\n     }\n \n     /// Rotates the double-ended queue `mid` places to the left."}]}