{"sha": "2d718a3fc23fbe9a27c71709c54128b5305609c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNzE4YTNmYzIzZmJlOWEyN2M3MTcwOWM1NDEyOGI1MzA1NjA5Yzc=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-30T00:09:09Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-30T19:24:03Z"}, "message": "The method trim_left_preserve_layout didn't handle tabs properly.\n\nThis is fixed by taking the method macros::indent_macro_snippet which\nessentially does the same: it indents a paragraph while preserving the\nlayout.", "tree": {"sha": "0a04610652e56357542d257da85718c204d0d918", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a04610652e56357542d257da85718c204d0d918"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d718a3fc23fbe9a27c71709c54128b5305609c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlvYr9MACgkQbVYg2Qgh\nATOsigf+LU3KOVBITrrmPuMA1rCih+lhXZNU6Mh0FUP6WVoWl+tUlM5nzDq4Lse7\nnRljMlByLaxYciXDNDF69BhxFqOWpHSOkp2GVhcw55p95LqjYLTR4WUszDGLoNEz\n+AYavQW8YhnRJ0LvSinuSyKuhMY5RF7QQbHqbqlsEV/B8/p02aULFVppc0lQxE3p\nnGupvWv+9W5XL71G8biIY2kKhsTho9Yd0LZRi43elO0TkCp8Gx04XC9NZJ5ACe/S\nKcWbFavI2LRC2f9+VxsO/cKgsFSpAKQ6WBcdIlBcP1sRI6MPfCf1WgHblc5hEDNX\n7feTt6Dv0h4VqAbpo/bVyyTaHI4Kgg==\n=fTCu\n-----END PGP SIGNATURE-----", "payload": "tree 0a04610652e56357542d257da85718c204d0d918\nparent b2706ebeccf1ee92fa587fb35dc8a7654d837309\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1540858149 +0100\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1540927443 +0100\n\nThe method trim_left_preserve_layout didn't handle tabs properly.\n\nThis is fixed by taking the method macros::indent_macro_snippet which\nessentially does the same: it indents a paragraph while preserving the\nlayout.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d718a3fc23fbe9a27c71709c54128b5305609c7", "html_url": "https://github.com/rust-lang/rust/commit/2d718a3fc23fbe9a27c71709c54128b5305609c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d718a3fc23fbe9a27c71709c54128b5305609c7/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2706ebeccf1ee92fa587fb35dc8a7654d837309", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2706ebeccf1ee92fa587fb35dc8a7654d837309", "html_url": "https://github.com/rust-lang/rust/commit/b2706ebeccf1ee92fa587fb35dc8a7654d837309"}], "stats": {"total": 290, "additions": 147, "deletions": 143}, "files": [{"sha": "eaed5e1d41eb6dd60eb74fc1d396ffb460f76a20", "filename": "src/comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d718a3fc23fbe9a27c71709c54128b5305609c7/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d718a3fc23fbe9a27c71709c54128b5305609c7/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=2d718a3fc23fbe9a27c71709c54128b5305609c7", "patch": "@@ -332,7 +332,7 @@ fn identify_comment(\n     let (first_group, rest) = orig.split_at(first_group_ending);\n     let rewritten_first_group =\n         if !config.normalize_comments() && has_bare_lines && style.is_block_comment() {\n-            trim_left_preserve_layout(first_group, &shape.indent, config)\n+            trim_left_preserve_layout(first_group, &shape.indent, config)?\n         } else if !config.normalize_comments()\n             && !config.wrap_comments()\n             && !config.format_doc_comments()"}, {"sha": "20592beaf17b88e9142128845bccbf44519d96da", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 104, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2d718a3fc23fbe9a27c71709c54128b5305609c7/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d718a3fc23fbe9a27c71709c54128b5305609c7/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=2d718a3fc23fbe9a27c71709c54128b5305609c7", "patch": "@@ -40,7 +40,10 @@ use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use source_map::SpanUtils;\n use spanned::Spanned;\n-use utils::{format_visibility, mk_sp, remove_trailing_white_spaces, rewrite_ident, wrap_str};\n+use utils::{\n+    format_visibility, is_empty_line, mk_sp, remove_trailing_white_spaces, rewrite_ident,\n+    trim_left_preserve_layout, wrap_str,\n+};\n use visitor::FmtVisitor;\n \n const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];\n@@ -373,7 +376,7 @@ pub fn rewrite_macro_inner(\n         }\n         DelimToken::Brace => {\n             // Skip macro invocations with braces, for now.\n-            indent_macro_snippet(context, context.snippet(mac.span), shape.indent)\n+            trim_left_preserve_layout(context.snippet(mac.span), &shape.indent, &context.config)\n         }\n         _ => unreachable!(),\n     }\n@@ -1101,108 +1104,6 @@ fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> DelimToken {\n     }\n }\n \n-/// Indent each line according to the specified `indent`.\n-/// e.g.\n-///\n-/// ```rust,ignore\n-/// foo!{\n-/// x,\n-/// y,\n-/// foo(\n-///     a,\n-///     b,\n-///     c,\n-/// ),\n-/// }\n-/// ```\n-///\n-/// will become\n-///\n-/// ```rust,ignore\n-/// foo!{\n-///     x,\n-///     y,\n-///     foo(\n-///         a,\n-///         b,\n-///         c,\n-///     ),\n-/// }\n-/// ```\n-fn indent_macro_snippet(\n-    context: &RewriteContext,\n-    macro_str: &str,\n-    indent: Indent,\n-) -> Option<String> {\n-    let mut lines = LineClasses::new(macro_str);\n-    let first_line = lines.next().map(|(_, s)| s.trim_right().to_owned())?;\n-    let mut trimmed_lines = Vec::with_capacity(16);\n-\n-    let mut veto_trim = false;\n-    let min_prefix_space_width = lines\n-        .filter_map(|(kind, line)| {\n-            let mut trimmed = true;\n-            let prefix_space_width = if is_empty_line(&line) {\n-                None\n-            } else {\n-                Some(get_prefix_space_width(context, &line))\n-            };\n-\n-            let line = if veto_trim || (kind.is_string() && !line.ends_with('\\\\')) {\n-                veto_trim = kind.is_string() && !line.ends_with('\\\\');\n-                trimmed = false;\n-                line\n-            } else {\n-                line.trim().to_owned()\n-            };\n-            trimmed_lines.push((trimmed, line, prefix_space_width));\n-\n-            // when computing the minimum, do not consider lines within a string\n-            match kind {\n-                FullCodeCharKind::InString | FullCodeCharKind::EndString => None,\n-                _ => prefix_space_width,\n-            }\n-        })\n-        .min()?;\n-\n-    Some(\n-        first_line\n-            + \"\\n\"\n-            + &trimmed_lines\n-                .iter()\n-                .map(\n-                    |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n-                        _ if !trimmed => line.to_owned(),\n-                        Some(original_indent_width) => {\n-                            let new_indent_width = indent.width()\n-                                + original_indent_width.saturating_sub(min_prefix_space_width);\n-                            let new_indent = Indent::from_width(context.config, new_indent_width);\n-                            format!(\"{}{}\", new_indent.to_string(context.config), line)\n-                        }\n-                        None => String::new(),\n-                    },\n-                )\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\"),\n-    )\n-}\n-\n-fn get_prefix_space_width(context: &RewriteContext, s: &str) -> usize {\n-    let mut width = 0;\n-    for c in s.chars() {\n-        match c {\n-            ' ' => width += 1,\n-            '\\t' => width += context.config.tab_spaces(),\n-            _ => return width,\n-        }\n-    }\n-    width\n-}\n-\n-fn is_empty_line(s: &str) -> bool {\n-    s.is_empty() || s.chars().all(char::is_whitespace)\n-}\n-\n // A very simple parser that just parses a macros 2.0 definition into its branches.\n // Currently we do not attempt to parse any further than that.\n #[derive(new)]"}, {"sha": "86c01af39fba5bda8f7841e027555ecaba4efe9b", "filename": "src/utils.rs", "status": "modified", "additions": 115, "deletions": 38, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/2d718a3fc23fbe9a27c71709c54128b5305609c7/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d718a3fc23fbe9a27c71709c54128b5305609c7/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=2d718a3fc23fbe9a27c71709c54128b5305609c7", "patch": "@@ -20,7 +20,7 @@ use syntax::ast::{\n use syntax::ptr;\n use syntax::source_map::{BytePos, Span, NO_EXPANSION};\n \n-use comment::{filter_normal_code, CharClasses, FullCodeCharKind};\n+use comment::{filter_normal_code, CharClasses, FullCodeCharKind, LineClasses};\n use config::Config;\n use rewrite::RewriteContext;\n use shape::{Indent, Shape};\n@@ -483,46 +483,123 @@ pub fn remove_trailing_white_spaces(text: &str) -> String {\n     buffer\n }\n \n-/// Trims a minimum of leading whitespaces so that the content layout is kept and aligns to indent.\n-pub fn trim_left_preserve_layout(orig: &str, indent: &Indent, config: &Config) -> String {\n-    let prefix_whitespace_min = orig\n-        .lines()\n-        // skip the line with the starting sigil since the leading whitespace is removed\n-        // otherwise, the minimum would always be zero\n-        .skip(1)\n-        .filter(|line| !line.is_empty())\n-        .map(|line| {\n-            let mut width = 0;\n-            for c in line.chars() {\n-                match c {\n-                    ' ' => width += 1,\n-                    '\\t' => width += config.tab_spaces(),\n-                    _ => break,\n-                }\n-            }\n-            width\n-        })\n-        .min()\n-        .unwrap_or(0);\n-\n-    let indent_str = indent.to_string(config);\n-    let mut lines = orig.lines();\n-    let first_line = lines.next().unwrap();\n-    let rest = lines\n-        .map(|line| {\n-            if line.is_empty() {\n-                String::from(\"\\n\")\n+/// Indent each line according to the specified `indent`.\n+/// e.g.\n+///\n+/// ```rust,ignore\n+/// foo!{\n+/// x,\n+/// y,\n+/// foo(\n+///     a,\n+///     b,\n+///     c,\n+/// ),\n+/// }\n+/// ```\n+///\n+/// will become\n+///\n+/// ```rust,ignore\n+/// foo!{\n+///     x,\n+///     y,\n+///     foo(\n+///         a,\n+///         b,\n+///         c,\n+///     ),\n+/// }\n+/// ```\n+pub fn trim_left_preserve_layout(orig: &str, indent: &Indent, config: &Config) -> Option<String> {\n+    let mut lines = LineClasses::new(orig);\n+    let first_line = lines.next().map(|(_, s)| s.trim_right().to_owned())?;\n+    let mut trimmed_lines = Vec::with_capacity(16);\n+\n+    let mut veto_trim = false;\n+    let min_prefix_space_width = lines\n+        .filter_map(|(kind, line)| {\n+            let mut trimmed = true;\n+            let prefix_space_width = if is_empty_line(&line) {\n+                None\n             } else {\n-                format!(\"\\n{}{}\", indent_str, &line[prefix_whitespace_min..])\n+                Some(get_prefix_space_width(config, &line))\n+            };\n+\n+            let line = if veto_trim || (kind.is_string() && !line.ends_with('\\\\')) {\n+                veto_trim = kind.is_string() && !line.ends_with('\\\\');\n+                trimmed = false;\n+                line\n+            } else {\n+                line.trim().to_owned()\n+            };\n+            trimmed_lines.push((trimmed, line, prefix_space_width));\n+\n+            // When computing the minimum, do not consider lines within a string.\n+            // The reason is there is a veto against trimming and indenting such lines\n+            match kind {\n+                FullCodeCharKind::InString | FullCodeCharKind::EndString => None,\n+                _ => prefix_space_width,\n             }\n         })\n-        .collect::<Vec<String>>()\n-        .concat();\n-    format!(\"{}{}\", first_line, rest)\n+        .min()?;\n+\n+    Some(\n+        first_line\n+            + \"\\n\"\n+            + &trimmed_lines\n+                .iter()\n+                .map(\n+                    |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n+                        _ if !trimmed => line.to_owned(),\n+                        Some(original_indent_width) => {\n+                            let new_indent_width = indent.width()\n+                                + original_indent_width.saturating_sub(min_prefix_space_width);\n+                            let new_indent = Indent::from_width(config, new_indent_width);\n+                            format!(\"{}{}\", new_indent.to_string(config), line)\n+                        }\n+                        None => String::new(),\n+                    },\n+                )\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\"),\n+    )\n+}\n+\n+pub fn is_empty_line(s: &str) -> bool {\n+    s.is_empty() || s.chars().all(char::is_whitespace)\n+}\n+\n+fn get_prefix_space_width(config: &Config, s: &str) -> usize {\n+    let mut width = 0;\n+    for c in s.chars() {\n+        match c {\n+            ' ' => width += 1,\n+            '\\t' => width += config.tab_spaces(),\n+            _ => return width,\n+        }\n+    }\n+    width\n }\n \n-#[test]\n-fn test_remove_trailing_white_spaces() {\n-    let s = \"    r#\\\"\\n        test\\n    \\\"#\";\n-    assert_eq!(remove_trailing_white_spaces(&s), s);\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_remove_trailing_white_spaces() {\n+        let s = \"    r#\\\"\\n        test\\n    \\\"#\";\n+        assert_eq!(remove_trailing_white_spaces(&s), s);\n+    }\n+\n+    #[test]\n+    fn test_trim_left_preserve_layout() {\n+        let s = \"aaa\\n\\tbbb\\n    ccc\";\n+        let config = Config::default();\n+        let indent = Indent::new(4, 0);\n+        assert_eq!(\n+            trim_left_preserve_layout(&s, &indent, &config),\n+            Some(\"aaa\\n    bbb\\n    ccc\".to_string())\n+        );\n+    }\n }"}, {"sha": "a43b83223e23547ffc0b329a50e11bed04e18d4d", "filename": "tests/source/issue-3132.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d718a3fc23fbe9a27c71709c54128b5305609c7/tests%2Fsource%2Fissue-3132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d718a3fc23fbe9a27c71709c54128b5305609c7/tests%2Fsource%2Fissue-3132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3132.rs?ref=2d718a3fc23fbe9a27c71709c54128b5305609c7", "patch": "@@ -0,0 +1,13 @@\n+fn test() {\n+    /*\n+    a\n+\t*/\n+    let x = 42;\n+    /*\n+    aaa\n+    \"line 1\n+  line 2\n+        line 3\"\n+    */\n+    let x = 42;\n+}"}, {"sha": "42388e09f74647ed7928b7e7ff3b65aaa4f5e828", "filename": "tests/target/issue-3132.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d718a3fc23fbe9a27c71709c54128b5305609c7/tests%2Ftarget%2Fissue-3132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d718a3fc23fbe9a27c71709c54128b5305609c7/tests%2Ftarget%2Fissue-3132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3132.rs?ref=2d718a3fc23fbe9a27c71709c54128b5305609c7", "patch": "@@ -0,0 +1,13 @@\n+fn test() {\n+    /*\n+    a\n+    */\n+    let x = 42;\n+    /*\n+      aaa\n+      \"line 1\n+    line 2\n+          line 3\"\n+      */\n+    let x = 42;\n+}"}]}