{"sha": "22d3f669452ed95882e0dd44fab956afa78776be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZDNmNjY5NDUyZWQ5NTg4MmUwZGQ0NGZhYjk1NmFmYTc4Nzc2YmU=", "commit": {"author": {"name": "Bernardo Meurer", "email": "meurerbernardo@gmail.com", "date": "2018-08-22T19:59:14Z"}, "committer": {"name": "Bernardo Meurer", "email": "meurerbernardo@gmail.com", "date": "2018-08-23T15:55:42Z"}, "message": "Fixup long code lines", "tree": {"sha": "eff4dbc38422b0d09e99efd55cada640e9a8ded5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eff4dbc38422b0d09e99efd55cada640e9a8ded5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22d3f669452ed95882e0dd44fab956afa78776be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAABAgAGBQJbftkCAAoJEOQhx0GR6hhsI4YH+wQik8R/YrPgzQDkjnqTIDmI\nlqxVMW6AWhP8U1gFmn3Eyn7bOra4uviZQiQUow3FLXTWK+elBzrpa1WPdVTVwUUU\n2Rh8nCOs4Sf0UJFtcwLw08ajGTbb1aHnGP/UzVkZ0JrPyiw2fKmeyll4QWfg3iCv\nZFN5zbwfilRecI7sjUaFc9dV/U2Whpwvp5UvYpU+07PCMDi8ZXVrcnYfjN2eDiWS\nM3gJRdkGZ5KLaTWwMSJq022oI+WZg4bAOOCqucBVCOIfOSf5yJxYSE75+Syn7KIg\nvPCm1WzXL7DYKThP7H6qmiCFme6UXLOWcDUFJ4X7rulsNln05ZTdRlPtTmttILY=\n=vNx+\n-----END PGP SIGNATURE-----", "payload": "tree eff4dbc38422b0d09e99efd55cada640e9a8ded5\nparent 35f25bfef3012c634a8c255033c9dbdcf268fb41\nauthor Bernardo Meurer <meurerbernardo@gmail.com> 1534967954 -0300\ncommitter Bernardo Meurer <meurerbernardo@gmail.com> 1535039742 -0700\n\nFixup long code lines\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22d3f669452ed95882e0dd44fab956afa78776be", "html_url": "https://github.com/rust-lang/rust/commit/22d3f669452ed95882e0dd44fab956afa78776be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22d3f669452ed95882e0dd44fab956afa78776be/comments", "author": {"login": "lovesegfault", "id": 7243783, "node_id": "MDQ6VXNlcjcyNDM3ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/7243783?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lovesegfault", "html_url": "https://github.com/lovesegfault", "followers_url": "https://api.github.com/users/lovesegfault/followers", "following_url": "https://api.github.com/users/lovesegfault/following{/other_user}", "gists_url": "https://api.github.com/users/lovesegfault/gists{/gist_id}", "starred_url": "https://api.github.com/users/lovesegfault/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lovesegfault/subscriptions", "organizations_url": "https://api.github.com/users/lovesegfault/orgs", "repos_url": "https://api.github.com/users/lovesegfault/repos", "events_url": "https://api.github.com/users/lovesegfault/events{/privacy}", "received_events_url": "https://api.github.com/users/lovesegfault/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lovesegfault", "id": 7243783, "node_id": "MDQ6VXNlcjcyNDM3ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/7243783?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lovesegfault", "html_url": "https://github.com/lovesegfault", "followers_url": "https://api.github.com/users/lovesegfault/followers", "following_url": "https://api.github.com/users/lovesegfault/following{/other_user}", "gists_url": "https://api.github.com/users/lovesegfault/gists{/gist_id}", "starred_url": "https://api.github.com/users/lovesegfault/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lovesegfault/subscriptions", "organizations_url": "https://api.github.com/users/lovesegfault/orgs", "repos_url": "https://api.github.com/users/lovesegfault/repos", "events_url": "https://api.github.com/users/lovesegfault/events{/privacy}", "received_events_url": "https://api.github.com/users/lovesegfault/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35f25bfef3012c634a8c255033c9dbdcf268fb41", "url": "https://api.github.com/repos/rust-lang/rust/commits/35f25bfef3012c634a8c255033c9dbdcf268fb41", "html_url": "https://github.com/rust-lang/rust/commit/35f25bfef3012c634a8c255033c9dbdcf268fb41"}], "stats": {"total": 122, "additions": 91, "deletions": 31}, "files": [{"sha": "373da1d04ff9ded7274c59b6c90c40fa7d4543b1", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -240,7 +240,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n+    fn cast_from_float(\n+        &self,\n+        bits: u128,\n+        fty: FloatTy,\n+        dest_ty: Ty<'tcx>\n+        ) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TyKind::*;\n         use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {"}, {"sha": "fdb1a1596c4dea03fd1f72d7ec69d0e3631e256a", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -280,7 +280,9 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M>\n+where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         *self.tcx\n@@ -340,7 +342,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n         let stack = mem::replace(&mut self.stack, Vec::new());\n-        let steps = mem::replace(&mut self.steps_since_detector_enabled, -STEPS_UNTIL_DETECTOR_ENABLED);\n+        let steps = mem::replace(&mut self.steps_since_detector_enabled,\n+                                 -STEPS_UNTIL_DETECTOR_ENABLED);\n         let r = f(self);\n         self.stack = stack;\n         self.steps_since_detector_enabled = steps;\n@@ -389,7 +392,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n \n-    pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>)\n+        -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n         trace!(\"substs: {:#?}\", self.substs());\n         trace!(\"param_env: {:#?}\", self.param_env);\n@@ -416,7 +420,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n-        if did.is_local() && self.tcx.has_typeck_tables(did) && self.tcx.typeck_tables_of(did).tainted_by_errors {\n+        if did.is_local()\n+            && self.tcx.has_typeck_tables(did)\n+            && self.tcx.typeck_tables_of(did).tainted_by_errors {\n             return err!(TypeckError);\n         }\n         trace!(\"load mir {:?}\", instance);\n@@ -663,7 +669,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         } else {\n             self.param_env\n         };\n-        self.tcx.const_eval(param_env.and(gid)).map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n+        self.tcx.const_eval(param_env.and(gid))\n+            .map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n     }\n \n     #[inline(always)]\n@@ -769,7 +776,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             } else {\n                 last_span = Some(span);\n             }\n-            let location = if self.tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+            let location = if self.tcx.def_key(instance.def_id()).disambiguated_data.data\n+                == DefPathData::ClosureExpr {\n                 \"closure\".to_owned()\n             } else {\n                 instance.to_string()"}, {"sha": "557b1509c69d5811ee6a6df29cf97ce1938b6264", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -241,7 +241,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         };\n \n-        let alloc_kind = self.alloc_kind.remove(&ptr.alloc_id).expect(\"alloc_map out of sync with alloc_kind\");\n+        let alloc_kind = self.alloc_kind\n+                        .remove(&ptr.alloc_id)\n+                        .expect(\"alloc_map out of sync with alloc_kind\");\n \n         // It is okay for us to still holds locks on deallocation -- for example, we could store\n         // data we own in a local, and the local could be deallocated (from StorageDead) before the\n@@ -259,7 +261,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         if let Some((size, align)) = size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n-                return err!(IncorrectAllocationInformation(size, Size::from_bytes(alloc.bytes.len() as u64), align, alloc.align));\n+                let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n+                return err!(IncorrectAllocationInformation(size,\n+                                                           bytes,\n+                                                           align,\n+                                                           alloc.align));\n             }\n         }\n \n@@ -678,7 +684,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     relocations\n                     .iter()\n                     .map(|&(offset, alloc_id)| {\n-                    (offset + dest.offset - src.offset + (i * size * relocations.len() as u64), alloc_id)\n+                    (offset + dest.offset - src.offset + (i * size * relocations.len() as u64),\n+                    alloc_id)\n                     })\n                 );\n             }\n@@ -707,11 +714,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 }\n \n                 for i in 0..length {\n-                    ptr::copy(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                    ptr::copy(src_bytes,\n+                              dest_bytes.offset((size.bytes() * i) as isize),\n+                              size.bytes() as usize);\n                 }\n             } else {\n                 for i in 0..length {\n-                    ptr::copy_nonoverlapping(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                    ptr::copy_nonoverlapping(src_bytes,\n+                                             dest_bytes.offset((size.bytes() * i) as isize),\n+                                             size.bytes() as usize);\n                 }\n             }\n         }\n@@ -778,7 +789,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Read a *non-ZST* scalar\n-    pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+    pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size)\n+        -> EvalResult<'tcx, ScalarMaybeUndef> {\n         // Make sure we don't read part of a pointer as a pointer\n         self.check_relocation_edges(ptr, size)?;\n         let endianness = self.endianness();\n@@ -801,7 +813,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(ScalarMaybeUndef::Scalar(Pointer::new(alloc_id, Size::from_bytes(bits as u64)).into())),\n+                Some(&alloc_id) => {\n+                    let ptr = Pointer::new(alloc_id, Size::from_bytes(bits as u64));\n+                    return Ok(ScalarMaybeUndef::Scalar(ptr.into()))\n+                }\n                 None => {},\n             }\n         }\n@@ -812,7 +827,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }))\n     }\n \n-    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align)\n+        -> EvalResult<'tcx, ScalarMaybeUndef> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n@@ -865,7 +881,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef)\n+        -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n         self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n     }\n@@ -1009,7 +1026,9 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M>;\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M>\n+where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         self\n@@ -1021,7 +1040,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Me\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M>\n+where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         &mut self.memory\n@@ -1033,7 +1054,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Ev\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> layout::HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M>\n+where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout"}, {"sha": "89293dc10123269280a1967ea7432024ce933e1e", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -68,7 +68,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout::Abi::Scalar(ref scalar) => scalar.value,\n             _ => return err!(TypeNotPrimitive(right_layout.ty)),\n         };\n-        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+        bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n         if !left_kind.is_float() && !right_kind.is_float() {"}, {"sha": "17ace26ed8a535413ffa857727bad9924ed25fa2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -287,11 +287,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 offsets[usize::try_from(field).unwrap()],\n             layout::FieldPlacement::Array { stride, .. } => {\n                 let len = base.len();\n-                assert!(field < len, \"Tried to access element {} of array/slice with length {}\", field, len);\n+                assert!(field < len,\n+                        \"Tried to access element {} of array/slice with length {}\", field, len);\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {\n-                assert!(field < count as u64, \"Tried to access field {} of union with {} fields\", field, count);\n+                assert!(field < count as u64,\n+                        \"Tried to access field {} of union with {} fields\", field, count);\n                 // Offset is always 0\n                 Size::from_bytes(0)\n             }\n@@ -604,7 +606,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Value::ScalarPair(a_val, b_val) => {\n                 let (a, b) = match dest.layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_value_to_mplace: invalid ScalarPair layout: {:#?}\", dest.layout)\n+                    _ => bug!(\"write_value_to_mplace: invalid ScalarPair layout: {:#?}\",\n+                              dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n                 let (a_align, b_align) = (a.align(&self), b.align(&self));\n@@ -770,7 +773,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Turn a place that is a dyn trait (i.e., PlaceExtra::Vtable and the appropriate layout)\n     /// or a slice into the specific fixed-size place and layout that is given by the vtable/len.\n     /// This \"unpacks\" the existential quantifier, so to speak.\n-    pub fn unpack_unsized_mplace(&self, mplace: MPlaceTy<'tcx>) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    pub fn unpack_unsized_mplace(&self, mplace: MPlaceTy<'tcx>)\n+        -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         trace!(\"Unpacking {:?} ({:?})\", *mplace, mplace.layout.ty);\n         let layout = match mplace.extra {\n             PlaceExtra::Vtable(vtable) => {"}, {"sha": "782c033e2df06f1b3d31f4d073d12c657dd40f99", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -55,7 +55,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op\n-                    let const_int = Scalar::Bits { bits: const_int, size: discr.layout.size.bytes() as u8 };\n+                    let const_int = Scalar::Bits {\n+                        bits: const_int,\n+                        size: discr.layout.size.bytes() as u8\n+                    };\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n                         discr,\n                         ValTy { value: Value::Scalar(const_int.into()), layout: discr.layout }\n@@ -154,7 +157,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.eval_operand_and_read_value(cond, None)?.to_scalar()?.to_bool()?;\n+                let cond_val = self.eval_operand_and_read_value(cond, None)?\n+                    .to_scalar()?\n+                    .to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n@@ -239,15 +244,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // We need to allow what comes up when a non-capturing closure is cast to a fn().\n         match (sig.abi, real_sig.abi) {\n             (Abi::Rust, Abi::RustCall) // check the ABIs.  This makes the test here non-symmetric.\n-                if check_ty_compat(sig.output(), real_sig.output()) && real_sig.inputs_and_output.len() == 3 => {\n+                if check_ty_compat(sig.output(), real_sig.output())\n+                    && real_sig.inputs_and_output.len() == 3 => {\n                 // First argument of real_sig must be a ZST\n                 let fst_ty = real_sig.inputs_and_output[0];\n                 if self.layout_of(fst_ty)?.is_zst() {\n                     // Second argument must be a tuple matching the argument list of sig\n                     let snd_ty = real_sig.inputs_and_output[1];\n                     match snd_ty.sty {\n+<<<<<<< HEAD\n                         ty::Tuple(tys) if sig.inputs().len() == tys.len() =>\n                             if sig.inputs().iter().zip(tys).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+=======\n+                        ty::TyTuple(tys) if sig.inputs().len() == tys.len() =>\n+                            if sig.inputs()\n+                                  .iter()\n+                                  .zip(tys)\n+                                  .all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+>>>>>>> 7d30ba9... Fixup long code lines\n                                 return Ok(true)\n                             },\n                         _ => {}\n@@ -304,7 +318,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         trace!(\n                             \"args: {:#?}\",\n                             self.frame().mir.args_iter().zip(args.iter())\n-                                .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n+                                .map(|(local, arg)| (local, **arg, arg.layout.ty))\n+                                .collect::<Vec<_>>()\n                         );\n                         let local = arg_locals.nth(1).unwrap();\n                         for (i, &op) in args.into_iter().enumerate() {\n@@ -325,7 +340,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::Item(_) => {\n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n                 if M::eval_fn_call(self, instance, destination, args, span)? {\n-                    // TODO: Can we make it return the frame to push, instead\n+                    // FIXME: Can we make it return the frame to push, instead\n                     // of the hook doing half of the work and us doing the argument\n                     // initialization?\n                     return Ok(());"}, {"sha": "4ce0563749ac6963f203e1cb5b3e8a46a9283cbe", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -92,7 +92,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n+            .to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align"}, {"sha": "b0dfceb259746b38a5b44ac7d8a33b8232662c7a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d3f669452ed95882e0dd44fab956afa78776be/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=22d3f669452ed95882e0dd44fab956afa78776be", "patch": "@@ -221,7 +221,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let variant = self.read_discriminant_as_variant_index(dest.into())?;\n                 let inner_dest = self.mplace_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n-                path.push(PathElem::Field(dest.layout.ty.ty_adt_def().unwrap().variants[variant].name));\n+                path.push(PathElem::Field(dest.layout.ty\n+                                          .ty_adt_def()\n+                                          .unwrap()\n+                                          .variants[variant].name));\n                 trace!(\"variant layout: {:#?}\", dest.layout);\n                 (variant, inner_dest)\n             },"}]}