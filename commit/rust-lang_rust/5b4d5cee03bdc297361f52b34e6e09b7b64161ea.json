{"sha": "5b4d5cee03bdc297361f52b34e6e09b7b64161ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNGQ1Y2VlMDNiZGMyOTczNjFmNTJiMzRlNmUwOWI3YjY0MTYxZWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-31T22:10:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-31T22:14:15Z"}, "message": "rustc: Make entire crates privileged scopes for the purposes of coherence", "tree": {"sha": "5e6c50f12a67f5c2c3bd863b0ecd164e90ace9fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e6c50f12a67f5c2c3bd863b0ecd164e90ace9fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b4d5cee03bdc297361f52b34e6e09b7b64161ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4d5cee03bdc297361f52b34e6e09b7b64161ea", "html_url": "https://github.com/rust-lang/rust/commit/5b4d5cee03bdc297361f52b34e6e09b7b64161ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b4d5cee03bdc297361f52b34e6e09b7b64161ea/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b554c1e0c46efcf0e55994fcd8fbc0c17b9c119", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b554c1e0c46efcf0e55994fcd8fbc0c17b9c119", "html_url": "https://github.com/rust-lang/rust/commit/3b554c1e0c46efcf0e55994fcd8fbc0c17b9c119"}], "stats": {"total": 64, "additions": 9, "deletions": 55}, "files": [{"sha": "e8f4c2b5f0de9dd3b827966cb677c6bb421c9983", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 55, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5b4d5cee03bdc297361f52b34e6e09b7b64161ea/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4d5cee03bdc297361f52b34e6e09b7b64161ea/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=5b4d5cee03bdc297361f52b34e6e09b7b64161ea", "patch": "@@ -147,18 +147,12 @@ struct CoherenceChecker {\n \n     let privileged_implementations: hashmap<node_id,()>;\n \n-    // The set of types that we are currently in the privileged scope of. This\n-    // is used while we traverse the AST while checking privileged scopes.\n-\n-    let privileged_types: hashmap<def_id,()>;\n-\n     new(crate_context: @crate_ctxt) {\n         self.crate_context = crate_context;\n         self.inference_context = new_infer_ctxt(crate_context.tcx);\n \n         self.base_type_def_ids = new_def_hash();\n         self.privileged_implementations = int_hash();\n-        self.privileged_types = new_def_hash();\n     }\n \n     // Create a mapping containing a MethodInfo for every provided\n@@ -427,36 +421,12 @@ struct CoherenceChecker {\n \n     // Privileged scope checking\n     fn check_privileged_scopes(crate: @crate) {\n-        // Gather up all privileged types.\n-        let privileged_types =\n-            self.gather_privileged_types(crate.node.module.items);\n-        for privileged_types.each |privileged_type| {\n-            self.privileged_types.insert(privileged_type, ());\n-        }\n-\n         visit_crate(*crate, (), mk_vt(@{\n             visit_item: |item, _context, visitor| {\n                 match item.node {\n                     item_mod(module_) => {\n-                        // First, gather up all privileged types.\n-                        let privileged_types =\n-                            self.gather_privileged_types(module_.items);\n-                        for privileged_types.each |privileged_type| {\n-                            debug!(\"(checking privileged scopes) entering \\\n-                                    privileged scope of %d:%d\",\n-                                   privileged_type.crate,\n-                                   privileged_type.node);\n-\n-                            self.privileged_types.insert(privileged_type, ());\n-                        }\n-\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, (), visitor);\n-\n-                        // Finally, remove privileged types from the map.\n-                        for privileged_types.each |privileged_type| {\n-                            self.privileged_types.remove(privileged_type);\n-                        }\n                     }\n                     item_impl(_, associated_traits, _, _) => {\n                         match self.base_type_def_ids.find(\n@@ -467,12 +437,9 @@ struct CoherenceChecker {\n                             }\n                             Some(base_type_def_id) => {\n                                 // Check to see whether the implementation is\n-                                // in the scope of its base type.\n-\n-                                let privileged_types = &self.privileged_types;\n-                                if privileged_types.\n-                                        contains_key(base_type_def_id) {\n+                                // in the same crate as its base type.\n \n+                                if base_type_def_id.crate == local_crate {\n                                     // Record that this implementation is OK.\n                                     self.privileged_implementations.insert\n                                         (item.id, ());\n@@ -492,7 +459,7 @@ struct CoherenceChecker {\n                                                          ~\"cannot implement \\\n                                                           inherent methods \\\n                                                           for a type outside \\\n-                                                          the scope the type \\\n+                                                          the crate the type \\\n                                                           was defined in; \\\n                                                           define and \\\n                                                           implement a trait \\\n@@ -546,25 +513,6 @@ struct CoherenceChecker {\n         return trait_id;\n     }\n \n-    fn gather_privileged_types(items: ~[@item]) -> @DVec<def_id> {\n-        let results = @DVec();\n-        for items.each |item| {\n-            match item.node {\n-                item_class(*) | item_enum(*) | item_trait(*) => {\n-                    results.push(local_def(item.id));\n-                }\n-\n-                item_const(*) | item_fn(*) | item_mod(*) |\n-                item_foreign_mod(*) | item_ty(*) | item_impl(*) |\n-                item_mac(*) => {\n-                    // Nothing to do.\n-                }\n-            }\n-        }\n-\n-        return results;\n-    }\n-\n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(item: @item) -> @Impl {\n "}, {"sha": "fb8b37ce2cd8275f4051acb4efa784330f4d37b0", "filename": "src/test/run-pass/coherence-impl-in-fn.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b4d5cee03bdc297361f52b34e6e09b7b64161ea/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4d5cee03bdc297361f52b34e6e09b7b64161ea/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs?ref=5b4d5cee03bdc297361f52b34e6e09b7b64161ea", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    enum x { foo }\n+    impl x : core::cmp::Eq {\n+        pure fn eq(&&other: x) -> bool { self as int == other as int }\n+    }\n+}"}]}