{"sha": "47d7434dde215460fc95916f2703c6925f58dcce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDc0MzRkZGUyMTU0NjBmYzk1OTE2ZjI3MDNjNjkyNWY1OGRjY2U=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-18T11:42:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-22T12:27:32Z"}, "message": "internal: replace AstTransformer with mutable syntax trees", "tree": {"sha": "2eb017e9a32da4fb6f729b6b9c617c2516dafc40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eb017e9a32da4fb6f729b6b9c617c2516dafc40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d7434dde215460fc95916f2703c6925f58dcce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d7434dde215460fc95916f2703c6925f58dcce", "html_url": "https://github.com/rust-lang/rust/commit/47d7434dde215460fc95916f2703c6925f58dcce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d7434dde215460fc95916f2703c6925f58dcce/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cfe2d0a5d663d29c3d196f9d16e91964780792a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfe2d0a5d663d29c3d196f9d16e91964780792a", "html_url": "https://github.com/rust-lang/rust/commit/3cfe2d0a5d663d29c3d196f9d16e91964780792a"}], "stats": {"total": 331, "additions": 123, "deletions": 208}, "files": [{"sha": "5d9cc55516ea2ae11ac0dbb8c786ab3b689e200a", "filename": "crates/ide_assists/src/ast_transform.rs", "status": "modified", "additions": 91, "deletions": 145, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fast_transform.rs?ref=47d7434dde215460fc95916f2703c6925f58dcce", "patch": "@@ -1,31 +1,12 @@\n //! `AstTransformer`s are functions that replace nodes in an AST and can be easily combined.\n-use hir::{HirDisplay, PathResolution, SemanticsScope};\n+use hir::{HirDisplay, SemanticsScope};\n use ide_db::helpers::mod_path_to_ast;\n use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstNode},\n-    ted, SyntaxNode,\n+    ted,\n };\n \n-pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: &N) {\n-    let mut skip_to = None;\n-    for event in node.syntax().preorder() {\n-        match event {\n-            syntax::WalkEvent::Enter(node) if skip_to.is_none() => {\n-                skip_to = transformer.get_substitution(&node, transformer).zip(Some(node));\n-            }\n-            syntax::WalkEvent::Enter(_) => (),\n-            syntax::WalkEvent::Leave(node) => match &skip_to {\n-                Some((replacement, skip_target)) if *skip_target == node => {\n-                    ted::replace(node, replacement.clone_for_update());\n-                    skip_to.take();\n-                }\n-                _ => (),\n-            },\n-        }\n-    }\n-}\n-\n /// `AstTransform` helps with applying bulk transformations to syntax nodes.\n ///\n /// This is mostly useful for IDE code generation. If you paste some existing\n@@ -35,8 +16,8 @@ pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: &N) {\n ///\n /// ```\n /// mod x {\n-///   pub struct A;\n-///   pub trait T<U> { fn foo(&self, _: U) -> A; }\n+///   pub struct A<V>;\n+///   pub trait T<U> { fn foo(&self, _: U) -> A<U>; }\n /// }\n ///\n /// mod y {\n@@ -45,7 +26,7 @@ pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: &N) {\n ///   impl T<()> for () {\n ///      // If we invoke **Add Missing Members** here, we want to copy-paste `foo`.\n ///      // But we want a slightly-modified version of it:\n-///      fn foo(&self, _: ()) -> x::A {}\n+///      fn foo(&self, _: ()) -> x::A<()> {}\n ///   }\n /// }\n /// ```\n@@ -54,49 +35,27 @@ pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: &N) {\n /// `SyntaxNode`. Note that the API here is a bit too high-order and high-brow.\n /// We'd want to somehow express this concept simpler, but so far nobody got to\n /// simplifying this!\n-pub trait AstTransform<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode>;\n-\n-    fn or<T: AstTransform<'a> + 'a>(self, other: T) -> Box<dyn AstTransform<'a> + 'a>\n-    where\n-        Self: Sized + 'a,\n-    {\n-        Box::new(Or(Box::new(self), Box::new(other)))\n-    }\n+pub(crate) struct AstTransform<'a> {\n+    pub(crate) subst: (hir::Trait, ast::Impl),\n+    pub(crate) target_scope: &'a SemanticsScope<'a>,\n+    pub(crate) source_scope: &'a SemanticsScope<'a>,\n }\n \n-struct Or<'a>(Box<dyn AstTransform<'a> + 'a>, Box<dyn AstTransform<'a> + 'a>);\n-\n-impl<'a> AstTransform<'a> for Or<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode> {\n-        self.0.get_substitution(node, recur).or_else(|| self.1.get_substitution(node, recur))\n+impl<'a> AstTransform<'a> {\n+    pub(crate) fn apply(&self, item: ast::AssocItem) {\n+        if let Some(ctx) = self.build_ctx() {\n+            ctx.apply(item)\n+        }\n     }\n-}\n-\n-pub struct SubstituteTypeParams<'a> {\n-    source_scope: &'a SemanticsScope<'a>,\n-    substs: FxHashMap<hir::TypeParam, ast::Type>,\n-}\n+    fn build_ctx(&self) -> Option<Ctx<'a>> {\n+        let db = self.source_scope.db;\n+        let target_module = self.target_scope.module()?;\n+        let source_module = self.source_scope.module()?;\n \n-impl<'a> SubstituteTypeParams<'a> {\n-    pub fn for_trait_impl(\n-        source_scope: &'a SemanticsScope<'a>,\n-        // FIXME: there's implicit invariant that `trait_` and  `source_scope` match...\n-        trait_: hir::Trait,\n-        impl_def: ast::Impl,\n-    ) -> SubstituteTypeParams<'a> {\n-        let substs = get_syntactic_substs(impl_def).unwrap_or_default();\n-        let generic_def: hir::GenericDef = trait_.into();\n+        let substs = get_syntactic_substs(self.subst.1.clone()).unwrap_or_default();\n+        let generic_def: hir::GenericDef = self.subst.0.into();\n         let substs_by_param: FxHashMap<_, _> = generic_def\n-            .type_params(source_scope.db)\n+            .type_params(db)\n             .into_iter()\n             // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n             .skip(1)\n@@ -110,109 +69,96 @@ impl<'a> SubstituteTypeParams<'a> {\n             .filter_map(|(k, v)| match v {\n                 Some(v) => Some((k, v)),\n                 None => {\n-                    let default = k.default(source_scope.db)?;\n+                    let default = k.default(db)?;\n                     Some((\n                         k,\n-                        ast::make::ty(\n-                            &default\n-                                .display_source_code(source_scope.db, source_scope.module()?.into())\n-                                .ok()?,\n-                        ),\n+                        ast::make::ty(&default.display_source_code(db, source_module.into()).ok()?),\n                     ))\n                 }\n             })\n             .collect();\n-        return SubstituteTypeParams { source_scope, substs: substs_by_param };\n-\n-        // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n-        // trait ref, and then go from the types in the substs back to the syntax).\n-        fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n-            let target_trait = impl_def.trait_()?;\n-            let path_type = match target_trait {\n-                ast::Type::PathType(path) => path,\n-                _ => return None,\n-            };\n-            let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n-\n-            let mut result = Vec::new();\n-            for generic_arg in generic_arg_list.generic_args() {\n-                match generic_arg {\n-                    ast::GenericArg::TypeArg(type_arg) => result.push(type_arg.ty()?),\n-                    ast::GenericArg::AssocTypeArg(_)\n-                    | ast::GenericArg::LifetimeArg(_)\n-                    | ast::GenericArg::ConstArg(_) => (),\n-                }\n-            }\n \n-            Some(result)\n-        }\n+        let res = Ctx { substs: substs_by_param, target_module, source_scope: self.source_scope };\n+        Some(res)\n     }\n }\n \n-impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        _recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode> {\n-        let type_ref = ast::Type::cast(node.clone())?;\n-        let path = match &type_ref {\n-            ast::Type::PathType(path_type) => path_type.path()?,\n-            _ => return None,\n-        };\n-        let resolution = self.source_scope.speculative_resolve(&path)?;\n-        match resolution {\n-            hir::PathResolution::TypeParam(tp) => Some(self.substs.get(&tp)?.syntax().clone()),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-pub struct QualifyPaths<'a> {\n-    target_scope: &'a SemanticsScope<'a>,\n+struct Ctx<'a> {\n+    substs: FxHashMap<hir::TypeParam, ast::Type>,\n+    target_module: hir::Module,\n     source_scope: &'a SemanticsScope<'a>,\n }\n \n-impl<'a> QualifyPaths<'a> {\n-    pub fn new(target_scope: &'a SemanticsScope<'a>, source_scope: &'a SemanticsScope<'a>) -> Self {\n-        Self { target_scope, source_scope }\n+impl<'a> Ctx<'a> {\n+    fn apply(&self, item: ast::AssocItem) {\n+        for event in item.syntax().preorder() {\n+            let node = match event {\n+                syntax::WalkEvent::Enter(_) => continue,\n+                syntax::WalkEvent::Leave(it) => it,\n+            };\n+            if let Some(path) = ast::Path::cast(node.clone()) {\n+                self.transform_path(path);\n+            }\n+        }\n     }\n-}\n-\n-impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode> {\n-        // FIXME handle value ns?\n-        let from = self.target_scope.module()?;\n-        let p = ast::Path::cast(node.clone())?;\n-        if p.segment().and_then(|s| s.param_list()).is_some() {\n+    fn transform_path(&self, path: ast::Path) -> Option<()> {\n+        if path.qualifier().is_some() {\n+            return None;\n+        }\n+        if path.segment().and_then(|s| s.param_list()).is_some() {\n             // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n             return None;\n         }\n-        let resolution = self.source_scope.speculative_resolve(&p)?;\n-        match resolution {\n-            PathResolution::Def(def) => {\n-                let found_path = from.find_use_path(self.source_scope.db.upcast(), def)?;\n-                let mut path = mod_path_to_ast(&found_path);\n \n-                let type_args = p.segment().and_then(|s| s.generic_arg_list());\n-                if let Some(type_args) = type_args {\n-                    apply(recur, &type_args);\n-                    let last_segment = path.segment().unwrap();\n-                    path = path.with_segment(last_segment.with_generic_args(type_args))\n-                }\n+        let resolution = self.source_scope.speculative_resolve(&path)?;\n \n-                Some(path.syntax().clone())\n+        match resolution {\n+            hir::PathResolution::TypeParam(tp) => {\n+                if let Some(subst) = self.substs.get(&tp) {\n+                    ted::replace(path.syntax(), subst.clone_subtree().clone_for_update().syntax())\n+                }\n+            }\n+            hir::PathResolution::Def(def) => {\n+                let found_path =\n+                    self.target_module.find_use_path(self.source_scope.db.upcast(), def)?;\n+                let res = mod_path_to_ast(&found_path).clone_for_update();\n+                if let Some(args) = path.segment().and_then(|it| it.generic_arg_list()) {\n+                    if let Some(segment) = res.segment() {\n+                        let old = segment.get_or_create_generic_arg_list();\n+                        ted::replace(old.syntax(), args.clone_subtree().syntax().clone_for_update())\n+                    }\n+                }\n+                ted::replace(path.syntax(), res.syntax())\n             }\n-            PathResolution::Local(_)\n-            | PathResolution::TypeParam(_)\n-            | PathResolution::SelfType(_)\n-            | PathResolution::ConstParam(_) => None,\n-            PathResolution::Macro(_) => None,\n-            PathResolution::AssocItem(_) => None,\n+            hir::PathResolution::Local(_)\n+            | hir::PathResolution::ConstParam(_)\n+            | hir::PathResolution::SelfType(_)\n+            | hir::PathResolution::Macro(_)\n+            | hir::PathResolution::AssocItem(_) => (),\n         }\n+        Some(())\n     }\n }\n+\n+// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n+// trait ref, and then go from the types in the substs back to the syntax).\n+fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n+    let target_trait = impl_def.trait_()?;\n+    let path_type = match target_trait {\n+        ast::Type::PathType(path) => path,\n+        _ => return None,\n+    };\n+    let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n+\n+    let mut result = Vec::new();\n+    for generic_arg in generic_arg_list.generic_args() {\n+        match generic_arg {\n+            ast::GenericArg::TypeArg(type_arg) => result.push(type_arg.ty()?),\n+            ast::GenericArg::AssocTypeArg(_)\n+            | ast::GenericArg::LifetimeArg(_)\n+            | ast::GenericArg::ConstArg(_) => (),\n+        }\n+    }\n+\n+    Some(result)\n+}"}, {"sha": "2e79a3aed3172362284276cad9de827bdefacd0c", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=47d7434dde215460fc95916f2703c6925f58dcce", "patch": "@@ -24,7 +24,7 @@ use syntax::{\n \n use crate::{\n     assist_context::{AssistBuilder, AssistContext},\n-    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+    ast_transform::AstTransform,\n };\n \n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n@@ -132,14 +132,18 @@ pub fn add_trait_assoc_items_to_impl(\n     target_scope: hir::SemanticsScope,\n ) -> (ast::Impl, ast::AssocItem) {\n     let source_scope = sema.scope_for_def(trait_);\n-    let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n-        .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_.clone()));\n-\n-    let items = items\n-        .into_iter()\n-        .map(|it| it.clone_for_update())\n-        .inspect(|it| ast_transform::apply(&*ast_transform, it))\n-        .map(|it| edit::remove_attrs_and_docs(&it).clone_subtree().clone_for_update());\n+\n+    let transform = AstTransform {\n+        subst: (trait_, impl_.clone()),\n+        source_scope: &source_scope,\n+        target_scope: &target_scope,\n+    };\n+\n+    let items = items.into_iter().map(|assoc_item| {\n+        let assoc_item = assoc_item.clone_for_update();\n+        transform.apply(assoc_item.clone());\n+        edit::remove_attrs_and_docs(&assoc_item).clone_subtree().clone_for_update()\n+    });\n \n     let res = impl_.clone_for_update();\n "}, {"sha": "19107ee3812d4c1c585afc1ff69e9ae86e7765ab", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=47d7434dde215460fc95916f2703c6925f58dcce", "patch": "@@ -6,14 +6,12 @@ use std::{\n     ops::{self, RangeInclusive},\n };\n \n-use arrayvec::ArrayVec;\n-\n use crate::{\n     algo,\n     ast::{self, make, AstNode},\n-    ted, AstToken, InsertPosition, NodeOrToken, SyntaxElement, SyntaxKind,\n+    ted, AstToken, NodeOrToken, SyntaxElement, SyntaxKind,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n-    SyntaxNode, SyntaxToken, T,\n+    SyntaxNode, SyntaxToken,\n };\n \n impl ast::BinExpr {\n@@ -25,46 +23,6 @@ impl ast::BinExpr {\n     }\n }\n \n-impl ast::Path {\n-    #[must_use]\n-    pub fn with_segment(&self, segment: ast::PathSegment) -> ast::Path {\n-        if let Some(old) = self.segment() {\n-            return self.replace_children(\n-                single_node(old.syntax().clone()),\n-                iter::once(segment.syntax().clone().into()),\n-            );\n-        }\n-        self.clone()\n-    }\n-}\n-\n-impl ast::PathSegment {\n-    #[must_use]\n-    pub fn with_generic_args(&self, type_args: ast::GenericArgList) -> ast::PathSegment {\n-        self._with_generic_args(type_args, false)\n-    }\n-\n-    #[must_use]\n-    pub fn with_turbo_fish(&self, type_args: ast::GenericArgList) -> ast::PathSegment {\n-        self._with_generic_args(type_args, true)\n-    }\n-\n-    fn _with_generic_args(&self, type_args: ast::GenericArgList, turbo: bool) -> ast::PathSegment {\n-        if let Some(old) = self.generic_arg_list() {\n-            return self.replace_children(\n-                single_node(old.syntax().clone()),\n-                iter::once(type_args.syntax().clone().into()),\n-            );\n-        }\n-        let mut to_insert: ArrayVec<SyntaxElement, 2> = ArrayVec::new();\n-        if turbo {\n-            to_insert.push(make::token(T![::]).into());\n-        }\n-        to_insert.push(type_args.syntax().clone().into());\n-        self.insert_children(InsertPosition::Last, to_insert)\n-    }\n-}\n-\n impl ast::UseTree {\n     /// Splits off the given prefix, making it the path component of the use tree, appending the rest of the path to all UseTreeList items.\n     #[must_use]\n@@ -233,16 +191,6 @@ fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n }\n \n pub trait AstNodeEdit: AstNode + Clone + Sized {\n-    #[must_use]\n-    fn insert_children(\n-        &self,\n-        position: InsertPosition<SyntaxElement>,\n-        to_insert: impl IntoIterator<Item = SyntaxElement>,\n-    ) -> Self {\n-        let new_syntax = algo::insert_children(self.syntax(), position, to_insert);\n-        Self::cast(new_syntax).unwrap()\n-    }\n-\n     #[must_use]\n     fn replace_children(\n         &self,"}, {"sha": "ca8103668b8c474fd76bf73636aceb94afff9f33", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=47d7434dde215460fc95916f2703c6925f58dcce", "patch": "@@ -239,6 +239,16 @@ impl ast::TypeBoundList {\n     }\n }\n \n+impl ast::PathSegment {\n+    pub fn get_or_create_generic_arg_list(&self) -> ast::GenericArgList {\n+        if self.generic_arg_list().is_none() {\n+            let arg_list = make::generic_arg_list().clone_for_update();\n+            ted::append_child(self.syntax(), arg_list.syntax())\n+        }\n+        self.generic_arg_list().unwrap()\n+    }\n+}\n+\n impl ast::UseTree {\n     pub fn remove(&self) {\n         for &dir in [Direction::Next, Direction::Prev].iter() {"}, {"sha": "0cf17062610996e5079b39d9c38e255215cd623e", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=47d7434dde215460fc95916f2703c6925f58dcce", "patch": "@@ -106,6 +106,10 @@ pub fn impl_trait(trait_: ast::Path, ty: ast::Path) -> ast::Impl {\n     ast_from_text(&format!(\"impl {} for {} {{}}\", trait_, ty))\n }\n \n+pub(crate) fn generic_arg_list() -> ast::GenericArgList {\n+    ast_from_text(\"const S: T<> = ();\")\n+}\n+\n pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n     ast_from_text(&format!(\"use {};\", name_ref))\n }"}, {"sha": "ae970f44f16a02368dedc75dfa928a3a13072d73", "filename": "crates/syntax/src/ted.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d7434dde215460fc95916f2703c6925f58dcce/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=47d7434dde215460fc95916f2703c6925f58dcce", "patch": "@@ -184,6 +184,9 @@ fn ws_between(left: &SyntaxElement, right: &SyntaxElement) -> Option<SyntaxToken\n     if left.kind() == T![&] && right.kind() == SyntaxKind::LIFETIME {\n         return None;\n     }\n+    if right.kind() == SyntaxKind::GENERIC_ARG_LIST {\n+        return None;\n+    }\n \n     if right.kind() == SyntaxKind::USE {\n         let mut indent = IndentLevel::from_element(left);"}]}