{"sha": "e6457bb67678c719d610e8f27f827c2e1ea56111", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NDU3YmI2NzY3OGM3MTlkNjEwZThmMjdmODI3YzJlMWVhNTYxMTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-21T19:11:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-10-01T19:28:17Z"}, "message": "std: Move platform specific path code into sys", "tree": {"sha": "8ea186fc56426f7d52a1c3169cf557473d138ffe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ea186fc56426f7d52a1c3169cf557473d138ffe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6457bb67678c719d610e8f27f827c2e1ea56111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6457bb67678c719d610e8f27f827c2e1ea56111", "html_url": "https://github.com/rust-lang/rust/commit/e6457bb67678c719d610e8f27f827c2e1ea56111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6457bb67678c719d610e8f27f827c2e1ea56111/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df9fa1a51e9e9570c30b98be2409964313f5d607", "url": "https://api.github.com/repos/rust-lang/rust/commits/df9fa1a51e9e9570c30b98be2409964313f5d607", "html_url": "https://github.com/rust-lang/rust/commit/df9fa1a51e9e9570c30b98be2409964313f5d607"}], "stats": {"total": 267, "additions": 141, "deletions": 126}, "files": [{"sha": "fdc1978b0c5012bd5be5edf1c86300b5f996525e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 126, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=e6457bb67678c719d610e8f27f827c2e1ea56111", "patch": "@@ -113,7 +113,7 @@ use ops::{self, Deref};\n \n use ffi::{OsStr, OsString};\n \n-use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n+use sys::path::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n \n ////////////////////////////////////////////////////////////////////////////////\n // GENERAL NOTES\n@@ -125,130 +125,6 @@ use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n // OsStr APIs for parsing, but it will take a while for those to become\n // available.\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Platform-specific definitions\n-////////////////////////////////////////////////////////////////////////////////\n-\n-// The following modules give the most basic tools for parsing paths on various\n-// platforms. The bulk of the code is devoted to parsing prefixes on Windows.\n-\n-#[cfg(unix)]\n-mod platform {\n-    use super::Prefix;\n-    use ffi::OsStr;\n-\n-    #[inline]\n-    pub fn is_sep_byte(b: u8) -> bool {\n-        b == b'/'\n-    }\n-\n-    #[inline]\n-    pub fn is_verbatim_sep(b: u8) -> bool {\n-        b == b'/'\n-    }\n-\n-    pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n-        None\n-    }\n-\n-    pub const MAIN_SEP_STR: &'static str = \"/\";\n-    pub const MAIN_SEP: char = '/';\n-}\n-\n-#[cfg(windows)]\n-mod platform {\n-    use ascii::*;\n-\n-    use super::{os_str_as_u8_slice, u8_slice_as_os_str, Prefix};\n-    use ffi::OsStr;\n-\n-    #[inline]\n-    pub fn is_sep_byte(b: u8) -> bool {\n-        b == b'/' || b == b'\\\\'\n-    }\n-\n-    #[inline]\n-    pub fn is_verbatim_sep(b: u8) -> bool {\n-        b == b'\\\\'\n-    }\n-\n-    pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n-        use super::Prefix::*;\n-        unsafe {\n-            // The unsafety here stems from converting between &OsStr and &[u8]\n-            // and back. This is safe to do because (1) we only look at ASCII\n-            // contents of the encoding and (2) new &OsStr values are produced\n-            // only from ASCII-bounded slices of existing &OsStr values.\n-            let mut path = os_str_as_u8_slice(path);\n-\n-            if path.starts_with(br\"\\\\\") {\n-                // \\\\\n-                path = &path[2..];\n-                if path.starts_with(br\"?\\\") {\n-                    // \\\\?\\\n-                    path = &path[2..];\n-                    if path.starts_with(br\"UNC\\\") {\n-                        // \\\\?\\UNC\\server\\share\n-                        path = &path[4..];\n-                        let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n-                            Some((server, share)) =>\n-                                (u8_slice_as_os_str(server), u8_slice_as_os_str(share)),\n-                            None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n-                        };\n-                        return Some(VerbatimUNC(server, share));\n-                    } else {\n-                        // \\\\?\\path\n-                        let idx = path.iter().position(|&b| b == b'\\\\');\n-                        if idx == Some(2) && path[1] == b':' {\n-                            let c = path[0];\n-                            if c.is_ascii() && (c as char).is_alphabetic() {\n-                                // \\\\?\\C:\\ path\n-                                return Some(VerbatimDisk(c.to_ascii_uppercase()));\n-                            }\n-                        }\n-                        let slice = &path[..idx.unwrap_or(path.len())];\n-                        return Some(Verbatim(u8_slice_as_os_str(slice)));\n-                    }\n-                } else if path.starts_with(b\".\\\\\") {\n-                    // \\\\.\\path\n-                    path = &path[2..];\n-                    let pos = path.iter().position(|&b| b == b'\\\\');\n-                    let slice = &path[..pos.unwrap_or(path.len())];\n-                    return Some(DeviceNS(u8_slice_as_os_str(slice)));\n-                }\n-                match parse_two_comps(path, is_sep_byte) {\n-                    Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n-                        // \\\\server\\share\n-                        return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n-                    }\n-                    _ => (),\n-                }\n-            } else if path.get(1) == Some(& b':') {\n-                // C:\n-                let c = path[0];\n-                if c.is_ascii() && (c as char).is_alphabetic() {\n-                    return Some(Disk(c.to_ascii_uppercase()));\n-                }\n-            }\n-            return None;\n-        }\n-\n-        fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n-            let first = match path.iter().position(|x| f(*x)) {\n-                None => return None,\n-                Some(x) => &path[..x],\n-            };\n-            path = &path[(first.len() + 1)..];\n-            let idx = path.iter().position(|x| f(*x));\n-            let second = &path[..idx.unwrap_or(path.len())];\n-            Some((first, second))\n-        }\n-    }\n-\n-    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n-    pub const MAIN_SEP: char = '\\\\';\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Windows Prefixes\n ////////////////////////////////////////////////////////////////////////////////\n@@ -373,7 +249,7 @@ pub fn is_separator(c: char) -> bool {\n \n /// The primary separator for the current platform\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAIN_SEPARATOR: char = platform::MAIN_SEP;\n+pub const MAIN_SEPARATOR: char = ::sys::path::MAIN_SEP;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Misc helpers"}, {"sha": "e61944315a0fc4659988db0950dd3edcf498eaee", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=e6457bb67678c719d610e8f27f827c2e1ea56111", "patch": "@@ -41,6 +41,7 @@ pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n+pub mod path;\n pub mod pipe;\n pub mod process;\n pub mod rand;"}, {"sha": "bf9af7a4353a89b67992cf63ff18709db4e48086", "filename": "src/libstd/sys/unix/path.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpath.rs?ref=e6457bb67678c719d610e8f27f827c2e1ea56111", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "21404f4fbebc343f8063e10946c72efd86027e59", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=e6457bb67678c719d610e8f27f827c2e1ea56111", "patch": "@@ -29,6 +29,7 @@ pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n+pub mod path;\n pub mod pipe;\n pub mod process;\n pub mod rand;"}, {"sha": "2b47808451bc29ed7b629e76778d6f7c52cf9024", "filename": "src/libstd/sys/windows/path.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6457bb67678c719d610e8f27f827c2e1ea56111/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=e6457bb67678c719d610e8f27f827c2e1ea56111", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ascii::*;\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+use mem;\n+\n+fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n+    unsafe { mem::transmute(s) }\n+}\n+unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n+    mem::transmute(s)\n+}\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/' || b == b'\\\\'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'\\\\'\n+}\n+\n+pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n+    use path::Prefix::*;\n+    unsafe {\n+        // The unsafety here stems from converting between &OsStr and &[u8]\n+        // and back. This is safe to do because (1) we only look at ASCII\n+        // contents of the encoding and (2) new &OsStr values are produced\n+        // only from ASCII-bounded slices of existing &OsStr values.\n+        let mut path = os_str_as_u8_slice(path);\n+\n+        if path.starts_with(br\"\\\\\") {\n+            // \\\\\n+            path = &path[2..];\n+            if path.starts_with(br\"?\\\") {\n+                // \\\\?\\\n+                path = &path[2..];\n+                if path.starts_with(br\"UNC\\\") {\n+                    // \\\\?\\UNC\\server\\share\n+                    path = &path[4..];\n+                    let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n+                        Some((server, share)) =>\n+                            (u8_slice_as_os_str(server), u8_slice_as_os_str(share)),\n+                        None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n+                    };\n+                    return Some(VerbatimUNC(server, share));\n+                } else {\n+                    // \\\\?\\path\n+                    let idx = path.iter().position(|&b| b == b'\\\\');\n+                    if idx == Some(2) && path[1] == b':' {\n+                        let c = path[0];\n+                        if c.is_ascii() && (c as char).is_alphabetic() {\n+                            // \\\\?\\C:\\ path\n+                            return Some(VerbatimDisk(c.to_ascii_uppercase()));\n+                        }\n+                    }\n+                    let slice = &path[..idx.unwrap_or(path.len())];\n+                    return Some(Verbatim(u8_slice_as_os_str(slice)));\n+                }\n+            } else if path.starts_with(b\".\\\\\") {\n+                // \\\\.\\path\n+                path = &path[2..];\n+                let pos = path.iter().position(|&b| b == b'\\\\');\n+                let slice = &path[..pos.unwrap_or(path.len())];\n+                return Some(DeviceNS(u8_slice_as_os_str(slice)));\n+            }\n+            match parse_two_comps(path, is_sep_byte) {\n+                Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n+                    // \\\\server\\share\n+                    return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n+                }\n+                _ => (),\n+            }\n+        } else if path.get(1) == Some(& b':') {\n+            // C:\n+            let c = path[0];\n+            if c.is_ascii() && (c as char).is_alphabetic() {\n+                return Some(Disk(c.to_ascii_uppercase()));\n+            }\n+        }\n+        return None;\n+    }\n+\n+    fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n+        let first = match path.iter().position(|x| f(*x)) {\n+            None => return None,\n+            Some(x) => &path[..x],\n+        };\n+        path = &path[(first.len() + 1)..];\n+        let idx = path.iter().position(|x| f(*x));\n+        let second = &path[..idx.unwrap_or(path.len())];\n+        Some((first, second))\n+    }\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+pub const MAIN_SEP: char = '\\\\';"}]}