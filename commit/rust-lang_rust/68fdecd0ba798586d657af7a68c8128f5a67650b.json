{"sha": "68fdecd0ba798586d657af7a68c8128f5a67650b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZmRlY2QwYmE3OTg1ODZkNjU3YWY3YTY4YzgxMjhmNWE2NzY1MGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-02T03:52:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-02T03:52:42Z"}, "message": "Auto merge of #67700 - cjgillot:passes-stability, r=Zoxc\n\nMove stability queries to librustc_passes.\n\nContains:\n- check_mod_unstable_api_usage query;\n- stability_index query;\n- check_unused_or_stable features pass.\n\nSplit out of #67688\n\nr? @Zoxc", "tree": {"sha": "c9ba68fbc4da260e413150d112238a5b0db4c1f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9ba68fbc4da260e413150d112238a5b0db4c1f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68fdecd0ba798586d657af7a68c8128f5a67650b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68fdecd0ba798586d657af7a68c8128f5a67650b", "html_url": "https://github.com/rust-lang/rust/commit/68fdecd0ba798586d657af7a68c8128f5a67650b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68fdecd0ba798586d657af7a68c8128f5a67650b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaca5f1d76cdb4d06dc0318e81493b9ae743cbc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaca5f1d76cdb4d06dc0318e81493b9ae743cbc5", "html_url": "https://github.com/rust-lang/rust/commit/aaca5f1d76cdb4d06dc0318e81493b9ae743cbc5"}, {"sha": "36b6630771cb371ffc6aa737ae26c6c8806c7060", "url": "https://api.github.com/repos/rust-lang/rust/commits/36b6630771cb371ffc6aa737ae26c6c8806c7060", "html_url": "https://github.com/rust-lang/rust/commit/36b6630771cb371ffc6aa737ae26c6c8806c7060"}], "stats": {"total": 1237, "additions": 628, "deletions": 609}, "files": [{"sha": "5ef4942ac3ba9d70ff8c1ddb1e58c5b85d93a447", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 11, "deletions": 602, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=68fdecd0ba798586d657af7a68c8128f5a67650b", "patch": "@@ -3,32 +3,25 @@\n \n pub use self::StabilityLevel::*;\n \n-use crate::hir::def::{DefKind, Res};\n-use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use crate::hir::{self, Generics, HirId, Item, StructField, Variant};\n+use crate::hir::def::DefKind;\n+use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n+use crate::hir::{self, HirId};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::{self, in_derive_expansion, Lint};\n-use crate::middle::privacy::AccessLevels;\n use crate::session::{DiagnosticMessageId, Session};\n-use crate::ty::query::Providers;\n use crate::ty::{self, TyCtxt};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::DiagnosticBuilder;\n use rustc_feature::GateIssue;\n use rustc_span::{MultiSpan, Span};\n-use syntax::ast::{Attribute, CRATE_NODE_ID};\n+use syntax::ast::CRATE_NODE_ID;\n use syntax::attr::{self, ConstStability, Deprecation, RustcDeprecation, Stability};\n use syntax::errors::Applicability;\n-use syntax::feature_gate::{feature_err, feature_err_issue};\n+use syntax::feature_gate::feature_err_issue;\n use syntax::symbol::{sym, Symbol};\n \n-use std::cmp::Ordering;\n-use std::mem::replace;\n use std::num::NonZeroU32;\n \n-use rustc_error_codes::*;\n-\n #[derive(PartialEq, Clone, Copy, Debug)]\n pub enum StabilityLevel {\n     Unstable,\n@@ -41,16 +34,6 @@ impl StabilityLevel {\n     }\n }\n \n-#[derive(PartialEq)]\n-enum AnnotationKind {\n-    // Annotation is required if not inherited from unstable parents\n-    Required,\n-    // Annotation is useless, reject it\n-    Prohibited,\n-    // Annotation itself is useless, but it can be propagated to children\n-    Container,\n-}\n-\n /// An entry in the `depr_map`.\n #[derive(Clone, HashStable)]\n pub struct DeprecationEntry {\n@@ -62,7 +45,7 @@ pub struct DeprecationEntry {\n }\n \n impl DeprecationEntry {\n-    fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n+    pub fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n         DeprecationEntry { attr, origin: Some(id) }\n     }\n \n@@ -83,391 +66,18 @@ impl DeprecationEntry {\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    stab_map: FxHashMap<HirId, &'tcx Stability>,\n-    const_stab_map: FxHashMap<HirId, &'tcx ConstStability>,\n-    depr_map: FxHashMap<HirId, DeprecationEntry>,\n+    pub stab_map: FxHashMap<HirId, &'tcx Stability>,\n+    pub const_stab_map: FxHashMap<HirId, &'tcx ConstStability>,\n+    pub depr_map: FxHashMap<HirId, DeprecationEntry>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FxHashMap<CrateNum, bool>,\n+    pub staged_api: FxHashMap<CrateNum, bool>,\n \n     /// Features enabled for this crate.\n-    active_features: FxHashSet<Symbol>,\n-}\n-\n-// A private tree-walker for producing an Index.\n-struct Annotator<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    index: &'a mut Index<'tcx>,\n-    parent_stab: Option<&'tcx Stability>,\n-    parent_depr: Option<DeprecationEntry>,\n-    in_trait_impl: bool,\n-}\n-\n-impl<'a, 'tcx> Annotator<'a, 'tcx> {\n-    // Determine the stability for a node based on its attributes and inherited\n-    // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(\n-        &mut self,\n-        hir_id: HirId,\n-        attrs: &[Attribute],\n-        item_sp: Span,\n-        kind: AnnotationKind,\n-        visit_children: F,\n-    ) where\n-        F: FnOnce(&mut Self),\n-    {\n-        if self.tcx.features().staged_api {\n-            // This crate explicitly wants staged API.\n-            debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n-            if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-                self.tcx.sess.span_err(\n-                    item_sp,\n-                    \"`#[deprecated]` cannot be used in staged API; \\\n-                                                 use `#[rustc_deprecated]` instead\",\n-                );\n-            }\n-            let (stab, const_stab) =\n-                attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n-            if let Some(const_stab) = const_stab {\n-                let const_stab = self.tcx.intern_const_stability(const_stab);\n-                self.index.const_stab_map.insert(hir_id, const_stab);\n-            }\n-            if let Some(mut stab) = stab {\n-                // Error if prohibited, or can't inherit anything from a container.\n-                if kind == AnnotationKind::Prohibited\n-                    || (kind == AnnotationKind::Container\n-                        && stab.level.is_stable()\n-                        && stab.rustc_depr.is_none())\n-                {\n-                    self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n-                }\n-\n-                debug!(\"annotate: found {:?}\", stab);\n-                // If parent is deprecated and we're not, inherit this by merging\n-                // deprecated_since and its reason.\n-                if let Some(parent_stab) = self.parent_stab {\n-                    if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n-                        stab.rustc_depr = parent_stab.rustc_depr.clone()\n-                    }\n-                }\n-\n-                let stab = self.tcx.intern_stability(stab);\n-\n-                // Check if deprecated_since < stable_since. If it is,\n-                // this is *almost surely* an accident.\n-                if let (\n-                    &Some(attr::RustcDeprecation { since: dep_since, .. }),\n-                    &attr::Stable { since: stab_since },\n-                ) = (&stab.rustc_depr, &stab.level)\n-                {\n-                    // Explicit version of iter::order::lt to handle parse errors properly\n-                    for (dep_v, stab_v) in\n-                        dep_since.as_str().split('.').zip(stab_since.as_str().split('.'))\n-                    {\n-                        if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n-                            match dep_v.cmp(&stab_v) {\n-                                Ordering::Less => {\n-                                    self.tcx.sess.span_err(\n-                                        item_sp,\n-                                        \"An API can't be stabilized \\\n-                                                                     after it is deprecated\",\n-                                    );\n-                                    break;\n-                                }\n-                                Ordering::Equal => continue,\n-                                Ordering::Greater => break,\n-                            }\n-                        } else {\n-                            // Act like it isn't less because the question is now nonsensical,\n-                            // and this makes us not do anything else interesting.\n-                            self.tcx.sess.span_err(\n-                                item_sp,\n-                                \"Invalid stability or deprecation \\\n-                                                             version found\",\n-                            );\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                self.index.stab_map.insert(hir_id, stab);\n-\n-                let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n-                visit_children(self);\n-                self.parent_stab = orig_parent_stab;\n-            } else {\n-                debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n-                if let Some(stab) = self.parent_stab {\n-                    if stab.level.is_unstable() {\n-                        self.index.stab_map.insert(hir_id, stab);\n-                    }\n-                }\n-                visit_children(self);\n-            }\n-        } else {\n-            // Emit errors for non-staged-api crates.\n-            let unstable_attrs = [\n-                sym::unstable,\n-                sym::stable,\n-                sym::rustc_deprecated,\n-                sym::rustc_const_unstable,\n-                sym::rustc_const_stable,\n-            ];\n-            for attr in attrs {\n-                let name = attr.name_or_empty();\n-                if unstable_attrs.contains(&name) {\n-                    attr::mark_used(attr);\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        attr.span,\n-                        E0734,\n-                        \"stability attributes may not be used outside of the standard library\",\n-                    )\n-                    .emit();\n-                }\n-            }\n-\n-            // Propagate unstability.  This can happen even for non-staged-api crates in case\n-            // -Zforce-unstable-if-unmarked is set.\n-            if let Some(stab) = self.parent_stab {\n-                if stab.level.is_unstable() {\n-                    self.index.stab_map.insert(hir_id, stab);\n-                }\n-            }\n-\n-            if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-                if kind == AnnotationKind::Prohibited {\n-                    self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n-                }\n-\n-                // `Deprecation` is just two pointers, no need to intern it\n-                let depr_entry = DeprecationEntry::local(depr, hir_id);\n-                self.index.depr_map.insert(hir_id, depr_entry.clone());\n-\n-                let orig_parent_depr = replace(&mut self.parent_depr, Some(depr_entry));\n-                visit_children(self);\n-                self.parent_depr = orig_parent_depr;\n-            } else if let Some(parent_depr) = self.parent_depr.clone() {\n-                self.index.depr_map.insert(hir_id, parent_depr);\n-                visit_children(self);\n-            } else {\n-                visit_children(self);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n-    /// Because stability levels are scoped lexically, we want to walk\n-    /// nested items in the context of the outer item, so enable\n-    /// deep-walking.\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir())\n-    }\n-\n-    fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n-        let orig_in_trait_impl = self.in_trait_impl;\n-        let mut kind = AnnotationKind::Required;\n-        match i.kind {\n-            // Inherent impls and foreign modules serve only as containers for other items,\n-            // they don't have their own stability. They still can be annotated as unstable\n-            // and propagate this unstability to children, but this annotation is completely\n-            // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {\n-                self.in_trait_impl = false;\n-                kind = AnnotationKind::Container;\n-            }\n-            hir::ItemKind::Impl(.., Some(_), _, _) => {\n-                self.in_trait_impl = true;\n-            }\n-            hir::ItemKind::Struct(ref sd, _) => {\n-                if let Some(ctor_hir_id) = sd.ctor_hir_id() {\n-                    self.annotate(ctor_hir_id, &i.attrs, i.span, AnnotationKind::Required, |_| {})\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        self.annotate(i.hir_id, &i.attrs, i.span, kind, |v| intravisit::walk_item(v, i));\n-        self.in_trait_impl = orig_in_trait_impl;\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.annotate(ti.hir_id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n-            intravisit::walk_trait_item(v, ti);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let kind =\n-            if self.in_trait_impl { AnnotationKind::Prohibited } else { AnnotationKind::Required };\n-        self.annotate(ii.hir_id, &ii.attrs, ii.span, kind, |v| {\n-            intravisit::walk_impl_item(v, ii);\n-        });\n-    }\n-\n-    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n-        self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required, |v| {\n-            if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n-                v.annotate(ctor_hir_id, &var.attrs, var.span, AnnotationKind::Required, |_| {});\n-            }\n-\n-            intravisit::walk_variant(v, var, g, item_id)\n-        })\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n-        self.annotate(s.hir_id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n-            intravisit::walk_struct_field(v, s);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.annotate(i.hir_id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n-            intravisit::walk_foreign_item(v, i);\n-        });\n-    }\n-\n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        self.annotate(md.hir_id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n-    }\n-}\n-\n-struct MissingStabilityAnnotations<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n-}\n-\n-impl<'a, 'tcx> MissingStabilityAnnotations<'a, 'tcx> {\n-    fn check_missing_stability(&self, hir_id: HirId, span: Span, name: &str) {\n-        let stab = self.tcx.stability().local_stability(hir_id);\n-        let is_error =\n-            !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(hir_id);\n-        if is_error {\n-            self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", name));\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n-    }\n-\n-    fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n-        match i.kind {\n-            // Inherent impls and foreign modules serve only as containers for other items,\n-            // they don't have their own stability. They still can be annotated as unstable\n-            // and propagate this unstability to children, but this annotation is completely\n-            // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n-\n-            _ => self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant()),\n-        }\n-\n-        intravisit::walk_item(self, i)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.check_missing_stability(ti.hir_id, ti.span, \"item\");\n-        intravisit::walk_trait_item(self, ti);\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent_item(ii.hir_id));\n-        if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.hir_id, ii.span, \"item\");\n-        }\n-        intravisit::walk_impl_item(self, ii);\n-    }\n-\n-    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n-        self.check_missing_stability(var.id, var.span, \"variant\");\n-        intravisit::walk_variant(self, var, g, item_id);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n-        self.check_missing_stability(s.hir_id, s.span, \"field\");\n-        intravisit::walk_struct_field(self, s);\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant());\n-        intravisit::walk_foreign_item(self, i);\n-    }\n-\n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_missing_stability(md.hir_id, md.span, \"macro\");\n-    }\n+    pub active_features: FxHashSet<Symbol>,\n }\n \n impl<'tcx> Index<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n-        let is_staged_api =\n-            tcx.sess.opts.debugging_opts.force_unstable_if_unmarked || tcx.features().staged_api;\n-        let mut staged_api = FxHashMap::default();\n-        staged_api.insert(LOCAL_CRATE, is_staged_api);\n-        let mut index = Index {\n-            staged_api,\n-            stab_map: Default::default(),\n-            const_stab_map: Default::default(),\n-            depr_map: Default::default(),\n-            active_features: Default::default(),\n-        };\n-\n-        let active_lib_features = &tcx.features().declared_lib_features;\n-        let active_lang_features = &tcx.features().declared_lang_features;\n-\n-        // Put the active features into a map for quick lookup.\n-        index.active_features = active_lib_features\n-            .iter()\n-            .map(|&(ref s, ..)| s.clone())\n-            .chain(active_lang_features.iter().map(|&(ref s, ..)| s.clone()))\n-            .collect();\n-\n-        {\n-            let krate = tcx.hir().krate();\n-            let mut annotator = Annotator {\n-                tcx,\n-                index: &mut index,\n-                parent_stab: None,\n-                parent_depr: None,\n-                in_trait_impl: false,\n-            };\n-\n-            // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n-            // a parent stability annotation which indicates that this is private\n-            // with the `rustc_private` feature. This is intended for use when\n-            // compiling librustc crates themselves so we can leverage crates.io\n-            // while maintaining the invariant that all sysroot crates are unstable\n-            // by default and are unable to be used.\n-            if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-                let reason = \"this crate is being loaded from the sysroot, an \\\n-                              unstable location; did you mean to load this crate \\\n-                              from crates.io via `Cargo.toml` instead?\";\n-                let stability = tcx.intern_stability(Stability {\n-                    level: attr::StabilityLevel::Unstable {\n-                        reason: Some(Symbol::intern(reason)),\n-                        issue: NonZeroU32::new(27812),\n-                        is_soft: false,\n-                    },\n-                    feature: sym::rustc_private,\n-                    rustc_depr: None,\n-                });\n-                annotator.parent_stab = Some(stability);\n-            }\n-\n-            annotator.annotate(\n-                hir::CRATE_HIR_ID,\n-                &krate.attrs,\n-                krate.span,\n-                AnnotationKind::Required,\n-                |v| intravisit::walk_crate(v, krate),\n-            );\n-        }\n-        return index;\n-    }\n-\n     pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n         self.stab_map.get(&id).cloned()\n     }\n@@ -481,16 +91,6 @@ impl<'tcx> Index<'tcx> {\n     }\n }\n \n-/// Cross-references the feature names of unstable APIs with enabled\n-/// features and possibly prints errors.\n-fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers { check_mod_unstable_api_usage, ..*providers };\n-}\n-\n pub fn report_unstable(\n     sess: &Session,\n     feature: Symbol,\n@@ -632,10 +232,6 @@ fn late_report_deprecation(\n     }\n }\n \n-struct Checker<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n /// Result of `TyCtxt::eval_stability`.\n pub enum EvalResult {\n     /// We can use the item because it is stable or we provided the\n@@ -807,195 +403,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for Checker<'tcx> {\n-    /// Because stability levels are scoped lexically, we want to walk\n-    /// nested items in the context of the outer item, so enable\n-    /// deep-walking.\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        match item.kind {\n-            hir::ItemKind::ExternCrate(_) => {\n-                // compiler-generated `extern crate` items have a dummy span.\n-                if item.span.is_dummy() {\n-                    return;\n-                }\n-\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n-                    Some(cnum) => cnum,\n-                    None => return,\n-                };\n-                let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, Some(item.hir_id), item.span);\n-            }\n-\n-            // For implementations of traits, check the stability of each item\n-            // individually as it's possible to have a stable trait with unstable\n-            // items.\n-            hir::ItemKind::Impl(.., Some(ref t), _, impl_item_refs) => {\n-                if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n-                    for impl_item_ref in impl_item_refs {\n-                        let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                        let trait_item_def_id = self\n-                            .tcx\n-                            .associated_items(trait_did)\n-                            .find(|item| item.ident.name == impl_item.ident.name)\n-                            .map(|item| item.def_id);\n-                        if let Some(def_id) = trait_item_def_id {\n-                            // Pass `None` to skip deprecation warnings.\n-                            self.tcx.check_stability(def_id, None, impl_item.span);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // There's no good place to insert stability check for non-Copy unions,\n-            // so semi-randomly perform it here in stability.rs\n-            hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let adt_def = self.tcx.adt_def(def_id);\n-                let ty = self.tcx.type_of(def_id);\n-\n-                if adt_def.has_dtor(self.tcx) {\n-                    feature_err(\n-                        &self.tcx.sess.parse_sess,\n-                        sym::untagged_unions,\n-                        item.span,\n-                        \"unions with `Drop` implementations are unstable\",\n-                    )\n-                    .emit();\n-                } else {\n-                    let param_env = self.tcx.param_env(def_id);\n-                    if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n-                        feature_err(\n-                            &self.tcx.sess.parse_sess,\n-                            sym::untagged_unions,\n-                            item.span,\n-                            \"unions with non-`Copy` fields are unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                }\n-            }\n-\n-            _ => (/* pass */),\n-        }\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n-        if let Some(def_id) = path.res.opt_def_id() {\n-            self.tcx.check_stability(def_id, Some(id), path.span)\n-        }\n-        intravisit::walk_path(self, path)\n-    }\n-}\n-\n impl<'tcx> TyCtxt<'tcx> {\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }\n }\n-\n-/// Given the list of enabled features that were not language features (i.e., that\n-/// were expected to be library features), and the list of features used from\n-/// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n-    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n-\n-    if tcx.stability().staged_api[&LOCAL_CRATE] {\n-        let krate = tcx.hir().krate();\n-        let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n-        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.span, \"crate\");\n-        intravisit::walk_crate(&mut missing, krate);\n-        krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n-    }\n-\n-    let declared_lang_features = &tcx.features().declared_lang_features;\n-    let mut lang_features = FxHashSet::default();\n-    for &(feature, span, since) in declared_lang_features {\n-        if let Some(since) = since {\n-            // Warn if the user has enabled an already-stable lang feature.\n-            unnecessary_stable_feature_lint(tcx, span, feature, since);\n-        }\n-        if !lang_features.insert(feature) {\n-            // Warn if the user enables a lang feature multiple times.\n-            duplicate_feature_err(tcx.sess, span, feature);\n-        }\n-    }\n-\n-    let declared_lib_features = &tcx.features().declared_lib_features;\n-    let mut remaining_lib_features = FxHashMap::default();\n-    for (feature, span) in declared_lib_features {\n-        if remaining_lib_features.contains_key(&feature) {\n-            // Warn if the user enables a lib feature multiple times.\n-            duplicate_feature_err(tcx.sess, *span, *feature);\n-        }\n-        remaining_lib_features.insert(feature, span.clone());\n-    }\n-    // `stdbuild` has special handling for `libc`, so we need to\n-    // recognise the feature when building std.\n-    // Likewise, libtest is handled specially, so `test` isn't\n-    // available as we'd like it to be.\n-    // FIXME: only remove `libc` when `stdbuild` is active.\n-    // FIXME: remove special casing for `test`.\n-    remaining_lib_features.remove(&Symbol::intern(\"libc\"));\n-    remaining_lib_features.remove(&sym::test);\n-\n-    let check_features = |remaining_lib_features: &mut FxHashMap<_, _>, defined_features: &[_]| {\n-        for &(feature, since) in defined_features {\n-            if let Some(since) = since {\n-                if let Some(span) = remaining_lib_features.get(&feature) {\n-                    // Warn if the user has enabled an already-stable lib feature.\n-                    unnecessary_stable_feature_lint(tcx, *span, feature, since);\n-                }\n-            }\n-            remaining_lib_features.remove(&feature);\n-            if remaining_lib_features.is_empty() {\n-                break;\n-            }\n-        }\n-    };\n-\n-    // We always collect the lib features declared in the current crate, even if there are\n-    // no unknown features, because the collection also does feature attribute validation.\n-    let local_defined_features = tcx.lib_features().to_vec();\n-    if !remaining_lib_features.is_empty() {\n-        check_features(&mut remaining_lib_features, &local_defined_features);\n-\n-        for &cnum in &*tcx.crates() {\n-            if remaining_lib_features.is_empty() {\n-                break;\n-            }\n-            check_features(&mut remaining_lib_features, tcx.defined_lib_features(cnum));\n-        }\n-    }\n-\n-    for (feature, span) in remaining_lib_features {\n-        struct_span_err!(tcx.sess, span, E0635, \"unknown feature `{}`\", feature).emit();\n-    }\n-\n-    // FIXME(#44232): the `used_features` table no longer exists, so we\n-    // don't lint about unused features. We should reenable this one day!\n-}\n-\n-fn unnecessary_stable_feature_lint(tcx: TyCtxt<'_>, span: Span, feature: Symbol, since: Symbol) {\n-    tcx.lint_hir(\n-        lint::builtin::STABLE_FEATURES,\n-        hir::CRATE_HIR_ID,\n-        span,\n-        &format!(\n-            \"the feature `{}` has been stable since {} and no longer requires \\\n-                  an attribute to enable\",\n-            feature, since\n-        ),\n-    );\n-}\n-\n-fn duplicate_feature_err(sess: &Session, span: Span, feature: Symbol) {\n-    struct_span_err!(sess, span, E0636, \"the feature `{}` has already been declared\", feature)\n-        .emit();\n-}"}, {"sha": "d83a720170b03e1d1517c8fcb0472951bcb5dcb6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=68fdecd0ba798586d657af7a68c8128f5a67650b", "patch": "@@ -2765,10 +2765,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         Lrc::new(tcx.glob_map.get(&id).cloned().unwrap_or_default())\n     };\n \n-    providers.stability_index = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.arena.alloc(stability::Index::new(tcx))\n-    };\n     providers.lookup_stability = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n         let id = tcx.hir().definitions().def_index_to_hir_id(id.index);"}, {"sha": "670ca30faf2c5a0132475f79e5eed2c81c072e96", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=68fdecd0ba798586d657af7a68c8128f5a67650b", "patch": "@@ -8,8 +8,8 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::lint;\n+use rustc::middle;\n use rustc::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n-use rustc::middle::{self, stability};\n use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n use rustc::session::config::{PpMode, PpSourceMode};\n use rustc::session::search_paths::PathKind;\n@@ -687,7 +687,6 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     typeck::provide(providers);\n     ty::provide(providers);\n     traits::provide(providers);\n-    stability::provide(providers);\n     rustc_passes::provide(providers);\n     rustc_resolve::provide(providers);\n     rustc_traits::provide(providers);\n@@ -881,7 +880,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                     },\n                     {\n                         time(sess, \"unused lib feature checking\", || {\n-                            stability::check_unused_or_stable_features(tcx)\n+                            rustc_passes::stability::check_unused_or_stable_features(tcx)\n                         });\n                     },\n                     {"}, {"sha": "a692c45ced40bedf4139cd40993653855665c3e9", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=68fdecd0ba798586d657af7a68c8128f5a67650b", "patch": "@@ -32,6 +32,7 @@ mod liveness;\n pub mod loops;\n mod reachable;\n mod region;\n+pub mod stability;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_const::provide(providers);\n@@ -43,4 +44,5 @@ pub fn provide(providers: &mut Providers<'_>) {\n     intrinsicck::provide(providers);\n     reachable::provide(providers);\n     region::provide(providers);\n+    stability::provide(providers);\n }"}, {"sha": "fcbc742b9a00b0b7253c9318ae7cc3ddf888ed97", "filename": "src/librustc_passes/stability.rs", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fdecd0ba798586d657af7a68c8128f5a67650b/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=68fdecd0ba798586d657af7a68c8128f5a67650b", "patch": "@@ -0,0 +1,613 @@\n+//! A pass that annotates every item and method with its stability level,\n+//! propagating default levels lexically from parent to children ast nodes.\n+\n+use rustc::hir::def::{DefKind, Res};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::{self, Generics, HirId, Item, StructField, Variant};\n+use rustc::lint;\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::middle::stability::{DeprecationEntry, Index};\n+use rustc::session::Session;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_span::Span;\n+use syntax::ast::Attribute;\n+use syntax::attr::{self, Stability};\n+use syntax::feature_gate::feature_err;\n+use syntax::symbol::{sym, Symbol};\n+\n+use std::cmp::Ordering;\n+use std::mem::replace;\n+use std::num::NonZeroU32;\n+\n+use rustc_error_codes::*;\n+\n+#[derive(PartialEq)]\n+enum AnnotationKind {\n+    // Annotation is required if not inherited from unstable parents\n+    Required,\n+    // Annotation is useless, reject it\n+    Prohibited,\n+    // Annotation itself is useless, but it can be propagated to children\n+    Container,\n+}\n+\n+// A private tree-walker for producing an Index.\n+struct Annotator<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    index: &'a mut Index<'tcx>,\n+    parent_stab: Option<&'tcx Stability>,\n+    parent_depr: Option<DeprecationEntry>,\n+    in_trait_impl: bool,\n+}\n+\n+impl<'a, 'tcx> Annotator<'a, 'tcx> {\n+    // Determine the stability for a node based on its attributes and inherited\n+    // stability. The stability is recorded in the index and used as the parent.\n+    fn annotate<F>(\n+        &mut self,\n+        hir_id: HirId,\n+        attrs: &[Attribute],\n+        item_sp: Span,\n+        kind: AnnotationKind,\n+        visit_children: F,\n+    ) where\n+        F: FnOnce(&mut Self),\n+    {\n+        if self.tcx.features().staged_api {\n+            // This crate explicitly wants staged API.\n+            debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n+            if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n+                self.tcx.sess.span_err(\n+                    item_sp,\n+                    \"`#[deprecated]` cannot be used in staged API; \\\n+                                                 use `#[rustc_deprecated]` instead\",\n+                );\n+            }\n+            let (stab, const_stab) =\n+                attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n+            if let Some(const_stab) = const_stab {\n+                let const_stab = self.tcx.intern_const_stability(const_stab);\n+                self.index.const_stab_map.insert(hir_id, const_stab);\n+            }\n+            if let Some(mut stab) = stab {\n+                // Error if prohibited, or can't inherit anything from a container.\n+                if kind == AnnotationKind::Prohibited\n+                    || (kind == AnnotationKind::Container\n+                        && stab.level.is_stable()\n+                        && stab.rustc_depr.is_none())\n+                {\n+                    self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n+                }\n+\n+                debug!(\"annotate: found {:?}\", stab);\n+                // If parent is deprecated and we're not, inherit this by merging\n+                // deprecated_since and its reason.\n+                if let Some(parent_stab) = self.parent_stab {\n+                    if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n+                        stab.rustc_depr = parent_stab.rustc_depr.clone()\n+                    }\n+                }\n+\n+                let stab = self.tcx.intern_stability(stab);\n+\n+                // Check if deprecated_since < stable_since. If it is,\n+                // this is *almost surely* an accident.\n+                if let (\n+                    &Some(attr::RustcDeprecation { since: dep_since, .. }),\n+                    &attr::Stable { since: stab_since },\n+                ) = (&stab.rustc_depr, &stab.level)\n+                {\n+                    // Explicit version of iter::order::lt to handle parse errors properly\n+                    for (dep_v, stab_v) in\n+                        dep_since.as_str().split('.').zip(stab_since.as_str().split('.'))\n+                    {\n+                        if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n+                            match dep_v.cmp(&stab_v) {\n+                                Ordering::Less => {\n+                                    self.tcx.sess.span_err(\n+                                        item_sp,\n+                                        \"An API can't be stabilized \\\n+                                                                     after it is deprecated\",\n+                                    );\n+                                    break;\n+                                }\n+                                Ordering::Equal => continue,\n+                                Ordering::Greater => break,\n+                            }\n+                        } else {\n+                            // Act like it isn't less because the question is now nonsensical,\n+                            // and this makes us not do anything else interesting.\n+                            self.tcx.sess.span_err(\n+                                item_sp,\n+                                \"Invalid stability or deprecation \\\n+                                                             version found\",\n+                            );\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                self.index.stab_map.insert(hir_id, stab);\n+\n+                let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n+                visit_children(self);\n+                self.parent_stab = orig_parent_stab;\n+            } else {\n+                debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n+                if let Some(stab) = self.parent_stab {\n+                    if stab.level.is_unstable() {\n+                        self.index.stab_map.insert(hir_id, stab);\n+                    }\n+                }\n+                visit_children(self);\n+            }\n+        } else {\n+            // Emit errors for non-staged-api crates.\n+            let unstable_attrs = [\n+                sym::unstable,\n+                sym::stable,\n+                sym::rustc_deprecated,\n+                sym::rustc_const_unstable,\n+                sym::rustc_const_stable,\n+            ];\n+            for attr in attrs {\n+                let name = attr.name_or_empty();\n+                if unstable_attrs.contains(&name) {\n+                    attr::mark_used(attr);\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        attr.span,\n+                        E0734,\n+                        \"stability attributes may not be used outside of the standard library\",\n+                    )\n+                    .emit();\n+                }\n+            }\n+\n+            // Propagate unstability.  This can happen even for non-staged-api crates in case\n+            // -Zforce-unstable-if-unmarked is set.\n+            if let Some(stab) = self.parent_stab {\n+                if stab.level.is_unstable() {\n+                    self.index.stab_map.insert(hir_id, stab);\n+                }\n+            }\n+\n+            if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n+                if kind == AnnotationKind::Prohibited {\n+                    self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n+                }\n+\n+                // `Deprecation` is just two pointers, no need to intern it\n+                let depr_entry = DeprecationEntry::local(depr, hir_id);\n+                self.index.depr_map.insert(hir_id, depr_entry.clone());\n+\n+                let orig_parent_depr = replace(&mut self.parent_depr, Some(depr_entry));\n+                visit_children(self);\n+                self.parent_depr = orig_parent_depr;\n+            } else if let Some(parent_depr) = self.parent_depr.clone() {\n+                self.index.depr_map.insert(hir_id, parent_depr);\n+                visit_children(self);\n+            } else {\n+                visit_children(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n+    /// Because stability levels are scoped lexically, we want to walk\n+    /// nested items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.hir())\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n+        let orig_in_trait_impl = self.in_trait_impl;\n+        let mut kind = AnnotationKind::Required;\n+        match i.kind {\n+            // Inherent impls and foreign modules serve only as containers for other items,\n+            // they don't have their own stability. They still can be annotated as unstable\n+            // and propagate this unstability to children, but this annotation is completely\n+            // optional. They inherit stability from their parents when unannotated.\n+            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {\n+                self.in_trait_impl = false;\n+                kind = AnnotationKind::Container;\n+            }\n+            hir::ItemKind::Impl(.., Some(_), _, _) => {\n+                self.in_trait_impl = true;\n+            }\n+            hir::ItemKind::Struct(ref sd, _) => {\n+                if let Some(ctor_hir_id) = sd.ctor_hir_id() {\n+                    self.annotate(ctor_hir_id, &i.attrs, i.span, AnnotationKind::Required, |_| {})\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        self.annotate(i.hir_id, &i.attrs, i.span, kind, |v| intravisit::walk_item(v, i));\n+        self.in_trait_impl = orig_in_trait_impl;\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n+        self.annotate(ti.hir_id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n+            intravisit::walk_trait_item(v, ti);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n+        let kind =\n+            if self.in_trait_impl { AnnotationKind::Prohibited } else { AnnotationKind::Required };\n+        self.annotate(ii.hir_id, &ii.attrs, ii.span, kind, |v| {\n+            intravisit::walk_impl_item(v, ii);\n+        });\n+    }\n+\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n+        self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required, |v| {\n+            if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n+                v.annotate(ctor_hir_id, &var.attrs, var.span, AnnotationKind::Required, |_| {});\n+            }\n+\n+            intravisit::walk_variant(v, var, g, item_id)\n+        })\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n+        self.annotate(s.hir_id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n+            intravisit::walk_struct_field(v, s);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n+        self.annotate(i.hir_id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n+            intravisit::walk_foreign_item(v, i);\n+        });\n+    }\n+\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n+        self.annotate(md.hir_id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n+    }\n+}\n+\n+struct MissingStabilityAnnotations<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    access_levels: &'a AccessLevels,\n+}\n+\n+impl<'a, 'tcx> MissingStabilityAnnotations<'a, 'tcx> {\n+    fn check_missing_stability(&self, hir_id: HirId, span: Span, name: &str) {\n+        let stab = self.tcx.stability().local_stability(hir_id);\n+        let is_error =\n+            !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(hir_id);\n+        if is_error {\n+            self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", name));\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n+        match i.kind {\n+            // Inherent impls and foreign modules serve only as containers for other items,\n+            // they don't have their own stability. They still can be annotated as unstable\n+            // and propagate this unstability to children, but this annotation is completely\n+            // optional. They inherit stability from their parents when unannotated.\n+            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n+\n+            _ => self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant()),\n+        }\n+\n+        intravisit::walk_item(self, i)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n+        self.check_missing_stability(ti.hir_id, ti.span, \"item\");\n+        intravisit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n+        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent_item(ii.hir_id));\n+        if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n+            self.check_missing_stability(ii.hir_id, ii.span, \"item\");\n+        }\n+        intravisit::walk_impl_item(self, ii);\n+    }\n+\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n+        self.check_missing_stability(var.id, var.span, \"variant\");\n+        intravisit::walk_variant(self, var, g, item_id);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n+        self.check_missing_stability(s.hir_id, s.span, \"field\");\n+        intravisit::walk_struct_field(self, s);\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n+        self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant());\n+        intravisit::walk_foreign_item(self, i);\n+    }\n+\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n+        self.check_missing_stability(md.hir_id, md.span, \"macro\");\n+    }\n+}\n+\n+fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n+    let is_staged_api =\n+        tcx.sess.opts.debugging_opts.force_unstable_if_unmarked || tcx.features().staged_api;\n+    let mut staged_api = FxHashMap::default();\n+    staged_api.insert(LOCAL_CRATE, is_staged_api);\n+    let mut index = Index {\n+        staged_api,\n+        stab_map: Default::default(),\n+        const_stab_map: Default::default(),\n+        depr_map: Default::default(),\n+        active_features: Default::default(),\n+    };\n+\n+    let active_lib_features = &tcx.features().declared_lib_features;\n+    let active_lang_features = &tcx.features().declared_lang_features;\n+\n+    // Put the active features into a map for quick lookup.\n+    index.active_features = active_lib_features\n+        .iter()\n+        .map(|&(ref s, ..)| s.clone())\n+        .chain(active_lang_features.iter().map(|&(ref s, ..)| s.clone()))\n+        .collect();\n+\n+    {\n+        let krate = tcx.hir().krate();\n+        let mut annotator = Annotator {\n+            tcx,\n+            index: &mut index,\n+            parent_stab: None,\n+            parent_depr: None,\n+            in_trait_impl: false,\n+        };\n+\n+        // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n+        // a parent stability annotation which indicates that this is private\n+        // with the `rustc_private` feature. This is intended for use when\n+        // compiling librustc crates themselves so we can leverage crates.io\n+        // while maintaining the invariant that all sysroot crates are unstable\n+        // by default and are unable to be used.\n+        if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+            let reason = \"this crate is being loaded from the sysroot, an \\\n+                          unstable location; did you mean to load this crate \\\n+                          from crates.io via `Cargo.toml` instead?\";\n+            let stability = tcx.intern_stability(Stability {\n+                level: attr::StabilityLevel::Unstable {\n+                    reason: Some(Symbol::intern(reason)),\n+                    issue: NonZeroU32::new(27812),\n+                    is_soft: false,\n+                },\n+                feature: sym::rustc_private,\n+                rustc_depr: None,\n+            });\n+            annotator.parent_stab = Some(stability);\n+        }\n+\n+        annotator.annotate(\n+            hir::CRATE_HIR_ID,\n+            &krate.attrs,\n+            krate.span,\n+            AnnotationKind::Required,\n+            |v| intravisit::walk_crate(v, krate),\n+        );\n+    }\n+    return index;\n+}\n+\n+/// Cross-references the feature names of unstable APIs with enabled\n+/// features and possibly prints errors.\n+fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+    tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers { check_mod_unstable_api_usage, ..*providers };\n+    providers.stability_index = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        tcx.arena.alloc(new_index(tcx))\n+    };\n+}\n+\n+struct Checker<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl Visitor<'tcx> for Checker<'tcx> {\n+    /// Because stability levels are scoped lexically, we want to walk\n+    /// nested items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+        match item.kind {\n+            hir::ItemKind::ExternCrate(_) => {\n+                // compiler-generated `extern crate` items have a dummy span.\n+                if item.span.is_dummy() {\n+                    return;\n+                }\n+\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n+                let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n+                    Some(cnum) => cnum,\n+                    None => return,\n+                };\n+                let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+                self.tcx.check_stability(def_id, Some(item.hir_id), item.span);\n+            }\n+\n+            // For implementations of traits, check the stability of each item\n+            // individually as it's possible to have a stable trait with unstable\n+            // items.\n+            hir::ItemKind::Impl(.., Some(ref t), _, impl_item_refs) => {\n+                if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n+                    for impl_item_ref in impl_item_refs {\n+                        let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n+                        let trait_item_def_id = self\n+                            .tcx\n+                            .associated_items(trait_did)\n+                            .find(|item| item.ident.name == impl_item.ident.name)\n+                            .map(|item| item.def_id);\n+                        if let Some(def_id) = trait_item_def_id {\n+                            // Pass `None` to skip deprecation warnings.\n+                            self.tcx.check_stability(def_id, None, impl_item.span);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // There's no good place to insert stability check for non-Copy unions,\n+            // so semi-randomly perform it here in stability.rs\n+            hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n+                let adt_def = self.tcx.adt_def(def_id);\n+                let ty = self.tcx.type_of(def_id);\n+\n+                if adt_def.has_dtor(self.tcx) {\n+                    feature_err(\n+                        &self.tcx.sess.parse_sess,\n+                        sym::untagged_unions,\n+                        item.span,\n+                        \"unions with `Drop` implementations are unstable\",\n+                    )\n+                    .emit();\n+                } else {\n+                    let param_env = self.tcx.param_env(def_id);\n+                    if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n+                        feature_err(\n+                            &self.tcx.sess.parse_sess,\n+                            sym::untagged_unions,\n+                            item.span,\n+                            \"unions with non-`Copy` fields are unstable\",\n+                        )\n+                        .emit();\n+                    }\n+                }\n+            }\n+\n+            _ => (/* pass */),\n+        }\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n+        if let Some(def_id) = path.res.opt_def_id() {\n+            self.tcx.check_stability(def_id, Some(id), path.span)\n+        }\n+        intravisit::walk_path(self, path)\n+    }\n+}\n+\n+/// Given the list of enabled features that were not language features (i.e., that\n+/// were expected to be library features), and the list of features used from\n+/// libraries, identify activated features that don't exist and error about them.\n+pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+\n+    if tcx.stability().staged_api[&LOCAL_CRATE] {\n+        let krate = tcx.hir().krate();\n+        let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n+        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.span, \"crate\");\n+        intravisit::walk_crate(&mut missing, krate);\n+        krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n+    }\n+\n+    let declared_lang_features = &tcx.features().declared_lang_features;\n+    let mut lang_features = FxHashSet::default();\n+    for &(feature, span, since) in declared_lang_features {\n+        if let Some(since) = since {\n+            // Warn if the user has enabled an already-stable lang feature.\n+            unnecessary_stable_feature_lint(tcx, span, feature, since);\n+        }\n+        if !lang_features.insert(feature) {\n+            // Warn if the user enables a lang feature multiple times.\n+            duplicate_feature_err(tcx.sess, span, feature);\n+        }\n+    }\n+\n+    let declared_lib_features = &tcx.features().declared_lib_features;\n+    let mut remaining_lib_features = FxHashMap::default();\n+    for (feature, span) in declared_lib_features {\n+        if remaining_lib_features.contains_key(&feature) {\n+            // Warn if the user enables a lib feature multiple times.\n+            duplicate_feature_err(tcx.sess, *span, *feature);\n+        }\n+        remaining_lib_features.insert(feature, span.clone());\n+    }\n+    // `stdbuild` has special handling for `libc`, so we need to\n+    // recognise the feature when building std.\n+    // Likewise, libtest is handled specially, so `test` isn't\n+    // available as we'd like it to be.\n+    // FIXME: only remove `libc` when `stdbuild` is active.\n+    // FIXME: remove special casing for `test`.\n+    remaining_lib_features.remove(&Symbol::intern(\"libc\"));\n+    remaining_lib_features.remove(&sym::test);\n+\n+    let check_features = |remaining_lib_features: &mut FxHashMap<_, _>, defined_features: &[_]| {\n+        for &(feature, since) in defined_features {\n+            if let Some(since) = since {\n+                if let Some(span) = remaining_lib_features.get(&feature) {\n+                    // Warn if the user has enabled an already-stable lib feature.\n+                    unnecessary_stable_feature_lint(tcx, *span, feature, since);\n+                }\n+            }\n+            remaining_lib_features.remove(&feature);\n+            if remaining_lib_features.is_empty() {\n+                break;\n+            }\n+        }\n+    };\n+\n+    // We always collect the lib features declared in the current crate, even if there are\n+    // no unknown features, because the collection also does feature attribute validation.\n+    let local_defined_features = tcx.lib_features().to_vec();\n+    if !remaining_lib_features.is_empty() {\n+        check_features(&mut remaining_lib_features, &local_defined_features);\n+\n+        for &cnum in &*tcx.crates() {\n+            if remaining_lib_features.is_empty() {\n+                break;\n+            }\n+            check_features(&mut remaining_lib_features, tcx.defined_lib_features(cnum));\n+        }\n+    }\n+\n+    for (feature, span) in remaining_lib_features {\n+        struct_span_err!(tcx.sess, span, E0635, \"unknown feature `{}`\", feature).emit();\n+    }\n+\n+    // FIXME(#44232): the `used_features` table no longer exists, so we\n+    // don't lint about unused features. We should reenable this one day!\n+}\n+\n+fn unnecessary_stable_feature_lint(tcx: TyCtxt<'_>, span: Span, feature: Symbol, since: Symbol) {\n+    tcx.lint_hir(\n+        lint::builtin::STABLE_FEATURES,\n+        hir::CRATE_HIR_ID,\n+        span,\n+        &format!(\n+            \"the feature `{}` has been stable since {} and no longer requires \\\n+                  an attribute to enable\",\n+            feature, since\n+        ),\n+    );\n+}\n+\n+fn duplicate_feature_err(sess: &Session, span: Span, feature: Symbol) {\n+    struct_span_err!(sess, span, E0636, \"the feature `{}` has already been declared\", feature)\n+        .emit();\n+}"}]}