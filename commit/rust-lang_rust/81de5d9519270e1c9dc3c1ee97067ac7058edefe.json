{"sha": "81de5d9519270e1c9dc3c1ee97067ac7058edefe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZGU1ZDk1MTkyNzBlMWM5ZGMzYzFlZTk3MDY3YWM3MDU4ZWRlZmU=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2018-12-06T18:26:11Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2018-12-10T19:09:50Z"}, "message": "Remove dependency on shell32.dll #56510", "tree": {"sha": "ecdc74cd976281003c970e2d568cd381f3d40fb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecdc74cd976281003c970e2d568cd381f3d40fb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81de5d9519270e1c9dc3c1ee97067ac7058edefe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81de5d9519270e1c9dc3c1ee97067ac7058edefe", "html_url": "https://github.com/rust-lang/rust/commit/81de5d9519270e1c9dc3c1ee97067ac7058edefe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81de5d9519270e1c9dc3c1ee97067ac7058edefe/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1137d29d5e551e377579c5a601fe7c444057d00c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1137d29d5e551e377579c5a601fe7c444057d00c", "html_url": "https://github.com/rust-lang/rust/commit/1137d29d5e551e377579c5a601fe7c444057d00c"}], "stats": {"total": 250, "additions": 207, "deletions": 43}, "files": [{"sha": "8641f28b23fa3f0bab40f050b758632aafffd4a1", "filename": "src/libstd/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=81de5d9519270e1c9dc3c1ee97067ac7058edefe", "patch": "@@ -68,7 +68,6 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=advapi32\");\n         println!(\"cargo:rustc-link-lib=ws2_32\");\n         println!(\"cargo:rustc-link-lib=userenv\");\n-        println!(\"cargo:rustc-link-lib=shell32\");\n     } else if target.contains(\"fuchsia\") {\n         println!(\"cargo:rustc-link-lib=zircon\");\n         println!(\"cargo:rustc-link-lib=fdio\");"}, {"sha": "3eea9b19b6f9d18f5e91a03d3d9a044e8880b9e5", "filename": "src/libstd/sys/windows/args.rs", "status": "modified", "additions": 206, "deletions": 38, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=81de5d9519270e1c9dc3c1ee97067ac7058edefe", "patch": "@@ -11,33 +11,161 @@\n #![allow(dead_code)] // runtime init functions not used during testing\n \n use os::windows::prelude::*;\n+use sys::windows::os::current_exe;\n use sys::c;\n-use slice;\n-use ops::Range;\n use ffi::OsString;\n-use libc::{c_int, c_void};\n use fmt;\n+use collections::VecDeque;\n+use core::iter;\n+use slice;\n+use path::PathBuf;\n \n pub unsafe fn init(_argc: isize, _argv: *const *const u8) { }\n \n pub unsafe fn cleanup() { }\n \n pub fn args() -> Args {\n     unsafe {\n-        let mut nArgs: c_int = 0;\n-        let lpCmdLine = c::GetCommandLineW();\n-        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n-\n-        // szArcList can be NULL if CommandLinToArgvW failed,\n-        // but in that case nArgs is 0 so we won't actually\n-        // try to read a null pointer\n-        Args { cur: szArgList, range: 0..(nArgs as isize) }\n+        let lp_cmd_line = c::GetCommandLineW();\n+        let parsed_args_list = parse_lp_cmd_line(\n+            lp_cmd_line as *const u16,\n+            || current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new()));\n+\n+        Args { parsed_args_list: parsed_args_list }\n     }\n }\n \n+/// Implements the Windows command-line argument parsing algorithm, described at\n+/// <https://docs.microsoft.com/en-us/previous-versions//17w5ykft(v=vs.85)>.\n+///\n+/// Windows includes a function to do this in shell32.dll,\n+/// but linking with that DLL causes the process to be registered as a GUI application.\n+/// GUI applications add a bunch of overhead, even if no windows are drawn. See\n+/// <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>.\n+unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_name: F)\n+                                                 -> VecDeque<OsString> {\n+    const BACKSLASH: u16 = '\\\\' as u16;\n+    const QUOTE: u16 = '\"' as u16;\n+    const TAB: u16 = '\\t' as u16;\n+    const SPACE: u16 = ' ' as u16;\n+    let mut in_quotes = false;\n+    let mut was_in_quotes = false;\n+    let mut backslash_count: usize = 0;\n+    let mut ret_val = VecDeque::new();\n+    let mut cur = Vec::new();\n+    if lp_cmd_line.is_null() || *lp_cmd_line == 0 {\n+        ret_val.push_back(exe_name());\n+        return ret_val;\n+    }\n+    let mut i = 0;\n+    // The executable name at the beginning is special.\n+    match *lp_cmd_line {\n+        // The executable name ends at the next quote mark,\n+        // no matter what.\n+        QUOTE => {\n+            loop {\n+                i += 1;\n+                if *lp_cmd_line.offset(i) == 0 {\n+                    ret_val.push_back(OsString::from_wide(\n+                        slice::from_raw_parts(lp_cmd_line.offset(1), i as usize - 1)\n+                    ));\n+                    return ret_val;\n+                }\n+                if *lp_cmd_line.offset(i) == QUOTE {\n+                    break;\n+                }\n+            }\n+            ret_val.push_back(OsString::from_wide(\n+                slice::from_raw_parts(lp_cmd_line.offset(1), i as usize - 1)\n+            ));\n+            i += 1;\n+        }\n+        // Implement quirk: when they say whitespace here,\n+        // they include the entire ASCII control plane:\n+        // \"However, if lpCmdLine starts with any amount of whitespace, CommandLineToArgvW\n+        // will consider the first argument to be an empty string. Excess whitespace at the\n+        // end of lpCmdLine is ignored.\"\n+        0...SPACE => {\n+            ret_val.push_back(OsString::new());\n+            i += 1;\n+        },\n+        // The executable name ends at the next quote mark,\n+        // no matter what.\n+        _ => {\n+            loop {\n+                i += 1;\n+                if *lp_cmd_line.offset(i) == 0 {\n+                    ret_val.push_back(OsString::from_wide(\n+                        slice::from_raw_parts(lp_cmd_line, i as usize)\n+                    ));\n+                    return ret_val;\n+                }\n+                if let 0...SPACE = *lp_cmd_line.offset(i) {\n+                    break;\n+                }\n+            }\n+            ret_val.push_back(OsString::from_wide(\n+                slice::from_raw_parts(lp_cmd_line, i as usize)\n+            ));\n+            i += 1;\n+        }\n+    }\n+    loop {\n+        let c = *lp_cmd_line.offset(i);\n+        match c {\n+            // backslash\n+            BACKSLASH => {\n+                backslash_count += 1;\n+                was_in_quotes = false;\n+            },\n+            QUOTE if backslash_count % 2 == 0 => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n+                backslash_count = 0;\n+                if was_in_quotes {\n+                    cur.push('\"' as u16);\n+                    was_in_quotes = false;\n+                } else {\n+                    was_in_quotes = in_quotes;\n+                    in_quotes = !in_quotes;\n+                }\n+            }\n+            QUOTE if backslash_count % 2 != 0 => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n+                backslash_count = 0;\n+                was_in_quotes = false;\n+                cur.push(b'\"' as u16);\n+            }\n+            SPACE | TAB if !in_quotes => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n+                if !cur.is_empty() || was_in_quotes {\n+                    ret_val.push_back(OsString::from_wide(&cur[..]));\n+                    cur.truncate(0);\n+                }\n+                backslash_count = 0;\n+                was_in_quotes = false;\n+            }\n+            0x00 => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n+                // include empty quoted strings at the end of the arguments list\n+                if !cur.is_empty() || was_in_quotes || in_quotes {\n+                    ret_val.push_back(OsString::from_wide(&cur[..]));\n+                }\n+                break;\n+            }\n+            _ => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n+                backslash_count = 0;\n+                was_in_quotes = false;\n+                cur.push(c);\n+            }\n+        }\n+        i += 1;\n+    }\n+    ret_val\n+}\n+\n pub struct Args {\n-    range: Range<isize>,\n-    cur: *mut *mut u16,\n+    parsed_args_list: VecDeque<OsString>,\n }\n \n pub struct ArgsInnerDebug<'a> {\n@@ -48,14 +176,13 @@ impl<'a> fmt::Debug for ArgsInnerDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"[\")?;\n         let mut first = true;\n-        for i in self.args.range.clone() {\n+        for i in &self.args.parsed_args_list {\n             if !first {\n                 f.write_str(\", \")?;\n             }\n             first = false;\n \n-            // Here we do allocation which could be avoided.\n-            fmt::Debug::fmt(&unsafe { os_string_from_ptr(*self.args.cur.offset(i)) }, f)?;\n+            fmt::Debug::fmt(i, f)?;\n         }\n         f.write_str(\"]\")?;\n         Ok(())\n@@ -70,38 +197,79 @@ impl Args {\n     }\n }\n \n-unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString {\n-    let mut len = 0;\n-    while *ptr.offset(len) != 0 { len += 1; }\n-\n-    // Push it onto the list.\n-    let ptr = ptr as *const u16;\n-    let buf = slice::from_raw_parts(ptr, len as usize);\n-    OsStringExt::from_wide(buf)\n-}\n-\n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> {\n-        self.range.next().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n+    fn next(&mut self) -> Option<OsString> { self.parsed_args_list.pop_front() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.parsed_args_list.len(), Some(self.parsed_args_list.len()))\n     }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> {\n-        self.range.next_back().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n-    }\n+    fn next_back(&mut self) -> Option<OsString> { self.parsed_args_list.pop_back() }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.range.len() }\n+    fn len(&self) -> usize { self.parsed_args_list.len() }\n }\n \n-impl Drop for Args {\n-    fn drop(&mut self) {\n-        // self.cur can be null if CommandLineToArgvW previously failed,\n-        // but LocalFree ignores NULL pointers\n-        unsafe { c::LocalFree(self.cur as *mut c_void); }\n+#[cfg(test)]\n+mod tests {\n+    use sys::windows::args::*;\n+    use ffi::OsString;\n+\n+    fn chk(string: &str, parts: &[&str]) {\n+        let mut wide: Vec<u16> = OsString::from(string).encode_wide().collect();\n+        wide.push(0);\n+        let parsed = unsafe {\n+            parse_lp_cmd_line(wide.as_ptr() as *const u16, || OsString::from(\"TEST.EXE\"))\n+        };\n+        let expected: Vec<OsString> = parts.iter().map(|k| OsString::from(k)).collect();\n+        assert_eq!(parsed, expected);\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        chk(\"\", &[\"TEST.EXE\"]);\n+        chk(\"\\0\", &[\"TEST.EXE\"]);\n+    }\n+\n+    #[test]\n+    fn single_words() {\n+        chk(\"EXE one_word\", &[\"EXE\", \"one_word\"]);\n+        chk(\"EXE a\", &[\"EXE\", \"a\"]);\n+        chk(\"EXE \ud83d\ude05\", &[\"EXE\", \"\ud83d\ude05\"]);\n+        chk(\"EXE \ud83d\ude05\ud83e\udd26\", &[\"EXE\", \"\ud83d\ude05\ud83e\udd26\"]);\n+    }\n+\n+    #[test]\n+    fn official_examples() {\n+        chk(r#\"EXE \"abc\" d e\"#, &[\"EXE\", \"abc\", \"d\", \"e\"]);\n+        chk(r#\"EXE a\\\\\\b d\"e f\"g h\"#, &[\"EXE\", r#\"a\\\\\\b\"#, \"de fg\", \"h\"]);\n+        chk(r#\"EXE a\\\\\\\"b c d\"#, &[\"EXE\", r#\"a\\\"b\"#, \"c\", \"d\"]);\n+        chk(r#\"EXE a\\\\\\\\\"b c\" d e\"#, &[\"EXE\", r#\"a\\\\b c\"#, \"d\", \"e\"]);\n+    }\n+\n+    #[test]\n+    fn whitespace_behavior() {\n+        chk(r#\" test\"#, &[\"\", \"test\"]);\n+        chk(r#\"  test\"#, &[\"\", \"test\"]);\n+        chk(r#\" test test2\"#, &[\"\", \"test\", \"test2\"]);\n+        chk(r#\" test  test2\"#, &[\"\", \"test\", \"test2\"]);\n+        chk(r#\"test test2 \"#, &[\"test\", \"test2\"]);\n+        chk(r#\"test  test2 \"#, &[\"test\", \"test2\"]);\n+        chk(r#\"test \"#, &[\"test\"]);\n+    }\n+\n+    #[test]\n+    fn genius_quotes() {\n+        chk(r#\"EXE \"\" \"\"\"#, &[\"EXE\", \"\", \"\"]);\n+        chk(r#\"EXE \"\" \"\"\"\"#, &[\"EXE\", \"\", \"\\\"\"]);\n+        chk(\n+            r#\"EXE \"this is \"\"\"all\"\"\" in the same argument\"\"#,\n+            &[\"EXE\", \"this is \\\"all\\\" in the same argument\"]\n+        );\n+        chk(r#\"EXE \"\\u{1}\"\"\"#, &[\"EXE\", \"\\u{1}\\\"\"]);\n+        chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", \"a\\\"\", \"a\"]);\n     }\n }"}, {"sha": "fa21f459a8a85754f67ad6541f3a2c688c25adc3", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=81de5d9519270e1c9dc3c1ee97067ac7058edefe", "patch": "@@ -1035,9 +1035,6 @@ extern \"system\" {\n \n     pub fn SetLastError(dwErrCode: DWORD);\n     pub fn GetCommandLineW() -> *mut LPCWSTR;\n-    pub fn LocalFree(ptr: *mut c_void);\n-    pub fn CommandLineToArgvW(lpCmdLine: *mut LPCWSTR,\n-                              pNumArgs: *mut c_int) -> *mut *mut u16;\n     pub fn GetTempPathW(nBufferLength: DWORD,\n                         lpBuffer: LPCWSTR) -> DWORD;\n     pub fn OpenProcessToken(ProcessHandle: HANDLE,"}, {"sha": "79399281804fb2cd8c682db02857c242645c94d1", "filename": "src/test/run-make-fulldeps/tools.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/81de5d9519270e1c9dc3c1ee97067ac7058edefe/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk?ref=81de5d9519270e1c9dc3c1ee97067ac7058edefe", "patch": "@@ -76,7 +76,7 @@ endif\n # Extra flags needed to compile a working executable with the standard library\n ifdef IS_WINDOWS\n ifdef IS_MSVC\n-\tEXTRACFLAGS := ws2_32.lib userenv.lib shell32.lib advapi32.lib\n+\tEXTRACFLAGS := ws2_32.lib userenv.lib advapi32.lib\n else\n \tEXTRACFLAGS := -lws2_32 -luserenv\n endif"}]}