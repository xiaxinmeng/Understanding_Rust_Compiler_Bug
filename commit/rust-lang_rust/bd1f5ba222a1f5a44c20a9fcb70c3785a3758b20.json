{"sha": "bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMWY1YmEyMjJhMWY1YTQ0YzIwYTlmY2I3MGMzNzg1YTM3NThiMjA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-02T07:03:19Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-02T07:03:19Z"}, "message": "move ast traits to a separate file", "tree": {"sha": "2fee5aa024ffdeaf16c76f9ef83cdce2c58462f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fee5aa024ffdeaf16c76f9ef83cdce2c58462f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20", "html_url": "https://github.com/rust-lang/rust/commit/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2912892effbcf24d94da235b9ac0d2a7fccea5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2912892effbcf24d94da235b9ac0d2a7fccea5d", "html_url": "https://github.com/rust-lang/rust/commit/c2912892effbcf24d94da235b9ac0d2a7fccea5d"}], "stats": {"total": 299, "additions": 155, "deletions": 144}, "files": [{"sha": "3e81fa99017354936cc0b06e6926988a1a92c7e2", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 7, "deletions": 144, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20", "patch": "@@ -1,17 +1,22 @@\n //! Abstract Syntax Tree, layered on top of untyped `SyntaxNode`s\n mod generated;\n+mod traits;\n \n use std::marker::PhantomData;\n \n use itertools::Itertools;\n \n-pub use self::generated::*;\n use crate::{\n-    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken, SyntaxElement, SyntaxElementChildren},\n+    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken, SyntaxElement},\n     SmolStr,\n     SyntaxKind::*,\n };\n \n+pub use self::{\n+    generated::*,\n+    traits::*,\n+};\n+\n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n@@ -25,137 +30,6 @@ pub trait AstNode:\n     fn syntax(&self) -> &SyntaxNode;\n }\n \n-pub trait TypeAscriptionOwner: AstNode {\n-    fn ascribed_type(&self) -> Option<&TypeRef> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait NameOwner: AstNode {\n-    fn name(&self) -> Option<&Name> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait VisibilityOwner: AstNode {\n-    fn visibility(&self) -> Option<&Visibility> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait LoopBodyOwner: AstNode {\n-    fn loop_body(&self) -> Option<&Block> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait ArgListOwner: AstNode {\n-    fn arg_list(&self) -> Option<&ArgList> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait FnDefOwner: AstNode {\n-    fn functions(&self) -> AstChildren<FnDef> {\n-        children(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ItemOrMacro<'a> {\n-    Item(&'a ModuleItem),\n-    Macro(&'a MacroCall),\n-}\n-\n-pub trait ModuleItemOwner: AstNode {\n-    fn items(&self) -> AstChildren<ModuleItem> {\n-        children(self)\n-    }\n-    fn items_with_macros(&self) -> ItemOrMacroIter {\n-        ItemOrMacroIter(self.syntax().children())\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n-\n-impl<'a> Iterator for ItemOrMacroIter<'a> {\n-    type Item = ItemOrMacro<'a>;\n-    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n-        loop {\n-            let n = self.0.next()?;\n-            if let Some(item) = ModuleItem::cast(n) {\n-                return Some(ItemOrMacro::Item(item));\n-            }\n-            if let Some(call) = MacroCall::cast(n) {\n-                return Some(ItemOrMacro::Macro(call));\n-            }\n-        }\n-    }\n-}\n-\n-pub trait TypeParamsOwner: AstNode {\n-    fn type_param_list(&self) -> Option<&TypeParamList> {\n-        child_opt(self)\n-    }\n-\n-    fn where_clause(&self) -> Option<&WhereClause> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait TypeBoundsOwner: AstNode {\n-    fn type_bound_list(&self) -> Option<&TypeBoundList> {\n-        child_opt(self)\n-    }\n-}\n-\n-pub trait AttrsOwner: AstNode {\n-    fn attrs(&self) -> AstChildren<Attr> {\n-        children(self)\n-    }\n-    fn has_atom_attr(&self, atom: &str) -> bool {\n-        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n-    }\n-}\n-\n-pub trait DocCommentsOwner: AstNode {\n-    fn doc_comments(&self) -> CommentIter {\n-        CommentIter { iter: self.syntax().children_with_tokens() }\n-    }\n-\n-    /// Returns the textual content of a doc comment block as a single string.\n-    /// That is, strips leading `///` (+ optional 1 character of whitespace)\n-    /// and joins lines.\n-    fn doc_comment_text(&self) -> Option<std::string::String> {\n-        let docs = self\n-            .doc_comments()\n-            .filter(|comment| comment.is_doc_comment())\n-            .map(|comment| {\n-                let prefix_len = comment.prefix().len();\n-\n-                let line = comment.text().as_str();\n-\n-                // Determine if the prefix or prefix + 1 char is stripped\n-                let pos =\n-                    if line.chars().nth(prefix_len).map(|c| c.is_whitespace()).unwrap_or(false) {\n-                        prefix_len + 1\n-                    } else {\n-                        prefix_len\n-                    };\n-\n-                line[pos..].to_owned()\n-            })\n-            .join(\"\\n\");\n-\n-        if docs.is_empty() {\n-            None\n-        } else {\n-            Some(docs)\n-        }\n-    }\n-}\n-\n impl Attr {\n     pub fn is_inner(&self) -> bool {\n         let tt = match self.value() {\n@@ -245,17 +119,6 @@ impl<'a> Comment<'a> {\n     }\n }\n \n-pub struct CommentIter<'a> {\n-    iter: SyntaxElementChildren<'a>,\n-}\n-\n-impl<'a> Iterator for CommentIter<'a> {\n-    type Item = Comment<'a>;\n-    fn next(&mut self) -> Option<Comment<'a>> {\n-        self.iter.by_ref().find_map(|el| el.as_token().and_then(Comment::cast))\n-    }\n-}\n-\n #[derive(Debug, PartialEq, Eq)]\n pub enum CommentFlavor {\n     Line,"}, {"sha": "85fe6d5e1c3df7746adc479ba0e79d773351f246", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=bd1f5ba222a1f5a44c20a9fcb70c3785a3758b20", "patch": "@@ -0,0 +1,148 @@\n+use itertools::Itertools;\n+\n+use crate::{\n+    syntax_node::{SyntaxNodeChildren, SyntaxElementChildren},\n+    ast::{self, child_opt, children, AstNode, AstChildren},\n+};\n+\n+pub trait TypeAscriptionOwner: AstNode {\n+    fn ascribed_type(&self) -> Option<&ast::TypeRef> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait NameOwner: AstNode {\n+    fn name(&self) -> Option<&ast::Name> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait VisibilityOwner: AstNode {\n+    fn visibility(&self) -> Option<&ast::Visibility> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait LoopBodyOwner: AstNode {\n+    fn loop_body(&self) -> Option<&ast::Block> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait ArgListOwner: AstNode {\n+    fn arg_list(&self) -> Option<&ast::ArgList> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait FnDefOwner: AstNode {\n+    fn functions(&self) -> AstChildren<ast::FnDef> {\n+        children(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ItemOrMacro<'a> {\n+    Item(&'a ast::ModuleItem),\n+    Macro(&'a ast::MacroCall),\n+}\n+\n+pub trait ModuleItemOwner: AstNode {\n+    fn items(&self) -> AstChildren<ast::ModuleItem> {\n+        children(self)\n+    }\n+    fn items_with_macros(&self) -> ItemOrMacroIter {\n+        ItemOrMacroIter(self.syntax().children())\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n+\n+impl<'a> Iterator for ItemOrMacroIter<'a> {\n+    type Item = ItemOrMacro<'a>;\n+    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n+        loop {\n+            let n = self.0.next()?;\n+            if let Some(item) = ast::ModuleItem::cast(n) {\n+                return Some(ItemOrMacro::Item(item));\n+            }\n+            if let Some(call) = ast::MacroCall::cast(n) {\n+                return Some(ItemOrMacro::Macro(call));\n+            }\n+        }\n+    }\n+}\n+\n+pub trait TypeParamsOwner: AstNode {\n+    fn type_param_list(&self) -> Option<&ast::TypeParamList> {\n+        child_opt(self)\n+    }\n+\n+    fn where_clause(&self) -> Option<&ast::WhereClause> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait TypeBoundsOwner: AstNode {\n+    fn type_bound_list(&self) -> Option<&ast::TypeBoundList> {\n+        child_opt(self)\n+    }\n+}\n+\n+pub trait AttrsOwner: AstNode {\n+    fn attrs(&self) -> AstChildren<ast::Attr> {\n+        children(self)\n+    }\n+    fn has_atom_attr(&self, atom: &str) -> bool {\n+        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n+    }\n+}\n+\n+pub trait DocCommentsOwner: AstNode {\n+    fn doc_comments(&self) -> CommentIter {\n+        CommentIter { iter: self.syntax().children_with_tokens() }\n+    }\n+\n+    /// Returns the textual content of a doc comment block as a single string.\n+    /// That is, strips leading `///` (+ optional 1 character of whitespace)\n+    /// and joins lines.\n+    fn doc_comment_text(&self) -> Option<std::string::String> {\n+        let docs = self\n+            .doc_comments()\n+            .filter(|comment| comment.is_doc_comment())\n+            .map(|comment| {\n+                let prefix_len = comment.prefix().len();\n+\n+                let line = comment.text().as_str();\n+\n+                // Determine if the prefix or prefix + 1 char is stripped\n+                let pos =\n+                    if line.chars().nth(prefix_len).map(|c| c.is_whitespace()).unwrap_or(false) {\n+                        prefix_len + 1\n+                    } else {\n+                        prefix_len\n+                    };\n+\n+                line[pos..].to_owned()\n+            })\n+            .join(\"\\n\");\n+\n+        if docs.is_empty() {\n+            None\n+        } else {\n+            Some(docs)\n+        }\n+    }\n+}\n+\n+pub struct CommentIter<'a> {\n+    iter: SyntaxElementChildren<'a>,\n+}\n+\n+impl<'a> Iterator for CommentIter<'a> {\n+    type Item = ast::Comment<'a>;\n+    fn next(&mut self) -> Option<ast::Comment<'a>> {\n+        self.iter.by_ref().find_map(|el| el.as_token().and_then(ast::Comment::cast))\n+    }\n+}"}]}