{"sha": "ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMTMxMDQ5YzRjZDEzMDJhZjFhNTYxNmZmODNkMGUxZjBjYWRlYTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-20T15:05:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-20T15:05:33Z"}, "message": "Merge #8600\n\n8600:  fix: no longer get stuck on windows r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ba89d0ef30ef3b4b428f0b007a65ea2cb834ef27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba89d0ef30ef3b4b428f0b007a65ea2cb834ef27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgfu29CRBK7hj4Ov3rIwAAUWsIAEoMfDPQlioBQsWc4gQFcFf1\n60eVK21aKsDWMNZOY2OLxceEm6eDPr0AJtlYpXs7cAmwHF7KlGUNT8IV9waVWGMC\nhXg+uUsiVKJl4VdHmWGwhUzyFJI1FKHsAi9ApQm7oUnux5IxvIc8gNHEzn595VGM\nAGzkYlF1JgRDzMDfwecPuolCEF+0PlCTnKaTdqqo4k/volN4TX7vR0/XQTMEY36Z\nsvjhw1zWl+fGBKN2F2KlLQoL8D3sM16UNAZklDUCQVtV5n1QfWD75rNcLukwh0le\nKtqUQneETRd0yR0AFz2oaGieUQIwJUKPmHZZqigFrqGOSMHQR3ngKF5o+lPrmek=\n=yFQ6\n-----END PGP SIGNATURE-----\n", "payload": "tree ba89d0ef30ef3b4b428f0b007a65ea2cb834ef27\nparent 86c2bb3c5be34c502634840da7cc8a147ac0e264\nparent 1772eb0f1a5c714c91f8ae45cc67cbae6b7ff348\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618931133 +0000\ncommitter GitHub <noreply@github.com> 1618931133 +0000\n\nMerge #8600\n\n8600:  fix: no longer get stuck on windows r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "html_url": "https://github.com/rust-lang/rust/commit/ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86c2bb3c5be34c502634840da7cc8a147ac0e264", "url": "https://api.github.com/repos/rust-lang/rust/commits/86c2bb3c5be34c502634840da7cc8a147ac0e264", "html_url": "https://github.com/rust-lang/rust/commit/86c2bb3c5be34c502634840da7cc8a147ac0e264"}, {"sha": "1772eb0f1a5c714c91f8ae45cc67cbae6b7ff348", "url": "https://api.github.com/repos/rust-lang/rust/commits/1772eb0f1a5c714c91f8ae45cc67cbae6b7ff348", "html_url": "https://github.com/rust-lang/rust/commit/1772eb0f1a5c714c91f8ae45cc67cbae6b7ff348"}], "stats": {"total": 395, "additions": 330, "deletions": 65}, "files": [{"sha": "14decc14ead002cb955db2d0bec0d2d199da1108", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "patch": "@@ -1573,6 +1573,9 @@ version = \"0.0.0\"\n dependencies = [\n  \"always-assert\",\n  \"backtrace\",\n+ \"libc\",\n+ \"miow\",\n+ \"winapi\",\n ]\n \n [[package]]"}, {"sha": "faca336de03a203fe17a933784c5937211e9a0a5", "filename": "crates/project_model/src/build_data.rs", "status": "modified", "additions": 76, "deletions": 58, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs?ref=ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "patch": "@@ -1,7 +1,6 @@\n //! Handles build script specific information\n \n use std::{\n-    io::BufReader,\n     path::PathBuf,\n     process::{Command, Stdio},\n     sync::Arc,\n@@ -13,7 +12,8 @@ use cargo_metadata::{BuildScript, Message};\n use itertools::Itertools;\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n-use stdx::{format_to, JodChild};\n+use serde::Deserialize;\n+use stdx::format_to;\n \n use crate::{cfg_flag::CfgFlag, CargoConfig};\n \n@@ -171,67 +171,86 @@ impl WorkspaceBuildData {\n \n         cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n \n-        let mut child = cmd.spawn().map(JodChild)?;\n-        let child_stdout = child.stdout.take().unwrap();\n-        let stdout = BufReader::new(child_stdout);\n-\n         let mut res = WorkspaceBuildData::default();\n-        for message in cargo_metadata::Message::parse_stream(stdout).flatten() {\n-            match message {\n-                Message::BuildScriptExecuted(BuildScript {\n-                    package_id,\n-                    out_dir,\n-                    cfgs,\n-                    env,\n-                    ..\n-                }) => {\n-                    let cfgs = {\n-                        let mut acc = Vec::new();\n-                        for cfg in cfgs {\n-                            match cfg.parse::<CfgFlag>() {\n-                                Ok(it) => acc.push(it),\n-                                Err(err) => {\n-                                    anyhow::bail!(\"invalid cfg from cargo-metadata: {}\", err)\n-                                }\n-                            };\n-                        }\n-                        acc\n-                    };\n-                    let package_build_data =\n-                        res.per_package.entry(package_id.repr.clone()).or_default();\n-                    // cargo_metadata crate returns default (empty) path for\n-                    // older cargos, which is not absolute, so work around that.\n-                    if !out_dir.as_str().is_empty() {\n-                        let out_dir = AbsPathBuf::assert(PathBuf::from(out_dir.into_os_string()));\n-                        package_build_data.out_dir = Some(out_dir);\n-                        package_build_data.cfgs = cfgs;\n-                    }\n \n-                    package_build_data.envs = env;\n+        let mut callback_err = None;\n+        let output = stdx::process::streaming_output(\n+            cmd,\n+            &mut |line| {\n+                if callback_err.is_some() {\n+                    return;\n                 }\n-                Message::CompilerArtifact(message) => {\n-                    progress(format!(\"metadata {}\", message.target.name));\n-\n-                    if message.target.kind.contains(&\"proc-macro\".to_string()) {\n-                        let package_id = message.package_id;\n-                        // Skip rmeta file\n-                        if let Some(filename) = message.filenames.iter().find(|name| is_dylib(name))\n-                        {\n-                            let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n-                            let package_build_data =\n-                                res.per_package.entry(package_id.repr.clone()).or_default();\n-                            package_build_data.proc_macro_dylib_path = Some(filename);\n+\n+                // Copy-pasted from existing cargo_metadata. It seems like we\n+                // should be using sered_stacker here?\n+                let mut deserializer = serde_json::Deserializer::from_str(&line);\n+                deserializer.disable_recursion_limit();\n+                let message = Message::deserialize(&mut deserializer)\n+                    .unwrap_or(Message::TextLine(line.to_string()));\n+\n+                match message {\n+                    Message::BuildScriptExecuted(BuildScript {\n+                        package_id,\n+                        out_dir,\n+                        cfgs,\n+                        env,\n+                        ..\n+                    }) => {\n+                        let cfgs = {\n+                            let mut acc = Vec::new();\n+                            for cfg in cfgs {\n+                                match cfg.parse::<CfgFlag>() {\n+                                    Ok(it) => acc.push(it),\n+                                    Err(err) => {\n+                                        callback_err = Some(anyhow::format_err!(\n+                                            \"invalid cfg from cargo-metadata: {}\",\n+                                            err\n+                                        ));\n+                                        return;\n+                                    }\n+                                };\n+                            }\n+                            acc\n+                        };\n+                        let package_build_data =\n+                            res.per_package.entry(package_id.repr.clone()).or_default();\n+                        // cargo_metadata crate returns default (empty) path for\n+                        // older cargos, which is not absolute, so work around that.\n+                        if !out_dir.as_str().is_empty() {\n+                            let out_dir =\n+                                AbsPathBuf::assert(PathBuf::from(out_dir.into_os_string()));\n+                            package_build_data.out_dir = Some(out_dir);\n+                            package_build_data.cfgs = cfgs;\n                         }\n+\n+                        package_build_data.envs = env;\n                     }\n+                    Message::CompilerArtifact(message) => {\n+                        progress(format!(\"metadata {}\", message.target.name));\n+\n+                        if message.target.kind.contains(&\"proc-macro\".to_string()) {\n+                            let package_id = message.package_id;\n+                            // Skip rmeta file\n+                            if let Some(filename) =\n+                                message.filenames.iter().find(|name| is_dylib(name))\n+                            {\n+                                let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n+                                let package_build_data =\n+                                    res.per_package.entry(package_id.repr.clone()).or_default();\n+                                package_build_data.proc_macro_dylib_path = Some(filename);\n+                            }\n+                        }\n+                    }\n+                    Message::CompilerMessage(message) => {\n+                        progress(message.target.name.clone());\n+                    }\n+                    Message::BuildFinished(_) => {}\n+                    Message::TextLine(_) => {}\n+                    _ => {}\n                 }\n-                Message::CompilerMessage(message) => {\n-                    progress(message.target.name.clone());\n-                }\n-                Message::BuildFinished(_) => {}\n-                Message::TextLine(_) => {}\n-                _ => {}\n-            }\n-        }\n+            },\n+            &mut |_| (),\n+        )?;\n \n         for package in packages {\n             let package_build_data = res.per_package.entry(package.id.repr.clone()).or_default();\n@@ -244,7 +263,6 @@ impl WorkspaceBuildData {\n             }\n         }\n \n-        let output = child.into_inner().wait_with_output()?;\n         if !output.status.success() {\n             let mut stderr = String::from_utf8(output.stderr).unwrap_or_default();\n             if stderr.is_empty() {"}, {"sha": "f78c5da7c82af34458498038798f58055bd4e7da", "filename": "crates/stdx/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2FCargo.toml?ref=ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "patch": "@@ -10,10 +10,15 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+libc = \"0.2.93\"\n backtrace = { version = \"0.3.44\", optional = true }\n always-assert = { version = \"0.1.2\", features = [\"log\"] }\n # Think twice before adding anything here\n \n+[target.'cfg(windows)'.dependencies]\n+miow = \"0.3.6\"\n+winapi = \"0.3.9\"\n+\n [features]\n # Uncomment to enable for the whole crate graph\n # default = [ \"backtrace\" ]"}, {"sha": "e3eb109156ce11bf35a82e22e776710b9672b74f", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "patch": "@@ -1,7 +1,8 @@\n //! Missing batteries for standard libraries.\n-use std::{cmp::Ordering, ops, process, time::Instant};\n+use std::{cmp::Ordering, ops, time::Instant};\n \n mod macros;\n+pub mod process;\n pub mod panic_context;\n \n pub use always_assert::{always, never};\n@@ -179,17 +180,17 @@ where\n }\n \n #[repr(transparent)]\n-pub struct JodChild(pub process::Child);\n+pub struct JodChild(pub std::process::Child);\n \n impl ops::Deref for JodChild {\n-    type Target = process::Child;\n-    fn deref(&self) -> &process::Child {\n+    type Target = std::process::Child;\n+    fn deref(&self) -> &std::process::Child {\n         &self.0\n     }\n }\n \n impl ops::DerefMut for JodChild {\n-    fn deref_mut(&mut self) -> &mut process::Child {\n+    fn deref_mut(&mut self) -> &mut std::process::Child {\n         &mut self.0\n     }\n }\n@@ -202,9 +203,9 @@ impl Drop for JodChild {\n }\n \n impl JodChild {\n-    pub fn into_inner(self) -> process::Child {\n+    pub fn into_inner(self) -> std::process::Child {\n         // SAFETY: repr transparent\n-        unsafe { std::mem::transmute::<JodChild, process::Child>(self) }\n+        unsafe { std::mem::transmute::<JodChild, std::process::Child>(self) }\n     }\n }\n "}, {"sha": "b0fa12f762d2eb9f9cb229e8686f9066027968ac", "filename": "crates/stdx/src/process.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fstdx%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad131049c4cd1302af1a5616ff83d0e1f0cadea2/crates%2Fstdx%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fprocess.rs?ref=ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "patch": "@@ -0,0 +1,238 @@\n+//! Read both stdout and stderr of child without deadlocks.\n+//!\n+//! https://github.com/rust-lang/cargo/blob/905af549966f23a9288e9993a85d1249a5436556/crates/cargo-util/src/read2.rs\n+//! https://github.com/rust-lang/cargo/blob/58a961314437258065e23cb6316dfc121d96fb71/crates/cargo-util/src/process_builder.rs#L231\n+\n+use std::{\n+    io,\n+    process::{Command, Output, Stdio},\n+};\n+\n+pub fn streaming_output(\n+    mut cmd: Command,\n+    on_stdout_line: &mut dyn FnMut(&str),\n+    on_stderr_line: &mut dyn FnMut(&str),\n+) -> io::Result<Output> {\n+    let mut stdout = Vec::new();\n+    let mut stderr = Vec::new();\n+\n+    let cmd = cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n+\n+    let status = {\n+        let mut child = cmd.spawn()?;\n+        let out = child.stdout.take().unwrap();\n+        let err = child.stderr.take().unwrap();\n+        imp::read2(out, err, &mut |is_out, data, eof| {\n+            let idx = if eof {\n+                data.len()\n+            } else {\n+                match data.iter().rposition(|b| *b == b'\\n') {\n+                    Some(i) => i + 1,\n+                    None => return,\n+                }\n+            };\n+            {\n+                // scope for new_lines\n+                let new_lines = {\n+                    let dst = if is_out { &mut stdout } else { &mut stderr };\n+                    let start = dst.len();\n+                    let data = data.drain(..idx);\n+                    dst.extend(data);\n+                    &dst[start..]\n+                };\n+                for line in String::from_utf8_lossy(new_lines).lines() {\n+                    if is_out {\n+                        on_stdout_line(line)\n+                    } else {\n+                        on_stderr_line(line)\n+                    }\n+                }\n+            }\n+        })?;\n+        child.wait()?\n+    };\n+\n+    Ok(Output { status, stdout, stderr })\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use std::{\n+        io::{self, prelude::*},\n+        mem,\n+        os::unix::prelude::*,\n+        process::{ChildStderr, ChildStdout},\n+    };\n+\n+    pub(crate) fn read2(\n+        mut out_pipe: ChildStdout,\n+        mut err_pipe: ChildStderr,\n+        data: &mut dyn FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n+        unsafe {\n+            libc::fcntl(out_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n+            libc::fcntl(err_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n+        }\n+\n+        let mut out_done = false;\n+        let mut err_done = false;\n+        let mut out = Vec::new();\n+        let mut err = Vec::new();\n+\n+        let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n+        fds[0].fd = out_pipe.as_raw_fd();\n+        fds[0].events = libc::POLLIN;\n+        fds[1].fd = err_pipe.as_raw_fd();\n+        fds[1].events = libc::POLLIN;\n+        let mut nfds = 2;\n+        let mut errfd = 1;\n+\n+        while nfds > 0 {\n+            // wait for either pipe to become readable using `select`\n+            let r = unsafe { libc::poll(fds.as_mut_ptr(), nfds, -1) };\n+            if r == -1 {\n+                let err = io::Error::last_os_error();\n+                if err.kind() == io::ErrorKind::Interrupted {\n+                    continue;\n+                }\n+                return Err(err);\n+            }\n+\n+            // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+            // EAGAIN. If we hit EOF, then this will happen because the underlying\n+            // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+            // this case we flip the other fd back into blocking mode and read\n+            // whatever's leftover on that file descriptor.\n+            let handle = |res: io::Result<_>| match res {\n+                Ok(_) => Ok(true),\n+                Err(e) => {\n+                    if e.kind() == io::ErrorKind::WouldBlock {\n+                        Ok(false)\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            };\n+            if !err_done && fds[errfd].revents != 0 && handle(err_pipe.read_to_end(&mut err))? {\n+                err_done = true;\n+                nfds -= 1;\n+            }\n+            data(false, &mut err, err_done);\n+            if !out_done && fds[0].revents != 0 && handle(out_pipe.read_to_end(&mut out))? {\n+                out_done = true;\n+                fds[0].fd = err_pipe.as_raw_fd();\n+                errfd = 0;\n+                nfds -= 1;\n+            }\n+            data(true, &mut out, out_done);\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use std::{\n+        io,\n+        os::windows::prelude::*,\n+        process::{ChildStderr, ChildStdout},\n+        slice,\n+    };\n+\n+    use miow::{\n+        iocp::{CompletionPort, CompletionStatus},\n+        pipe::NamedPipe,\n+        Overlapped,\n+    };\n+    use winapi::shared::winerror::ERROR_BROKEN_PIPE;\n+\n+    struct Pipe<'a> {\n+        dst: &'a mut Vec<u8>,\n+        overlapped: Overlapped,\n+        pipe: NamedPipe,\n+        done: bool,\n+    }\n+\n+    pub(crate) fn read2(\n+        out_pipe: ChildStdout,\n+        err_pipe: ChildStderr,\n+        data: &mut dyn FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n+        let mut out = Vec::new();\n+        let mut err = Vec::new();\n+\n+        let port = CompletionPort::new(1)?;\n+        port.add_handle(0, &out_pipe)?;\n+        port.add_handle(1, &err_pipe)?;\n+\n+        unsafe {\n+            let mut out_pipe = Pipe::new(out_pipe, &mut out);\n+            let mut err_pipe = Pipe::new(err_pipe, &mut err);\n+\n+            out_pipe.read()?;\n+            err_pipe.read()?;\n+\n+            let mut status = [CompletionStatus::zero(), CompletionStatus::zero()];\n+\n+            while !out_pipe.done || !err_pipe.done {\n+                for status in port.get_many(&mut status, None)? {\n+                    if status.token() == 0 {\n+                        out_pipe.complete(status);\n+                        data(true, out_pipe.dst, out_pipe.done);\n+                        out_pipe.read()?;\n+                    } else {\n+                        err_pipe.complete(status);\n+                        data(false, err_pipe.dst, err_pipe.done);\n+                        err_pipe.read()?;\n+                    }\n+                }\n+            }\n+\n+            Ok(())\n+        }\n+    }\n+\n+    impl<'a> Pipe<'a> {\n+        unsafe fn new<P: IntoRawHandle>(p: P, dst: &'a mut Vec<u8>) -> Pipe<'a> {\n+            Pipe {\n+                dst,\n+                pipe: NamedPipe::from_raw_handle(p.into_raw_handle()),\n+                overlapped: Overlapped::zero(),\n+                done: false,\n+            }\n+        }\n+\n+        unsafe fn read(&mut self) -> io::Result<()> {\n+            let dst = slice_to_end(self.dst);\n+            match self.pipe.read_overlapped(dst, self.overlapped.raw()) {\n+                Ok(_) => Ok(()),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(ERROR_BROKEN_PIPE as i32) {\n+                        self.done = true;\n+                        Ok(())\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        }\n+\n+        unsafe fn complete(&mut self, status: &CompletionStatus) {\n+            let prev = self.dst.len();\n+            self.dst.set_len(prev + status.bytes_transferred() as usize);\n+            if status.bytes_transferred() == 0 {\n+                self.done = true;\n+            }\n+        }\n+    }\n+\n+    unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n+        if v.capacity() == 0 {\n+            v.reserve(16);\n+        }\n+        if v.capacity() == v.len() {\n+            v.reserve(1);\n+        }\n+        slice::from_raw_parts_mut(v.as_mut_ptr().add(v.len()), v.capacity() - v.len())\n+    }\n+}"}]}