{"sha": "7b58193f90185a5730732a727362576a9bdca26b", "node_id": "C_kwDOAAsO6NoAKDdiNTgxOTNmOTAxODVhNTczMDczMmE3MjczNjI1NzZhOWJkY2EyNmI", "commit": {"author": {"name": "CAD97", "email": "cad97@cad97.com", "date": "2022-03-25T05:57:05Z"}, "committer": {"name": "CAD97", "email": "cad97@cad97.com", "date": "2022-03-25T05:57:05Z"}, "message": "Adjust tests for isize::MAX allocation always being checked", "tree": {"sha": "9314100ce43ee0729846ed5d5cfbc9dde8fefd47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9314100ce43ee0729846ed5d5cfbc9dde8fefd47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b58193f90185a5730732a727362576a9bdca26b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b58193f90185a5730732a727362576a9bdca26b", "html_url": "https://github.com/rust-lang/rust/commit/7b58193f90185a5730732a727362576a9bdca26b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b58193f90185a5730732a727362576a9bdca26b/comments", "author": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cd49a0fa8599bbf1705fede777ec2e82b7e3239", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd49a0fa8599bbf1705fede777ec2e82b7e3239", "html_url": "https://github.com/rust-lang/rust/commit/3cd49a0fa8599bbf1705fede777ec2e82b7e3239"}], "stats": {"total": 453, "additions": 142, "deletions": 311}, "files": [{"sha": "99d1296a4c92564faf34bd1f8fdfc3542c57a7c5", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 38, "deletions": 88, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7b58193f90185a5730732a727362576a9bdca26b/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b58193f90185a5730732a727362576a9bdca26b/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=7b58193f90185a5730732a727362576a9bdca26b", "patch": "@@ -693,12 +693,6 @@ fn test_try_reserve() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n-    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n-    // Any platform that succeeds for these requests is technically broken with\n-    // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = usize::BITS < 64;\n-\n     {\n         // Note: basic stuff is checked by test_reserve\n         let mut empty_string: String = String::new();\n@@ -712,35 +706,19 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            // Check isize::MAX + 1 does count as overflow\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            // Check usize::MAX does count as overflow\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX + 1 is an OOM\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            // Check usize::MAX is an OOM\n-            assert_matches!(\n-                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        // Check isize::MAX + 1 does count as overflow\n+        assert_matches!(\n+            empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        // Check usize::MAX does count as overflow\n+        assert_matches!(\n+            empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -753,19 +731,13 @@ fn test_try_reserve() {\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should always overflow in the add-to-len\n         assert_matches!(\n             ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n@@ -785,8 +757,6 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = usize::BITS < 64;\n-\n     {\n         let mut empty_string: String = String::new();\n \n@@ -799,31 +769,17 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            assert_matches!(\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        assert_matches!(\n+            empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        assert_matches!(\n+            empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -839,19 +795,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n             Err(CapacityOverflow),"}, {"sha": "2f93250bce24aea0091776d69b47e534c63b6303", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 52, "deletions": 114, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/7b58193f90185a5730732a727362576a9bdca26b/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b58193f90185a5730732a727362576a9bdca26b/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=7b58193f90185a5730732a727362576a9bdca26b", "patch": "@@ -1489,12 +1489,6 @@ fn test_try_reserve() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n-    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n-    // Any platform that succeeds for these requests is technically broken with\n-    // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = usize::BITS < 64;\n-\n     {\n         // Note: basic stuff is checked by test_reserve\n         let mut empty_bytes: Vec<u8> = Vec::new();\n@@ -1508,35 +1502,19 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            // Check isize::MAX + 1 does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            // Check usize::MAX does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX + 1 is an OOM\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            // Check usize::MAX is an OOM\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        // Check isize::MAX + 1 does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        // Check usize::MAX does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1549,19 +1527,13 @@ fn test_try_reserve() {\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should always overflow in the add-to-len\n         assert_matches!(\n             ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n@@ -1582,19 +1554,13 @@ fn test_try_reserve() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should fail in the mul-by-size\n         assert_matches!(\n             ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n@@ -1614,8 +1580,6 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = size_of::<usize>() < 8;\n-\n     {\n         let mut empty_bytes: Vec<u8> = Vec::new();\n \n@@ -1628,31 +1592,17 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"usize::MAX should trigger an OOM!\"\n-            );\n-        }\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1668,19 +1618,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n             Err(CapacityOverflow),\n@@ -1701,19 +1645,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n             Err(CapacityOverflow),"}, {"sha": "019d73c0b16bbb03b43281aad5d0a56983cf9e9a", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 52, "deletions": 109, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7b58193f90185a5730732a727362576a9bdca26b/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b58193f90185a5730732a727362576a9bdca26b/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=7b58193f90185a5730732a727362576a9bdca26b", "patch": "@@ -2,7 +2,6 @@ use std::assert_matches::assert_matches;\n use std::collections::TryReserveErrorKind::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n-use std::mem::size_of;\n use std::ops::Bound::*;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n@@ -1161,12 +1160,6 @@ fn test_try_reserve() {\n     const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n-    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n-    // Any platform that succeeds for these requests is technically broken with\n-    // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = size_of::<usize>() < 8;\n-\n     {\n         // Note: basic stuff is checked by test_reserve\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n@@ -1180,31 +1173,19 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            // Check isize::MAX + 1 does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            // Check usize::MAX does count as overflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX is an OOM\n-            // VecDeque starts with capacity 7, always adds 1 to the capacity\n-            // and also rounds the number to next power of 2 so this is the\n-            // furthest we can go without triggering CapacityOverflow\n-            assert_matches!(\n-                empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+        // Check isize::MAX + 1 does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        // Check usize::MAX does count as overflow\n+        assert_matches!(\n+            empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1217,19 +1198,13 @@ fn test_try_reserve() {\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should always overflow in the add-to-len\n         assert_matches!(\n             ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n@@ -1250,19 +1225,13 @@ fn test_try_reserve() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         // Should fail in the mul-by-size\n         assert_matches!(\n             ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n@@ -1282,8 +1251,6 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = size_of::<usize>() < 8;\n-\n     {\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n \n@@ -1296,29 +1263,17 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n-        if guards_against_isize {\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"usize::MAX should trigger an overflow!\"\n-            );\n-        } else {\n-            // Check isize::MAX is an OOM\n-            // VecDeque starts with capacity 7, always adds 1 to the capacity\n-            // and also rounds the number to next power of 2 so this is the\n-            // furthest we can go without triggering CapacityOverflow\n-            assert_matches!(\n-                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n+        assert_matches!(\n+            empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1334,19 +1289,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n             Err(CapacityOverflow),\n@@ -1367,19 +1316,13 @@ fn test_try_reserve_exact() {\n         {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if guards_against_isize {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(CapacityOverflow),\n-                \"isize::MAX + 1 should trigger an overflow!\"\n-            );\n-        } else {\n-            assert_matches!(\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n-                Err(AllocError { .. }),\n-                \"isize::MAX + 1 should trigger an OOM!\"\n-            );\n-        }\n+\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"isize::MAX + 1 should trigger an overflow!\"\n+        );\n+\n         assert_matches!(\n             ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n             Err(CapacityOverflow),"}]}