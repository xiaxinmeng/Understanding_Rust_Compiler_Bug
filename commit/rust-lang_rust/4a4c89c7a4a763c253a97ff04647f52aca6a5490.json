{"sha": "4a4c89c7a4a763c253a97ff04647f52aca6a5490", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNGM4OWM3YTRhNzYzYzI1M2E5N2ZmMDQ2NDdmNTJhY2E2YTU0OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T13:11:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T13:11:48Z"}, "message": "auto merge of #20119 : FlaPer87/rust/oibit-send-and-friends, r=nikomatsakis\n\nMore work on opt-in built in traits. `Send` and `Sync` are not opt-in, `OwnedPtr` renamed to `UniquePtr` and the `Send` and `Sync` traits are now unsafe.\r\n\r\nNOTE: This likely needs to be rebased on top of the yet-to-land snapshot.\r\n\r\nr? @nikomatsakis \r\n\r\ncc #13231", "tree": {"sha": "e7d313c7ebc0418284ea65089db287cca633bc99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d313c7ebc0418284ea65089db287cca633bc99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a4c89c7a4a763c253a97ff04647f52aca6a5490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4c89c7a4a763c253a97ff04647f52aca6a5490", "html_url": "https://github.com/rust-lang/rust/commit/4a4c89c7a4a763c253a97ff04647f52aca6a5490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a4c89c7a4a763c253a97ff04647f52aca6a5490/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9be54be15b4b4ba5c1b22d958d7619a5154ab469", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be54be15b4b4ba5c1b22d958d7619a5154ab469", "html_url": "https://github.com/rust-lang/rust/commit/9be54be15b4b4ba5c1b22d958d7619a5154ab469"}, {"sha": "1a73ccc8db0a10e82632808e058645f2d6fa0095", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a73ccc8db0a10e82632808e058645f2d6fa0095", "html_url": "https://github.com/rust-lang/rust/commit/1a73ccc8db0a10e82632808e058645f2d6fa0095"}], "stats": {"total": 1508, "additions": 975, "deletions": 533}, "files": [{"sha": "8d8bbb429325b1e9ec194be7070e82448a96e7c6", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -117,6 +117,10 @@ pub struct Arc<T> {\n     _ptr: *mut ArcInner<T>,\n }\n \n+unsafe impl<T: Sync + Send> Send for Arc<T> { }\n+unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n+\n+\n /// A weak pointer to an `Arc`.\n ///\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n@@ -129,13 +133,19 @@ pub struct Weak<T> {\n     _ptr: *mut ArcInner<T>,\n }\n \n+unsafe impl<T: Sync + Send> Send for Weak<T> { }\n+unsafe impl<T: Sync + Send> Sync for Weak<T> { }\n+\n struct ArcInner<T> {\n     strong: atomic::AtomicUint,\n     weak: atomic::AtomicUint,\n     data: T,\n }\n \n-impl<T: Sync + Send> Arc<T> {\n+unsafe impl<T: Sync + Send> Send for ArcInner<T> {}\n+unsafe impl<T: Sync + Send> Sync for ArcInner<T> {}\n+\n+impl<T> Arc<T> {\n     /// Constructs a new `Arc<T>`.\n     ///\n     /// # Examples\n@@ -587,6 +597,7 @@ mod tests {\n     use std::str::Str;\n     use std::sync::atomic;\n     use std::task;\n+    use std::kinds::Send;\n     use std::vec::Vec;\n     use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;"}, {"sha": "3c6b2d2cbc068904bc2f87e6aa7b844eafb9f49b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -19,6 +19,7 @@ use core::hash::{mod, Hash};\n use core::kinds::Sized;\n use core::mem;\n use core::option::Option;\n+use core::ptr::Unique;\n use core::raw::TraitObject;\n use core::result::Result;\n use core::result::Result::{Ok, Err};\n@@ -44,7 +45,7 @@ pub static HEAP: () = ();\n /// A type that represents a uniquely-owned value.\n #[lang = \"owned_box\"]\n #[unstable = \"custom allocators will add an additional type parameter (with default)\"]\n-pub struct Box<T>(*mut T);\n+pub struct Box<T>(Unique<T>);\n \n #[stable]\n impl<T: Default> Default for Box<T> {"}, {"sha": "ee61004d199bf3e5100a7346aad4c89c9491d6c0", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -43,6 +43,8 @@ struct Rawlink<T> {\n }\n \n impl<T> Copy for Rawlink<T> {}\n+unsafe impl<T:'static+Send> Send for Rawlink<T> {}\n+unsafe impl<T:Send+Sync> Sync for Rawlink<T> {}\n \n struct Node<T> {\n     next: Link<T>,"}, {"sha": "d700b187e8a6d6265be52aede3006e0cdfaee8cb", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -58,7 +58,7 @@ use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops;\n-use core::ptr;\n+use core::ptr::{mod, Unique};\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n@@ -133,7 +133,7 @@ use slice::CloneSliceExt;\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Vec<T> {\n-    ptr: *mut T,\n+    ptr: Unique<T>,\n     len: uint,\n     cap: uint,\n }\n@@ -176,7 +176,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { ptr: EMPTY as *mut T, len: 0, cap: 0 }\n+        Vec { ptr: Unique(EMPTY as *mut T), len: 0, cap: 0 }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -209,15 +209,15 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: EMPTY as *mut T, len: 0, cap: uint::MAX }\n+            Vec { ptr: Unique(EMPTY as *mut T), len: 0, cap: uint::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n-            Vec { ptr: ptr as *mut T, len: 0, cap: capacity }\n+            Vec { ptr: Unique(ptr as *mut T), len: 0, cap: capacity }\n         }\n     }\n \n@@ -284,7 +284,7 @@ impl<T> Vec<T> {\n     #[unstable = \"needs finalization\"]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n-        Vec { ptr: ptr, len: length, cap: capacity }\n+        Vec { ptr: Unique(ptr), len: length, cap: capacity }\n     }\n \n     /// Creates a vector by copying the elements from a raw pointer.\n@@ -795,19 +795,19 @@ impl<T> Vec<T> {\n         if self.len == 0 {\n             if self.cap != 0 {\n                 unsafe {\n-                    dealloc(self.ptr, self.cap)\n+                    dealloc(self.ptr.0, self.cap)\n                 }\n                 self.cap = 0;\n             }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large.\n-                self.ptr = reallocate(self.ptr as *mut u8,\n-                                      self.cap * mem::size_of::<T>(),\n-                                      self.len * mem::size_of::<T>(),\n-                                      mem::min_align_of::<T>()) as *mut T;\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                self.ptr = Unique(reallocate(self.ptr.0 as *mut u8,\n+                                               self.cap * mem::size_of::<T>(),\n+                                               self.len * mem::size_of::<T>(),\n+                                               mem::min_align_of::<T>()) as *mut T);\n+                if self.ptr.0.is_null() { ::alloc::oom() }\n             }\n             self.cap = self.len;\n         }\n@@ -867,7 +867,7 @@ impl<T> Vec<T> {\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr as *const T,\n+                data: self.ptr.0 as *const T,\n                 len: self.len,\n             })\n         }\n@@ -890,9 +890,9 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let ptr = self.ptr;\n+            let ptr = self.ptr.0;\n             let cap = self.cap;\n-            let begin = self.ptr as *const T;\n+            let begin = self.ptr.0 as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n                 (ptr as uint + self.len()) as *const T\n             } else {\n@@ -1110,14 +1110,14 @@ impl<T> Vec<T> {\n             let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n             if old_size > size { panic!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, old_size, size);\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                self.ptr = Unique(alloc_or_realloc(self.ptr.0, old_size, size));\n+                if self.ptr.0.is_null() { ::alloc::oom() }\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n-            let end = (self.ptr as *const T).offset(self.len as int) as *mut T;\n+            let end = self.ptr.0.offset(self.len as int);\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -1162,11 +1162,11 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n-            let begin = self.ptr as *const T;\n+            let begin = self.ptr.0 as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (self.ptr as uint + self.len()) as *const T\n+                (self.ptr.0 as uint + self.len()) as *const T\n             } else {\n-                self.ptr.offset(self.len() as int) as *const T\n+                self.ptr.0.offset(self.len() as int) as *const T\n             };\n             self.set_len(0);\n             Drain {\n@@ -1231,8 +1231,10 @@ impl<T> Vec<T> {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                self.ptr = Unique(alloc_or_realloc(self.ptr.0,\n+                                                     self.cap * mem::size_of::<T>(),\n+                                                     size));\n+                if self.ptr.0.is_null() { ::alloc::oom() }\n             }\n             self.cap = capacity;\n         }\n@@ -1355,7 +1357,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr as *const T,\n+                data: self.ptr.0 as *const T,\n                 len: self.len\n             })\n         }\n@@ -1380,7 +1382,7 @@ impl<T> Drop for Vec<T> {\n                 for x in self.iter() {\n                     ptr::read(x);\n                 }\n-                dealloc(self.ptr, self.cap)\n+                dealloc(self.ptr.0, self.cap)\n             }\n         }\n     }\n@@ -1418,7 +1420,7 @@ impl<T> IntoIter<T> {\n             for _x in self { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n-            Vec { ptr: allocation, cap: cap, len: 0 }\n+            Vec { ptr: Unique(allocation), cap: cap, len: 0 }\n         }\n     }\n "}, {"sha": "9452d0a64bf63e914333fa299728bc9656f5b739", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -14,6 +14,8 @@\n \n pub use self::Ordering::*;\n \n+use kinds::Sync;\n+\n use intrinsics;\n use cell::UnsafeCell;\n \n@@ -23,24 +25,32 @@ pub struct AtomicBool {\n     v: UnsafeCell<uint>,\n }\n \n+unsafe impl Sync for AtomicBool {}\n+\n /// A signed integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n }\n \n+unsafe impl Sync for AtomicInt {}\n+\n /// An unsigned integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n }\n \n+unsafe impl Sync for AtomicUint {}\n+\n /// A raw pointer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<uint>,\n }\n \n+unsafe impl<T> Sync for AtomicPtr<T> {}\n+\n /// Atomic memory orderings\n ///\n /// Memory orderings limit the ways that both the compiler and CPU may reorder"}, {"sha": "fb030ea45f3998180bb64a72d73838b55a8f8ac2", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -19,7 +19,7 @@\n \n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n-pub trait Send for Sized? : 'static {\n+pub unsafe trait Send for Sized? : 'static {\n     // empty.\n }\n \n@@ -81,7 +81,7 @@ pub trait Copy for Sized? {\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n #[lang=\"sync\"]\n-pub trait Sync for Sized? {\n+pub unsafe trait Sync for Sized? {\n     // Empty\n }\n "}, {"sha": "8c9d77a0e9cd7f48789bda02c81fcb6d92921ae5", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -92,6 +92,7 @@ use clone::Clone;\n use intrinsics;\n use option::Option;\n use option::Option::{Some, None};\n+use kinds::{Send, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering;\n@@ -501,3 +502,35 @@ impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n }\n+\n+/// A wrapper around a raw `*mut T` that indicates that the possessor\n+/// of this wrapper owns the referent. This in turn implies that the\n+/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a\n+/// raw `*mut T` (which conveys no particular ownership semantics).\n+/// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n+/// internally use raw pointers to manage the memory that they own.\n+pub struct Unique<T>(pub *mut T);\n+\n+/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `Unique` must enforce it.\n+unsafe impl<T:Send> Send for Unique<T> { }\n+\n+/// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `Unique` must enforce it.\n+unsafe impl<T:Sync> Sync for Unique<T> { }\n+\n+impl<T> Unique<T> {\n+    /// Returns a null Unique.\n+    pub fn null() -> Unique<T> {\n+        Unique(RawPtr::null())\n+    }\n+\n+    /// Return an (unsafe) pointer into the memory owned by `self`.\n+    pub unsafe fn offset(self, offset: int) -> *mut T {\n+        (self.0 as *const T).offset(offset) as *mut T\n+    }\n+}"}, {"sha": "8c4f74027a52f0a7a9ede9a5b4e7d8b17ebcadb5", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -27,8 +27,9 @@\n \n extern crate libc;\n \n-use std::c_vec::CVec;\n use libc::{c_void, size_t, c_int};\n+use std::c_vec::CVec;\n+use std::ptr::Unique;\n \n #[link(name = \"miniz\", kind = \"static\")]\n extern {\n@@ -59,7 +60,8 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n                                              &mut outsz,\n                                              flags);\n         if !res.is_null() {\n-            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, move|:| libc::free(res)))\n+            let res = Unique(res);\n+            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n         } else {\n             None\n         }\n@@ -84,7 +86,8 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, move|:| libc::free(res)))\n+            let res = Unique(res);\n+            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n         } else {\n             None\n         }"}, {"sha": "1ea79bdf606dade4719c6cf7a3e9e39d2917fe74", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -67,5 +67,6 @@ register_diagnostics! {\n     E0173,\n     E0174,\n     E0177,\n-    E0178\n+    E0178,\n+    E0179\n }"}, {"sha": "14f927f5b1ecb6fba5ea6a0da295145933187be5", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -31,6 +31,7 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n+use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n@@ -119,12 +120,19 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        fulfill_cx.register_builtin_bound(self.tcx, ty, ty::BoundSync,\n-                                          traits::ObligationCause::dummy());\n-        let env = ty::empty_parameter_environment();\n-        if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n-            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n-                                            type which implements Sync\");\n+        match traits::poly_trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n+            Ok(trait_ref) => {\n+                let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+                fulfill_cx.register_trait_ref(self.tcx, trait_ref, cause);\n+                let env = ty::empty_parameter_environment();\n+                match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n+                    Ok(()) => { },\n+                    Err(ref errors) => {\n+                      traits::report_fulfillment_errors(&infcx, errors);\n+                    }\n+                }\n+            }\n+            Err(ErrorReported) => { }\n         }\n     }\n }"}, {"sha": "87b378d579c1cb75774448094854880f861a6138", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -113,7 +113,7 @@ pub struct Upvar {\n // different kinds of pointers:\n #[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum PointerKind {\n-    OwnedPtr,\n+    Unique,\n     BorrowedPtr(ty::BorrowKind, ty::Region),\n     Implicit(ty::BorrowKind, ty::Region),     // Implicit deref of a borrowed ptr.\n     UnsafePtr(ast::Mutability)\n@@ -199,7 +199,7 @@ pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n     match t.sty {\n         ty::ty_uniq(_) |\n         ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n-            Some(deref_ptr(OwnedPtr))\n+            Some(deref_ptr(Unique))\n         }\n \n         ty::ty_rptr(r, mt) => {\n@@ -316,7 +316,7 @@ impl MutabilityCategory {\n     pub fn from_pointer_kind(base_mutbl: MutabilityCategory,\n                              ptr: PointerKind) -> MutabilityCategory {\n         match ptr {\n-            OwnedPtr => {\n+            Unique => {\n                 base_mutbl.inherit()\n             }\n             BorrowedPtr(borrow_kind, _) | Implicit(borrow_kind, _) => {\n@@ -1339,7 +1339,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           Implicit(..) => {\n                             \"dereference (dereference is implicit, due to indexing)\".to_string()\n                           }\n-                          OwnedPtr => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n+                          Unique => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n                           _ => format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n                       }\n                   }\n@@ -1400,7 +1400,7 @@ impl<'tcx> cmt_<'tcx> {\n             }\n             cat_downcast(ref b, _) |\n             cat_interior(ref b, _) |\n-            cat_deref(ref b, _, OwnedPtr) => {\n+            cat_deref(ref b, _, Unique) => {\n                 b.guarantor()\n             }\n         }\n@@ -1419,7 +1419,7 @@ impl<'tcx> cmt_<'tcx> {\n             cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n             cat_downcast(ref b, _) |\n-            cat_deref(ref b, _, OwnedPtr) |\n+            cat_deref(ref b, _, Unique) |\n             cat_interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n@@ -1511,7 +1511,7 @@ impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n \n pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     match ptr {\n-        OwnedPtr => \"Box\",\n+        Unique => \"Box\",\n         BorrowedPtr(ty::ImmBorrow, _) |\n         Implicit(ty::ImmBorrow, _) => \"&\",\n         BorrowedPtr(ty::MutBorrow, _) |"}, {"sha": "462857de1d4f88b6b1e25b348959200242cfc4a7", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -0,0 +1,349 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{FulfillmentError, FulfillmentErrorCode,\n+            ObligationCauseCode, SelectionError,\n+            PredicateObligation, OutputTypeParameterMismatch};\n+\n+use middle::infer::InferCtxt;\n+use middle::ty::{mod};\n+use syntax::codemap::Span;\n+use util::ppaux::{Repr, UserString};\n+\n+pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                           errors: &Vec<FulfillmentError<'tcx>>) {\n+    for error in errors.iter() {\n+        report_fulfillment_error(infcx, error);\n+    }\n+}\n+\n+fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      error: &FulfillmentError<'tcx>) {\n+    match error.code {\n+        FulfillmentErrorCode::CodeSelectionError(ref e) => {\n+            report_selection_error(infcx, &error.obligation, e);\n+        }\n+        FulfillmentErrorCode::CodeAmbiguity => {\n+            maybe_report_ambiguity(infcx, &error.obligation);\n+        }\n+    }\n+}\n+\n+pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                        obligation: &PredicateObligation<'tcx>,\n+                                        error: &SelectionError<'tcx>)\n+{\n+    match *error {\n+        SelectionError::Overflow => {\n+            // We could track the stack here more precisely if we wanted, I imagine.\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        infcx.resolve_type_vars_if_possible(&**trait_ref);\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"overflow evaluating the trait `{}` for the type `{}`\",\n+                            trait_ref.user_string(infcx.tcx),\n+                            trait_ref.self_ty().user_string(infcx.tcx))[]);\n+                }\n+\n+                ty::Predicate::Equate(ref predicate) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                    let err = infcx.equality_predicate(obligation.cause.span,\n+                                                       &predicate).unwrap_err();\n+\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(infcx.tcx),\n+                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n+                }\n+            }\n+\n+            let current_limit = infcx.tcx.sess.recursion_limit.get();\n+            let suggested_limit = current_limit * 2;\n+            infcx.tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                    suggested_limit)[]);\n+\n+            note_obligation_cause(infcx, obligation);\n+        }\n+        SelectionError::Unimplemented => {\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        infcx.resolve_type_vars_if_possible(\n+                            &**trait_ref);\n+                    if !ty::type_is_error(trait_ref.self_ty()) {\n+                        infcx.tcx.sess.span_err(\n+                            obligation.cause.span,\n+                            format!(\n+                                \"the trait `{}` is not implemented for the type `{}`\",\n+                                trait_ref.user_string(infcx.tcx),\n+                                trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n+                }\n+\n+                ty::Predicate::Equate(ref predicate) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                    let err = infcx.equality_predicate(obligation.cause.span,\n+                                                       &predicate).unwrap_err();\n+\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(infcx.tcx),\n+                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(&obligation.trait_ref);\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate.user_string(infcx.tcx)).as_slice());\n+                }\n+            }\n+        }\n+        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n+            let expected_trait_ref =\n+                infcx.resolve_type_vars_if_possible(\n+                    &**expected_trait_ref);\n+            let actual_trait_ref =\n+                infcx.resolve_type_vars_if_possible(\n+                    &**actual_trait_ref);\n+            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n+                infcx.tcx.sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                         but the trait `{}` is required ({})\",\n+                        expected_trait_ref.self_ty().user_string(infcx.tcx),\n+                        expected_trait_ref.user_string(infcx.tcx),\n+                        actual_trait_ref.user_string(infcx.tcx),\n+                        ty::type_err_to_str(infcx.tcx, e)).as_slice());\n+                note_obligation_cause(infcx, obligation);\n+            }\n+        }\n+    }\n+}\n+\n+fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                    obligation: &PredicateObligation<'tcx>) {\n+    // Unable to successfully determine, probably means\n+    // insufficient type information, but could mean\n+    // ambiguous impls. The latter *ought* to be a\n+    // coherence violation, so we don't report it here.\n+\n+    let trait_ref = match obligation.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            infcx.resolve_type_vars_if_possible(&**trait_ref)\n+        }\n+        _ => {\n+            infcx.tcx.sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"ambiguity from something other than a trait: {}\",\n+                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n+        }\n+    };\n+    let self_ty = trait_ref.self_ty();\n+\n+    debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n+           trait_ref.repr(infcx.tcx),\n+           self_ty.repr(infcx.tcx),\n+           obligation.repr(infcx.tcx));\n+    let all_types = &trait_ref.substs().types;\n+    if all_types.iter().any(|&t| ty::type_is_error(t)) {\n+    } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n+        // This is kind of a hack: it frequently happens that some earlier\n+        // error prevents types from being fully inferred, and then we get\n+        // a bunch of uninteresting errors saying something like \"<generic\n+        // #0> doesn't implement Sized\".  It may even be true that we\n+        // could just skip over all checks where the self-ty is an\n+        // inference variable, but I was afraid that there might be an\n+        // inference variable created, registered as an obligation, and\n+        // then never forced by writeback, and hence by skipping here we'd\n+        // be ignoring the fact that we don't KNOW the type works\n+        // out. Though even that would probably be harmless, given that\n+        // we're only talking about builtin traits, which are known to be\n+        // inhabited. But in any case I just threw in this check for\n+        // has_errors() to be sure that compilation isn't happening\n+        // anyway. In that case, why inundate the user.\n+        if !infcx.tcx.sess.has_errors() {\n+            if infcx.tcx.lang_items.sized_trait()\n+                  .map_or(false, |sized_id| sized_id == trait_ref.def_id()) {\n+                infcx.tcx.sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"unable to infer enough type information about `{}`; type annotations \\\n+                         required\",\n+                        self_ty.user_string(infcx.tcx)).as_slice());\n+            } else {\n+                infcx.tcx.sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"unable to infer enough type information to \\\n+                         locate the impl of the trait `{}` for \\\n+                         the type `{}`; type annotations required\",\n+                        trait_ref.user_string(infcx.tcx),\n+                        self_ty.user_string(infcx.tcx))[]);\n+                note_obligation_cause(infcx, obligation);\n+            }\n+        }\n+    } else if !infcx.tcx.sess.has_errors() {\n+         // Ambiguity. Coherence should have reported an error.\n+        infcx.tcx.sess.span_bug(\n+            obligation.cause.span,\n+            format!(\n+                \"coherence failed to report ambiguity: \\\n+                 cannot locate the impl of the trait `{}` for \\\n+                 the type `{}`\",\n+                trait_ref.user_string(infcx.tcx),\n+                self_ty.user_string(infcx.tcx))[]);\n+    }\n+}\n+\n+fn note_obligation_cause<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                   obligation: &PredicateObligation<'tcx>)\n+{\n+    let trait_ref = match obligation.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            infcx.resolve_type_vars_if_possible(&**trait_ref)\n+        }\n+        _ => {\n+            infcx.tcx.sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"ambiguity from something other than a trait: {}\",\n+                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n+        }\n+    };\n+\n+    note_obligation_cause_code(infcx,\n+                               &trait_ref,\n+                               obligation.cause.span,\n+                               &obligation.cause.code)\n+}\n+\n+fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                        trait_ref: &ty::PolyTraitRef<'tcx>,\n+                                        cause_span: Span,\n+                                        cause_code: &ObligationCauseCode<'tcx>)\n+{\n+    let tcx = infcx.tcx;\n+    let trait_name = ty::item_path_str(tcx, trait_ref.def_id());\n+    match *cause_code {\n+        ObligationCauseCode::MiscObligation => { }\n+        ObligationCauseCode::ItemObligation(item_def_id) => {\n+            let item_name = ty::item_path_str(tcx, item_def_id);\n+            tcx.sess.span_note(\n+                cause_span,\n+                format!(\n+                    \"the trait `{}` must be implemented because it is required by `{}`\",\n+                    trait_name,\n+                    item_name).as_slice());\n+        }\n+        ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                format!(\n+                    \"the trait `{}` must be implemented for the cast \\\n+                     to the object type `{}`\",\n+                    trait_name,\n+                    infcx.ty_to_string(object_ty)).as_slice());\n+        }\n+        ObligationCauseCode::RepeatVec => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"the `Copy` trait is required because the \\\n+                 repeated element will be copied\");\n+        }\n+        ObligationCauseCode::VariableType(_) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"all local variables must have a statically known size\");\n+        }\n+        ObligationCauseCode::ReturnType => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"the return type of a function must have a \\\n+                 statically known size\");\n+        }\n+        ObligationCauseCode::AssignmentLhsSized => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"the left-hand-side of an assignment must have a statically known size\");\n+        }\n+        ObligationCauseCode::StructInitializerSized => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"structs must have a statically known size to be initialized\");\n+        }\n+        ObligationCauseCode::ClosureCapture(var_id, closure_span, builtin_bound) => {\n+            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n+            let trait_name = ty::item_path_str(tcx, def_id);\n+            let name = ty::local_var_name_str(tcx, var_id);\n+            span_note!(tcx.sess, closure_span,\n+                       \"the closure that captures `{}` requires that all captured variables \\\n+                       implement the trait `{}`\",\n+                       name,\n+                       trait_name);\n+        }\n+        ObligationCauseCode::FieldSized => {\n+            span_note!(tcx.sess, cause_span,\n+                       \"only the last field of a struct or enum variant \\\n+                       may have a dynamically sized type\")\n+        }\n+        ObligationCauseCode::ObjectSized => {\n+            span_note!(tcx.sess, cause_span,\n+                       \"only sized types can be made into objects\");\n+        }\n+        ObligationCauseCode::SharedStatic => {\n+            span_note!(tcx.sess, cause_span,\n+                       \"shared static variables must have a type that implements `Sync`\");\n+        }\n+        ObligationCauseCode::BuiltinDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n+            let root_trait_ref =\n+                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+            span_note!(tcx.sess, cause_span,\n+                       \"the type `{}` must implement `{}` because it appears within the type `{}`\",\n+                       trait_ref.self_ty().user_string(infcx.tcx),\n+                       trait_ref.user_string(infcx.tcx),\n+                       root_trait_ref.self_ty().user_string(infcx.tcx));\n+            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+        }\n+        ObligationCauseCode::ImplDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n+            let root_trait_ref =\n+                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+            span_note!(tcx.sess, cause_span,\n+                       \"the type `{}` must implement `{}` due to the requirements \\\n+                        on the impl of `{}` for the type `{}`\",\n+                       trait_ref.self_ty().user_string(infcx.tcx),\n+                       trait_ref.user_string(infcx.tcx),\n+                       root_trait_ref.user_string(infcx.tcx),\n+                       root_trait_ref.self_ty().user_string(infcx.tcx));\n+            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+        }\n+    }\n+}"}, {"sha": "e9e80ed8c18c9c3aea0adb018829f391a5ee78cd", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -305,7 +305,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     let tcx = selcx.tcx();\n     match predicate.trait_ref {\n         ty::Predicate::Trait(ref trait_ref) => {\n-            let trait_obligation = Obligation { cause: predicate.cause,\n+            let trait_obligation = Obligation { cause: predicate.cause.clone(),\n                                                 recursion_depth: predicate.recursion_depth,\n                                                 trait_ref: trait_ref.clone() };\n             match selcx.select(&trait_obligation) {\n@@ -368,7 +368,9 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                         CodeSelectionError(Unimplemented)));\n             } else {\n                 let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n-                register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+                register_region_obligation(tcx, t_a, r_b,\n+                                           predicate.cause.clone(),\n+                                           region_obligations);\n             }\n             true\n         }"}, {"sha": "6597730846dedbe55d63c98c3b4885c1d4ae1237", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -23,6 +23,7 @@ use std::slice::Iter;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n+pub use self::error_reporting::report_fulfillment_errors;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n@@ -36,6 +37,7 @@ pub use self::util::transitive_bounds;\n pub use self::util::poly_trait_ref_for_builtin_bound;\n \n mod coherence;\n+mod error_reporting;\n mod fulfill;\n mod select;\n mod util;\n@@ -57,7 +59,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::PolyTraitRef<'tcx>>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n-#[deriving(Copy, Clone)]\n+#[deriving(Clone)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -72,7 +74,7 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>\n }\n \n-#[deriving(Copy, Clone)]\n+#[deriving(Clone)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n@@ -84,9 +86,6 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n-    /// To implement drop, type must be sendable.\n-    DropTrait,\n-\n     /// Various cases where expressions must be sized/copy/etc:\n     AssignmentLhsSized,        // L = X implies that L is Sized\n     StructInitializerSized,    // S { ... } must be Sized\n@@ -103,6 +102,13 @@ pub enum ObligationCauseCode<'tcx> {\n \n     // Only Sized types can be made into objects\n     ObjectSized,\n+\n+    // static items must have `Sync` type\n+    SharedStatic,\n+\n+    BuiltinDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n+\n+    ImplDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n }\n \n pub type Obligations<'tcx, O> = subst::VecPerParamSpace<Obligation<'tcx, O>>;"}, {"sha": "42b753927d55e27f7127e7549b6d9b70c8544e31", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 66, "deletions": 29, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -18,6 +18,7 @@ use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n+use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n@@ -256,7 +257,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let obligation =\n             util::predicate_for_builtin_bound(\n                 self.tcx(),\n-                previous_stack.obligation.cause,\n+                previous_stack.obligation.cause.clone(),\n                 bound,\n                 previous_stack.obligation.recursion_depth + 1,\n                 ty);\n@@ -416,7 +417,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(substs) => {\n                     let vtable_impl = self.vtable_impl(impl_def_id,\n                                                        substs,\n-                                                       obligation.cause,\n+                                                       obligation.cause.clone(),\n                                                        obligation.recursion_depth + 1,\n                                                        skol_map,\n                                                        snapshot);\n@@ -663,25 +664,35 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // behavior, ignore user-defined impls here. This will\n                 // go away by the time 1.0 is released.\n                 if !self.tcx().sess.features.borrow().opt_out_copy {\n-                    try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n+                    try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n                 }\n \n                 try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n                                                             stack,\n                                                             &mut candidates));\n             }\n+            Some(bound @ ty::BoundSend) |\n+            Some(bound @ ty::BoundSync) => {\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+\n+                // No explicit impls were declared for this type, consider the fallback rules.\n+                if candidates.vec.is_empty() {\n+                    try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+                }\n+            }\n+\n+            Some(bound @ ty::BoundSized) => {\n+                // Sized and Copy are always automatically computed.\n+                try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+            }\n \n             None => {\n                 // For the time being, we ignore user-defined impls for builtin-bounds, other than\n                 // `Copy`.\n                 // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n                 try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n-            }\n-\n-            Some(bound) => {\n-                try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n             }\n         }\n \n@@ -816,7 +827,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Search for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      candidates: &mut CandidateSet<'tcx>)\n+                                      candidate_vec: &mut Vec<Candidate<'tcx>>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n         let all_impls = self.all_impls(obligation.trait_ref.def_id());\n@@ -827,7 +838,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match self.match_impl(impl_def_id, obligation, snapshot,\n                                       &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                     Ok(_) => {\n-                        candidates.vec.push(ImplCandidate(impl_def_id));\n+                        candidate_vec.push(ImplCandidate(impl_def_id));\n                     }\n                     Err(()) => { }\n                 }\n@@ -1007,7 +1018,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_ptr(ty::mt { ty: referent_ty, .. }) => {     // *const T, *mut T\n+            ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n                     ty::BoundCopy |\n                     ty::BoundSized => {\n@@ -1016,7 +1027,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     ty::BoundSync |\n                     ty::BoundSend => {\n-                        Ok(If(vec![referent_ty]))\n+                        // sync and send are not implemented for *const, *mut\n+                        Err(Unimplemented)\n                     }\n                 }\n             }\n@@ -1323,16 +1335,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::BoundSync => {\n                     if\n                         Some(def_id) == tcx.lang_items.no_sync_bound() ||\n-                        Some(def_id) == tcx.lang_items.managed_bound()\n-                    {\n-                        return Err(Unimplemented)\n-                    } else if\n+                        Some(def_id) == tcx.lang_items.managed_bound() ||\n                         Some(def_id) == tcx.lang_items.unsafe_type()\n                     {\n-                        // FIXME(#13231) -- we currently consider `UnsafeCell<T>`\n-                        // to always be sync. This is allow for types like `Queue`\n-                        // and `Mutex`, where `Queue<T> : Sync` is `T : Send`.\n-                        return Ok(If(Vec::new()));\n+                        return Err(Unimplemented)\n                     }\n                 }\n \n@@ -1407,7 +1413,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // where-clause trait-ref could be unified with the obligation\n         // trait-ref. Repeat that unification now without any\n         // transactional boundary; it should not fail.\n-        match self.confirm_poly_trait_refs(obligation.cause,\n+        match self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                            obligation.trait_ref.clone(),\n                                            param.bound.clone()) {\n             Ok(()) => Ok(param),\n@@ -1446,10 +1452,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: Vec<Ty<'tcx>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n+        let derived_cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n         let obligations = nested.iter().map(|&t| {\n             util::predicate_for_builtin_bound(\n                 self.tcx(),\n-                obligation.cause,\n+                derived_cause.clone(),\n                 bound,\n                 obligation.recursion_depth + 1,\n                 t)\n@@ -1462,7 +1469,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // as a special case, `Send` requires `'static`\n         if bound == ty::BoundSend {\n             obligations.push(Obligation {\n-                cause: obligation.cause,\n+                cause: obligation.cause.clone(),\n                 recursion_depth: obligation.recursion_depth+1,\n                 trait_ref: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n                                                             ty::ReStatic)).as_predicate(),\n@@ -1496,7 +1503,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let substs = self.rematch_impl(impl_def_id, obligation,\n                                            snapshot, &skol_map, Rc::new(skol_obligation_trait_ref));\n             debug!(\"confirm_impl_candidate substs={}\", substs);\n-            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause,\n+            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n     }\n@@ -1570,10 +1577,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             substs: substs,\n         }));\n \n-        try!(self.confirm_poly_trait_refs(obligation.cause,\n+        try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.trait_ref.clone(),\n                                           trait_ref));\n-\n         Ok(self_ty)\n     }\n \n@@ -1616,7 +1622,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                trait_ref.repr(self.tcx()));\n \n-        self.confirm_poly_trait_refs(obligation.cause,\n+        self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.trait_ref.clone(),\n                                      trait_ref)\n     }\n@@ -1808,7 +1814,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// back `Ok(T=int)`.\n     fn match_inherent_impl(&mut self,\n                            impl_def_id: ast::DefId,\n-                           obligation_cause: ObligationCause,\n+                           obligation_cause: &ObligationCause,\n                            obligation_self_ty: Ty<'tcx>)\n                            -> Result<Substs<'tcx>,()>\n     {\n@@ -1841,7 +1847,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_self_types(&mut self,\n-                        cause: ObligationCause,\n+                        cause: &ObligationCause,\n \n                         // The self type provided by the impl/caller-obligation:\n                         provided_self_ty: Ty<'tcx>,\n@@ -1920,6 +1926,37 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None\n         }\n     }\n+\n+    #[allow(unused_comparisons)]\n+    fn derived_cause(&self,\n+                     obligation: &TraitObligation<'tcx>,\n+                     variant: fn(Rc<ty::Binder<ty::TraitRef<'tcx>>>,\n+                                 Rc<ObligationCauseCode<'tcx>>)\n+                                 -> ObligationCauseCode<'tcx>)\n+                     -> ObligationCause<'tcx>\n+    {\n+        /*!\n+         * Creates a cause for obligations that are derived from\n+         * `obligation` by a recursive search (e.g., for a builtin\n+         * bound, or eventually a `impl Foo for ..`). If `obligation`\n+         * is itself a derived obligation, this is just a clone, but\n+         * otherwise we create a \"derived obligation\" cause so as to\n+         * keep track of the original root obligation for error\n+         * reporting.\n+         */\n+\n+        // NOTE(flaper87): As of now, it keeps track of the whole error\n+        // chain. Ideally, we should have a way to configure this either\n+        // by using -Z verbose or just a CLI argument.\n+        if obligation.recursion_depth >= 0 {\n+            ObligationCause::new(obligation.cause.span,\n+                                 obligation.trait_ref.def_id().node,\n+                                 variant(obligation.trait_ref.clone(),\n+                                         Rc::new(obligation.cause.code.clone())))\n+        } else {\n+            obligation.cause.clone()\n+        }\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for Candidate<'tcx> {"}, {"sha": "0864b21870d08f08204cba0b7715f42bc420ea2c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -260,7 +260,7 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n            generic_bounds.repr(tcx));\n \n     generic_bounds.predicates.map(|predicate| {\n-        Obligation { cause: cause,\n+        Obligation { cause: cause.clone(),\n                      recursion_depth: recursion_depth,\n                      trait_ref: predicate.clone() }\n     })"}, {"sha": "b7cde762a849fe87e9c0526eab00033bcf6c6cc9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -439,7 +439,7 @@ impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n         traits::Obligation {\n-            cause: self.cause,\n+            cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n             trait_ref: self.trait_ref.fold_with(folder),\n         }"}, {"sha": "fdb13ecabde81669e29007ae8948237781206ba2", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -31,11 +31,11 @@ use std::rc::Rc;\n \n // FIXME (#16118): These functions are intended to allow the borrow checker to\n // be less precise in its handling of Box while still allowing moves out of a\n-// Box. They should be removed when OwnedPtr is removed from LoanPath.\n+// Box. They should be removed when Unique is removed from LoanPath.\n \n fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<'tcx> {\n-    //! Returns the base of the leftmost dereference of an OwnedPtr in\n-    //! `loan_path`. If there is no dereference of an OwnedPtr in `loan_path`,\n+    //! Returns the base of the leftmost dereference of an Unique in\n+    //! `loan_path`. If there is no dereference of an Unique in `loan_path`,\n     //! then it just returns `loan_path` itself.\n \n     return match helper(loan_path) {\n@@ -46,7 +46,7 @@ fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<\n     fn helper<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> Option<&'a LoanPath<'tcx>> {\n         match loan_path.kind {\n             LpVar(_) | LpUpvar(_) => None,\n-            LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n+            LpExtend(ref lp_base, _, LpDeref(mc::Unique)) => {\n                 match helper(&**lp_base) {\n                     v @ Some(_) => v,\n                     None => Some(&**lp_base)\n@@ -70,7 +70,7 @@ fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'\n     fn helper<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Option<Rc<LoanPath<'tcx>>> {\n         match loan_path.kind {\n             LpVar(_) | LpUpvar(_) => None,\n-            LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n+            LpExtend(ref lp_base, _, LpDeref(mc::Unique)) => {\n                 match helper(lp_base) {\n                     v @ Some(_) => v,\n                     None => Some(lp_base.clone())\n@@ -878,7 +878,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    mc::cat_deref(b, _, mc::OwnedPtr) => {\n+                    mc::cat_deref(b, _, mc::Unique) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;\n                     }"}, {"sha": "ef9130bb607d816eb23aaa31579fafde4ab12910", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -291,9 +291,9 @@ fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n             add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n         }\n \n-        // *LV for OwnedPtr consumes the contents of the box (at\n+        // *LV for Unique consumes the contents of the box (at\n         // least when it is non-copy...), so propagate inward.\n-        LpExtend(ref loan_parent, _, LpDeref(mc::OwnedPtr)) => {\n+        LpExtend(ref loan_parent, _, LpDeref(mc::Unique)) => {\n             add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n         }\n "}, {"sha": "6f02f447a158d7be441513c69ba4cf017dae96fe", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -189,7 +189,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             }\n         }\n \n-        mc::cat_deref(ref b, _, mc::OwnedPtr) => {\n+        mc::cat_deref(ref b, _, mc::Unique) => {\n             check_and_get_illegal_move_origin(bccx, b)\n         }\n     }"}, {"sha": "1c57097ae26339a9c70626cc96617836836521a1", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n \n             mc::cat_downcast(ref base, _) |\n-            mc::cat_deref(ref base, _, mc::OwnedPtr) |     // L-Deref-Send\n+            mc::cat_deref(ref base, _, mc::Unique) |     // L-Deref-Send\n             mc::cat_interior(ref base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 r\n             }\n             mc::cat_downcast(ref cmt, _) |\n-            mc::cat_deref(ref cmt, _, mc::OwnedPtr) |\n+            mc::cat_deref(ref cmt, _, mc::Unique) |\n             mc::cat_interior(ref cmt, _) => {\n                 self.scope(cmt)\n             }"}, {"sha": "b3fb7123ef3a70e5c3fc95034518d017a9bd48ba", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n \n             mc::cat_deref(cmt_base, _, pk) => {\n                 match pk {\n-                    mc::OwnedPtr => {\n+                    mc::Unique => {\n                         // R-Deref-Send-Pointer\n                         //\n                         // When we borrow the interior of an owned pointer, we"}, {"sha": "513b955da3f5855104e5a1adb1db86610220f65b", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -281,6 +281,8 @@ struct ModuleConfig {\n     time_passes: bool,\n }\n \n+unsafe impl Send for ModuleConfig { }\n+\n impl ModuleConfig {\n     fn new(tm: TargetMachineRef, passes: Vec<String>) -> ModuleConfig {\n         ModuleConfig {"}, {"sha": "640e83469b2695ae8a8020d4140b5dfa76a0126c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -216,32 +216,32 @@ use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::ast_util::PostExpansionMethod;\n use syntax::parse::token::{mod, special_idents};\n \n-static DW_LANG_RUST: c_uint = 0x9000;\n+const DW_LANG_RUST: c_uint = 0x9000;\n \n #[allow(non_upper_case_globals)]\n-static DW_TAG_auto_variable: c_uint = 0x100;\n+const DW_TAG_auto_variable: c_uint = 0x100;\n #[allow(non_upper_case_globals)]\n-static DW_TAG_arg_variable: c_uint = 0x101;\n+const DW_TAG_arg_variable: c_uint = 0x101;\n \n #[allow(non_upper_case_globals)]\n-static DW_ATE_boolean: c_uint = 0x02;\n+const DW_ATE_boolean: c_uint = 0x02;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_float: c_uint = 0x04;\n+const DW_ATE_float: c_uint = 0x04;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_signed: c_uint = 0x05;\n+const DW_ATE_signed: c_uint = 0x05;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_unsigned: c_uint = 0x07;\n+const DW_ATE_unsigned: c_uint = 0x07;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_unsigned_char: c_uint = 0x08;\n+const DW_ATE_unsigned_char: c_uint = 0x08;\n \n-static UNKNOWN_LINE_NUMBER: c_uint = 0;\n-static UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n+const UNKNOWN_LINE_NUMBER: c_uint = 0;\n+const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n // ptr::null() doesn't work :(\n-static UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n-static UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n+const UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n+const UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n \n-static FLAGS_NONE: c_uint = 0;\n+const FLAGS_NONE: c_uint = 0;\n \n //=-----------------------------------------------------------------------------\n //  Public Interface of debuginfo module"}, {"sha": "c53e164fb0703abd2149aeb527192fa9e3f57719", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -60,6 +60,9 @@ pub struct ModuleTranslation {\n     pub llmod: ModuleRef,\n }\n \n+unsafe impl Send for ModuleTranslation { }\n+unsafe impl Sync for ModuleTranslation { }\n+\n pub struct CrateTranslation {\n     pub modules: Vec<ModuleTranslation>,\n     pub metadata_module: ModuleTranslation,"}, {"sha": "e17cf81baa873ad775b3e3ddf2babac151f62490", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -1403,7 +1403,7 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n             }\n \n             mc::cat_downcast(cmt_base, _) |\n-            mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n+            mc::cat_deref(cmt_base, _, mc::Unique) |\n             mc::cat_interior(cmt_base, _) => {\n                 // Borrowing interior or owned data requires the base\n                 // to be valid and borrowable in the same fashion.\n@@ -1627,7 +1627,7 @@ fn adjust_upvar_borrow_kind_for_mut<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                cmt.repr(rcx.tcx()));\n \n         match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::OwnedPtr) |\n+            mc::cat_deref(base, _, mc::Unique) |\n             mc::cat_interior(base, _) |\n             mc::cat_downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n@@ -1674,7 +1674,7 @@ fn adjust_upvar_borrow_kind_for_unique<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, cmt: mc::c\n                cmt.repr(rcx.tcx()));\n \n         match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::OwnedPtr) |\n+            mc::cat_deref(base, _, mc::Unique) |\n             mc::cat_interior(base, _) |\n             mc::cat_downcast(base, _) => {\n                 // Interior or owned data is unique if base is"}, {"sha": "7ebf39e2e9a143198c7fcb860cbe8b7e4912631d", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 276, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -11,16 +11,14 @@\n use check::{FnCtxt, structurally_resolved_type};\n use middle::subst::{FnSpace};\n use middle::traits;\n-use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n use middle::traits::{Obligation, ObligationCause};\n-use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n-use middle::traits::{PredicateObligation};\n+use middle::traits::report_fulfillment_errors;\n use middle::ty::{mod, Ty};\n use middle::infer;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::{UserString, Repr, ty_to_string};\n+use util::ppaux::{Repr, ty_to_string};\n \n pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    cast_expr: &ast::Expr,\n@@ -285,199 +283,7 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n                                                fcx);\n     match r {\n         Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n-    }\n-}\n-\n-pub fn report_fulfillment_errors<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                           errors: &Vec<FulfillmentError<'tcx>>) {\n-    for error in errors.iter() {\n-        report_fulfillment_error(fcx, error);\n-    }\n-}\n-\n-pub fn report_fulfillment_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          error: &FulfillmentError<'tcx>) {\n-    match error.code {\n-        CodeSelectionError(ref e) => {\n-            report_selection_error(fcx, &error.obligation, e);\n-        }\n-        CodeAmbiguity => {\n-            maybe_report_ambiguity(fcx, &error.obligation);\n-        }\n-    }\n-}\n-\n-pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>,\n-                                        error: &SelectionError<'tcx>)\n-{\n-    match *error {\n-        Overflow => {\n-            // We could track the stack here more precisely if we wanted, I imagine.\n-            let predicate =\n-                fcx.infcx().resolve_type_vars_if_possible(&obligation.trait_ref);\n-            fcx.tcx().sess.span_err(\n-                obligation.cause.span,\n-                format!(\n-                    \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(fcx.tcx())).as_slice());\n-\n-            let current_limit = fcx.tcx().sess.recursion_limit.get();\n-            let suggested_limit = current_limit * 2;\n-            fcx.tcx().sess.span_note(\n-                obligation.cause.span,\n-                format!(\n-                    \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                    suggested_limit)[]);\n-\n-            note_obligation_cause(fcx, obligation);\n-        }\n-        Unimplemented => {\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref = fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n-                    if !ty::type_is_error(trait_ref.self_ty()) {\n-                        fcx.tcx().sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n-                                \"the trait `{}` is not implemented for the type `{}`\",\n-                                trait_ref.user_string(fcx.tcx()),\n-                                trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n-                    }\n-                }\n-\n-                ty::Predicate::Equate(ref predicate) => {\n-                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n-                    let err = fcx.infcx().equality_predicate(obligation.cause.span,\n-                                                             &predicate).unwrap_err();\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(fcx.tcx()),\n-                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n-                }\n-\n-                ty::Predicate::RegionOutlives(ref predicate) => {\n-                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n-                    let err = fcx.infcx().region_outlives_predicate(obligation.cause.span,\n-                                                                    &predicate).unwrap_err();\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(fcx.tcx()),\n-                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n-                }\n-\n-                ty::Predicate::TypeOutlives(ref predicate) => {\n-                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate.user_string(fcx.tcx())).as_slice());\n-                }\n-            }\n-\n-            note_obligation_cause(fcx, obligation);\n-        }\n-        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n-            let expected_trait_ref =\n-                fcx.infcx().resolve_type_vars_if_possible(\n-                    &**expected_trait_ref);\n-            let actual_trait_ref =\n-                fcx.infcx().resolve_type_vars_if_possible(\n-                    &**actual_trait_ref);\n-            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n-                         but the trait `{}` is required ({})\",\n-                        expected_trait_ref.self_ty().user_string(fcx.tcx()),\n-                        expected_trait_ref.user_string(fcx.tcx()),\n-                        actual_trait_ref.user_string(fcx.tcx()),\n-                        ty::type_err_to_str(fcx.tcx(), e)).as_slice());\n-                note_obligation_cause(fcx, obligation);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>) {\n-    // Unable to successfully determine, probably means\n-    // insufficient type information, but could mean\n-    // ambiguous impls. The latter *ought* to be a\n-    // coherence violation, so we don't report it here.\n-\n-    let trait_ref = match obligation.trait_ref {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            fcx.infcx().resolve_type_vars_if_possible(&**trait_ref)\n-        }\n-        _ => {\n-            fcx.tcx().sess.span_bug(\n-                obligation.cause.span,\n-                format!(\"ambiguity from something other than a trait: {}\",\n-                        obligation.trait_ref.repr(fcx.tcx())).as_slice());\n-        }\n-    };\n-    let self_ty = trait_ref.self_ty();\n-\n-    debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n-           trait_ref.repr(fcx.tcx()),\n-           self_ty.repr(fcx.tcx()),\n-           obligation.repr(fcx.tcx()));\n-    let all_types = &trait_ref.substs().types;\n-    if all_types.iter().any(|&t| ty::type_is_error(t)) {\n-    } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n-        // This is kind of a hack: it frequently happens that some earlier\n-        // error prevents types from being fully inferred, and then we get\n-        // a bunch of uninteresting errors saying something like \"<generic\n-        // #0> doesn't implement Sized\".  It may even be true that we\n-        // could just skip over all checks where the self-ty is an\n-        // inference variable, but I was afraid that there might be an\n-        // inference variable created, registered as an obligation, and\n-        // then never forced by writeback, and hence by skipping here we'd\n-        // be ignoring the fact that we don't KNOW the type works\n-        // out. Though even that would probably be harmless, given that\n-        // we're only talking about builtin traits, which are known to be\n-        // inhabited. But in any case I just threw in this check for\n-        // has_errors() to be sure that compilation isn't happening\n-        // anyway. In that case, why inundate the user.\n-        if !fcx.tcx().sess.has_errors() {\n-            if fcx.ccx.tcx.lang_items.sized_trait()\n-                  .map_or(false, |sized_id| sized_id == trait_ref.def_id()) {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"unable to infer enough type information about `{}`; type annotations \\\n-                         required\",\n-                        self_ty.user_string(fcx.tcx()))[]);\n-            } else {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"unable to infer enough type information to \\\n-                         locate the impl of the trait `{}` for \\\n-                         the type `{}`; type annotations required\",\n-                        trait_ref.user_string(fcx.tcx()),\n-                        self_ty.user_string(fcx.tcx()))[]);\n-                note_obligation_cause(fcx, obligation);\n-            }\n-        }\n-    } else if !fcx.tcx().sess.has_errors() {\n-         // Ambiguity. Coherence should have reported an error.\n-        fcx.tcx().sess.span_bug(\n-            obligation.cause.span,\n-            format!(\n-                \"coherence failed to report ambiguity: \\\n-                 cannot locate the impl of the trait `{}` for \\\n-                 the type `{}`\",\n-                trait_ref.user_string(fcx.tcx()),\n-                self_ty.user_string(fcx.tcx()))[]);\n+        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }\n \n@@ -490,7 +296,7 @@ pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n         .select_where_possible(fcx.infcx(), &fcx.inh.param_env, fcx)\n     {\n         Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }\n \n@@ -504,83 +310,6 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n         .select_new_obligations(fcx.infcx(), &fcx.inh.param_env, fcx)\n     {\n         Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n-    }\n-}\n-\n-fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                   obligation: &PredicateObligation<'tcx>) {\n-    let tcx = fcx.tcx();\n-    match obligation.cause.code {\n-        traits::MiscObligation => { }\n-        traits::ItemObligation(item_def_id) => {\n-            let item_name = ty::item_path_str(tcx, item_def_id);\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                format!(\n-                    \"required by `{}`\",\n-                    item_name).as_slice());\n-        }\n-        traits::ObjectCastObligation(object_ty) => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                format!(\n-                    \"required for the cast to the object type `{}`\",\n-                    fcx.infcx().ty_to_string(object_ty)).as_slice());\n-        }\n-        traits::RepeatVec => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"the `Copy` trait is required because the \\\n-                 repeated element will be copied\");\n-        }\n-        traits::VariableType(_) => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"all local variables must have a statically known size\");\n-        }\n-        traits::ReturnType => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"the return type of a function must have a \\\n-                 statically known size\");\n-        }\n-        traits::AssignmentLhsSized => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"the left-hand-side of an assignment must have a statically known size\");\n-        }\n-        traits::StructInitializerSized => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"structs must have a statically known size to be initialized\");\n-        }\n-        traits::DropTrait => {\n-            span_note!(tcx.sess, obligation.cause.span,\n-                      \"cannot implement a destructor on a \\\n-                      structure or enumeration that does not satisfy Send\");\n-            span_help!(tcx.sess, obligation.cause.span,\n-                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n-                       to force the compiler to allow this\");\n-        }\n-        traits::ClosureCapture(var_id, closure_span, builtin_bound) => {\n-            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-            let trait_name = ty::item_path_str(tcx, def_id);\n-            let name = ty::local_var_name_str(tcx, var_id);\n-            span_note!(tcx.sess, closure_span,\n-                       \"the closure that captures `{}` requires that all captured variables \\\"\n-                       implement the trait `{}`\",\n-                       name,\n-                       trait_name);\n-        }\n-        traits::FieldSized => {\n-            span_note!(tcx.sess, obligation.cause.span,\n-                       \"only the last field of a struct or enum variant \\\n-                       may have a dynamically sized type\")\n-        }\n-        traits::ObjectSized => {\n-            span_note!(tcx.sess, obligation.cause.span,\n-                       \"only sized types can be made into objects\");\n-        }\n+        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }"}, {"sha": "39bcfb354b873f380064fdbdd5b46ccbd9e3bc17", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -188,7 +188,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 match self_ty.sty {\n                     ty::ty_struct(def_id, _) |\n                     ty::ty_enum(def_id, _) => {\n-                        check_struct_safe_for_destructor(fcx, item.span, self_ty, def_id);\n+                        check_struct_safe_for_destructor(fcx, item.span, def_id);\n                     }\n                     _ => {\n                         // Coherence already reports an error in this case.\n@@ -221,7 +221,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let poly_trait_ref = ty::Binder(trait_ref);\n             let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &poly_trait_ref);\n             for predicate in predicates.into_iter() {\n-                fcx.register_predicate(traits::Obligation::new(cause, predicate));\n+                fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n             }\n         });\n     }\n@@ -460,20 +460,16 @@ fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n \n fn check_struct_safe_for_destructor<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                               span: Span,\n-                                              self_ty: Ty<'tcx>,\n                                               struct_did: ast::DefId) {\n     let struct_tpt = ty::lookup_item_type(fcx.tcx(), struct_did);\n-    if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n-        && !struct_tpt.generics.has_region_params(subst::TypeSpace)\n+    if struct_tpt.generics.has_type_params(subst::TypeSpace)\n+        || struct_tpt.generics.has_region_params(subst::TypeSpace)\n     {\n-        let cause = traits::ObligationCause::new(span, fcx.body_id, traits::DropTrait);\n-        fcx.register_builtin_bound(self_ty, ty::BoundSend, cause);\n-    } else {\n         span_err!(fcx.tcx().sess, span, E0141,\n                   \"cannot implement a destructor on a structure \\\n-                       with type parameters\");\n-            span_note!(fcx.tcx().sess, span,\n-                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n-                        to force the compiler to allow this\");\n+                   with type parameters\");\n+        span_note!(fcx.tcx().sess, span,\n+                   \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n+                    to force the compiler to allow this\");\n     }\n }"}, {"sha": "ffe19203769d4c6386be784c1b10ce2bdd6d5e07", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -72,13 +72,12 @@ use libc;\n \n use fmt;\n use hash;\n-use kinds::marker;\n use mem;\n use ptr;\n use slice::{mod, ImmutableIntSlice};\n use str;\n use string::String;\n-\n+use core::kinds::marker;\n \n /// The representation of a C String.\n ///\n@@ -90,6 +89,9 @@ pub struct CString {\n     owns_buffer_: bool,\n }\n \n+unsafe impl Send for CString { }\n+unsafe impl Sync for CString { }\n+\n impl Clone for CString {\n     /// Clone this CString into a new, uniquely owned CString. For safety\n     /// reasons, this is always a deep clone with the memory allocated"}, {"sha": "f4338815f759bcd7cd91eb1c30ec020ddf2e615e", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -180,12 +180,12 @@ mod tests {\n \n     fn malloc(n: uint) -> CVec<u8> {\n         unsafe {\n-            let mem = libc::malloc(n as libc::size_t);\n-            if mem.is_null() { ::alloc::oom() }\n+            let mem = ptr::Unique(libc::malloc(n as libc::size_t));\n+            if mem.0.is_null() { ::alloc::oom() }\n \n-            CVec::new_with_dtor(mem as *mut u8,\n+            CVec::new_with_dtor(mem.0 as *mut u8,\n                                 n,\n-                                move|| { libc::free(mem as *mut libc::c_void); })\n+                                move|| { libc::free(mem.0 as *mut libc::c_void); })\n         }\n     }\n "}, {"sha": "3ae3a8ffbad3bfe3399559851dbbecdbec3c1018", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -23,7 +23,7 @@ use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::{RawPtr, copy_nonoverlapping_memory, zero_memory};\n+use ptr::{Unique, RawPtr, copy_nonoverlapping_memory, zero_memory};\n use ptr;\n use rt::heap::{allocate, deallocate};\n \n@@ -69,7 +69,7 @@ const EMPTY_BUCKET: u64 = 0u64;\n pub struct RawTable<K, V> {\n     capacity: uint,\n     size:     uint,\n-    hashes:   *mut u64,\n+    hashes:   Unique<u64>,\n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n     marker:   marker::CovariantType<(K,V)>,\n@@ -563,7 +563,7 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: 0 as *mut u64,\n+                hashes: Unique::null(),\n                 marker: marker::CovariantType,\n             };\n         }\n@@ -602,7 +602,7 @@ impl<K, V> RawTable<K, V> {\n         RawTable {\n             capacity: capacity,\n             size:     0,\n-            hashes:   hashes,\n+            hashes:   Unique(hashes),\n             marker:   marker::CovariantType,\n         }\n     }\n@@ -611,14 +611,14 @@ impl<K, V> RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n \n-        let buffer = self.hashes as *mut u8;\n+        let buffer = self.hashes.0 as *mut u8;\n         let (keys_offset, vals_offset) = calculate_offsets(hashes_size,\n                                                            keys_size, min_align_of::<K>(),\n                                                            min_align_of::<V>());\n \n         unsafe {\n             RawBucket {\n-                hash: self.hashes,\n+                hash: self.hashes.0,\n                 key:  buffer.offset(keys_offset as int) as *mut K,\n                 val:  buffer.offset(vals_offset as int) as *mut V\n             }\n@@ -631,7 +631,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: uint) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            zero_memory(ret.hashes, capacity);\n+            zero_memory(ret.hashes.0, capacity);\n             ret\n         }\n     }\n@@ -651,7 +651,7 @@ impl<K, V> RawTable<K, V> {\n         RawBuckets {\n             raw: self.first_bucket_raw(),\n             hashes_end: unsafe {\n-                self.hashes.offset(self.capacity as int)\n+                self.hashes.0.offset(self.capacity as int)\n             },\n             marker: marker::ContravariantLifetime,\n         }\n@@ -916,7 +916,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n #[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.hashes.is_null() {\n+        if self.hashes.0.is_null() {\n             return;\n         }\n         // This is done in reverse because we've likely partially taken\n@@ -936,7 +936,7 @@ impl<K, V> Drop for RawTable<K, V> {\n                                                     vals_size, min_align_of::<V>());\n \n         unsafe {\n-            deallocate(self.hashes as *mut u8, size, align);\n+            deallocate(self.hashes.0 as *mut u8, size, align);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "412b7161305e68b12c2d9db7adc400ad1ad834fc", "filename": "src/libstd/comm/blocking.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fblocking.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -13,6 +13,7 @@\n use thread::Thread;\n use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Ordering};\n use sync::Arc;\n+use kinds::{Sync, Send};\n use kinds::marker::{NoSend, NoSync};\n use mem;\n use clone::Clone;\n@@ -22,6 +23,9 @@ struct Inner {\n     woken: AtomicBool,\n }\n \n+unsafe impl Send for Inner {}\n+unsafe impl Sync for Inner {}\n+\n #[deriving(Clone)]\n pub struct SignalToken {\n     inner: Arc<Inner>,"}, {"sha": "c85bea87218ff6be2aa279890ad08dd1c4ed76db", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -319,6 +319,7 @@ pub use self::TrySendError::*;\n use self::Flavor::*;\n \n use alloc::arc::Arc;\n+use core::kinds;\n use core::kinds::marker;\n use core::mem;\n use core::cell::UnsafeCell;\n@@ -357,10 +358,12 @@ mod spsc_queue;\n #[unstable]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n-    // can't share in an arc\n-    _marker: marker::NoSync,\n }\n \n+// The receiver port can be sent from place to place, so long as it\n+// is not used to receive non-sendable things.\n+unsafe impl<T:Send> Send for Receiver<T> { }\n+\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n@@ -374,15 +377,17 @@ pub struct Messages<'a, T:'a> {\n #[unstable]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n-    // can't share in an arc\n-    _marker: marker::NoSync,\n }\n \n+// The send port can be sent from place to place, so long as it\n+// is not used to send non-sendable things.\n+unsafe impl<T:Send> Send for Sender<T> { }\n+\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[unstable = \"this type may be renamed, but it will always exist\"]\n pub struct SyncSender<T> {\n-    inner: Arc<UnsafeCell<sync::Packet<T>>>,\n+    inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n@@ -418,10 +423,10 @@ pub enum TrySendError<T> {\n }\n \n enum Flavor<T> {\n-    Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n-    Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n-    Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n-    Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n+    Oneshot(Arc<RacyCell<oneshot::Packet<T>>>),\n+    Stream(Arc<RacyCell<stream::Packet<T>>>),\n+    Shared(Arc<RacyCell<shared::Packet<T>>>),\n+    Sync(Arc<RacyCell<sync::Packet<T>>>),\n }\n \n #[doc(hidden)]\n@@ -472,7 +477,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// ```\n #[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n+    let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n     (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n }\n \n@@ -512,7 +517,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n #[unstable = \"this function may be renamed to more accurately reflect the type \\\n               of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n+    let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n }\n \n@@ -524,7 +529,6 @@ impl<T: Send> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n         Sender {\n             inner: UnsafeCell::new(inner),\n-            _marker: marker::NoSync,\n         }\n     }\n \n@@ -594,7 +598,8 @@ impl<T: Send> Sender<T> {\n                     if !(*p).sent() {\n                         return (*p).send(t);\n                     } else {\n-                        let a = Arc::new(UnsafeCell::new(stream::Packet::new()));\n+                        let a =\n+                            Arc::new(RacyCell::new(stream::Packet::new()));\n                         match (*p).upgrade(Receiver::new(Stream(a.clone()))) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n@@ -631,7 +636,7 @@ impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n+                let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n@@ -642,7 +647,7 @@ impl<T: Send> Clone for Sender<T> {\n                 }\n             }\n             Stream(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n+                let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n@@ -686,7 +691,7 @@ impl<T: Send> Drop for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> SyncSender<T> {\n-    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n+    fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner, _marker: marker::NoSync }\n     }\n \n@@ -775,7 +780,7 @@ impl<T: Send> Drop for SyncSender<T> {\n \n impl<T: Send> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: UnsafeCell::new(inner), _marker: marker::NoSync }\n+        Receiver { inner: UnsafeCell::new(inner) }\n     }\n \n     /// Blocks waiting for a value on this receiver\n@@ -1018,6 +1023,27 @@ impl<T: Send> Drop for Receiver<T> {\n     }\n }\n \n+/// A version of `UnsafeCell` intended for use in concurrent data\n+/// structures (for example, you might put it in an `Arc`).\n+struct RacyCell<T>(pub UnsafeCell<T>);\n+\n+impl<T> RacyCell<T> {\n+\n+    fn new(value: T) -> RacyCell<T> {\n+        RacyCell(UnsafeCell { value: value })\n+    }\n+\n+    unsafe fn get(&self) -> *mut T {\n+        self.0.get()\n+    }\n+\n+}\n+\n+unsafe impl<T:Send> Send for RacyCell<T> { }\n+\n+unsafe impl<T> kinds::Sync for RacyCell<T> { } // Oh dear\n+\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "cddef236664343332998cf53dbaebd6358449a76", "filename": "src/libstd/comm/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -76,6 +76,9 @@ pub struct Queue<T> {\n     tail: UnsafeCell<*mut Node<T>>,\n }\n \n+unsafe impl<T:Send> Send for Queue<T> { }\n+unsafe impl<T:Send> Sync for Queue<T> { }\n+\n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n         mem::transmute(box Node {"}, {"sha": "becb78063aeb5ae82ae9c87676879c0f3d678686", "filename": "src/libstd/comm/spsc_queue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fspsc_queue.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -73,6 +73,10 @@ pub struct Queue<T> {\n     cache_subtractions: AtomicUint,\n }\n \n+unsafe impl<T: Send> Send for Queue<T> { }\n+\n+unsafe impl<T: Send> Sync for Queue<T> { }\n+\n impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {"}, {"sha": "88338849965b0589177f9aeda001a9c6e16ee44b", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -53,6 +53,10 @@ pub struct Packet<T> {\n     lock: Mutex<State<T>>,\n }\n \n+unsafe impl<T:Send> Send for Packet<T> { }\n+\n+unsafe impl<T:Send> Sync for Packet<T> { }\n+\n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n     queue: Queue,       // queue of senders waiting to send data\n@@ -69,6 +73,8 @@ struct State<T> {\n     canceled: Option<&'static mut bool>,\n }\n \n+unsafe impl<T: Send> Send for State<T> {}\n+\n /// Possible flavors of threads who can be blocked on this channel.\n enum Blocker {\n     BlockedSender(SignalToken),\n@@ -88,6 +94,8 @@ struct Node {\n     next: *mut Node,\n }\n \n+unsafe impl Send for Node {}\n+\n /// A simple ring-buffer\n struct Buffer<T> {\n     buf: Vec<Option<T>>,"}, {"sha": "c26450310a9b286a8b2f95a98d32ac27a2b958fe", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -22,6 +22,7 @@ use result::Result::{Ok, Err};\n use slice::{SliceExt};\n use slice;\n use vec::Vec;\n+use kinds::{Send,Sync};\n \n /// Wraps a Reader and buffers input from it\n ///\n@@ -51,6 +52,11 @@ pub struct BufferedReader<R> {\n     cap: uint,\n }\n \n+\n+unsafe impl<R: Send> Send for BufferedReader<R> {}\n+unsafe impl<R: Send+Sync> Sync for BufferedReader<R> {}\n+\n+\n impl<R: Reader> BufferedReader<R> {\n     /// Creates a new `BufferedReader` with the specified buffer capacity\n     pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {"}, {"sha": "b7da57fed270839911710e87b44ac8a78b9c0f40", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -34,7 +34,7 @@ use failure::LOCAL_STDERR;\n use fmt;\n use io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n-use kinds::Send;\n+use kinds::{Sync, Send};\n use libc;\n use mem;\n use option::Option;\n@@ -98,26 +98,34 @@ thread_local! {\n     }\n }\n \n+struct RaceBox(BufferedReader<StdReader>);\n+\n+unsafe impl Send for RaceBox {}\n+unsafe impl Sync for RaceBox {}\n+\n /// A synchronized wrapper around a buffered reader from stdin\n #[deriving(Clone)]\n pub struct StdinReader {\n-    inner: Arc<Mutex<BufferedReader<StdReader>>>,\n+    inner: Arc<Mutex<RaceBox>>,\n }\n \n+unsafe impl Send for StdinReader {}\n+unsafe impl Sync for StdinReader {}\n+\n /// A guard for exclusive access to `StdinReader`'s internal `BufferedReader`.\n pub struct StdinReaderGuard<'a> {\n-    inner: MutexGuard<'a, BufferedReader<StdReader>>,\n+    inner: MutexGuard<'a, RaceBox>,\n }\n \n impl<'a> Deref<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n     fn deref(&self) -> &BufferedReader<StdReader> {\n-        &*self.inner\n+        &self.inner.0\n     }\n }\n \n impl<'a> DerefMut<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n     fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> {\n-        &mut *self.inner\n+        &mut self.inner.0\n     }\n }\n \n@@ -147,53 +155,53 @@ impl StdinReader {\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_line(&mut self) -> IoResult<String> {\n-        self.inner.lock().read_line()\n+        self.inner.lock().0.read_line()\n     }\n \n     /// Like `Buffer::read_until`.\n     ///\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n-        self.inner.lock().read_until(byte)\n+        self.inner.lock().0.read_until(byte)\n     }\n \n     /// Like `Buffer::read_char`.\n     ///\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_char(&mut self) -> IoResult<char> {\n-        self.inner.lock().read_char()\n+        self.inner.lock().0.read_char()\n     }\n }\n \n impl Reader for StdinReader {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner.lock().read(buf)\n+        self.inner.lock().0.read(buf)\n     }\n \n     // We have to manually delegate all of these because the default impls call\n     // read more than once and we don't want those calls to interleave (or\n     // incur the costs of repeated locking).\n \n     fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner.lock().read_at_least(min, buf)\n+        self.inner.lock().0.read_at_least(min, buf)\n     }\n \n     fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n-        self.inner.lock().push_at_least(min, len, buf)\n+        self.inner.lock().0.push_at_least(min, len, buf)\n     }\n \n     fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n-        self.inner.lock().read_to_end()\n+        self.inner.lock().0.read_to_end()\n     }\n \n     fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n-        self.inner.lock().read_le_uint_n(nbytes)\n+        self.inner.lock().0.read_le_uint_n(nbytes)\n     }\n \n     fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n-        self.inner.lock().read_be_uint_n(nbytes)\n+        self.inner.lock().0.read_be_uint_n(nbytes)\n     }\n }\n \n@@ -221,7 +229,7 @@ pub fn stdin() -> StdinReader {\n                 BufferedReader::new(stdin_raw())\n             };\n             let stdin = StdinReader {\n-                inner: Arc::new(Mutex::new(stdin))\n+                inner: Arc::new(Mutex::new(RaceBox(stdin)))\n             };\n             STDIN = mem::transmute(box stdin);\n \n@@ -426,6 +434,9 @@ pub struct StdWriter {\n     inner: StdSource\n }\n \n+unsafe impl Send for StdWriter {}\n+unsafe impl Sync for StdWriter {}\n+\n impl StdWriter {\n     /// Gets the size of this output window, if possible. This is typically used\n     /// when the writer is attached to something like a terminal, this is used"}, {"sha": "88bdb29caecadc94b7e386cd02979ed039fee701", "filename": "src/libstd/rt/exclusive.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Frt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Frt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fexclusive.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -26,6 +26,10 @@ pub struct Exclusive<T> {\n     data: UnsafeCell<T>,\n }\n \n+unsafe impl<T:Send> Send for Exclusive<T> { }\n+\n+unsafe impl<T:Send> Sync for Exclusive<T> { }\n+\n /// An RAII guard returned via `lock`\n pub struct ExclusiveGuard<'a, T:'a> {\n     // FIXME #12808: strange name to try to avoid interfering with"}, {"sha": "6cdb199819aff60f61a996ad3426f503c621738f", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use kinds::{Send, Sync};\n use sync::{Mutex, Condvar};\n \n /// A barrier enables multiple tasks to synchronize the beginning\n@@ -35,12 +36,18 @@ pub struct Barrier {\n     num_threads: uint,\n }\n \n+unsafe impl Send for Barrier {}\n+unsafe impl Sync for Barrier {}\n+\n // The inner state of a double barrier\n struct BarrierState {\n     count: uint,\n     generation_id: uint,\n }\n \n+unsafe impl Send for BarrierState {}\n+unsafe impl Sync for BarrierState {}\n+\n impl Barrier {\n     /// Create a new barrier that can block a given number of threads.\n     ///"}, {"sha": "f1940bfd829b769934d46c33068f2420f2634cf8", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -58,6 +58,9 @@ use time::Duration;\n /// ```\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n /// Statically allocated condition variables.\n ///\n /// This structure is identical to `Condvar` except that it is suitable for use\n@@ -75,6 +78,9 @@ pub struct StaticCondvar {\n     mutex: AtomicUint,\n }\n \n+unsafe impl Send for StaticCondvar {}\n+unsafe impl Sync for StaticCondvar {}\n+\n /// Constant initializer for a statically allocated condition variable.\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,"}, {"sha": "4d2fbfc4055f4163b5df12e0f63b9b1f3517c7d0", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -73,6 +73,10 @@ pub struct Mutex<T> {\n     data: UnsafeCell<T>,\n }\n \n+unsafe impl<T:Send> Send for Mutex<T> { }\n+\n+unsafe impl<T:Send> Sync for Mutex<T> { }\n+\n /// The static mutex type is provided to allow for static allocation of mutexes.\n ///\n /// Note that this is a separate type because using a Mutex correctly means that\n@@ -99,6 +103,8 @@ pub struct StaticMutex {\n     poison: UnsafeCell<poison::Flag>,\n }\n \n+unsafe impl Sync for StaticMutex {}\n+\n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked.\n ///\n@@ -278,6 +284,11 @@ mod test {\n     use thread::Thread;\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n \n+    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n+\n+    unsafe impl<T:'static+Send> Send for Packet<T> {}\n+    unsafe impl<T> Sync for Packet<T> {}\n+\n     #[test]\n     fn smoke() {\n         let m = Mutex::new(());\n@@ -337,19 +348,19 @@ mod test {\n \n     #[test]\n     fn test_mutex_arc_condvar() {\n-        let arc = Arc::new((Mutex::new(false), Condvar::new()));\n-        let arc2 = arc.clone();\n+        let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));\n+        let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n         spawn(move|| {\n             // wait until parent gets in\n             rx.recv();\n-            let &(ref lock, ref cvar) = &*arc2;\n+            let &(ref lock, ref cvar) = &*packet2.0;\n             let mut lock = lock.lock();\n             *lock = true;\n             cvar.notify_one();\n         });\n \n-        let &(ref lock, ref cvar) = &*arc;\n+        let &(ref lock, ref cvar) = &*packet.0;\n         let lock = lock.lock();\n         tx.send(());\n         assert!(!*lock);\n@@ -361,20 +372,20 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_arc_condvar_poison() {\n-        let arc = Arc::new((Mutex::new(1i), Condvar::new()));\n-        let arc2 = arc.clone();\n+        let packet = Packet(Arc::new((Mutex::new(1i), Condvar::new())));\n+        let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n \n         spawn(move|| {\n             rx.recv();\n-            let &(ref lock, ref cvar) = &*arc2;\n+            let &(ref lock, ref cvar) = &*packet2.0;\n             let _g = lock.lock();\n             cvar.notify_one();\n             // Parent should fail when it wakes up.\n             panic!();\n         });\n \n-        let &(ref lock, ref cvar) = &*arc;\n+        let &(ref lock, ref cvar) = &*packet.0;\n         let lock = lock.lock();\n         tx.send(());\n         while *lock == 1 {"}, {"sha": "4d9fbb5990840af8ce3ab716a962b3e66c20912e", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -14,6 +14,7 @@\n //! example use case would be for initializing an FFI library.\n \n use int;\n+use kinds::Sync;\n use mem::drop;\n use ops::FnOnce;\n use sync::atomic;\n@@ -41,6 +42,8 @@ pub struct Once {\n     lock_cnt: atomic::AtomicInt,\n }\n \n+unsafe impl Sync for Once {}\n+\n /// Initialization value for static `Once` values.\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,"}, {"sha": "76d05d9bfd419ad796ffb8f4ad4d050c822b0a13", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -60,6 +60,9 @@ pub struct RWLock<T> {\n     data: UnsafeCell<T>,\n }\n \n+unsafe impl<T:'static+Send> Send for RWLock<T> {}\n+unsafe impl<T> Sync for RWLock<T> {}\n+\n /// Structure representing a statically allocated RWLock.\n ///\n /// This structure is intended to be used inside of a `static` and will provide\n@@ -88,6 +91,9 @@ pub struct StaticRWLock {\n     poison: UnsafeCell<poison::Flag>,\n }\n \n+unsafe impl Send for StaticRWLock {}\n+unsafe impl Sync for StaticRWLock {}\n+\n /// Constant initialization for a statically-initialized rwlock.\n pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n     inner: sys::RWLOCK_INIT,"}, {"sha": "a629f035b07afad3b0a5c294496549527aca27ef", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -59,6 +59,15 @@ pub struct Helper<M> {\n     pub shutdown: UnsafeCell<bool>,\n }\n \n+unsafe impl<M:Send> Send for Helper<M> { }\n+\n+unsafe impl<M:Send> Sync for Helper<M> { }\n+\n+struct RaceBox(helper_signal::signal);\n+\n+unsafe impl Send for RaceBox {}\n+unsafe impl Sync for RaceBox {}\n+\n impl<M: Send> Helper<M> {\n     /// Lazily boots a helper thread, becoming a no-op if the helper has already\n     /// been spawned.\n@@ -81,9 +90,11 @@ impl<M: Send> Helper<M> {\n                 let (receive, send) = helper_signal::new();\n                 *self.signal.get() = send as uint;\n \n+                let receive = RaceBox(receive);\n+\n                 let t = f();\n                 Thread::spawn(move |:| {\n-                    helper(receive, rx, t);\n+                    helper(receive.0, rx, t);\n                     let _g = self.lock.lock();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()"}, {"sha": "567c26956efe94f6c3a1e62d440b7e75b9d46035", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use kinds::Sync;\n use sys::mutex as imp;\n \n /// An OS-based mutual exclusion lock.\n@@ -17,6 +18,8 @@ use sys::mutex as imp;\n /// at the top level of the crate instead of this type.\n pub struct Mutex(imp::Mutex);\n \n+unsafe impl Sync for Mutex {}\n+\n /// Constant initializer for statically allocated mutexes.\n pub const MUTEX_INIT: Mutex = Mutex(imp::MUTEX_INIT);\n "}, {"sha": "a4ebcbd25d00efc345345c66b8562ff551104cd4", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -162,6 +162,9 @@ mod signal {\n         sa_restorer: *mut libc::c_void,\n     }\n \n+    unsafe impl ::kinds::Send for sigaction { }\n+    unsafe impl ::kinds::Sync for sigaction { }\n+\n     #[repr(C)]\n     #[cfg(target_word_size = \"32\")]\n     pub struct sigset_t {\n@@ -211,6 +214,9 @@ mod signal {\n         sa_resv: [libc::c_int, ..1],\n     }\n \n+    impl ::kinds::Send for sigaction { }\n+    impl ::kinds::Sync for sigaction { }\n+\n     #[repr(C)]\n     pub struct sigset_t {\n         __val: [libc::c_ulong, ..32],"}, {"sha": "81f8659d6ae08b87c79c247655ab1c68a668a1ba", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use cell::UnsafeCell;\n+use kinds::Sync;\n use sys::sync as ffi;\n use sys_common::mutex;\n \n@@ -23,6 +24,8 @@ pub const MUTEX_INIT: Mutex = Mutex {\n     inner: UnsafeCell { value: ffi::PTHREAD_MUTEX_INITIALIZER },\n };\n \n+unsafe impl Sync for Mutex {}\n+\n impl Mutex {\n     #[inline]\n     pub unsafe fn new() -> Mutex {"}, {"sha": "f1b078b4e80ab6c46d3f81a23ec980e0b163830b", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -117,6 +117,9 @@ pub struct UnixStream {\n     write_deadline: u64,\n }\n \n+unsafe impl Send for UnixStream {}\n+unsafe impl Sync for UnixStream {}\n+\n impl UnixStream {\n     pub fn connect(addr: &CString,\n                    timeout: Option<u64>) -> IoResult<UnixStream> {\n@@ -215,6 +218,9 @@ pub struct UnixListener {\n     path: CString,\n }\n \n+unsafe impl Send for UnixListener {}\n+unsafe impl Sync for UnixListener {}\n+\n impl UnixListener {\n     pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n         bind(addr, libc::SOCK_STREAM).map(|fd| {\n@@ -259,6 +265,9 @@ struct AcceptorInner {\n     closed: atomic::AtomicBool,\n }\n \n+unsafe impl Send for AcceptorInner {}\n+unsafe impl Sync for AcceptorInner {}\n+\n impl UnixAcceptor {\n     pub fn fd(&self) -> fd_t { self.inner.listener.fd() }\n "}, {"sha": "bcbbb8766b7f47038534f8b574e19be6c9773989", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -160,7 +160,7 @@ mod imp {\n \n         pub static SIGSTKSZ: libc::size_t = 8192;\n \n-        pub static SIG_DFL: sighandler_t = 0i as sighandler_t;\n+        pub const SIG_DFL: sighandler_t = 0i as sighandler_t;\n \n         // This definition is not as accurate as it could be, {si_addr} is\n         // actually a giant union. Currently we're only interested in that field,"}, {"sha": "e2a78947e167ab015c9ea3950b3d5a0b1fda65d3", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -33,6 +33,8 @@ pub struct TcpListener {\n     pub inner: FileDesc,\n }\n \n+unsafe impl Sync for TcpListener {}\n+\n impl TcpListener {\n     pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n         let fd = try!(net::socket(addr, libc::SOCK_STREAM));\n@@ -96,6 +98,8 @@ struct AcceptorInner {\n     closed: atomic::AtomicBool,\n }\n \n+unsafe impl Sync for AcceptorInner {}\n+\n impl TcpAcceptor {\n     pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n "}, {"sha": "3ac7c09154e352e10d1514a618f7d3ccb4a784e3", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -22,6 +22,8 @@ pub struct Mutex { inner: atomic::AtomicUint }\n \n pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::INIT_ATOMIC_UINT };\n \n+unsafe impl Sync for Mutex {}\n+\n #[inline]\n pub unsafe fn raw(m: &Mutex) -> ffi::LPCRITICAL_SECTION {\n     m.get()"}, {"sha": "fc3640f260437b8d1f72a1eb1f5ccb6cbbe2add7", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -214,6 +214,9 @@ pub struct UnixStream {\n     write_deadline: u64,\n }\n \n+unsafe impl Send for UnixStream {}\n+unsafe impl Sync for UnixStream {}\n+\n impl UnixStream {\n     fn try_connect(p: *const u16) -> Option<libc::HANDLE> {\n         // Note that most of this is lifted from the libuv implementation.\n@@ -559,6 +562,9 @@ pub struct UnixListener {\n     name: CString,\n }\n \n+unsafe impl Send for UnixListener {}\n+unsafe impl Sync for UnixListener {}\n+\n impl UnixListener {\n     pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n         // Although we technically don't need the pipe until much later, we\n@@ -603,11 +609,17 @@ pub struct UnixAcceptor {\n     deadline: u64,\n }\n \n+unsafe impl Send for UnixAcceptor {}\n+unsafe impl Sync for UnixAcceptor {}\n+\n struct AcceptorState {\n     abort: Event,\n     closed: atomic::AtomicBool,\n }\n \n+unsafe impl Send for AcceptorState {}\n+unsafe impl Sync for AcceptorState {}\n+\n impl UnixAcceptor {\n     pub fn accept(&mut self) -> IoResult<UnixStream> {\n         // This function has some funky implementation details when working with"}, {"sha": "513c1d38e363492bf5b4111675fafe2453780637", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -24,6 +24,9 @@ pub use sys_common::net::TcpStream;\n \n pub struct Event(c::WSAEVENT);\n \n+unsafe impl Send for Event {}\n+unsafe impl Sync for Event {}\n+\n impl Event {\n     pub fn new() -> IoResult<Event> {\n         let event = unsafe { c::WSACreateEvent() };\n@@ -49,6 +52,9 @@ impl Drop for Event {\n \n pub struct TcpListener { sock: sock_t }\n \n+unsafe impl Send for TcpListener {}\n+unsafe impl Sync for TcpListener {}\n+\n impl TcpListener {\n     pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n         sys::init_net();\n@@ -109,13 +115,19 @@ pub struct TcpAcceptor {\n     deadline: u64,\n }\n \n+unsafe impl Send for TcpAcceptor {}\n+unsafe impl Sync for TcpAcceptor {}\n+\n struct AcceptorInner {\n     listener: TcpListener,\n     abort: Event,\n     accept: Event,\n     closed: atomic::AtomicBool,\n }\n \n+unsafe impl Send for AcceptorInner {}\n+unsafe impl Sync for AcceptorInner {}\n+\n impl TcpAcceptor {\n     pub fn socket(&self) -> sock_t { self.inner.listener.socket() }\n "}, {"sha": "874838950cd12bfcd59f0751d74d64b40de9cbfc", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -48,6 +48,9 @@ pub enum Req {\n     RemoveTimer(libc::HANDLE, Sender<()>),\n }\n \n+unsafe impl Send for Req {}\n+\n+\n fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n     let mut objs = vec![input];\n     let mut chans = vec![];"}, {"sha": "56731bd7ec3ee2a38d99026349cc991729b05688", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -129,7 +129,7 @@ use borrow::IntoCow;\n use boxed::Box;\n use cell::UnsafeCell;\n use clone::Clone;\n-use kinds::Send;\n+use kinds::{Send, Sync};\n use ops::{Drop, FnOnce};\n use option::Option::{mod, Some, None};\n use result::Result::{Err, Ok};\n@@ -211,8 +211,8 @@ impl Builder {\n     }\n \n     fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> JoinGuard<T> {\n-        let my_packet = Arc::new(UnsafeCell::new(None));\n-        let their_packet = my_packet.clone();\n+        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n+        let their_packet = Packet(my_packet.0.clone());\n \n         let Builder { name, stack_size, stdout, stderr } = self;\n \n@@ -266,7 +266,7 @@ impl Builder {\n                 }\n             };\n             unsafe {\n-                *their_packet.get() = Some(match (output, try_result) {\n+                *their_packet.0.get() = Some(match (output, try_result) {\n                     (Some(data), Ok(_)) => Ok(data),\n                     (None, Err(cause)) => Err(cause),\n                     _ => unreachable!()\n@@ -289,12 +289,16 @@ struct Inner {\n     cvar: Condvar,\n }\n \n+unsafe impl Sync for Inner {}\n+\n #[deriving(Clone)]\n /// A handle to a thread.\n pub struct Thread {\n     inner: Arc<Inner>,\n }\n \n+unsafe impl Sync for Thread {}\n+\n impl Thread {\n     // Used only internally to construct a thread object without spawning\n     fn new(name: Option<String>) -> Thread {\n@@ -379,6 +383,11 @@ impl thread_info::NewThread for Thread {\n /// A thread that completes without panicking is considered to exit successfully.\n pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n \n+struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n+\n+unsafe impl<T:'static+Send> Send for Packet<T> {}\n+unsafe impl<T> Sync for Packet<T> {}\n+\n #[must_use]\n /// An RAII-style guard that will block until thread termination when dropped.\n ///\n@@ -387,9 +396,11 @@ pub struct JoinGuard<T> {\n     native: imp::rust_thread,\n     thread: Thread,\n     joined: bool,\n-    packet: Arc<UnsafeCell<Option<Result<T>>>>,\n+    packet: Packet<T>,\n }\n \n+unsafe impl<T: Send> Sync for JoinGuard<T> {}\n+\n impl<T: Send> JoinGuard<T> {\n     /// Extract a handle to the thread this guard will join on.\n     pub fn thread(&self) -> &Thread {\n@@ -406,7 +417,7 @@ impl<T: Send> JoinGuard<T> {\n         unsafe { imp::join(self.native) };\n         self.joined = true;\n         unsafe {\n-            (*self.packet.get()).take().unwrap()\n+            (*self.packet.0.get()).take().unwrap()\n         }\n     }\n "}, {"sha": "242dceb425636291692151bf6bf0c0adc2f82b6b", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -280,6 +280,8 @@ mod imp {\n         pub dtor_running: UnsafeCell<bool>, // should be Cell\n     }\n \n+    unsafe impl<T> ::kinds::Sync for Key<T> { }\n+\n     #[doc(hidden)]\n     impl<T> Key<T> {\n         pub unsafe fn get(&'static self) -> Option<&'static T> {\n@@ -410,6 +412,8 @@ mod imp {\n         pub os: OsStaticKey,\n     }\n \n+    unsafe impl<T> ::kinds::Sync for Key<T> { }\n+\n     struct Value<T: 'static> {\n         key: &'static Key<T>,\n         value: T,"}, {"sha": "756c86c211547efaebea7df4e9e55adc557aa867", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -198,10 +198,11 @@ impl<T> Key<T> {\n mod imp {\n     use std::cell::UnsafeCell;\n \n-    // FIXME: Should be a `Cell`, but that's not `Sync`\n     #[doc(hidden)]\n     pub struct KeyInner<T> { pub inner: UnsafeCell<*mut T> }\n \n+    unsafe impl<T> ::kinds::Sync for KeyInner<T> { }\n+\n     #[doc(hidden)]\n     impl<T> KeyInner<T> {\n         #[doc(hidden)]\n@@ -222,6 +223,8 @@ mod imp {\n         pub marker: marker::InvariantType<T>,\n     }\n \n+    unsafe impl<T> ::kinds::Sync for KeyInner<T> { }\n+\n     #[doc(hidden)]\n     impl<T> KeyInner<T> {\n         #[doc(hidden)]"}, {"sha": "cf29bb048d6445b4f98bdc67b80aee7d9cac9094", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -26,8 +26,11 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n         MetaWord(ref tname) => {\n             match tname.get() {\n                 \"Copy\" => \"Copy\",\n-                \"Send\" => \"Send\",\n-                \"Sync\" => \"Sync\",\n+                \"Send\" | \"Sync\" => {\n+                    return cx.span_err(span,\n+                                       format!(\"{} is an unsafe trait and it \\\n+                                               should be implemented explicitly\", *tname)[])\n+                }\n                 ref tname => {\n                     cx.span_bug(span,\n                                 format!(\"expected built-in trait name but \\"}, {"sha": "88dd6fce88f044337fcccb147db68127240b0e88", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -976,6 +976,8 @@ enum TestEvent {\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n \n+unsafe impl Send for MonitorMsg {}\n+\n fn run_tests<F>(opts: &TestOpts,\n                 tests: Vec<TestDescAndFn> ,\n                 mut callback: F) -> io::IoResult<()> where"}, {"sha": "66965110f73eeb824cb64eabcc4f87b846b72c9b", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -46,7 +46,7 @@ extern crate libc;\n \n use std::io::stdio::{stdin_raw, stdout_raw};\n use std::num::{div_rem};\n-use std::ptr::{copy_memory};\n+use std::ptr::{copy_memory, Unique};\n use std::io::{IoResult, EndOfFile};\n \n struct Tables {\n@@ -219,10 +219,15 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n     }\n }\n \n+\n+struct Racy<T>(T);\n+\n+unsafe impl<T: 'static> Send for Racy<T> {}\n+\n /// Executes a closure in parallel over the given iterator over mutable slice.\n /// The closure `f` is run in parallel with an element of `iter`.\n fn parallel<'a, I, T, F>(mut iter: I, f: F)\n-        where T: Send + Sync,\n+        where T: 'a+Send + Sync,\n               I: Iterator<&'a mut [T]>,\n               F: Fn(&'a mut [T]) + Sync {\n     use std::mem;\n@@ -234,11 +239,11 @@ fn parallel<'a, I, T, F>(mut iter: I, f: F)\n \n         // Need to convert `f` and `chunk` to something that can cross the task\n         // boundary.\n-        let f = &f as *const F as *const uint;\n-        let raw = chunk.repr();\n+        let f = Racy(&f as *const F as *const uint);\n+        let raw = Racy(chunk.repr());\n         spawn(move|| {\n-            let f = f as *const F;\n-            unsafe { (*f)(mem::transmute(raw)) }\n+            let f = f.0 as *const F;\n+            unsafe { (*f)(mem::transmute(raw.0)) }\n             drop(tx)\n         });\n     }"}, {"sha": "df388fbdde54fd6a89866087186bbba5b279ebcc", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -108,6 +108,11 @@ fn dot(v: &[f64], u: &[f64]) -> f64 {\n     v.iter().zip(u.iter()).map(|(a, b)| *a * *b).sum()\n }\n \n+\n+struct Racy<T>(T);\n+\n+unsafe impl<T: 'static> Send for Racy<T> {}\n+\n // Executes a closure in parallel over the given mutable slice. The closure `f`\n // is run in parallel and yielded the starting index within `v` as well as a\n // sub-slice of `v`.\n@@ -122,11 +127,11 @@ fn parallel<'a, T, F>(v: &'a mut [T], f: F)\n \n         // Need to convert `f` and `chunk` to something that can cross the task\n         // boundary.\n-        let f = &f as *const _ as *const uint;\n-        let raw = chunk.repr();\n+        let f = Racy(&f as *const _ as *const uint);\n+        let raw = Racy(chunk.repr());\n         spawn(move|| {\n-            let f = f as *const F;\n-            unsafe { (*f)(i * size, mem::transmute(raw)) }\n+            let f = f.0 as *const F;\n+            unsafe { (*f)(i * size, mem::transmute(raw.0)) }\n             drop(tx)\n         });\n     }"}, {"sha": "d61ad98ee1e53f6ad8206c3028fc4d14c4d6ff6c", "filename": "src/test/compile-fail/deriving-bounds.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fderiving-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fderiving-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-bounds.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Sync(Bad),Send,Copy)]\n+#[deriving(Copy(Bad))]\n //~^ ERROR unexpected value in deriving, expected a trait\n struct Test;\n \n+#[deriving(Sync)]\n+//~^ ERROR Sync is an unsafe trait and it should be implemented explicitly\n+struct Test1;\n+\n pub fn main() {}"}, {"sha": "63a40e2374b15cbee042b0f1123a6e9e2c5d6771", "filename": "src/test/compile-fail/issue-17718-static-sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -14,6 +14,6 @@ struct Foo { marker: marker::NoSync }\n \n static FOO: uint = 3;\n static BAR: Foo = Foo { marker: marker::NoSync };\n-//~^ ERROR: shared static items must have a type which implements Sync\n+//~^ ERROR: the trait `core::kinds::Sync` is not implemented\n \n fn main() {}"}, {"sha": "a8a699d62d5eed33c6d8dccab6ba671b0caefe44", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -33,4 +33,5 @@ struct A {\n fn main() {\n     let a = A {v: box B{v: None} as Box<Foo+Send>};\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n+    //~^^ ERROR the trait `core::kinds::Send` is not implemented\n }"}, {"sha": "2646edd7684e6fe5c5a5ecdc72e3f4f36174318e", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -14,6 +14,8 @@ use std::cell::RefCell;\n // Regresion test for issue 7364\n static boxed: Box<RefCell<int>> = box RefCell::new(0);\n //~^ ERROR statics are not allowed to have custom pointers\n-//~^^ ERROR: shared static items must have a type which implements Sync\n+//~^^ ERROR: the trait `core::kinds::Sync` is not implemented for the type\n+//~^^^ ERROR: the trait `core::kinds::Sync` is not implemented for the type\n+//~^^^^ ERROR: the trait `core::kinds::Sync` is not implemented for the type\n \n fn main() { }"}, {"sha": "803da617abdc08f9c91aadc1b65a69ee0208ccb9", "filename": "src/test/compile-fail/kindck-destructor-owned.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -9,19 +9,6 @@\n // except according to those terms.\n \n \n-use std::rc::Rc;\n-\n-struct Foo {\n-    f: Rc<int>,\n-}\n-\n-impl Drop for Foo {\n-//~^ ERROR the trait `core::kinds::Send` is not implemented\n-//~^^ NOTE cannot implement a destructor on a structure or enumeration that does not satisfy Send\n-    fn drop(&mut self) {\n-    }\n-}\n-\n struct Bar<'a> {\n     f: &'a int,\n }"}, {"sha": "fdd8584a8bb06b19db9f2d2ae833116536c1e4e4", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -17,6 +17,8 @@ fn bar<F:FnOnce() + Send>(_: F) { }\n \n fn main() {\n     let x = Rc::new(3u);\n-    bar(move|| foo(x)); //~ ERROR `core::kinds::Send` is not implemented\n+    bar(move|| foo(x));\n+    //~^ ERROR `core::kinds::Send` is not implemented\n+    //~^^ ERROR `core::kinds::Send` is not implemented\n }\n "}, {"sha": "4e1641025d5aec0fe480d219e5b6136324c36618", "filename": "src/test/compile-fail/kindck-send-unsafe.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate core;\n+\n fn assert_send<T:Send>() { }\n \n-// unsafe ptrs are ok unless they point at unsendable things\n-fn test70() {\n-    assert_send::<*mut int>();\n-}\n fn test71<'a>() {\n-    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<*mut &'a int>();\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented for the type\n }\n \n fn main() {"}, {"sha": "4b058f6fdb343cef21cd68dc531f15edd9352259", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -14,5 +14,8 @@ fn f<T: Sync>(_: T) {}\n \n fn main() {\n     let x = RefCell::new(0i);\n-    f(x); //~ ERROR `core::kinds::Sync` is not implemented\n+    f(x);\n+    //~^ ERROR `core::kinds::Sync` is not implemented\n+    //~^^ ERROR `core::kinds::Sync` is not implemented\n+    //~^^^ ERROR `core::kinds::Sync` is not implemented\n }"}, {"sha": "48747c7ce1da7f994c2fb957f3f154575f8e06cb", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -37,6 +37,7 @@ fn main() {\n \n     task::spawn(move|| {\n         //~^ ERROR `core::kinds::Send` is not implemented\n+        //~^^ ERROR `core::kinds::Send` is not implemented\n         let y = x;\n         println!(\"{}\", y);\n     });"}, {"sha": "004921b1db0d2ab4b82045208be02aafef8b62a1", "filename": "src/test/compile-fail/no_send-rc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -16,4 +16,5 @@ fn main() {\n     let x = Rc::new(5i);\n     bar(x);\n     //~^ ERROR `core::kinds::Send` is not implemented\n+    //~^^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "ac3b456def526cbfe8f25d6dc40e3cfb39acbd30", "filename": "src/test/compile-fail/no_share-rc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -17,4 +17,5 @@ fn main() {\n     let x = Rc::new(RefCell::new(5i));\n     bar(x);\n     //~^ ERROR the trait `core::kinds::Sync` is not implemented\n+    //~^^ ERROR the trait `core::kinds::Sync` is not implemented\n }"}, {"sha": "e15cb25295aac7defa8ec6fa8766911fedf96830", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -12,8 +12,11 @@\n // in this file all test region bound and lifetime violations that are\n // detected during type check.\n \n+extern crate core;\n+use core::ptr::Unique;\n+\n fn assert_send<T:Send>() { }\n-trait Dummy { }\n+trait Dummy:Send { }\n \n // lifetime pointers with 'static lifetime are ok\n \n@@ -58,7 +61,7 @@ fn box_with_region_not_ok<'a>() {\n \n fn object_with_random_bound_not_ok<'a>() {\n     assert_send::<&'a (Dummy+'a)>();\n-    //~^ ERROR not implemented\n+    //~^ ERROR reference has a longer lifetime\n }\n \n fn object_with_send_bound_not_ok<'a>() {\n@@ -73,17 +76,12 @@ fn closure_with_lifetime_not_ok<'a>() {\n \n // unsafe pointers are ok unless they point at unsendable things\n \n-fn unsafe_ok1<'a>(_: &'a int) {\n-    assert_send::<*const int>();\n-    assert_send::<*mut int>();\n-}\n+struct UniqueUnsafePtr(Unique<*const int>);\n \n-fn unsafe_ok2<'a>(_: &'a int) {\n-    assert_send::<*const &'a int>(); //~ ERROR declared lifetime bound not satisfied\n-}\n+unsafe impl Send for UniqueUnsafePtr {}\n \n-fn unsafe_ok3<'a>(_: &'a int) {\n-    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n+fn unsafe_ok1<'a>(_: &'a int) {\n+    assert_send::<UniqueUnsafePtr>();\n }\n \n fn main() {"}, {"sha": "d96599404deb840f13faaee2b10ea0f75fa727bb", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -17,4 +17,5 @@ fn test_send<S: Send>() {}\n pub fn main() {\n     test_send::<rand::TaskRng>();\n     //~^ ERROR `core::kinds::Send` is not implemented\n+    //~^^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "a7911eb791eb2338d836be4d377ebc6e1f6776a2", "filename": "src/test/compile-fail/typeck-unsafe-always-share.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -30,12 +30,15 @@ fn test<T: Sync>(s: T){\n fn main() {\n     let us = UnsafeCell::new(MySync{u: UnsafeCell::new(0i)});\n     test(us);\n+    //~^ ERROR `core::kinds::Sync` is not implemented\n \n     let uns = UnsafeCell::new(NoSync{m: marker::NoSync});\n     test(uns);\n+    //~^ ERROR `core::kinds::Sync` is not implemented\n \n     let ms = MySync{u: uns};\n     test(ms);\n+    //~^ ERROR `core::kinds::Sync` is not implemented\n \n     let ns = NoSync{m: marker::NoSync};\n     test(ns);"}, {"sha": "48d5028f4357d2111f1324f5e57a23e6df7fb40a", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -16,5 +16,7 @@ fn f<T:Send>(_i: T) {\n \n fn main() {\n     let i = box Rc::new(100i);\n-    f(i); //~ ERROR `core::kinds::Send` is not implemented\n+    f(i);\n+    //~^ ERROR `core::kinds::Send` is not implemented\n+    //~^^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "cd5918e2f47ff5e5bb33527cf2171dbf4abf594b", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -28,6 +28,8 @@ fn foo(i:int, j: Rc<String>) -> foo {\n \n fn main() {\n   let cat = \"kitty\".to_string();\n-  let (tx, _) = channel(); //~ ERROR `core::kinds::Send` is not implemented\n+  let (tx, _) = channel();\n+  //~^ ERROR `core::kinds::Send` is not implemented\n+  //~^^ ERROR `core::kinds::Send` is not implemented\n   tx.send(foo(42, Rc::new(cat)));\n }"}, {"sha": "35783ea5899d55897a1a1e245b902f5439d9a430", "filename": "src/test/run-pass/const-block.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fconst-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fconst-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -11,11 +11,15 @@\n #![allow(dead_code)]\n #![allow(unused_unsafe)]\n \n+use std::kinds::Sync;\n+\n struct Foo {\n     a: uint,\n     b: *const ()\n }\n \n+unsafe impl Sync for Foo {}\n+\n fn foo<T>(a: T) -> T {\n     a\n }"}, {"sha": "50e460bd1798a79c5752c4bc62c6683e8c5d9e0a", "filename": "src/test/run-pass/const-cast-ptr-int.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -10,8 +10,14 @@\n \n use std::ptr;\n \n-static a: *const u8 = 0 as *const u8;\n+struct TestStruct {\n+    x: *const u8\n+}\n+\n+unsafe impl Sync for TestStruct {}\n+\n+static a: TestStruct = TestStruct{x: 0 as *const u8};\n \n pub fn main() {\n-    assert_eq!(a, ptr::null());\n+    assert_eq!(a.x, ptr::null());\n }"}, {"sha": "b7e9c0338dd6375fdd84d395e49ee1cce538d418", "filename": "src/test/run-pass/const-cast.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -10,14 +10,16 @@\n \n extern crate libc;\n \n-extern fn foo() {}\n+struct TestStruct {\n+    x: *const libc::c_void\n+}\n \n+unsafe impl Sync for TestStruct {}\n+\n+extern fn foo() {}\n const x: extern \"C\" fn() = foo;\n-static y: *const libc::c_void = x as *const libc::c_void;\n-const a: &'static int = &10;\n-static b: *const int = a as *const int;\n+static y: TestStruct = TestStruct { x: x as *const libc::c_void };\n \n pub fn main() {\n-    assert_eq!(x as *const libc::c_void, y);\n-    assert_eq!(a as *const int, b);\n+    assert_eq!(x as *const libc::c_void, y.x);\n }"}, {"sha": "0bf27cfbb2418381f714690c2552da0a5981fea2", "filename": "src/test/run-pass/deriving-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fderiving-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fderiving-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-bounds.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Sync,Send,Copy)]\n+#[deriving(Copy)]\n struct Test;\n \n pub fn main() {}"}, {"sha": "c6847ce55dec2ca7090c97bdb090a74ceb98caa6", "filename": "src/test/run-pass/issue-13837.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fissue-13837.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fissue-13837.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13837.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static TEST_VALUE : *const [int; 2] = 0x1234 as *const [int; 2];\n+struct TestStruct {\n+    x: *const [int; 2]\n+}\n+\n+unsafe impl Sync for TestStruct {}\n+\n+static TEST_VALUE : TestStruct = TestStruct{x: 0x1234 as *const [int; 2]};\n \n fn main() {}"}, {"sha": "0851f0e367bf85ce977ae5685d593e6d217a17da", "filename": "src/test/run-pass/issue-17718-static-unsafe-interior.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -11,38 +11,46 @@\n use std::kinds::marker;\n use std::cell::UnsafeCell;\n \n+struct MyUnsafePack<T>(UnsafeCell<T>);\n+\n+unsafe impl<T: Send> Sync for MyUnsafePack<T> {}\n+\n struct MyUnsafe<T> {\n-    value: UnsafeCell<T>\n+    value: MyUnsafePack<T>\n }\n \n impl<T> MyUnsafe<T> {\n     fn forbidden(&self) {}\n }\n \n+unsafe impl<T: Send> Sync for MyUnsafe<T> {}\n+\n enum UnsafeEnum<T> {\n     VariantSafe,\n     VariantUnsafe(UnsafeCell<T>)\n }\n \n+unsafe impl<T: Send> Sync for UnsafeEnum<T> {}\n+\n static STATIC1: UnsafeEnum<int> = UnsafeEnum::VariantSafe;\n \n-static STATIC2: UnsafeCell<int> = UnsafeCell { value: 1 };\n-const CONST: UnsafeCell<int> = UnsafeCell { value: 1 };\n+static STATIC2: MyUnsafePack<int> = MyUnsafePack(UnsafeCell { value: 1 });\n+const CONST: MyUnsafePack<int> = MyUnsafePack(UnsafeCell { value: 1 });\n static STATIC3: MyUnsafe<int> = MyUnsafe{value: CONST};\n \n-static STATIC4: &'static UnsafeCell<int> = &STATIC2;\n+static STATIC4: &'static MyUnsafePack<int> = &STATIC2;\n \n struct Wrap<T> {\n     value: T\n }\n \n-static UNSAFE: UnsafeCell<int> = UnsafeCell{value: 1};\n-static WRAPPED_UNSAFE: Wrap<&'static UnsafeCell<int>> = Wrap { value: &UNSAFE };\n+unsafe impl<T: Send> Sync for Wrap<T> {}\n+\n+static UNSAFE: MyUnsafePack<int> = MyUnsafePack(UnsafeCell{value: 2});\n+static WRAPPED_UNSAFE: Wrap<&'static MyUnsafePack<int>> = Wrap { value: &UNSAFE };\n \n fn main() {\n     let a = &STATIC1;\n \n     STATIC3.forbidden()\n }\n-\n-"}, {"sha": "d949cab97c2292764e7805ed88afe38cd439d9c6", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -23,6 +23,7 @@ pub mod pipes {\n     use std::mem::{replace, swap};\n     use std::mem;\n     use std::task;\n+    use std::kinds::Send;\n \n     pub struct Stuff<T> {\n         state: state,\n@@ -45,6 +46,8 @@ pub mod pipes {\n         payload: Option<T>\n     }\n \n+    unsafe impl<T:Send> Send for packet<T> {}\n+\n     pub fn packet<T:Send>() -> *const packet<T> {\n         unsafe {\n             let p: *const packet<T> = mem::transmute(box Stuff{\n@@ -230,8 +233,13 @@ pub mod pingpong {\n     use std::mem;\n \n     pub struct ping(::pipes::send_packet<pong>);\n+\n+    unsafe impl Send for ping {}\n+\n     pub struct pong(::pipes::send_packet<ping>);\n \n+    unsafe impl Send for pong {}\n+\n     pub fn liberate_ping(p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {\n             let _addr : *const ::pipes::send_packet<pong> = match &p {"}, {"sha": "a8ae3f40f0ec6e43da6c85d4c3cf3bbede538d5e", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c89c7a4a763c253a97ff04647f52aca6a5490/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=4a4c89c7a4a763c253a97ff04647f52aca6a5490", "patch": "@@ -11,7 +11,14 @@\n // This test checks that the `_` type placeholder works\n // correctly for enabling type inference.\n \n-static CONSTEXPR: *const int = &413 as *const _;\n+struct TestStruct {\n+    x: *const int\n+}\n+\n+unsafe impl Sync for TestStruct {}\n+\n+static CONSTEXPR: TestStruct = TestStruct{x: &413 as *const _};\n+\n \n pub fn main() {\n     let x: Vec<_> = range(0u, 5).collect();"}]}