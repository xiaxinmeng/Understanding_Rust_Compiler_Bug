{"sha": "d4618e0879257dc5e058589639f1eb2179d7f1f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NjE4ZTA4NzkyNTdkYzVlMDU4NTg5NjM5ZjFlYjIxNzlkN2YxZjg=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-25T16:14:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-25T16:14:48Z"}, "message": "Merge pull request #2871 from flip1995/gen_gen_nightly\n\nThe Great Generics Generalisation: Clippy edition", "tree": {"sha": "61c3ecdf6fdba88de2c0e61f0c85f8eddb65e147", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61c3ecdf6fdba88de2c0e61f0c85f8eddb65e147"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4618e0879257dc5e058589639f1eb2179d7f1f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbMRT4CRBK7hj4Ov3rIwAAdHIIAIVm5Cp7lH5kWHKOyGblgb62\nK6YpXMFcwA+rDWTezL8cjLn+uy3jZ9j9nGH3KGTpkSS/J0TjUSJtnI8Ud4m304QH\nJXuNhVji0x4moX6tFlT2Dg21QzXzP5IDrzqA8GwGcne5u8xRYppLZgJzz2kIQDGI\npRCaZ3aeYC/lJmm4uZS0x+jp2uoRYATFOWld4JodI7yZRiEYtHbkPKhZnLuWayhW\nxwaLN8c8OHe77wux48K6ISD/YAeptAw//b3+x3IAiUg/H5bR66fH/ZlAIjHB9Yju\nvcT9Z621fJtK59ozo5qp1OMB6jGv+Rb/UVKC2yfVmNiQM2NsEqFCoN+AdouTssQ=\n=Hwu5\n-----END PGP SIGNATURE-----\n", "payload": "tree 61c3ecdf6fdba88de2c0e61f0c85f8eddb65e147\nparent 5f5fa084ec89d692c251e28ca8923a75b29cb1af\nparent 203ad28021ddad978285f2533bdb678bed05f2e3\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1529943288 +0200\ncommitter GitHub <noreply@github.com> 1529943288 +0200\n\nMerge pull request #2871 from flip1995/gen_gen_nightly\n\nThe Great Generics Generalisation: Clippy edition"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4618e0879257dc5e058589639f1eb2179d7f1f8", "html_url": "https://github.com/rust-lang/rust/commit/d4618e0879257dc5e058589639f1eb2179d7f1f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4618e0879257dc5e058589639f1eb2179d7f1f8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f5fa084ec89d692c251e28ca8923a75b29cb1af", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f5fa084ec89d692c251e28ca8923a75b29cb1af", "html_url": "https://github.com/rust-lang/rust/commit/5f5fa084ec89d692c251e28ca8923a75b29cb1af"}, {"sha": "203ad28021ddad978285f2533bdb678bed05f2e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/203ad28021ddad978285f2533bdb678bed05f2e3", "html_url": "https://github.com/rust-lang/rust/commit/203ad28021ddad978285f2533bdb678bed05f2e3"}], "stats": {"total": 283, "additions": 179, "deletions": 104}, "files": [{"sha": "c861e4ee4e263fd7d8abc0e6bee897e89c33cdf7", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n }\n \n fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, _, _, eid) = item.node {\n+    if let ItemFn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         true"}, {"sha": "d773289263ef0df78bd8831215f01f4dfb365218", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprAgain(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n+            ExprContinue(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n             ExprCall(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n                 match typ.sty {"}, {"sha": "554c983d7c514748cbc4982f33effe3b3c8c37cd", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -92,17 +92,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         };\n \n         let unsafety = match kind {\n-            hir::intravisit::FnKind::ItemFn(_, _, unsafety, _, _, _, _) => unsafety,\n-            hir::intravisit::FnKind::Method(_, sig, _, _) => sig.unsafety,\n+            hir::intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _, _) => unsafety,\n+            hir::intravisit::FnKind::Method(_, sig, _, _) => sig.header.unsafety,\n             hir::intravisit::FnKind::Closure(_) => return,\n         };\n \n         // don't warn for implementations, it's not their fault\n         if !is_impl {\n             // don't lint extern functions decls, it's not their fault either\n             match kind {\n-                hir::intravisit::FnKind::Method(_, &hir::MethodSig { abi: Abi::Rust, .. }, _, _) |\n-                hir::intravisit::FnKind::ItemFn(_, _, _, _, Abi::Rust, _, _) => self.check_arg_number(cx, decl, span),\n+                hir::intravisit::FnKind::Method(_, &hir::MethodSig { header: hir::FnHeader { abi: Abi::Rust, .. }, .. }, _, _) |\n+                hir::intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _, _) => self.check_arg_number(cx, decl, span),\n                 _ => {},\n             }\n         }\n@@ -113,13 +113,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, ref eid) = item.node {\n             // don't lint extern functions decls, it's not their fault\n-            if sig.abi == Abi::Rust {\n+            if sig.header.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n             if let hir::TraitMethod::Provided(eid) = *eid {\n                 let body = cx.tcx.hir.body(eid);\n-                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, body, item.id);\n+                self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.id);\n             }\n         }\n     }"}, {"sha": "1c063464fcc27a00cc7da016151ca94b583b9cd4", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -59,7 +59,7 @@ impl LintPass for LifetimePass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, _, ref generics, id) = item.node {\n+        if let ItemFn(ref decl, _, ref generics, id) = item.node {\n             check_fn_inner(cx, decl, Some(id), generics, item.span);\n         }\n     }\n@@ -101,23 +101,31 @@ fn check_fn_inner<'a, 'tcx>(\n     }\n \n     let mut bounds_lts = Vec::new();\n-    for typ in generics.ty_params() {\n+    let types = generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Type { .. } => Some(param),\n+        GenericParamKind::Lifetime { .. } => None,\n+    });\n+    for typ in types {\n         for bound in &typ.bounds {\n             let mut visitor = RefVisitor::new(cx);\n-            walk_ty_param_bound(&mut visitor, bound);\n+            walk_param_bound(&mut visitor, bound);\n             if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n                 return;\n             }\n-            if let TraitTyParamBound(ref trait_ref, _) = *bound {\n+            if let GenericBound::Trait(ref trait_ref, _) = *bound {\n                 let params = &trait_ref\n                     .trait_ref\n                     .path\n                     .segments\n                     .last()\n                     .expect(\"a path must have at least one segment\")\n-                    .parameters;\n+                    .args;\n                 if let Some(ref params) = *params {\n-                    for bound in &params.lifetimes {\n+                    let lifetimes = params.args.iter().filter_map(|arg| match arg {\n+                        GenericArg::Lifetime(lt) => Some(lt),\n+                        GenericArg::Type(_) => None,\n+                    });\n+                    for bound in lifetimes {\n                         if bound.name.name() != \"'static\" && !bound.is_elided() {\n                             return;\n                         }\n@@ -230,9 +238,9 @@ fn could_use_elision<'a, 'tcx: 'a>(\n fn allowed_lts_from(named_generics: &[GenericParam]) -> HashSet<RefLt> {\n     let mut allowed_lts = HashSet::new();\n     for par in named_generics.iter() {\n-        if let GenericParam::Lifetime(ref lt) = *par {\n-            if lt.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(lt.lifetime.name.name()));\n+        if let GenericParamKind::Lifetime { .. } = par.kind {\n+            if par.bounds.is_empty() {\n+                allowed_lts.insert(RefLt::Named(par.name.name()));\n             }\n         }\n     }\n@@ -295,8 +303,12 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     }\n \n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n-        if let Some(ref last_path_segment) = last_path_segment(qpath).parameters {\n-            if !last_path_segment.parenthesized && last_path_segment.lifetimes.is_empty() {\n+        if let Some(ref last_path_segment) = last_path_segment(qpath).args {\n+            if !last_path_segment.parenthesized\n+                && !last_path_segment.args.iter().any(|arg| match arg {\n+                    GenericArg::Lifetime(_) => true,\n+                    GenericArg::Type(_) => false,\n+                }) {\n                 let hir_id = self.cx.tcx.hir.node_to_hir_id(ty.id);\n                 match self.cx.tables.qpath_def(qpath, hir_id) {\n                     Def::TyAlias(def_id) | Def::Struct(def_id) => {\n@@ -335,7 +347,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             TyImplTraitExistential(exist_ty_id, _, _) => {\n                 if let ItemExistential(ref exist_ty) = self.cx.tcx.hir.expect_item(exist_ty_id.id).node {\n                     for bound in &exist_ty.bounds {\n-                        if let RegionTyParamBound(_) = *bound {\n+                        if let GenericBound::Outlives(_) = *bound {\n                             self.record(&None);\n                         }\n                     }\n@@ -377,7 +389,7 @@ fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &\n                 let allowed_lts = allowed_lts_from(&pred.bound_generic_params);\n                 // now walk the bounds\n                 for bound in pred.bounds.iter() {\n-                    walk_ty_param_bound(&mut visitor, bound);\n+                    walk_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n                 match visitor.into_vec() {\n@@ -418,7 +430,7 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n         // don't want to spuriously remove them\n         // `'b` in `'a: 'b` is useless unless used elsewhere in\n         // a non-lifetime bound\n-        if param.is_type_param() {\n+        if let GenericParamKind::Type { .. } = param.kind {\n             walk_generic_param(self, param)\n         }\n     }\n@@ -428,9 +440,11 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n }\n \n fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n-    let hs = generics\n-        .lifetimes()\n-        .map(|lt| (lt.lifetime.name.name(), lt.lifetime.span))\n+    let hs = generics.params.iter()\n+        .filter_map(|par| match par.kind {\n+            GenericParamKind::Lifetime { .. } => Some((par.name.name(), par.span)),\n+            _ => None,\n+        })\n         .collect();\n     let mut checker = LifetimeChecker { map: hs };\n "}, {"sha": "8808de9025d2df9ec437d83be7cfa188f17498b7", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -640,7 +640,7 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n             }\n         },\n         ExprBlock(ref b, _) => never_loop_block(b, main_loop_id),\n-        ExprAgain(d) => {\n+        ExprContinue(d) => {\n             let id = d.target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {"}, {"sha": "97c2522d2ced803c2b91d28e76752fd0facdba52", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -104,7 +104,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n             let arg_segment = [\n                 PathSegment {\n                     name: id,\n-                    parameters: None,\n+                    args: None,\n                     infer_types: true,\n                 },\n             ];"}, {"sha": "b5e1780fd0ca062cb917845907859cefdf139920", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n use std::iter;\n use syntax::ast;\n use syntax::codemap::{Span, BytePos};\n-use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self, \n+use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self,\n             is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n             span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n@@ -336,7 +336,7 @@ declare_clippy_lint! {\n ///\n /// **Known problems:** If the function has side-effects, not calling it will\n /// change the semantic of the program, but you shouldn't rely on that anyway.\n-/// \n+///\n /// **Example:**\n /// ```rust\n /// foo.expect(&format(\"Err {}: {}\", err_code, err_msg))\n@@ -1020,7 +1020,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n                 }\n             }\n         };\n-        \n+\n         snippet(cx, a.span, \"..\").into_owned()\n     }\n \n@@ -1077,7 +1077,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n         }\n \n         let sugg: Cow<_> = snippet(cx, arg.span, \"..\");\n-        \n+\n         span_lint_and_sugg(\n             cx,\n             EXPECT_FUN_CALL,\n@@ -2091,26 +2091,35 @@ impl SelfKind {\n \n fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n     single_segment_ty(ty).map_or(false, |seg| {\n-        generics.ty_params().any(|param| {\n-            param.name == seg.name && param.bounds.iter().any(|bound| {\n-                if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n-                    let path = &ptr.trait_ref.path;\n-                    match_path(path, name) && path.segments.last().map_or(false, |s| {\n-                        if let Some(ref params) = s.parameters {\n-                            if params.parenthesized {\n-                                false\n+        generics.params.iter().any(|param| match param.kind {\n+            hir::GenericParamKind::Type { .. } => {\n+                param.name.name() == seg.name && param.bounds.iter().any(|bound| {\n+                    if let hir::GenericBound::Trait(ref ptr, ..) = *bound {\n+                        let path = &ptr.trait_ref.path;\n+                        match_path(path, name) && path.segments.last().map_or(false, |s| {\n+                            if let Some(ref params) = s.args {\n+                                if params.parenthesized {\n+                                    false\n+                                } else {\n+                                    // FIXME(flip1995): messy, improve if there is a better option\n+                                    // in the compiler\n+                                    let types: Vec<_> = params.args.iter().filter_map(|arg| match arg {\n+                                        hir::GenericArg::Type(ty) => Some(ty),\n+                                        _ => None,\n+                                    }).collect();\n+                                    types.len() == 1\n+                                        && (is_self_ty(&types[0]) || is_ty(&*types[0], self_ty))\n+                                }\n                             } else {\n-                                params.types.len() == 1\n-                                    && (is_self_ty(&params.types[0]) || is_ty(&*params.types[0], self_ty))\n+                                false\n                             }\n-                        } else {\n-                            false\n-                        }\n-                    })\n-                } else {\n-                    false\n-                }\n-            })\n+                        })\n+                    } else {\n+                        false\n+                    }\n+                })\n+            },\n+            _ => false,\n         })\n     })\n }"}, {"sha": "414e507a55b4651892428cc8349b58038e6f24fa", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -558,7 +558,7 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n         .ctxt()\n         .outer()\n         .expn_info()\n-        .map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n+        .map_or(false, |info| matches!(info.format, ExpnFormat::MacroAttribute(_)))\n }\n \n /// Test whether `def` is a variable defined outside a macro."}, {"sha": "94247e64b1051f39e07aab8b3a8143895934f877", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -189,13 +189,13 @@ impl LintPass for MiscEarly {\n impl EarlyLintPass for MiscEarly {\n     fn check_generics(&mut self, cx: &EarlyContext, gen: &Generics) {\n         for param in &gen.params {\n-            if let GenericParam::Type(ref ty) = *param {\n-                let name = ty.ident.name.as_str();\n+            if let GenericParamKind::Type { .. } = param.kind {\n+                let name = param.ident.name.as_str();\n                 if constants::BUILTIN_TYPES.contains(&&*name) {\n                     span_lint(\n                         cx,\n                         BUILTIN_TYPE_SHADOW,\n-                        ty.ident.span,\n+                        param.ident.span,\n                         &format!(\"This generic shadows the built-in type `{}`\", name),\n                     );\n                 }\n@@ -296,7 +296,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n         match expr.node {\n             ExprKind::Call(ref paren, _) => if let ExprKind::Paren(ref closure) = paren.node {\n-                if let ExprKind::Closure(_, _, ref decl, ref block, _) = closure.node {\n+                if let ExprKind::Closure(_, _, _, ref decl, ref block, _) = closure.node {\n                     span_lint_and_then(\n                         cx,\n                         REDUNDANT_CLOSURE_CALL,\n@@ -327,7 +327,7 @@ impl EarlyLintPass for MiscEarly {\n             if_chain! {\n                 if let StmtKind::Local(ref local) = w[0].node;\n                 if let Option::Some(ref t) = local.init;\n-                if let ExprKind::Closure(_, _, _, _, _) = t.node;\n+                if let ExprKind::Closure(..) = t.node;\n                 if let PatKind::Ident(_, ident, _) = local.pat.node;\n                 if let StmtKind::Semi(ref second) = w[1].node;\n                 if let ExprKind::Assign(_, ref call) = second.node;"}, {"sha": "03a45bc18472f7fd12662b555cb9aa7102aec557", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -72,8 +72,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., abi, _, attrs) => {\n-                if abi != Abi::Rust {\n+            FnKind::ItemFn(.., header, _, attrs) => {\n+                if header.abi != Abi::Rust {\n                     return;\n                 }\n                 for a in attrs {\n@@ -218,8 +218,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             if let TyPath(QPath::Resolved(_, ref path)) = input.node;\n                             if let Some(elem_ty) = path.segments.iter()\n                                 .find(|seg| seg.name == \"Vec\")\n-                                .and_then(|ps| ps.parameters.as_ref())\n-                                .map(|params| &params.types[0]);\n+                                .and_then(|ps| ps.args.as_ref())\n+                                .map(|params| params.args.iter().find_map(|arg| match arg {\n+                                    GenericArg::Type(ty) => Some(ty),\n+                                    GenericArg::Lifetime(_) => None,\n+                                }).unwrap());\n                             then {\n                                 let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));\n                                 db.span_suggestion(input.span,"}, {"sha": "adc91bacdef7ef2d1623453466012dc2ed9a962e", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -99,11 +99,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         let name = impl_item.name;\n                         let id = impl_item.id;\n-                        if sig.constness == hir::Constness::Const {\n+                        if sig.header.constness == hir::Constness::Const {\n                             // can't be implemented by default\n                             return;\n                         }\n-                        if impl_item.generics.params.iter().any(|gen| gen.is_type_param()) {\n+                        if impl_item.generics.params.iter().any(|gen| match gen.kind {\n+                            hir::GenericParamKind::Type { .. } => true,\n+                            _ => false\n+                        }) {\n                             // when the result of `new()` depends on a type parameter we should not require\n                             // an\n                             // impl of `Default`"}, {"sha": "b49e3f87ec99342b8d09219b7992bb37ed8dd9b2", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n \n impl EarlyLintPass for NonExpressiveNames {\n     fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n-        if let ItemKind::Fn(ref decl, _, _, _, _, ref blk) = item.node {\n+        if let ItemKind::Fn(ref decl, _, _, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, decl, blk);\n         }\n     }"}, {"sha": "68cecc8de678fb02f5ff42d98cac1c9f0737dd7c", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -103,7 +103,7 @@ impl LintPass for PointerPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, _, _, body_id) = item.node {\n+        if let ItemFn(ref decl, _, _, body_id) = item.node {\n             check_fn(cx, decl, item.id, Some(body_id));\n         }\n     }\n@@ -160,10 +160,15 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                 let mut ty_snippet = None;\n                 if_chain! {\n                     if let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n-                    if let Some(&PathSegment{parameters: Some(ref parameters), ..}) = path.segments.last();\n-                    if parameters.types.len() == 1;\n+                    if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n                     then {\n-                        ty_snippet = snippet_opt(cx, parameters.types[0].span);\n+                        let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty),\n+                            _ => None,\n+                        }).collect();\n+                        if types.len() == 1 {\n+                            ty_snippet = snippet_opt(cx, types[0].span);\n+                        }\n                     }\n                 };\n                 if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n@@ -218,9 +223,12 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                     if let TyPath(ref path) = ty.node;\n                     if let QPath::Resolved(None, ref pp) = *path;\n                     if let [ref bx] = *pp.segments;\n-                    if let Some(ref params) = bx.parameters;\n+                    if let Some(ref params) = bx.args;\n                     if !params.parenthesized;\n-                    if let [ref inner] = *params.types;\n+                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                        GenericArg::Type(ty) => Some(ty),\n+                        GenericArg::Lifetime(_) => None,\n+                    });\n                     then {\n                         let replacement = snippet_opt(cx, inner.span);\n                         if let Some(r) = replacement {"}, {"sha": "c2e981979a18d34aa4f6dd9439741d03912fada9", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -455,9 +455,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n fn get_type_snippet(cx: &LateContext, path: &QPath, to_ref_ty: Ty) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n-        if let Some(ref params) = seg.parameters;\n+        if let Some(ref params) = seg.args;\n         if !params.parenthesized;\n-        if let Some(to_ty) = params.types.get(1);\n+        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            GenericArg::Lifetime(_) => None,\n+        }).nth(1);\n         if let TyRptr(_, ref to_ty) = to_ty.node;\n         then {\n             return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();"}, {"sha": "8d0ddbec98829537fcbbc6e0a46441ffb33603ad", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -84,8 +84,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., abi, _, attrs) => {\n-                if abi != Abi::Rust {\n+            FnKind::ItemFn(.., header, _, attrs) => {\n+                if header.abi != Abi::Rust {\n                     return;\n                 }\n                 for a in attrs {"}, {"sha": "887e9f12712b423a19404fdb1928e75faebe6372", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -180,9 +180,12 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n-        if let Some(ref params) = last.parameters;\n+        if let Some(ref params) = last.args;\n         if !params.parenthesized;\n-        if let Some(ty) = params.types.get(0);\n+        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            GenericArg::Lifetime(_) => None,\n+        });\n         if let TyPath(ref qpath) = ty.node;\n         if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(ty.id)));\n         if match_def_path(cx.tcx, did, path);\n@@ -244,24 +247,35 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                 QPath::Resolved(Some(ref ty), ref p) => {\n                     check_ty(cx, ty, is_local);\n                     for ty in p.segments.iter().flat_map(|seg| {\n-                        seg.parameters\n+                        seg.args\n                             .as_ref()\n-                            .map_or_else(|| [].iter(), |params| params.types.iter())\n+                            .map_or_else(|| [].iter(), |params| params.args.iter())\n+                            .filter_map(|arg| match arg {\n+                                GenericArg::Type(ty) => Some(ty),\n+                                GenericArg::Lifetime(_) => None,\n+                            })\n                     }) {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n                 QPath::Resolved(None, ref p) => for ty in p.segments.iter().flat_map(|seg| {\n-                    seg.parameters\n+                    seg.args\n                         .as_ref()\n-                        .map_or_else(|| [].iter(), |params| params.types.iter())\n+                        .map_or_else(|| [].iter(), |params| params.args.iter())\n+                        .filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty),\n+                            GenericArg::Lifetime(_) => None,\n+                        })\n                 }) {\n                     check_ty(cx, ty, is_local);\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n                     check_ty(cx, ty, is_local);\n-                    if let Some(ref params) = seg.parameters {\n-                        for ty in params.types.iter() {\n+                    if let Some(ref params) = seg.args {\n+                        for ty in params.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty),\n+                            GenericArg::Lifetime(_) => None,\n+                        }) {\n                             check_ty(cx, ty, is_local);\n                         }\n                     }\n@@ -288,9 +302,12 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n                 if Some(def_id) == cx.tcx.lang_items().owned_box();\n                 if let QPath::Resolved(None, ref path) = *qpath;\n                 if let [ref bx] = *path.segments;\n-                if let Some(ref params) = bx.parameters;\n+                if let Some(ref params) = bx.args;\n                 if !params.parenthesized;\n-                if let [ref inner] = *params.types;\n+                if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    GenericArg::Lifetime(_) => None,\n+                });\n                 then {\n                     if is_any_trait(inner) {\n                         // Ignore `Box<Any>` types, see #1884 for details.\n@@ -1208,7 +1225,10 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n             TyTraitObject(ref param_bounds, _) => {\n                 let has_lifetime_parameters = param_bounds\n                     .iter()\n-                    .any(|bound| bound.bound_generic_params.iter().any(|gen| gen.is_lifetime_param()));\n+                    .any(|bound| bound.bound_generic_params.iter().any(|gen| match gen.kind {\n+                        GenericParamKind::Lifetime { .. } => true,\n+                        _ => false,\n+                    }));\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>\n                     (50 * self.nest, 1)\n@@ -1859,7 +1879,11 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n         if let TyPath(QPath::Resolved(None, ref path)) = hir_ty.node {\n-            let params = &path.segments.last().as_ref()?.parameters.as_ref()?.types;\n+            let params: Vec<_> = path.segments.last().as_ref()?.args.as_ref()?\n+                .args.iter().filter_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    GenericArg::Lifetime(_) => None,\n+                }).collect();\n             let params_len = params.len();\n \n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);"}, {"sha": "ca3000326750cc23a0781ac36f4f6d18b58577b3", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBreak(destination, _) | hir::ExprAgain(destination) => if let Some(label) = destination.label {\n+            hir::ExprBreak(destination, _) | hir::ExprContinue(destination) => if let Some(label) = destination.label {\n                 self.labels.remove(&label.name.as_str());\n             },\n             hir::ExprLoop(_, Some(label), _) | hir::ExprWhile(_, _, Some(label)) => {"}, {"sha": "170db6ceabb6b804e072842c84b17a0fded517bb", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -58,9 +58,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n             if let ItemImpl(.., ref item_type, ref refs) = item.node;\n             if let Ty_::TyPath(QPath::Resolved(_, ref item_path)) = item_type.node;\n             then {\n-                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).parameters;\n+                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = if let Some(ref params) = *parameters {\n-                    !params.parenthesized && params.lifetimes.len() == 0\n+                    !params.parenthesized && !params.args.iter().any(|arg| match arg {\n+                        GenericArg::Lifetime(_) => true,\n+                        GenericArg::Type(_) => false,\n+                    })\n                 } else {\n                     true\n                 };"}, {"sha": "df6a06bc4784926475b670850dffab178da99bd7", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -432,7 +432,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 }\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprAgain(ref _destination) => {\n+            Expr_::ExprContinue(ref _destination) => {\n                 let destination_pat = self.next(\"destination\");\n                 println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing"}, {"sha": "ee6b004dc6cbd4b158cb105e8c8d40e946718708", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprAgain(li), &ExprAgain(ri)) => {\n+            (&ExprContinue(li), &ExprContinue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.name.as_str() == r.name.as_str())\n             },\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n@@ -152,6 +152,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.ident.name == right.ident.name && self.eq_expr(&left.expr, &right.expr)\n     }\n \n+    fn eq_generic_arg(&mut self, left: &GenericArg, right: &GenericArg) -> bool {\n+        match (left, right) {\n+            (GenericArg::Lifetime(l_lt), GenericArg::Lifetime(r_lt)) => self.eq_lifetime(l_lt, r_lt),\n+            (GenericArg::Type(l_ty), GenericArg::Type(r_ty)) => self.eq_ty(l_ty, r_ty),\n+            _ => false,\n+        }\n+    }\n+\n     fn eq_lifetime(&mut self, left: &Lifetime, right: &Lifetime) -> bool {\n         left.name == right.name\n     }\n@@ -201,10 +209,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n-    fn eq_path_parameters(&mut self, left: &PathParameters, right: &PathParameters) -> bool {\n+    fn eq_path_parameters(&mut self, left: &GenericArgs, right: &GenericArgs) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n-            over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r))\n-                && over(&left.types, &right.types, |l, r| self.eq_ty(l, r))\n+            over(&left.args, &right.args, |l, r| self.eq_generic_arg(l, r)) // FIXME(flip1995): may not work\n                 && over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n         } else if left.parenthesized && right.parenthesized {\n             over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r))\n@@ -224,7 +231,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         if left.name.as_str() != right.name.as_str() {\n             return false;\n         }\n-        match (&left.parameters, &right.parameters) {\n+        match (&left.args, &right.args) {\n             (&None, &None) => true,\n             (&Some(ref l), &Some(ref r)) => self.eq_path_parameters(l, r),\n             _ => false,\n@@ -345,8 +352,8 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprAgain(i) => {\n-                let c: fn(_) -> _ = ExprAgain;\n+            ExprContinue(i) => {\n+                let c: fn(_) -> _ = ExprContinue;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.name);"}, {"sha": "9d92147048c3237509f5a12eadb2dc2dcc310b56", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -300,7 +300,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprAgain(_) => println!(\"{}Again\", ind),\n+        hir::ExprContinue(_) => println!(\"{}Again\", ind),\n         hir::ExprRet(ref e) => {\n             println!(\"{}Ret\", ind);\n             if let Some(ref e) = *e {"}, {"sha": "ae8ffcf2fce61fd3589e82f9e3d8333f46348634", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -57,7 +57,7 @@ pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro(span: Span) -> bool {\n     span.ctxt().outer().expn_info().map_or(false, |info| {\n-        match info.callee.format {\n+        match info.format {\n             // don't treat range expressions desugared to structs as \"in_macro\"\n             ExpnFormat::CompilerDesugaring(kind) => kind != CompilerDesugaringKind::DotFill,\n             _ => true,\n@@ -68,7 +68,7 @@ pub fn in_macro(span: Span) -> bool {\n /// Returns true if `expn_info` was expanded by range expressions.\n pub fn is_range_expression(span: Span) -> bool {\n     span.ctxt().outer().expn_info().map_or(false, |info| {\n-        match info.callee.format {\n+        match info.format {\n             ExpnFormat::CompilerDesugaring(CompilerDesugaringKind::DotFill) => true,\n             _ => false,\n         }\n@@ -84,12 +84,12 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     /// this after other checks have already happened.\n     fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, info: &ExpnInfo) -> bool {\n         // no ExpnInfo = no macro\n-        if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n+        if let ExpnFormat::MacroAttribute(..) = info.format {\n             // these are all plugins\n             return true;\n         }\n         // no span for the callee = external macro\n-        info.callee.span.map_or(true, |span| {\n+        info.def_site.map_or(true, |span| {\n             // no snippet = external macro or compiler-builtin expansion\n             cx.sess()\n                 .codemap()\n@@ -524,7 +524,7 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n         match node {\n             Node::NodeBlock(block) => Some(block),\n             Node::NodeItem(&Item {\n-                node: ItemFn(_, _, _, _, _, eid),\n+                node: ItemFn(_, _, _, eid),\n                 ..\n             }) | Node::NodeImplItem(&ImplItem {\n                 node: ImplItemKind::Method(_, eid),\n@@ -768,7 +768,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n         let span_name_span = span.ctxt()\n             .outer()\n             .expn_info()\n-            .map(|ei| (ei.callee.name(), ei.call_site));\n+            .map(|ei| (ei.format.name(), ei.call_site));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -791,7 +791,7 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     let span_name_span = span.ctxt()\n         .outer()\n         .expn_info()\n-        .map(|ei| (ei.callee.name(), ei.call_site));\n+        .map(|ei| (ei.format.name(), ei.call_site));\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),"}, {"sha": "eb2197a5891e7afcad58c9eb041117d661596c31", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4618e0879257dc5e058589639f1eb2179d7f1f8/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=d4618e0879257dc5e058589639f1eb2179d7f1f8", "patch": "@@ -52,7 +52,7 @@ impl<'a> Sugg<'a> {\n                 hir::ExprIf(..) |\n                 hir::ExprUnary(..) |\n                 hir::ExprMatch(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprAgain(..) |\n+                hir::ExprContinue(..) |\n                 hir::ExprYield(..) |\n                 hir::ExprArray(..) |\n                 hir::ExprBlock(..) |\n@@ -100,6 +100,7 @@ impl<'a> Sugg<'a> {\n             ast::ExprKind::ObsoleteInPlace(..) |\n             ast::ExprKind::Unary(..) |\n             ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            ast::ExprKind::Async(..) |\n             ast::ExprKind::Block(..) |\n             ast::ExprKind::Break(..) |\n             ast::ExprKind::Call(..) |"}]}