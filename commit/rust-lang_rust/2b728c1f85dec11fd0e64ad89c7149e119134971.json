{"sha": "2b728c1f85dec11fd0e64ad89c7149e119134971", "node_id": "C_kwDOAAsO6NoAKDJiNzI4YzFmODVkZWMxMWZkMGU2NGFkODljNzE0OWUxMTkxMzQ5NzE", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-21T17:06:31Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-21T18:04:44Z"}, "message": "rustdoc: factor `document_type_layout` into its own module", "tree": {"sha": "bfdaf90a93f68a9411d260e8c2bd61be84ee58c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfdaf90a93f68a9411d260e8c2bd61be84ee58c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b728c1f85dec11fd0e64ad89c7149e119134971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b728c1f85dec11fd0e64ad89c7149e119134971", "html_url": "https://github.com/rust-lang/rust/commit/2b728c1f85dec11fd0e64ad89c7149e119134971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b728c1f85dec11fd0e64ad89c7149e119134971/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99e1cdb46f1b26ba8b458dded654f7f6a59973bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e1cdb46f1b26ba8b458dded654f7f6a59973bc", "html_url": "https://github.com/rust-lang/rust/commit/99e1cdb46f1b26ba8b458dded654f7f6a59973bc"}], "stats": {"total": 167, "additions": 90, "deletions": 77}, "files": [{"sha": "a699d0b38a70c58a2dd5c8b128400f02715dcf44", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b728c1f85dec11fd0e64ad89c7149e119134971/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b728c1f85dec11fd0e64ad89c7149e119134971/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2b728c1f85dec11fd0e64ad89c7149e119134971", "patch": "@@ -32,6 +32,7 @@ mod context;\n mod print_item;\n mod sidebar;\n mod span_map;\n+mod type_layout;\n mod write_shared;\n \n pub(crate) use self::context::*;"}, {"sha": "b71109f15609e27b46f2c4d9fcbc1d91cb7077cd", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2b728c1f85dec11fd0e64ad89c7149e119134971/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b728c1f85dec11fd0e64ad89c7149e119134971/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=2b728c1f85dec11fd0e64ad89c7149e119134971", "patch": "@@ -6,16 +6,14 @@ use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::stability;\n-use rustc_middle::span_bug;\n-use rustc_middle::ty::layout::LayoutError;\n-use rustc_middle::ty::{self, Adt, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_target::abi::{Primitive, TagEncoding, Variants};\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n \n+use super::type_layout::document_type_layout;\n use super::{\n     collect_paths_for_type, document, ensure_trailing_slash, get_filtered_impls_for_reference,\n     item_ty_to_section, notable_traits_button, notable_traits_json, render_all_impls,\n@@ -1932,79 +1930,6 @@ fn document_non_exhaustive<'a>(item: &'a clean::Item) -> impl fmt::Display + 'a\n     })\n }\n \n-fn document_type_layout<'a, 'cx: 'a>(\n-    cx: &'a Context<'cx>,\n-    ty_def_id: DefId,\n-) -> impl fmt::Display + 'a + Captures<'cx> {\n-    #[derive(Template)]\n-    #[template(path = \"type_layout.html\")]\n-    struct TypeLayout<'cx> {\n-        variants: Vec<(Symbol, TypeLayoutSize)>,\n-        type_layout_size: Result<TypeLayoutSize, LayoutError<'cx>>,\n-    }\n-\n-    #[derive(Template)]\n-    #[template(path = \"type_layout_size.html\")]\n-    struct TypeLayoutSize {\n-        is_unsized: bool,\n-        is_uninhabited: bool,\n-        size: u64,\n-    }\n-\n-    display_fn(move |f| {\n-        if !cx.shared.show_type_layout {\n-            return Ok(());\n-        }\n-\n-        let tcx = cx.tcx();\n-        let param_env = tcx.param_env(ty_def_id);\n-        let ty = tcx.type_of(ty_def_id).subst_identity();\n-        let type_layout = tcx.layout_of(param_env.and(ty));\n-\n-        let variants =\n-            if let Ok(type_layout) = type_layout &&\n-                let Variants::Multiple { variants, tag, tag_encoding, .. } =\n-                    type_layout.layout.variants() &&\n-                !variants.is_empty()\n-            {\n-                let tag_size =\n-                    if let TagEncoding::Niche { .. } = tag_encoding {\n-                        0\n-                    } else if let Primitive::Int(i, _) = tag.primitive() {\n-                        i.size().bytes()\n-                    } else {\n-                        span_bug!(cx.tcx().def_span(ty_def_id), \"tag is neither niche nor int\")\n-                    };\n-                let variants = variants\n-                    .iter_enumerated()\n-                    .map(|(variant_idx, variant_layout)| {\n-                        let Adt(adt, _) = type_layout.ty.kind() else {\n-                            span_bug!(cx.tcx().def_span(ty_def_id), \"not an adt\")\n-                        };\n-                        let name = adt.variant(variant_idx).name;\n-                        let is_unsized = variant_layout.abi.is_unsized();\n-                        let is_uninhabited = variant_layout.abi.is_uninhabited();\n-                        let size = variant_layout.size.bytes() - tag_size;\n-                        let type_layout_size = TypeLayoutSize { is_unsized, is_uninhabited, size };\n-                        (name, type_layout_size)\n-                    }).collect();\n-                variants\n-            } else {\n-                Vec::new()\n-            }\n-        ;\n-\n-        let type_layout_size = tcx.layout_of(param_env.and(ty)).map(|layout| {\n-            let is_unsized = layout.abi.is_unsized();\n-            let is_uninhabited = layout.abi.is_uninhabited();\n-            let size = layout.size.bytes();\n-            TypeLayoutSize { is_unsized, is_uninhabited, size }\n-        });\n-\n-        Ok(TypeLayout { variants, type_layout_size }.render_into(f).unwrap())\n-    })\n-}\n-\n fn pluralize(count: usize) -> &'static str {\n     if count > 1 { \"s\" } else { \"\" }\n }"}, {"sha": "0befc9625db7899fbb609354c4b9f76c4f45ef03", "filename": "src/librustdoc/html/render/type_layout.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2b728c1f85dec11fd0e64ad89c7149e119134971/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b728c1f85dec11fd0e64ad89c7149e119134971/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs?ref=2b728c1f85dec11fd0e64ad89c7149e119134971", "patch": "@@ -0,0 +1,87 @@\n+use askama::Template;\n+\n+use rustc_data_structures::captures::Captures;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::span_bug;\n+use rustc_middle::ty::layout::LayoutError;\n+use rustc_middle::ty::Adt;\n+use rustc_span::symbol::Symbol;\n+use rustc_target::abi::{Primitive, TagEncoding, Variants};\n+\n+use std::fmt;\n+\n+use crate::html::format::display_fn;\n+use crate::html::render::Context;\n+\n+#[derive(Template)]\n+#[template(path = \"type_layout.html\")]\n+struct TypeLayout<'cx> {\n+    variants: Vec<(Symbol, TypeLayoutSize)>,\n+    type_layout_size: Result<TypeLayoutSize, LayoutError<'cx>>,\n+}\n+\n+#[derive(Template)]\n+#[template(path = \"type_layout_size.html\")]\n+struct TypeLayoutSize {\n+    is_unsized: bool,\n+    is_uninhabited: bool,\n+    size: u64,\n+}\n+\n+pub(crate) fn document_type_layout<'a, 'cx: 'a>(\n+    cx: &'a Context<'cx>,\n+    ty_def_id: DefId,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |f| {\n+        if !cx.shared.show_type_layout {\n+            return Ok(());\n+        }\n+\n+        let tcx = cx.tcx();\n+        let param_env = tcx.param_env(ty_def_id);\n+        let ty = tcx.type_of(ty_def_id).subst_identity();\n+        let type_layout = tcx.layout_of(param_env.and(ty));\n+\n+        let variants =\n+            if let Ok(type_layout) = type_layout &&\n+                let Variants::Multiple { variants, tag, tag_encoding, .. } =\n+                    type_layout.layout.variants() &&\n+                !variants.is_empty()\n+            {\n+                let tag_size =\n+                    if let TagEncoding::Niche { .. } = tag_encoding {\n+                        0\n+                    } else if let Primitive::Int(i, _) = tag.primitive() {\n+                        i.size().bytes()\n+                    } else {\n+                        span_bug!(cx.tcx().def_span(ty_def_id), \"tag is neither niche nor int\")\n+                    };\n+                let variants = variants\n+                    .iter_enumerated()\n+                    .map(|(variant_idx, variant_layout)| {\n+                        let Adt(adt, _) = type_layout.ty.kind() else {\n+                            span_bug!(cx.tcx().def_span(ty_def_id), \"not an adt\")\n+                        };\n+                        let name = adt.variant(variant_idx).name;\n+                        let is_unsized = variant_layout.abi.is_unsized();\n+                        let is_uninhabited = variant_layout.abi.is_uninhabited();\n+                        let size = variant_layout.size.bytes() - tag_size;\n+                        let type_layout_size = TypeLayoutSize { is_unsized, is_uninhabited, size };\n+                        (name, type_layout_size)\n+                    }).collect();\n+                variants\n+            } else {\n+                Vec::new()\n+            }\n+        ;\n+\n+        let type_layout_size = tcx.layout_of(param_env.and(ty)).map(|layout| {\n+            let is_unsized = layout.abi.is_unsized();\n+            let is_uninhabited = layout.abi.is_uninhabited();\n+            let size = layout.size.bytes();\n+            TypeLayoutSize { is_unsized, is_uninhabited, size }\n+        });\n+\n+        Ok(TypeLayout { variants, type_layout_size }.render_into(f).unwrap())\n+    })\n+}"}]}