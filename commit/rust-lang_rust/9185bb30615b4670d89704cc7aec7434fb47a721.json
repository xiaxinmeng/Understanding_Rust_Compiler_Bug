{"sha": "9185bb30615b4670d89704cc7aec7434fb47a721", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxODViYjMwNjE1YjQ2NzBkODk3MDRjYzdhZWM3NDM0ZmI0N2E3MjE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-06-27T21:04:45Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-06-27T21:04:45Z"}, "message": "Generate a direct assignment in MIR for `let x = y;`", "tree": {"sha": "dcdf544c6b4b7729a4f9ff60d6a248242ddaf351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcdf544c6b4b7729a4f9ff60d6a248242ddaf351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9185bb30615b4670d89704cc7aec7434fb47a721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9185bb30615b4670d89704cc7aec7434fb47a721", "html_url": "https://github.com/rust-lang/rust/commit/9185bb30615b4670d89704cc7aec7434fb47a721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9185bb30615b4670d89704cc7aec7434fb47a721/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4aff10bb1b9b202bb6464f99d198d3e6f49e6991", "url": "https://api.github.com/repos/rust-lang/rust/commits/4aff10bb1b9b202bb6464f99d198d3e6f49e6991", "html_url": "https://github.com/rust-lang/rust/commit/4aff10bb1b9b202bb6464f99d198d3e6f49e6991"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "d905b38331607da2cc4e6f923001e94c75592c11", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9185bb30615b4670d89704cc7aec7434fb47a721/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9185bb30615b4670d89704cc7aec7434fb47a721/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=9185bb30615b4670d89704cc7aec7434fb47a721", "patch": "@@ -11,7 +11,6 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::expr::category::Category;\n use hair::*;\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -57,23 +56,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             });\n         }\n \n-        // Careful here not to cause an infinite cycle. If we always\n-        // called `into`, then for places like `x.f`, it would\n-        // eventually fallback to us, and we'd loop. There's a reason\n-        // for this: `as_temp` is the point where we bridge the \"by\n-        // reference\" semantics of `as_place` with the \"by value\"\n-        // semantics of `into`, `as_operand`, `as_rvalue`, and (of\n-        // course) `as_temp`.\n-        match Category::of(&expr.kind).unwrap() {\n-            Category::Place => {\n-                let place = unpack!(block = this.as_place(block, expr));\n-                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n-                this.cfg.push_assign(block, source_info, &Place::Local(temp), rvalue);\n-            }\n-            _ => {\n-                unpack!(block = this.into(&Place::Local(temp), block, expr));\n-            }\n-        }\n+        unpack!(block = this.into(&Place::Local(temp), block, expr));\n \n         // In constants, temp_lifetime is None. We should not need to drop\n         // anything because no values with a destructor can be created in"}, {"sha": "59a7f49af80746ff955b62d14e37b544384e37f8", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9185bb30615b4670d89704cc7aec7434fb47a721/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9185bb30615b4670d89704cc7aec7434fb47a721/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=9185bb30615b4670d89704cc7aec7434fb47a721", "patch": "@@ -288,6 +288,37 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.unit()\n             }\n \n+            // Avoid creating a temporary\n+            ExprKind::VarRef { .. } |\n+            ExprKind::SelfRef |\n+            ExprKind::StaticRef { .. } => {\n+                debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n+                let place = unpack!(block = this.as_place(block, expr));\n+                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n+                block.unit()\n+            }\n+            ExprKind::Index { .. } |\n+            ExprKind::Deref { .. } |\n+            ExprKind::Field { .. } => {\n+                debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n+                // Create a \"fake\" temporary variable so that we check that the\n+                // value is Sized. Usually, this is caught in type checking, but\n+                // in the case of box expr there is no such check.\n+                if let Place::Projection(..) = destination {\n+                    this.local_decls.push(LocalDecl::new_temp(expr.ty, expr.span));\n+                }\n+\n+                debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n+                let place = unpack!(block = this.as_place(block, expr));\n+                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n+                block.unit()\n+            }\n+\n             // these are the cases that are more naturally handled by some other mode\n             ExprKind::Unary { .. } |\n             ExprKind::Binary { .. } |\n@@ -300,18 +331,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Unsize { .. } |\n             ExprKind::Repeat { .. } |\n             ExprKind::Borrow { .. } |\n-            ExprKind::VarRef { .. } |\n-            ExprKind::SelfRef |\n-            ExprKind::StaticRef { .. } |\n             ExprKind::Array { .. } |\n             ExprKind::Tuple { .. } |\n             ExprKind::Adt { .. } |\n             ExprKind::Closure { .. } |\n-            ExprKind::Index { .. } |\n-            ExprKind::Deref { .. } |\n             ExprKind::Literal { .. } |\n-            ExprKind::Yield { .. } |\n-            ExprKind::Field { .. } => {\n+            ExprKind::Yield { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     Category::Rvalue(RvalueFunc::Into) => false,\n                     _ => true,"}, {"sha": "a63cf41f0663ed25d858cbe7ef9e81aa3541803b", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9185bb30615b4670d89704cc7aec7434fb47a721/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9185bb30615b4670d89704cc7aec7434fb47a721/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=9185bb30615b4670d89704cc7aec7434fb47a721", "patch": "@@ -65,7 +65,7 @@\n //! which can fallback to `into`. So if one of the `ExprKind` variants is not, in fact,\n //! implemented in the category where it is supposed to be, there will be a problem.\n //!\n-//! Of those fallbacks, the most interesting one is `as_temp`, because\n+//! Of those fallbacks, the most interesting one is `into`, because\n //! it discriminates based on the category of the expression. This is\n //! basically the point where the \"by value\" operations are bridged\n //! over to the \"by reference\" mode (`as_place`)."}]}