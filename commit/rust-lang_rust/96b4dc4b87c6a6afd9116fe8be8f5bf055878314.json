{"sha": "96b4dc4b87c6a6afd9116fe8be8f5bf055878314", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YjRkYzRiODdjNmE2YWZkOTExNmZlOGJlOGY1YmYwNTU4NzgzMTQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-07T22:28:54Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-08T02:25:03Z"}, "message": "Refactor away the fields id and is_public of ImportResolution and rename ImportResolution to NameResolution", "tree": {"sha": "64db109911efe332b245686b30b10f9e7c782a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64db109911efe332b245686b30b10f9e7c782a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96b4dc4b87c6a6afd9116fe8be8f5bf055878314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96b4dc4b87c6a6afd9116fe8be8f5bf055878314", "html_url": "https://github.com/rust-lang/rust/commit/96b4dc4b87c6a6afd9116fe8be8f5bf055878314", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96b4dc4b87c6a6afd9116fe8be8f5bf055878314/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4428b1cfdf724bc4b43173195192da57a5901e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4428b1cfdf724bc4b43173195192da57a5901e4f", "html_url": "https://github.com/rust-lang/rust/commit/4428b1cfdf724bc4b43173195192da57a5901e4f"}], "stats": {"total": 114, "additions": 49, "deletions": 65}, "files": [{"sha": "0c7563f9864676dd9178e49228680da905a790e3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96b4dc4b87c6a6afd9116fe8be8f5bf055878314/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96b4dc4b87c6a6afd9116fe8be8f5bf055878314/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=96b4dc4b87c6a6afd9116fe8be8f5bf055878314", "patch": "@@ -16,7 +16,7 @@\n use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use resolve_imports::ImportResolution;\n+use resolve_imports::NameResolution;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind};\n@@ -703,13 +703,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let mut import_resolutions = module_.import_resolutions.borrow_mut();\n                 for &ns in [TypeNS, ValueNS].iter() {\n                     let mut resolution = import_resolutions.entry((target, ns)).or_insert(\n-                        ImportResolution::new(id, is_public)\n+                        NameResolution::default()\n                     );\n \n                     resolution.outstanding_references += 1;\n-                    // the source of this name is different now\n-                    resolution.id = id;\n-                    resolution.is_public = is_public;\n                 }\n             }\n             GlobImport => {"}, {"sha": "5a78315d79cf11203933910f2d85548d192ce108", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96b4dc4b87c6a6afd9116fe8be8f5bf055878314/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96b4dc4b87c6a6afd9116fe8be8f5bf055878314/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=96b4dc4b87c6a6afd9116fe8be8f5bf055878314", "patch": "@@ -92,7 +92,7 @@ use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n \n-use resolve_imports::{ImportDirective, ImportResolution};\n+use resolve_imports::{ImportDirective, NameResolution};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -346,8 +346,9 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                              .import_resolutions\n                                              .borrow()\n                                              .get(&(name, ValueNS)) {\n-                let item = resolver.ast_map.expect_item(directive.id);\n-                err.span_note(item.span, \"constant imported here\");\n+                if let Some(binding) = directive.binding {\n+                    err.span_note(binding.span.unwrap(), \"constant imported here\");\n+                }\n             }\n             err\n         }\n@@ -814,7 +815,7 @@ pub struct ModuleS<'a> {\n     anonymous_children: RefCell<NodeMap<Module<'a>>>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<(Name, Namespace), ImportResolution<'a>>>,\n+    import_resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n@@ -1219,8 +1220,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     #[inline]\n-    fn record_import_use(&mut self, name: Name, ns: Namespace, resolution: &ImportResolution<'a>) {\n-        let import_id = resolution.id;\n+    fn record_import_use(&mut self, name: Name, ns: Namespace, binding: &NameBinding<'a>) {\n+        let import_id = match binding.kind {\n+            NameBindingKind::Import { id, .. } => id,\n+            _ => return,\n+        };\n+\n         self.used_imports.insert((import_id, ns));\n \n         if !self.make_glob_map {\n@@ -1592,20 +1597,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Check the list of resolved imports.\n         match module_.import_resolutions.borrow().get(&(name, namespace)) {\n-            Some(import_resolution) if allow_private_imports || import_resolution.is_public => {\n-                if import_resolution.is_public && import_resolution.outstanding_references != 0 {\n-                    debug!(\"(resolving name in module) import unresolved; bailing out\");\n-                    return Indeterminate;\n-                }\n+            Some(import_resolution) => {\n                 if let Some(binding) = import_resolution.binding {\n+                    if !allow_private_imports && binding.is_public() { return Failed(None) }\n+                    if binding.is_public() && import_resolution.outstanding_references != 0 {\n+                        debug!(\"(resolving name in module) import unresolved; bailing out\");\n+                        return Indeterminate;\n+                    }\n+\n                     debug!(\"(resolving name in module) resolved to import\");\n                     if record_used {\n-                        self.record_import_use(name, namespace, &import_resolution);\n+                        self.record_import_use(name, namespace, binding);\n                     }\n                     return Success(binding);\n                 }\n             }\n-            Some(..) | None => {} // Continue.\n+            None => {}\n         }\n \n         // We're out of luck.\n@@ -3482,7 +3489,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n                     let trait_name = self.get_trait_name(did);\n-                    self.record_import_use(trait_name, TypeNS, &import);\n+                    self.record_import_use(trait_name, TypeNS, binding);\n                 }\n             }\n "}, {"sha": "b67de2d170dbb0b2de0f6b86598cdd50857ea752", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/96b4dc4b87c6a6afd9116fe8be8f5bf055878314/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96b4dc4b87c6a6afd9116fe8be8f5bf055878314/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=96b4dc4b87c6a6afd9116fe8be8f5bf055878314", "patch": "@@ -101,39 +101,30 @@ impl ImportDirective {\n }\n \n #[derive(Debug)]\n-/// An ImportResolution records what we know about an imported name in a given namespace.\n+/// An NameResolution records what we know about an imported name in a given namespace.\n /// More specifically, it records the number of unresolved `use` directives that import the name,\n /// the `use` directive importing the name in the namespace, and the `NameBinding` to which the\n /// name in the namespace resolves (if applicable).\n /// Different `use` directives may import the same name in different namespaces.\n-pub struct ImportResolution<'a> {\n+pub struct NameResolution<'a> {\n     // When outstanding_references reaches zero, outside modules can count on the targets being\n     // correct. Before then, all bets are off; future `use` directives could override the name.\n     // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n     // is if the name is imported by exactly two `use` directives, one of which resolves to a\n     // value and the other of which resolves to a type.\n     pub outstanding_references: usize,\n \n-    /// Whether this resolution came from a `use` or a `pub use`.\n-    pub is_public: bool,\n-\n     /// Resolution of the name in the namespace\n     pub binding: Option<&'a NameBinding<'a>>,\n-\n-    /// The source node of the `use` directive\n-    pub id: NodeId,\n }\n \n-impl<'a> ImportResolution<'a> {\n-    pub fn new(id: NodeId, is_public: bool) -> Self {\n-        ImportResolution {\n-            outstanding_references: 0,\n-            id: id,\n-            binding: None,\n-            is_public: is_public,\n-        }\n+impl<'a> Default for NameResolution<'a> {\n+    fn default() -> Self {\n+        NameResolution { outstanding_references: 0, binding: None }\n     }\n+}\n \n+impl<'a> NameResolution<'a> {\n     pub fn shadowable(&self) -> Shadowable {\n         match self.binding {\n             Some(binding) if binding.defined_with(DefModifiers::PRELUDE) =>\n@@ -216,8 +207,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 debug!(\"(resolving import error) adding import resolution for `{}`\",\n                        target);\n \n-                ImportResolution::new(e.import_directive.id,\n-                                      e.import_directive.is_public)\n+                NameResolution::default()\n             });\n \n             if resolution.binding.is_none() {\n@@ -402,13 +392,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             // The name is an import which has been fully resolved, so we just follow it.\n             Some(resolution) if resolution.outstanding_references == 0 => {\n-                // Import resolutions must be declared with \"pub\" in order to be exported.\n-                if !resolution.is_public {\n-                    return Failed(None);\n-                }\n-\n                 if let Some(binding) = resolution.binding {\n-                    self.resolver.record_import_use(name, ns, &resolution);\n+                    // Import resolutions must be declared with \"pub\" in order to be exported.\n+                    if !binding.is_public() {\n+                        return Failed(None);\n+                    }\n+\n+                    self.resolver.record_import_use(name, ns, binding);\n                     Success(binding)\n                 } else {\n                     Failed(None)\n@@ -549,10 +539,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n                         import_resolution.binding =\n                             Some(self.resolver.new_name_binding(directive.import(name_binding)));\n-                        import_resolution.id = directive.id;\n-                        import_resolution.is_public = directive.is_public;\n \n-                        self.add_export(module_, target, &import_resolution);\n+                        self.add_export(module_, target, import_resolution.binding.unwrap());\n                     }\n                     Failed(_) => {\n                         // Continue.\n@@ -644,7 +632,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                            lp: LastPrivate)\n                            -> ResolveResult<()> {\n         let id = import_directive.id;\n-        let is_public = import_directive.is_public;\n \n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n@@ -679,19 +666,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n             let mut dest_import_resolution =\n                 import_resolutions.entry((name, ns))\n-                                  .or_insert_with(|| ImportResolution::new(id, is_public));\n+                                  .or_insert_with(|| NameResolution::default());\n \n             match target_import_resolution.binding {\n-                Some(binding) if target_import_resolution.is_public => {\n+                Some(binding) if binding.is_public() => {\n                     self.check_for_conflicting_import(&dest_import_resolution,\n                                                       import_directive.span,\n                                                       name,\n                                                       ns);\n-                    dest_import_resolution.id = id;\n-                    dest_import_resolution.is_public = is_public;\n                     dest_import_resolution.binding =\n                         Some(self.resolver.new_name_binding(import_directive.import(binding)));\n-                    self.add_export(module_, name, &dest_import_resolution);\n+                    self.add_export(module_, name, dest_import_resolution.binding.unwrap());\n                 }\n                 _ => {}\n             }\n@@ -728,12 +713,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                import_directive: &ImportDirective,\n                                (name, ns): (Name, Namespace),\n                                name_binding: &'b NameBinding<'b>) {\n-        let id = import_directive.id;\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let dest_import_resolution = import_resolutions.entry((name, ns)).or_insert_with(|| {\n-            ImportResolution::new(id, is_public)\n+            NameResolution::default()\n         });\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` to `{}`\",\n@@ -767,9 +751,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             } else {\n                 dest_import_resolution.binding =\n                     Some(self.resolver.new_name_binding(import_directive.import(name_binding)));\n-                dest_import_resolution.id = id;\n-                dest_import_resolution.is_public = is_public;\n-                self.add_export(module_, name, &dest_import_resolution);\n+                self.add_export(module_, name, dest_import_resolution.binding.unwrap());\n             }\n         }\n \n@@ -779,13 +761,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                            (name, ns));\n     }\n \n-    fn add_export(&mut self, module: Module<'b>, name: Name, resolution: &ImportResolution<'b>) {\n-        if !resolution.is_public { return }\n+    fn add_export(&mut self, module: Module<'b>, name: Name, binding: &NameBinding<'b>) {\n+        if !binding.is_public() { return }\n         let node_id = match module.def_id() {\n             Some(def_id) => self.resolver.ast_map.as_local_node_id(def_id).unwrap(),\n             None => return,\n         };\n-        let export = match resolution.binding.as_ref().unwrap().def() {\n+        let export = match binding.def() {\n             Some(def) => Export { name: name, def_id: def.def_id() },\n             None => return,\n         };\n@@ -794,7 +776,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicting_import(&mut self,\n-                                    import_resolution: &ImportResolution,\n+                                    import_resolution: &NameResolution,\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n@@ -815,8 +797,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     }\n                     ValueNS => \"value\",\n                 };\n-                let use_id = import_resolution.id;\n-                let item = self.resolver.ast_map.expect_item(use_id);\n                 let mut err = struct_span_err!(self.resolver.session,\n                                                import_span,\n                                                E0252,\n@@ -825,7 +805,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                ns_word,\n                                                name);\n                 span_note!(&mut err,\n-                           item.span,\n+                           binding.span.unwrap(),\n                            \"previous import of `{}` here\",\n                            name);\n                 err.emit();\n@@ -848,7 +828,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n                                                      module: Module<'b>,\n-                                                     import: &ImportResolution<'b>,\n+                                                     import: &NameResolution<'b>,\n                                                      import_span: Span,\n                                                      (name, ns): (Name, Namespace)) {\n         // Check for item conflicts."}]}