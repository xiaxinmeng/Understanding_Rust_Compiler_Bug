{"sha": "1271ea4f958d335ee67452faff925ab9b8715648", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNzFlYTRmOTU4ZDMzNWVlNjc0NTJmYWZmOTI1YWI5Yjg3MTU2NDg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-22T21:01:51Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-05T13:41:40Z"}, "message": "refactor a bit", "tree": {"sha": "99b55de91738fe9786913e046933ba403c4af879", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99b55de91738fe9786913e046933ba403c4af879"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1271ea4f958d335ee67452faff925ab9b8715648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1271ea4f958d335ee67452faff925ab9b8715648", "html_url": "https://github.com/rust-lang/rust/commit/1271ea4f958d335ee67452faff925ab9b8715648", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1271ea4f958d335ee67452faff925ab9b8715648/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38747dd3a7e3ffd0eb3cec501184638ac644fef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/38747dd3a7e3ffd0eb3cec501184638ac644fef6", "html_url": "https://github.com/rust-lang/rust/commit/38747dd3a7e3ffd0eb3cec501184638ac644fef6"}], "stats": {"total": 186, "additions": 116, "deletions": 70}, "files": [{"sha": "e7c750f4bb49d60531c0d296adc6c7e2c1b397b5", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1271ea4f958d335ee67452faff925ab9b8715648/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271ea4f958d335ee67452faff925ab9b8715648/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=1271ea4f958d335ee67452faff925ab9b8715648", "patch": "@@ -20,16 +20,17 @@ use ty::subst::Subst;\n use infer::{InferCtxt, InferOk};\n \n #[derive(Copy, Clone, Debug)]\n-enum InferIsLocal {\n-    BrokenYes,\n-    Yes,\n-    No\n+/// Whether we do the orphan check relative to this crate or\n+/// to some remote crate.\n+enum InCrate {\n+    Local,\n+    Remote\n }\n \n #[derive(Debug, Copy, Clone)]\n pub enum Conflict {\n     Upstream,\n-    Downstream\n+    Downstream { used_to_be_broken: bool }\n }\n \n pub struct OverlapResult<'tcx> {\n@@ -136,21 +137,23 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n }\n \n pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                             trait_ref: ty::TraitRef<'tcx>,\n-                                             broken: bool)\n+                                             trait_ref: ty::TraitRef<'tcx>)\n                                              -> Option<Conflict>\n {\n-    debug!(\"trait_ref_is_knowable(trait_ref={:?}, broken={:?})\", trait_ref, broken);\n-    let mode = if broken {\n-        InferIsLocal::BrokenYes\n-    } else {\n-        InferIsLocal::Yes\n-    };\n-    if orphan_check_trait_ref(tcx, trait_ref, mode).is_ok() {\n+    debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n+    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref.\n-        debug!(\"trait_ref_is_knowable: downstream crate might implement\");\n-        return Some(Conflict::Downstream);\n+\n+        // A trait can be implementable for a trait ref by both the current\n+        // crate and crates downstream of it. Older versions of rustc\n+        // were not aware of this, causing incoherence (issue #43355).\n+        let used_to_be_broken =\n+            orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok();\n+        if used_to_be_broken {\n+            debug!(\"trait_ref_is_knowable({:?}) - USED TO BE BROKEN\", trait_ref);\n+        }\n+        return Some(Conflict::Downstream { used_to_be_broken });\n     }\n \n     if trait_ref_is_local_or_fundamental(tcx, trait_ref) {\n@@ -161,6 +164,7 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         // which we already know about.\n         return None;\n     }\n+\n     // This is a remote non-fundamental trait, so if another crate\n     // can be the \"final owner\" of a substitution of this trait-ref,\n     // they are allowed to implement it future-compatibly.\n@@ -169,7 +173,7 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // and if we are an intermediate owner, then we don't care\n     // about future-compatibility, which means that we're OK if\n     // we are an owner.\n-    if orphan_check_trait_ref(tcx, trait_ref, InferIsLocal::No).is_ok() {\n+    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok() {\n         debug!(\"trait_ref_is_knowable: orphan check passed\");\n         return None;\n     } else {\n@@ -213,31 +217,31 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal::No)\n+    orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n }\n \n fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n                                 trait_ref: ty::TraitRef<'tcx>,\n-                                infer_is_local: InferIsLocal)\n+                                in_crate: InCrate)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check_trait_ref(trait_ref={:?}, infer_is_local={:?})\",\n-           trait_ref, infer_is_local);\n+    debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\",\n+           trait_ref, in_crate);\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     // Find the first input type that either references a type parameter OR\n     // some local type.\n     for input_ty in trait_ref.input_types() {\n-        if ty_is_local(tcx, input_ty, infer_is_local) {\n+        if ty_is_local(tcx, input_ty, in_crate) {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n-            let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, in_crate);\n             for uncovered_ty in uncovered_tys {\n                 if let Some(param) = uncovered_ty.walk()\n-                    .find(|t| is_possibly_remote_type(t, infer_is_local))\n+                    .find(|t| is_possibly_remote_type(t, in_crate))\n                 {\n                     debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n                     return Err(OrphanCheckErr::UncoveredTy(param));\n@@ -251,7 +255,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n         // Otherwise, enforce invariant that there are no type\n         // parameters reachable.\n         if let Some(param) = input_ty.walk()\n-            .find(|t| is_possibly_remote_type(t, infer_is_local))\n+            .find(|t| is_possibly_remote_type(t, in_crate))\n         {\n             debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n             return Err(OrphanCheckErr::UncoveredTy(param));\n@@ -263,29 +267,29 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n     return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n-fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, infer_is_local: InferIsLocal)\n+fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, in_crate: InCrate)\n                        -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(ty, infer_is_local) {\n+    if ty_is_local_constructor(ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n         ty.walk_shallow()\n-          .flat_map(|t| uncovered_tys(tcx, t, infer_is_local))\n+          .flat_map(|t| uncovered_tys(tcx, t, in_crate))\n           .collect()\n     } else {\n         vec![ty]\n     }\n }\n \n-fn is_possibly_remote_type(ty: Ty, _infer_is_local: InferIsLocal) -> bool {\n+fn is_possibly_remote_type(ty: Ty, _in_crate: InCrate) -> bool {\n     match ty.sty {\n         ty::TyProjection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }\n }\n \n-fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n-    ty_is_local_constructor(ty, infer_is_local) ||\n-        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n+fn ty_is_local(tcx: TyCtxt, ty: Ty, in_crate: InCrate) -> bool {\n+    ty_is_local_constructor(ty, in_crate) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n@@ -299,15 +303,16 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     }\n }\n \n-fn def_id_is_local(def_id: DefId, infer_is_local: InferIsLocal) -> bool {\n-    match infer_is_local {\n-        InferIsLocal::Yes => false,\n-        InferIsLocal::No |\n-        InferIsLocal::BrokenYes => def_id.is_local()\n+fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n+    match in_crate {\n+        // The type is local to *this* crate - it will not be\n+        // local in any other crate.\n+        InCrate::Remote => false,\n+        InCrate::Local => def_id.is_local()\n     }\n }\n \n-fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal) -> bool {\n+fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n@@ -330,18 +335,19 @@ fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal) -> bool {\n             false\n         }\n \n-        ty::TyInfer(..) => match infer_is_local {\n-            InferIsLocal::No => false,\n-            InferIsLocal::Yes |\n-            InferIsLocal::BrokenYes => true\n+        ty::TyInfer(..) => match in_crate {\n+            InCrate::Local => false,\n+            // The inference variable might be unified with a local\n+            // type in that remote crate.\n+            InCrate::Remote => true,\n         },\n \n-        ty::TyAdt(def, _) => def_id_is_local(def.did, infer_is_local),\n-        ty::TyForeign(did) => def_id_is_local(did, infer_is_local),\n+        ty::TyAdt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::TyForeign(did) => def_id_is_local(did, in_crate),\n \n         ty::TyDynamic(ref tt, ..) => {\n             tt.principal().map_or(false, |p| {\n-                def_id_is_local(p.def_id(), infer_is_local)\n+                def_id_is_local(p.def_id(), in_crate)\n             })\n         }\n "}, {"sha": "d65a5f1c3aacbda636fc58995c6b805da0500bbe", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1271ea4f958d335ee67452faff925ab9b8715648/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271ea4f958d335ee67452faff925ab9b8715648/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=1271ea4f958d335ee67452faff925ab9b8715648", "patch": "@@ -60,6 +60,12 @@ mod structural_impls;\n pub mod trans;\n mod util;\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum IntercrateMode {\n+    Issue43355,\n+    Fixed\n+}\n+\n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n /// which the vtable must be found.  The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of"}, {"sha": "9625894b8725a1f627ef1eb7c33f360d0c65fc62", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1271ea4f958d335ee67452faff925ab9b8715648/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271ea4f958d335ee67452faff925ab9b8715648/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1271ea4f958d335ee67452faff925ab9b8715648", "patch": "@@ -13,7 +13,7 @@\n use self::SelectionCandidate::*;\n use self::EvaluationResult::*;\n \n-use super::coherence;\n+use super::coherence::{self, Conflict};\n use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n@@ -1077,28 +1077,33 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(None);\n         }\n \n-        if !self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            // Heuristics: show the diagnostics when there are no candidates in crate.\n-            let candidate_set = self.assemble_candidates(stack)?;\n-            if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n-                let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                let self_ty = trait_ref.self_ty();\n-                let trait_desc = trait_ref.to_string();\n-                let self_desc = if self_ty.has_concrete_skeleton() {\n-                    Some(self_ty.to_string())\n-                } else {\n-                    None\n-                };\n-                let cause = if !coherence::trait_ref_is_local_or_fundamental(self.tcx(),\n-                                                                             trait_ref) {\n-                    IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                } else {\n-                    IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                };\n-                self.intercrate_ambiguity_causes.push(cause);\n+        match self.is_knowable(stack) {\n+            Some(Conflict::Downstream { used_to_be_broken: true }) if false => {\n+                // ignore this for future-compat.\n+            }\n+            None => {}\n+            Some(conflict) => {\n+                debug!(\"coherence stage: not knowable\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                let candidate_set = self.assemble_candidates(stack)?;\n+                if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n+                    let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                    let self_ty = trait_ref.self_ty();\n+                    let trait_desc = trait_ref.to_string();\n+                    let self_desc = if self_ty.has_concrete_skeleton() {\n+                        Some(self_ty.to_string())\n+                    } else {\n+                        None\n+                    };\n+                    let cause = if let Conflict::Upstream = conflict {\n+                        IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                    } else {\n+                        IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                    };\n+                    self.intercrate_ambiguity_causes.push(cause);\n+                }\n+                return Ok(None);\n             }\n-            return Ok(None);\n         }\n \n         let candidate_set = self.assemble_candidates(stack)?;\n@@ -1205,12 +1210,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn is_knowable<'o>(&mut self,\n                        stack: &TraitObligationStack<'o, 'tcx>)\n-                       -> bool\n+                       -> Option<Conflict>\n     {\n         debug!(\"is_knowable(intercrate={})\", self.intercrate);\n \n         if !self.intercrate {\n-            return true;\n+            return None;\n         }\n \n         let obligation = &stack.obligation;\n@@ -1221,7 +1226,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // bound regions\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n-        coherence::trait_ref_is_knowable(self.tcx(), trait_ref, false).is_none()\n+        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n     }\n \n     /// Returns true if the global caches can be used."}, {"sha": "b379507c1dbd87820292e49aa7136203fc7f75fd", "filename": "src/test/compile-fail/issue-43355.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1271ea4f958d335ee67452faff925ab9b8715648/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271ea4f958d335ee67452faff925ab9b8715648/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs?ref=1271ea4f958d335ee67452faff925ab9b8715648", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+\n+pub trait Trait2<X> {}\n+\n+pub struct A;\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+\n+impl<X> Trait1<Box<X>> for A {\n+//~^ ERROR conflicting implementations of trait\n+//~| downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n+    type Output = i32;\n+}\n+\n+fn main() {}"}]}