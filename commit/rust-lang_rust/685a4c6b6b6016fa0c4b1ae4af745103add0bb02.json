{"sha": "685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NWE0YzZiNmI2MDE2ZmEwYzRiMWFlNGFmNzQ1MTAzYWRkMGJiMDI=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-02-23T22:55:36Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-03-14T23:28:57Z"}, "message": "Use the correct FakeReadCause", "tree": {"sha": "14eb066c36a1a3bcc247e498d99b163042de7e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14eb066c36a1a3bcc247e498d99b163042de7e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "html_url": "https://github.com/rust-lang/rust/commit/685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6cf070eb4c228c146ca9971cddeb034084f88de", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6cf070eb4c228c146ca9971cddeb034084f88de", "html_url": "https://github.com/rust-lang/rust/commit/b6cf070eb4c228c146ca9971cddeb034084f88de"}], "stats": {"total": 1009, "additions": 391, "deletions": 618}, "files": [{"sha": "425e62d6f61a983b044b9c9ed41f67e0b6c20ef9", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -47,6 +47,7 @@ use rustc_hir::{\n };\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n@@ -430,8 +431,7 @@ pub struct TypeckResults<'tcx> {\n     /// see `MinCaptureInformationMap` for more details.\n     pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n \n-    /// [FIXME] RFC2229 Change to use HashSet instead of Vec\n-    pub closure_fake_reads: FxHashMap<DefId, Vec<HirPlace<'tcx>>>,\n+    pub closure_fake_reads: FxHashMap<DefId, Vec<(HirPlace<'tcx>, FakeReadCause)>>,\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator)."}, {"sha": "808c6e3ff644b76b358f4ec6d3b03e675fcbbd1d", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -94,14 +94,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         )\n                     );\n                 }\n-                // ROX:\n-                //\n-                // Where the handling of destructure patterns start\n-                //\n-                // let (a, b, c, _ ) = something\n-                //\n-                // (a, b, c, _) is the pattern\n-                // something is the initializer\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer, lint_level } => {\n                     let ignores_expr_result = matches!(*pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n@@ -133,8 +125,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                             ArmHasGuard(false),\n                                             Some((None, initializer_span)),\n                                         );\n-                                        // This is where we get into pattern handling of the let\n-                                        // statement\n                                         this.expr_into_pattern(block, pattern.clone(), init)\n                                     })\n                                 }"}, {"sha": "6519d5fae1c7f732bb872a9e060049e2008a8321", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -84,20 +84,25 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n     mir_projections: &[PlaceElem<'tcx>],\n ) -> Vec<HirProjectionKind> {\n     let mut hir_projections = Vec::new();\n+    let mut variant = None;\n \n     for mir_projection in mir_projections {\n         let hir_projection = match mir_projection {\n             ProjectionElem::Deref => HirProjectionKind::Deref,\n             ProjectionElem::Field(field, _) => {\n                 // We will never encouter this for multivariant enums,\n                 // read the comment for `Downcast`.\n-                HirProjectionKind::Field(field.index() as u32, VariantIdx::new(0))\n+                let variant = variant.unwrap_or(VariantIdx::new(0));\n+                HirProjectionKind::Field(field.index() as u32, variant)\n             }\n-            ProjectionElem::Downcast(..) => {\n-                // This projections exist only for enums that have\n-                // multiple variants. Since such enums that are captured\n-                // completely, we can stop here.\n-                break;\n+            ProjectionElem::Downcast(.., idx) => {\n+                // This projections exist for enums that have\n+                // single and multiple variants.\n+                // For single variants, enums are not captured completely.\n+                // We keep track of VariantIdx so we can use this information\n+                // if the next ProjectionElem is a Field\n+                variant = Some(*idx);\n+                continue;\n             }\n             ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n@@ -107,7 +112,7 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n                 break;\n             }\n         };\n-\n+        variant = None;\n         hir_projections.push(hir_projection);\n     }\n \n@@ -231,13 +236,12 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                         from_builder.projection\n                     )\n                 } else {\n-                    // FIXME(project-rfc-2229#24): Handle this case properly\n                     debug!(\n                         \"No associated capture found for {:?}[{:#?}]\",\n                         var_hir_id, from_builder.projection,\n                     );\n                 }\n-                return Err(upvar_resolved_place_builder);\n+                return Err(from_builder);\n             };\n \n             let closure_ty = typeck_results\n@@ -289,11 +293,10 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         if let PlaceBase::Local(local) = self.base {\n             Place { local, projection: tcx.intern_place_elems(&self.projection) }\n         } else {\n-            self.try_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n+            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n         }\n     }\n \n-    /// ROX: Function that will be called when we really do need a place\n     fn expect_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n@@ -302,14 +305,14 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n     }\n \n-    fn try_upvars_resolved<'a>(\n+    crate fn try_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n-    ) -> PlaceBuilder<'tcx> {\n+    ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n         match to_upvars_resolved_place_builder(self, tcx, typeck_results) {\n-            Ok(upvars_resolved) => upvars_resolved,\n-            Err(upvars_unresolved) => upvars_unresolved,\n+            Ok(upvars_resolved) => Ok(upvars_resolved),\n+            Err(upvars_unresolved) => Err(upvars_unresolved),\n         }\n     }\n \n@@ -376,7 +379,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n-    // ROX: As place builder\n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n     crate fn as_place_builder("}, {"sha": "c7f16fd4e4049bf498363f49eaf35d92c8626bee", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -165,7 +165,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure { closure_id, substs, upvars, movability, fake_reads } => {\n+            ExprKind::Closure {\n+                closure_id,\n+                substs,\n+                upvars,\n+                movability,\n+                fake_reads: opt_fake_reads,\n+            } => {\n                 // see (*) above\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n@@ -204,18 +210,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n-\n-                if let Some(fake_reads) = fake_reads {\n-                    for thir_place in fake_reads.into_iter() {\n-                        //  = this.hir.mirror(thir_place);\n-                        let mir_place = unpack!(block = this.as_place(block, thir_place));\n-                        // [FIXME] RFC2229 FakeReadCause can be ForLet or ForMatch, need to use the correct one\n-                        this.cfg.push_fake_read(\n-                            block,\n-                            source_info,\n-                            FakeReadCause::ForMatchedPlace,\n-                            mir_place,\n-                        );\n+                if let Some(fake_reads) = opt_fake_reads {\n+                    for (thir_place, cause) in fake_reads.into_iter() {\n+                        let place_builder =\n+                            unpack!(block = this.as_place_builder(block, thir_place));\n+\n+                        if let Ok(place_builder_resolved) =\n+                            place_builder.clone().try_upvars_resolved(this.tcx, this.typeck_results)\n+                        {\n+                            let mir_place = place_builder_resolved\n+                                .clone()\n+                                .into_place(this.tcx, this.typeck_results);\n+                            this.cfg.push_fake_read(block, source_info, cause, mir_place);\n+                        }\n                     }\n                 }\n "}, {"sha": "b2e8b2de1bc6a64f0c30010173f77fe94a121789", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -280,7 +280,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let field_names: Vec<_> =\n                     (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect();\n \n-                // ROX: This is probably here the function record/struct update pattern is done.\n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n                     let place_builder = unpack!(block = this.as_place_builder(block, base));\n "}, {"sha": "59b3fd8647897303e5aa1708015b407460db14a2", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,6 +1,3 @@\n-// ROX: this folder contains all code for handling patterns, including exhaustiveness checking etc.\n-// We want to be careful ^^'\n-\n //! Code related to match expressions. These are sufficiently complex to\n //! warrant their own module and submodules. :) This main module includes the\n //! high-level algorithm, the submodules contain the details.\n@@ -100,7 +97,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n-        let mut arm_candidates = self.create_match_candidates(scrutinee_place.clone(), &arms);\n+        let mut arm_candidates =\n+            self.create_match_candidates(scrutinee_place.clone(), &arms.clone());\n \n         let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n         let mut candidates =\n@@ -127,8 +125,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         scrutinee_span: Span,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let scrutinee_place_builder = unpack!(block = self.as_place_builder(block, scrutinee));\n-        let scrutinee_place =\n-            scrutinee_place_builder.clone().into_place(self.tcx, self.typeck_results);\n         // Matching on a `scrutinee_place` with an uninhabited type doesn't\n         // generate any memory reads by itself, and so if the place \"expression\"\n         // contains unsafe operations like raw pointer dereferences or union\n@@ -146,7 +142,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // check safety.\n         let cause_matched_place = FakeReadCause::ForMatchedPlace;\n         let source_info = self.source_info(scrutinee_span);\n-        self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n+\n+        if let Ok(scrutinee_builder) =\n+            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            let scrutinee_place =\n+                scrutinee_builder.clone().into_place(self.tcx, self.typeck_results);\n+            self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n+        }\n \n         block.and(scrutinee_place_builder)\n     }\n@@ -228,7 +231,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_match_arms(\n         &mut self,\n         destination: Place<'tcx>,\n-        scrutinee_place: PlaceBuilder<'tcx>,\n+        scrutinee_place_builder: PlaceBuilder<'tcx>,\n         scrutinee_span: Span,\n         arm_candidates: Vec<(&'_ Arm<'_, 'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n@@ -242,17 +245,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n+                    let body = arm.body.clone();\n+                    let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n+                    let scrutinee_place: Place<'tcx>;\n+                    if let Ok(scrutinee_builder) = scrutinee_place_builder\n+                        .clone()\n+                        .try_upvars_resolved(this.tcx, this.typeck_results)\n+                    {\n+                        scrutinee_place =\n+                            scrutinee_builder.clone().into_place(this.tcx, this.typeck_results);\n+                        opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n+                    }\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n                         &arm.pattern,\n                         ArmHasGuard(arm.guard.is_some()),\n-                        Some((\n-                            Some(\n-                                &scrutinee_place.clone().into_place(this.tcx, this.typeck_results),\n-                            ),\n-                            scrutinee_span,\n-                        )),\n+                        opt_scrutinee_place,\n                     );\n \n                     let arm_block = this.bind_pattern(\n@@ -457,15 +466,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             _ => {\n-                // Converts the destruct pattern into a place\n-                //\n-                // We don't want to convert to a place right away\n-                // because in case of such pattern inside a closure, the projections matching a\n-                // captured place might have not been applied.\n-                // [FIXME] Need to find where this is happening and make the necessary changes there once\n-                // Candidate is modified\n-                //\n-                // We want to use a place builder; Maybe use `as_place_builder`\n                 let place_builder = unpack!(block = self.as_place_builder(block, initializer));\n                 self.place_into_pattern(block, irrefutable_pat, place_builder, true)\n             }\n@@ -479,12 +479,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         initializer: PlaceBuilder<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n-        let place = initializer.clone().into_place(self.tcx, self.typeck_results);\n-        let mut candidate = Candidate::new(initializer, &irrefutable_pat, false);\n-\n+        let mut candidate = Candidate::new(initializer.clone(), &irrefutable_pat, false);\n         let fake_borrow_temps =\n             self.lower_match_tree(block, irrefutable_pat.span, false, &mut [&mut candidate]);\n-\n         // For matches and function arguments, the place that is being matched\n         // can be set when creating the variables. But the place for\n         // let PATTERN = ... might not even exist until we do the assignment.\n@@ -499,7 +496,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n                     )))) = self.local_decls[local].local_info\n                     {\n-                        *match_place = Some(place);\n+                        if let Ok(match_pair_resolved) =\n+                            initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                        {\n+                            let place = match_pair_resolved\n+                                .clone()\n+                                .into_place(self.tcx, self.typeck_results);\n+                            *match_place = Some(place);\n+                        }\n                     } else {\n                         bug!(\"Let binding to non-user variable.\")\n                     }\n@@ -1461,7 +1465,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows {\n-            fb.insert(match_place.clone().into_place(self.tcx, self.typeck_results));\n+            if let Ok(match_place_resolved) =\n+                match_place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+            {\n+                let resolved_place =\n+                    match_place_resolved.clone().into_place(self.tcx, self.typeck_results);\n+                fb.insert(resolved_place);\n+            }\n         }\n \n         // perform the test, branching to one of N blocks. For each of\n@@ -1776,28 +1786,36 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n                 Guard::IfLet(pat, scrutinee) => {\n                     let scrutinee_span = scrutinee.span;\n-                    let scrutinee_place = unpack!(\n+                    let scrutinee_place_builder = unpack!(\n                         block = self.lower_scrutinee(block, scrutinee.clone(), scrutinee_span)\n                     );\n-                    let mut guard_candidate = Candidate::new(scrutinee_place.clone(), &pat, false);\n+                    let mut guard_candidate =\n+                        Candidate::new(scrutinee_place_builder.clone(), &pat, false);\n                     let wildcard = Pat::wildcard_from_ty(pat.ty);\n                     let mut otherwise_candidate =\n-                        Candidate::new(scrutinee_place.clone(), &wildcard, false);\n+                        Candidate::new(scrutinee_place_builder.clone(), &wildcard, false);\n                     let fake_borrow_temps = self.lower_match_tree(\n                         block,\n                         pat.span,\n                         false,\n                         &mut [&mut guard_candidate, &mut otherwise_candidate],\n                     );\n+                    let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n+                    let scrutinee_place: Place<'tcx>;\n+                    if let Ok(scrutinee_builder) = scrutinee_place_builder\n+                        .clone()\n+                        .try_upvars_resolved(self.tcx, self.typeck_results)\n+                    {\n+                        scrutinee_place =\n+                            scrutinee_builder.clone().into_place(self.tcx, self.typeck_results);\n+                        opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n+                    }\n                     self.declare_bindings(\n                         None,\n                         pat.span.to(arm_span.unwrap()),\n                         pat,\n                         ArmHasGuard(false),\n-                        Some((\n-                            Some(&scrutinee_place.clone().into_place(tcx, self.typeck_results)),\n-                            scrutinee.span,\n-                        )),\n+                        opt_scrutinee_place,\n                     );\n                     let post_guard_block = self.bind_pattern(\n                         self.source_info(pat.span),"}, {"sha": "dc4f28864561a2c2cffaab3139304595831c5138", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -149,16 +149,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Result<(), MatchPair<'pat, 'tcx>> {\n         let tcx = self.tcx;\n-        // Generate place to be used in Ascription\n-        // Generate place to be used in Binding\n-        let place = match_pair.place.clone().into_place(tcx, self.typeck_results);\n         match *match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: thir::pattern::Ascription { variance, user_ty, user_ty_span },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n                 // value being matched, taking the variance field into account.\n+                let place = match_pair.place.clone().into_place(self.tcx, self.typeck_results);\n                 candidate.ascriptions.push(Ascription {\n                     span: user_ty_span,\n                     user_ty,\n@@ -177,6 +175,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Binding { name, mutability, mode, var, ty, ref subpattern, is_primary: _ } => {\n+                let place = match_pair.place.clone().into_place(self.tcx, self.typeck_results);\n                 candidate.bindings.push(Binding {\n                     name,\n                     mutability,"}, {"sha": "02f1998f49619aa2acd91605a741c20636eddf87", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -156,7 +156,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n-        let place = place_builder.clone().into_place(self.tcx, self.typeck_results);\n+        let place: Place<'tcx>;\n+        if let Ok(test_place_builder) =\n+            place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            place = test_place_builder.clone().into_place(self.tcx, self.typeck_results);\n+        } else {\n+            return;\n+        }\n         debug!(\n             \"perform_test({:?}, {:?}: {:?}, {:?})\",\n             block,"}, {"sha": "6b7bd2e9dcc8f350b3b69cb80ef4dc4848ce541b", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -455,27 +455,32 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 );\n \n                 let fake_reads = match self.typeck_results().closure_fake_reads.get(&def_id) {\n-                    Some(vals) => Some(self.arena.alloc_from_iter(vals\n-                        .iter()\n-                        .filter(|val| match val.base {\n-                            HirPlaceBase::Upvar(_) => true,\n-                            _ => false,\n-                        })\n-                        .map(|val| {\n-                            let var_hir_id = match val.base {\n-                                HirPlaceBase::Upvar(upvar_id) => {\n-                                    debug!(\"upvar\");\n-                                    upvar_id.var_path.hir_id\n-                                }\n-                                _ => {\n-                                    bug!(\n-                                        \"Do not know how to get HirId out of Rvalue and StaticItem\"\n-                                    );\n-                                }\n-                            };\n-                            self.fake_read_capture_upvar(expr, val.clone(), var_hir_id)\n-                        })\n-                    )),\n+                    Some(vals) => {\n+                        Some(\n+                            vals.iter()\n+                                .map(|(place, cause)| {\n+                                    (\n+                                        self.arena.alloc(\n+                                            self.convert_captured_hir_place(expr, place.clone()),\n+                                        ),\n+                                        *cause,\n+                                    )\n+                                    // let var_hir_id = match val.base {\n+                                    //     HirPlaceBase::Upvar(upvar_id) => {\n+                                    //         debug!(\"upvar\");\n+                                    //         upvar_id.var_path.hir_id\n+                                    //     }\n+                                    //     _ => {\n+                                    //         bug!(\n+                                    //             \"Do not know how to get HirId out of Rvalue and StaticItem\"\n+                                    //         );\n+                                    //     }\n+                                    // };\n+                                    // self.fake_read_capture_upvar(expr, val.clone(), var_hir_id)\n+                                })\n+                                .collect(),\n+                        )\n+                    }\n                     None => None,\n                 };\n \n@@ -1045,23 +1050,26 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         ExprKind::Deref { arg: ref_expr }\n     }\n \n-    fn fake_read_capture_upvar(\n+    fn convert_captured_hir_place(\n         &mut self,\n         closure_expr: &'tcx hir::Expr<'tcx>,\n         place: HirPlace<'tcx>,\n-        hir_id: hir::HirId,\n     ) -> Expr<'thir, 'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n         let var_ty = place.base_ty;\n \n+        let var_hir_id = match place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            base => bug!(\"Expected an upvar, found {:?}\", base),\n+        };\n+\n         let mut captured_place_expr = Expr {\n             temp_lifetime,\n             ty: var_ty,\n             span: closure_expr.span,\n-            kind: self.convert_var(hir_id),\n+            kind: self.convert_var(var_hir_id),\n         };\n-        // [FIXME] RFC2229 Maybe we should introduce an immutable borrow of the fake capture so that we don't\n-        // end up moving this place\n+\n         for proj in place.projections.iter() {\n             let kind = match proj.kind {\n                 HirProjectionKind::Deref => {\n@@ -1095,48 +1103,9 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         upvar_ty: Ty<'tcx>,\n     ) -> Expr<'thir, 'tcx> {\n         let upvar_capture = captured_place.info.capture_kind;\n+        let captured_place_expr =\n+            self.convert_captured_hir_place(closure_expr, captured_place.place.clone());\n         let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-        let var_ty = captured_place.place.base_ty;\n-\n-        // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n-        // as it's seen for use within the closure and not at the time of closure creation.\n-        //\n-        // That is we see expect to see it start from a captured upvar and not something that is local\n-        // to the closure's parent.\n-        let var_hir_id = match captured_place.place.base {\n-            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-            base => bug!(\"Expected an upvar, found {:?}\", base),\n-        };\n-\n-        let mut captured_place_expr = Expr {\n-            temp_lifetime,\n-            ty: var_ty,\n-            span: closure_expr.span,\n-            kind: self.convert_var(var_hir_id),\n-        };\n-\n-        for proj in captured_place.place.projections.iter() {\n-            let kind = match proj.kind {\n-                HirProjectionKind::Deref => {\n-                    ExprKind::Deref { arg: self.arena.alloc(captured_place_expr) }\n-                }\n-                HirProjectionKind::Field(field, ..) => {\n-                    // Variant index will always be 0, because for multi-variant\n-                    // enums, we capture the enum entirely.\n-                    ExprKind::Field {\n-                        lhs: self.arena.alloc(captured_place_expr),\n-                        name: Field::new(field as usize),\n-                    }\n-                }\n-                HirProjectionKind::Index | HirProjectionKind::Subslice => {\n-                    // We don't capture these projections, so we can ignore them here\n-                    continue;\n-                }\n-            };\n-\n-            captured_place_expr =\n-                Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n-        }\n \n         match upvar_capture {\n             ty::UpvarCapture::ByValue(_) => captured_place_expr,"}, {"sha": "a6ec3b7bdd20df43eff348958ccbba62d50a74ef", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -9,7 +9,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::{BinOp, BorrowKind, Field, UnOp};\n+use rustc_middle::mir::{BinOp, BorrowKind, FakeReadCause, Field, UnOp};\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{AdtDef, Const, Ty, UpvarSubsts, UserType};\n@@ -281,7 +281,7 @@ pub enum ExprKind<'thir, 'tcx> {\n         substs: UpvarSubsts<'tcx>,\n         upvars: &'thir [Expr<'thir, 'tcx>],\n         movability: Option<hir::Movability>,\n-        fake_reads: Option<&'thir mut [Expr<'thir, 'tcx>]>,\n+        fake_reads: Option<Vec<(&'thir mut Expr<'thir, 'tcx>, FakeReadCause)>>,\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,"}, {"sha": "9a43eaa3f5dc0aa0e2f144eea3f288f64828fd5e", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -34,14 +34,14 @@ use super::writeback::Resolver;\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection, ProjectionKind};\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n use rustc_session::lint;\n@@ -248,7 +248,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let final_tupled_upvars_type = self.tcx.mk_tup(final_upvar_tys.iter());\n         self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n-        let fake_reads = delegate.fake_reads.into_iter().map(|fake_read| fake_read).collect();\n+        let fake_reads =\n+            delegate.fake_reads.into_iter().map(|(place, cause)| (place, cause)).collect();\n         self.typeck_results.borrow_mut().closure_fake_reads.insert(closure_def_id, fake_reads);\n \n         // If we are also inferred the closure kind here,\n@@ -1153,7 +1154,7 @@ struct InferBorrowKind<'a, 'tcx> {\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n     /// ```\n     capture_information: InferredCaptureInformation<'tcx>,\n-    fake_reads: FxHashSet<Place<'tcx>>, // these need to be fake read.\n+    fake_reads: Vec<(Place<'tcx>, FakeReadCause)>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -1415,9 +1416,9 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn fake_read(&mut self, place: Place<'tcx>) {\n+    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause) {\n         if let PlaceBase::Upvar(_) = place.base {\n-            self.fake_reads.insert(place);\n+            self.fake_reads.push((place, cause));\n         }\n     }\n "}, {"sha": "1be629ce9dc8f1cf0a70927cc82a271f72716df3", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::Place as HirPlace;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -368,18 +369,20 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_fake_reads_map(&mut self) {\n-        let mut resolved_closure_fake_reads: FxHashMap<DefId, Vec<HirPlace<'tcx>>> =\n-            Default::default();\n+        let mut resolved_closure_fake_reads: FxHashMap<\n+            DefId,\n+            Vec<(HirPlace<'tcx>, FakeReadCause)>,\n+        > = Default::default();\n         for (closure_def_id, fake_reads) in\n             self.fcx.typeck_results.borrow().closure_fake_reads.iter()\n         {\n-            let mut resolved_fake_reads = Vec::<HirPlace<'tcx>>::new();\n-            for fake_read in fake_reads.iter() {\n+            let mut resolved_fake_reads = Vec::<(HirPlace<'tcx>, FakeReadCause)>::new();\n+            for (place, cause) in fake_reads.iter() {\n                 let locatable =\n                     self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n \n-                let resolved_fake_read = self.resolve(fake_read.clone(), &locatable);\n-                resolved_fake_reads.push(resolved_fake_read);\n+                let resolved_fake_read = self.resolve(place.clone(), &locatable);\n+                resolved_fake_reads.push((resolved_fake_read, *cause));\n             }\n             resolved_closure_fake_reads.insert(*closure_def_id, resolved_fake_reads);\n         }"}, {"sha": "6dbf8094548e83891afcd59e32d8ca9e6f6c4e49", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -8,13 +8,14 @@ pub use self::ConsumeMode::*;\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::LocalDefId;\n-// use rustc_hir::Pat;\n use rustc_hir::PatKind;\n+use rustc_hir::QPath;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -54,7 +55,7 @@ pub trait Delegate<'tcx> {\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n     // [FIXME] RFC2229 This should also affect clippy ref: https://github.com/sexxi-goose/rust/pull/27\n-    fn fake_read(&mut self, place: Place<'tcx>);\n+    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -237,18 +238,26 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // We only want to borrow discr if the pattern contain something other\n                 // than wildcards\n                 let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n-                let mut res = false;\n+                let mut needs_to_be_read = false;\n                 for arm in arms.iter() {\n                     return_if_err!(mc.cat_pattern(discr_place.clone(), &arm.pat, |_place, pat| {\n                         if let PatKind::Binding(_, _, _, opt_sub_pat) = pat.kind {\n                             if let None = opt_sub_pat {\n-                                res = true;\n+                                needs_to_be_read = true;\n+                            }\n+                        } else if let PatKind::TupleStruct(qpath, _, _) = &pat.kind {\n+                            // If a TupleStruct has a Some PathSegment, we should read the discr_place\n+                            // regardless if it contains a Wild pattern later\n+                            if let QPath::Resolved(_, path) = qpath {\n+                                if let Res::Def(DefKind::Ctor(_, _), _) = path.res {\n+                                    needs_to_be_read = true;\n+                                }\n                             }\n                         }\n                     }));\n                 }\n \n-                if res {\n+                if needs_to_be_read {\n                     self.borrow_expr(&discr, ty::ImmBorrow);\n                 }\n \n@@ -539,6 +548,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n \n     fn walk_arm(&mut self, discr_place: &PlaceWithHirId<'tcx>, arm: &hir::Arm<'_>) {\n+        self.delegate.fake_read(discr_place.place.clone(), FakeReadCause::ForMatchedPlace);\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -551,15 +561,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n+        self.delegate.fake_read(discr_place.place.clone(), FakeReadCause::ForLet);\n         self.walk_pat(discr_place, pat);\n     }\n \n     /// The core driver for walking a pattern\n     fn walk_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n-        self.delegate.fake_read(discr_place.place.clone());\n-\n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, body_owner: _, ref mut delegate } = *self;\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n@@ -620,10 +629,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n     /// closure as the DefId.\n     fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n-        // Over here we walk a closure that is nested inside the current body\n-        // If the current body is a closure, then we also want to report back any fake reads,\n-        // starting off of variables that are captured by our parent as well.\n-\n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n         let upvars = self.tcx().upvars_mentioned(self.body_owner);\n \n@@ -633,15 +638,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Closure(..) | ty::Generator(..)\n         );\n \n-        // [FIXME] RFC2229 Closures within closures don't work\n         if let Some(fake_reads) = self.mc.typeck_results.closure_fake_reads.get(&closure_def_id) {\n-            for fake_read in fake_reads.iter() {\n-                // Use this as a reference for if we should promote the fake read\n+            for (fake_read, cause) in fake_reads.iter() {\n                 match fake_read.base {\n                     PlaceBase::Upvar(upvar_id) => {\n                         if upvars.map_or(body_owner_is_closure, |upvars| {\n                             !upvars.contains_key(&upvar_id.var_path.hir_id)\n                         }) {\n+                            // [FIXME] RFC2229 Update this comment\n                             // The nested closure might be capturing the current (enclosing) closure's local variables.\n                             // We check if the root variable is ever mentioned within the enclosing closure, if not\n                             // then for the current body (if it's a closure) these aren't captures, we will ignore them.\n@@ -655,14 +659,13 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         );\n                     }\n                 };\n-                self.delegate.fake_read(fake_read.clone());\n+                self.delegate.fake_read(fake_read.clone(), *cause);\n             }\n         }\n \n         if let Some(min_captures) = self.mc.typeck_results.closure_min_captures.get(&closure_def_id)\n         {\n             for (var_hir_id, min_list) in min_captures.iter() {\n-                // Use this as a reference for if we should promote the fake read\n                 if upvars.map_or(body_owner_is_closure, |upvars| !upvars.contains_key(var_hir_id)) {\n                     // The nested closure might be capturing the current (enclosing) closure's local variables.\n                     // We check if the root variable is ever mentioned within the enclosing closure, if not"}, {"sha": "402f5e4f33e6f30bbf29239d4fcade7aceac5d5b", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.stderr", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -7,19 +7,6 @@ LL | #![feature(capture_disjoint_fields)]\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-warning: irrefutable `if let` pattern\n-  --> $DIR/closure-origin-single-variant-diagnostics.rs:18:9\n-   |\n-LL | /         if let SingleVariant::Point(ref mut x, _) = point {\n-LL | |\n-LL | |             *x += 1;\n-LL | |         }\n-   | |_________^\n-   |\n-   = note: `#[warn(irrefutable_let_patterns)]` on by default\n-   = note: this pattern will always match, so the `if let` is useless\n-   = help: consider replacing the `if let` with a `let`\n-\n error[E0382]: use of moved value: `c`\n   --> $DIR/closure-origin-single-variant-diagnostics.rs:21:13\n    |"}, {"sha": "d91a28feae5c93913e582504fabc623164e911d6", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure-pattern-closure-within-closure.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,17 +1,19 @@\n+//check-pass\n #![feature(capture_disjoint_fields)]\n-#![feature(rustc_attrs)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n \n fn main() {\n     let _z = 9;\n     let t = (String::from(\"Hello\"), String::from(\"World\"));\n     let g = (String::from(\"Mr\"), String::from(\"Goose\"));\n \n-    let a = #[rustc_capture_analysis] || {\n+    let a = || {\n         let (_, g2) = g;\n-        println!(\"{}\", g2);\n-        let c = #[rustc_capture_analysis] ||  {\n+        //~^ WARN unused variable: `g2`\n+        let c = ||  {\n             let (_, t2) = t;\n-            println!(\"{}\", t2);\n+            //~^ WARN unused variable: `t2`\n         };\n \n         c();"}, {"sha": "d88c16567b74eb0e7408889ccd7fa07112bc5c85", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure-pattern-closure-within-closure.stderr", "status": "modified", "additions": 13, "deletions": 93, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,110 +1,30 @@\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:9:13\n-   |\n-LL |     let a = #[rustc_capture_analysis] || {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:12:17\n-   |\n-LL |         let c = #[rustc_capture_analysis] ||  {\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:1:12\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:2:12\n    |\n LL | #![feature(capture_disjoint_fields)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-error: First Pass analysis includes:\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:12:43\n-   |\n-LL |           let c = #[rustc_capture_analysis] ||  {\n-   |  ___________________________________________^\n-LL | |             let (_, t2) = t;\n-LL | |             println!(\"{}\", t2);\n-LL | |         };\n-   | |_________^\n-   |\n-note: Capturing t[(1, 0)] -> ByValue\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:13:27\n-   |\n-LL |             let (_, t2) = t;\n-   |                           ^\n-\n-error: Min Capture analysis includes:\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:12:43\n-   |\n-LL |           let c = #[rustc_capture_analysis] ||  {\n-   |  ___________________________________________^\n-LL | |             let (_, t2) = t;\n-LL | |             println!(\"{}\", t2);\n-LL | |         };\n-   | |_________^\n-   |\n-note: Min Capture t[(1, 0)] -> ByValue\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:13:27\n+warning: unused variable: `t2`\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:15:21\n    |\n LL |             let (_, t2) = t;\n-   |                           ^\n-\n-error: First Pass analysis includes:\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:9:39\n+   |                     ^^ help: if this is intentional, prefix it with an underscore: `_t2`\n    |\n-LL |       let a = #[rustc_capture_analysis] || {\n-   |  _______________________________________^\n-LL | |         let (_, g2) = g;\n-LL | |         println!(\"{}\", g2);\n-LL | |         let c = #[rustc_capture_analysis] ||  {\n-...  |\n-LL | |         c();\n-LL | |     };\n-   | |_____^\n-   |\n-note: Capturing g[(1, 0)] -> ByValue\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:10:23\n-   |\n-LL |         let (_, g2) = g;\n-   |                       ^\n-note: Capturing t[(1, 0)] -> ByValue\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:13:27\n+note: the lint level is defined here\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:4:9\n    |\n-LL |             let (_, t2) = t;\n-   |                           ^\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n \n-error: Min Capture analysis includes:\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:9:39\n-   |\n-LL |       let a = #[rustc_capture_analysis] || {\n-   |  _______________________________________^\n-LL | |         let (_, g2) = g;\n-LL | |         println!(\"{}\", g2);\n-LL | |         let c = #[rustc_capture_analysis] ||  {\n-...  |\n-LL | |         c();\n-LL | |     };\n-   | |_____^\n-   |\n-note: Min Capture g[(1, 0)] -> ByValue\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:10:23\n+warning: unused variable: `g2`\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:12:17\n    |\n LL |         let (_, g2) = g;\n-   |                       ^\n-note: Min Capture t[(1, 0)] -> ByValue\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:13:27\n-   |\n-LL |             let (_, t2) = t;\n-   |                           ^\n+   |                 ^^ help: if this is intentional, prefix it with an underscore: `_g2`\n \n-error: aborting due to 6 previous errors; 1 warning emitted\n+warning: 3 warnings emitted\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "757b506fd6edeacb09ed33b29d2f2f22ece93fdf", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns-1.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b6cf070eb4c228c146ca9971cddeb034084f88de/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6cf070eb4c228c146ca9971cddeb034084f88de/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns-1.rs?ref=b6cf070eb4c228c146ca9971cddeb034084f88de", "patch": "@@ -1,118 +0,0 @@\n-//check-pass\n-#![feature(capture_disjoint_fields)]\n-//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n-#![warn(unused)]\n-\n-struct Point {\n-    x: u32,\n-    y: u32,\n-}\n-\n-fn test1() {\n-    let _z = 9;\n-    let t = (String::from(\"Hello\"), String::from(\"World\"));\n-\n-    let c = ||  {\n-        let (t1, t2) = t;\n-        println!(\"{} {}\", t1, t2);\n-    };\n-\n-    c();\n-}\n-\n-fn test2() {\n-    let _z = 9;\n-    let t = (String::from(\"Hello\"), String::from(\"World\"));\n-\n-    let c = ||  {\n-        let (t1, _) = t;\n-        println!(\"{}\", t1);\n-    };\n-\n-    c();\n-}\n-\n-fn test3() {\n-    let _z = 9;\n-    let t = (String::from(\"Hello\"), String::from(\"World\"));\n-\n-    let c = ||  {\n-        let (_, t2) = t;\n-        println!(\"{}\", t2);\n-    };\n-\n-    c();\n-}\n-\n-fn test4() {\n-    let _z = 9;\n-    let t = (String::from(\"Hello\"), String::from(\"World\"));\n-    //~^ WARN unused variable: `t`\n-\n-    let c = ||  {\n-        let (_, _) = t;\n-    };\n-\n-    c();\n-}\n-\n-fn test5() {\n-    let _z = 9;\n-    let t = (String::new(), String::new());\n-    let _c = ||  {\n-        let _a = match t {\n-            (t1, _) => t1,\n-        };\n-    };\n-}\n-\n-fn test6() {\n-    let _z = 9;\n-    let t = (String::new(), String::new());\n-    let _c = ||  {\n-        let _a = match t {\n-            (_, t2) => t2,\n-        };\n-    };\n-}\n-\n-fn test7() {\n-    let x = 0;\n-    //~^ WARN unused variable: `x`\n-    let tup = (1, 2);\n-    //~^ WARN unused variable: `tup`\n-    let p = Point { x: 10, y: 20 };\n-\n-    let c = || {\n-        let _ = x;\n-        let Point { x, y } = p; // 1\n-        //~^ WARN unused variable: `x`\n-        println!(\"{}\", y);\n-        let (_, _) = tup; // 2\n-    };\n-\n-    c();\n-}\n-\n-fn test8() {\n-    let _z = 9;\n-    let t = (String::from(\"Hello\"), String::from(\"World\"));\n-\n-    let c = ||  {\n-        let (_, t) = t;\n-        println!(\"{}\", t);\n-    };\n-\n-    c();\n-}\n-\n-fn main() {\n-    test1();\n-    test2();\n-    test3();\n-    test4();\n-    test5();\n-    test6();\n-    test7();\n-    test8();\n-}"}, {"sha": "1ae64eb83ef78eeb350f0b51f832785351ed6e2d", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns-1.stderr", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b6cf070eb4c228c146ca9971cddeb034084f88de/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6cf070eb4c228c146ca9971cddeb034084f88de/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns-1.stderr?ref=b6cf070eb4c228c146ca9971cddeb034084f88de", "patch": "@@ -1,42 +0,0 @@\n-warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/destructure_patterns-1.rs:2:12\n-   |\n-LL | #![feature(capture_disjoint_fields)]\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n-\n-warning: unused variable: `t`\n-  --> $DIR/destructure_patterns-1.rs:49:9\n-   |\n-LL |     let t = (String::from(\"Hello\"), String::from(\"World\"));\n-   |         ^ help: if this is intentional, prefix it with an underscore: `_t`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/destructure_patterns-1.rs:4:9\n-   |\n-LL | #![warn(unused)]\n-   |         ^^^^^^\n-   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n-\n-warning: unused variable: `x`\n-  --> $DIR/destructure_patterns-1.rs:88:21\n-   |\n-LL |         let Point { x, y } = p; // 1\n-   |                     ^ help: try ignoring the field: `x: _`\n-\n-warning: unused variable: `x`\n-  --> $DIR/destructure_patterns-1.rs:80:9\n-   |\n-LL |     let x = 0;\n-   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n-\n-warning: unused variable: `tup`\n-  --> $DIR/destructure_patterns-1.rs:82:9\n-   |\n-LL |     let tup = (1, 2);\n-   |         ^^^ help: if this is intentional, prefix it with an underscore: `_tup`\n-\n-warning: 5 warnings emitted\n-"}, {"sha": "7d2c573dddd7c5524ebbac423c979584334cddb3", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns.rs", "status": "modified", "additions": 110, "deletions": 38, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,52 +1,124 @@\n+//check-pass\n #![feature(capture_disjoint_fields)]\n-#![feature(rustc_attrs)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n \n-struct S {\n-    a: String,\n-    b: String,\n+struct Point {\n+    x: u32,\n+    y: u32,\n }\n \n-fn main() {\n+fn test1() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (t1, t2) = t;\n+        //~^ WARN unused variable: `t1`\n+        //~| WARN unused variable: `t2`\n+    };\n+\n+    c();\n+}\n+\n+fn test2() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (t1, _) = t;\n+        //~^ WARN unused variable: `t1`\n+    };\n+\n+    c();\n+}\n+\n+fn test3() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (_, t2) = t;\n+        //~^ WARN unused variable: `t2`\n+    };\n+\n+    c();\n+}\n+\n+fn test4() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+    //~^ WARN unused variable: `t`\n+\n+    let c = ||  {\n+        let (_, _) = t;\n+    };\n+\n+    c();\n+}\n+\n+fn test5() {\n     let t = (String::new(), String::new());\n+    let _c = ||  {\n+        let _a = match t {\n+            (t1, _) => t1,\n+        };\n+    };\n+}\n \n-    let s = S {\n-        a: String::new(),\n-        b: String::new(),\n+fn test6() {\n+    let t = (String::new(), String::new());\n+    let _c = ||  {\n+        let _a = match t {\n+            (_, t2) => t2,\n+        };\n     };\n+}\n \n-    let c = #[rustc_capture_analysis] || {\n-        let (t1, t2) = t;\n+fn test7() {\n+    let t = (String::new(), String::new());\n+    let _c = ||  {\n+        let _a = match t {\n+            (t1, t2) => (t1, t2),\n+        };\n     };\n+}\n \n+// [FIXME] RFC2229 Add an explanation for test\n+fn test8() {\n+    let x = 0;\n+    //~^ WARN unused variable: `x`\n+    let tup = (1, 2);\n+    //~^ WARN unused variable: `tup`\n+    let p = Point { x: 10, y: 20 };\n \n-    // MIR Build\n-    //\n-    // Create place for the initalizer in let which is `t`\n-    //\n-    // I'm reading Field 1 from `t`, so apply Field projections;\n-    //\n-    // new place -> t[1]\n-    //\n-    // I'm reading Field 2 from `t`, so apply Field projections;\n-    //\n-    // new place -> t[2]\n-    //\n-    // New\n-    // ---------\n-    //\n-    // I'm building something starting at `t`\n-    //\n-    // I read field 1 from `t`\n-    //\n-    // I need to use `t[1]`, therefore the place must be constructable\n-    //\n-    // Find the capture index for `t[1]` for this closure.\n-    //\n-    // I read field 2 from `t`\n-    //\n-    // I need to use `t[2]`, therefore the place must be constructable\n-    //\n-    // Find the capture index for `t[2]` for this closure.\n+    let c = || {\n+        let _ = x;\n+        let Point { x, y } = p; // 1\n+        //~^ WARN unused variable: `x`\n+        println!(\"{}\", y);\n+        let (_, _) = tup; // 2\n+    };\n+\n+    c();\n+}\n+\n+fn test9() {\n+    let _z = 9;\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (_, t) = t;\n+        println!(\"{}\", t);\n+    };\n \n     c();\n }\n+\n+fn main() {\n+    test1();\n+    test2();\n+    test3();\n+    test4();\n+    test5();\n+    test6();\n+    test7();\n+    test8();\n+    test9();\n+}"}, {"sha": "b92bf089e9ed23868f67661a5db84a50a0ba6731", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns.stderr", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,61 +1,66 @@\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/destructure_patterns.rs:17:13\n-   |\n-LL |     let c = #[rustc_capture_analysis] || {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/destructure_patterns.rs:1:12\n+  --> $DIR/destructure_patterns.rs:2:12\n    |\n LL | #![feature(capture_disjoint_fields)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-error: First Pass analysis includes:\n-  --> $DIR/destructure_patterns.rs:17:39\n+warning: unused variable: `t1`\n+  --> $DIR/destructure_patterns.rs:15:14\n    |\n-LL |       let c = #[rustc_capture_analysis] || {\n-   |  _______________________________________^\n-LL | |         let (t1, t2) = t;\n-LL | |     };\n-   | |_____^\n+LL |         let (t1, t2) = t;\n+   |              ^^ help: if this is intentional, prefix it with an underscore: `_t1`\n    |\n-note: Capturing t[(0, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:18:24\n+note: the lint level is defined here\n+  --> $DIR/destructure_patterns.rs:4:9\n    |\n-LL |         let (t1, t2) = t;\n-   |                        ^\n-note: Capturing t[(1, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:18:24\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+\n+warning: unused variable: `t2`\n+  --> $DIR/destructure_patterns.rs:15:18\n    |\n LL |         let (t1, t2) = t;\n-   |                        ^\n+   |                  ^^ help: if this is intentional, prefix it with an underscore: `_t2`\n \n-error: Min Capture analysis includes:\n-  --> $DIR/destructure_patterns.rs:17:39\n+warning: unused variable: `t1`\n+  --> $DIR/destructure_patterns.rs:27:14\n    |\n-LL |       let c = #[rustc_capture_analysis] || {\n-   |  _______________________________________^\n-LL | |         let (t1, t2) = t;\n-LL | |     };\n-   | |_____^\n+LL |         let (t1, _) = t;\n+   |              ^^ help: if this is intentional, prefix it with an underscore: `_t1`\n+\n+warning: unused variable: `t2`\n+  --> $DIR/destructure_patterns.rs:38:17\n    |\n-note: Min Capture t[(0, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:18:24\n+LL |         let (_, t2) = t;\n+   |                 ^^ help: if this is intentional, prefix it with an underscore: `_t2`\n+\n+warning: unused variable: `t`\n+  --> $DIR/destructure_patterns.rs:46:9\n    |\n-LL |         let (t1, t2) = t;\n-   |                        ^\n-note: Min Capture t[(1, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:18:24\n+LL |     let t = (String::from(\"Hello\"), String::from(\"World\"));\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_t`\n+\n+warning: unused variable: `x`\n+  --> $DIR/destructure_patterns.rs:93:21\n    |\n-LL |         let (t1, t2) = t;\n-   |                        ^\n+LL |         let Point { x, y } = p; // 1\n+   |                     ^ help: try ignoring the field: `x: _`\n+\n+warning: unused variable: `x`\n+  --> $DIR/destructure_patterns.rs:85:9\n+   |\n+LL |     let x = 0;\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+\n+warning: unused variable: `tup`\n+  --> $DIR/destructure_patterns.rs:87:9\n+   |\n+LL |     let tup = (1, 2);\n+   |         ^^^ help: if this is intentional, prefix it with an underscore: `_tup`\n \n-error: aborting due to 3 previous errors; 1 warning emitted\n+warning: 9 warnings emitted\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "6b3835634c6fea7d0c9a6204ea316ea8e2ec9937", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/no_capture_with_wildcard_match.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fno_capture_with_wildcard_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fno_capture_with_wildcard_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fno_capture_with_wildcard_match.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,12 +1,25 @@\n+//check-pass\n #![feature(capture_disjoint_fields)]\n //~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n-#![feature(rustc_attrs)]\n \n-fn main() {\n+fn test1() {\n     let foo = [1, 2, 3];\n-    let c = #[rustc_capture_analysis] || {\n-        //~^ ERROR: attributes on expressions are experimental\n-        //~| ERROR: First Pass analysis includes:\n+    let c = || {\n         match foo { _ => () };\n     };\n }\n+\n+fn test2() {\n+    let foo = Some([1, 2, 3]);\n+    let c = || {\n+        match foo {\n+            Some(_) => 1,\n+            _ => 2\n+        };\n+    };\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+}"}, {"sha": "6f5b28aa6cf67fe6a715d0dcdfc08dff155fb0d7", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/no_capture_with_wildcard_match.stderr", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fno_capture_with_wildcard_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fno_capture_with_wildcard_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fno_capture_with_wildcard_match.stderr?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,32 +1,11 @@\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/no_capture_with_wildcard_match.rs:7:13\n-   |\n-LL |     let c = #[rustc_capture_analysis] || {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/no_capture_with_wildcard_match.rs:1:12\n+  --> $DIR/no_capture_with_wildcard_match.rs:2:12\n    |\n LL | #![feature(capture_disjoint_fields)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-error: First Pass analysis includes:\n-  --> $DIR/no_capture_with_wildcard_match.rs:7:39\n-   |\n-LL |       let c = #[rustc_capture_analysis] || {\n-   |  _______________________________________^\n-LL | |\n-LL | |\n-LL | |         match foo { _ => () };\n-LL | |     };\n-   | |_____^\n-\n-error: aborting due to 2 previous errors; 1 warning emitted\n+warning: 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "34710e69b965952ff037c9faff381c17494478c4", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct_update_syntax.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.rs?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,4 +1,6 @@\n+//check-pass\n #![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n #![feature(rustc_attrs)]\n \n struct S {\n@@ -12,7 +14,7 @@ fn main() {\n         b: String::new(),\n     };\n \n-    let c = #[rustc_capture_analysis] || {\n+    let c = || {\n         let s2 = S {\n             a: format!(\"New a\"),\n             ..s"}, {"sha": "66171f35763d8e495ec7114fd68581e58684c6df", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct_update_syntax.stderr", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.stderr?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -1,57 +1,11 @@\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/struct_update_syntax.rs:15:13\n-   |\n-LL |     let c = #[rustc_capture_analysis] || {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/struct_update_syntax.rs:1:12\n+  --> $DIR/struct_update_syntax.rs:2:12\n    |\n LL | #![feature(capture_disjoint_fields)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-error: First Pass analysis includes:\n-  --> $DIR/struct_update_syntax.rs:15:39\n-   |\n-LL |       let c = #[rustc_capture_analysis] || {\n-   |  _______________________________________^\n-LL | |         let s2 = S {\n-LL | |             a: format!(\"New a\"),\n-LL | |             ..s\n-LL | |         };\n-LL | |     };\n-   | |_____^\n-   |\n-note: Capturing s[(1, 0)] -> ByValue\n-  --> $DIR/struct_update_syntax.rs:18:15\n-   |\n-LL |             ..s\n-   |               ^\n-\n-error: Min Capture analysis includes:\n-  --> $DIR/struct_update_syntax.rs:15:39\n-   |\n-LL |       let c = #[rustc_capture_analysis] || {\n-   |  _______________________________________^\n-LL | |         let s2 = S {\n-LL | |             a: format!(\"New a\"),\n-LL | |             ..s\n-LL | |         };\n-LL | |     };\n-   | |_____^\n-   |\n-note: Min Capture s[(1, 0)] -> ByValue\n-  --> $DIR/struct_update_syntax.rs:18:15\n-   |\n-LL |             ..s\n-   |               ^\n-\n-error: aborting due to 3 previous errors; 1 warning emitted\n+warning: 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "a3469ee21142516d0fdd2fefab358737a07c3638", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/685a4c6b6b6016fa0c4b1ae4af745103add0bb02/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "patch": "@@ -189,18 +189,19 @@ LL |     drop(_x3);\n error[E0382]: use of moved value: `tup`\n   --> $DIR/borrowck-move-ref-pattern.rs:43:14\n    |\n-LL |     let mut tup = (U, U, U);\n-   |         ------- move occurs because `tup` has type `(U, U, U)`, which does not implement the `Copy` trait\n-LL |     let c1 = || {\n-   |              -- value moved into closure here\n-LL |         let (ref _x0, _x1, _) = tup;\n-   |                                 --- variable moved due to use in closure\n-LL |     };\n-LL |     let c2 = || {\n-   |              ^^ value used here after move\n-LL |\n-LL |         let (ref mut _x0, _, _x2) = tup;\n-   |                                     --- use occurs due to use in closure\n+LL |       let mut tup = (U, U, U);\n+   |           ------- move occurs because `tup` has type `(U, U, U)`, which does not implement the `Copy` trait\n+LL |       let c1 = || {\n+   |                -- value moved into closure here\n+LL |           let (ref _x0, _x1, _) = tup;\n+   |                                   --- variable moved due to use in closure\n+LL |       };\n+LL |       let c2 = || {\n+   |  ______________^\n+LL | |\n+LL | |         let (ref mut _x0, _, _x2) = tup;\n+LL | |     };\n+   | |_____^ value used here after move\n \n error: aborting due to 18 previous errors\n "}]}