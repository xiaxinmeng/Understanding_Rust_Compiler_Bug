{"sha": "2bcd951749b67402ccaa31f1bb0349656f880fe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiY2Q5NTE3NDliNjc0MDJjY2FhMzFmMWJiMDM0OTY1NmY4ODBmZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-01T19:16:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-01T19:16:24Z"}, "message": "auto merge of #11974 : huonw/rust/no-at-vec, r=pcwalton\n\nThis removes @[] from the parser as well as much of the handling of it (and `@str`) from the compiler as I can find.\r\n\r\nI've just rebased @pcwalton's (already reviewed) `@str` removal (and fixed the problems in a separate commit); the only new work is the trailing commits with my authorship.\r\n\r\nCloses #11967", "tree": {"sha": "bb3de89383f032ca622a27e20e237282c9569a48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb3de89383f032ca622a27e20e237282c9569a48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bcd951749b67402ccaa31f1bb0349656f880fe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bcd951749b67402ccaa31f1bb0349656f880fe2", "html_url": "https://github.com/rust-lang/rust/commit/2bcd951749b67402ccaa31f1bb0349656f880fe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bcd951749b67402ccaa31f1bb0349656f880fe2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60ffbeb2a495d097e38f51348ebcf5a884947c25", "url": "https://api.github.com/repos/rust-lang/rust/commits/60ffbeb2a495d097e38f51348ebcf5a884947c25", "html_url": "https://github.com/rust-lang/rust/commit/60ffbeb2a495d097e38f51348ebcf5a884947c25"}, {"sha": "212507413a2768ec4b6a072dde73d60527c2beee", "url": "https://api.github.com/repos/rust-lang/rust/commits/212507413a2768ec4b6a072dde73d60527c2beee", "html_url": "https://github.com/rust-lang/rust/commit/212507413a2768ec4b6a072dde73d60527c2beee"}], "stats": {"total": 4717, "additions": 2078, "deletions": 2639}, "files": [{"sha": "0b817539b2988755d91072216b928c4fb1462b53", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -3079,7 +3079,7 @@ A value of type `str` is a Unicode string,\n represented as a vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n Since `str` is of unknown size, it is not a _first class_ type,\n but can only be instantiated through a pointer type,\n-such as `&str`, `@str` or `~str`.\n+such as `&str` or `~str`.\n \n ### Tuple types\n \n@@ -3115,7 +3115,7 @@ Such a definite-sized vector type is a first-class type, since its size is known\n A vector without such a size is said to be of _indefinite_ size,\n and is therefore not a _first-class_ type.\n An indefinite-size vector can only be instantiated through a pointer type,\n-such as `&[T]`, `@[T]` or `~[T]`.\n+such as `&[T]` or `~[T]`.\n The kind of a vector type depends on the kind of its element type,\n as with other simple structural types.\n "}, {"sha": "9bd4c1d58fc6b7d1b7dd66b8a094c43ace5e469e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -27,28 +27,38 @@ extern mod extra;\n use extra::list::{List, Cons, Nil};\n use extra::list;\n \n-use std::at_vec;\n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::num;\n use std::ptr;\n use std::kinds::marker;\n use std::mem;\n+use std::rc::Rc;\n use std::rt::global_heap;\n use std::unstable::intrinsics::{TyDesc, get_tydesc};\n use std::unstable::intrinsics;\n use std::util;\n+use std::vec;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n #[deriving(Clone)]\n struct Chunk {\n-    data: RefCell<@[u8]>,\n+    data: Rc<RefCell<~[u8]>>,\n     fill: Cell<uint>,\n     is_pod: Cell<bool>,\n }\n+impl Chunk {\n+    fn capacity(&self) -> uint {\n+        self.data.borrow().borrow().get().capacity()\n+    }\n+\n+    unsafe fn as_ptr(&self) -> *u8 {\n+        self.data.borrow().borrow().get().as_ptr()\n+    }\n+}\n \n // Arenas are used to quickly allocate objects that share a\n // lifetime. The arena uses ~[u8] vectors as a backing store to\n@@ -97,10 +107,8 @@ impl Arena {\n }\n \n fn chunk(size: uint, is_pod: bool) -> Chunk {\n-    let mut v: @[u8] = @[];\n-    unsafe { at_vec::raw::reserve(&mut v, size); }\n     Chunk {\n-        data: RefCell::new(unsafe { cast::transmute(v) }),\n+        data: Rc::new(RefCell::new(vec::with_capacity(size))),\n         fill: Cell::new(0u),\n         is_pod: Cell::new(is_pod),\n     }\n@@ -131,10 +139,7 @@ fn round_up(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n     let mut idx = 0;\n-    let buf = {\n-        let data = chunk.data.borrow();\n-        data.get().as_ptr()\n-    };\n+    let buf = chunk.as_ptr();\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n@@ -172,11 +177,13 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TyDesc, bool) {\n }\n \n impl Arena {\n+    fn chunk_size(&self) -> uint {\n+        self.pod_head.capacity()\n+    }\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.pod_head.data.get());\n-        let new_min_chunk_size = num::max(n_bytes, chunk_size);\n+        let new_min_chunk_size = num::max(n_bytes, self.chunk_size());\n         self.chunks.set(@Cons(self.pod_head.clone(), self.chunks.get()));\n         self.pod_head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n@@ -190,15 +197,15 @@ impl Arena {\n             let this = transmute_mut_region(self);\n             let start = round_up(this.pod_head.fill.get(), align);\n             let end = start + n_bytes;\n-            if end > at_vec::capacity(this.pod_head.data.get()) {\n+            if end > self.chunk_size() {\n                 return this.alloc_pod_grow(n_bytes, align);\n             }\n             this.pod_head.fill.set(end);\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill.get());\n \n-            ptr::offset(this.pod_head.data.get().as_ptr(), start as int)\n+            this.pod_head.as_ptr().offset(start as int)\n         }\n     }\n \n@@ -217,8 +224,7 @@ impl Arena {\n     fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.head.data.get());\n-        let new_min_chunk_size = num::max(n_bytes, chunk_size);\n+        let new_min_chunk_size = num::max(n_bytes, self.chunk_size());\n         self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n         self.head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);\n@@ -244,7 +250,7 @@ impl Arena {\n                 end = start + n_bytes;\n             }\n \n-            if end > at_vec::capacity(self.head.data.get()) {\n+            if end > self.head.capacity() {\n                 return self.alloc_nonpod_grow(n_bytes, align);\n             }\n \n@@ -254,7 +260,7 @@ impl Arena {\n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = self.head.data.get().as_ptr();\n+            let buf = self.head.as_ptr();\n             return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n         }\n     }\n@@ -606,5 +612,3 @@ mod test {\n         })\n     }\n }\n-\n-"}, {"sha": "cea899b18c01a112ddc9ff46a536c82f037e68af", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -80,7 +80,7 @@ pub mod BigDigit {\n /**\n A big unsigned integer type.\n \n-A `BigUint`-typed value `BigUint { data: @[a, b, c] }` represents a number\n+A `BigUint`-typed value `BigUint { data: ~[a, b, c] }` represents a number\n `(a + b * BigDigit::base + c * BigDigit::base^2)`.\n */\n #[deriving(Clone)]"}, {"sha": "9b1b1e0548e0727dd059cfc30413a4f8190c7022", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -18,7 +18,6 @@ Core encoding and decoding interfaces.\n #[forbid(non_camel_case_types)];\n \n \n-use std::at_vec;\n use std::hashmap::{HashMap, HashSet};\n use std::rc::Rc;\n use std::trie::{TrieMap, TrieSet};\n@@ -310,18 +309,6 @@ impl<D:Decoder> Decodable<D> for ~str {\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for @str {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for @str {\n-    fn decode(d: &mut D) -> @str {\n-        d.read_str().to_managed()\n-    }\n-}\n-\n impl<S:Encoder> Encodable<S> for f32 {\n     fn encode(&self, s: &mut S) {\n         s.emit_f32(*self)\n@@ -456,26 +443,6 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n-    fn decode(d: &mut D) -> @[T] {\n-        d.read_seq(|d, len| {\n-            at_vec::from_fn(len, |i| {\n-                d.read_seq_elt(i, |d| Decodable::decode(d))\n-            })\n-        })\n-    }\n-}\n-\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) {\n         s.emit_option(|s| {"}, {"sha": "fc38fa25a214655799f0ab2386def9bbd5a3babf", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -473,10 +473,10 @@ pub fn build_link_meta(sess: Session,\n                        symbol_hasher: &mut Sha256)\n                        -> LinkMeta {\n     // This calculates CMH as defined above\n-    fn crate_hash(symbol_hasher: &mut Sha256, crateid: &CrateId) -> @str {\n+    fn crate_hash(symbol_hasher: &mut Sha256, crateid: &CrateId) -> ~str {\n         symbol_hasher.reset();\n         symbol_hasher.input_str(crateid.to_str());\n-        truncated_hash_result(symbol_hasher).to_managed()\n+        truncated_hash_result(symbol_hasher)\n     }\n \n     let crateid = match attr::find_crateid(attrs) {\n@@ -510,7 +510,8 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n pub fn symbol_hash(tcx: ty::ctxt,\n                    symbol_hasher: &mut Sha256,\n                    t: ty::t,\n-                   link_meta: &LinkMeta) -> @str {\n+                   link_meta: &LinkMeta)\n+                   -> ~str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -523,23 +524,22 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with 'h' so that it never blends into adjacent digits\n     hash.unshift_char('h');\n-    // tjc: allocation is unfortunate; need to change std::hash\n-    hash.to_managed()\n+    hash\n }\n \n-pub fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> @str {\n+pub fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n     {\n         let type_hashcodes = ccx.type_hashcodes.borrow();\n         match type_hashcodes.get().find(&t) {\n-            Some(&h) => return h,\n+            Some(h) => return h.to_str(),\n             None => {}\n         }\n     }\n \n     let mut type_hashcodes = ccx.type_hashcodes.borrow_mut();\n     let mut symbol_hasher = ccx.symbol_hasher.borrow_mut();\n     let hash = symbol_hash(ccx.tcx, symbol_hasher.get(), t, &ccx.link_meta);\n-    type_hashcodes.get().insert(t, hash);\n+    type_hashcodes.get().insert(t, hash.clone());\n     hash\n }\n \n@@ -963,7 +963,7 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for &(cnum, ref path) in crates.iter() {\n-        let name = sess.cstore.get_crate_data(cnum).name;\n+        let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(format!(\"could not find rlib for: `{}`\", name));\n@@ -1221,7 +1221,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n                 // If we're not doing LTO, then our job is simply to just link\n                 // against the archive.\n                 if sess.lto() {\n-                    let name = sess.cstore.get_crate_data(cnum).name;\n+                    let name = sess.cstore.get_crate_data(cnum).name.clone();\n                     time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n                          (), |()| {\n                         let dst = tmpdir.join(cratepath.filename().unwrap());"}, {"sha": "3fbcd377b8b1cdd9b6203a749d82421680213285", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -42,7 +42,7 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n     // module that we've got.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for (cnum, path) in crates.move_iter() {\n-        let name = sess.cstore.get_crate_data(cnum).name;\n+        let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let path = match path {\n             Some(p) => p,\n             None => {"}, {"sha": "b779c7e73b1c93945af5b432bc576046263b35d0", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -44,6 +44,7 @@ use syntax::codemap;\n use syntax::diagnostic;\n use syntax::ext::base::CrateLoader;\n use syntax::parse;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::print::{pp, pprust};\n use syntax;\n@@ -60,52 +61,56 @@ pub enum PpMode {\n  * The name used for source code that doesn't originate in a file\n  * (e.g. source from stdin or a string)\n  */\n-pub fn anon_src() -> @str { @\"<anon>\" }\n+pub fn anon_src() -> ~str {\n+    \"<anon>\".to_str()\n+}\n \n-pub fn source_name(input: &Input) -> @str {\n+pub fn source_name(input: &Input) -> ~str {\n     match *input {\n       // FIXME (#9639): This needs to handle non-utf8 paths\n-      FileInput(ref ifile) => ifile.as_str().unwrap().to_managed(),\n+      FileInput(ref ifile) => ifile.as_str().unwrap().to_str(),\n       StrInput(_) => anon_src()\n     }\n }\n \n pub fn default_configuration(sess: Session) ->\n    ast::CrateConfig {\n     let tos = match sess.targ_cfg.os {\n-        abi::OsWin32 =>   @\"win32\",\n-        abi::OsMacos =>   @\"macos\",\n-        abi::OsLinux =>   @\"linux\",\n-        abi::OsAndroid => @\"android\",\n-        abi::OsFreebsd => @\"freebsd\"\n+        abi::OsWin32 =>   InternedString::new(\"win32\"),\n+        abi::OsMacos =>   InternedString::new(\"macos\"),\n+        abi::OsLinux =>   InternedString::new(\"linux\"),\n+        abi::OsAndroid => InternedString::new(\"android\"),\n+        abi::OsFreebsd => InternedString::new(\"freebsd\"),\n     };\n \n     // ARM is bi-endian, however using NDK seems to default\n     // to little-endian unless a flag is provided.\n     let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-        abi::X86 =>    (@\"little\", @\"x86\",    @\"32\"),\n-        abi::X86_64 => (@\"little\", @\"x86_64\", @\"64\"),\n-        abi::Arm =>    (@\"little\", @\"arm\",    @\"32\"),\n-        abi::Mips =>   (@\"big\",    @\"mips\",   @\"32\")\n+        abi::X86 =>    (\"little\", \"x86\",    \"32\"),\n+        abi::X86_64 => (\"little\", \"x86_64\", \"64\"),\n+        abi::Arm =>    (\"little\", \"arm\",    \"32\"),\n+        abi::Mips =>   (\"big\",    \"mips\",   \"32\")\n     };\n \n     let fam = match sess.targ_cfg.os {\n-        abi::OsWin32 => @\"windows\",\n-        _ => @\"unix\"\n+        abi::OsWin32 => InternedString::new(\"windows\"),\n+        _ => InternedString::new(\"unix\")\n     };\n \n     let mk = attr::mk_name_value_item_str;\n     return ~[ // Target bindings.\n-         attr::mk_word_item(fam),\n-         mk(@\"target_os\", tos),\n-         mk(@\"target_family\", fam),\n-         mk(@\"target_arch\", arch),\n-         mk(@\"target_endian\", end),\n-         mk(@\"target_word_size\", wordsz),\n+         attr::mk_word_item(fam.clone()),\n+         mk(InternedString::new(\"target_os\"), tos),\n+         mk(InternedString::new(\"target_family\"), fam),\n+         mk(InternedString::new(\"target_arch\"), InternedString::new(arch)),\n+         mk(InternedString::new(\"target_endian\"), InternedString::new(end)),\n+         mk(InternedString::new(\"target_word_size\"),\n+            InternedString::new(wordsz)),\n     ];\n }\n \n-pub fn append_configuration(cfg: &mut ast::CrateConfig, name: @str) {\n+pub fn append_configuration(cfg: &mut ast::CrateConfig,\n+                            name: InternedString) {\n     if !cfg.iter().any(|mi| mi.name() == name) {\n         cfg.push(attr::mk_word_item(name))\n     }\n@@ -118,9 +123,15 @@ pub fn build_configuration(sess: Session) ->\n     let default_cfg = default_configuration(sess);\n     let mut user_cfg = sess.opts.cfg.clone();\n     // If the user wants a test runner, then add the test cfg\n-    if sess.opts.test { append_configuration(&mut user_cfg, @\"test\") }\n+    if sess.opts.test {\n+        append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n+    }\n     // If the user requested GC, then add the GC cfg\n-    append_configuration(&mut user_cfg, if sess.opts.gc { @\"gc\" } else { @\"nogc\" });\n+    append_configuration(&mut user_cfg, if sess.opts.gc {\n+        InternedString::new(\"gc\")\n+    } else {\n+        InternedString::new(\"nogc\")\n+    });\n     return vec::append(user_cfg, default_cfg);\n }\n \n@@ -129,16 +140,15 @@ fn parse_cfgspecs(cfgspecs: ~[~str], demitter: @diagnostic::Emitter)\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n-        parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n+        parse::parse_meta_from_source_str(\"cfgspec\".to_str(), s, ~[], sess)\n     }).collect::<ast::CrateConfig>()\n }\n \n pub enum Input {\n     /// Load source from file\n     FileInput(Path),\n     /// The string is the source\n-    // FIXME (#2319): Don't really want to box the source string\n-    StrInput(@str)\n+    StrInput(~str)\n }\n \n pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &Input)\n@@ -148,9 +158,11 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &Input)\n             FileInput(ref file) => {\n                 parse::parse_crate_from_file(&(*file), cfg.clone(), sess.parse_sess)\n             }\n-            StrInput(src) => {\n-                parse::parse_crate_from_source_str(\n-                    anon_src(), src, cfg.clone(), sess.parse_sess)\n+            StrInput(ref src) => {\n+                parse::parse_crate_from_source_str(anon_src(),\n+                                                   (*src).clone(),\n+                                                   cfg.clone(),\n+                                                   sess.parse_sess)\n             }\n         }\n     })\n@@ -474,13 +486,13 @@ fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames, crate\n \n     // Build a list of files used to compile the output and\n     // write Makefile-compatible dependency rules\n-    let files: ~[@str] = {\n+    let files: ~[~str] = {\n         let files = sess.codemap.files.borrow();\n         files.get()\n              .iter()\n              .filter_map(|fmap| {\n                  if fmap.is_real_file() {\n-                     Some(fmap.name)\n+                     Some(fmap.name.clone())\n                  } else {\n                      None\n                  }\n@@ -615,7 +627,7 @@ pub fn pretty_print_input(sess: Session,\n         _ => @pprust::NoAnn as @pprust::PpAnn,\n     };\n \n-    let src = sess.codemap.get_filemap(source_name(input)).src;\n+    let src = &sess.codemap.get_filemap(source_name(input)).src;\n     let mut rdr = MemReader::new(src.as_bytes().to_owned());\n     let stdout = io::stdout();\n     pprust::print_crate(sess.codemap,\n@@ -1100,17 +1112,17 @@ pub fn build_output_filenames(input: &Input,\n \n           let mut stem = match *input {\n               // FIXME (#9639): This needs to handle non-utf8 paths\n-              FileInput(ref ifile) => (*ifile).filestem_str().unwrap().to_managed(),\n-              StrInput(_) => @\"rust_out\"\n+              FileInput(ref ifile) => {\n+                  (*ifile).filestem_str().unwrap().to_str()\n+              }\n+              StrInput(_) => ~\"rust_out\"\n           };\n \n           // If a crateid is present, we use it as the link name\n           let crateid = attr::find_crateid(attrs);\n           match crateid {\n               None => {}\n-              Some(crateid) => {\n-                  stem = crateid.name.to_managed()\n-              }\n+              Some(crateid) => stem = crateid.name.to_str(),\n           }\n \n           if sess.building_library.get() {\n@@ -1201,7 +1213,7 @@ mod test {\n         let sessopts = build_session_options(~\"rustc\", matches, @diagnostic::DefaultEmitter);\n         let sess = build_session(sessopts, None, @diagnostic::DefaultEmitter);\n         let cfg = build_configuration(sess);\n-        let mut test_items = cfg.iter().filter(|m| \"test\" == m.name());\n+        let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());\n     }"}, {"sha": "cebc25c4845d4ba8d9ac17466d8cb6ee9a09c7a9", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -352,9 +352,11 @@ impl Session_ {\n         self.debugging_opt(NO_LANDING_PADS)\n     }\n \n-    // pointless function, now...\n-    pub fn str_of(&self, id: ast::Ident) -> @str {\n-        token::ident_to_str(&id)\n+    // DEPRECATED. This function results in a lot of allocations when they\n+    // are not necessary.\n+    pub fn str_of(&self, id: ast::Ident) -> ~str {\n+        let string = token::get_ident(id.name);\n+        string.get().to_str()\n     }\n \n     // pointless function, now...\n@@ -417,7 +419,12 @@ pub fn building_library(options: &Options, crate: &ast::Crate) -> bool {\n         }\n     }\n     match syntax::attr::first_attr_value_str_by_name(crate.attrs, \"crate_type\") {\n-        Some(s) => \"lib\" == s || \"rlib\" == s || \"dylib\" == s || \"staticlib\" == s,\n+        Some(s) => {\n+            s.equiv(&(\"lib\")) ||\n+            s.equiv(&(\"rlib\")) ||\n+            s.equiv(&(\"dylib\")) ||\n+            s.equiv(&(\"staticlib\"))\n+        }\n         _ => false\n     }\n }\n@@ -435,16 +442,22 @@ pub fn collect_outputs(session: &Session,\n     }\n     let mut base = session.opts.outputs.clone();\n     let mut iter = attrs.iter().filter_map(|a| {\n-        if \"crate_type\" == a.name() {\n+        if a.name().equiv(&(\"crate_type\")) {\n             match a.value_str() {\n-                Some(n) if \"rlib\" == n => Some(OutputRlib),\n-                Some(n) if \"dylib\" == n => Some(OutputDylib),\n-                Some(n) if \"lib\" == n => Some(default_lib_output()),\n-                Some(n) if \"staticlib\" == n => Some(OutputStaticlib),\n-                Some(n) if \"bin\" == n => Some(OutputExecutable),\n+                Some(ref n) if n.equiv(&(\"rlib\")) => Some(OutputRlib),\n+                Some(ref n) if n.equiv(&(\"dylib\")) => Some(OutputDylib),\n+                Some(ref n) if n.equiv(&(\"lib\")) => {\n+                    Some(default_lib_output())\n+                }\n+                Some(ref n) if n.equiv(&(\"staticlib\")) => {\n+                    Some(OutputStaticlib)\n+                }\n+                Some(ref n) if n.equiv(&(\"bin\")) => Some(OutputExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n-                                     a.span, ~\"invalid `crate_type` value\");\n+                    session.add_lint(lint::UnknownCrateType,\n+                                     ast::CRATE_NODE_ID,\n+                                     a.span,\n+                                     ~\"invalid `crate_type` value\");\n                     None\n                 }\n                 _ => {"}, {"sha": "ed4455c2f89a10fe95cda7b5bf522081742341fd", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -98,7 +98,8 @@ impl Context {\n \n impl Visitor<()> for Context {\n     fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n-        let s = token::ident_to_str(&id);\n+        let string = token::get_ident(id.name);\n+        let s = string.get();\n \n         if !s.is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n@@ -122,7 +123,7 @@ impl Visitor<()> for Context {\n             }\n             ast::ViewItemExternMod(..) => {\n                 for attr in i.attrs.iter() {\n-                    if \"phase\" == attr.name() {\n+                    if attr.name().get() == \"phase\"{\n                         self.gate_feature(\"phase\", attr.span,\n                                           \"compile time crate loading is \\\n                                            experimental and possibly buggy\");\n@@ -135,7 +136,7 @@ impl Visitor<()> for Context {\n \n     fn visit_item(&mut self, i: &ast::Item, _:()) {\n         for attr in i.attrs.iter() {\n-            if \"thread_local\" == attr.name() {\n+            if attr.name().equiv(&(\"thread_local\")) {\n                 self.gate_feature(\"thread_local\", i.span,\n                                   \"`#[thread_local]` is an experimental feature, and does not \\\n                                   currently handle destructors. There is no corresponding \\\n@@ -227,8 +228,7 @@ impl Visitor<()> for Context {\n \n     fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         match e.node {\n-            ast::ExprUnary(_, ast::UnBox, _) |\n-            ast::ExprVstore(_, ast::ExprVstoreBox) => {\n+            ast::ExprUnary(_, ast::UnBox, _) => {\n                 self.gate_box(e.span);\n             }\n             _ => {}\n@@ -258,7 +258,9 @@ pub fn check_crate(sess: Session, crate: &ast::Crate) {\n     };\n \n     for attr in crate.attrs.iter() {\n-        if \"feature\" != attr.name() { continue }\n+        if !attr.name().equiv(&(\"feature\")) {\n+            continue\n+        }\n \n         match attr.meta_item_list() {\n             None => {\n@@ -268,14 +270,16 @@ pub fn check_crate(sess: Session, crate: &ast::Crate) {\n             Some(list) => {\n                 for &mi in list.iter() {\n                     let name = match mi.node {\n-                        ast::MetaWord(word) => word,\n+                        ast::MetaWord(ref word) => (*word).clone(),\n                         _ => {\n-                            sess.span_err(mi.span, \"malformed feature, expected \\\n-                                                    just one word\");\n+                            sess.span_err(mi.span,\n+                                          \"malformed feature, expected just \\\n+                                           one word\");\n                             continue\n                         }\n                     };\n-                    match KNOWN_FEATURES.iter().find(|& &(n, _)| n == name) {\n+                    match KNOWN_FEATURES.iter()\n+                                        .find(|& &(n, _)| name.equiv(&n)) {\n                         Some(&(name, Active)) => { cx.features.push(name); }\n                         Some(&(_, Removed)) => {\n                             sess.span_err(mi.span, \"feature has been removed\");"}, {"sha": "4eb36b0f3fbd128b0978303f8fe38a17d9bb1395", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -19,6 +19,8 @@ use syntax::codemap;\n use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::util::small_vector::SmallVector;\n \n pub static VERSION: &'static str = \"0.10-pre\";\n@@ -56,11 +58,13 @@ struct StandardLibraryInjector {\n     sess: Session,\n }\n \n-pub fn with_version(crate: &str) -> Option<(@str, ast::StrStyle)> {\n+pub fn with_version(crate: &str) -> Option<(InternedString, ast::StrStyle)> {\n     match option_env!(\"CFG_DISABLE_INJECT_STD_VERSION\") {\n         Some(\"1\") => None,\n         _ => {\n-            Some((format!(\"{}\\\\#{}\", crate, VERSION).to_managed(),\n+            Some((token::intern_and_get_ident(format!(\"{}\\\\#{}\",\n+                                                      crate,\n+                                                      VERSION)),\n                   ast::CookedStr))\n         }\n     }\n@@ -73,9 +77,12 @@ impl fold::Folder for StandardLibraryInjector {\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n             attrs: ~[\n-                attr::mk_attr(attr::mk_list_item(@\"phase\",\n-                                                 ~[attr::mk_word_item(@\"syntax\"),\n-                                                   attr::mk_word_item(@\"link\")]))\n+                attr::mk_attr(attr::mk_list_item(\n+                        InternedString::new(\"phase\"),\n+                        ~[\n+                            attr::mk_word_item(InternedString::new(\"syntax\")),\n+                            attr::mk_word_item(InternedString::new(\"link\")\n+                        )]))\n             ],\n             vis: ast::Inherited,\n             span: DUMMY_SP"}, {"sha": "2704e828ea4632f5b6e67708d1b7dbd3da76756d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -27,6 +27,8 @@ use syntax::ext::base::ExtCtxt;\n use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::util::small_vector::SmallVector;\n@@ -132,7 +134,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             if !cx.sess.building_library.get() {\n                 @ast::Item {\n                     attrs: item.attrs.iter().filter_map(|attr| {\n-                        if \"main\" != attr.name() {\n+                        if !attr.name().equiv(&(\"main\")) {\n                             Some(*attr)\n                         } else {\n                             None\n@@ -169,7 +171,7 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n     cx.ext_cx.bt_push(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            name: @\"test\",\n+            name: ~\"test\",\n             format: MacroAttribute,\n             span: None\n         }\n@@ -248,7 +250,7 @@ fn is_bench_fn(i: @ast::Item) -> bool {\n fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n-        \"ignore\" == attr.name() && match attr.meta_item_list() {\n+        attr.name().equiv(&(\"ignore\")) && match attr.meta_item_list() {\n             Some(ref cfgs) => attr::test_cfg(cx.config, cfgs.iter().map(|x| *x)),\n             None => true\n         }\n@@ -330,8 +332,9 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     let item_ = ast::ItemMod(testmod);\n \n     // This attribute tells resolve to let us call unexported functions\n+    let resolve_unexported_str = InternedString::new(\"!resolve_unexported\");\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(resolve_unexported_str));\n \n     let item = ast::Item {\n         ident: cx.sess.ident_of(\"__test\"),\n@@ -424,7 +427,8 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     debug!(\"encoding {}\", ast_util::path_name_i(path));\n \n     let name_lit: ast::Lit =\n-        nospan(ast::LitStr(ast_util::path_name_i(path).to_managed(), ast::CookedStr));\n+        nospan(ast::LitStr(token::intern_and_get_ident(\n+                    ast_util::path_name_i(path)), ast::CookedStr));\n \n     let name_expr = @ast::Expr {\n           id: ast::DUMMY_NODE_ID,"}, {"sha": "7ba96516bf91b14cc3b42b816ac63ee60da6326c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -235,9 +235,10 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       0u => d::early_error(demitter, \"no input filename given\"),\n       1u => {\n         let ifile = matches.free[0].as_slice();\n-        if \"-\" == ifile {\n-            let src = str::from_utf8_owned(io::stdin().read_to_end()).unwrap();\n-            (d::StrInput(src.to_managed()), None)\n+        if ifile == \"-\" {\n+            let src =\n+                str::from_utf8_owned(io::stdin().read_to_end()).unwrap();\n+            (d::StrInput(src), None)\n         } else {\n             (d::FileInput(Path::new(ifile)), Some(Path::new(ifile)))\n         }\n@@ -319,9 +320,11 @@ fn parse_crate_attrs(sess: session::Session,\n         d::FileInput(ref ifile) => {\n             parse::parse_crate_attrs_from_file(ifile, ~[], sess.parse_sess)\n         }\n-        d::StrInput(src) => {\n-            parse::parse_crate_attrs_from_source_str(\n-                d::anon_src(), src, ~[], sess.parse_sess)\n+        d::StrInput(ref src) => {\n+            parse::parse_crate_attrs_from_source_str(d::anon_src(),\n+                                                     (*src).clone(),\n+                                                     ~[],\n+                                                     sess.parse_sess)\n         }\n     }\n }"}, {"sha": "85a6677d18866a3781ed79f65eb504cbdef7d366", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -212,5 +212,5 @@ pub static tag_macro_def: uint = 0x112;\n #[deriving(Clone)]\n pub struct LinkMeta {\n     crateid: CrateId,\n-    crate_hash: @str,\n+    crate_hash: ~str,\n }"}, {"sha": "9c2c5a5745848e8bae7c5a98530150defda9fdc8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -27,8 +27,8 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::diagnostic::SpanHandler;\n use syntax::ext::base::{CrateLoader, MacroCrate};\n+use syntax::parse::token::{IdentInterner, InternedString};\n use syntax::parse::token;\n-use syntax::parse::token::IdentInterner;\n use syntax::crateid::CrateId;\n use syntax::visit;\n \n@@ -76,7 +76,7 @@ impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n struct cache_entry {\n     cnum: ast::CrateNum,\n     span: Span,\n-    hash: @str,\n+    hash: ~str,\n     crateid: CrateId,\n }\n \n@@ -124,19 +124,17 @@ struct Env {\n fn visit_crate(e: &Env, c: &ast::Crate) {\n     let cstore = e.sess.cstore;\n \n-    for a in c.attrs.iter().filter(|m| \"link_args\" == m.name()) {\n+    for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n         match a.value_str() {\n-          Some(ref linkarg) => {\n-            cstore.add_used_link_args(*linkarg);\n-          }\n-          None => {/* fallthrough */ }\n+          Some(ref linkarg) => cstore.add_used_link_args(linkarg.get()),\n+          None => { /* fallthrough */ }\n         }\n     }\n }\n \n fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n     let should_load = i.attrs.iter().all(|attr| {\n-        \"phase\" != attr.name() ||\n+        attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n                 attr::contains_name(phases, \"link\")\n             })\n@@ -148,45 +146,49 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n     match extract_crate_info(i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e, info.ident, info.name, info.version,\n-                                     @\"\", i.span);\n+            let cnum = resolve_crate(e,\n+                                     info.ident.clone(),\n+                                     info.name.clone(),\n+                                     info.version.clone(),\n+                                     ~\"\",\n+                                     i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n         None => ()\n     }\n }\n \n struct CrateInfo {\n-    ident: @str,\n-    name: @str,\n-    version: @str,\n+    ident: ~str,\n+    name: ~str,\n+    version: ~str,\n     id: ast::NodeId,\n }\n \n fn extract_crate_info(i: &ast::ViewItem) -> Option<CrateInfo> {\n     match i.node {\n-        ast::ViewItemExternMod(ident, path_opt, id) => {\n-            let ident = token::ident_to_str(&ident);\n+        ast::ViewItemExternMod(ref ident, ref path_opt, id) => {\n+            let ident = token::get_ident(ident.name);\n             debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n-                   ident, path_opt);\n-            let (name, version) = match path_opt {\n-                Some((path_str, _)) => {\n-                    let crateid: Option<CrateId> = from_str(path_str);\n+                   ident.get(), path_opt);\n+            let (name, version) = match *path_opt {\n+                Some((ref path_str, _)) => {\n+                    let crateid: Option<CrateId> = from_str(path_str.get());\n                     match crateid {\n-                        None => (@\"\", @\"\"),\n+                        None => (~\"\", ~\"\"),\n                         Some(crateid) => {\n                             let version = match crateid.version {\n-                                None => @\"\",\n-                                Some(ref ver) => ver.to_managed(),\n+                                None => ~\"\",\n+                                Some(ref ver) => ver.to_str(),\n                             };\n-                            (crateid.name.to_managed(), version)\n+                            (crateid.name.to_str(), version)\n                         }\n                     }\n                 }\n-                None => (ident, @\"\"),\n+                None => (ident.get().to_str(), ~\"\"),\n             };\n             Some(CrateInfo {\n-                  ident: ident,\n+                  ident: ident.get().to_str(),\n                   name: name,\n                   version: version,\n                   id: id,\n@@ -206,36 +208,42 @@ fn visit_item(e: &Env, i: &ast::Item) {\n             // First, add all of the custom link_args attributes\n             let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n-                .filter_map(|at| if \"link_args\" == at.name() {Some(at)} else {None})\n+                .filter_map(|at| if at.name().equiv(&(\"link_args\")) {\n+                    Some(at)\n+                } else {\n+                    None\n+                })\n                 .to_owned_vec();\n             for m in link_args.iter() {\n                 match m.value_str() {\n-                    Some(linkarg) => {\n-                        cstore.add_used_link_args(linkarg);\n-                    }\n+                    Some(linkarg) => cstore.add_used_link_args(linkarg.get()),\n                     None => { /* fallthrough */ }\n                 }\n             }\n \n             // Next, process all of the #[link(..)]-style arguments\n             let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n-                .filter_map(|at| if \"link\" == at.name() {Some(at)} else {None})\n+                .filter_map(|at| if at.name().equiv(&(\"link\")) {\n+                    Some(at)\n+                } else {\n+                    None\n+                })\n                 .to_owned_vec();\n             for m in link_args.iter() {\n                 match m.meta_item_list() {\n                     Some(items) => {\n                         let kind = items.iter().find(|k| {\n-                            \"kind\" == k.name()\n+                            k.name().equiv(&(\"kind\"))\n                         }).and_then(|a| a.value_str());\n                         let kind = match kind {\n                             Some(k) => {\n-                                if \"static\" == k {\n+                                if k.equiv(&(\"static\")) {\n                                     cstore::NativeStatic\n                                 } else if e.sess.targ_cfg.os == abi::OsMacos &&\n-                                          \"framework\" == k {\n+                                          k.equiv(&(\"framework\")) {\n                                     cstore::NativeFramework\n-                                } else if \"framework\" == k {\n+                                } else if k.equiv(&(\"framework\")) {\n                                     e.sess.span_err(m.span,\n                                         \"native frameworks are only available \\\n                                          on OSX targets\");\n@@ -249,21 +257,21 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             None => cstore::NativeUnknown\n                         };\n                         let n = items.iter().find(|n| {\n-                            \"name\" == n.name()\n+                            n.name().equiv(&(\"name\"))\n                         }).and_then(|a| a.value_str());\n                         let n = match n {\n                             Some(n) => n,\n                             None => {\n                                 e.sess.span_err(m.span,\n                                     \"#[link(...)] specified without \\\n                                      `name = \\\"foo\\\"`\");\n-                                @\"foo\"\n+                                InternedString::new(\"foo\")\n                             }\n                         };\n-                        if n.is_empty() {\n+                        if n.get().is_empty() {\n                             e.sess.span_err(m.span, \"#[link(name = \\\"\\\")] given with empty name\");\n                         } else {\n-                            cstore.add_used_library(n.to_owned(), kind);\n+                            cstore.add_used_library(n.get().to_owned(), kind);\n                         }\n                     }\n                     None => {}\n@@ -274,14 +282,14 @@ fn visit_item(e: &Env, i: &ast::Item) {\n     }\n }\n \n-fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast::CrateNum> {\n+fn existing_match(e: &Env, name: ~str, version: ~str, hash: &str) -> Option<ast::CrateNum> {\n     let crate_cache = e.crate_cache.borrow();\n     for c in crate_cache.get().iter() {\n         let crateid_version = match c.crateid.version {\n-            None => @\"0.0\",\n-            Some(ref ver) => ver.to_managed(),\n+            None => ~\"0.0\",\n+            Some(ref ver) => ver.to_str(),\n         };\n-        if (name.is_empty() || c.crateid.name.to_managed() == name) &&\n+        if (name.is_empty() || c.crateid.name == name) &&\n             (version.is_empty() || crateid_version == version) &&\n             (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n@@ -291,19 +299,19 @@ fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast:\n }\n \n fn resolve_crate(e: &mut Env,\n-                 ident: @str,\n-                 name: @str,\n-                 version: @str,\n-                 hash: @str,\n+                 ident: ~str,\n+                 name: ~str,\n+                 version: ~str,\n+                 hash: ~str,\n                  span: Span)\n               -> ast::CrateNum {\n-    match existing_match(e, name, version, hash) {\n+    match existing_match(e, name.clone(), version.clone(), hash.clone()) {\n       None => {\n         let load_ctxt = loader::Context {\n             sess: e.sess,\n             span: span,\n             ident: ident,\n-            name: name,\n+            name: name.clone(),\n             version: version,\n             hash: hash,\n             os: e.os,\n@@ -364,10 +372,13 @@ fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n     let r = decoder::get_crate_deps(cdata);\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n-        let cname_str = token::ident_to_str(&dep.name);\n+        let cname_str = token::get_ident(dep.name.name);\n         debug!(\"resolving dep crate {} ver: {} hash: {}\",\n                cname_str, dep.vers, dep.hash);\n-        match existing_match(e, cname_str, dep.vers, dep.hash) {\n+        match existing_match(e,\n+                             cname_str.get().to_str(),\n+                             dep.vers.clone(),\n+                             dep.hash.clone()) {\n           Some(local_cnum) => {\n             debug!(\"already have it\");\n             // We've already seen this crate\n@@ -379,8 +390,12 @@ fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = DUMMY_SP;\n-            let local_cnum = resolve_crate(e, cname_str, cname_str, dep.vers,\n-                                           dep.hash, fake_span);\n+            let local_cnum = resolve_crate(e,\n+                                           cname_str.get().to_str(),\n+                                           cname_str.get().to_str(),\n+                                           dep.vers.clone(),\n+                                           dep.hash.clone(),\n+                                           fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }\n@@ -411,8 +426,12 @@ impl Loader {\n impl CrateLoader for Loader {\n     fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(crate).unwrap();\n-        let cnum = resolve_crate(&mut self.env, info.ident, info.name,\n-                                 info.version, @\"\", crate.span);\n+        let cnum = resolve_crate(&mut self.env,\n+                                 info.ident.clone(),\n+                                 info.name.clone(),\n+                                 info.version.clone(),\n+                                 ~\"\",\n+                                 crate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {\n             lib: library.dylib,"}, {"sha": "1a65b326bbdea51b09f52f88dc1cb3f6e706dc24", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -18,6 +18,7 @@ use middle::ty;\n use middle::typeck;\n \n use std::vec;\n+use std::rc::Rc;\n use reader = extra::ebml::reader;\n use syntax::ast;\n use syntax::ast_map;\n@@ -221,8 +222,8 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                  class_id, def) );\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: @~[],\n-                                region_param_defs: @[]},\n+        generics: ty::Generics {type_param_defs: Rc::new(~[]),\n+                                region_param_defs: Rc::new(~[])},\n         ty: ty\n     }\n }"}, {"sha": "33625000e4ad0876a52e6348bfb3bcc08a34f399", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -32,7 +32,7 @@ pub enum MetadataBlob {\n }\n \n pub struct crate_metadata {\n-    name: @str,\n+    name: ~str,\n     data: MetadataBlob,\n     cnum_map: cnum_map,\n     cnum: ast::CrateNum\n@@ -89,12 +89,12 @@ impl CStore {\n         *metas.get().get(&cnum)\n     }\n \n-    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> @str {\n+    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> ~str {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn get_crate_vers(&self, cnum: ast::CrateNum) -> @str {\n+    pub fn get_crate_vers(&self, cnum: ast::CrateNum) -> ~str {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_vers(cdata.data())\n     }\n@@ -192,7 +192,7 @@ impl CStore {\n \n     // returns hashes of crates directly used by this crate. Hashes are sorted by\n     // (crate name, crate version, crate hash) in lexicographic order (not semver)\n-    pub fn get_dep_hashes(&self) -> ~[@str] {\n+    pub fn get_dep_hashes(&self) -> ~[~str] {\n         let mut result = ~[];\n \n         let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n@@ -202,7 +202,7 @@ impl CStore {\n             let vers = decoder::get_crate_vers(cdata.data());\n             debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n             result.push(crate_hash {\n-                name: cdata.name,\n+                name: cdata.name.clone(),\n                 vers: vers,\n                 hash: hash\n             });\n@@ -215,15 +215,15 @@ impl CStore {\n             debug!(\"  hash[{}]: {}\", x.name, x.hash);\n         }\n \n-        result.map(|ch| ch.hash)\n+        result.move_iter().map(|crate_hash { hash, ..}| hash).collect()\n     }\n }\n \n #[deriving(Clone, TotalEq, TotalOrd)]\n struct crate_hash {\n-    name: @str,\n-    vers: @str,\n-    hash: @str,\n+    name: ~str,\n+    vers: ~str,\n+    hash: ~str,\n }\n \n impl crate_metadata {"}, {"sha": "deae31abdcb5e7456a4ad2640503946b47c692e7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -25,11 +25,11 @@ use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n-use std::at_vec;\n use std::u64;\n use std::io;\n use std::io::extensions::u64_from_be_bytes;\n use std::option;\n+use std::rc::Rc;\n use std::vec;\n use extra::ebml::reader;\n use extra::ebml;\n@@ -246,7 +246,7 @@ fn item_ty_param_defs(item: ebml::Doc,\n                       tcx: ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n-                      -> @~[ty::TypeParameterDef] {\n+                      -> Rc<~[ty::TypeParameterDef]> {\n     let mut bounds = ~[];\n     reader::tagged_docs(item, tag, |p| {\n         let bd = parse_type_param_def_data(\n@@ -255,27 +255,27 @@ fn item_ty_param_defs(item: ebml::Doc,\n         bounds.push(bd);\n         true\n     });\n-    @bounds\n+    Rc::new(bounds)\n }\n \n fn item_region_param_defs(item_doc: ebml::Doc,\n                           tcx: ty::ctxt,\n                           cdata: Cmd)\n-                          -> @[ty::RegionParameterDef] {\n-    at_vec::build(None, |push| {\n-        reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n+                          -> Rc<~[ty::RegionParameterDef]> {\n+    let mut v = ~[];\n+    reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n             let ident_str_doc = reader::get_doc(rp_doc,\n                                                 tag_region_param_def_ident);\n             let ident = item_name(tcx.sess.intr(), ident_str_doc);\n             let def_id_doc = reader::get_doc(rp_doc,\n                                              tag_region_param_def_def_id);\n             let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n             let def_id = translate_def_id(cdata, def_id);\n-            push(ty::RegionParameterDef { ident: ident,\n-                                          def_id: def_id });\n+            v.push(ty::RegionParameterDef { ident: ident,\n+                                            def_id: def_id });\n             true\n         });\n-    })\n+    Rc::new(v)\n }\n \n fn item_ty_param_count(item: ebml::Doc) -> uint {\n@@ -1059,23 +1059,23 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     let mut items: ~[@ast::MetaItem] = ~[];\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = nd.as_str_slice().to_managed();\n+        let n = token::intern_and_get_ident(nd.as_str_slice());\n         items.push(attr::mk_word_item(n));\n         true\n     });\n     reader::tagged_docs(md, tag_meta_item_name_value, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = nd.as_str_slice().to_managed();\n-        let v = vd.as_str_slice().to_managed();\n+        let n = token::intern_and_get_ident(nd.as_str_slice());\n+        let v = token::intern_and_get_ident(vd.as_str_slice());\n         // FIXME (#623): Should be able to decode MetaNameValue variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n         true\n     });\n     reader::tagged_docs(md, tag_meta_item_list, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = nd.as_str_slice().to_managed();\n+        let n = token::intern_and_get_ident(nd.as_str_slice());\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n         true\n@@ -1130,18 +1130,18 @@ pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n pub struct CrateDep {\n     cnum: ast::CrateNum,\n     name: ast::Ident,\n-    vers: @str,\n-    hash: @str\n+    vers: ~str,\n+    hash: ~str\n }\n \n pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n     let mut deps: ~[CrateDep] = ~[];\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> @str {\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n         let d = reader::get_doc(doc, tag_);\n-        d.as_str_slice().to_managed()\n+        d.as_str_slice().to_str()\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         deps.push(CrateDep {cnum: crate_num,\n@@ -1159,24 +1159,29 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) {\n \n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n-        write!(out, \"{} {}-{}-{}\\n\",\n-                 dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers);\n+        let string = token::get_ident(dep.name.name);\n+        write!(out,\n+               \"{} {}-{}-{}\\n\",\n+               dep.cnum,\n+               string.get(),\n+               dep.hash,\n+               dep.vers);\n     }\n \n     write!(out, \"\\n\");\n }\n \n-pub fn get_crate_hash(data: &[u8]) -> @str {\n+pub fn get_crate_hash(data: &[u8]) -> ~str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    hashdoc.as_str_slice().to_managed()\n+    hashdoc.as_str_slice().to_str()\n }\n \n-pub fn get_crate_vers(data: &[u8]) -> @str {\n+pub fn get_crate_vers(data: &[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     match attr::find_crateid(attrs) {\n-        None => @\"0.0\",\n-        Some(crateid) => crateid.version_or_default().to_managed(),\n+        None => ~\"0.0\",\n+        Some(crateid) => crateid.version_or_default().to_str(),\n     }\n }\n "}, {"sha": "6a1c3dd4b62e032fa97f5975a3538203c2cce893", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -21,29 +21,28 @@ use middle::ty;\n use middle::typeck;\n use middle;\n \n+use extra::serialize::Encodable;\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap, HashSet};\n use std::io::MemWriter;\n use std::str;\n use std::vec;\n-\n-use extra::serialize::Encodable;\n-\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::*;\n-use syntax::attr;\n+use syntax::ast_util;\n use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n use syntax::codemap;\n use syntax::diagnostic::SpanHandler;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n-use syntax::ast_util;\n+use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n-use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n@@ -172,7 +171,7 @@ pub fn def_to_str(did: DefId) -> ~str {\n \n fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n                              ecx: &EncodeContext,\n-                             params: @~[ty::TypeParameterDef],\n+                             params: &[ty::TypeParameterDef],\n                              tag: uint) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -189,7 +188,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n \n fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n                             ecx: &EncodeContext,\n-                            params: @[ty::RegionParameterDef]) {\n+                            params: &[ty::RegionParameterDef]) {\n     for param in params.iter() {\n         ebml_w.start_tag(tag_region_param_def);\n \n@@ -216,9 +215,9 @@ fn encode_item_variances(ebml_w: &mut writer::Encoder,\n fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n                           ecx: &EncodeContext,\n                           tpt: &ty::ty_param_bounds_and_ty) {\n-    encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs,\n+    encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs(),\n                               tag_items_data_item_ty_param_bounds);\n-    encode_region_param_defs(ebml_w, ecx, tpt.generics.region_param_defs);\n+    encode_region_param_defs(ebml_w, ecx, tpt.generics.region_param_defs());\n     encode_type(ecx, ebml_w, tpt.ty);\n }\n \n@@ -491,7 +490,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     exp: &middle::resolve::Export2) {\n     match ecx.tcx.items.find(exp.def_id.node) {\n         Some(ast_map::NodeItem(item, path)) => {\n-            let original_name = ecx.tcx.sess.str_of(item.ident);\n+            let original_name = token::get_ident(item.ident.name);\n \n             //\n             // We don't need to reexport static methods on items\n@@ -503,7 +502,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             // encoded metadata for static methods relative to Bar,\n             // but not yet for Foo.\n             //\n-            if mod_path != *path || exp.name != original_name {\n+            if mod_path != *path || original_name.get() != exp.name {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n                         debug!(\"(encode reexported static methods) {} \\\n@@ -793,7 +792,7 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_def_id(ebml_w, method_ty.def_id);\n     encode_name(ecx, ebml_w, method_ty.ident);\n     encode_ty_type_param_defs(ebml_w, ecx,\n-                              method_ty.generics.type_param_defs,\n+                              method_ty.generics.type_param_defs(),\n                               tag_item_method_tps);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n@@ -834,7 +833,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n-        let num_params = tpt.generics.type_param_defs.len();\n+        let num_params = tpt.generics.type_param_defs().len();\n         if num_params > 0u || is_default_impl\n             || should_inline(ast_method.attrs) {\n             (ecx.encode_inlined_item)(\n@@ -1178,10 +1177,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(ebml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_ty_type_param_defs(ebml_w, ecx,\n-                                  trait_def.generics.type_param_defs,\n+                                  trait_def.generics.type_param_defs(),\n                                   tag_items_data_item_ty_param_bounds);\n         encode_region_param_defs(ebml_w, ecx,\n-                                 trait_def.generics.region_param_defs);\n+                                 trait_def.generics.region_param_defs());\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -1357,11 +1356,10 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n                          index: @RefCell<~[entry<i64>]>) {\n     match items.get(ni.id) {\n         ast_map::NodeForeignItem(_, abi, _, pt) => {\n+            let string = token::get_ident(ni.ident.name);\n             debug!(\"writing foreign item {}::{}\",\n-                   ast_map::path_to_str(\n-                       *pt,\n-                       token::get_ident_interner()),\n-                   token::ident_to_str(&ni.ident));\n+                   ast_map::path_to_str(*pt, token::get_ident_interner()),\n+                   string.get());\n \n             let mut ebml_w = unsafe {\n                 ebml_w.unsafe_clone()\n@@ -1513,32 +1511,32 @@ fn write_i64(writer: &mut MemWriter, &n: &i64) {\n \n fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n     match mi.node {\n-      MetaWord(name) => {\n+      MetaWord(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.as_bytes());\n+        ebml_w.writer.write(name.get().as_bytes());\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n-      MetaNameValue(name, value) => {\n+      MetaNameValue(ref name, ref value) => {\n         match value.node {\n-          LitStr(value, _) => {\n+          LitStr(ref value, _) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(name.as_bytes());\n+            ebml_w.writer.write(name.get().as_bytes());\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(value.as_bytes());\n+            ebml_w.writer.write(value.get().as_bytes());\n             ebml_w.end_tag();\n             ebml_w.end_tag();\n           }\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      MetaList(name, ref items) => {\n+      MetaList(ref name, ref items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.as_bytes());\n+        ebml_w.writer.write(name.get().as_bytes());\n         ebml_w.end_tag();\n         for inner_item in items.iter() {\n             encode_meta_item(ebml_w, *inner_item);\n@@ -1569,13 +1567,13 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n         attr::mk_attr(\n             attr::mk_name_value_item_str(\n-                @\"crate_id\",\n-                ecx.link_meta.crateid.to_str().to_managed()))\n+                InternedString::new(\"crate_id\"),\n+                token::intern_and_get_ident(ecx.link_meta.crateid.to_str())))\n     }\n \n     let mut attrs = ~[];\n     for attr in crate.attrs.iter() {\n-        if \"crate_id\" != attr.name()  {\n+        if !attr.name().equiv(&(\"crate_id\")) {\n             attrs.push(*attr);\n         }\n     }\n@@ -1621,7 +1619,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(ecx, cstore);\n     for dep in r.iter() {\n-        encode_crate_dep(ecx, ebml_w, *dep);\n+        encode_crate_dep(ecx, ebml_w, (*dep).clone());\n     }\n     ebml_w.end_tag();\n }"}, {"sha": "8e557560b95f1f83403b1481041805018a575cac", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -46,10 +46,10 @@ pub enum Os {\n pub struct Context {\n     sess: Session,\n     span: Span,\n-    ident: @str,\n-    name: @str,\n-    version: @str,\n-    hash: @str,\n+    ident: ~str,\n+    name: ~str,\n+    version: ~str,\n+    hash: ~str,\n     os: Os,\n     intr: @IdentInterner\n }\n@@ -80,7 +80,7 @@ impl Context {\n \n     fn find_library_crate(&self) -> Option<Library> {\n         let filesearch = self.sess.filesearch;\n-        let crate_name = self.name;\n+        let crate_name = self.name.clone();\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n@@ -109,8 +109,10 @@ impl Context {\n                     } else if candidate {\n                         match get_metadata_section(self.os, path) {\n                             Some(cvec) =>\n-                                if crate_matches(cvec.as_slice(), self.name,\n-                                                 self.version, self.hash) {\n+                                if crate_matches(cvec.as_slice(),\n+                                                 self.name.clone(),\n+                                                 self.version.clone(),\n+                                                 self.hash.clone()) {\n                                     debug!(\"found {} with matching crate_id\",\n                                            path.display());\n                                     let (rlib, dylib) = if file.ends_with(\".rlib\") {\n@@ -235,9 +237,9 @@ pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n }\n \n fn crate_matches(crate_data: &[u8],\n-                 name: @str,\n-                 version: @str,\n-                 hash: @str) -> bool {\n+                 name: ~str,\n+                 version: ~str,\n+                 hash: ~str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     match attr::find_crateid(attrs) {\n         None => false,\n@@ -246,8 +248,9 @@ fn crate_matches(crate_data: &[u8],\n                 let chash = decoder::get_crate_hash(crate_data);\n                 if chash != hash { return false; }\n             }\n-            name == crateid.name.to_managed() &&\n-                (version.is_empty() || version == crateid.version_or_default().to_managed())\n+            name == crateid.name &&\n+                (version.is_empty() ||\n+                 crateid.version_or_default() == version)\n         }\n     }\n }"}, {"sha": "92af631c2bd3e71a034bc9fcc3feaa63990feccc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -156,7 +156,6 @@ fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::vstore {\n \n     match next(st) {\n       '~' => ty::vstore_uniq,\n-      '@' => ty::vstore_box,\n       '&' => ty::vstore_slice(parse_region(st, conv)),\n       c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n     }"}, {"sha": "d17a45165432c089b06d939c7059be6e173a670b", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -45,7 +45,7 @@ pub struct ctxt {\n pub struct ty_abbrev {\n     pos: uint,\n     len: uint,\n-    s: @str\n+    s: ~str\n }\n \n pub enum abbrev_ctxt {\n@@ -65,19 +65,21 @@ pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n               let short_names_cache = cx.tcx.short_names_cache.borrow();\n               result_str_opt = short_names_cache.get()\n                                                 .find(&t)\n-                                                .map(|result| *result);\n+                                                .map(|result| {\n+                                                    (*result).clone()\n+                                                });\n           }\n           let result_str = match result_str_opt {\n             Some(s) => s,\n             None => {\n                 let wr = &mut MemWriter::new();\n                 enc_sty(wr, cx, &ty::get(t).sty);\n-                let s = str::from_utf8(wr.get_ref()).unwrap().to_managed();\n+                let s = str::from_utf8(wr.get_ref()).unwrap();\n                 let mut short_names_cache = cx.tcx\n                                               .short_names_cache\n                                               .borrow_mut();\n-                short_names_cache.get().insert(t, s);\n-                s\n+                short_names_cache.get().insert(t, s.to_str());\n+                s.to_str()\n             }\n           };\n           w.write(result_str.as_bytes());\n@@ -103,7 +105,7 @@ pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n           let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n           if abbrev_len < len {\n               // I.e. it's actually an abbreviation.\n-              let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len).to_managed();\n+              let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len);\n               let a = ty_abbrev { pos: pos as uint,\n                                   len: len as uint,\n                                   s: s };\n@@ -217,7 +219,6 @@ pub fn enc_vstore(w: &mut MemWriter, cx: @ctxt, v: ty::vstore) {\n     match v {\n         ty::vstore_fixed(u) => mywrite!(w, \"{}|\", u),\n         ty::vstore_uniq => mywrite!(w, \"~\"),\n-        ty::vstore_box => mywrite!(w, \"@\"),\n         ty::vstore_slice(r) => {\n             mywrite!(w, \"&\");\n             enc_region(w, cx, r);"}, {"sha": "29ea3475d3441bc42758d574dbdb541ed0158654", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -32,10 +32,10 @@ use syntax::fold::Folder;\n use syntax::parse::token;\n use syntax;\n \n-use std::at_vec;\n use std::libc;\n use std::cast;\n use std::io::Seek;\n+use std::rc::Rc;\n \n use extra::ebml::reader;\n use extra::ebml;\n@@ -812,13 +812,13 @@ impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n             this.emit_struct_field(\"generics\", 0, |this| {\n                 this.emit_struct(\"Generics\", 2, |this| {\n                     this.emit_struct_field(\"type_param_defs\", 0, |this| {\n-                        this.emit_from_vec(*tpbt.generics.type_param_defs,\n+                        this.emit_from_vec(tpbt.generics.type_param_defs(),\n                                            |this, type_param_def| {\n                             this.emit_type_param_def(ecx, type_param_def);\n                         })\n                     });\n                     this.emit_struct_field(\"region_param_defs\", 1, |this| {\n-                        tpbt.generics.region_param_defs.encode(this);\n+                        tpbt.generics.region_param_defs().encode(this);\n                     })\n                 })\n             });\n@@ -997,7 +997,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_tpbt(ecx, *tpbt);\n+                    ebml_w.emit_tpbt(ecx, tpbt.clone());\n                 })\n             })\n         }\n@@ -1064,7 +1064,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(*cap_vars, |ebml_w, cap_var| {\n+                    ebml_w.emit_from_vec(*cap_vars.borrow(), |ebml_w, cap_var| {\n                         cap_var.encode(ebml_w);\n                     })\n                 })\n@@ -1183,8 +1183,8 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                                 this.read_struct_field(\"type_param_defs\",\n                                                        0,\n                                                        |this| {\n-                                    @this.read_to_vec(|this|\n-                                        this.read_type_param_def(xcx))\n+                                    Rc::new(this.read_to_vec(|this|\n+                                                             this.read_type_param_def(xcx)))\n                             }),\n                             region_param_defs:\n                                 this.read_struct_field(\"region_param_defs\",\n@@ -1382,13 +1382,11 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n-                            at_vec::to_managed_move(\n-                                val_dsr.read_to_vec(\n-                                    |val_dsr| val_dsr.read_capture_var(xcx)));\n+                                val_dsr.read_to_vec(|val_dsr| val_dsr.read_capture_var(xcx));\n                         let mut capture_map = dcx.maps\n                                                  .capture_map\n                                                  .borrow_mut();\n-                        capture_map.get().insert(id, cvars);\n+                        capture_map.get().insert(id, Rc::new(cvars));\n                     }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug("}, {"sha": "b280da31c45371301f2cb2e77326275e591bbadb", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -733,7 +733,7 @@ fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n                                 span: Span) {\n         let capture_map = this.bccx.capture_map.borrow();\n         let cap_vars = capture_map.get().get(&closure_id);\n-        for cap_var in cap_vars.iter() {\n+        for cap_var in cap_vars.borrow().iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n             let var_path = @LpVar(var_id);\n             this.check_if_path_is_moved(closure_id, span,\n@@ -839,4 +839,3 @@ fn check_loans_in_block<'a>(this: &mut CheckLoanCtxt<'a>,\n     visit::walk_block(this, blk, ());\n     this.check_for_conflicting_loans(blk.id);\n }\n-"}, {"sha": "0d9b4b0b171cc487c95e29f62ae7e13ae0eabd96", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -69,7 +69,7 @@ pub fn gather_captures(bccx: &BorrowckCtxt,\n                        closure_expr: &ast::Expr) {\n     let capture_map = bccx.capture_map.borrow();\n     let captured_vars = capture_map.get().get(&closure_expr.id);\n-    for captured_var in captured_vars.iter() {\n+    for captured_var in captured_vars.borrow().iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let fvar_id = ast_util::def_id_of_def(captured_var.def).node;"}, {"sha": "8f6d4de476b13866f6490a0076a53d1bf57acff0", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -194,16 +194,6 @@ pub struct BorrowStats {\n //\n // Note that there is no entry with derefs:3---the type of that expression\n // is T, which is not a box.\n-//\n-// Note that implicit dereferences also occur with indexing of `@[]`,\n-// `@str`, etc.  The same rules apply. So, for example, given a\n-// variable `x` of type `@[@[...]]`, if I have an instance of the\n-// expression `x[0]` which is then auto-slice'd, there would be two\n-// potential entries in the root map, both with the id of the `x[0]`\n-// expression. The entry with `derefs==0` refers to the deref of `x`\n-// used as part of evaluating `x[0]`. The entry with `derefs==1`\n-// refers to the deref of the `x[0]` that occurs as part of the\n-// auto-slice.\n #[deriving(Eq, IterBytes)]\n pub struct root_map_key {\n     id: ast::NodeId,\n@@ -774,7 +764,8 @@ impl BorrowckCtxt {\n                         match pat.node {\n                             ast::PatIdent(_, ref path, _) => {\n                                 let ident = ast_util::path_to_ident(path);\n-                                out.push_str(token::ident_to_str(&ident));\n+                                let string = token::get_ident(ident.name);\n+                                out.push_str(string.get());\n                             }\n                             _ => {\n                                 self.tcx.sess.bug(\n@@ -795,8 +786,9 @@ impl BorrowckCtxt {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n                 match fname {\n                     mc::NamedField(ref fname) => {\n+                        let string = token::get_ident(*fname);\n                         out.push_char('.');\n-                        out.push_str(token::interner_get(*fname));\n+                        out.push_str(string.get());\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push_char('#'); // invent a notation here"}, {"sha": "d52ae81328f630784508e86867ece2fa6a1a3b32", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -192,8 +192,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                     \"references in constants may only refer to \\\n                      immutable values\");\n           },\n-          ExprVstore(_, ExprVstoreUniq) |\n-          ExprVstore(_, ExprVstoreBox) => {\n+          ExprVstore(_, ExprVstoreUniq) => {\n               sess.span_err(e.span, \"cannot allocate vectors in constant expressions\")\n           },\n "}, {"sha": "d402305401eb96ecc103d80940bf72050278090f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -176,8 +176,8 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n             match ty::get(ty).sty {\n                 ty::ty_bool => {\n                     match *ctor {\n-                        val(const_bool(true)) => Some(@\"true\"),\n-                        val(const_bool(false)) => Some(@\"false\"),\n+                        val(const_bool(true)) => Some(~\"true\"),\n+                        val(const_bool(false)) => Some(~\"false\"),\n                         _ => None\n                     }\n                 }\n@@ -197,7 +197,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                 }\n                 ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n                     match *ctor {\n-                        vec(n) => Some(format!(\"vectors of length {}\", n).to_managed()),\n+                        vec(n) => Some(format!(\"vectors of length {}\", n)),\n                         _ => None\n                     }\n                 }\n@@ -214,9 +214,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n \n type matrix = ~[~[@Pat]];\n \n-enum useful { useful(ty::t, ctor), useful_, not_useful }\n+#[deriving(Clone)]\n+enum useful {\n+    useful(ty::t, ctor),\n+    useful_,\n+    not_useful,\n+}\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n enum ctor {\n     single,\n     variant(DefId),\n@@ -261,15 +266,15 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                                           val(const_bool(false)),\n                                           0u, left_ty)\n                   }\n-                  ref u => *u,\n+                  ref u => (*u).clone(),\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n                 for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n-                      ref u => return *u,\n+                      ref u => return (*u).clone(),\n                     }\n                 }\n                 not_useful\n@@ -289,7 +294,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 for n in iter::range(0u, max_len + 1) {\n                   match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                     not_useful => (),\n-                    ref u => return *u,\n+                    ref u => return (*u).clone(),\n                   }\n                 }\n                 not_useful\n@@ -304,15 +309,15 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n             match is_useful(cx,\n                             &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n                             v.tail()) {\n-              useful_ => useful(left_ty, *ctor),\n-              ref u => *u,\n+              useful_ => useful(left_ty, (*ctor).clone()),\n+              ref u => (*u).clone(),\n             }\n           }\n         }\n       }\n       Some(ref v0_ctor) => {\n         let arity = ctor_arity(cx, v0_ctor, left_ty);\n-        is_useful_specialized(cx, m, v, *v0_ctor, arity, left_ty)\n+        is_useful_specialized(cx, m, v, (*v0_ctor).clone(), arity, left_ty)\n       }\n     }\n }\n@@ -329,7 +334,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt,\n         cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n-      ref u => *u,\n+      ref u => (*u).clone(),\n     }\n }\n \n@@ -407,7 +412,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n             let r = pat_ctor_id(cx, r[0]);\n             for id in r.iter() {\n                 if !found.contains(id) {\n-                    found.push(*id);\n+                    found.push((*id).clone());\n                 }\n             }\n         }\n@@ -770,8 +775,8 @@ fn specialize(cx: &MatchCheckCtxt,\n             }\n             PatRange(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n-                    val(ref v) => (*v, *v),\n-                    range(ref lo, ref hi) => (*lo, *hi),\n+                    val(ref v) => ((*v).clone(), (*v).clone()),\n+                    range(ref lo, ref hi) => ((*lo).clone(), (*hi).clone()),\n                     single => return Some(r.tail().to_owned()),\n                     _ => fail!(\"type error\")\n                 };"}, {"sha": "cbe1e8f72d933d6ccde522cbd17a32cc1e6e1180", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -16,13 +16,15 @@ use middle::ty;\n use middle::typeck::astconv;\n use middle;\n \n-use syntax::{ast, ast_map, ast_util};\n-use syntax::visit;\n-use syntax::visit::Visitor;\n use syntax::ast::*;\n+use syntax::parse::token::InternedString;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+use syntax::{ast, ast_map, ast_util};\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n+use std::rc::Rc;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -238,7 +240,6 @@ impl ConstEvalVisitor {\n                 match vstore {\n                     ast::ExprVstoreSlice => self.classify(e),\n                     ast::ExprVstoreUniq |\n-                    ast::ExprVstoreBox |\n                     ast::ExprVstoreMutSlice => non_const\n                 }\n             }\n@@ -319,8 +320,8 @@ pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n     const_uint(u64),\n-    const_str(@str),\n-    const_binary(@[u8]),\n+    const_str(InternedString),\n+    const_binary(Rc<~[u8]>),\n     const_bool(bool)\n }\n \n@@ -508,15 +509,15 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n \n pub fn lit_to_const(lit: &Lit) -> const_val {\n     match lit.node {\n-        LitStr(s, _) => const_str(s),\n-        LitBinary(data) => const_binary(data),\n+        LitStr(ref s, _) => const_str((*s).clone()),\n+        LitBinary(ref data) => const_binary(data.clone()),\n         LitChar(n) => const_uint(n as u64),\n         LitInt(n, _) => const_int(n),\n         LitUint(n, _) => const_uint(n),\n         LitIntUnsuffixed(n) => const_int(n),\n-        LitFloat(n, _) => const_float(from_str::<f64>(n).unwrap() as f64),\n-        LitFloatUnsuffixed(n) =>\n-            const_float(from_str::<f64>(n).unwrap() as f64),\n+        LitFloat(ref n, _) | LitFloatUnsuffixed(ref n) => {\n+            const_float(from_str::<f64>(n.get()).unwrap() as f64)\n+        }\n         LitNil => const_int(0i64),\n         LitBool(b) => const_bool(b)\n     }\n@@ -530,7 +531,7 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n         (&const_int(a), &const_int(b)) => compare_vals(a, b),\n         (&const_uint(a), &const_uint(b)) => compare_vals(a, b),\n         (&const_float(a), &const_float(b)) => compare_vals(a, b),\n-        (&const_str(a), &const_str(b)) => compare_vals(a, b),\n+        (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n         (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n         _ => None\n     }"}, {"sha": "08ab8edf750caf93130348b3ae428325b5cb8cb9", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -360,9 +360,10 @@ impl DeadVisitor {\n \n     fn warn_dead_code(&mut self, id: ast::NodeId,\n                       span: codemap::Span, ident: &ast::Ident) {\n+        let string = token::get_ident(ident.name);\n         self.tcx.sess.add_lint(DeadCode, id, span,\n                                format!(\"code is never used: `{}`\",\n-                                       token::ident_to_str(ident)));\n+                                       string.get()));\n     }\n }\n "}, {"sha": "0d6dc6572c36ec8ebf86d5170fd0fd452118f8bc", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -277,7 +277,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n               ExprPath(_) => {\n                 let did = ast_util::def_id_of_def(def_map.get()\n                                                          .get_copy(&e.id));\n-                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n+                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs.clone()\n               }\n               _ => {\n                 // Type substitutions should only occur on paths and\n@@ -289,6 +289,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                     \"non path/method call expr has type substs??\")\n               }\n             };\n+            let type_param_defs = type_param_defs.borrow();\n             if ts.len() != type_param_defs.len() {\n                 // Fail earlier to make debugging easier\n                 fail!(\"internal error: in kind::check_expr, length \\\n@@ -362,8 +363,8 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n             for ts in r.iter() {\n                 let def_map = cx.tcx.def_map.borrow();\n                 let did = ast_util::def_id_of_def(def_map.get().get_copy(&id));\n-                let type_param_defs =\n-                    ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n+                let generics = ty::lookup_item_type(cx.tcx, did).generics;\n+                let type_param_defs = generics.type_param_defs();\n                 for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n                     check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n                 }"}, {"sha": "2b100ffa4c98d9cc4726216acb1587fb989153c9", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -26,8 +26,9 @@ use middle::ty::{BuiltinBound, BoundFreeze, BoundPod, BoundSend, BoundSized};\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n-use syntax::visit;\n+use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n+use syntax::visit;\n \n use std::hashmap::HashMap;\n use std::iter::Enumerate;\n@@ -182,11 +183,11 @@ impl LanguageItemCollector {\n     }\n }\n \n-pub fn extract(attrs: &[ast::Attribute]) -> Option<@str> {\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     for attribute in attrs.iter() {\n         match attribute.name_str_pair() {\n-            Some((key, value)) if \"lang\" == key => {\n-                return Some(value);\n+            Some((ref key, ref value)) if key.equiv(&(\"lang\")) => {\n+                return Some((*value).clone());\n             }\n             Some(..) | None => {}\n         }"}, {"sha": "e674af6b3b3e3444254006fc3483a4f9d037b021", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -34,18 +34,17 @@\n //! Context itself, span_lint should be used instead of add_lint.\n \n use driver::session;\n+use metadata::csearch;\n use middle::dead::DEAD_CODE_LINT_STR;\n+use middle::pat_util;\n use middle::privacy;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::ty;\n+use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n+use middle::typeck::infer;\n use middle::typeck;\n-use middle::pat_util;\n-use metadata::csearch;\n-use util::ppaux::{ty_to_str};\n use std::to_str::ToStr;\n-\n-use middle::typeck::infer;\n-use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n+use util::ppaux::{ty_to_str};\n \n use std::cmp;\n use std::hashmap::HashMap;\n@@ -59,13 +58,14 @@ use std::u64;\n use std::u8;\n use extra::smallintmap::SmallIntMap;\n use syntax::ast_map;\n-use syntax::attr;\n+use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::{AttrMetaMethods, AttributeMethods};\n+use syntax::attr;\n use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n-use syntax::{ast, ast_util, visit};\n-use syntax::ast_util::IdVisitingOperation;\n use syntax::visit::Visitor;\n+use syntax::{ast, ast_util, visit};\n \n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub enum Lint {\n@@ -540,10 +540,16 @@ impl<'a> Context<'a> {\n         });\n \n         let old_is_doc_hidden = self.is_doc_hidden;\n-        self.is_doc_hidden = self.is_doc_hidden ||\n-            attrs.iter().any(|attr| (\"doc\" == attr.name() && match attr.meta_item_list()\n-                                     { None => false,\n-                                       Some(l) => attr::contains_name(l, \"hidden\") }));\n+        self.is_doc_hidden =\n+            self.is_doc_hidden ||\n+            attrs.iter()\n+                 .any(|attr| {\n+                     attr.name().equiv(&(\"doc\")) &&\n+                     match attr.meta_item_list() {\n+                         None => false,\n+                         Some(l) => attr::contains_name(l, \"hidden\")\n+                     }\n+                 });\n \n         f(self);\n \n@@ -569,12 +575,12 @@ impl<'a> Context<'a> {\n // Return true if that's the case. Otherwise return false.\n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::Attribute],\n-                 f: |@ast::MetaItem, level, @str| -> bool)\n+                 f: |@ast::MetaItem, level, InternedString| -> bool)\n                  -> bool {\n     let xs = [allow, warn, deny, forbid];\n     for &level in xs.iter() {\n         let level_name = level_to_str(level);\n-        for attr in attrs.iter().filter(|m| level_name == m.name()) {\n+        for attr in attrs.iter().filter(|m| m.name().equiv(&level_name)) {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::MetaList(_, ref metas) => metas,\n@@ -585,8 +591,8 @@ pub fn each_lint(sess: session::Session,\n             };\n             for meta in metas.iter() {\n                 match meta.node {\n-                    ast::MetaWord(lintname) => {\n-                        if !f(*meta, level, lintname) {\n+                    ast::MetaWord(ref lintname) => {\n+                        if !f(*meta, level, (*lintname).clone()) {\n                             return false;\n                         }\n                     }\n@@ -603,15 +609,17 @@ pub fn each_lint(sess: session::Session,\n // Check from a list of attributes if it contains the appropriate\n // `#[level(lintname)]` attribute (e.g. `#[allow(dead_code)]).\n pub fn contains_lint(attrs: &[ast::Attribute],\n-                    level: level, lintname: &'static str) -> bool {\n+                     level: level,\n+                     lintname: &'static str)\n+                     -> bool {\n     let level_name = level_to_str(level);\n-    for attr in attrs.iter().filter(|m| level_name == m.name()) {\n+    for attr in attrs.iter().filter(|m| m.name().equiv(&level_name)) {\n         if attr.meta_item_list().is_none() {\n             continue\n         }\n         let list = attr.meta_item_list().unwrap();\n         for meta_item in list.iter() {\n-            if lintname == meta_item.name() {\n+            if meta_item.name().equiv(&lintname) {\n                 return true;\n             }\n         }\n@@ -879,8 +887,7 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n         let mut n_uniq = 0;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match ty::get(t).sty {\n-                ty::ty_box(_) | ty::ty_str(ty::vstore_box) |\n-                ty::ty_vec(_, ty::vstore_box) |\n+                ty::ty_box(_) |\n                 ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n                     n_box += 1;\n                 }\n@@ -1240,8 +1247,7 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n     // Warn if string and vector literals with sigils, or boxing expressions,\n     // are immediately borrowed.\n     let allocation = match e.node {\n-        ast::ExprVstore(e2, ast::ExprVstoreUniq) |\n-        ast::ExprVstore(e2, ast::ExprVstoreBox) => {\n+        ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n             match e2.node {\n                 ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n                     VectorAllocation\n@@ -1314,7 +1320,7 @@ fn check_missing_doc_attrs(cx: &Context,\n \n     let has_doc = attrs.iter().any(|a| {\n         match a.node.value.node {\n-            ast::MetaNameValue(ref name, _) if \"doc\" == *name => true,\n+            ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n             _ => false\n         }\n     });"}, {"sha": "fb5e548e12f6eb7b8a24f19274b92b4476eb9a25", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -120,6 +120,7 @@ use std::vec;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n+use syntax::parse::token;\n use syntax::print::pprust::{expr_to_str, block_to_str};\n use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n@@ -332,13 +333,14 @@ impl IrMaps {\n         }\n     }\n \n-    pub fn variable_name(&self, var: Variable) -> @str {\n+    pub fn variable_name(&self, var: Variable) -> ~str {\n         let var_kinds = self.var_kinds.borrow();\n         match var_kinds.get()[var.get()] {\n             Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n-                self.tcx.sess.str_of(nm)\n+                let string = token::get_ident(nm.name);\n+                string.get().to_str()\n             },\n-            ImplicitRet => @\"<implicit-ret>\"\n+            ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n@@ -500,7 +502,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n         let capture_map = this.capture_map.borrow();\n         let cvs = capture_map.get().get(&expr.id);\n         let mut call_caps = ~[];\n-        for cv in cvs.iter() {\n+        for cv in cvs.borrow().iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n@@ -1669,7 +1671,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn should_warn(&self, var: Variable) -> Option<@str> {\n+    pub fn should_warn(&self, var: Variable) -> Option<~str> {\n         let name = self.ir.variable_name(var);\n         if name.len() == 0 || name[0] == ('_' as u8) { None } else { Some(name) }\n     }"}, {"sha": "72fd98e56ed6743548907bc974b4d4d5d48ccb09", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -178,9 +178,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         }\n \n         ty::ty_box(_) |\n-        ty::ty_vec(_, ty::vstore_box) |\n-        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n-        ty::ty_str(ty::vstore_box) => {\n+        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n             Some(deref_ptr(gc_ptr))\n         }\n \n@@ -1233,7 +1231,10 @@ pub fn ptr_sigil(ptr: PointerKind) -> ~str {\n impl Repr for InteriorKind {\n     fn repr(&self, _tcx: ty::ctxt) -> ~str {\n         match *self {\n-            InteriorField(NamedField(fld)) => token::interner_get(fld).to_owned(),\n+            InteriorField(NamedField(fld)) => {\n+                let string = token::get_ident(fld);\n+                string.get().to_owned()\n+            }\n             InteriorField(PositionalField(i)) => format!(\"\\\\#{:?}\", i),\n             InteriorElement(_) => ~\"[]\",\n         }"}, {"sha": "d73d7f3d6f1dbf803e4a573c8980880e1918c4e5", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -136,9 +136,9 @@ use util::ppaux::Repr;\n use util::common::indenter;\n use util::ppaux::UserString;\n \n-use std::at_vec;\n use std::cell::RefCell;\n use std::hashmap::{HashSet, HashMap};\n+use std::rc::Rc;\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n@@ -159,7 +159,7 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @RefCell<HashMap<NodeId, @[CaptureVar]>>;\n+pub type CaptureMap = @RefCell<HashMap<NodeId, Rc<~[CaptureVar]>>>;\n \n pub type MovesMap = @RefCell<HashSet<NodeId>>;\n \n@@ -681,23 +681,22 @@ impl VisitContext {\n         self.consume_expr(arg_expr)\n     }\n \n-    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> @[CaptureVar] {\n+    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> Rc<~[CaptureVar]> {\n         debug!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n         let sigil = ty::ty_closure_sigil(fn_ty);\n         let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n-        if sigil == BorrowedSigil {\n+        let v = if sigil == BorrowedSigil {\n             // || captures everything by ref\n-            at_vec::from_fn(freevars.len(), |i| {\n-                let fvar = &freevars[i];\n-                CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef}\n-            })\n+            freevars.iter()\n+                    .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n+                    .collect()\n         } else {\n             // @fn() and ~fn() capture by copy or by move depending on type\n-            at_vec::from_fn(freevars.len(), |i| {\n-                let fvar = &freevars[i];\n+            freevars.iter()\n+                    .map(|fvar| {\n                 let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n                 let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n                 debug!(\"fvar_def_id={:?} fvar_ty={}\",\n@@ -708,7 +707,9 @@ impl VisitContext {\n                     CapCopy\n                 };\n                 CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n-            })\n-        }\n+\n+                }).collect()\n+        };\n+        Rc::new(v)\n     }\n }"}, {"sha": "ae1b71f5ccad193be87fae4c60785bc8f712a912", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -530,8 +530,10 @@ impl<'a> PrivacyVisitor<'a> {\n                             ast::ItemTrait(..) => \"trait\",\n                             _ => return false,\n                         };\n-                        let msg = format!(\"{} `{}` is private\", desc,\n-                                          token::ident_to_str(&item.ident));\n+                        let string = token::get_ident(item.ident.name);\n+                        let msg = format!(\"{} `{}` is private\",\n+                                          desc,\n+                                          string.get());\n                         self.tcx.sess.span_note(span, msg);\n                     }\n                     Some(..) | None => {}\n@@ -588,8 +590,10 @@ impl<'a> PrivacyVisitor<'a> {\n             if struct_vis != ast::Public && field.vis == ast::Public { break }\n             if !is_local(field.id) ||\n                !self.private_accessible(field.id.node) {\n-                self.tcx.sess.span_err(span, format!(\"field `{}` is private\",\n-                                             token::ident_to_str(&ident)));\n+                let string = token::get_ident(ident.name);\n+                self.tcx.sess.span_err(span,\n+                                       format!(\"field `{}` is private\",\n+                                               string.get()))\n             }\n             break;\n         }\n@@ -603,8 +607,11 @@ impl<'a> PrivacyVisitor<'a> {\n         let method_id = ty::method(self.tcx, method_id).provided_source\n                                                        .unwrap_or(method_id);\n \n-        self.ensure_public(span, method_id, None,\n-                           format!(\"method `{}`\", token::ident_to_str(name)));\n+        let string = token::get_ident(name.name);\n+        self.ensure_public(span,\n+                           method_id,\n+                           None,\n+                           format!(\"method `{}`\", string.get()));\n     }\n \n     // Checks that a path is in scope.\n@@ -617,10 +624,17 @@ impl<'a> PrivacyVisitor<'a> {\n             match *self.last_private_map.get(&path_id) {\n                 resolve::AllPublic => {},\n                 resolve::DependsOn(def) => {\n-                    let name = token::ident_to_str(&path.segments.last().unwrap()\n-                                                        .identifier);\n-                    self.ensure_public(span, def, Some(origdid),\n-                                       format!(\"{} `{}`\", tyname, name));\n+                    let name = token::get_ident(path.segments\n+                                                    .last()\n+                                                    .unwrap()\n+                                                    .identifier\n+                                                    .name);\n+                    self.ensure_public(span,\n+                                       def,\n+                                       Some(origdid),\n+                                       format!(\"{} `{}`\",\n+                                               tyname,\n+                                               name.get()));\n                 }\n             }\n         };"}, {"sha": "6ee44c03a8041cf15293e4d8ff486f2bd6de9a79", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -20,9 +20,8 @@ use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_util::{def_id_of_def, local_def, mtwt_resolve};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n+use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n-use syntax::parse::token::{IdentInterner, interner_get};\n-use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::opt_vec::OptVec;\n@@ -53,7 +52,7 @@ pub type TraitMap = HashMap<NodeId,@RefCell<~[DefId]>>;\n pub type ExportMap2 = @RefCell<HashMap<NodeId, ~[Export2]>>;\n \n pub struct Export2 {\n-    name: @str,        // The name of the target.\n+    name: ~str,        // The name of the target.\n     def_id: DefId,     // The definition of the target.\n }\n \n@@ -1894,8 +1893,9 @@ impl Resolver {\n         csearch::each_child_of_item(self.session.cstore,\n                                     def_id,\n                                     |def_like, child_ident, visibility| {\n+            let child_ident_string = token::get_ident(child_ident.name);\n             debug!(\"(populating external module) ... found ident: {}\",\n-                   token::ident_to_str(&child_ident));\n+                   child_ident_string.get());\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n                                                             child_ident,\n@@ -2114,24 +2114,26 @@ impl Resolver {\n     }\n \n     fn import_directive_subclass_to_str(&mut self,\n-                                            subclass: ImportDirectiveSubclass)\n-                                            -> @str {\n+                                        subclass: ImportDirectiveSubclass)\n+                                        -> ~str {\n         match subclass {\n-            SingleImport(_target, source) => self.session.str_of(source),\n-            GlobImport => @\"*\"\n+            SingleImport(_target, source) => {\n+                self.session.str_of(source).to_str()\n+            }\n+            GlobImport => ~\"*\"\n         }\n     }\n \n     fn import_path_to_str(&mut self,\n-                              idents: &[Ident],\n-                              subclass: ImportDirectiveSubclass)\n-                              -> @str {\n+                          idents: &[Ident],\n+                          subclass: ImportDirectiveSubclass)\n+                          -> ~str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n             (format!(\"{}::{}\",\n-                  self.idents_to_str(idents),\n-                  self.import_directive_subclass_to_str(subclass))).to_managed()\n+                     self.idents_to_str(idents),\n+                     self.import_directive_subclass_to_str(subclass)))\n         }\n     }\n \n@@ -2584,7 +2586,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                     to `{}`\",\n-                   interner_get(name),\n+                   token::get_ident(name).get().to_str(),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_));\n \n@@ -3101,11 +3103,12 @@ impl Resolver {\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        if \"self\" == token::ident_to_str(&module_path[0]) {\n+        let first_module_path_string = token::get_ident(module_path[0].name);\n+        if \"self\" == first_module_path_string.get() {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if \"super\" == token::ident_to_str(&module_path[0]) {\n+        } else if \"super\" == first_module_path_string.get() {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -3114,8 +3117,11 @@ impl Resolver {\n         }\n \n         // Now loop through all the `super`s we find.\n-        while i < module_path.len() &&\n-                \"super\" == token::ident_to_str(&module_path[i]) {\n+        while i < module_path.len() {\n+            let string = token::get_ident(module_path[i].name);\n+            if \"super\" != string.get() {\n+                break\n+            }\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n@@ -3354,10 +3360,10 @@ impl Resolver {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n-                       interner_get(name),\n+                       token::get_ident(name).get().to_str(),\n                        def_id_of_def(d));\n                 exports2.push(Export2 {\n-                    name: interner_get(name),\n+                    name: token::get_ident(name).get().to_str(),\n                     def_id: def_id_of_def(d)\n                 });\n             }\n@@ -3380,7 +3386,7 @@ impl Resolver {\n                 match importresolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\",\n-                               interner_get(*name));\n+                               token::get_ident(*name).get().to_str());\n                         self.add_exports_of_namebindings(exports2,\n                                                          *name,\n                                                          target.bindings,\n@@ -4155,31 +4161,37 @@ impl Resolver {\n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n                   None => {\n+                    let string = token::get_ident(key);\n                     self.resolve_error(\n                         p.span,\n                         format!(\"variable `{}` from pattern \\\\#1 is \\\n                                   not bound in pattern \\\\#{}\",\n-                             interner_get(key), i + 1));\n+                                string.get(),\n+                                i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n+                        let string = token::get_ident(key);\n                         self.resolve_error(\n                             binding_i.span,\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern \\\\#{} than in pattern \\\\#1\",\n-                                 interner_get(key), i + 1));\n+                                    string.get(),\n+                                    i + 1));\n                     }\n                   }\n                 }\n             }\n \n             for (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n+                    let string = token::get_ident(key);\n                     self.resolve_error(\n                         binding.span,\n                         format!(\"variable `{}` from pattern \\\\#{} is \\\n                                   not bound in pattern \\\\#1\",\n-                             interner_get(key), i + 1));\n+                                string.get(),\n+                                i + 1));\n                 }\n             }\n         }\n@@ -4371,9 +4383,10 @@ impl Resolver {\n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def, lp)\n                                 if mode == RefutableMode => {\n+                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n-                                   interner_get(renamed));\n+                                   string.get());\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4382,17 +4395,19 @@ impl Resolver {\n                             self.record_def(pattern.id, (def, lp));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n+                            let string = token::get_ident(renamed);\n                             self.resolve_error(pattern.span,\n                                                   format!(\"declaration of `{}` \\\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                       interner_get(renamed)));\n+                                                          string.get()));\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n+                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n-                                   interner_get(renamed));\n+                                   string.get());\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4406,8 +4421,9 @@ impl Resolver {\n                                                    allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n+                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) binding `{}`\",\n-                                   interner_get(renamed));\n+                                   string.get());\n \n                             let def = match mode {\n                                 RefutableMode => {\n@@ -5009,10 +5025,10 @@ impl Resolver {\n     }\n \n     fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n-                                -> Option<@str> {\n+                                -> Option<~str> {\n         let this = &mut *self;\n \n-        let mut maybes: ~[@str] = ~[];\n+        let mut maybes: ~[~str] = ~[];\n         let mut values: ~[uint] = ~[];\n \n         let mut j = {\n@@ -5024,14 +5040,15 @@ impl Resolver {\n             let value_ribs = this.value_ribs.borrow();\n             let bindings = value_ribs.get()[j].bindings.borrow();\n             for (&k, _) in bindings.get().iter() {\n-                maybes.push(interner_get(k));\n+                let string = token::get_ident(k);\n+                maybes.push(string.get().to_str());\n                 values.push(uint::MAX);\n             }\n         }\n \n         let mut smallest = 0;\n-        for (i, &other) in maybes.iter().enumerate() {\n-            values[i] = name.lev_distance(other);\n+        for (i, other) in maybes.iter().enumerate() {\n+            values[i] = name.lev_distance(*other);\n \n             if values[i] <= values[smallest] {\n                 smallest = i;\n@@ -5190,7 +5207,9 @@ impl Resolver {\n                         self.resolve_error(expr.span,\n                                               format!(\"use of undeclared label \\\n                                                    `{}`\",\n-                                                   interner_get(label))),\n+                                                   token::get_ident(label)\n+                                                    .get()\n+                                                    .to_str())),\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // FIXME: is AllPublic correct?\n                         self.record_def(expr.id, (def, AllPublic))\n@@ -5510,7 +5529,7 @@ impl Resolver {\n         self.populate_module_if_necessary(module_);\n         let children = module_.children.borrow();\n         for (&name, _) in children.get().iter() {\n-            debug!(\"* {}\", interner_get(name));\n+            debug!(\"* {}\", token::get_ident(name).get().to_str());\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -5534,7 +5553,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* {}:{}{}\", interner_get(*name),\n+            debug!(\"* {}:{}{}\", token::get_ident(*name).get().to_str(),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "c4a30171687d260c5895fee671add77241ea91aa", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -13,8 +13,9 @@\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n+\n+use std::rc::Rc;\n use syntax::opt_vec::OptVec;\n-use std::at_vec;\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n@@ -84,10 +85,9 @@ impl<T:Subst> Subst for ~[T] {\n         self.map(|t| t.subst(tcx, substs))\n     }\n }\n-\n-impl<T:Subst> Subst for @[T] {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @[T] {\n-        at_vec::map(*self, |t| t.subst(tcx, substs))\n+impl<T:Subst> Subst for Rc<T> {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Rc<T> {\n+        Rc::new(self.borrow().subst(tcx, substs))\n     }\n }\n "}, {"sha": "135b16b22abd238bdf5a0a8de76e1c3bb2c7a030", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -229,6 +229,7 @@ use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::parse::token::InternedString;\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n@@ -1031,7 +1032,6 @@ fn match_datum(bcx: &Block,\n \n fn extract_vec_elems<'a>(\n                      bcx: &'a Block<'a>,\n-                     pat_span: Span,\n                      pat_id: ast::NodeId,\n                      elem_count: uint,\n                      slice: Option<uint>,\n@@ -1040,7 +1040,7 @@ fn extract_vec_elems<'a>(\n                      -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n-    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id, 0);\n+    let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n     let mut elems = vec::from_fn(elem_count, |i| {\n@@ -1174,7 +1174,7 @@ fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n struct DynamicFailureHandler<'a> {\n     bcx: &'a Block<'a>,\n     sp: Span,\n-    msg: @str,\n+    msg: InternedString,\n     finished: @Cell<Option<BasicBlockRef>>,\n }\n \n@@ -1187,7 +1187,7 @@ impl<'a> DynamicFailureHandler<'a> {\n \n         let fcx = self.bcx.fcx;\n         let fail_cx = fcx.new_block(false, \"case_fallthrough\", None);\n-        controlflow::trans_fail(fail_cx, Some(self.sp), self.msg);\n+        controlflow::trans_fail(fail_cx, Some(self.sp), self.msg.clone());\n         self.finished.set(Some(fail_cx.llbb));\n         fail_cx.llbb\n     }\n@@ -1511,13 +1511,11 @@ fn compile_submatch_continue<'r,\n                                 vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n-    let mut pat_span = DUMMY_SP;\n     for br in m.iter() {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n             pat_id = br.pats[col].id;\n-            pat_span = br.pats[col].span;\n         }\n     }\n \n@@ -1766,7 +1764,7 @@ fn compile_submatch_continue<'r,\n                     vec_len_ge(i) => (n + 1u, Some(i)),\n                     vec_len_eq => (n, None)\n                 };\n-                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n,\n+                let args = extract_vec_elems(opt_cx, pat_id, n,\n                                              slice, val, test_val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n@@ -1891,7 +1889,8 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n             let fail_handler = ~DynamicFailureHandler {\n                 bcx: scope_cx,\n                 sp: discr_expr.span,\n-                msg: @\"scrutinizing value that can't exist\",\n+                msg: InternedString::new(\"scrutinizing value that can't \\\n+                                          exist\"),\n                 finished: fail_cx,\n             };\n             DynamicFailureHandlerClass(fail_handler)"}, {"sha": "db99bd53704ebd38f0628a24cfb571727a8ef98b", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -38,8 +38,8 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let temp_scope = fcx.push_custom_cleanup_scope();\n \n     // Prepare the output operands\n-    let outputs = ia.outputs.map(|&(c, out)| {\n-        constraints.push(c);\n+    let outputs = ia.outputs.map(|&(ref c, out)| {\n+        constraints.push((*c).clone());\n \n         let out_datum = unpack_datum!(bcx, expr::trans(bcx, out));\n         output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n@@ -48,8 +48,8 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     });\n \n     // Now the input operands\n-    let inputs = ia.inputs.map(|&(c, input)| {\n-        constraints.push(c);\n+    let inputs = ia.inputs.map(|&(ref c, input)| {\n+        constraints.push((*c).clone());\n \n         unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n@@ -63,13 +63,13 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    let mut constraints = constraints.connect(\",\");\n+    let mut constraints = constraints.map(|s| s.get().to_str()).connect(\",\");\n \n     let mut clobbers = getClobbers();\n-    if !ia.clobbers.is_empty() && !clobbers.is_empty() {\n-        clobbers = format!(\"{},{}\", ia.clobbers, clobbers);\n+    if !ia.clobbers.get().is_empty() && !clobbers.is_empty() {\n+        clobbers = format!(\"{},{}\", ia.clobbers.get(), clobbers);\n     } else {\n-        clobbers.push_str(ia.clobbers);\n+        clobbers.push_str(ia.clobbers.get());\n     }\n \n     // Add the clobbers to our constraints list\n@@ -98,7 +98,7 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n         ast::AsmIntel => lib::llvm::AD_Intel\n     };\n \n-    let r = ia.asm.with_c_str(|a| {\n+    let r = ia.asm.get().with_c_str(|a| {\n         constraints.with_c_str(|c| {\n             InlineAsmCall(bcx, a, c, inputs, output_type, ia.volatile, ia.alignstack, dialect)\n         })"}, {"sha": "7bd2653f86990d871f433a3a213a23880b48207a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -76,16 +76,17 @@ use std::hashmap::HashMap;\n use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n+use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n use syntax::ast_map::{PathName, PathPrettyName, path_elem_to_str};\n use syntax::ast_util::{local_def, is_local};\n+use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n-use syntax::{ast, ast_util, ast_map};\n-use syntax::attr::AttrMetaMethods;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n-use syntax::visit;\n use syntax::visit::Visitor;\n+use syntax::visit;\n+use syntax::{ast, ast_util, ast_map};\n \n pub use middle::trans::context::task_llcx;\n \n@@ -359,7 +360,7 @@ pub fn malloc_raw_dyn<'a>(\n             None);\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty_value.ptr_to()))\n     } else {\n-        // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n+        // we treat ~fn as @ here, which isn't ideal\n         let langcall = match heap {\n             heap_managed => {\n                 require_alloc_fn(bcx, t, MallocFnLangItem)\n@@ -509,7 +510,7 @@ pub fn set_no_split_stack(f: ValueRef) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: @str) {\n+pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: ~str) {\n     let mut all_llvm_symbols = ccx.all_llvm_symbols.borrow_mut();\n     if all_llvm_symbols.get().contains(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n@@ -604,7 +605,8 @@ pub fn compare_scalar_types<'a>(\n             rslt(\n                 controlflow::trans_fail(\n                     cx, None,\n-                    @\"attempt to compare values of type type\"),\n+                    InternedString::new(\"attempt to compare values of type \\\n+                                         type\")),\n                 C_nil())\n         }\n         _ => {\n@@ -856,9 +858,9 @@ pub fn fail_if_zero<'a>(\n                     rhs_t: ty::t)\n                     -> &'a Block<'a> {\n     let text = if divrem == ast::BiDiv {\n-        @\"attempted to divide by zero\"\n+        \"attempted to divide by zero\"\n     } else {\n-        @\"attempted remainder with a divisor of zero\"\n+        \"attempted remainder with a divisor of zero\"\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n@@ -875,7 +877,7 @@ pub fn fail_if_zero<'a>(\n       }\n     };\n     with_cond(cx, is_zero, |bcx| {\n-        controlflow::trans_fail(bcx, Some(span), text)\n+        controlflow::trans_fail(bcx, Some(span), InternedString::new(text))\n     })\n }\n \n@@ -1951,7 +1953,7 @@ fn exported_name(ccx: &CrateContext, path: ast_map::Path,\n                  ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n-        Some(name) => name.to_owned(),\n+        Some(name) => name.get().to_owned(),\n \n         // Don't mangle\n         _ if attr::contains_name(attrs, \"no_mangle\")\n@@ -2099,7 +2101,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     match attr::first_attr_value_str_by_name(i.attrs, \"link_section\") {\n                         Some(sect) => unsafe {\n-                            sect.with_c_str(|buf| {\n+                            sect.get().with_c_str(|buf| {\n                                 llvm::LLVMSetSection(v, buf);\n                             })\n                         },\n@@ -2161,9 +2163,9 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                     ccx.crate_map\n                                 }\n                             } else {\n-                                let ident = foreign::link_name(ccx, ni);\n+                                let ident = foreign::link_name(ni);\n                                 unsafe {\n-                                    ident.with_c_str(|buf| {\n+                                    ident.get().with_c_str(|buf| {\n                                         let ty = type_of(ccx, ty);\n                                         llvm::LLVMAddGlobal(ccx.llmod,\n                                                             ty.to_ref(), buf)\n@@ -2476,21 +2478,21 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n         let mut keys = ~[];\n         let module_data = ccx.module_data.borrow();\n         for (k, _) in module_data.get().iter() {\n-            keys.push(k.to_managed());\n+            keys.push(k.clone());\n         }\n         keys\n     };\n \n     for key in keys.iter() {\n-            let llstrval = C_str_slice(ccx, *key);\n-            let module_data = ccx.module_data.borrow();\n-            let val = *module_data.get().find_equiv(key).unwrap();\n-            let v_ptr = p2i(ccx, val);\n-            let elt = C_struct([\n-                llstrval,\n-                v_ptr\n-            ], false);\n-            elts.push(elt);\n+        let llstrval = C_str_slice(ccx, token::intern_and_get_ident(*key));\n+        let module_data = ccx.module_data.borrow();\n+        let val = *module_data.get().find_equiv(key).unwrap();\n+        let v_ptr = p2i(ccx, val);\n+        let elt = C_struct([\n+            llstrval,\n+            v_ptr\n+        ], false);\n+        elts.push(elt);\n     }\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));"}, {"sha": "80d92d856864c05368af7595c79d067b8bb529a0", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -220,7 +220,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n         bcx.tcx(), param_substs, impl_res.trait_vtables);\n \n     // Now we pull any vtables for parameters on the actual method.\n-    let num_method_vtables = method.generics.type_param_defs.len();\n+    let num_method_vtables = method.generics.type_param_defs().len();\n     let method_vtables = match impl_vtables {\n         Some(vtables) => {\n             let num_impl_type_parameters ="}, {"sha": "c9631a72ee7c9823589d6b91c237b3361e117153", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -403,11 +403,11 @@ pub fn trans_expr_fn<'a>(\n         let capture_map = ccx.maps.capture_map.borrow();\n         capture_map.get().get_copy(&user_id)\n     };\n-    let ClosureResult {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, sigil);\n+    let ClosureResult {llbox, cdata_ty, bcx} = build_closure(bcx, *cap_vars.borrow(), sigil);\n     trans_closure(ccx, sub_path, decl, body, llfn,\n                   bcx.fcx.param_substs, user_id,\n                   [], ty::ty_fn_ret(fty),\n-                  |bcx| load_environment(bcx, cdata_ty, cap_vars, sigil));\n+                  |bcx| load_environment(bcx, cdata_ty, *cap_vars.borrow(), sigil));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n \n     bcx"}, {"sha": "78affcc69e1138bc26dbe8ef048bdcd21d09f454", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -30,7 +30,6 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n-\n use arena::TypedArena;\n use std::c_str::ToCStr;\n use std::cast::transmute;\n@@ -41,6 +40,7 @@ use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use syntax::ast::{Ident};\n use syntax::ast_map::{Path, PathElem, PathPrettyName};\n use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n \n@@ -446,8 +446,9 @@ impl<'a> Block<'a> {\n     }\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n-    pub fn ident(&self, ident: Ident) -> @str {\n-        token::ident_to_str(&ident)\n+    pub fn ident(&self, ident: Ident) -> ~str {\n+        let string = token::get_ident(ident.name);\n+        string.get().to_str()\n     }\n \n     pub fn node_id_to_str(&self, id: ast::NodeId) -> ~str {\n@@ -597,18 +598,19 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n+pub fn C_cstr(cx: &CrateContext, s: InternedString) -> ValueRef {\n     unsafe {\n         {\n             let const_cstr_cache = cx.const_cstr_cache.borrow();\n-            match const_cstr_cache.get().find_equiv(&s) {\n+            match const_cstr_cache.get().find(&s) {\n                 Some(&llval) => return llval,\n                 None => ()\n             }\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx,\n-                                                s.as_ptr() as *c_char, s.len() as c_uint,\n+                                                s.get().as_ptr() as *c_char,\n+                                                s.get().len() as c_uint,\n                                                 False);\n \n         let gsym = token::gensym(\"str\");\n@@ -627,9 +629,9 @@ pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CrateContext, s: @str) -> ValueRef {\n+pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     unsafe {\n-        let len = s.len();\n+        let len = s.get().len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n         C_struct([cs, C_uint(cx, len)], false)\n     }\n@@ -766,7 +768,6 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n         ty::ty_float(_) => MonoFloat,\n         ty::ty_rptr(..) | ty::ty_uniq(..) | ty::ty_box(..) |\n         ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) |\n-        ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_bare_fn(..) => MonoNonNull,\n         // Is that everything?  Would closures or slices qualify?\n         _ => MonoBits\n@@ -970,7 +971,8 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n pub fn filename_and_line_num_from_span(bcx: &Block, span: Span)\n                                        -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n-    let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n+    let filename_cstr = C_cstr(bcx.ccx(),\n+                               token::intern_and_get_ident(loc.file.name));\n     let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)"}, {"sha": "a8b0da8026689bd321f2075f5e0bc68e1ea94588", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -57,12 +57,14 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n                                 ty_to_str(cx.tcx, lit_int_ty)))\n             }\n         }\n-        ast::LitFloat(fs, t) => C_floating(fs, Type::float_from_ty(t)),\n-        ast::LitFloatUnsuffixed(fs) => {\n+        ast::LitFloat(ref fs, t) => {\n+            C_floating(fs.get(), Type::float_from_ty(t))\n+        }\n+        ast::LitFloatUnsuffixed(ref fs) => {\n             let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n             match ty::get(lit_float_ty).sty {\n                 ty::ty_float(t) => {\n-                    C_floating(fs, Type::float_from_ty(t))\n+                    C_floating(fs.get(), Type::float_from_ty(t))\n                 }\n                 _ => {\n                     cx.sess.span_bug(lit.span,\n@@ -72,8 +74,8 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(b),\n         ast::LitNil => C_nil(),\n-        ast::LitStr(s, _) => C_str_slice(cx, s),\n-        ast::LitBinary(data) => C_binary_slice(cx, data),\n+        ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n+        ast::LitBinary(ref data) => C_binary_slice(cx, *data.borrow()),\n     }\n }\n \n@@ -312,7 +314,9 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n-          ast::ExprLit(lit) => (consts::const_lit(cx, e, *lit), true),\n+          ast::ExprLit(lit) => {\n+              (consts::const_lit(cx, e, (*lit).clone()), true)\n+          }\n           ast::ExprBinary(_, b, e1, e2) => {\n             let (te1, _) = const_expr(cx, e1, is_local);\n             let (te2, _) = const_expr(cx, e2, is_local);"}, {"sha": "2872d5566339bb0b5f65c795a2ac8b590267f11b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -19,12 +19,12 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::builder::Builder;\n-use middle::trans::debuginfo;\n use middle::trans::common::{C_i32, C_null};\n-use middle::ty;\n-\n+use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n+use middle::trans::base::{decl_crate_map};\n+use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n-\n+use middle::ty;\n use util::sha2::Sha256;\n \n use std::cell::{Cell, RefCell};\n@@ -33,10 +33,7 @@ use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::libc::c_uint;\n use syntax::ast;\n-\n-use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n-\n-use middle::trans::base::{decl_crate_map};\n+use syntax::parse::token::InternedString;\n \n pub struct CrateContext {\n      sess: session::Session,\n@@ -71,7 +68,7 @@ pub struct CrateContext {\n      // Cache generated vtables\n      vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n      // Cache of constant strings,\n-     const_cstr_cache: RefCell<HashMap<@str, ValueRef>>,\n+     const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,\n@@ -99,8 +96,8 @@ pub struct CrateContext {\n      llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n      adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n      symbol_hasher: RefCell<Sha256>,\n-     type_hashcodes: RefCell<HashMap<ty::t, @str>>,\n-     all_llvm_symbols: RefCell<HashSet<@str>>,\n+     type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n+     all_llvm_symbols: RefCell<HashSet<~str>>,\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n      stats: @Stats,"}, {"sha": "d361c36fbdacd3a8142af145318fdae2b17fe6f2", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -28,6 +28,8 @@ use syntax::ast;\n use syntax::ast::Name;\n use syntax::ast_util;\n use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::visit::Visitor;\n \n pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n@@ -332,7 +334,7 @@ pub fn trans_fail_expr<'a>(\n                 unpack_datum!(bcx, expr::trans_to_lvalue(bcx, arg_expr, \"fail\"));\n \n             if ty::type_is_str(arg_datum.ty) {\n-                let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);\n+                let (lldata, _) = arg_datum.get_vec_base_and_len(bcx);\n                 return trans_fail_value(bcx, sp_opt, lldata);\n             } else if bcx.unreachable.get() || ty::type_is_bot(arg_datum.ty) {\n                 return bcx;\n@@ -342,14 +344,14 @@ pub fn trans_fail_expr<'a>(\n                     ppaux::ty_to_str(tcx, arg_datum.ty));\n             }\n         }\n-        _ => trans_fail(bcx, sp_opt, @\"explicit failure\")\n+        _ => trans_fail(bcx, sp_opt, InternedString::new(\"explicit failure\"))\n     }\n }\n \n pub fn trans_fail<'a>(\n                   bcx: &'a Block<'a>,\n                   sp_opt: Option<Span>,\n-                  fail_str: @str)\n+                  fail_str: InternedString)\n                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n@@ -367,11 +369,11 @@ fn trans_fail_value<'a>(\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        (C_cstr(bcx.ccx(), loc.file.name),\n+        (C_cstr(bcx.ccx(), token::intern_and_get_ident(loc.file.name)),\n          loc.line as int)\n       }\n       None => {\n-        (C_cstr(bcx.ccx(), @\"<runtime>\"), 0)\n+        (C_cstr(bcx.ccx(), InternedString::new(\"<runtime>\")), 0)\n       }\n     };\n     let V_str = PointerCast(bcx, V_fail_str, Type::i8p());"}, {"sha": "2a2421077a8c6d66c8b26576f19ff6bef122f15c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -528,49 +528,8 @@ impl Datum<Lvalue> {\n         }\n     }\n \n-    pub fn get_vec_base_and_byte_len<'a>(\n-                                     &self,\n-                                     mut bcx: &'a Block<'a>,\n-                                     span: Span,\n-                                     expr_id: ast::NodeId,\n-                                     derefs: uint)\n-                                     -> (&'a Block<'a>, ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Performs rooting\n-        //! and write guards checks.\n-\n-        // only imp't for @[] and @str, but harmless\n-        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs);\n-        let (base, len) = self.get_vec_base_and_byte_len_no_root(bcx);\n-        (bcx, base, len)\n-    }\n-\n-    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: &Block)\n-                                             -> (ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Des not root\n-        //! nor perform write guard checks.\n-\n-        tvec::get_base_and_byte_len(bcx, self.val, self.ty)\n-    }\n-\n-    pub fn get_vec_base_and_len<'a>(&self,\n-                                    mut bcx: &'a Block<'a>,\n-                                    span: Span,\n-                                    expr_id: ast::NodeId,\n-                                    derefs: uint)\n-                                    -> (&'a Block<'a>, ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Performs rooting\n-        //! and write guards checks.\n-\n-        // only imp't for @[] and @str, but harmless\n-        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs);\n-        let (base, len) = self.get_vec_base_and_len_no_root(bcx);\n-        (bcx, base, len)\n-    }\n-\n-    pub fn get_vec_base_and_len_no_root<'a>(&self, bcx: &'a Block<'a>)\n-                                            -> (ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Des not root\n-        //! nor perform write guard checks.\n+    pub fn get_vec_base_and_len<'a>(&self, bcx: &'a Block<'a>) -> (ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair.\n \n         tvec::get_base_and_len(bcx, self.val, self.ty)\n     }"}, {"sha": "3cdb1c52d3c5beea3fdbd93ed65a222ab4accf01", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 55, "deletions": 62, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -622,7 +622,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     };\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n-    let mut function_name = token::ident_to_str(&ident).to_owned();\n+    let function_name_string = token::get_ident(ident.name);\n+    let mut function_name = function_name_string.get().to_owned();\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -791,7 +792,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n                 let ident = special_idents::type_self;\n \n-                let param_metadata = token::ident_to_str(&ident).with_c_str(|name| {\n+                let param_metadata_string = token::get_ident(ident.name);\n+                let param_metadata = param_metadata_string.get()\n+                                                          .with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -829,7 +832,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             // Again, only create type information if extra_debuginfo is enabled\n             if cx.sess.opts.extra_debuginfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let param_metadata = token::ident_to_str(&ident).with_c_str(|name| {\n+                let param_metadata_string = token::get_ident(ident.name);\n+                let param_metadata = param_metadata_string.get()\n+                                                          .with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -931,10 +936,11 @@ fn declare_local(bcx: &Block,\n                  span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n-    let filename = span_start(cx, span).file.name;\n+    let filename = span_start(cx, span).file.name.clone();\n     let file_metadata = file_metadata(cx, filename);\n \n-    let name: &str = token::ident_to_str(&variable_ident);\n+    let variable_ident_string = token::get_ident(variable_ident.name);\n+    let name: &str = variable_ident_string.get();\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n \n@@ -1139,9 +1145,10 @@ impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n                                   -> ~[MemberDescription] {\n         self.fields.map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n-                @\"\"\n+                ~\"\"\n             } else {\n-                token::ident_to_str(&field.ident)\n+                let string = token::get_ident(field.ident.name);\n+                string.get().to_str()\n             };\n \n             MemberDescription {\n@@ -1165,7 +1172,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id, span);\n \n-    let file_name = span_start(cx, definition_span).file.name;\n+    let file_name = span_start(cx, definition_span).file.name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n@@ -1244,7 +1251,7 @@ impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n                                   -> ~[MemberDescription] {\n         self.component_types.map(|&component_type| {\n             MemberDescription {\n-                name: @\"\",\n+                name: ~\"\",\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n@@ -1322,7 +1329,7 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n                 MemberDescription {\n-                    name: @\"\",\n+                    name: ~\"\",\n                     llvm_type: variant_llvm_type,\n                     type_metadata: variant_type_metadata,\n                     offset: FixedMemberOffset { bytes: 0 },\n@@ -1332,17 +1339,17 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n }\n \n struct EnumVariantMemberDescriptionFactory {\n-    args: ~[(@str, ty::t)],\n+    args: ~[(~str, ty::t)],\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n \n impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n-        self.args.iter().enumerate().map(|(i, &(name, ty))| {\n+        self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             MemberDescription {\n-                name: name,\n+                name: name.to_str(),\n                 llvm_type: type_of::type_of(cx, ty),\n                 type_metadata: match self.discriminant_type_metadata {\n                     Some(metadata) if i == 0 => metadata,\n@@ -1362,7 +1369,8 @@ fn describe_enum_variant(cx: &CrateContext,\n                          file_metadata: DIFile,\n                          span: Span)\n                       -> (DICompositeType, Type, @MemberDescriptionFactory) {\n-    let variant_name = token::ident_to_str(&variant_info.name);\n+    let variant_info_string = token::get_ident(variant_info.name.name);\n+    let variant_name = variant_info_string.get();\n     let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n                                           struct_def.packed);\n     // Could some consistency checks here: size, align, field count, discr type\n@@ -1395,19 +1403,24 @@ fn describe_enum_variant(cx: &CrateContext,\n \n     // Get the argument names from the enum variant info\n     let mut arg_names = match variant_info.arg_names {\n-        Some(ref names) => names.map(|ident| token::ident_to_str(ident)),\n-        None => variant_info.args.map(|_| @\"\")\n+        Some(ref names) => {\n+            names.map(|ident| {\n+                let string = token::get_ident(ident.name);\n+                string.get().to_str()\n+            })\n+        }\n+        None => variant_info.args.map(|_| ~\"\")\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field\n     if discriminant_type_metadata.is_some() {\n-        arg_names.insert(0, @\"\");\n+        arg_names.insert(0, ~\"\");\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: ~[(@str, ty::t)] = arg_names.iter()\n+    let args: ~[(~str, ty::t)] = arg_names.iter()\n         .zip(struct_def.fields.iter())\n-        .map(|(&s, &t)| (s, t))\n+        .map(|(s, &t)| (s.to_str(), t))\n         .collect();\n \n     let member_description_factory =\n@@ -1452,7 +1465,8 @@ fn prepare_enum_metadata(cx: &CrateContext,\n     let enumerators_metadata: ~[DIDescriptor] = variants\n         .iter()\n         .map(|v| {\n-            let name: &str = token::ident_to_str(&v.name);\n+            let string = token::get_ident(v.name.name);\n+            let name: &str = string.get();\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n             name.with_c_str(|name| {\n@@ -1580,7 +1594,7 @@ enum MemberOffset {\n }\n \n struct MemberDescription {\n-    name: @str,\n+    name: ~str,\n     llvm_type: Type,\n     type_metadata: DIType,\n     offset: MemberOffset,\n@@ -1737,31 +1751,31 @@ fn boxed_type_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: @\"refcnt\",\n+            name: ~\"refcnt\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"tydesc\",\n+            name: ~\"tydesc\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"prev\",\n+            name: ~\"prev\",\n             llvm_type: member_llvm_types[2],\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"next\",\n+            name: ~\"next\",\n             llvm_type: member_llvm_types[3],\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"val\",\n+            name: ~\"val\",\n             llvm_type: member_llvm_types[4],\n             type_metadata: content_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -1848,19 +1862,19 @@ fn vec_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: @\"fill\",\n+            name: ~\"fill\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"alloc\",\n+            name: ~\"alloc\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"elements\",\n+            name: ~\"elements\",\n             llvm_type: member_llvm_types[2],\n             type_metadata: array_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -1882,23 +1896,6 @@ fn vec_metadata(cx: &CrateContext,\n         span);\n }\n \n-fn boxed_vec_metadata(cx: &CrateContext,\n-                      element_type: ty::t,\n-                      span: Span)\n-                   -> DICompositeType {\n-    let element_llvm_type = type_of::type_of(cx, element_type);\n-    let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n-    let vec_metadata = vec_metadata(cx, element_type, span);\n-\n-    return boxed_type_metadata(\n-        cx,\n-        Some(vec_type_name),\n-        vec_llvm_type,\n-        vec_metadata,\n-        span);\n-}\n-\n fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n@@ -1917,13 +1914,13 @@ fn vec_slice_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: @\"data_ptr\",\n+            name: ~\"data_ptr\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"length\",\n+            name: ~\"length\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,\n@@ -1996,17 +1993,18 @@ fn trait_metadata(cx: &CrateContext,\n     // the trait's methods.\n     let path = ty::item_path(cx.tcx, def_id);\n     let ident = path.last().unwrap().ident();\n+    let ident_string = token::get_ident(ident.name);\n     let name = ppaux::trait_store_to_str(cx.tcx, trait_store) +\n                ppaux::mutability_to_str(mutability) +\n-               token::ident_to_str(&ident);\n+               ident_string.get();\n     // Add type and region parameters\n     let name = ppaux::parameterized(cx.tcx, name, &substs.regions,\n                                     substs.tps, def_id, true);\n \n     let (containing_scope, definition_span) =\n         get_namespace_and_span_for_item(cx, def_id, usage_site_span);\n \n-    let file_name = span_start(cx, definition_span).file.name;\n+    let file_name = span_start(cx, definition_span).file.name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n \n     let trait_llvm_type = type_of::type_of(cx, trait_type);\n@@ -2078,10 +2076,6 @@ fn type_metadata(cx: &CrateContext,\n                     let vec_metadata = vec_metadata(cx, i8_t, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n-                ty::vstore_box => {\n-                    let boxed_vec_metadata = boxed_vec_metadata(cx, i8_t, usage_site_span);\n-                    pointer_type_metadata(cx, t, boxed_vec_metadata)\n-                }\n                 ty::vstore_slice(_region) => {\n                     vec_slice_metadata(cx, t, i8_t, usage_site_span)\n                 }\n@@ -2102,10 +2096,6 @@ fn type_metadata(cx: &CrateContext,\n                     let vec_metadata = vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n-                ty::vstore_box => {\n-                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, usage_site_span);\n-                    pointer_type_metadata(cx, t, boxed_vec_metadata)\n-                }\n                 ty::vstore_slice(_) => {\n                     vec_slice_metadata(cx, t, mt.ty, usage_site_span)\n                 }\n@@ -2714,7 +2704,7 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprInlineAsm(ast::InlineAsm { inputs: ref inputs,\n                                                 outputs: ref outputs,\n                                                 .. }) => {\n-                // inputs, outputs: ~[(@str, @expr)]\n+                // inputs, outputs: ~[(~str, @expr)]\n                 for &(_, exp) in inputs.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n@@ -2755,8 +2745,10 @@ impl NamespaceTreeNode {\n                 }\n                 None => {}\n             }\n-            let name = token::ident_to_str(&node.ident);\n-            output.push_str(format!(\"{}{}\", name.len(), name));\n+            let string = token::get_ident(node.ident.name);\n+            output.push_str(format!(\"{}{}\",\n+                                    string.get().len(),\n+                                    string.get()));\n         }\n     }\n }\n@@ -2807,7 +2799,8 @@ fn namespace_for_item(cx: &CrateContext,\n                     Some(node) => node.scope,\n                     None => ptr::null()\n                 };\n-                let namespace_name = token::ident_to_str(&ident);\n+                let namespace_name_string = token::get_ident(ident.name);\n+                let namespace_name = namespace_name_string.get();\n \n                 let namespace_metadata = unsafe {\n                     namespace_name.with_c_str(|namespace_name| {"}, {"sha": "517f9e1a31d81c7ff643ed25b6b7419859edfc88", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -202,12 +202,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                     unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n                 }\n                 Some(AutoBorrowVec(..)) => {\n-                    unpack_datum!(bcx, auto_slice(bcx, adj.autoderefs,\n-                                                  expr, datum))\n+                    unpack_datum!(bcx, auto_slice(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowVecRef(..)) => {\n-                    unpack_datum!(bcx, auto_slice_and_ref(bcx, adj.autoderefs,\n-                                                          expr, datum))\n+                    unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowFn(..)) => {\n                     let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span,\n@@ -271,7 +269,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n     fn auto_slice<'a>(\n                   bcx: &'a Block<'a>,\n-                  autoderefs: uint,\n                   expr: &ast::Expr,\n                   datum: Datum<Expr>)\n                   -> DatumBlock<'a, Expr> {\n@@ -290,8 +287,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         let datum = unpack_datum!(\n             bcx, datum.to_lvalue_datum(bcx, \"auto_slice\", expr.id));\n \n-        let (bcx, base, len) =\n-            datum.get_vec_base_and_len(bcx, expr.span, expr.id, autoderefs+1);\n+        let (base, len) = datum.get_vec_base_and_len(bcx);\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n@@ -323,11 +319,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n     fn auto_slice_and_ref<'a>(\n                           bcx: &'a Block<'a>,\n-                          autoderefs: uint,\n                           expr: &ast::Expr,\n                           datum: Datum<Expr>)\n                           -> DatumBlock<'a, Expr> {\n-        let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n+        let DatumBlock { bcx, datum } = auto_slice(bcx, expr, datum);\n         auto_ref(bcx, datum, expr)\n     }\n \n@@ -519,19 +514,10 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprIndex(_, base, idx) => {\n             trans_index(bcx, expr, base, idx)\n         }\n-        ast::ExprVstore(contents, ast::ExprVstoreBox) => {\n-            fcx.push_ast_cleanup_scope(contents.id);\n-            let datum = unpack_datum!(\n-                bcx, tvec::trans_uniq_or_managed_vstore(bcx, heap_managed,\n-                                                        expr, contents));\n-            bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n-            DatumBlock(bcx, datum)\n-        }\n         ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n             let datum = unpack_datum!(\n-                bcx, tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n-                                                        expr, contents));\n+                bcx, tvec::trans_uniq_vstore(bcx, expr, contents));\n             bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n             DatumBlock(bcx, datum)\n         }\n@@ -543,9 +529,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             let heap = heap_exchange;\n             return trans_boxed_expr(bcx, box_ty, contents, contents_ty, heap)\n         }\n-        ast::ExprLit(lit) => {\n-            trans_immediate_lit(bcx, expr, *lit)\n-        }\n+        ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n         ast::ExprBinary(_, op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n             {\n@@ -636,8 +620,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n     let vt = tvec::vec_types(bcx, base_datum.ty);\n     base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n \n-    let (bcx, base, len) =\n-        base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id, 0);\n+    let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n     debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n     debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n@@ -836,8 +819,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => {\n-                    tvec::trans_lit_str(bcx, expr, s, dest)\n+                ast::LitStr(ref s, _) => {\n+                    tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n                 }\n                 _ => {\n                     bcx.tcx()\n@@ -1799,9 +1782,9 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>)\n             let external_srcs = ccx.external_srcs.borrow();\n             srccrate = match external_srcs.get().find(&bcx.fcx.id) {\n                 Some(&src) => {\n-                    ccx.sess.cstore.get_crate_data(src.crate).name\n+                    ccx.sess.cstore.get_crate_data(src.crate).name.clone()\n                 }\n-                None => ccx.link_meta.crateid.name.to_managed(),\n+                None => ccx.link_meta.crateid.name.to_str(),\n             };\n         };\n         let mut modpath = ~[PathMod(ccx.sess.ident_of(srccrate))];\n@@ -2032,4 +2015,3 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n }\n-"}, {"sha": "bc9dd767ec670348a31d72baa6c4f750e69ab413", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -31,7 +31,8 @@ use std::vec;\n use syntax::abi::{Cdecl, Aapcs, C, AbiSet, Win64};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{InternedString, special_idents};\n+use syntax::parse::token;\n use syntax::{ast};\n use syntax::{attr, ast_map};\n use util::ppaux::{Repr, UserString};\n@@ -135,7 +136,7 @@ pub fn register_foreign_item_fn(ccx: @CrateContext,\n     };\n \n     // Register the function as a C extern fn\n-    let lname = link_name(ccx, foreign_item);\n+    let lname = link_name(foreign_item);\n     let tys = foreign_types_for_id(ccx, foreign_item.id);\n \n     // Make sure the calling convention is right for variadic functions\n@@ -150,8 +151,12 @@ pub fn register_foreign_item_fn(ccx: @CrateContext,\n     let llfn;\n     {\n         let mut externs = ccx.externs.borrow_mut();\n-        llfn = base::get_extern_fn(externs.get(), ccx.llmod, lname,\n-                                   cc, llfn_ty, tys.fn_sig.output);\n+        llfn = base::get_extern_fn(externs.get(),\n+                                   ccx.llmod,\n+                                   lname.get(),\n+                                   cc,\n+                                   llfn_ty,\n+                                   tys.fn_sig.output);\n     };\n     add_argument_attributes(&tys, llfn);\n \n@@ -372,9 +377,9 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n             _ => ()\n         }\n \n-        let lname = link_name(ccx, foreign_item);\n+        let lname = link_name(foreign_item);\n         let mut item_symbols = ccx.item_symbols.borrow_mut();\n-        item_symbols.get().insert(foreign_item.id, lname.to_owned());\n+        item_symbols.get().insert(foreign_item.id, lname.get().to_owned());\n     }\n }\n \n@@ -726,10 +731,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n // This code is kind of a confused mess and needs to be reworked given\n // the massive simplifications that have occurred.\n \n-pub fn link_name(ccx: &CrateContext, i: @ast::ForeignItem) -> @str {\n+pub fn link_name(i: @ast::ForeignItem) -> InternedString {\n      match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n-        None => ccx.sess.str_of(i.ident),\n-        Some(ln) => ln,\n+        None => token::get_ident(i.ident.name),\n+        Some(ln) => ln.clone(),\n     }\n }\n "}, {"sha": "1bfbb3f99b1999f474b666cdc029d2e6896cf649", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -15,32 +15,32 @@\n \n use back::abi;\n use back::link::*;\n-use lib;\n use lib::llvm::{llvm, ValueRef, True};\n+use lib;\n use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n use middle::trans::adt;\n use middle::trans::base::*;\n+use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n-use middle::trans::build::*;\n use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n use middle::trans::tvec;\n+use middle::trans::type_::Type;\n use middle::trans::type_of::type_of;\n use middle::ty;\n-use util::ppaux;\n use util::ppaux::ty_to_short_str;\n-\n-use middle::trans::type_::Type;\n+use util::ppaux;\n \n use arena::TypedArena;\n use std::c_str::ToCStr;\n use std::cell::Cell;\n use std::libc::c_uint;\n use syntax::ast;\n+use syntax::parse::token;\n \n pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_free\");\n@@ -64,10 +64,7 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"take_ty\");\n     match ty::get(t).sty {\n-        ty::ty_box(_) |\n-        ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n-            incr_refcnt_of_boxed(bcx, v)\n-        }\n+        ty::ty_box(_) => incr_refcnt_of_boxed(bcx, v),\n         ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n             incr_refcnt_of_boxed(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]))\n         }\n@@ -113,10 +110,6 @@ fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n                 if !ty::type_needs_drop(tcx, typ) =>\n             return ty::mk_box(tcx, ty::mk_nil()),\n \n-            ty::ty_vec(mt, ty::vstore_box)\n-                if !ty::type_needs_drop(tcx, mt.ty) =>\n-            return ty::mk_box(tcx, ty::mk_nil()),\n-\n             ty::ty_uniq(typ)\n                 if !ty::type_needs_drop(tcx, typ) =>\n             return ty::mk_uniq(tcx, ty::mk_nil()),\n@@ -326,11 +319,6 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n         ty::ty_box(body_ty) => {\n             decr_refcnt_maybe_free(bcx, v0, Some(body_ty))\n         }\n-        ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n-            let unit_ty = ty::sequence_element_type(ccx.tcx, t);\n-            let unboxed_vec_ty = ty::mk_mut_unboxed_vec(ccx.tcx, unit_ty);\n-            decr_refcnt_maybe_free(bcx, v0, Some(unboxed_vec_ty))\n-        }\n         ty::ty_uniq(content_ty) => {\n             let llbox = Load(bcx, v0);\n             let not_null = IsNotNull(bcx, llbox);\n@@ -471,16 +459,17 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n \n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n-    let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n-    note_unique_llvm_symbol(ccx, name);\n+    let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n     let gvar = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }\n     });\n+    note_unique_llvm_symbol(ccx, name);\n \n-    let ty_name = C_str_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n+    let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx, t));\n+    let ty_name = C_str_slice(ccx, ty_name);\n \n     let inf = @tydesc_info {\n         ty: t,\n@@ -498,10 +487,10 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                         name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n-    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n+    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, ~\"glue_\" + name);\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n-    note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty, ty::mk_nil());\n+    note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;\n }\n "}, {"sha": "c60199b3c0d0ad4eaa4150dae1b699b7253df212", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -152,7 +152,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n \n             let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n             let num_type_params =\n-                impl_tpt.generics.type_param_defs.len() +\n+                impl_tpt.generics.type_param_defs().len() +\n                 mth.generics.ty_params.len();\n \n           if num_type_params == 0 {"}, {"sha": "49f1b073f873e1292232958e533570e007e92280", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -337,8 +337,10 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             Ret(bcx, td);\n         }\n         \"type_id\" => {\n-            let hash = ty::hash_crate_independent(ccx.tcx, substs.tys[0],\n-                                                  ccx.link_meta.crate_hash);\n+            let hash = ty::hash_crate_independent(\n+                ccx.tcx,\n+                substs.tys[0],\n+                ccx.link_meta.crate_hash.clone());\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n             let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);"}, {"sha": "b13a8800cee84d238d621e0df6c2adf689c0ba7a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -182,7 +182,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n     // out which impl the `Trait<T1...Tn>` bound on the type `self` was\n     // bound to.\n     let bound_index = ty::lookup_trait_def(bcx.tcx(), trait_id).\n-        generics.type_param_defs.len();\n+        generics.type_param_defs().len();\n \n     let mname = if method_id.crate == ast::LOCAL_CRATE {\n         {\n@@ -318,7 +318,7 @@ pub fn combine_impl_and_methods_tps(bcx: &Block,\n \n     let ccx = bcx.ccx();\n     let method = ty::method(ccx.tcx, mth_did);\n-    let n_m_tps = method.generics.type_param_defs.len();\n+    let n_m_tps = method.generics.type_param_defs().len();\n     let node_substs = node_id_type_params(bcx, callee_id);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs"}, {"sha": "b9d23c47fcdce3518b2dbb5c62bd8570b5b01c0f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -20,6 +20,7 @@ use middle::trans::datum::*;\n use middle::trans::glue;\n use middle::trans::machine;\n use middle::trans::meth;\n+use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -31,9 +32,8 @@ use std::vec;\n use syntax::ast::DefId;\n use syntax::ast;\n use syntax::ast_map::PathName;\n-use syntax::parse::token::special_idents;\n-\n-use middle::trans::type_::Type;\n+use syntax::parse::token::{InternedString, special_idents};\n+use syntax::parse::token;\n \n pub struct Reflector<'a> {\n     visitor_val: ValueRef,\n@@ -56,14 +56,14 @@ impl<'a> Reflector<'a> {\n         C_bool(b)\n     }\n \n-    pub fn c_slice(&mut self, s: @str) -> ValueRef {\n+    pub fn c_slice(&mut self, s: InternedString) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::ReStatic);\n         let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n-        let len = C_uint(bcx.ccx(), s.len());\n+        let len = C_uint(bcx.ccx(), s.get().len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n@@ -140,7 +140,6 @@ impl<'a> Reflector<'a> {\n             }\n             ty::vstore_slice(_) => (~\"slice\", ~[]),\n             ty::vstore_uniq => (~\"uniq\", ~[]),\n-            ty::vstore_box => (~\"box\", ~[])\n         }\n     }\n \n@@ -260,15 +259,19 @@ impl<'a> Reflector<'a> {\n                         fields[0].ident.name != special_idents::unnamed_field.name;\n               }\n \n-              let extra = ~[self.c_slice(ty_to_str(tcx, t).to_managed()),\n-                            self.c_bool(named_fields),\n-                            self.c_uint(fields.len())] + self.c_size_and_align(t);\n+              let extra = ~[\n+                  self.c_slice(token::intern_and_get_ident(ty_to_str(tcx,\n+                                                                     t))),\n+                  self.c_bool(named_fields),\n+                  self.c_uint(fields.len())\n+              ] + self.c_size_and_align(t);\n               self.bracketed(\"class\", extra, |this| {\n                   for (i, field) in fields.iter().enumerate() {\n-                      let extra = ~[this.c_uint(i),\n-                                    this.c_slice(bcx.ccx().sess.str_of(field.ident)),\n-                                    this.c_bool(named_fields)]\n-                          + this.c_mt(&field.mt);\n+                      let extra = ~[\n+                        this.c_uint(i),\n+                        this.c_slice(token::get_ident(field.ident.name)),\n+                        this.c_bool(named_fields)\n+                      ] + this.c_mt(&field.mt);\n                       this.visit(\"class_field\", extra);\n                   }\n               })\n@@ -330,7 +333,7 @@ impl<'a> Reflector<'a> {\n                 + self.c_size_and_align(t);\n             self.bracketed(\"enum\", enum_args, |this| {\n                 for (i, v) in variants.iter().enumerate() {\n-                    let name = ccx.sess.str_of(v.name);\n+                    let name = token::get_ident(v.name.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n@@ -352,7 +355,9 @@ impl<'a> Reflector<'a> {\n           }\n \n           ty::ty_trait(_, _, _, _, _) => {\n-              let extra = [self.c_slice(ty_to_str(tcx, t).to_managed())];\n+              let extra = [\n+                  self.c_slice(token::intern_and_get_ident(ty_to_str(tcx, t)))\n+              ];\n               self.visit(\"trait\", extra);\n           }\n "}, {"sha": "a0a1ff20a9a9c5d9e75b4983971b173f8444c584", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 56, "deletions": 79, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -31,6 +31,7 @@ use middle::ty;\n use util::ppaux::ty_to_str;\n \n use syntax::ast;\n+use syntax::parse::token::InternedString;\n \n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n@@ -43,9 +44,6 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n         ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) => {\n             ty::mk_uniq(tcx, unboxed_vec_ty)\n         }\n-        ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n-            ty::mk_box(tcx, unboxed_vec_ty)\n-        }\n         _ => tcx.sess.bug(\"non boxed-vec type \\\n                            in tvec::expand_boxed_vec_ty\")\n     }\n@@ -64,21 +62,6 @@ pub fn get_alloc(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-pub fn get_bodyptr(bcx: &Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n-    let vt = vec_types(bcx, t);\n-\n-    let managed = match ty::get(vt.vec_ty).sty {\n-      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => true,\n-      _ => false\n-    };\n-\n-    if managed {\n-        GEPi(bcx, vptr, [0u, abi::box_field_body])\n-    } else {\n-        vptr\n-    }\n-}\n-\n pub fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n@@ -127,11 +110,10 @@ pub fn alloc_uniq_raw<'a>(\n     alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n }\n \n-pub fn alloc_vec<'a>(\n+pub fn alloc_uniq_vec<'a>(\n                  bcx: &'a Block<'a>,\n                  unit_ty: ty::t,\n-                 elts: uint,\n-                 heap: heap)\n+                 elts: uint)\n                  -> Result<'a> {\n     let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n@@ -142,7 +124,7 @@ pub fn alloc_vec<'a>(\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n     let Result {bcx: bcx, val: vptr} =\n-        alloc_raw(bcx, unit_ty, fill, alloc, heap);\n+        alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange);\n     return rslt(bcx, vptr);\n }\n \n@@ -231,8 +213,11 @@ pub fn trans_slice_vstore<'a>(\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => {\n-                    return trans_lit_str(bcx, content_expr, s, dest);\n+                ast::LitStr(ref s, _) => {\n+                    return trans_lit_str(bcx,\n+                                         content_expr,\n+                                         s.clone(),\n+                                         dest)\n                 }\n                 _ => {}\n             }\n@@ -284,7 +269,7 @@ pub fn trans_slice_vstore<'a>(\n pub fn trans_lit_str<'a>(\n                      bcx: &'a Block<'a>,\n                      lit_expr: &ast::Expr,\n-                     str_lit: @str,\n+                     str_lit: InternedString,\n                      dest: Dest)\n                      -> &'a Block<'a> {\n     /*!\n@@ -301,7 +286,7 @@ pub fn trans_lit_str<'a>(\n         Ignore => bcx,\n         SaveIn(lldest) => {\n             unsafe {\n-                let bytes = str_lit.len();\n+                let bytes = str_lit.get().len();\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n@@ -316,66 +301,62 @@ pub fn trans_lit_str<'a>(\n }\n \n \n-pub fn trans_uniq_or_managed_vstore<'a>(bcx: &'a Block<'a>,\n-                                        heap: heap,\n-                                        vstore_expr: &ast::Expr,\n-                                        content_expr: &ast::Expr)\n-                                        -> DatumBlock<'a, Expr> {\n+pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n+                             vstore_expr: &ast::Expr,\n+                             content_expr: &ast::Expr)\n+                             -> DatumBlock<'a, Expr> {\n     /*!\n-     * @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n-     * appropriate heap and write the array elements into them.\n+     * ~[...] and ~\"...\" allocate boxes in the exchange heap and write\n+     * the array elements into them.\n      */\n \n-    debug!(\"trans_uniq_or_managed_vstore(vstore_expr={}, heap={:?})\",\n-           bcx.expr_to_str(vstore_expr), heap);\n+    debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_str(vstore_expr));\n     let fcx = bcx.fcx;\n \n     // Handle ~\"\".\n-    match heap {\n-        heap_exchange => {\n-            match content_expr.node {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitStr(s, _) => {\n-                            let llptrval = C_cstr(bcx.ccx(), s);\n-                            let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n-                            let llsizeval = C_uint(bcx.ccx(), s.len());\n-                            let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n-                            let lldestval = rvalue_scratch_datum(bcx, typ, \"\");\n-                            let alloc_fn = langcall(bcx,\n-                                                    Some(lit.span),\n-                                                    \"\",\n-                                                    StrDupUniqFnLangItem);\n-                            let bcx = callee::trans_lang_call(\n-                                bcx,\n-                                alloc_fn,\n-                                [ llptrval, llsizeval ],\n-                                Some(expr::SaveIn(lldestval.val))).bcx;\n-                            return DatumBlock(bcx, lldestval).to_expr_datumblock();\n-                        }\n-                        _ => {}\n-                    }\n+    match content_expr.node {\n+        ast::ExprLit(lit) => {\n+            match lit.node {\n+                ast::LitStr(ref s, _) => {\n+                    let llptrval = C_cstr(bcx.ccx(), (*s).clone());\n+                    let llptrval = PointerCast(bcx,\n+                                               llptrval,\n+                                               Type::i8p());\n+                    let llsizeval = C_uint(bcx.ccx(), s.get().len());\n+                    let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n+                    let lldestval = rvalue_scratch_datum(bcx,\n+                                                         typ,\n+                                                         \"\");\n+                    let alloc_fn = langcall(bcx,\n+                                            Some(lit.span),\n+                                            \"\",\n+                                            StrDupUniqFnLangItem);\n+                    let bcx = callee::trans_lang_call(\n+                        bcx,\n+                        alloc_fn,\n+                        [ llptrval, llsizeval ],\n+                        Some(expr::SaveIn(lldestval.val))).bcx;\n+                    return DatumBlock(bcx, lldestval).to_expr_datumblock();\n                 }\n                 _ => {}\n             }\n         }\n-        heap_exchange_closure => fail!(\"vectors use exchange_alloc\"),\n-        heap_managed => {}\n+        _ => {}\n     }\n \n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n \n-    let Result {bcx, val} = alloc_vec(bcx, vt.unit_ty, count, heap);\n+    let Result {bcx, val} = alloc_uniq_vec(bcx, vt.unit_ty, count);\n \n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_free_value(cleanup::CustomScope(temp_scope), val, heap);\n+    fcx.schedule_free_value(cleanup::CustomScope(temp_scope), val, heap_exchange);\n \n-    let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val, vt.vec_ty));\n+    let dataptr = get_dataptr(bcx, val);\n \n-    debug!(\"alloc_vec() returned val={}, dataptr={}\",\n+    debug!(\"alloc_uniq_vec() returned val={}, dataptr={}\",\n            bcx.val_to_str(val), bcx.val_to_str(dataptr));\n \n     let bcx = write_content(bcx, &vt, vstore_expr,\n@@ -405,15 +386,13 @@ pub fn write_content<'a>(\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => {\n+                ast::LitStr(ref s, _) => {\n                     match dest {\n-                        Ignore => {\n-                            return bcx;\n-                        }\n+                        Ignore => return bcx,\n                         SaveIn(lldest) => {\n-                            let bytes = s.len();\n+                            let bytes = s.get().len();\n                             let llbytes = C_uint(bcx.ccx(), bytes);\n-                            let llcstr = C_cstr(bcx.ccx(), s);\n+                            let llcstr = C_cstr(bcx.ccx(), (*s).clone());\n                             base::call_memcpy(bcx,\n                                               lldest,\n                                               llcstr,\n@@ -516,7 +495,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => s.len(),\n+                ast::LitStr(ref s, _) => s.get().len(),\n                 _ => {\n                     bcx.tcx().sess.span_bug(content_expr.span,\n                                             \"Unexpected evec content\")\n@@ -564,10 +543,9 @@ pub fn get_base_and_byte_len(bcx: &Block,\n             let len = Mul(bcx, count, vt.llunit_size);\n             (base, len)\n         }\n-        ty::vstore_uniq | ty::vstore_box => {\n+        ty::vstore_uniq => {\n             assert!(type_is_immediate(bcx.ccx(), vt.vec_ty));\n-            let llval = Load(bcx, llval);\n-            let body = get_bodyptr(bcx, llval, vec_ty);\n+            let body = Load(bcx, llval);\n             (get_dataptr(bcx, body), get_fill(bcx, body))\n         }\n     }\n@@ -604,10 +582,9 @@ pub fn get_base_and_len(bcx: &Block,\n             let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n             (base, count)\n         }\n-        ty::vstore_uniq | ty::vstore_box => {\n+        ty::vstore_uniq => {\n             assert!(type_is_immediate(bcx.ccx(), vt.vec_ty));\n-            let llval = Load(bcx, llval);\n-            let body = get_bodyptr(bcx, llval, vec_ty);\n+            let body = Load(bcx, llval);\n             (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n         }\n     }\n@@ -724,7 +701,7 @@ pub fn iter_vec_uniq<'r,\n                      f: iter_vec_block<'r,'b>)\n                      -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n-    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n+    let data_ptr = get_dataptr(bcx, vptr);\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n "}, {"sha": "0bc5ffd10196f78c4debeabcf7e1a43a5227a384", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -115,9 +115,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_float(t) => Type::float_from_ty(t),\n \n         ty::ty_str(ty::vstore_uniq) |\n-        ty::ty_str(ty::vstore_box) |\n         ty::ty_vec(_, ty::vstore_uniq) |\n-        ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_box(..) |\n         ty::ty_uniq(..) |\n         ty::ty_ptr(..) |\n@@ -221,13 +219,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         let name = llvm_type_name(cx, an_enum, did, substs.tps);\n         adt::incomplete_type_of(cx, repr, name)\n       }\n-      ty::ty_str(ty::vstore_box) => {\n-          Type::at_box(cx, Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n-      }\n-      ty::ty_vec(ref mt, ty::vstore_box) => {\n-          let e_ty = type_of(cx, mt.ty);\n-          Type::at_box(cx, Type::vec(cx.sess.targ_cfg.arch, &e_ty)).ptr_to()\n-      }\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n       }"}, {"sha": "0f4b11bde707b81b9240b0e1f59480c87dd6d7b2", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -46,10 +46,10 @@ fn root<'a, K:KindOps>(datum: &Datum<K>,\n                        _span: Span,\n                        root_key: root_map_key,\n                        root_info: RootInfo) -> &'a Block<'a> {\n-    //! In some cases, borrowck will decide that an @T/@[]/@str\n-    //! value must be rooted for the program to be safe.  In that\n-    //! case, we will call this function, which will stash a copy\n-    //! away until we exit the scope `scope_id`.\n+    //! In some cases, borrowck will decide that an @T value must be\n+    //! rooted for the program to be safe.  In that case, we will call\n+    //! this function, which will stash a copy away until we exit the\n+    //! scope `scope_id`.\n \n     debug!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n            root_key, root_info, datum.to_str(bcx.ccx()));\n@@ -62,4 +62,3 @@ fn root<'a, K:KindOps>(datum: &Datum<K>,\n         cleanup::AstScope(root_info.scope), (),\n         |(), bcx, llval| datum.shallow_copy_and_take(bcx, llval)).bcx\n }\n-"}, {"sha": "003a10eb48258967753a84b73c66fd3b19851db9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -34,6 +34,7 @@ use std::cmp;\n use std::hashmap::{HashMap, HashSet};\n use std::ops;\n use std::ptr::to_unsafe_ptr;\n+use std::rc::Rc;\n use std::to_bytes;\n use std::to_str::ToStr;\n use std::vec;\n@@ -129,7 +130,6 @@ pub struct mt {\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n-    vstore_box,\n     vstore_slice(Region)\n }\n \n@@ -226,10 +226,10 @@ pub enum AutoRef {\n     /// Convert from T to &T\n     AutoPtr(Region, ast::Mutability),\n \n-    /// Convert from @[]/~[]/&[] to &[] (or str)\n+    /// Convert from ~[]/&[] to &[] (or str)\n     AutoBorrowVec(Region, ast::Mutability),\n \n-    /// Convert from @[]/~[]/&[] to &&[] (or str)\n+    /// Convert from ~[]/&[] to &&[] (or str)\n     AutoBorrowVecRef(Region, ast::Mutability),\n \n     /// Convert from @fn()/~fn()/|| to ||\n@@ -291,7 +291,7 @@ pub struct ctxt_ {\n     freevars: RefCell<freevars::freevar_map>,\n     tcache: type_cache,\n     rcache: creader_cache,\n-    short_names_cache: RefCell<HashMap<t, @str>>,\n+    short_names_cache: RefCell<HashMap<t, ~str>>,\n     needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     tc_cache: RefCell<HashMap<uint, TypeContents>>,\n     ast_ty_to_ty_cache: RefCell<HashMap<NodeId, ast_ty_to_ty_cache_entry>>,\n@@ -870,15 +870,21 @@ pub struct RegionParameterDef {\n #[deriving(Clone)]\n pub struct Generics {\n     /// List of type parameters declared on the item.\n-    type_param_defs: @~[TypeParameterDef],\n+    type_param_defs: Rc<~[TypeParameterDef]>,\n \n     /// List of region parameters declared on the item.\n-    region_param_defs: @[RegionParameterDef],\n+    region_param_defs: Rc<~[RegionParameterDef]>,\n }\n \n impl Generics {\n     pub fn has_type_params(&self) -> bool {\n-        !self.type_param_defs.is_empty()\n+        !self.type_param_defs.borrow().is_empty()\n+    }\n+    pub fn type_param_defs<'a>(&'a self) -> &'a [TypeParameterDef] {\n+        self.type_param_defs.borrow().as_slice()\n+    }\n+    pub fn region_param_defs<'a>(&'a self) -> &'a [RegionParameterDef] {\n+        self.region_param_defs.borrow().as_slice()\n     }\n }\n \n@@ -1551,7 +1557,7 @@ pub fn type_is_box(ty: t) -> bool {\n \n pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_box(_) | ty_vec(_, vstore_box) | ty_str(vstore_box) => true,\n+      ty_box(_) => true,\n       _ => false\n     }\n }\n@@ -1675,10 +1681,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n           }\n           ty_uniq(_) |\n           ty_str(vstore_uniq) |\n-          ty_str(vstore_box) |\n-          ty_vec(_, vstore_uniq) |\n-          ty_vec(_, vstore_box)\n-          => {\n+          ty_vec(_, vstore_uniq) => {\n             // Once we're inside a box, the annihilator will find\n             // it and destroy it.\n             if !encountered_box {\n@@ -2021,10 +2024,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n-            ty_vec(mt, vstore_box) => {\n-                tc_mt(cx, mt, cache).managed_pointer()\n-            }\n-\n             ty_vec(ref mt, vstore_slice(r)) => {\n                 tc_ty(cx, mt.ty, cache).reference(\n                     borrowed_contents(r, mt.mutbl))\n@@ -2034,10 +2033,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 tc_mt(cx, mt, cache)\n             }\n \n-            ty_str(vstore_box) => {\n-                TC::Managed\n-            }\n-\n             ty_str(vstore_slice(r)) => {\n                 borrowed_contents(r, ast::MutImmutable)\n             }\n@@ -2523,8 +2518,8 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_type | ty_ptr(_) | ty_bare_fn(_) => result = true,\n       // Boxed types\n       ty_box(_) | ty_uniq(_) | ty_closure(_) |\n-      ty_str(vstore_uniq) | ty_str(vstore_box) |\n-      ty_vec(_, vstore_uniq) | ty_vec(_, vstore_box) |\n+      ty_str(vstore_uniq) |\n+      ty_vec(_, vstore_uniq) |\n       ty_trait(_, _, _, _, _) | ty_rptr(_,_) => result = false,\n       // Structural types\n       ty_enum(did, ref substs) => {\n@@ -3105,7 +3100,7 @@ pub fn expr_has_ty_params(cx: ctxt, expr: &ast::Expr) -> bool {\n pub fn method_call_type_param_defs(tcx: ctxt,\n                                    method_map: typeck::method_map,\n                                    id: ast::NodeId)\n-                                   -> Option<@~[TypeParameterDef]> {\n+                                   -> Option<Rc<~[TypeParameterDef]>> {\n     let method_map = method_map.borrow();\n     method_map.get().find(&id).map(|method| {\n         match method.origin {\n@@ -3125,12 +3120,12 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n             let trait_type_param_defs =\n-                lookup_trait_def(tcx, trt_id).generics.type_param_defs;\n-            @vec::append(\n-                (*trait_type_param_defs).clone(),\n-                *ty::trait_method(tcx,\n-                                  trt_id,\n-                                  n_mth).generics.type_param_defs)\n+                lookup_trait_def(tcx, trt_id).generics.type_param_defs();\n+            Rc::new(vec::append(\n+                trait_type_param_defs.to_owned(),\n+                ty::trait_method(tcx,\n+                                 trt_id,\n+                                 n_mth).generics.type_param_defs()))\n           }\n         }\n     })\n@@ -3296,7 +3291,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::ExprUnary(..) |\n         ast::ExprAddrOf(..) |\n         ast::ExprBinary(..) |\n-        ast::ExprVstore(_, ast::ExprVstoreBox) |\n         ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n             RvalueDatumExpr\n         }\n@@ -3344,9 +3338,10 @@ pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n+    let string = token::get_ident(name);\n     tcx.sess.bug(format!(\n         \"No field named `{}` found in the list of fields `{:?}`\",\n-        token::interner_get(name),\n+        string.get(),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n@@ -4165,7 +4160,7 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n     let mut found = false;\n     each_attr(tcx, did, |item| {\n-        if attr == item.name() {\n+        if item.name().equiv(&attr) {\n             found = true;\n             false\n         } else {\n@@ -4211,7 +4206,7 @@ pub fn lookup_field_type(tcx: ctxt,\n                Some(&ty_param_bounds_and_ty {ty, ..}) => ty,\n                None => {\n                    let tpt = csearch::get_field_type(tcx, struct_id, id);\n-                   tcache.get().insert(id, tpt);\n+                   tcache.get().insert(id, tpt.clone());\n                    tpt.ty\n                }\n             }\n@@ -4419,7 +4414,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n \n         fn fold_vstore(&mut self, vstore: vstore) -> vstore {\n             match vstore {\n-                vstore_fixed(..) | vstore_uniq | vstore_box => vstore,\n+                vstore_fixed(..) | vstore_uniq => vstore,\n                 vstore_slice(_) => vstore_slice(ReStatic)\n             }\n         }\n@@ -4834,7 +4829,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n \n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n+pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n     use std::hash::{SipState, Streaming};\n \n     let mut hash = SipState::new(0, 0);\n@@ -4856,7 +4851,6 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n         match v {\n             vstore_fixed(_) => hash.input([0]),\n             vstore_uniq => hash.input([1]),\n-            vstore_box => hash.input([2]),\n             vstore_slice(r) => {\n                 hash.input([3]);\n                 region(hash, r);\n@@ -4865,7 +4859,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n     };\n     let did = |hash: &mut SipState, did: DefId| {\n         let h = if ast_util::is_local(did) {\n-            local_hash\n+            local_hash.clone()\n         } else {\n             tcx.sess.cstore.get_crate_hash(did.crate)\n         };"}, {"sha": "63d6e2ae4428a53f3bcc98c3ee8f794df0c482d2", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -202,7 +202,6 @@ pub fn super_fold_vstore<T:TypeFolder>(this: &mut T,\n     match vstore {\n         ty::vstore_fixed(i) => ty::vstore_fixed(i),\n         ty::vstore_uniq => ty::vstore_uniq,\n-        ty::vstore_box => ty::vstore_box,\n         ty::vstore_slice(r) => ty::vstore_slice(this.fold_region(r)),\n     }\n }"}, {"sha": "90abdc5ac502febf95b8c7343ba856a802dd5ccc", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -170,7 +170,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let expected_num_region_params = decl_generics.region_param_defs.len();\n+    let expected_num_region_params = decl_generics.region_param_defs().len();\n     let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n         path.segments.last().unwrap().lifetimes.map(\n@@ -197,8 +197,8 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n \n     // Convert the type parameters supplied by the user.\n     let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).len();\n-    let formal_ty_param_count = decl_generics.type_param_defs.len();\n-    let required_ty_param_count = decl_generics.type_param_defs.iter()\n+    let formal_ty_param_count = decl_generics.type_param_defs().len();\n+    let required_ty_param_count = decl_generics.type_param_defs().iter()\n                                                .take_while(|x| x.default.is_none())\n                                                .len();\n     if supplied_ty_param_count < required_ty_param_count {\n@@ -228,7 +228,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                                  ~\"provided type arguments with defaults\");\n     }\n \n-    let defaults = decl_generics.type_param_defs.slice_from(supplied_ty_param_count)\n+    let defaults = decl_generics.type_param_defs().slice_from(supplied_ty_param_count)\n                                 .iter().map(|&x| x.default.unwrap());\n     let tps = path.segments.iter().flat_map(|s| s.types.iter())\n                             .map(|&a_t| ast_ty_to_ty(this, rscope, a_t))\n@@ -384,6 +384,23 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n \n+    enum PointerTy {\n+        Box,\n+        VStore(ty::vstore)\n+    }\n+    impl PointerTy {\n+        fn expect_vstore(&self, tcx: ty::ctxt, span: Span, ty: &str) -> ty::vstore {\n+            match *self {\n+                Box => {\n+                    tcx.sess.span_err(span, format!(\"managed {} are not supported\", ty));\n+                    // everything can be ~, so this is a worth substitute\n+                    ty::vstore_uniq\n+                }\n+                VStore(vst) => vst\n+            }\n+        }\n+    }\n+\n     // Handle @, ~, and & being able to mean strs and vecs.\n     // If a_seq_ty is a str or a vec, make it a str/vec.\n     // Also handle first-class trait types.\n@@ -392,17 +409,18 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                   this: &AC,\n                   rscope: &RS,\n                   a_seq_ty: &ast::MutTy,\n-                  vst: ty::vstore,\n+                  ptr_ty: PointerTy,\n                   constr: |ty::mt| -> ty::t)\n                   -> ty::t {\n         let tcx = this.tcx();\n-        debug!(\"mk_pointer(vst={:?})\", vst);\n+        debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n \n         match a_seq_ty.ty.node {\n             ast::TyVec(ty) => {\n+                let vst = ptr_ty.expect_vstore(tcx, a_seq_ty.ty.span, \"vectors\");\n                 let mut mt = ast_ty_to_mt(this, rscope, ty);\n                 if a_seq_ty.mutbl == ast::MutMutable {\n-                    mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n+                    mt.mutbl = ast::MutMutable;\n                 }\n                 debug!(\"&[]: vst={:?}\", vst);\n                 return ty::mk_vec(tcx, mt, vst);\n@@ -413,20 +431,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 // will run after this as long as the path isn't a trait.\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.get().find(&id) {\n-                    Some(&ast::DefPrimTy(ast::TyStr)) if a_seq_ty.mutbl == ast::MutImmutable => {\n+                    Some(&ast::DefPrimTy(ast::TyStr)) if\n+                            a_seq_ty.mutbl == ast::MutImmutable => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                        let vst = ptr_ty.expect_vstore(tcx, path.span, \"strings\");\n                         return ty::mk_str(tcx, vst);\n                     }\n                     Some(&ast::DefTrait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n                             this, rscope, trait_def_id, None, path);\n-                        let trait_store = match vst {\n-                            ty::vstore_box => ty::BoxTraitStore,\n-                            ty::vstore_uniq => ty::UniqTraitStore,\n-                            ty::vstore_slice(r) => {\n+                        let trait_store = match ptr_ty {\n+                            Box => ty::BoxTraitStore,\n+                            VStore(ty::vstore_uniq) => ty::UniqTraitStore,\n+                            VStore(ty::vstore_slice(r)) => {\n                                 ty::RegionTraitStore(r)\n                             }\n-                            ty::vstore_fixed(..) => {\n+                            VStore(ty::vstore_fixed(..)) => {\n                                 tcx.sess.span_err(\n                                     path.span,\n                                     \"@trait, ~trait or &trait are the only supported \\\n@@ -474,12 +494,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyBot => ty::mk_bot(),\n             ast::TyBox(ty) => {\n                 let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, ty::vstore_box,\n-                           |tmt| ty::mk_box(tcx, tmt.ty))\n+                mk_pointer(this, rscope, &mt, Box, |tmt| ty::mk_box(tcx, tmt.ty))\n             }\n             ast::TyUniq(ty) => {\n                 let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, ty::vstore_uniq,\n+                mk_pointer(this, rscope, &mt, VStore(ty::vstore_uniq),\n                            |tmt| ty::mk_uniq(tcx, tmt.ty))\n             }\n             ast::TyVec(ty) => {\n@@ -493,7 +512,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n+                mk_pointer(this, rscope, mt, VStore(ty::vstore_slice(r)),\n                            |tmt| ty::mk_rptr(tcx, r, tmt))\n             }\n             ast::TyTup(ref fields) => {"}, {"sha": "97b07186f4e099b600fd863e9b72202cb85896a9", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -147,7 +147,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                             ty::enum_variant_with_id(tcx, enm, var);\n                         let var_tpt = ty::lookup_item_type(tcx, var);\n                         vinfo.args.map(|t| {\n-                            if var_tpt.generics.type_param_defs.len() ==\n+                            if var_tpt.generics.type_param_defs().len() ==\n                                 expected_substs.tps.len()\n                             {\n                                 ty::subst(tcx, expected_substs, *t)\n@@ -172,7 +172,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                              None);\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n-                    arg_types = (*subpats).clone()\n+                    arg_types = subpats.clone()\n                                           .unwrap_or_default()\n                                           .map(|_| ty::mk_err());\n                 }\n@@ -221,7 +221,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     None);\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n-            arg_types = (*subpats).clone()\n+            arg_types = subpats.clone()\n                                   .unwrap_or_default()\n                                   .map(|_| ty::mk_err());\n         }\n@@ -339,9 +339,11 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             if found_fields.contains(&i) {\n                 continue;\n             }\n+\n+            let string = token::get_ident(field.name);\n             tcx.sess.span_err(span,\n                               format!(\"pattern does not mention field `{}`\",\n-                                   token::interner_get(field.name)));\n+                                      string.get()));\n         }\n     }\n }\n@@ -602,7 +604,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           ty::ty_vec(mt, vstore) => {\n             let region_var = match vstore {\n                 ty::vstore_slice(r) => r,\n-                ty::vstore_box | ty::vstore_uniq | ty::vstore_fixed(_) => {\n+                ty::vstore_uniq | ty::vstore_fixed(_) => {\n                     default_region_var\n                 }\n             };\n@@ -697,4 +699,3 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n \n #[deriving(Eq)]\n enum PointerKind { Send, Borrowed }\n-"}, {"sha": "d32d51c251a86277a3647183ee2169826a982e19", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -555,8 +555,10 @@ impl<'a> LookupContext<'a> {\n                 return; // already visited\n             }\n         }\n+\n+        let method_name = token::get_ident(self.m_name);\n         debug!(\"push_candidates_from_impl: {} {} {}\",\n-               token::interner_get(self.m_name),\n+               method_name.get(),\n                impl_info.ident.repr(self.tcx()),\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n@@ -697,7 +699,6 @@ impl<'a> LookupContext<'a> {\n         let tcx = self.tcx();\n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n-            ty_vec(mt, vstore_box) |\n             ty_vec(mt, vstore_uniq) |\n             ty_vec(mt, vstore_slice(_)) | // NDM(#3148)\n             ty_vec(mt, vstore_fixed(_)) => {\n@@ -726,7 +727,6 @@ impl<'a> LookupContext<'a> {\n                     })\n             }\n \n-            ty_str(vstore_box) |\n             ty_str(vstore_uniq) |\n             ty_str(vstore_fixed(_)) => {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n@@ -952,7 +952,7 @@ impl<'a> LookupContext<'a> {\n         // If they were not explicitly supplied, just construct fresh\n         // type variables.\n         let num_supplied_tps = self.supplied_tps.len();\n-        let num_method_tps = candidate.method_ty.generics.type_param_defs.len();\n+        let num_method_tps = candidate.method_ty.generics.type_param_defs().len();\n         let m_substs = {\n             if num_supplied_tps == 0u {\n                 self.fcx.infcx().next_ty_vars(num_method_tps)"}, {"sha": "43179aa3c928a3350aba1dac35d904a45f4e833d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -564,7 +564,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n         let param_env = ty::construct_parameter_environment(\n                 ccx.tcx,\n                 None,\n-                *fn_tpt.generics.type_param_defs,\n+                fn_tpt.generics.type_param_defs(),\n                 [],\n                 [],\n                 body.id);\n@@ -674,9 +674,9 @@ fn check_method_body(ccx: @CrateCtxt,\n         ty::construct_parameter_environment(\n             ccx.tcx,\n             self_bound,\n-            *item_generics.type_param_defs,\n-            *method_generics.type_param_defs,\n-            item_generics.region_param_defs,\n+            item_generics.type_param_defs(),\n+            method_generics.type_param_defs(),\n+            item_generics.region_param_defs(),\n             method.body.id);\n \n     // Compute the fty from point of view of inside fn\n@@ -776,7 +776,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n     debug!(\"compare_impl_method()\");\n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    let impl_tps = impl_generics.type_param_defs.len();\n+    let impl_tps = impl_generics.type_param_defs().len();\n \n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n@@ -812,8 +812,8 @@ fn compare_impl_method(tcx: ty::ctxt,\n         }\n     }\n \n-    let num_impl_m_type_params = impl_m.generics.type_param_defs.len();\n-    let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n+    let num_impl_m_type_params = impl_m.generics.type_param_defs().len();\n+    let num_trait_m_type_params = trait_m.generics.type_param_defs().len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n         tcx.sess.span_err(\n             impl_m_span,\n@@ -838,10 +838,10 @@ fn compare_impl_method(tcx: ty::ctxt,\n         return;\n     }\n \n-    for (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n-        // For each of the corresponding impl ty param's bounds...\n-        let impl_param_def = &impl_m.generics.type_param_defs[i];\n+    let it = trait_m.generics.type_param_defs().iter()\n+        .zip(impl_m.generics.type_param_defs().iter());\n \n+    for (i, (trait_param_def, impl_param_def)) in it.enumerate() {\n         // Check that the impl does not require any builtin-bounds\n         // that the trait does not guarantee:\n         let extra_bounds =\n@@ -886,15 +886,15 @@ fn compare_impl_method(tcx: ty::ctxt,\n     // impl type is \"&'a str\", then this would replace the self\n     // type with a free region `self`.\n     let dummy_impl_tps: ~[ty::t] =\n-        impl_generics.type_param_defs.iter().enumerate().\n+        impl_generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i, t.def_id)).\n         collect();\n     let dummy_method_tps: ~[ty::t] =\n-        impl_m.generics.type_param_defs.iter().enumerate().\n+        impl_m.generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n         collect();\n     let dummy_impl_regions: OptVec<ty::Region> =\n-        impl_generics.region_param_defs.iter().\n+        impl_generics.region_param_defs().iter().\n         map(|l| ty::ReFree(ty::FreeRegion {\n                 scope_id: impl_m_body_id,\n                 bound_region: ty::BrNamed(l.def_id, l.ident)})).\n@@ -1374,8 +1374,8 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n     let (n_tps, n_rps, raw_ty) = {\n         let ity = ty::lookup_item_type(tcx, did);\n-        (ity.generics.type_param_defs.len(),\n-         ity.generics.region_param_defs.len(),\n+        (ity.generics.type_param_defs().len(),\n+         ity.generics.region_param_defs().len(),\n          ity.ty)\n     };\n \n@@ -1419,10 +1419,10 @@ fn generics_of_static_method_container(type_context: ty::ctxt,\n                                        -> ty::Generics {\n     match provenance {\n         ast::FromTrait(trait_def_id) => {\n-            ty::lookup_trait_def(type_context, trait_def_id).generics\n+            ty::lookup_trait_def(type_context, trait_def_id).generics.clone()\n         }\n         ast::FromImpl(impl_def_id) => {\n-            ty::lookup_item_type(type_context, impl_def_id).generics\n+            ty::lookup_item_type(type_context, impl_def_id).generics.clone()\n         }\n     }\n }\n@@ -1485,7 +1485,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n \n             // Make sure lifetime parameterization agrees with the trait or\n             // implementation type.\n-            let trait_region_parameter_count = generics.region_param_defs.len();\n+            let trait_region_parameter_count = generics.region_param_defs().len();\n             let supplied_region_parameter_count = trait_segment.lifetimes.len();\n             if trait_region_parameter_count != supplied_region_parameter_count\n                 && supplied_region_parameter_count != 0 {\n@@ -1501,8 +1501,8 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n             // Make sure the number of type parameters supplied on the trait\n             // or implementation segment equals the number of type parameters\n             // on the trait or implementation definition.\n-            let formal_ty_param_count = generics.type_param_defs.len();\n-            let required_ty_param_count = generics.type_param_defs.iter()\n+            let formal_ty_param_count = generics.type_param_defs().len();\n+            let required_ty_param_count = generics.type_param_defs().iter()\n                                                   .take_while(|x| x.default.is_none())\n                                                   .len();\n             let supplied_ty_param_count = trait_segment.types.len();\n@@ -1517,7 +1517,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                 } else {\n                     \"s\"\n                 };\n-                let needs = if required_ty_param_count < generics.type_param_defs.len() {\n+                let needs = if required_ty_param_count < generics.type_param_defs().len() {\n                     \"needs at least\"\n                 } else {\n                     \"needs\"\n@@ -1539,7 +1539,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                 } else {\n                     \"s\"\n                 };\n-                let needs = if required_ty_param_count < generics.type_param_defs.len() {\n+                let needs = if required_ty_param_count < generics.type_param_defs().len() {\n                     \"needs at most\"\n                 } else {\n                     \"needs\"\n@@ -2335,9 +2335,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n+                        let string = token::get_ident(field);\n                         format!(\"attempted to take value of method `{}` on type `{}` \\\n-                              (try writing an anonymous function)\",\n-                             token::interner_get(field), actual)\n+                                 (try writing an anonymous function)\",\n+                                string.get(),\n+                                actual)\n                     },\n                     expr_t, None);\n             }\n@@ -2346,9 +2348,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n+                        let string = token::get_ident(field);\n                         format!(\"attempted access of field `{}` on type `{}`, \\\n-                              but no field with that name was found\",\n-                             token::interner_get(field), actual)\n+                                 but no field with that name was found\",\n+                                string.get(),\n+                                actual)\n                     },\n                     expr_t, None);\n             }\n@@ -2428,8 +2432,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                     let name = class_field.name;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n-                        missing_fields.push(\n-                            ~\"`\" + token::interner_get(name) + \"`\");\n+                        let string = token::get_ident(name);\n+                        missing_fields.push(~\"`\" + string.get() + \"`\");\n                     }\n                 }\n \n@@ -2461,8 +2465,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Look up the number of type parameters and the raw type, and\n         // determine whether the class is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, class_id);\n-        let type_parameter_count = item_type.generics.type_param_defs.len();\n-        let region_parameter_count = item_type.generics.region_param_defs.len();\n+        let type_parameter_count = item_type.generics.type_param_defs().len();\n+        let region_parameter_count = item_type.generics.region_param_defs().len();\n         let raw_type = item_type.ty;\n \n         // Generate the struct type.\n@@ -2519,8 +2523,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, enum_id);\n-        let type_parameter_count = item_type.generics.type_param_defs.len();\n-        let region_parameter_count = item_type.generics.region_param_defs.len();\n+        let type_parameter_count = item_type.generics.type_param_defs().len();\n+        let region_parameter_count = item_type.generics.region_param_defs().len();\n         let raw_type = item_type.ty;\n \n         // Generate the enum type.\n@@ -3706,8 +3710,8 @@ pub fn instantiate_path(fcx: @FnCtxt,\n                         node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n \n-    let ty_param_count = tpt.generics.type_param_defs.len();\n-    let ty_param_req = tpt.generics.type_param_defs.iter()\n+    let ty_param_count = tpt.generics.type_param_defs().len();\n+    let ty_param_req = tpt.generics.type_param_defs().iter()\n                                                    .take_while(|x| x.default.is_none())\n                                                    .len();\n     let mut ty_substs_len = 0;\n@@ -3722,7 +3726,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n     // determine the region parameters, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n-    let num_expected_regions = tpt.generics.region_param_defs.len();\n+    let num_expected_regions = tpt.generics.region_param_defs().len();\n     let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n         pth.segments.last().unwrap().lifetimes.map(\n@@ -3751,7 +3755,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n         ast::DefStaticMethod(_, provenance @ ast::FromTrait(_), _) => {\n             let generics = generics_of_static_method_container(fcx.ccx.tcx,\n                                                                provenance);\n-            (ty_param_count - 1, ty_param_req - 1, Some(generics.type_param_defs.len()))\n+            (ty_param_count - 1, ty_param_req - 1, Some(generics.type_param_defs().len()))\n         }\n         _ => (ty_param_count, ty_param_req, None),\n     };\n@@ -3796,7 +3800,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n         // at the appropriate position.\n         let mut result = ~[];\n         let mut pushed = false;\n-        let defaults = tpt.generics.type_param_defs.iter()\n+        let defaults = tpt.generics.type_param_defs().iter()\n                           .enumerate().filter_map(|(i, x)| {\n             match self_parameter_index {\n                 Some(index) if index == i => None,\n@@ -3905,7 +3909,6 @@ pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n                               -> ty::vstore {\n     match v {\n         ast::ExprVstoreUniq => ty::vstore_uniq,\n-        ast::ExprVstoreBox => ty::vstore_box,\n         ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n             match e.node {\n                 ast::ExprLit(..) |\n@@ -4301,7 +4304,7 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                     variadic: false}\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n-    let i_n_tps = i_ty.generics.type_param_defs.len();\n+    let i_n_tps = i_ty.generics.type_param_defs().len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, format!(\"intrinsic has wrong number \\\n                                          of type parameters: found {}, \\"}, {"sha": "6d46cd38087c73fb93d640d9a668670e8a9e610c", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -1215,9 +1215,7 @@ pub mod guarantor {\n             }\n             ty::ty_box(..) |\n             ty::ty_ptr(..) |\n-            ty::ty_vec(_, ty::vstore_box) |\n-            ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n-            ty::ty_str(ty::vstore_box) => {\n+            ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n                 OtherPointer\n             }\n             ty::ty_closure(ref closure_ty) => {\n@@ -1301,7 +1299,6 @@ pub mod guarantor {\n                 let guarantor1 = match vstore {\n                     ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,\n                     ty::vstore_slice(r) => Some(r),\n-                    ty::vstore_box => None\n                 };\n \n                 link_ref_bindings_in_pats(rcx, before, guarantor1);"}, {"sha": "4db43b2c9137089bdcd7fd7dd23c578569a011a3", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -423,7 +423,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         let im_generics =\n             ty::lookup_item_type(tcx, im.did).generics;\n         let subres = lookup_vtables(vcx, location_info,\n-                                    *im_generics.type_param_defs, &substs,\n+                                    im_generics.type_param_defs(), &substs,\n                                     is_early);\n \n \n@@ -688,12 +688,12 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n-            if has_trait_bounds(*item_ty.generics.type_param_defs) {\n+            if has_trait_bounds(item_ty.generics.type_param_defs()) {\n                 debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n-                       item_ty.generics.type_param_defs.repr(fcx.tcx()));\n+                       item_ty.generics.type_param_defs().repr(fcx.tcx()));\n                 let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           *item_ty.generics.type_param_defs,\n+                                           item_ty.generics.type_param_defs(),\n                                            substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, ex.id, vtbls);\n@@ -717,11 +717,11 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n           Some(type_param_defs) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n-            if has_trait_bounds(*type_param_defs) {\n+            if has_trait_bounds(*type_param_defs.borrow()) {\n                 let substs = fcx.node_ty_substs(callee_id);\n                 let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           *type_param_defs, &substs, is_early);\n+                                           *type_param_defs.borrow(), &substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, callee_id, vtbls);\n                 }\n@@ -784,9 +784,9 @@ pub fn resolve_impl(ccx: @CrateCtxt,\n     let param_env = ty::construct_parameter_environment(\n         ccx.tcx,\n         None,\n-        *impl_generics.type_param_defs,\n+        impl_generics.type_param_defs(),\n         [],\n-        impl_generics.region_param_defs,\n+        impl_generics.region_param_defs(),\n         impl_item.id);\n \n     let impl_trait_ref = @impl_trait_ref.subst(ccx.tcx, &param_env.free_substs);\n@@ -800,7 +800,7 @@ pub fn resolve_impl(ccx: @CrateCtxt,\n     let trait_def = ty::lookup_trait_def(ccx.tcx, impl_trait_ref.def_id);\n     let vtbls = lookup_vtables(&vcx,\n                                &loc_info,\n-                               *trait_def.generics.type_param_defs,\n+                               trait_def.generics.type_param_defs(),\n                                &impl_trait_ref.substs,\n                                false);\n "}, {"sha": "5ca879fea4a67cd472760fd25195a9bf8abd7b4a", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -47,13 +47,13 @@ use syntax::visit;\n \n use std::cell::RefCell;\n use std::hashmap::HashSet;\n-use std::result::Ok;\n+use std::rc::Rc;\n use std::vec;\n \n pub struct UniversalQuantificationResult {\n     monotype: t,\n     type_variables: ~[ty::t],\n-    type_param_defs: @~[ty::TypeParameterDef]\n+    type_param_defs: Rc<~[ty::TypeParameterDef]>\n }\n \n pub fn get_base_type(inference_context: @InferCtxt,\n@@ -356,11 +356,11 @@ impl CoherenceChecker {\n             // construct the polytype for the method based on the method_ty\n             let new_generics = ty::Generics {\n                 type_param_defs:\n-                    @vec::append(\n-                        (*impl_poly_type.generics.type_param_defs).clone(),\n-                        *new_method_ty.generics.type_param_defs),\n+                    Rc::new(vec::append(\n+                        impl_poly_type.generics.type_param_defs().to_owned(),\n+                            new_method_ty.generics.type_param_defs())),\n                 region_param_defs:\n-                    impl_poly_type.generics.region_param_defs\n+                    impl_poly_type.generics.region_param_defs.clone()\n             };\n             let new_polytype = ty::ty_param_bounds_and_ty {\n                 generics: new_generics,\n@@ -449,7 +449,7 @@ impl CoherenceChecker {\n                     let polytype_b = self.get_self_type_for_implementation(\n                             implementation_b);\n \n-                    if self.polytypes_unify(polytype_a, polytype_b) {\n+                    if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n                         let session = self.crate_context.tcx.sess;\n                         session.span_err(\n                             self.span_of_impl(implementation_b),\n@@ -497,13 +497,13 @@ impl CoherenceChecker {\n     pub fn universally_quantify_polytype(&self,\n                                          polytype: ty_param_bounds_and_ty)\n                                          -> UniversalQuantificationResult {\n-        let region_parameter_count = polytype.generics.region_param_defs.len();\n+        let region_parameter_count = polytype.generics.region_param_defs().len();\n         let region_parameters =\n             self.inference_context.next_region_vars(\n                 infer::BoundRegionInCoherence,\n                 region_parameter_count);\n \n-        let bounds_count = polytype.generics.type_param_defs.len();\n+        let bounds_count = polytype.generics.type_param_defs().len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n@@ -518,7 +518,7 @@ impl CoherenceChecker {\n         UniversalQuantificationResult {\n             monotype: monotype,\n             type_variables: substitutions.tps,\n-            type_param_defs: polytype.generics.type_param_defs\n+            type_param_defs: polytype.generics.type_param_defs.clone()\n         }\n     }\n \n@@ -770,15 +770,15 @@ pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n     // determine how many type parameters were declared on the impl\n     let num_impl_type_parameters = {\n         let impl_polytype = ty::lookup_item_type(tcx, impl_id);\n-        impl_polytype.generics.type_param_defs.len()\n+        impl_polytype.generics.type_param_defs().len()\n     };\n \n     // determine how many type parameters appear on the trait\n     let num_trait_type_parameters = trait_ref.substs.tps.len();\n \n     // the current method type has the type parameters from the trait + method\n     let num_method_type_parameters =\n-        num_trait_type_parameters + method.generics.type_param_defs.len();\n+        num_trait_type_parameters + method.generics.type_param_defs().len();\n \n     // the new method type will have the type parameters from the impl + method\n     let combined_tps = vec::from_fn(num_method_type_parameters, |i| {\n@@ -789,7 +789,7 @@ pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n             // replace type parameters that belong to method with another\n             // type parameter, this time with the index adjusted\n             let method_index = i - num_trait_type_parameters;\n-            let type_param_def = &method.generics.type_param_defs[method_index];\n+            let type_param_def = &method.generics.type_param_defs()[method_index];\n             let new_index = num_impl_type_parameters + method_index;\n             ty::mk_param(tcx, new_index, type_param_def.def_id)\n         }"}, {"sha": "c1a6e53069efeb3ff2a08fd06a1ce543cd629b65", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -44,6 +44,7 @@ use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n use util::ppaux;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n use std::vec;\n use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -285,28 +286,28 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let dummy_defid = ast::DefId {crate: 0, node: 0};\n \n         // Represents [A',B',C']\n-        let num_trait_bounds = trait_ty_generics.type_param_defs.len();\n+        let num_trait_bounds = trait_ty_generics.type_param_defs().len();\n         let non_shifted_trait_tps = vec::from_fn(num_trait_bounds, |i| {\n-            ty::mk_param(tcx, i, trait_ty_generics.type_param_defs[i].def_id)\n+            ty::mk_param(tcx, i, trait_ty_generics.type_param_defs()[i].def_id)\n         });\n \n         // Represents [D']\n         let self_param = ty::mk_param(tcx, num_trait_bounds,\n                                       dummy_defid);\n \n         // Represents [E',F',G']\n-        let num_method_bounds = m.generics.type_param_defs.len();\n+        let num_method_bounds = m.generics.type_param_defs().len();\n         let shifted_method_tps = vec::from_fn(num_method_bounds, |i| {\n             ty::mk_param(tcx, i + num_trait_bounds + 1,\n-                         m.generics.type_param_defs[i].def_id)\n+                         m.generics.type_param_defs()[i].def_id)\n         });\n \n         // Convert the regions 'a, 'b, 'c defined on the trait into\n         // bound regions on the fn. Note that because these appear in the\n         // bound for `Self` they must be early bound.\n-        let new_early_region_param_defs = trait_ty_generics.region_param_defs;\n+        let new_early_region_param_defs = trait_ty_generics.region_param_defs.clone();\n         let rps_from_trait =\n-            trait_ty_generics.region_param_defs.iter().\n+            trait_ty_generics.region_param_defs().iter().\n             enumerate().\n             map(|(index,d)| ty::ReEarlyBound(d.def_id.node, index, d.ident)).\n             collect();\n@@ -334,7 +335,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let mut new_type_param_defs = ~[];\n         let substd_type_param_defs =\n             trait_ty_generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(*substd_type_param_defs);\n+        new_type_param_defs.push_all(*substd_type_param_defs.borrow());\n \n         // add in the \"self\" type parameter\n         let self_trait_def = get_trait_def(ccx, local_def(trait_id));\n@@ -351,7 +352,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         // add in the type parameters from the method\n         let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(*substd_type_param_defs);\n+        new_type_param_defs.push_all(*substd_type_param_defs.borrow());\n \n         debug!(\"static method {} type_param_defs={} ty={}, substs={}\",\n                m.def_id.repr(tcx),\n@@ -363,7 +364,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         tcache.get().insert(m.def_id,\n                           ty_param_bounds_and_ty {\n                               generics: ty::Generics {\n-                                  type_param_defs: @new_type_param_defs,\n+                                  type_param_defs: Rc::new(new_type_param_defs),\n                                   region_param_defs: new_early_region_param_defs\n                               },\n                               ty: ty\n@@ -383,7 +384,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n         let fty = astconv::ty_of_method(this, *m_id, *m_purity, trait_self_ty,\n                                         *m_explicit_self, m_decl);\n-        let num_trait_type_params = trait_generics.type_param_defs.len();\n+        let num_trait_type_params = trait_generics.type_param_defs().len();\n         ty::Method::new(\n             *m_ident,\n             // FIXME(#5121) -- distinguish early vs late lifetime params\n@@ -466,7 +467,7 @@ fn convert_methods(ccx: &CrateCtxt,\n {\n     let tcx = ccx.tcx;\n     for m in ms.iter() {\n-        let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs.len();\n+        let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs().len();\n         let m_ty_generics = ty_generics(ccx, &m.generics, num_rcvr_ty_params);\n         let mty = @ty_of_method(ccx,\n                                 container,\n@@ -489,10 +490,10 @@ fn convert_methods(ccx: &CrateCtxt,\n                 // itself\n                 ty_param_bounds_and_ty {\n                     generics: ty::Generics {\n-                        type_param_defs: @vec::append(\n-                            (*rcvr_ty_generics.type_param_defs).clone(),\n-                            *m_ty_generics.type_param_defs),\n-                        region_param_defs: rcvr_ty_generics.region_param_defs,\n+                        type_param_defs: Rc::new(vec::append(\n+                            rcvr_ty_generics.type_param_defs().to_owned(),\n+                            m_ty_generics.type_param_defs())),\n+                        region_param_defs: rcvr_ty_generics.region_param_defs.clone(),\n                     },\n                     ty: fty\n                 });\n@@ -574,7 +575,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             let mut tcache = tcx.tcache.borrow_mut();\n             tcache.get().insert(local_def(it.id),\n                               ty_param_bounds_and_ty {\n-                                  generics: i_ty_generics,\n+                                  generics: i_ty_generics.clone(),\n                                   ty: selfty});\n         }\n \n@@ -637,7 +638,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n         {\n             let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt);\n+            tcache.get().insert(local_def(it.id), tpt.clone());\n         }\n \n         convert_struct(ccx, struct_def, tpt, it.id);\n@@ -816,7 +817,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n     {\n         let tcache = tcx.tcache.borrow();\n         match tcache.get().find(&def_id) {\n-            Some(&tpt) => return tpt,\n+            Some(tpt) => return tpt.clone(),\n             _ => {}\n         }\n     }\n@@ -826,7 +827,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             let tpt = no_params(typ);\n \n             let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt);\n+            tcache.get().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemFn(decl, purity, abi, ref generics, _) => {\n@@ -838,8 +839,8 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                                               decl);\n             let tpt = ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n-                    type_param_defs: ty_generics.type_param_defs,\n-                    region_param_defs: @[],\n+                    type_param_defs: ty_generics.type_param_defs.clone(),\n+                    region_param_defs: Rc::new(~[]),\n                 },\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n@@ -849,14 +850,14 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                     ppaux::ty_to_str(tcx, tpt.ty));\n \n             let mut tcache = ccx.tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt);\n+            tcache.get().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemTy(t, ref generics) => {\n             {\n                 let mut tcache = tcx.tcache.borrow_mut();\n                 match tcache.get().find(&local_def(it.id)) {\n-                    Some(&tpt) => return tpt,\n+                    Some(tpt) => return tpt.clone(),\n                     None => { }\n                 }\n             }\n@@ -870,7 +871,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             };\n \n             let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt);\n+            tcache.get().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemEnum(_, ref generics) => {\n@@ -884,7 +885,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             };\n \n             let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt);\n+            tcache.get().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemTrait(..) => {\n@@ -902,7 +903,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             };\n \n             let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt);\n+            tcache.get().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n@@ -925,8 +926,8 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n         ast::ForeignItemStatic(t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n-                    type_param_defs: @~[],\n-                    region_param_defs: @[],\n+                    type_param_defs: Rc::new(~[]),\n+                    region_param_defs: Rc::new(~[]),\n                 },\n                 ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n             }\n@@ -938,11 +939,11 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                    generics: &ast::Generics,\n                    base_index: uint) -> ty::Generics {\n     return ty::Generics {\n-        region_param_defs: generics.lifetimes.iter().map(|l| {\n+        region_param_defs: Rc::new(generics.lifetimes.iter().map(|l| {\n                 ty::RegionParameterDef { ident: l.ident,\n                                          def_id: local_def(l.id) }\n-            }).collect(),\n-        type_param_defs: @generics.ty_params.mapi_to_vec(|offset, param| {\n+            }).collect()),\n+        type_param_defs: Rc::new(generics.ty_params.mapi_to_vec(|offset, param| {\n             let existing_def_opt = {\n                 let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n                 ty_param_defs.get().find(&param.id).map(|def| *def)\n@@ -969,7 +970,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                     def\n                 }\n             }\n-        })\n+        }))\n     };\n \n     fn compute_bounds(\n@@ -1040,7 +1041,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     };\n \n     let mut tcache = ccx.tcx.tcache.borrow_mut();\n-    tcache.get().insert(def_id, tpt);\n+    tcache.get().insert(def_id, tpt.clone());\n     return tpt;\n }\n \n@@ -1049,11 +1050,11 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n                       self_ty: Option<ty::t>) -> ty::substs\n {\n     let params: ~[ty::t] =\n-        ty_generics.type_param_defs.iter().enumerate().map(\n+        ty_generics.type_param_defs().iter().enumerate().map(\n             |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n \n     let regions: OptVec<ty::Region> =\n-        ty_generics.region_param_defs.iter().enumerate().map(\n+        ty_generics.region_param_defs().iter().enumerate().map(\n             |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.ident)).collect();\n \n     substs {regions: ty::NonerasedRegions(regions),"}, {"sha": "adf36cf973bac44e6cd78ef7e69b811a47827727", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -67,7 +67,7 @@ we may want to adjust precisely when coercions occur.\n \n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn, AutoBorrowObj};\n use middle::ty::{AutoDerefRef};\n-use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n+use middle::ty::{vstore_slice, vstore_uniq};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n@@ -272,7 +272,6 @@ impl Coerce {\n                b.inf_str(self.get_ref().infcx));\n \n         match *sty_a {\n-            ty::ty_str(vstore_box) |\n             ty::ty_str(vstore_uniq) => {}\n             _ => {\n                 return self.subtype(a, b);"}, {"sha": "a6fc91899f06732734d3eb452772f145fba7da4b", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -70,6 +70,7 @@ use util::ppaux;\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n+use std::rc::Rc;\n use std::result;\n use extra::list::List;\n use extra::list;\n@@ -271,8 +272,8 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: @~[],\n-                                region_param_defs: @[]},\n+        generics: ty::Generics {type_param_defs: Rc::new(~[]),\n+                                region_param_defs: Rc::new(~[])},\n         ty: t\n     }\n }"}, {"sha": "51364addfed23098333b725c269777f044f9b413", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -736,7 +736,7 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_region(r, contra);\n             }\n \n-            ty::vstore_fixed(_) | ty::vstore_uniq | ty::vstore_box => {\n+            ty::vstore_fixed(_) | ty::vstore_uniq => {\n             }\n         }\n     }\n@@ -750,7 +750,7 @@ impl<'a> ConstraintContext<'a> {\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n \n-        for (i, p) in generics.type_param_defs.iter().enumerate() {\n+        for (i, p) in generics.type_param_defs().iter().enumerate() {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam, i);\n             let variance_i = self.xform(variance, variance_decl);\n@@ -760,7 +760,7 @@ impl<'a> ConstraintContext<'a> {\n         match substs.regions {\n             ty::ErasedRegions => {}\n             ty::NonerasedRegions(ref rps) => {\n-                for (i, p) in generics.region_param_defs.iter().enumerate() {\n+                for (i, p) in generics.region_param_defs().iter().enumerate() {\n                     let variance_decl =\n                         self.declared_variance(p.def_id, def_id, RegionParam, i);\n                     let variance_i = self.xform(variance, variance_decl);"}, {"sha": "eba99c7fb5a0250177263136012b04495161a3ef", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -260,7 +260,6 @@ pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n     match vs {\n       ty::vstore_fixed(n) => format!(\"{}\", n),\n       ty::vstore_uniq => ~\"~\",\n-      ty::vstore_box => ~\"@\",\n       ty::vstore_slice(r) => region_ptr_to_str(cx, r)\n     }\n }\n@@ -522,11 +521,11 @@ pub fn parameterized(cx: ctxt,\n     }\n \n     let generics = if is_trait {\n-        ty::lookup_trait_def(cx, did).generics\n+        ty::lookup_trait_def(cx, did).generics.clone()\n     } else {\n         ty::lookup_item_type(cx, did).generics\n     };\n-    let ty_params = generics.type_param_defs.iter();\n+    let ty_params = generics.type_param_defs().iter();\n     let num_defaults = ty_params.zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n         match def.default {\n             Some(default) => default == actual,\n@@ -789,8 +788,8 @@ impl Repr for ty::ty_param_bounds_and_ty {\n impl Repr for ty::Generics {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         format!(\"Generics(type_param_defs: {}, region_param_defs: {})\",\n-                self.type_param_defs.repr(tcx),\n-                self.region_param_defs.repr(tcx))\n+                self.type_param_defs().repr(tcx),\n+                self.region_param_defs().repr(tcx))\n     }\n }\n \n@@ -824,7 +823,8 @@ impl Repr for ty::Method {\n \n impl Repr for ast::Ident {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        token::ident_to_str(self).to_owned()\n+        let string = token::get_ident(self.name);\n+        string.get().to_str()\n     }\n }\n "}, {"sha": "8220be1046166106e5eaac81afcbab4530d38879", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -11,15 +11,15 @@\n //! This module contains the \"cleaned\" pieces of the AST, and the functions\n //! that clean them.\n \n-use its = syntax::parse::token::ident_to_str;\n-\n use syntax;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttributeMethods;\n use syntax::codemap::Pos;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n \n use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n@@ -223,9 +223,13 @@ pub enum Attribute {\n impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self) -> Attribute {\n         match self.node {\n-            ast::MetaWord(s) => Word(s.to_owned()),\n-            ast::MetaList(ref s, ref l) => List(s.to_owned(), l.clean()),\n-            ast::MetaNameValue(s, ref v) => NameValue(s.to_owned(), lit_to_str(v))\n+            ast::MetaWord(ref s) => Word(s.get().to_owned()),\n+            ast::MetaList(ref s, ref l) => {\n+                List(s.get().to_owned(), l.clean())\n+            }\n+            ast::MetaNameValue(ref s, ref v) => {\n+                NameValue(s.get().to_owned(), lit_to_str(v))\n+            }\n         }\n     }\n }\n@@ -238,21 +242,24 @@ impl Clean<Attribute> for ast::Attribute {\n \n // This is a rough approximation that gets us what we want.\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n-    fn name(&self) -> @str {\n+    fn name(&self) -> InternedString {\n         match **self {\n-            Word(ref n) | List(ref n, _) | NameValue(ref n, _) =>\n-                n.to_managed()\n+            Word(ref n) | List(ref n, _) | NameValue(ref n, _) => {\n+                token::intern_and_get_ident(*n)\n+            }\n         }\n     }\n \n-    fn value_str(&self) -> Option<@str> {\n+    fn value_str(&self) -> Option<InternedString> {\n         match **self {\n-            NameValue(_, ref v) => Some(v.to_managed()),\n+            NameValue(_, ref v) => Some(token::intern_and_get_ident(*v)),\n             _ => None,\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n-    fn name_str_pair(&self) -> Option<(@str, @str)> { None }\n+    fn name_str_pair(&self) -> Option<(InternedString, InternedString)> {\n+        None\n+    }\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -867,24 +874,25 @@ impl Clean<PathSegment> for ast::PathSegment {\n }\n \n fn path_to_str(p: &ast::Path) -> ~str {\n-    use syntax::parse::token::interner_get;\n+    use syntax::parse::token;\n \n     let mut s = ~\"\";\n     let mut first = true;\n-    for i in p.segments.iter().map(|x| interner_get(x.identifier.name)) {\n+    for i in p.segments.iter().map(|x| token::get_ident(x.identifier.name)) {\n         if !first || p.global {\n             s.push_str(\"::\");\n         } else {\n             first = false;\n         }\n-        s.push_str(i);\n+        s.push_str(i.get());\n     }\n     s\n }\n \n impl Clean<~str> for ast::Ident {\n     fn clean(&self) -> ~str {\n-        its(self).to_owned()\n+        let string = token::get_ident(self.name);\n+        string.get().to_owned()\n     }\n }\n \n@@ -1030,8 +1038,13 @@ pub enum ViewItemInner {\n impl Clean<ViewItemInner> for ast::ViewItem_ {\n     fn clean(&self) -> ViewItemInner {\n         match self {\n-            &ast::ViewItemExternMod(ref i, ref p, ref id) =>\n-                ExternMod(i.clean(), p.map(|(ref x, _)| x.to_owned()), *id),\n+            &ast::ViewItemExternMod(ref i, ref p, ref id) => {\n+                let string = match *p {\n+                    None => None,\n+                    Some((ref x, _)) => Some(x.get().to_owned()),\n+                };\n+                ExternMod(i.clean(), string, *id)\n+            }\n             &ast::ViewItemUse(ref vp) => Import(vp.clean())\n         }\n     }\n@@ -1137,14 +1150,14 @@ impl ToSource for syntax::codemap::Span {\n \n fn lit_to_str(lit: &ast::Lit) -> ~str {\n     match lit.node {\n-        ast::LitStr(st, _) => st.to_owned(),\n-        ast::LitBinary(data) => format!(\"{:?}\", data.as_slice()),\n+        ast::LitStr(ref st, _) => st.get().to_owned(),\n+        ast::LitBinary(ref data) => format!(\"{:?}\", data.borrow().as_slice()),\n         ast::LitChar(c) => ~\"'\" + std::char::from_u32(c).unwrap().to_str() + \"'\",\n         ast::LitInt(i, _t) => i.to_str(),\n         ast::LitUint(u, _t) => u.to_str(),\n         ast::LitIntUnsuffixed(i) => i.to_str(),\n-        ast::LitFloat(f, _t) => f.to_str(),\n-        ast::LitFloatUnsuffixed(f) => f.to_str(),\n+        ast::LitFloat(ref f, _t) => f.get().to_str(),\n+        ast::LitFloatUnsuffixed(ref f) => f.get().to_str(),\n         ast::LitBool(b) => b.to_str(),\n         ast::LitNil => ~\"\",\n     }"}, {"sha": "0e2d6c972ae60df0fe6283ca0cd866c45f5860ac", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -15,6 +15,7 @@ use rustc::middle::privacy;\n \n use syntax::ast;\n use syntax::diagnostic;\n+use syntax::parse::token;\n use syntax::parse;\n use syntax;\n \n@@ -71,7 +72,8 @@ fn get_ast_and_resolve(cpath: &Path,\n \n     let mut cfg = build_configuration(sess);\n     for cfg_ in cfgs.move_iter() {\n-        cfg.push(@dummy_spanned(ast::MetaWord(cfg_.to_managed())));\n+        let cfg_ = token::intern_and_get_ident(cfg_);\n+        cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n     let crate = phase_1_parse_input(sess, cfg.clone(), &input);"}, {"sha": "86b6a5734a5d8d07aba49f902600defb463235c0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -45,6 +45,7 @@ use extra::arc::Arc;\n use extra::json::ToJson;\n use syntax::ast;\n use syntax::attr;\n+use syntax::parse::token::InternedString;\n \n use clean;\n use doctree;\n@@ -803,12 +804,13 @@ impl<'a> Item<'a> {\n impl<'a> fmt::Default for Item<'a> {\n     fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) {\n         match attr::find_stability(it.item.attrs.iter()) {\n-            Some(stability) => {\n+            Some(ref stability) => {\n                 write!(fmt.buf,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),\n                        reason = match stability.text {\n-                           Some(s) => s, None => @\"\",\n+                           Some(ref s) => (*s).clone(),\n+                           None => InternedString::new(\"\"),\n                        });\n             }\n             None => {}"}, {"sha": "12874d1b502a282e4249f8f69d64319c767d9dd0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -137,7 +137,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n     }\n }\n \n-fn maketest(s: &str, cratename: &str) -> @str {\n+fn maketest(s: &str, cratename: &str) -> ~str {\n     let mut prog = ~r\"\n #[deny(warnings)];\n #[allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n@@ -156,7 +156,7 @@ fn maketest(s: &str, cratename: &str) -> @str {\n         prog.push_str(\"\\n}\");\n     }\n \n-    return prog.to_managed();\n+    return prog;\n }\n \n pub struct Collector {"}, {"sha": "ba31699a7d04e54450f894edc3d02e965b630e78", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -30,6 +30,8 @@ use syntax::ext::base::{ExtCtxt, MacroCrate};\n use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n use syntax::fold::Folder;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::util::small_vector::SmallVector;\n use syntax::crateid::CrateId;\n@@ -77,7 +79,7 @@ fn fold_mod(m: &ast::Mod, fold: &mut CrateSetup) -> ast::Mod {\n     fn strip_main(item: @ast::Item) -> @ast::Item {\n         @ast::Item {\n             attrs: item.attrs.iter().filter_map(|attr| {\n-                if \"main\" != attr.name() {\n+                if !attr.name().equiv(&(\"main\")) {\n                     Some(*attr)\n                 } else {\n                     None\n@@ -101,13 +103,15 @@ fn fold_item(item: @ast::Item, fold: &mut CrateSetup)\n     let mut had_pkg_do = false;\n \n     for attr in item.attrs.iter() {\n-        if \"pkg_do\" == attr.name() {\n+        if attr.name().equiv(&(\"pkg_do\")) {\n             had_pkg_do = true;\n             match attr.node.value.node {\n                 ast::MetaList(_, ref mis) => {\n                     for mi in mis.iter() {\n                         match mi.node {\n-                            ast::MetaWord(cmd) => cmds.push(cmd.to_owned()),\n+                            ast::MetaWord(ref cmd) => {\n+                                cmds.push(cmd.get().to_owned())\n+                            }\n                             _ => {}\n                         };\n                     }\n@@ -314,7 +318,9 @@ pub fn compile_input(context: &BuildContext,\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let crateid_attr =\n-            attr::mk_name_value_item_str(@\"crate_id\", crate_id.to_str().to_managed());\n+            attr::mk_name_value_item_str(\n+                InternedString::new(\"crate_id\"),\n+                token::intern_and_get_ident(crate_id.to_str()));\n \n         debug!(\"crateid attr: {:?}\", crateid_attr);\n         crate.attrs.push(attr::mk_attr(crateid_attr));\n@@ -466,13 +472,14 @@ impl<'a> CrateInstaller<'a> {\n \n         match vi.node {\n             // ignore metadata, I guess\n-            ast::ViewItemExternMod(lib_ident, path_opt, _) => {\n-                let lib_name = match path_opt {\n-                    Some((p, _)) => p,\n-                    None => self.sess.str_of(lib_ident)\n+            ast::ViewItemExternMod(ref lib_ident, ref path_opt, _) => {\n+                let lib_name = match *path_opt {\n+                    Some((ref p, _)) => (*p).clone(),\n+                    None => token::get_ident(lib_ident.name),\n                 };\n                 debug!(\"Finding and installing... {}\", lib_name);\n-                let crate_id: CrateId = from_str(lib_name).expect(\"valid crate id\");\n+                let crate_id: CrateId =\n+                    from_str(lib_name.get()).expect(\"valid crate id\");\n                 // Check standard Rust library path first\n                 let whatever = system_library(&self.context.sysroot_to_use(), &crate_id);\n                 debug!(\"system library returned {:?}\", whatever);\n@@ -642,7 +649,7 @@ pub fn find_and_install_dependencies(installer: &mut CrateInstaller,\n     visit::walk_crate(installer, c, ())\n }\n \n-pub fn mk_string_lit(s: @str) -> ast::Lit {\n+pub fn mk_string_lit(s: InternedString) -> ast::Lit {\n     Spanned {\n         node: ast::LitStr(s, ast::CookedStr),\n         span: DUMMY_SP"}, {"sha": "55e90248e1c3b608149c72e16c6b72ae3ee9fa5e", "filename": "src/libstd/at_vec.rs", "status": "removed", "additions": 0, "deletions": 424, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=60ffbeb2a495d097e38f51348ebcf5a884947c25", "patch": "@@ -1,424 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations on managed vectors (`@[T]` type)\n-\n-use clone::Clone;\n-use container::Container;\n-use iter::{Iterator, FromIterator};\n-use option::{Option, Some, None};\n-use mem;\n-use unstable::raw::Repr;\n-use vec::{ImmutableVector, OwnedVector};\n-\n-/// Code for dealing with @-vectors. This is pretty incomplete, and\n-/// contains a bunch of duplication from the code for ~-vectors.\n-\n-/// Returns the number of elements the vector can hold without reallocating\n-#[inline]\n-pub fn capacity<T>(v: @[T]) -> uint {\n-    unsafe {\n-        let managed_box = v.repr();\n-        (*managed_box).data.alloc / mem::size_of::<T>()\n-    }\n-}\n-\n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- * The initial size for the vector may optionally be specified\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the vector to reserve\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> @[A] {\n-    let mut vec = @[];\n-    unsafe { raw::reserve(&mut vec, size.unwrap_or(4)); }\n-    builder(|x| unsafe { raw::push(&mut vec, x) });\n-    vec\n-}\n-\n-// Appending\n-\n-/// Iterates over the `rhs` vector, copying each element and appending it to the\n-/// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline]\n-pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n-    build(Some(lhs.len() + rhs.len()), |push| {\n-        for x in lhs.iter() {\n-            push((*x).clone());\n-        }\n-        for elt in rhs.iter() {\n-            push(elt.clone());\n-        }\n-    })\n-}\n-\n-\n-/// Apply a function to each element of a vector and return the results\n-#[inline]\n-pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n-    build(Some(v.len()), |push| {\n-        for elem in v.iter() {\n-            push(f(elem));\n-        }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable vector.\n- *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value returned by the function `op`.\n- */\n-#[inline]\n-pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n-    build(Some(n_elts), |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts { push(op(i)); i += 1u; }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable vector.\n- *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value `t`.\n- */\n-#[inline]\n-pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n-    build(Some(n_elts), |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts {\n-            push(t.clone());\n-            i += 1u;\n-        }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable managed vector by moving all the\n- * elements from an owned vector.\n- */\n-#[inline]\n-pub fn to_managed_move<T>(v: ~[T]) -> @[T] {\n-    let mut av = @[];\n-    unsafe {\n-        raw::reserve(&mut av, v.len());\n-        for x in v.move_iter() {\n-            raw::push(&mut av, x);\n-        }\n-        av\n-    }\n-}\n-\n-/**\n- * Creates and initializes an immutable managed vector by copying all the\n- * elements of a slice.\n- */\n-#[inline]\n-pub fn to_managed<T:Clone>(v: &[T]) -> @[T] {\n-    from_fn(v.len(), |i| v[i].clone())\n-}\n-\n-impl<T> Clone for @[T] {\n-    fn clone(&self) -> @[T] {\n-        *self\n-    }\n-}\n-\n-impl<A> FromIterator<A> for @[A] {\n-    #[inline]\n-    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> @[A] {\n-        let (lower, _) = iterator.size_hint();\n-        build(Some(lower), |push| {\n-            for x in *iterator {\n-                push(x);\n-            }\n-        })\n-    }\n-}\n-\n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use at_vec::append;\n-    use clone::Clone;\n-    use ops::Add;\n-    use vec::Vector;\n-\n-    impl<'a,T:Clone, V: Vector<T>> Add<V,@[T]> for @[T] {\n-        #[inline]\n-        fn add(&self, rhs: &V) -> @[T] {\n-            append(*self, rhs.as_slice())\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-#[allow(missing_doc)]\n-pub mod raw {\n-    use at_vec::capacity;\n-    use cast;\n-    use cast::{transmute, transmute_copy};\n-    use container::Container;\n-    use option::None;\n-    use mem;\n-    use num::next_power_of_two;\n-    use ptr;\n-    use unstable::intrinsics::{move_val_init, TyDesc};\n-    use unstable::intrinsics;\n-    use unstable::raw::{Box, Vec};\n-\n-    /**\n-     * Sets the length of a vector\n-     *\n-     * This will explicitly set the size of the vector, without actually\n-     * modifying its buffers, so it is up to the caller to ensure that\n-     * the vector is actually the specified size.\n-     */\n-    #[inline]\n-    pub unsafe fn set_len<T>(v: &mut @[T], new_len: uint) {\n-        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n-        (*repr).data.fill = new_len * mem::size_of::<T>();\n-    }\n-\n-    /**\n-     * Pushes a new value onto this vector.\n-     */\n-    #[inline]\n-    pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n-        let full = {\n-            let repr: *Box<Vec<T>> = cast::transmute_copy(v);\n-            (*repr).data.alloc > (*repr).data.fill\n-        };\n-        if full {\n-            push_fast(v, initval);\n-        } else {\n-            push_slow(v, initval);\n-        }\n-    }\n-\n-    #[inline] // really pretty please\n-    unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n-        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n-        let amt = v.len();\n-        (*repr).data.fill += mem::size_of::<T>();\n-        let p = ptr::offset(&(*repr).data.data as *T, amt as int) as *mut T;\n-        move_val_init(&mut(*p), initval);\n-    }\n-\n-    #[inline]\n-    unsafe fn push_slow<T>(v: &mut @[T], initval: T) {\n-        reserve_at_least(v, v.len() + 1u);\n-        push_fast(v, initval);\n-    }\n-\n-    /**\n-     * Reserves capacity for exactly `n` elements in the given vector.\n-     *\n-     * If the capacity for `v` is already equal to or greater than the\n-     * requested capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * v - A vector\n-     * * n - The number of elements to reserve space for\n-     */\n-    #[inline]\n-    pub unsafe fn reserve<T>(v: &mut @[T], n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        if capacity(*v) < n {\n-            let ptr: *mut *mut Box<Vec<()>> = transmute(v);\n-            let ty = intrinsics::get_tydesc::<T>();\n-            return reserve_raw(ty, ptr, n);\n-        }\n-    }\n-\n-    // Implementation detail. Shouldn't be public\n-    #[allow(missing_doc)]\n-    #[inline]\n-    pub fn reserve_raw(ty: *TyDesc, ptr: *mut *mut Box<Vec<()>>, n: uint) {\n-        // check for `uint` overflow\n-        unsafe {\n-            if n > (**ptr).data.alloc / (*ty).size {\n-                let alloc = n * (*ty).size;\n-                let total_size = alloc + mem::size_of::<Vec<()>>();\n-                if alloc / (*ty).size != n || total_size < alloc {\n-                    fail!(\"vector size is too large: {}\", n);\n-                }\n-                (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n-                (**ptr).data.alloc = alloc;\n-            }\n-        }\n-\n-        #[inline]\n-        fn local_realloc(ptr: *(), size: uint) -> *() {\n-            use rt::local::Local;\n-            use rt::task::Task;\n-\n-            let mut task = Local::borrow(None::<Task>);\n-            task.get().heap.realloc(ptr as *mut Box<()>, size) as *()\n-        }\n-    }\n-\n-    /**\n-     * Reserves capacity for at least `n` elements in the given vector.\n-     *\n-     * This function will over-allocate in order to amortize the\n-     * allocation costs in scenarios where the caller may need to\n-     * repeatedly reserve additional space.\n-     *\n-     * If the capacity for `v` is already equal to or greater than the\n-     * requested capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * v - A vector\n-     * * n - The number of elements to reserve space for\n-     */\n-    #[inline]\n-    pub unsafe fn reserve_at_least<T>(v: &mut @[T], n: uint) {\n-        reserve(v, next_power_of_two(n));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use prelude::*;\n-    use bh = extra::test::BenchHarness;\n-\n-    #[test]\n-    fn test() {\n-        // Some code that could use that, then:\n-        fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-            build(None, |push| {\n-                for i in range(lo, hi) {\n-                    push(i);\n-                }\n-            })\n-        }\n-\n-        assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n-        assert_eq!(from_fn(5, |x| x+1), @[1, 2, 3, 4, 5]);\n-        assert_eq!(from_elem(5, 3.14), @[3.14, 3.14, 3.14, 3.14, 3.14]);\n-    }\n-\n-    #[test]\n-    fn append_test() {\n-        assert_eq!(@[1,2,3] + &[4,5,6], @[1,2,3,4,5,6]);\n-    }\n-\n-    #[test]\n-    fn test_to_managed_move() {\n-        assert_eq!(to_managed_move::<int>(~[]), @[]);\n-        assert_eq!(to_managed_move(~[true]), @[true]);\n-        assert_eq!(to_managed_move(~[1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n-        assert_eq!(to_managed_move(~[~\"abc\", ~\"123\"]), @[~\"abc\", ~\"123\"]);\n-        assert_eq!(to_managed_move(~[~[42]]), @[~[42]]);\n-    }\n-\n-    #[test]\n-    fn test_to_managed() {\n-        assert_eq!(to_managed::<int>([]), @[]);\n-        assert_eq!(to_managed([true]), @[true]);\n-        assert_eq!(to_managed([1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n-        assert_eq!(to_managed([@\"abc\", @\"123\"]), @[@\"abc\", @\"123\"]);\n-        assert_eq!(to_managed([@[42]]), @[@[42]]);\n-    }\n-\n-    #[bench]\n-    fn bench_capacity(b: &mut bh) {\n-        let x = @[1, 2, 3];\n-        b.iter(|| {\n-            let _ = capacity(x);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_build_sized(b: &mut bh) {\n-        let len = 64;\n-        b.iter(|| {\n-            build(Some(len), |push| for i in range(0, 1024) { push(i) });\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_build(b: &mut bh) {\n-        b.iter(|| {\n-            for i in range(0, 95) {\n-                build(None, |push| push(i));\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_append(b: &mut bh) {\n-        let lhs = @[7, ..128];\n-        let rhs = range(0, 256).to_owned_vec();\n-        b.iter(|| {\n-            let _ = append(lhs, rhs);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_map(b: &mut bh) {\n-        let elts = range(0, 256).to_owned_vec();\n-        b.iter(|| {\n-            let _ = map(elts, |x| x*2);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_from_fn(b: &mut bh) {\n-        b.iter(|| {\n-            let _ = from_fn(1024, |x| x);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_from_elem(b: &mut bh) {\n-        b.iter(|| {\n-            let _ = from_elem(1024, 0u64);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_to_managed_move(b: &mut bh) {\n-        b.iter(|| {\n-            let elts = range(0, 1024).to_owned_vec(); // yikes! can't move out of capture, though\n-            to_managed_move(elts);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_managed(b: &mut bh) {\n-        let elts = range(0, 1024).to_owned_vec();\n-        b.iter(|| {\n-            let _ = to_managed(elts);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_clone(b: &mut bh) {\n-        let elts = to_managed(range(0, 1024).to_owned_vec());\n-        b.iter(|| {\n-            let _ = elts.clone();\n-        });\n-    }\n-}"}, {"sha": "13e6d808095841806e0eb103875e1a81dd3f3750", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -1167,7 +1167,6 @@ delegate!(  u8 to Unsigned)\n delegate!( u16 to Unsigned)\n delegate!( u32 to Unsigned)\n delegate!( u64 to Unsigned)\n-delegate!(@str to String)\n delegate!(~str to String)\n delegate!(&'a str to String)\n delegate!(bool to Bool)"}, {"sha": "fa7c94ac9948a250d8f01af676bc7e6f6c748a67", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -35,7 +35,6 @@ pub struct Gc<T> {\n }\n \n #[cfg(test)]\n-#[no_send]\n pub struct Gc<T> {\n     priv ptr: @T,\n     priv marker: marker::NoSend,"}, {"sha": "adce11fed2dad9160249b176c2c85a90e2efca38", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -114,7 +114,6 @@ pub mod tuple;\n \n pub mod vec;\n pub mod vec_ng;\n-pub mod at_vec;\n pub mod str;\n \n pub mod ascii;"}, {"sha": "c5482811a94d60f51b9327bd52748cbb055aa595", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -604,19 +604,6 @@ impl BytesContainer for ~str {\n     fn is_str(_: Option<~str>) -> bool { true }\n }\n \n-impl BytesContainer for @str {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(self.as_slice())\n-    }\n-    #[inline]\n-    fn is_str(_: Option<@str>) -> bool { true }\n-}\n-\n impl<'a> BytesContainer for &'a [u8] {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n@@ -635,13 +622,6 @@ impl BytesContainer for ~[u8] {\n     }\n }\n \n-impl BytesContainer for @[u8] {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_slice()\n-    }\n-}\n-\n impl BytesContainer for CString {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {"}, {"sha": "ba0cd0bb521dc4fc5245f8cd7c273cdf767560fe", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -807,8 +807,6 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n@@ -830,12 +828,9 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n-        t!(s: \"a/b/c\", [@\"d\", @\"e\"], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a/b/c/d/e\"));\n     }\n \n     #[test]\n@@ -917,8 +912,6 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n@@ -940,11 +933,8 @@ mod tests {\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n-        t!(s: \"a/b/c\", [@\"d\", @\"e\"], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a/b/c/d/e\"));\n     }\n \n     #[test]"}, {"sha": "eec6f37b627a2da640c13df53f77b9692b9b6988", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -1587,8 +1587,6 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n@@ -1610,12 +1608,9 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(s: \"a\\\\b\\\\c\", [@\"d\", @\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n     }\n \n     #[test]\n@@ -1732,8 +1727,6 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n@@ -1755,11 +1748,8 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(s: \"a\\\\b\\\\c\", [@\"d\", @\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n     }\n \n     #[test]"}, {"sha": "d6b4d3f5656294fa3b48f63c36b1982b646126e8", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -183,9 +183,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_estr_box(&mut self) -> bool {\n-        self.align_to::<@str>();\n-        if ! self.inner.visit_estr_box() { return false; }\n-        self.bump_past::<@str>();\n         true\n     }\n \n@@ -253,10 +250,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@[u8]>();\n-        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n-        self.bump_past::<@[u8]>();\n+    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n         true\n     }\n "}, {"sha": "41ddf02778768d1cd42e7c1ffeaed4ffadc64a93", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -272,10 +272,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_estr_box(&mut self) -> bool {\n-        self.get::<@str>(|this, s| {\n-            this.writer.write(['@' as u8]);\n-            this.write_escaped_slice(*s);\n-        })\n+        true\n     }\n \n     fn visit_estr_uniq(&mut self) -> bool {\n@@ -628,7 +625,6 @@ fn test_repr() {\n     exact_test(&false, \"false\");\n     exact_test(&1.234, \"1.234f64\");\n     exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n-    exact_test(&(@\"hello\"), \"@\\\"hello\\\"\");\n     exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n \n     exact_test(&(@10), \"@10\");\n@@ -641,12 +637,6 @@ fn test_repr() {\n     exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n \n     exact_test(&(1,), \"(1,)\");\n-    exact_test(&(@[1,2,3,4,5,6,7,8]),\n-               \"@[1, 2, 3, 4, 5, 6, 7, 8]\");\n-    exact_test(&(@[1u8,2u8,3u8,4u8]),\n-               \"@[1u8, 2u8, 3u8, 4u8]\");\n-    exact_test(&(@[\"hi\", \"there\"]),\n-               \"@[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(~[\"hi\", \"there\"]),\n                \"~[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(&[\"hi\", \"there\"]),"}, {"sha": "79936b4afad0afb473887e8dbbbf57fbd0c6170d", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -332,6 +332,6 @@ mod bench {\n \n     #[bench]\n     fn alloc_managed_big(bh: &mut BenchHarness) {\n-        bh.iter(|| { @[10, ..1000]; });\n+        bh.iter(|| { @([10, ..1000]); });\n     }\n }"}, {"sha": "b075b75b70acce849634e1f7895e2974a316ee55", "filename": "src/libstd/send_str.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fsend_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fsend_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsend_str.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -185,15 +185,13 @@ mod tests {\n         assert_eq!(s.len(), 5);\n         assert_eq!(s.as_slice(), \"abcde\");\n         assert_eq!(s.to_str(), ~\"abcde\");\n-        assert!(s.equiv(&@\"abcde\"));\n         assert!(s.lt(&SendStrOwned(~\"bcdef\")));\n         assert_eq!(SendStrStatic(\"\"), Default::default());\n \n         let o = SendStrOwned(~\"abcde\");\n         assert_eq!(o.len(), 5);\n         assert_eq!(o.as_slice(), \"abcde\");\n         assert_eq!(o.to_str(), ~\"abcde\");\n-        assert!(o.equiv(&@\"abcde\"));\n         assert!(o.lt(&SendStrStatic(\"bcdef\")));\n         assert_eq!(SendStrOwned(~\"\"), Default::default());\n "}, {"sha": "0315e560bb783c98cd306f950685d55c6405c454", "filename": "src/libstd/str.rs", "status": "modified", "additions": 11, "deletions": 120, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -17,46 +17,35 @@ Unicode string manipulation (`str` type)\n Rust's string type is one of the core primitive types of the language. While\n represented by the name `str`, the name `str` is not actually a valid type in\n Rust. Each string must also be decorated with its ownership. This means that\n-there are three common kinds of strings in rust:\n+there are two common kinds of strings in rust:\n \n * `~str` - This is an owned string. This type obeys all of the normal semantics\n            of the `~T` types, meaning that it has one, and only one, owner. This\n            type cannot be implicitly copied, and is moved out of when passed to\n            other functions.\n \n-* `@str` - This is a managed string. Similarly to `@T`, this type can be\n-           implicitly copied, and each implicit copy will increment the\n-           reference count to the string. This means that there is no \"true\n-           owner\" of the string, and the string will be deallocated when the\n-           reference count reaches 0.\n-\n-* `&str` - Finally, this is the borrowed string type. This type of string can\n-           only be created from one of the other two kinds of strings. As the\n-           name \"borrowed\" implies, this type of string is owned elsewhere, and\n-           this string cannot be moved out of.\n+* `&str` - This is the borrowed string type. This type of string can only be\n+           created from the other kind of string. As the name \"borrowed\"\n+           implies, this type of string is owned elsewhere, and this string\n+           cannot be moved out of.\n \n As an example, here's a few different kinds of strings.\n \n ```rust\n-#[feature(managed_boxes)];\n-\n fn main() {\n     let owned_string = ~\"I am an owned string\";\n-    let managed_string = @\"This string is garbage-collected\";\n     let borrowed_string1 = \"This string is borrowed with the 'static lifetime\";\n     let borrowed_string2: &str = owned_string;   // owned strings can be borrowed\n-    let borrowed_string3: &str = managed_string; // managed strings can also be borrowed\n }\n  ```\n \n-From the example above, you can see that rust has 3 different kinds of string\n-literals. The owned/managed literals correspond to the owned/managed string\n-types, but the \"borrowed literal\" is actually more akin to C's concept of a\n-static string.\n+From the example above, you can see that rust has 2 different kinds of string\n+literals. The owned literals correspond to the owned string types, but the\n+\"borrowed literal\" is actually more akin to C's concept of a static string.\n \n-When a string is declared without a `~` or `@` sigil, then the string is\n-allocated statically in the rodata of the executable/library. The string then\n-has the type `&'static str` meaning that the string is valid for the `'static`\n+When a string is declared without a `~` sigil, then the string is allocated\n+statically in the rodata of the executable/library. The string then has the\n+type `&'static str` meaning that the string is valid for the `'static`\n lifetime, otherwise known as the lifetime of the entire program. As can be\n inferred from the type, these static strings are not mutable.\n \n@@ -89,11 +78,9 @@ The actual representation of strings have direct mappings to vectors:\n \n * `~str` is the same as `~[u8]`\n * `&str` is the same as `&[u8]`\n-* `@str` is the same as `@[u8]`\n \n */\n \n-use at_vec;\n use cast;\n use cast::transmute;\n use char;\n@@ -157,16 +144,6 @@ impl<'a> ToStr for &'a str {\n     fn to_str(&self) -> ~str { self.to_owned() }\n }\n \n-impl ToStr for @str {\n-    #[inline]\n-    fn to_str(&self) -> ~str { self.to_owned() }\n-}\n-\n-impl<'a> FromStr for @str {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<@str> { Some(s.to_managed()) }\n-}\n-\n /// Convert a byte to a UTF-8 string\n ///\n /// # Failure\n@@ -1140,11 +1117,6 @@ pub mod traits {\n         fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n \n-    impl TotalOrd for @str {\n-        #[inline]\n-        fn cmp(&self, other: &@str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n     impl<'a> Eq for &'a str {\n         #[inline]\n         fn eq(&self, other: & &'a str) -> bool {\n@@ -1161,13 +1133,6 @@ pub mod traits {\n         }\n     }\n \n-    impl Eq for @str {\n-        #[inline]\n-        fn eq(&self, other: &@str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-    }\n-\n     impl<'a> TotalEq for &'a str {\n         #[inline]\n         fn equals(&self, other: & &'a str) -> bool {\n@@ -1182,13 +1147,6 @@ pub mod traits {\n         }\n     }\n \n-    impl TotalEq for @str {\n-        #[inline]\n-        fn equals(&self, other: &@str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-    }\n-\n     impl<'a> Ord for &'a str {\n         #[inline]\n         fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n@@ -1199,21 +1157,11 @@ pub mod traits {\n         fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n     }\n \n-    impl Ord for @str {\n-        #[inline]\n-        fn lt(&self, other: &@str) -> bool { self.cmp(other) == Less }\n-    }\n-\n     impl<'a, S: Str> Equiv<S> for &'a str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n-    impl<'a, S: Str> Equiv<S> for @str {\n-        #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-    }\n-\n     impl<'a, S: Str> Equiv<S> for ~str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n@@ -1250,16 +1198,6 @@ impl<'a> Str for ~str {\n     fn into_owned(self) -> ~str { self }\n }\n \n-impl<'a> Str for @str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        let s: &'a str = *self; s\n-    }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str { self.to_owned() }\n-}\n-\n impl<'a> Container for &'a str {\n     #[inline]\n     fn len(&self) -> uint {\n@@ -1272,11 +1210,6 @@ impl Container for ~str {\n     fn len(&self) -> uint { self.as_slice().len() }\n }\n \n-impl Container for @str {\n-    #[inline]\n-    fn len(&self) -> uint { self.as_slice().len() }\n-}\n-\n impl Mutable for ~str {\n     /// Remove all content, make the string empty\n     #[inline]\n@@ -1734,9 +1667,6 @@ pub trait StrSlice<'a> {\n     /// Copy a slice into a new owned str.\n     fn to_owned(&self) -> ~str;\n \n-    /// Copy a slice into a new managed str.\n-    fn to_managed(&self) -> @str;\n-\n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16];\n \n@@ -2246,14 +2176,6 @@ impl<'a> StrSlice<'a> for &'a str {\n         }\n     }\n \n-    #[inline]\n-    fn to_managed(&self) -> @str {\n-        unsafe {\n-            let v: *&[u8] = cast::transmute(self);\n-            cast::transmute(at_vec::to_managed(*v))\n-        }\n-    }\n-\n     fn to_utf16(&self) -> ~[u16] {\n         let mut u = ~[];\n         for ch in self.chars() {\n@@ -2682,20 +2604,6 @@ impl DeepClone for ~str {\n     }\n }\n \n-impl Clone for @str {\n-    #[inline]\n-    fn clone(&self) -> @str {\n-        *self\n-    }\n-}\n-\n-impl DeepClone for @str {\n-    #[inline]\n-    fn deep_clone(&self) -> @str {\n-        *self\n-    }\n-}\n-\n impl FromIterator<char> for ~str {\n     #[inline]\n     fn from_iterator<T: Iterator<char>>(iterator: &mut T) -> ~str {\n@@ -2727,10 +2635,6 @@ impl Default for ~str {\n     fn default() -> ~str { ~\"\" }\n }\n \n-impl Default for @str {\n-    fn default() -> @str { @\"\" }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use iter::AdditiveIterator;\n@@ -3536,12 +3440,6 @@ mod tests {\n         assert_eq!(\"\\U0001d4ea\\r\".escape_default(), ~\"\\\\U0001d4ea\\\\r\");\n     }\n \n-    #[test]\n-    fn test_to_managed() {\n-        assert_eq!(\"abc\".to_managed(), @\"abc\");\n-        assert_eq!(\"abcdef\".slice(1, 5).to_managed(), @\"bcde\");\n-    }\n-\n     #[test]\n     fn test_total_ord() {\n         \"1234\".cmp(& &\"123\") == Greater;\n@@ -3579,15 +3477,12 @@ mod tests {\n                 let e = $e;\n                 assert_eq!(s1 + s2, e.to_owned());\n                 assert_eq!(s1.to_owned() + s2, e.to_owned());\n-                assert_eq!(s1.to_managed() + s2, e.to_owned());\n             } }\n         );\n \n         t!(\"foo\",  \"bar\", \"foobar\");\n-        t!(\"foo\", @\"bar\", \"foobar\");\n         t!(\"foo\", ~\"bar\", \"foobar\");\n         t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\",  \"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", @\"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n         t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n \n@@ -3874,7 +3769,6 @@ mod tests {\n         }\n \n         t::<&str>();\n-        t::<@str>();\n         t::<~str>();\n     }\n \n@@ -3886,7 +3780,6 @@ mod tests {\n \n         let s = ~\"01234\";\n         assert_eq!(5, sum_len([\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len([@\"01\", @\"2\", @\"34\", @\"\"]));\n         assert_eq!(5, sum_len([~\"01\", ~\"2\", ~\"34\", ~\"\"]));\n         assert_eq!(5, sum_len([s.as_slice()]));\n     }\n@@ -3957,8 +3850,6 @@ mod tests {\n     fn test_from_str() {\n       let owned: Option<~str> = from_str(&\"string\");\n       assert_eq!(owned, Some(~\"string\"));\n-      let managed: Option<@str> = from_str(&\"string\");\n-      assert_eq!(managed, Some(@\"string\"));\n     }\n }\n "}, {"sha": "4c545de73b48b23ad57304dfa8688e4aff46883a", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -266,13 +266,6 @@ impl<A:IterBytes> IterBytes for ~[A] {\n     }\n }\n \n-impl<A:IterBytes> IterBytes for @[A] {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.as_slice().iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl<'a> IterBytes for &'a str {\n     #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n@@ -288,13 +281,6 @@ impl IterBytes for ~str {\n     }\n }\n \n-impl IterBytes for @str {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.as_slice().iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {"}, {"sha": "87d59f0979194841bb28f827fc42c7bf8a45fc91", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -159,25 +159,6 @@ impl<A:ToStr> ToStr for ~[A] {\n     }\n }\n \n-impl<A:ToStr> ToStr for @[A] {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        let mut acc = ~\"[\";\n-        let mut first = true;\n-        for elt in self.iter() {\n-            if first {\n-                first = false;\n-            }\n-            else {\n-                acc.push_str(\", \");\n-            }\n-            acc.push_str(elt.to_str());\n-        }\n-        acc.push_char(']');\n-        acc\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use hashmap::HashMap;\n@@ -195,7 +176,6 @@ mod tests {\n         assert_eq!(false.to_str(), ~\"false\");\n         assert_eq!(().to_str(), ~\"()\");\n         assert_eq!((~\"hi\").to_str(), ~\"hi\");\n-        assert_eq!((@\"hi\").to_str(), ~\"hi\");\n     }\n \n     #[test]"}, {"sha": "63208b3f2d707a500f06ed76f16e21627c3a52ff", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -56,10 +56,8 @@ pub trait Repr<T> {\n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n impl<T> Repr<*Box<T>> for @T {}\n-impl<T> Repr<*Box<Vec<T>>> for @[T] {}\n impl<T> Repr<*Vec<T>> for ~[T] {}\n impl Repr<*String> for ~str {}\n-impl Repr<*Box<String>> for @str {}\n \n // sure would be nice to have this\n // impl<T> Repr<*Vec<T>> for ~[T] {}"}, {"sha": "607b30c000bd58d528870cbee561427a8abd381b", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -646,13 +646,6 @@ pub mod traits {\n         fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n     }\n \n-    impl<T:Eq> Eq for @[T] {\n-        #[inline]\n-        fn eq(&self, other: &@[T]) -> bool { self.as_slice() == *other }\n-        #[inline]\n-        fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n-    }\n-\n     impl<'a,T:TotalEq> TotalEq for &'a [T] {\n         fn equals(&self, other: & &'a [T]) -> bool {\n             self.len() == other.len() &&\n@@ -665,11 +658,6 @@ pub mod traits {\n         fn equals(&self, other: &~[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n     }\n \n-    impl<T:TotalEq> TotalEq for @[T] {\n-        #[inline]\n-        fn equals(&self, other: &@[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n-    }\n-\n     impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n@@ -680,11 +668,6 @@ pub mod traits {\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for @[T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n     impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n         fn cmp(&self, other: & &'a [T]) -> Ordering {\n             order::cmp(self.iter(), other.iter())\n@@ -696,11 +679,6 @@ pub mod traits {\n         fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n \n-    impl<T: TotalOrd> TotalOrd for @[T] {\n-        #[inline]\n-        fn cmp(&self, other: &@[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n     impl<'a, T: Eq + Ord> Ord for &'a [T] {\n         fn lt(&self, other: & &'a [T]) -> bool {\n             order::lt(self.iter(), other.iter())\n@@ -730,17 +708,6 @@ pub mod traits {\n         fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    impl<T: Eq + Ord> Ord for @[T] {\n-        #[inline]\n-        fn lt(&self, other: &@[T]) -> bool { self.as_slice() < other.as_slice() }\n-        #[inline]\n-        fn le(&self, other: &@[T]) -> bool { self.as_slice() <= other.as_slice() }\n-        #[inline]\n-        fn ge(&self, other: &@[T]) -> bool { self.as_slice() >= other.as_slice() }\n-        #[inline]\n-        fn gt(&self, other: &@[T]) -> bool { self.as_slice() > other.as_slice() }\n-    }\n-\n     impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> ~[T] {\n@@ -778,11 +745,6 @@ impl<T> Vector<T> for ~[T] {\n     fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n \n-impl<T> Vector<T> for @[T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n-}\n-\n impl<'a, T> Container for &'a [T] {\n     /// Returns the length of a vector\n     #[inline]\n@@ -833,15 +795,6 @@ impl<T: Clone> CloneableVector<T> for ~[T] {\n     fn into_owned(self) -> ~[T] { self }\n }\n \n-/// Extension methods for managed vectors\n-impl<T: Clone> CloneableVector<T> for @[T] {\n-    #[inline]\n-    fn to_owned(&self) -> ~[T] { self.as_slice().to_owned() }\n-\n-    #[inline(always)]\n-    fn into_owned(self) -> ~[T] { self.to_owned() }\n-}\n-\n /// Extension methods for vectors\n pub trait ImmutableVector<'a, T> {\n     /**\n@@ -2637,10 +2590,6 @@ impl<A> Default for ~[A] {\n     fn default() -> ~[A] { ~[] }\n }\n \n-impl<A> Default for @[A] {\n-    fn default() -> @[A] { @[] }\n-}\n-\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         /// An iterator for iterating over a vector.\n@@ -3117,14 +3066,6 @@ mod tests {\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n-        // Test on managed heap.\n-        let vec_managed = @[1, 2, 3, 4, 5];\n-        let v_c = vec_managed.slice(0u, 3u).to_owned();\n-        assert_eq!(v_c.len(), 3u);\n-        assert_eq!(v_c[0], 1);\n-        assert_eq!(v_c[1], 2);\n-        assert_eq!(v_c[2], 3);\n-\n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n         let v_d = vec_unique.slice(1u, 6u).to_owned();\n@@ -4060,7 +4001,6 @@ mod tests {\n         );\n \n         t!(&[int]);\n-        t!(@[int]);\n         t!(~[int]);\n     }\n "}, {"sha": "228329cbda12a467f88135d0a99b78411ef9915e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -14,11 +14,13 @@ use codemap::{Span, Spanned, DUMMY_SP};\n use abi::AbiSet;\n use ast_util;\n use opt_vec::OptVec;\n-use parse::token::{interner_get, str_to_ident, special_idents};\n+use parse::token::{InternedString, special_idents, str_to_ident};\n+use parse::token;\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::option::Option;\n+use std::rc::Rc;\n use std::to_str::ToStr;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -125,7 +127,8 @@ pub type Mrk = u32;\n \n impl<S:Encoder> Encodable<S> for Ident {\n     fn encode(&self, s: &mut S) {\n-        s.emit_str(interner_get(self.name));\n+        let string = token::get_ident(self.name);\n+        s.emit_str(string.get());\n     }\n }\n \n@@ -295,9 +298,9 @@ pub type MetaItem = Spanned<MetaItem_>;\n \n #[deriving(Clone, Encodable, Decodable, IterBytes)]\n pub enum MetaItem_ {\n-    MetaWord(@str),\n-    MetaList(@str, ~[@MetaItem]),\n-    MetaNameValue(@str, Lit),\n+    MetaWord(InternedString),\n+    MetaList(InternedString, ~[@MetaItem]),\n+    MetaNameValue(InternedString, Lit),\n }\n \n // can't be derived because the MetaList requires an unordered comparison\n@@ -402,19 +405,9 @@ impl ToStr for Sigil {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable, IterBytes)]\n-pub enum Vstore {\n-    // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n-    VstoreFixed(Option<uint>),     // [1,2,3,4]\n-    VstoreUniq,                    // ~[1,2,3,4]\n-    VstoreBox,                     // @[1,2,3,4]\n-    VstoreSlice(Option<Lifetime>)  // &'foo? [1,2,3,4]\n-}\n-\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum ExprVstore {\n     ExprVstoreUniq,                 // ~[1,2,3,4]\n-    ExprVstoreBox,                  // @[1,2,3,4]\n     ExprVstoreSlice,                // &[1,2,3,4]\n     ExprVstoreMutSlice,             // &mut [1,2,3,4]\n }\n@@ -721,14 +714,14 @@ pub type Lit = Spanned<Lit_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Lit_ {\n-    LitStr(@str, StrStyle),\n-    LitBinary(@[u8]),\n+    LitStr(InternedString, StrStyle),\n+    LitBinary(Rc<~[u8]>),\n     LitChar(u32),\n     LitInt(i64, IntTy),\n     LitUint(u64, UintTy),\n     LitIntUnsuffixed(i64),\n-    LitFloat(@str, FloatTy),\n-    LitFloatUnsuffixed(@str),\n+    LitFloat(InternedString, FloatTy),\n+    LitFloatUnsuffixed(InternedString),\n     LitNil,\n     LitBool(bool),\n }\n@@ -897,11 +890,11 @@ pub enum AsmDialect {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct InlineAsm {\n-    asm: @str,\n+    asm: InternedString,\n     asm_str_style: StrStyle,\n-    clobbers: @str,\n-    inputs: ~[(@str, @Expr)],\n-    outputs: ~[(@str, @Expr)],\n+    clobbers: InternedString,\n+    inputs: ~[(InternedString, @Expr)],\n+    outputs: ~[(InternedString, @Expr)],\n     volatile: bool,\n     alignstack: bool,\n     dialect: AsmDialect\n@@ -1074,7 +1067,7 @@ pub enum ViewItem_ {\n     // optional @str: if present, this is a location (containing\n     // arbitrary characters) from which to fetch the crate sources\n     // For example, extern mod whatever = \"github.com/mozilla/rust\"\n-    ViewItemExternMod(Ident, Option<(@str, StrStyle)>, NodeId),\n+    ViewItemExternMod(Ident, Option<(InternedString,StrStyle)>, NodeId),\n     ViewItemUse(~[@ViewPath]),\n }\n "}, {"sha": "89209ab2104f00780452b0e5cdc69063615bfafb", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -62,9 +62,10 @@ pub fn path_to_str_with_sep(p: &[PathElem], sep: &str, itr: @IdentInterner)\n \n pub fn path_ident_to_str(p: &Path, i: Ident, itr: @IdentInterner) -> ~str {\n     if p.is_empty() {\n-        itr.get(i.name).to_owned()\n+        itr.get(i.name).into_owned()\n     } else {\n-        format!(\"{}::{}\", path_to_str(*p, itr), itr.get(i.name))\n+        let string = itr.get(i.name);\n+        format!(\"{}::{}\", path_to_str(*p, itr), string.as_slice())\n     }\n }\n \n@@ -75,7 +76,7 @@ pub fn path_to_str(p: &[PathElem], itr: @IdentInterner) -> ~str {\n pub fn path_elem_to_str(pe: PathElem, itr: @IdentInterner) -> ~str {\n     match pe {\n         PathMod(s) | PathName(s) | PathPrettyName(s, _) => {\n-            itr.get(s.name).to_owned()\n+            itr.get(s.name).into_owned()\n         }\n     }\n }\n@@ -105,7 +106,11 @@ fn pretty_ty(ty: &Ty, itr: @IdentInterner, out: &mut ~str) {\n         // need custom handling.\n         TyNil => { out.push_str(\"$NIL$\"); return }\n         TyPath(ref path, _, _) => {\n-            out.push_str(itr.get(path.segments.last().unwrap().identifier.name));\n+            out.push_str(itr.get(path.segments\n+                                     .last()\n+                                     .unwrap()\n+                                     .identifier\n+                                     .name).as_slice());\n             return\n         }\n         TyTup(ref tys) => {\n@@ -138,7 +143,8 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> PathElem {\n     match *trait_ref {\n         None => pretty = ~\"\",\n         Some(ref trait_ref) => {\n-            pretty = itr.get(trait_ref.path.segments.last().unwrap().identifier.name).to_owned();\n+            pretty = itr.get(trait_ref.path.segments.last().unwrap().identifier.name)\n+                        .into_owned();\n             pretty.push_char('$');\n         }\n     };\n@@ -489,17 +495,21 @@ pub fn node_id_to_str(map: Map, id: NodeId, itr: @IdentInterner) -> ~str {\n              path_ident_to_str(path, item.ident, itr), abi, id)\n       }\n       Some(NodeMethod(m, _, path)) => {\n+        let name = itr.get(m.ident.name);\n         format!(\"method {} in {} (id={})\",\n-             itr.get(m.ident.name), path_to_str(*path, itr), id)\n+             name.as_slice(), path_to_str(*path, itr), id)\n       }\n       Some(NodeTraitMethod(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n+        let name = itr.get(m.ident.name);\n         format!(\"method {} in {} (id={})\",\n-             itr.get(m.ident.name), path_to_str(*path, itr), id)\n+             name.as_slice(), path_to_str(*path, itr), id)\n       }\n       Some(NodeVariant(ref variant, _, path)) => {\n+        let name = itr.get(variant.node.name.name);\n         format!(\"variant {} in {} (id={})\",\n-             itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n+             name.as_slice(),\n+             path_to_str(*path, itr), id)\n       }\n       Some(NodeExpr(expr)) => {\n         format!(\"expr {} (id={})\", pprust::expr_to_str(expr, itr), id)"}, {"sha": "afedb62105ba7e80766d5a73f11369da4ec71cbf", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -25,7 +25,10 @@ use std::num;\n \n pub fn path_name_i(idents: &[Ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n+    idents.map(|i| {\n+        let string = token::get_ident(i.name);\n+        string.get().to_str()\n+    }).connect(\"::\")\n }\n \n // totally scary function: ignores all but the last element, should have"}, {"sha": "78e9d3bd46f8c5c476d03de7b4f254f8d66a075e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 67, "deletions": 49, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -16,57 +16,63 @@ use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use parse::token::InternedString;\n+use parse::token;\n use crateid::CrateId;\n \n use std::hashmap::HashSet;\n \n pub trait AttrMetaMethods {\n-    // This could be changed to `fn check_name(&self, name: @str) ->\n+    // This could be changed to `fn check_name(&self, name: InternedString) ->\n     // bool` which would facilitate a side table recording which\n     // attributes/meta items are used/unused.\n \n     /// Retrieve the name of the meta item, e.g. foo in #[foo],\n     /// #[foo=\"bar\"] and #[foo(bar)]\n-    fn name(&self) -> @str;\n+    fn name(&self) -> InternedString;\n \n     /**\n      * Gets the string value if self is a MetaNameValue variant\n      * containing a string, otherwise None.\n      */\n-    fn value_str(&self) -> Option<@str>;\n+    fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]>;\n \n     /**\n      * If the meta item is a name-value type with a string value then returns\n      * a tuple containing the name and string value, otherwise `None`\n      */\n-    fn name_str_pair(&self) -> Option<(@str, @str)>;\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)>;\n }\n \n impl AttrMetaMethods for Attribute {\n-    fn name(&self) -> @str { self.meta().name() }\n-    fn value_str(&self) -> Option<@str> { self.meta().value_str() }\n+    fn name(&self) -> InternedString { self.meta().name() }\n+    fn value_str(&self) -> Option<InternedString> {\n+        self.meta().value_str()\n+    }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n         self.node.value.meta_item_list()\n     }\n-    fn name_str_pair(&self) -> Option<(@str, @str)> { self.meta().name_str_pair() }\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)> {\n+        self.meta().name_str_pair()\n+    }\n }\n \n impl AttrMetaMethods for MetaItem {\n-    fn name(&self) -> @str {\n+    fn name(&self) -> InternedString {\n         match self.node {\n-            MetaWord(n) => n,\n-            MetaNameValue(n, _) => n,\n-            MetaList(n, _) => n\n+            MetaWord(ref n) => (*n).clone(),\n+            MetaNameValue(ref n, _) => (*n).clone(),\n+            MetaList(ref n, _) => (*n).clone(),\n         }\n     }\n \n-    fn value_str(&self) -> Option<@str> {\n+    fn value_str(&self) -> Option<InternedString> {\n         match self.node {\n             MetaNameValue(_, ref v) => {\n                 match v.node {\n-                    ast::LitStr(s, _) => Some(s),\n+                    ast::LitStr(ref s, _) => Some((*s).clone()),\n                     _ => None,\n                 }\n             },\n@@ -81,19 +87,21 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn name_str_pair(&self) -> Option<(@str, @str)> {\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)> {\n         self.value_str().map(|s| (self.name(), s))\n     }\n }\n \n // Annoying, but required to get test_cfg to work\n impl AttrMetaMethods for @MetaItem {\n-    fn name(&self) -> @str { (**self).name() }\n-    fn value_str(&self) -> Option<@str> { (**self).value_str() }\n+    fn name(&self) -> InternedString { (**self).name() }\n+    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n         (**self).meta_item_list()\n     }\n-    fn name_str_pair(&self) -> Option<(@str, @str)> { (**self).name_str_pair() }\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)> {\n+        (**self).name_str_pair()\n+    }\n }\n \n \n@@ -114,8 +122,10 @@ impl AttributeMethods for Attribute {\n     fn desugar_doc(&self) -> Attribute {\n         if self.node.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n-            let meta = mk_name_value_item_str(@\"doc\",\n-                                              strip_doc_comment_decoration(comment).to_managed());\n+            let meta = mk_name_value_item_str(\n+                InternedString::new(\"doc\"),\n+                token::intern_and_get_ident(strip_doc_comment_decoration(\n+                        comment.get())));\n             mk_attr(meta)\n         } else {\n             *self\n@@ -125,20 +135,22 @@ impl AttributeMethods for Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: @str, value: @str) -> @MetaItem {\n+pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n+                              -> @MetaItem {\n     let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: @str, value: ast::Lit) -> @MetaItem {\n+pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n+                          -> @MetaItem {\n     @dummy_spanned(MetaNameValue(name, value))\n }\n \n-pub fn mk_list_item(name: @str, items: ~[@MetaItem]) -> @MetaItem {\n+pub fn mk_list_item(name: InternedString, items: ~[@MetaItem]) -> @MetaItem {\n     @dummy_spanned(MetaList(name, items))\n }\n \n-pub fn mk_word_item(name: @str) -> @MetaItem {\n+pub fn mk_word_item(name: InternedString) -> @MetaItem {\n     @dummy_spanned(MetaWord(name))\n }\n \n@@ -150,12 +162,14 @@ pub fn mk_attr(item: @MetaItem) -> Attribute {\n     })\n }\n \n-pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n-    let style = doc_comment_style(text);\n+pub fn mk_sugared_doc_attr(text: InternedString, lo: BytePos, hi: BytePos)\n+                           -> Attribute {\n+    let style = doc_comment_style(text.get());\n     let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n         style: style,\n-        value: @spanned(lo, hi, MetaNameValue(@\"doc\", lit)),\n+        value: @spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n+                                              lit)),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -178,20 +192,22 @@ pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n     debug!(\"attr::contains_name (name={})\", name);\n     metas.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n-        name == item.name()\n+        item.name().equiv(&name)\n     })\n }\n \n pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n-                                 -> Option<@str> {\n+                                 -> Option<InternedString> {\n     attrs.iter()\n-        .find(|at| name == at.name())\n+        .find(|at| at.name().equiv(&name))\n         .and_then(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n-                                     -> Option<@str> {\n-    items.rev_iter().find(|mi| name == mi.name()).and_then(|i| i.value_str())\n+                                     -> Option<InternedString> {\n+    items.rev_iter()\n+         .find(|mi| mi.name().equiv(&name))\n+         .and_then(|i| i.value_str())\n }\n \n /* Higher-level applications */\n@@ -201,16 +217,16 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n     // human-readable strings.\n     let mut v = items.iter()\n         .map(|&mi| (mi.name(), mi))\n-        .collect::<~[(@str, @MetaItem)]>();\n+        .collect::<~[(InternedString, @MetaItem)]>();\n \n-    v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+    v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {\n         match m.node {\n-            MetaList(n, ref mis) => {\n+            MetaList(ref n, ref mis) => {\n                 @Spanned {\n-                    node: MetaList(n, sort_meta_items(*mis)),\n+                    node: MetaList((*n).clone(), sort_meta_items(*mis)),\n                     .. /*bad*/ (*m).clone()\n                 }\n             }\n@@ -225,7 +241,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n  */\n pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n     let mut result = ~[];\n-    for attr in attrs.iter().filter(|at| \"link\" == at.name()) {\n+    for attr in attrs.iter().filter(|at| at.name().equiv(&(\"link\"))) {\n         match attr.meta().node {\n             MetaList(_, ref items) => result.push_all(*items),\n             _ => ()\n@@ -237,7 +253,7 @@ pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n pub fn find_crateid(attrs: &[Attribute]) -> Option<CrateId> {\n     match first_attr_value_str_by_name(attrs, \"crate_id\") {\n         None => None,\n-        Some(id) => from_str::<CrateId>(id),\n+        Some(id) => from_str::<CrateId>(id.get()),\n     }\n }\n \n@@ -254,8 +270,8 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n         match attr.node.value.node {\n-          MetaWord(n) if \"inline\" == n => InlineHint,\n-          MetaList(n, ref items) if \"inline\" == n => {\n+          MetaWord(ref n) if n.equiv(&(\"inline\")) => InlineHint,\n+          MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n             if contains_name(*items, \"always\") {\n                 InlineAlways\n             } else if contains_name(*items, \"never\") {\n@@ -284,7 +300,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n     // this doesn't work.\n     let some_cfg_matches = metas.any(|mi| {\n         debug!(\"testing name: {}\", mi.name());\n-        if \"cfg\" == mi.name() { // it is a #[cfg()] attribute\n+        if mi.name().equiv(&(\"cfg\")) { // it is a #[cfg()] attribute\n             debug!(\"is cfg\");\n             no_cfgs = false;\n              // only #[cfg(...)] ones are understood.\n@@ -294,7 +310,8 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n                     cfg_meta.iter().all(|cfg_mi| {\n                         debug!(\"cfg({}[...])\", cfg_mi.name());\n                         match cfg_mi.node {\n-                            ast::MetaList(s, ref not_cfgs) if \"not\" == s => {\n+                            ast::MetaList(ref s, ref not_cfgs)\n+                            if s.equiv(&(\"not\")) => {\n                                 debug!(\"not!\");\n                                 // inside #[cfg(not(...))], so these need to all\n                                 // not match.\n@@ -320,7 +337,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n /// Represents the #[deprecated=\"foo\"] (etc) attributes.\n pub struct Stability {\n     level: StabilityLevel,\n-    text: Option<@str>\n+    text: Option<InternedString>\n }\n \n /// The available stability levels.\n@@ -335,9 +352,10 @@ pub enum StabilityLevel {\n }\n \n /// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It) -> Option<Stability> {\n+pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n+                      -> Option<Stability> {\n     for m in metas {\n-        let level = match m.name().as_slice() {\n+        let level = match m.name().get() {\n             \"deprecated\" => Deprecated,\n             \"experimental\" => Experimental,\n             \"unstable\" => Unstable,\n@@ -360,7 +378,7 @@ pub fn require_unique_names(diagnostic: @SpanHandler, metas: &[@MetaItem]) {\n     for meta in metas.iter() {\n         let name = meta.name();\n \n-        if !set.insert(name) {\n+        if !set.insert(name.clone()) {\n             diagnostic.span_fatal(meta.span,\n                                   format!(\"duplicate meta item `{}`\", name));\n         }\n@@ -384,14 +402,14 @@ pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprA\n     -> ReprAttr {\n     let mut acc = acc;\n     match attr.node {\n-        ast::MetaList(s, ref items) if \"repr\" == s => {\n+        ast::MetaList(ref s, ref items) if s.equiv(&(\"repr\")) => {\n             for item in items.iter() {\n                 match item.node {\n-                    ast::MetaWord(word) => {\n-                        let hint = match word.as_slice() {\n+                    ast::MetaWord(ref word) => {\n+                        let hint = match word.get() {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => ReprExtern,\n-                            _ => match int_type_of_word(word) {\n+                            _ => match int_type_of_word(word.get()) {\n                                 Some(ity) => ReprInt(item.span, ity),\n                                 None => {\n                                     // Not a word we recognize"}, {"sha": "2ada3ac16ea6674dea57f361caeda55cc26232a8", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -160,17 +160,17 @@ pub struct LocWithOpt {\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n \n-#[deriving(IterBytes)]\n+#[deriving(Clone, IterBytes)]\n pub enum MacroFormat {\n     // e.g. #[deriving(...)] <item>\n     MacroAttribute,\n     // e.g. `format!()`\n     MacroBang\n }\n \n-#[deriving(IterBytes)]\n+#[deriving(Clone, IterBytes)]\n pub struct NameAndSpan {\n-    name: @str,\n+    name: ~str,\n     // the format with which the macro was invoked.\n     format: MacroFormat,\n     span: Option<Span>\n@@ -183,7 +183,7 @@ pub struct ExpnInfo {\n     callee: NameAndSpan\n }\n \n-pub type FileName = @str;\n+pub type FileName = ~str;\n \n pub struct FileLines\n {\n@@ -206,7 +206,7 @@ pub struct FileMap {\n     /// e.g. `<anon>`\n     name: FileName,\n     /// The complete source code\n-    src: @str,\n+    src: ~str,\n     /// The start position of this source in the CodeMap\n     start_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n@@ -267,7 +267,7 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn new_filemap(&self, filename: FileName, src: @str) -> @FileMap {\n+    pub fn new_filemap(&self, filename: FileName, src: ~str) -> @FileMap {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.get().last() {\n             None => 0,\n@@ -301,7 +301,7 @@ impl CodeMap {\n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n         LocWithOpt {\n-            filename: loc.file.name,\n+            filename: loc.file.name.to_str(),\n             line: loc.line,\n             col: loc.col,\n             file: Some(loc.file)\n@@ -324,7 +324,7 @@ impl CodeMap {\n \n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n         let lo = self.lookup_char_pos(sp.lo);\n-        lo.file.name\n+        lo.file.name.to_str()\n     }\n \n     pub fn span_to_lines(&self, sp: Span) -> @FileLines {\n@@ -468,7 +468,7 @@ mod test {\n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(@\"blork.rs\",@\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n         fm.next_line(BytePos(0));\n         assert_eq!(&fm.get_line(0),&~\"first line.\");\n         // TESTING BROKEN BEHAVIOR:\n@@ -480,7 +480,7 @@ mod test {\n     #[should_fail]\n     fn t2 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(@\"blork.rs\",@\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n         fm.next_line(BytePos(10));"}, {"sha": "1a3ebf3ce5d1cccdbd04140d1ec338f59cebcc02", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -17,6 +17,7 @@ use codemap::Span;\n use ext::base;\n use ext::base::*;\n use parse;\n+use parse::token::InternedString;\n use parse::token;\n \n enum State {\n@@ -43,7 +44,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                            cx.cfg(),\n                                            tts.to_owned());\n \n-    let mut asm = @\"\";\n+    let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;\n     let mut outputs = ~[];\n     let mut inputs = ~[];\n@@ -79,10 +80,10 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let (constraint, _str_style) = p.parse_str();\n \n-                    if constraint.starts_with(\"+\") {\n+                    if constraint.get().starts_with(\"+\") {\n                         cx.span_unimpl(p.last_span,\n                                        \"'+' (read+write) output operand constraint modifier\");\n-                    } else if !constraint.starts_with(\"=\") {\n+                    } else if !constraint.get().starts_with(\"=\") {\n                         cx.span_err(p.last_span, \"output operand constraint lacks '='\");\n                     }\n \n@@ -104,9 +105,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let (constraint, _str_style) = p.parse_str();\n \n-                    if constraint.starts_with(\"=\") {\n+                    if constraint.get().starts_with(\"=\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '='\");\n-                    } else if constraint.starts_with(\"+\") {\n+                    } else if constraint.get().starts_with(\"+\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n@@ -137,11 +138,11 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             Options => {\n                 let (option, _str_style) = p.parse_str();\n \n-                if \"volatile\" == option {\n+                if option.equiv(&(\"volatile\")) {\n                     volatile = true;\n-                } else if \"alignstack\" == option {\n+                } else if option.equiv(&(\"alignstack\")) {\n                     alignstack = true;\n-                } else if \"intel\" == option {\n+                } else if option.equiv(&(\"intel\")) {\n                     dialect = ast::AsmIntel;\n                 }\n \n@@ -191,9 +192,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     MRExpr(@ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n-            asm: asm,\n+            asm: token::intern_and_get_ident(asm.get()),\n             asm_str_style: asm_str_style.unwrap(),\n-            clobbers: cons.to_managed(),\n+            clobbers: token::intern_and_get_ident(cons),\n             inputs: inputs,\n             outputs: outputs,\n             volatile: volatile,"}, {"sha": "08098b71ce450544f989231545aec3d8564e6d61", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -16,7 +16,7 @@ use ext;\n use ext::expand;\n use parse;\n use parse::token;\n-use parse::token::{ident_to_str, intern, str_to_ident};\n+use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use std::hashmap::HashMap;\n@@ -31,7 +31,7 @@ use std::unstable::dynamic_lib::DynamicLibrary;\n // ast::MacInvocTT.\n \n pub struct MacroDef {\n-    name: @str,\n+    name: ~str,\n     ext: SyntaxExtension\n }\n \n@@ -335,7 +335,8 @@ impl<'a> ExtCtxt<'a> {\n                     Some(@ExpnInfo {\n                         call_site: Span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: self.backtrace},\n-                        callee: *callee});\n+                        callee: (*callee).clone()\n+                    });\n             }\n         }\n     }\n@@ -396,9 +397,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.trace_mac = x\n     }\n-    pub fn str_of(&self, id: ast::Ident) -> @str {\n-        ident_to_str(&id)\n-    }\n     pub fn ident_of(&self, st: &str) -> ast::Ident {\n         str_to_ident(st)\n     }\n@@ -407,11 +405,11 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from `expr`, emitting `err_msg` if `expr`\n /// is not a string literal. This does not stop compilation on error,\n /// merely emits a non-fatal error and returns None.\n-pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr,\n-                   err_msg: &str) -> Option<(@str, ast::StrStyle)> {\n+pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr, err_msg: &str)\n+                   -> Option<(InternedString, ast::StrStyle)> {\n     match expr.node {\n         ast::ExprLit(l) => match l.node {\n-            ast::LitStr(s, style) => return Some((s, style)),\n+            ast::LitStr(ref s, style) => return Some(((*s).clone(), style)),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n@@ -424,7 +422,9 @@ pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr,\n /// compilation should call\n /// `cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be\n /// done as rarely as possible).\n-pub fn check_zero_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree],\n+pub fn check_zero_tts(cx: &ExtCtxt,\n+                      sp: Span,\n+                      tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_err(sp, format!(\"{} takes no arguments\", name));\n@@ -437,13 +437,16 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n                                sp: Span,\n                                tts: &[ast::TokenTree],\n                                name: &str)\n-                               -> Option<@str> {\n+                               -> Option<~str> {\n     if tts.len() != 1 {\n         cx.span_err(sp, format!(\"{} takes 1 argument.\", name));\n     } else {\n         match tts[0] {\n             ast::TTTok(_, token::LIT_STR(ident))\n-                | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => return Some(cx.str_of(ident)),\n+            | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n+                let interned_str = token::get_ident(ident.name);\n+                return Some(interned_str.get().to_str())\n+            }\n             _ => cx.span_err(sp, format!(\"{} requires a string.\", name)),\n         }\n     }"}, {"sha": "c5ee19484668e675f3194d23dde290ef6c188490", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -19,6 +19,7 @@ use fold::Folder;\n use opt_vec;\n use opt_vec::OptVec;\n use parse::token::special_idents;\n+use parse::token;\n \n pub struct Field {\n     ident: ast::Ident,\n@@ -134,13 +135,13 @@ pub trait AstBuilder {\n     fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr;\n-    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr;\n+    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr;\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr;\n \n     fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr;\n     fn expr_none(&self, sp: Span) -> @ast::Expr;\n \n-    fn expr_fail(&self, span: Span, msg: @str) -> @ast::Expr;\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr;\n     fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n \n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n@@ -228,9 +229,17 @@ pub trait AstBuilder {\n \n     fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: @str) -> @ast::MetaItem;\n-    fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem;\n-    fn meta_name_value(&self, sp: Span, name: @str, value: ast::Lit_) -> @ast::MetaItem;\n+    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem;\n+    fn meta_list(&self,\n+                 sp: Span,\n+                 name: InternedString,\n+                 mis: ~[@ast::MetaItem])\n+                 -> @ast::MetaItem;\n+    fn meta_name_value(&self,\n+                       sp: Span,\n+                       name: InternedString,\n+                       value: ast::Lit_)\n+                       -> @ast::MetaItem;\n \n     fn view_use(&self, sp: Span,\n                 vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem;\n@@ -581,10 +590,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n-    fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr {\n+    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n-    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr {\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n     }\n \n@@ -612,7 +621,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(none)\n     }\n \n-    fn expr_fail(&self, span: Span, msg: @str) -> @ast::Expr {\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n@@ -623,13 +632,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             ],\n             ~[\n                 self.expr_str(span, msg),\n-                self.expr_str(span, loc.file.name),\n+                self.expr_str(span,\n+                              token::intern_and_get_ident(loc.file.name)),\n                 self.expr_uint(span, loc.line),\n             ])\n     }\n \n     fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n-        self.expr_fail(span, @\"internal error: entered unreachable code\")\n+        self.expr_fail(span,\n+                       InternedString::new(\n+                           \"internal error: entered unreachable code\"))\n     }\n \n \n@@ -866,13 +878,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn meta_word(&self, sp: Span, w: @str) -> @ast::MetaItem {\n+    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem {\n         @respan(sp, ast::MetaWord(w))\n     }\n-    fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem {\n+    fn meta_list(&self,\n+                 sp: Span,\n+                 name: InternedString,\n+                 mis: ~[@ast::MetaItem])\n+                 -> @ast::MetaItem {\n         @respan(sp, ast::MetaList(name, mis))\n     }\n-    fn meta_name_value(&self, sp: Span, name: @str, value: ast::Lit_) -> @ast::MetaItem {\n+    fn meta_name_value(&self,\n+                       sp: Span,\n+                       name: InternedString,\n+                       value: ast::Lit_)\n+                       -> @ast::MetaItem {\n         @respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n     }\n "}, {"sha": "6852a0cec33ac4b3507e3fbbbd84dee6363922a4", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -31,8 +31,8 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n             // expression is a literal\n             ast::ExprLit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n-                ast::LitStr(s, _) => {\n-                    for byte in s.bytes() {\n+                ast::LitStr(ref s, _) => {\n+                    for byte in s.get().bytes() {\n                         bytes.push(cx.expr_u8(expr.span, byte));\n                     }\n                 }"}, {"sha": "295c456c9d0bc316e085fe9949bd2dfdae8c1ffa", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -21,9 +21,10 @@ use ext::base;\n use ext::build::AstBuilder;\n use attr;\n use attr::*;\n-use parse;\n-use parse::token;\n use parse::attr::ParserAttr;\n+use parse::token::InternedString;\n+use parse::token;\n+use parse;\n \n pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n@@ -39,7 +40,7 @@ pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::M\n     }\n \n     // test_cfg searches for meta items looking like `cfg(foo, ...)`\n-    let in_cfg = &[cx.meta_list(sp, @\"cfg\", cfgs)];\n+    let in_cfg = &[cx.meta_list(sp, InternedString::new(\"cfg\"), cfgs)];\n \n     let matches_cfg = attr::test_cfg(cx.cfg(), in_cfg.iter().map(|&x| x));\n     let e = cx.expr_bool(sp, matches_cfg);"}, {"sha": "c13f9bf92af022257248a152aa18b7ee090b5216", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -14,6 +14,7 @@ use ast;\n use codemap;\n use ext::base;\n use ext::build::AstBuilder;\n+use parse::token;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n@@ -28,9 +29,10 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n         match e.node {\n             ast::ExprLit(lit) => {\n                 match lit.node {\n-                    ast::LitStr(s, _) | ast::LitFloat(s, _)\n-                    | ast::LitFloatUnsuffixed(s) => {\n-                        accumulator.push_str(s);\n+                    ast::LitStr(ref s, _) |\n+                    ast::LitFloat(ref s, _) |\n+                    ast::LitFloatUnsuffixed(ref s) => {\n+                        accumulator.push_str(s.get());\n                     }\n                     ast::LitChar(c) => {\n                         accumulator.push_char(char::from_u32(c).unwrap());\n@@ -55,5 +57,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    return base::MRExpr(cx.expr_str(sp, accumulator.to_managed()));\n+    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(accumulator)))\n }"}, {"sha": "e0d53add6489fec9e6ced7165996504061b46723", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -30,7 +30,10 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             }\n         } else {\n             match *e {\n-                ast::TTTok(_, token::IDENT(ident,_)) => res_str.push_str(cx.str_of(ident)),\n+                ast::TTTok(_, token::IDENT(ident,_)) => {\n+                    let interned_str = token::get_ident(ident.name);\n+                    res_str.push_str(interned_str.get())\n+                }\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n                     return MacResult::dummy_expr();"}, {"sha": "019a4dfe7cca4573b162078dbb205d6253958b53", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -18,6 +18,8 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token::InternedString;\n+use parse::token;\n \n pub fn expand_deriving_decodable(cx: &ExtCtxt,\n                                  span: Span,\n@@ -82,10 +84,15 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                                       cx.expr_uint(span, field),\n                                       lambdadecode])\n             });\n-            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_struct\"),\n-                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(trait_span, nfields),\n-                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n+            cx.expr_method_call(trait_span,\n+                                decoder,\n+                                cx.ident_of(\"read_struct\"),\n+                                ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_uint(trait_span, nfields),\n+                cx.lambda_expr_1(trait_span, result, blkarg)\n+            ])\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n@@ -95,7 +102,8 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n-                variants.push(cx.expr_str(v_span, cx.str_of(name)));\n+                variants.push(cx.expr_str(v_span,\n+                                          token::get_ident(name.name)));\n \n                 let decoded = decode_static_fields(cx,\n                                                    v_span,\n@@ -120,9 +128,14 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             let result = cx.expr_method_call(trait_span, blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n                                              ~[variant_vec, lambda]);\n-            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_enum\"),\n-                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n-                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n+            cx.expr_method_call(trait_span,\n+                                decoder,\n+                                cx.ident_of(\"read_enum\"),\n+                                ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                cx.lambda_expr_1(trait_span, result, blkarg)\n+            ])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };\n@@ -135,15 +148,18 @@ fn decode_static_fields(cx: &ExtCtxt,\n                         trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: |Span, @str, uint| -> @Expr)\n+                        getarg: |Span, InternedString, uint| -> @Expr)\n                         -> @Expr {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {\n                 cx.expr_ident(trait_span, outer_pat_ident)\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n-                    getarg(span, format!(\"_field{}\", i).to_managed(), i)\n+                    getarg(span,\n+                           token::intern_and_get_ident(format!(\"_field{}\",\n+                                                               i)),\n+                           i)\n                 }).collect();\n \n                 cx.expr_call_ident(trait_span, outer_pat_ident, fields)\n@@ -152,7 +168,9 @@ fn decode_static_fields(cx: &ExtCtxt,\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n-                cx.field_imm(span, name, getarg(span, cx.str_of(name), i))\n+                cx.field_imm(span,\n+                             name,\n+                             getarg(span, token::get_ident(name.name), i))\n             }).collect();\n             cx.expr_struct_ident(trait_span, outer_pat_ident, fields)\n         }"}, {"sha": "c50c9f18389c2ff897b979f861b0b0c16687ebd6", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -80,6 +80,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token;\n \n pub fn expand_deriving_encodable(cx: &ExtCtxt,\n                                  span: Span,\n@@ -125,10 +126,17 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n-            for (i, &FieldInfo { name, self_, span, .. }) in fields.iter().enumerate() {\n+            for (i, &FieldInfo {\n+                    name,\n+                    self_,\n+                    span,\n+                    ..\n+                }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => cx.str_of(id),\n-                    None => format!(\"_field{}\", i).to_managed()\n+                    Some(id) => token::get_ident(id.name),\n+                    None => {\n+                        token::intern_and_get_ident(format!(\"_field{}\", i))\n+                    }\n                 };\n                 let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n@@ -141,10 +149,15 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            cx.expr_method_call(trait_span, encoder, cx.ident_of(\"emit_struct\"),\n-                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(trait_span, fields.len()),\n-                                  blk])\n+            cx.expr_method_call(trait_span,\n+                                encoder,\n+                                cx.ident_of(\"emit_struct\"),\n+                                ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_uint(trait_span, fields.len()),\n+                blk\n+            ])\n         }\n \n         EnumMatching(idx, variant, ref fields) => {\n@@ -167,19 +180,23 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, cx.str_of(variant.node.name));\n+            let name = cx.expr_str(trait_span,\n+                                   token::get_ident(variant.node.name.name));\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            ~[name,\n                                              cx.expr_uint(trait_span, idx),\n                                              cx.expr_uint(trait_span, fields.len()),\n                                              blk]);\n             let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n-            let ret = cx.expr_method_call(trait_span, encoder,\n+            let ret = cx.expr_method_call(trait_span,\n+                                          encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          ~[cx.expr_str(trait_span,\n-                                            cx.str_of(substr.type_ident)),\n-                                            blk]);\n+                                          ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                blk\n+            ]);\n             cx.expr_block(cx.block(trait_span, ~[me], Some(ret)))\n         }\n "}, {"sha": "8eaff592765b2ef7581c2551b684fa9e151a510b", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -184,6 +184,8 @@ use ext::build::AstBuilder;\n use codemap;\n use codemap::Span;\n use opt_vec;\n+use parse::token::InternedString;\n+use parse::token;\n \n use std::vec;\n \n@@ -396,8 +398,10 @@ impl<'a> TraitDef<'a> {\n         let doc_attr = cx.attribute(\n             self.span,\n             cx.meta_name_value(self.span,\n-                               @\"doc\",\n-                               ast::LitStr(@\"Automatically derived.\", ast::CookedStr)));\n+                               InternedString::new(\"doc\"),\n+                               ast::LitStr(token::intern_and_get_ident(\n+                                       \"Automatically derived.\"),\n+                                       ast::CookedStr)));\n         cx.item(\n             self.span,\n             ::parse::token::special_idents::clownshoes_extensions,\n@@ -567,7 +571,14 @@ impl<'a> MethodDef<'a> {\n         let body_block = trait_.cx.block_expr(body);\n \n         let attrs = if self.inline {\n-            ~[trait_.cx.attribute(trait_.span, trait_.cx.meta_word(trait_.span, @\"inline\"))]\n+            ~[\n+                trait_.cx\n+                      .attribute(trait_.span,\n+                                 trait_.cx\n+                                       .meta_word(trait_.span,\n+                                                  InternedString::new(\n+                                                      \"inline\")))\n+            ]\n         } else {\n             ~[]\n         };\n@@ -933,7 +944,7 @@ impl<'a> TraitDef<'a> {\n         to_set.expn_info = Some(@codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n-                name: format!(\"deriving({})\", trait_name).to_managed(),\n+                name: format!(\"deriving({})\", trait_name),\n                 format: codemap::MacroAttribute,\n                 span: Some(self.span)\n             }"}, {"sha": "9c487146639bb2fc380303305d1f0d7f104dd17b", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -75,12 +75,12 @@ pub fn expand_meta_deriving(cx: &ExtCtxt,\n         MetaList(_, ref titems) => {\n             titems.rev_iter().fold(in_items, |in_items, &titem| {\n                 match titem.node {\n-                    MetaNameValue(tname, _) |\n-                    MetaList(tname, _) |\n-                    MetaWord(tname) => {\n+                    MetaNameValue(ref tname, _) |\n+                    MetaList(ref tname, _) |\n+                    MetaWord(ref tname) => {\n                         macro_rules! expand(($func:path) => ($func(cx, titem.span,\n                                                                    titem, in_items)));\n-                        match tname.as_slice() {\n+                        match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n                             \"DeepClone\" => expand!(clone::expand_deriving_deep_clone),\n "}, {"sha": "e2f72e8708551adea5a574b95868316cb52d0754", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -14,6 +14,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token::InternedString;\n \n pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n                                       span: Span,\n@@ -73,13 +74,13 @@ fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) ->\n     match *substr.fields {\n         StaticStruct(..) => {\n             cx.span_err(trait_span, \"`FromPrimitive` cannot be derived for structs\");\n-            return cx.expr_fail(trait_span, @\"\");\n+            return cx.expr_fail(trait_span, InternedString::new(\"\"));\n         }\n         StaticEnum(enum_def, _) => {\n             if enum_def.variants.is_empty() {\n                 cx.span_err(trait_span,\n                             \"`FromPrimitive` cannot be derived for enums with no variants\");\n-                return cx.expr_fail(trait_span, @\"\");\n+                return cx.expr_fail(trait_span, InternedString::new(\"\"));\n             }\n \n             let mut arms = ~[];\n@@ -91,7 +92,8 @@ fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) ->\n                             cx.span_err(trait_span,\n                                         \"`FromPrimitive` cannot be derived for \\\n                                         enum variants with arguments\");\n-                            return cx.expr_fail(trait_span, @\"\");\n+                            return cx.expr_fail(trait_span,\n+                                                InternedString::new(\"\"));\n                         }\n                         let span = variant.span;\n \n@@ -117,7 +119,8 @@ fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) ->\n                         cx.span_err(trait_span,\n                                     \"`FromPrimitive` cannot be derived for enums \\\n                                     with struct variants\");\n-                        return cx.expr_fail(trait_span, @\"\");\n+                        return cx.expr_fail(trait_span,\n+                                            InternedString::new(\"\"));\n                     }\n                 }\n             }"}, {"sha": "6101d647ca5dd9beed219375ecb0a3623760b211", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -14,6 +14,8 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token::InternedString;\n+use parse::token;\n \n pub fn expand_deriving_to_str(cx: &ExtCtxt,\n                               span: Span,\n@@ -47,18 +49,22 @@ pub fn expand_deriving_to_str(cx: &ExtCtxt,\n // doesn't invoke the to_str() method on each field. Hence we mirror\n // the logic of the repr_to_str() method, but with tweaks to call to_str()\n // on sub-fields.\n-fn to_str_substructure(cx: &ExtCtxt, span: Span,\n-                       substr: &Substructure) -> @Expr {\n+fn to_str_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure)\n+                       -> @Expr {\n     let to_str = cx.ident_of(\"to_str\");\n \n-    let doit = |start: &str, end: @str, name: ast::Ident,\n+    let doit = |start: &str,\n+                end: InternedString,\n+                name: ast::Ident,\n                 fields: &[FieldInfo]| {\n         if fields.len() == 0 {\n-            cx.expr_str_uniq(span, cx.str_of(name))\n+            cx.expr_str_uniq(span, token::get_ident(name.name))\n         } else {\n             let buf = cx.ident_of(\"buf\");\n-            let start = cx.str_of(name) + start;\n-            let init = cx.expr_str_uniq(span, start.to_managed());\n+            let interned_str = token::get_ident(name.name);\n+            let start =\n+                token::intern_and_get_ident(interned_str.get() + start);\n+            let init = cx.expr_str_uniq(span, start);\n             let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n             let push_str = cx.ident_of(\"push_str\");\n \n@@ -70,38 +76,53 @@ fn to_str_substructure(cx: &ExtCtxt, span: Span,\n \n             for (i, &FieldInfo {name, span, self_, .. }) in fields.iter().enumerate() {\n                 if i > 0 {\n-                    push(cx.expr_str(span, @\", \"));\n+                    push(cx.expr_str(span, InternedString::new(\", \")));\n                 }\n                 match name {\n                     None => {}\n                     Some(id) => {\n-                        let name = cx.str_of(id) + \": \";\n-                        push(cx.expr_str(span, name.to_managed()));\n+                        let interned_id = token::get_ident(id.name);\n+                        let name = interned_id.get() + \": \";\n+                        push(cx.expr_str(span,\n+                                         token::intern_and_get_ident(name)));\n                     }\n                 }\n                 push(cx.expr_method_call(span, self_, to_str, ~[]));\n             }\n             push(cx.expr_str(span, end));\n \n-            cx.expr_block(cx.block(span, stmts, Some(cx.expr_ident(span, buf))))\n+            cx.expr_block(cx.block(span, stmts, Some(cx.expr_ident(span,\n+                                                                   buf))))\n         }\n     };\n \n     return match *substr.fields {\n         Struct(ref fields) => {\n             if fields.len() == 0 || fields[0].name.is_none() {\n-                doit(\"(\", @\")\", substr.type_ident, *fields)\n+                doit(\"(\",\n+                     InternedString::new(\")\"),\n+                     substr.type_ident,\n+                     *fields)\n             } else {\n-                doit(\"{\", @\"}\", substr.type_ident, *fields)\n+                doit(\"{\",\n+                     InternedString::new(\"}\"),\n+                     substr.type_ident,\n+                     *fields)\n             }\n         }\n \n         EnumMatching(_, variant, ref fields) => {\n             match variant.node.kind {\n                 ast::TupleVariantKind(..) =>\n-                    doit(\"(\", @\")\", variant.node.name, *fields),\n+                    doit(\"(\",\n+                         InternedString::new(\")\"),\n+                         variant.node.name,\n+                         *fields),\n                 ast::StructVariantKind(..) =>\n-                    doit(\"{\", @\"}\", variant.node.name, *fields),\n+                    doit(\"{\",\n+                         InternedString::new(\"}\"),\n+                         variant.node.name,\n+                         *fields),\n             }\n         }\n "}, {"sha": "c23a1ce1e28d5f8592ec559bec8a12323cf1b7bb", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -19,6 +19,7 @@ use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n+use parse::token;\n \n use std::os;\n \n@@ -52,7 +53,11 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some((v, _style)) => v\n     };\n     let msg = match exprs.len() {\n-        1 => format!(\"environment variable `{}` not defined\", var).to_managed(),\n+        1 => {\n+            token::intern_and_get_ident(format!(\"environment variable `{}` \\\n+                                                 not defined\",\n+                                                var))\n+        }\n         2 => {\n             match expr_to_str(cx, exprs[1], \"expected string literal\") {\n                 None => return MacResult::dummy_expr(),\n@@ -65,12 +70,12 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     };\n \n-    let e = match os::getenv(var) {\n+    let e = match os::getenv(var.get()) {\n         None => {\n-            cx.span_err(sp, msg);\n+            cx.span_err(sp, msg.get());\n             cx.expr_uint(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, s.to_managed())\n+        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s))\n     };\n     MRExpr(e)\n }"}, {"sha": "d8d98b2779316b5d1a15cf6a918f23fbd85230e8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 78, "deletions": 52, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -22,8 +22,8 @@ use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n use fold::*;\n use parse;\n+use parse::token::{fresh_mark, fresh_name, intern};\n use parse::token;\n-use parse::token::{fresh_mark, fresh_name, ident_to_str, intern};\n use visit;\n use visit::Visitor;\n use util::small_vector::SmallVector;\n@@ -54,13 +54,14 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                         return e;\n                     }\n                     let extname = &pth.segments[0].identifier;\n-                    let extnamestr = ident_to_str(extname);\n+                    let extnamestr = token::get_ident(extname.name);\n                     // leaving explicit deref here to highlight unbox op:\n                     let marked_after = match fld.extsbox.find(&extname.name) {\n                         None => {\n                             fld.cx.span_err(\n                                 pth.span,\n-                                format!(\"macro undefined: '{}'\", extnamestr));\n+                                format!(\"macro undefined: '{}'\",\n+                                        extnamestr.get()));\n \n                             // let compilation continue\n                             return e;\n@@ -69,7 +70,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                             fld.cx.bt_push(ExpnInfo {\n                                 call_site: e.span,\n                                 callee: NameAndSpan {\n-                                    name: extnamestr,\n+                                    name: extnamestr.get().to_str(),\n                                     format: MacroBang,\n                                     span: exp_span,\n                                 },\n@@ -94,7 +95,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                                         pth.span,\n                                         format!(\n                                             \"non-expr macro in expr pos: {}\",\n-                                            extnamestr\n+                                            extnamestr.get()\n                                         )\n                                     );\n                                     return e;\n@@ -107,7 +108,8 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                         _ => {\n                             fld.cx.span_err(\n                                 pth.span,\n-                                format!(\"'{}' is not a tt-style macro\", extnamestr)\n+                                format!(\"'{}' is not a tt-style macro\",\n+                                        extnamestr.get())\n                             );\n                             return e;\n                         }\n@@ -221,12 +223,12 @@ pub fn expand_mod_items(module_: &ast::Mod, fld: &mut MacroExpander) -> ast::Mod\n         item.attrs.rev_iter().fold(~[*item], |items, attr| {\n             let mname = attr.name();\n \n-            match fld.extsbox.find(&intern(mname)) {\n+            match fld.extsbox.find(&intern(mname.get())) {\n               Some(&ItemDecorator(dec_fn)) => {\n                   fld.cx.bt_push(ExpnInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n-                          name: mname,\n+                          name: mname.get().to_str(),\n                           format: MacroAttribute,\n                           span: None\n                       }\n@@ -295,28 +297,31 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n     };\n \n     let extname = &pth.segments[0].identifier;\n-    let extnamestr = ident_to_str(extname);\n+    let extnamestr = token::get_ident(extname.name);\n     let fm = fresh_mark();\n     let expanded = match fld.extsbox.find(&extname.name) {\n         None => {\n             fld.cx.span_err(pth.span,\n-                            format!(\"macro undefined: '{}!'\", extnamestr));\n+                            format!(\"macro undefined: '{}!'\",\n+                                    extnamestr.get()));\n             // let compilation continue\n             return SmallVector::zero();\n         }\n \n         Some(&NormalTT(ref expander, span)) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n+                let string = token::get_ident(it.ident.name);\n                 fld.cx.span_err(pth.span,\n                                 format!(\"macro {}! expects no ident argument, \\\n-                                        given '{}'\", extnamestr,\n-                                        ident_to_str(&it.ident)));\n+                                        given '{}'\",\n+                                        extnamestr.get(),\n+                                        string.get()));\n                 return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: extnamestr,\n+                    name: extnamestr.get().to_str(),\n                     format: MacroBang,\n                     span: span\n                 }\n@@ -328,13 +333,14 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n         Some(&IdentTT(ref expander, span)) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n                 fld.cx.span_err(pth.span,\n-                                format!(\"macro {}! expects an ident argument\", extnamestr));\n+                                format!(\"macro {}! expects an ident argument\",\n+                                        extnamestr.get()));\n                 return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: extnamestr,\n+                    name: extnamestr.get().to_str(),\n                     format: MacroBang,\n                     span: span\n                 }\n@@ -344,7 +350,9 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n             expander.expand(fld.cx, it.span, it.ident, marked_tts)\n         }\n         _ => {\n-            fld.cx.span_err(it.span, format!(\"{}! is not legal in item position\", extnamestr));\n+            fld.cx.span_err(it.span,\n+                            format!(\"{}! is not legal in item position\",\n+                                    extnamestr.get()));\n             return SmallVector::zero();\n         }\n     };\n@@ -356,7 +364,9 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n                 .collect()\n         }\n         MRExpr(_) => {\n-            fld.cx.span_err(pth.span, format!(\"expr macro in item position: {}\", extnamestr));\n+            fld.cx.span_err(pth.span,\n+                            format!(\"expr macro in item position: {}\",\n+                                    extnamestr.get()));\n             return SmallVector::zero();\n         }\n         MRAny(any_macro) => {\n@@ -385,7 +395,7 @@ pub fn expand_view_item(vi: &ast::ViewItem,\n                         fld: &mut MacroExpander)\n                         -> ast::ViewItem {\n     let should_load = vi.attrs.iter().any(|attr| {\n-        \"phase\" == attr.name() &&\n+        attr.name().get() == \"phase\" &&\n             attr.meta_item_list().map_or(false, |phases| {\n                 attr::contains_name(phases, \"syntax\")\n             })\n@@ -402,15 +412,18 @@ fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n     let MacroCrate { lib, cnum } = fld.cx.loader.load_crate(crate);\n \n     let crate_name = match crate.node {\n-        ast::ViewItemExternMod(ref name, _, _) => token::ident_to_str(name),\n+        ast::ViewItemExternMod(ref name, _, _) => {\n+            let string = token::get_ident(name.name);\n+            string.get().to_str()\n+        },\n         _ => unreachable!(),\n     };\n-    let name = format!(\"<{} macros>\", crate_name).to_managed();\n+    let name = format!(\"<{} macros>\", crate_name);\n \n     let exported_macros = fld.cx.loader.get_exported_macros(cnum);\n     for source in exported_macros.iter() {\n-        let item = parse::parse_item_from_source_str(name,\n-                                                     source.to_managed(),\n+        let item = parse::parse_item_from_source_str(name.clone(),\n+                                                     (*source).clone(),\n                                                      fld.cx.cfg(),\n                                                      fld.cx.parse_sess())\n                 .expect(\"expected a serialized item\");\n@@ -475,18 +488,19 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n         return SmallVector::zero();\n     }\n     let extname = &pth.segments[0].identifier;\n-    let extnamestr = ident_to_str(extname);\n+    let extnamestr = token::get_ident(extname.name);\n     let marked_after = match fld.extsbox.find(&extname.name) {\n         None => {\n-            fld.cx.span_err(pth.span, format!(\"macro undefined: '{}'\", extnamestr));\n+            fld.cx.span_err(pth.span, format!(\"macro undefined: '{}'\",\n+                                              extnamestr.get()));\n             return SmallVector::zero();\n         }\n \n         Some(&NormalTT(ref expandfun, exp_span)) => {\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: s.span,\n                 callee: NameAndSpan {\n-                    name: extnamestr,\n+                    name: extnamestr.get().to_str(),\n                     format: MacroBang,\n                     span: exp_span,\n                 }\n@@ -511,7 +525,8 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                 MRAny(any_macro) => any_macro.make_stmt(),\n                 _ => {\n                     fld.cx.span_err(pth.span,\n-                                    format!(\"non-stmt macro in stmt pos: {}\", extnamestr));\n+                                    format!(\"non-stmt macro in stmt pos: {}\",\n+                                            extnamestr.get()));\n                     return SmallVector::zero();\n                 }\n             };\n@@ -520,7 +535,8 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n         }\n \n         _ => {\n-            fld.cx.span_err(pth.span, format!(\"'{}' is not a tt-style macro\", extnamestr));\n+            fld.cx.span_err(pth.span, format!(\"'{}' is not a tt-style macro\",\n+                                              extnamestr.get()));\n             return SmallVector::zero();\n         }\n     };\n@@ -945,7 +961,7 @@ mod test {\n     use fold::*;\n     use ext::base::{CrateLoader, MacroCrate};\n     use parse;\n-    use parse::token::{fresh_mark, gensym, intern, ident_to_str};\n+    use parse::token::{fresh_mark, gensym, intern};\n     use parse::token;\n     use util::parser_testing::{string_to_crate, string_to_crate_and_sess};\n     use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n@@ -1009,11 +1025,11 @@ mod test {\n     // make sure that macros can leave scope\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n-        let src = @\"fn bogus() {macro_rules! z (() => (3+4))}\\\n+        let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            @\"<test>\",\n+            ~\"<test>\",\n             src,\n             ~[],sess);\n         // should fail:\n@@ -1024,11 +1040,11 @@ mod test {\n     // make sure that macros can leave scope for modules\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n-        let src = @\"mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            @\"<test>\",\n+            ~\"<test>\",\n             src,\n             ~[],sess);\n         // should fail:\n@@ -1038,36 +1054,36 @@ mod test {\n \n     // macro_escape modules shouldn't cause macros to leave scope\n     #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = @\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            @\"<test>\",\n+            ~\"<test>\",\n             src,\n             ~[], sess);\n         // should fail:\n         let mut loader = ErrLoader;\n-        expand_crate(sess,&mut loader,~[],crate_ast);\n+        expand_crate(sess, &mut loader, ~[], crate_ast);\n     }\n \n     #[test] fn test_contains_flatten (){\n-        let attr1 = make_dummy_attr (@\"foo\");\n-        let attr2 = make_dummy_attr (@\"bar\");\n-        let escape_attr = make_dummy_attr (@\"macro_escape\");\n+        let attr1 = make_dummy_attr (\"foo\");\n+        let attr2 = make_dummy_attr (\"bar\");\n+        let escape_attr = make_dummy_attr (\"macro_escape\");\n         let attrs1 = ~[attr1, escape_attr, attr2];\n         assert_eq!(contains_macro_escape (attrs1),true);\n         let attrs2 = ~[attr1,attr2];\n         assert_eq!(contains_macro_escape (attrs2),false);\n     }\n \n     // make a MetaWord outer attribute with the given name\n-    fn make_dummy_attr(s: @str) -> ast::Attribute {\n+    fn make_dummy_attr(s: &str) -> ast::Attribute {\n         Spanned {\n             span:codemap::DUMMY_SP,\n             node: Attribute_ {\n                 style: AttrOuter,\n                 value: @Spanned {\n-                    node: MetaWord(s),\n+                    node: MetaWord(token::intern_and_get_ident(s)),\n                     span: codemap::DUMMY_SP,\n                 },\n                 is_sugared_doc: false,\n@@ -1077,7 +1093,7 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let item_ast = string_to_crate(@\"fn f() -> int { a }\");\n+        let item_ast = string_to_crate(~\"fn f() -> int { a }\");\n         let a_name = intern(\"a\");\n         let a2_name = gensym(\"a2\");\n         let mut renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n@@ -1116,7 +1132,7 @@ mod test {\n     //    pprust::print_crate_(&mut s, crate);\n     //}\n \n-    fn expand_crate_str(crate_str: @str) -> ast::Crate {\n+    fn expand_crate_str(crate_str: ~str) -> ast::Crate {\n         let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n         // the cfg argument actually does matter, here...\n         let mut loader = ErrLoader;\n@@ -1134,7 +1150,7 @@ mod test {\n     //}\n \n     #[test] fn macro_tokens_should_match(){\n-        expand_crate_str(@\"macro_rules! m((a)=>(13)) fn main(){m!(a);}\");\n+        expand_crate_str(~\"macro_rules! m((a)=>(13)) fn main(){m!(a);}\");\n     }\n \n     // renaming tests expand a crate and then check that the bindings match\n@@ -1208,9 +1224,9 @@ mod test {\n     fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n         let invalid_name = token::special_idents::invalid.name;\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n-            (ref str,ref conns, bic) => (str.to_managed(), conns.clone(), bic)\n+            (ref str,ref conns, bic) => (str.to_owned(), conns.clone(), bic)\n         };\n-        let cr = expand_crate_str(teststr.to_managed());\n+        let cr = expand_crate_str(teststr.to_owned());\n         // find the bindings:\n         let mut name_finder = new_name_finder(~[]);\n         visit::walk_crate(&mut name_finder,&cr,());\n@@ -1260,9 +1276,12 @@ mod test {\n                         println!(\"uh oh, matches but shouldn't:\");\n                         println!(\"varref: {:?}\",varref);\n                         // good lord, you can't make a path with 0 segments, can you?\n+                        let string = token::get_ident(varref.segments[0]\n+                                                            .identifier\n+                                                            .name);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments[0].identifier.name,\n-                                 ident_to_str(&varref.segments[0].identifier));\n+                                 string.get());\n                         println!(\"binding: {:?}\", bindings[binding_idx]);\n                         ast_util::display_sctable(get_sctable());\n                     }\n@@ -1273,7 +1292,7 @@ mod test {\n     }\n \n     #[test] fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = @\"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n+        let crate_str = ~\"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n foo_module!()\n \";\n@@ -1284,7 +1303,10 @@ foo_module!()\n         let bindings = name_finder.ident_accumulator;\n \n         let cxbinds : ~[&ast::Ident] =\n-            bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n+            bindings.iter().filter(|b| {\n+                let string = token::get_ident(b.name);\n+                \"xx\" == string.get()\n+            }).collect();\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => fail!(\"expected just one binding for ext_cx\")\n@@ -1296,9 +1318,13 @@ foo_module!()\n         let varrefs = path_finder.path_accumulator;\n \n         // the xx binding should bind all of the xx varrefs:\n-        for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n-                                          && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))\n-                                     }).enumerate() {\n+        for (idx,v) in varrefs.iter().filter(|p|{\n+            p.segments.len() == 1\n+            && {\n+                let string = token::get_ident(p.segments[0].identifier.name);\n+                \"xx\" == string.get()\n+            }\n+        }).enumerate() {\n             if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");\n                 println!(\"this is xx varref \\\\# {:?}\",idx);\n@@ -1323,7 +1349,7 @@ foo_module!()\n \n     #[test]\n     fn pat_idents(){\n-        let pat = string_to_pat(@\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n+        let pat = string_to_pat(~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n         let mut pat_idents = new_name_finder(~[]);\n         pat_idents.visit_pat(pat, ());\n         assert_eq!(pat_idents.ident_accumulator,"}, {"sha": "ba1d5efdd49cd5a8ca787859217eb28fbb975460", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 80, "deletions": 55, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -14,23 +14,24 @@ use codemap::{Span, respan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use rsparse = parse;\n-use parse::token;\n use opt_vec;\n+use parse::token::InternedString;\n+use parse::token;\n+use rsparse = parse;\n use std::fmt::parse;\n use std::hashmap::{HashMap, HashSet};\n use std::vec;\n \n #[deriving(Eq)]\n enum ArgumentType {\n-    Known(@str),\n+    Known(~str),\n     Unsigned,\n     String,\n }\n \n enum Position {\n     Exact(uint),\n-    Named(@str),\n+    Named(~str),\n }\n \n struct Context<'a> {\n@@ -42,12 +43,12 @@ struct Context<'a> {\n     args: ~[@ast::Expr],\n     arg_types: ~[Option<ArgumentType>],\n     // Parsed named expressions and the types that we've found for them so far\n-    names: HashMap<@str, @ast::Expr>,\n-    name_types: HashMap<@str, ArgumentType>,\n+    names: HashMap<~str, @ast::Expr>,\n+    name_types: HashMap<~str, ArgumentType>,\n \n     // Collection of the compiled `rt::Piece` structures\n     pieces: ~[@ast::Expr],\n-    name_positions: HashMap<@str, uint>,\n+    name_positions: HashMap<~str, uint>,\n     method_statics: ~[@ast::Item],\n \n     // Updated as arguments are consumed or methods are entered\n@@ -104,10 +105,11 @@ impl<'a> Context<'a> {\n                         return (extra, None);\n                     }\n                 };\n-                let name = self.ecx.str_of(ident);\n+                let interned_name = token::get_ident(ident.name);\n+                let name = interned_name.get();\n                 p.expect(&token::EQ);\n                 let e = p.parse_expr();\n-                match self.names.find(&name) {\n+                match self.names.find_equiv(&name) {\n                     None => {}\n                     Some(prev) => {\n                         self.ecx.span_err(e.span, format!(\"duplicate argument \\\n@@ -117,7 +119,7 @@ impl<'a> Context<'a> {\n                         continue\n                     }\n                 }\n-                self.names.insert(name, e);\n+                self.names.insert(name.to_str(), e);\n             } else {\n                 self.args.push(p.parse_expr());\n                 self.arg_types.push(None);\n@@ -156,13 +158,13 @@ impl<'a> Context<'a> {\n                         Exact(i)\n                     }\n                     parse::ArgumentIs(i) => Exact(i),\n-                    parse::ArgumentNamed(s) => Named(s.to_managed()),\n+                    parse::ArgumentNamed(s) => Named(s.to_str()),\n                 };\n \n                 // and finally the method being applied\n                 match arg.method {\n                     None => {\n-                        let ty = Known(arg.format.ty.to_managed());\n+                        let ty = Known(arg.format.ty.to_str());\n                         self.verify_arg_type(pos, ty);\n                     }\n                     Some(ref method) => { self.verify_method(pos, *method); }\n@@ -184,7 +186,7 @@ impl<'a> Context<'a> {\n                 self.verify_arg_type(Exact(i), Unsigned);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_managed()), Unsigned);\n+                self.verify_arg_type(Named(s.to_str()), Unsigned);\n             }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {\n@@ -259,7 +261,13 @@ impl<'a> Context<'a> {\n                     self.ecx.span_err(self.fmtsp, msg);\n                     return;\n                 }\n-                self.verify_same(self.args[arg].span, ty, self.arg_types[arg]);\n+                {\n+                    let arg_type = match self.arg_types[arg] {\n+                        None => None,\n+                        Some(ref x) => Some(x)\n+                    };\n+                    self.verify_same(self.args[arg].span, &ty, arg_type);\n+                }\n                 if self.arg_types[arg].is_none() {\n                     self.arg_types[arg] = Some(ty);\n                 }\n@@ -274,10 +282,9 @@ impl<'a> Context<'a> {\n                         return;\n                     }\n                 };\n-                self.verify_same(span, ty,\n-                                 self.name_types.find(&name).map(|&x| x));\n+                self.verify_same(span, &ty, self.name_types.find(&name));\n                 if !self.name_types.contains_key(&name) {\n-                    self.name_types.insert(name, ty);\n+                    self.name_types.insert(name.clone(), ty);\n                 }\n                 // Assign this named argument a slot in the arguments array if\n                 // it hasn't already been assigned a slot.\n@@ -297,30 +304,36 @@ impl<'a> Context<'a> {\n     ///\n     /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n     /// that: `Some(None) == Some(Some(x))`\n-    fn verify_same(&self, sp: Span, ty: ArgumentType,\n-                   before: Option<ArgumentType>) {\n+    fn verify_same(&self,\n+                   sp: Span,\n+                   ty: &ArgumentType,\n+                   before: Option<&ArgumentType>) {\n         let cur = match before {\n             None => return,\n             Some(t) => t,\n         };\n-        if ty == cur { return }\n+        if *ty == *cur {\n+            return\n+        }\n         match (cur, ty) {\n-            (Known(cur), Known(ty)) => {\n+            (&Known(ref cur), &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument redeclared with type `{}` when \\\n-                                           it was previously `{}`\", ty, cur));\n+                                           it was previously `{}`\",\n+                                          *ty,\n+                                          *cur));\n             }\n-            (Known(cur), _) => {\n+            (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           cur));\n+                                           *cur));\n             }\n-            (_, Known(ty)) => {\n+            (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           ty));\n+                                           *ty));\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -333,13 +346,18 @@ impl<'a> Context<'a> {\n     fn static_attrs(&self) -> ~[ast::Attribute] {\n         // Flag statics as `address_insignificant` so LLVM can merge duplicate\n         // globals as much as possible (which we're generating a whole lot of).\n-        let unnamed = self.ecx.meta_word(self.fmtsp, @\"address_insignificant\");\n+        let unnamed = self.ecx\n+                          .meta_word(self.fmtsp,\n+                                     InternedString::new(\n+                                         \"address_insignificant\"));\n         let unnamed = self.ecx.attribute(self.fmtsp, unnamed);\n \n         // Do not warn format string as dead code\n-        let dead_code = self.ecx.meta_word(self.fmtsp, @\"dead_code\");\n+        let dead_code = self.ecx.meta_word(self.fmtsp,\n+                                           InternedString::new(\"dead_code\"));\n         let allow_dead_code = self.ecx.meta_list(self.fmtsp,\n-                                                 @\"allow\", ~[dead_code]);\n+                                                 InternedString::new(\"allow\"),\n+                                                 ~[dead_code]);\n         let allow_dead_code = self.ecx.attribute(self.fmtsp, allow_dead_code);\n         return ~[unnamed, allow_dead_code];\n     }\n@@ -391,9 +409,8 @@ impl<'a> Context<'a> {\n                     self.ecx.expr_path(path)\n                 }\n                 parse::CountIsName(n) => {\n-                    let n = n.to_managed();\n-                    let i = match self.name_positions.find_copy(&n) {\n-                        Some(i) => i,\n+                    let i = match self.name_positions.find_equiv(&n) {\n+                        Some(&i) => i,\n                         None => 0, // error already emitted elsewhere\n                     };\n                     let i = i + self.args.len();\n@@ -410,7 +427,7 @@ impl<'a> Context<'a> {\n                         let result = arm.result.iter().map(|p| {\n                             self.trans_piece(p)\n                         }).collect();\n-                        let s = arm.selector.to_managed();\n+                        let s = token::intern_and_get_ident(arm.selector);\n                         let selector = self.ecx.expr_str(sp, s);\n                         self.ecx.expr_struct(sp, p, ~[\n                             self.ecx.field_imm(sp,\n@@ -486,8 +503,12 @@ impl<'a> Context<'a> {\n \n         match *piece {\n             parse::String(s) => {\n-                self.ecx.expr_call_global(sp, rtpath(\"String\"),\n-                                          ~[self.ecx.expr_str(sp, s.to_managed())])\n+                let s = token::intern_and_get_ident(s);\n+                self.ecx.expr_call_global(sp,\n+                                          rtpath(\"String\"),\n+                                          ~[\n+                    self.ecx.expr_str(sp, s)\n+                ])\n             }\n             parse::CurrentArgument => {\n                 let nil = self.ecx.expr_lit(sp, ast::LitNil);\n@@ -509,9 +530,8 @@ impl<'a> Context<'a> {\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n                     parse::ArgumentNamed(n) => {\n-                        let n = n.to_managed();\n-                        let i = match self.name_positions.find_copy(&n) {\n-                            Some(i) => i,\n+                        let i = match self.name_positions.find_equiv(&n) {\n+                            Some(&i) => i,\n                             None => 0, // error already emitted elsewhere\n                         };\n                         let i = i + self.args.len();\n@@ -623,14 +643,17 @@ impl<'a> Context<'a> {\n             locals.push(self.format_arg(e.span, Exact(i),\n                                         self.ecx.expr_ident(e.span, name)));\n         }\n-        for (&name, &e) in self.names.iter() {\n-            if !self.name_types.contains_key(&name) { continue }\n+        for (name, &e) in self.names.iter() {\n+            if !self.name_types.contains_key(name) {\n+                continue\n+            }\n \n-            let lname = self.ecx.ident_of(format!(\"__arg{}\", name));\n+            let lname = self.ecx.ident_of(format!(\"__arg{}\", *name));\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n-            names[*self.name_positions.get(&name)] =\n-                Some(self.format_arg(e.span, Named(name),\n+            names[*self.name_positions.get(name)] =\n+                Some(self.format_arg(e.span,\n+                                     Named((*name).clone()),\n                                      self.ecx.expr_ident(e.span, lname)));\n         }\n \n@@ -672,16 +695,16 @@ impl<'a> Context<'a> {\n                                            Some(result)))\n     }\n \n-    fn format_arg(&self, sp: Span, argno: Position,\n-                  arg: @ast::Expr) -> @ast::Expr {\n+    fn format_arg(&self, sp: Span, argno: Position, arg: @ast::Expr)\n+                  -> @ast::Expr {\n         let ty = match argno {\n-            Exact(i) => self.arg_types[i].unwrap(),\n-            Named(s) => *self.name_types.get(&s)\n+            Exact(ref i) => self.arg_types[*i].get_ref(),\n+            Named(ref s) => self.name_types.get(s)\n         };\n \n-        let fmt_trait = match ty {\n-            Known(tyname) => {\n-                match tyname.as_slice() {\n+        let fmt_trait = match *ty {\n+            Known(ref tyname) => {\n+                match (*tyname).as_slice() {\n                     \"\"  => \"Default\",\n                     \"?\" => \"Poly\",\n                     \"b\" => \"Bool\",\n@@ -698,8 +721,9 @@ impl<'a> Context<'a> {\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n-                        self.ecx.span_err(sp, format!(\"unknown format trait \\\n-                                                       `{}`\", tyname));\n+                        self.ecx.span_err(sp,\n+                                          format!(\"unknown format trait `{}`\",\n+                                                  *tyname));\n                         \"Dummy\"\n                     }\n                 }\n@@ -757,8 +781,9 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n     // Be sure to recursively expand macros just in case the format string uses\n     // a macro to build the format expression.\n     let expr = cx.ecx.expand_expr(efmt);\n-    let fmt = match expr_to_str(cx.ecx, expr,\n-                                     \"format argument must be a string literal.\") {\n+    let fmt = match expr_to_str(cx.ecx,\n+                                expr,\n+                                \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n         None => return MacResult::dummy_expr()\n     };\n@@ -770,7 +795,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n             cx.ecx.span_err(efmt.span, m);\n         }\n     }).inside(|| {\n-        for piece in parse::Parser::new(fmt) {\n+        for piece in parse::Parser::new(fmt.get()) {\n             if !err {\n                 cx.verify_piece(&piece);\n                 let piece = cx.trans_piece(&piece);"}, {"sha": "bd1ac616f52d26fd7b42558518ea6b06e4313217", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -31,6 +31,7 @@ use parse;\n pub mod rt {\n     use ast;\n     use ext::base::ExtCtxt;\n+    use parse::token;\n     use parse;\n     use print::pprust;\n \n@@ -65,132 +66,134 @@ pub mod rt {\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        fn to_source(&self) -> @str;\n+        fn to_source(&self) -> ~str;\n     }\n \n     impl ToSource for ast::Ident {\n-        fn to_source(&self) -> @str {\n-            ident_to_str(self)\n+        fn to_source(&self) -> ~str {\n+            let this = get_ident(self.name);\n+            this.get().to_owned()\n         }\n     }\n \n     impl ToSource for @ast::Item {\n-        fn to_source(&self) -> @str {\n-            pprust::item_to_str(*self, get_ident_interner()).to_managed()\n+        fn to_source(&self) -> ~str {\n+            pprust::item_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl<'a> ToSource for &'a [@ast::Item] {\n-        fn to_source(&self) -> @str {\n-            self.map(|i| i.to_source()).connect(\"\\n\\n\").to_managed()\n+        fn to_source(&self) -> ~str {\n+            self.map(|i| i.to_source()).connect(\"\\n\\n\")\n         }\n     }\n \n     impl ToSource for ast::Ty {\n-        fn to_source(&self) -> @str {\n-            pprust::ty_to_str(self, get_ident_interner()).to_managed()\n+        fn to_source(&self) -> ~str {\n+            pprust::ty_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl<'a> ToSource for &'a [ast::Ty] {\n-        fn to_source(&self) -> @str {\n-            self.map(|i| i.to_source()).connect(\", \").to_managed()\n+        fn to_source(&self) -> ~str {\n+            self.map(|i| i.to_source()).connect(\", \")\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self) -> @str {\n-            pprust::generics_to_str(self, get_ident_interner()).to_managed()\n+        fn to_source(&self) -> ~str {\n+            pprust::generics_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for @ast::Expr {\n-        fn to_source(&self) -> @str {\n-            pprust::expr_to_str(*self, get_ident_interner()).to_managed()\n+        fn to_source(&self) -> ~str {\n+            pprust::expr_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for ast::Block {\n-        fn to_source(&self) -> @str {\n-            pprust::block_to_str(self, get_ident_interner()).to_managed()\n+        fn to_source(&self) -> ~str {\n+            pprust::block_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl<'a> ToSource for &'a str {\n-        fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::LitStr(self.to_managed(), ast::CookedStr));\n-            pprust::lit_to_str(&lit).to_managed()\n+        fn to_source(&self) -> ~str {\n+            let lit = dummy_spanned(ast::LitStr(\n+                    token::intern_and_get_ident(*self), ast::CookedStr));\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for int {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for i8 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI8));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for i16 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI16));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n \n     impl ToSource for i32 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI32));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for i64 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI64));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for uint {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u8 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU8));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u16 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU16));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u32 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU32));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u64 {\n-        fn to_source(&self) -> @str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU64));\n-            pprust::lit_to_str(&lit).to_managed()\n+            pprust::lit_to_str(&lit)\n         }\n     }\n \n@@ -237,52 +240,49 @@ pub mod rt {\n     impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: @str) -> @ast::Item;\n-        fn parse_expr(&self, s: @str) -> @ast::Expr;\n-        fn parse_stmt(&self, s: @str) -> @ast::Stmt;\n-        fn parse_tts(&self, s: @str) -> ~[ast::TokenTree];\n+        fn parse_item(&self, s: ~str) -> @ast::Item;\n+        fn parse_expr(&self, s: ~str) -> @ast::Expr;\n+        fn parse_stmt(&self, s: ~str) -> @ast::Stmt;\n+        fn parse_tts(&self, s: ~str) -> ~[ast::TokenTree];\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n-        fn parse_item(&self, s: @str) -> @ast::Item {\n+        fn parse_item(&self, s: ~str) -> @ast::Item {\n             let res = parse::parse_item_from_source_str(\n-                @\"<quote expansion>\",\n+                \"<quote expansion>\".to_str(),\n                 s,\n                 self.cfg(),\n                 self.parse_sess());\n             match res {\n                 Some(ast) => ast,\n                 None => {\n-                    error!(\"Parse error with ```\\n{}\\n```\", s);\n+                    error!(\"Parse error\");\n                     fail!()\n                 }\n             }\n         }\n \n-        fn parse_stmt(&self, s: @str) -> @ast::Stmt {\n-            parse::parse_stmt_from_source_str(\n-                @\"<quote expansion>\",\n-                s,\n-                self.cfg(),\n-                ~[],\n-                self.parse_sess())\n+        fn parse_stmt(&self, s: ~str) -> @ast::Stmt {\n+            parse::parse_stmt_from_source_str(\"<quote expansion>\".to_str(),\n+                                              s,\n+                                              self.cfg(),\n+                                              ~[],\n+                                              self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: @str) -> @ast::Expr {\n-            parse::parse_expr_from_source_str(\n-                @\"<quote expansion>\",\n-                s,\n-                self.cfg(),\n-                self.parse_sess())\n+        fn parse_expr(&self, s: ~str) -> @ast::Expr {\n+            parse::parse_expr_from_source_str(\"<quote expansion>\".to_str(),\n+                                              s,\n+                                              self.cfg(),\n+                                              self.parse_sess())\n         }\n \n-        fn parse_tts(&self, s: @str) -> ~[ast::TokenTree] {\n-            parse::parse_tts_from_source_str(\n-                @\"<quote expansion>\",\n-                s,\n-                self.cfg(),\n-                self.parse_sess())\n+        fn parse_tts(&self, s: ~str) -> ~[ast::TokenTree] {\n+            parse::parse_tts_from_source_str(\"<quote expansion>\".to_str(),\n+                                             s,\n+                                             self.cfg(),\n+                                             self.parse_sess())\n         }\n     }\n \n@@ -349,7 +349,7 @@ fn id_ext(str: &str) -> ast::Ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n-    let e_str = cx.expr_str(sp, cx.str_of(ident));\n+    let e_str = cx.expr_str(sp, token::get_ident(ident.name));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),"}, {"sha": "f3f947ec00d3d3a64c5817d3b1355427b62dd475", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -16,11 +16,13 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n-use parse::token::{get_ident_interner};\n+use parse::token::get_ident_interner;\n+use parse::token;\n use print::pprust;\n \n use std::io;\n use std::io::File;\n+use std::rc::Rc;\n use std::str;\n \n // These macros all relate to the file system; they either return\n@@ -57,21 +59,26 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    let filename = loc.file.name;\n+    let filename = token::intern_and_get_ident(loc.file.name);\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, get_ident_interner());\n-    base::MRExpr(cx.expr_str(sp, s.to_managed()))\n+    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    base::MRExpr(cx.expr_str(sp,\n-                             cx.mod_path().map(|x| cx.str_of(*x)).connect(\"::\").to_managed()))\n+    let string = cx.mod_path()\n+                   .map(|x| {\n+                        let interned_str = token::get_ident(x.name);\n+                        interned_str.get().to_str()\n+                    })\n+                   .connect(\"::\");\n+    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(string)))\n }\n \n // include! : parse the given file as an expr\n@@ -113,11 +120,11 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            let src = src.to_managed();\n-            let filename = file.display().to_str().to_managed();\n+            let filename = file.display().to_str();\n+            let interned = token::intern_and_get_ident(src);\n             cx.parse_sess.cm.new_filemap(filename, src);\n \n-            base::MRExpr(cx.expr_str(sp, src))\n+            base::MRExpr(cx.expr_str(sp, interned))\n         }\n         None => {\n             cx.span_err(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n@@ -129,8 +136,6 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         -> base::MacResult\n {\n-    use std::at_vec;\n-\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bin!\") {\n         Some(f) => f,\n         None => return MacResult::dummy_expr()\n@@ -142,8 +147,7 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             return MacResult::dummy_expr();\n         }\n         Ok(bytes) => {\n-            let bytes = at_vec::to_managed_move(bytes);\n-            base::MRExpr(cx.expr_lit(sp, ast::LitBinary(bytes)))\n+            base::MRExpr(cx.expr_lit(sp, ast::LitBinary(Rc::new(bytes))))\n         }\n     }\n }"}, {"sha": "6d1b8dd235854254086f12b6c87174ed79480a2b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -18,7 +18,7 @@ use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n-use parse::token::{Token, EOF, to_str, Nonterminal, get_ident_interner, ident_to_str};\n+use parse::token::{Token, EOF, to_str, Nonterminal, get_ident_interner};\n use parse::token;\n \n use std::hashmap::HashMap;\n@@ -183,8 +183,9 @@ pub fn nameize(p_s: @ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n                 node: MatchNonterminal(ref bind_name, _, idx), span: sp\n           } => {\n             if ret_val.contains_key(bind_name) {\n-                p_s.span_diagnostic.span_fatal(sp,\n-                                               \"Duplicated bind name: \"+ ident_to_str(bind_name))\n+                let string = token::get_ident(bind_name.name);\n+                p_s.span_diagnostic\n+                   .span_fatal(sp, \"Duplicated bind name: \" + string.get())\n             }\n             ret_val.insert(*bind_name, res[idx]);\n           }\n@@ -364,8 +365,11 @@ pub fn parse(sess: @ParseSess,\n                 let nts = bb_eis.map(|ei| {\n                     match ei.elts[ei.idx].node {\n                       MatchNonterminal(ref bind,ref name,_) => {\n-                        format!(\"{} ('{}')\", ident_to_str(name),\n-                             ident_to_str(bind))\n+                        let bind_string = token::get_ident(bind.name);\n+                        let name_string = token::get_ident(name.name);\n+                        format!(\"{} ('{}')\",\n+                                name_string.get(),\n+                                bind_string.get())\n                       }\n                       _ => fail!()\n                     } }).connect(\" or \");\n@@ -388,8 +392,9 @@ pub fn parse(sess: @ParseSess,\n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, ref name, idx) => {\n+                    let name_string = token::get_ident(name.name);\n                     ei.matches[idx].push(@MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, ident_to_str(name))));\n+                        parse_nt(&mut rust_parser, name_string.get())));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()"}, {"sha": "c179e9959e0be50bc44ad2a42c2449bfa7431ac9", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -21,8 +21,9 @@ use ext::tt::macro_parser::{parse, parse_or_else};\n use parse::lexer::{new_tt_reader, Reader};\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n-use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n+use parse::token::{get_ident_interner, special_idents, gensym_ident};\n use parse::token::{FAT_ARROW, SEMI, NtMatchers, NtTT, EOF};\n+use parse::token;\n use print;\n use std::cell::RefCell;\n use util::small_vector::SmallVector;\n@@ -112,10 +113,11 @@ fn generic_extension(cx: &ExtCtxt,\n                      rhses: &[@NamedMatch])\n                      -> MacResult {\n     if cx.trace_macros() {\n+        let interned_name = token::get_ident(name.name);\n         println!(\"{}! \\\\{ {} \\\\}\",\n-                  cx.str_of(name),\n-                  print::pprust::tt_to_str(&TTDelim(@arg.to_owned()),\n-                                           get_ident_interner()));\n+                 interned_name.get(),\n+                 print::pprust::tt_to_str(&TTDelim(@arg.to_owned()),\n+                                          get_ident_interner()));\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n@@ -229,7 +231,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n     };\n \n     return MRDef(MacroDef {\n-        name: ident_to_str(&name),\n+        name: token::get_ident(name.name).get().to_str(),\n         ext: NormalTT(exp, Some(sp))\n     });\n }"}, {"sha": "d2fa24b1cfede7b66b7065e61077b5c574c69b95", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -14,7 +14,7 @@ use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, NtIdent};\n-use parse::token::{ident_to_str};\n+use parse::token;\n use parse::lexer::TokenAndSpan;\n \n use std::cell::{Cell, RefCell};\n@@ -122,9 +122,10 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> @NamedMatch {\n     match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n+            let name_string = token::get_ident(name.name);\n             r.sp_diag.span_fatal(r.cur_span.get(),\n                                  format!(\"unknown macro variable `{}`\",\n-                                         ident_to_str(&name)));\n+                                         name_string.get()));\n         }\n     }\n }\n@@ -145,11 +146,11 @@ fn lis_merge(lhs: LockstepIterSize, rhs: LockstepIterSize) -> LockstepIterSize {\n             LisContradiction(_) => rhs.clone(),\n             LisConstraint(r_len, _) if l_len == r_len => lhs.clone(),\n             LisConstraint(r_len, ref r_id) => {\n-                let l_n = ident_to_str(l_id);\n-                let r_n = ident_to_str(r_id);\n+                let l_n = token::get_ident(l_id.name);\n+                let r_n = token::get_ident(r_id.name);\n                 LisContradiction(format!(\"Inconsistent lockstep iteration: \\\n                                           '{}' has {} items, but '{}' has {}\",\n-                                          l_n, l_len, r_n, r_len))\n+                                          l_n.get(), l_len, r_n.get(), r_len))\n             }\n         }\n     }\n@@ -313,10 +314,11 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                 return ret_val;\n               }\n               MatchedSeq(..) => {\n+                let string = token::get_ident(ident.name);\n                 r.sp_diag.span_fatal(\n                     r.cur_span.get(), /* blame the macro writer */\n                     format!(\"variable '{}' is still repeating at this depth\",\n-                         ident_to_str(&ident)));\n+                            string.get()));\n               }\n             }\n           }"}, {"sha": "8f5bbc2cdad186d38669561de4843ad3a2f4c5be", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -321,15 +321,14 @@ fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n     @Spanned {\n         node:\n             match mi.node {\n-                MetaWord(id) => MetaWord(id),\n-                MetaList(id, ref mis) => {\n+                MetaWord(ref id) => MetaWord((*id).clone()),\n+                MetaList(ref id, ref mis) => {\n                     let fold_meta_item = |x| fold_meta_item_(x, fld);\n-                    MetaList(\n-                        id,\n-                        mis.map(|e| fold_meta_item(*e))\n-                    )\n+                    MetaList((*id).clone(), mis.map(|e| fold_meta_item(*e)))\n+                }\n+                MetaNameValue(ref id, ref s) => {\n+                    MetaNameValue((*id).clone(), (*s).clone())\n                 }\n-                MetaNameValue(id, s) => MetaNameValue(id, s)\n             },\n         span: fld.new_span(mi.span) }\n }\n@@ -498,12 +497,10 @@ fn fold_variant_arg_<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n                                        -> ViewItem{\n     let inner_view_item = match vi.node {\n-        ViewItemExternMod(ref ident,\n-                             string,\n-                             node_id) => {\n+        ViewItemExternMod(ref ident, ref string, node_id) => {\n             ViewItemExternMod(ident.clone(),\n-                                 string,\n-                                 folder.new_id(node_id))\n+                              (*string).clone(),\n+                              folder.new_id(node_id))\n         }\n         ViewItemUse(ref view_paths) => {\n             ViewItemUse(folder.fold_view_paths(*view_paths))\n@@ -815,8 +812,12 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         }\n         ExprInlineAsm(ref a) => {\n             ExprInlineAsm(InlineAsm {\n-                inputs: a.inputs.map(|&(c, input)| (c, folder.fold_expr(input))),\n-                outputs: a.outputs.map(|&(c, out)| (c, folder.fold_expr(out))),\n+                inputs: a.inputs.map(|&(ref c, input)| {\n+                    ((*c).clone(), folder.fold_expr(input))\n+                }),\n+                outputs: a.outputs.map(|&(ref c, out)| {\n+                    ((*c).clone(), folder.fold_expr(out))\n+                }),\n                 .. (*a).clone()\n             })\n         }\n@@ -898,7 +899,8 @@ mod test {\n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n         let mut zz_fold = ToZzIdentFolder;\n-        let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+        let ast = string_to_crate(\n+            ~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n                      pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n@@ -909,8 +911,9 @@ mod test {\n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n         let mut zz_fold = ToZzIdentFolder;\n-        let ast = string_to_crate(@\"macro_rules! a {(b $c:expr $(d $e:token)f+\n-=> (g $(d $d $e)+))} \");\n+        let ast = string_to_crate(\n+            ~\"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n+              (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n                      pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,"}, {"sha": "c9bea78d02db5acac5e8f0fa77d8669052cf5876", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -45,7 +45,7 @@ impl ParserAttr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                    self.id_to_str(s),\n+                    self.id_to_interned_str(s),\n                     self.span.lo,\n                     self.span.hi\n                 );\n@@ -133,7 +133,7 @@ impl ParserAttr for Parser {\n                 }\n                 token::DOC_COMMENT(s) => {\n                     self.bump();\n-                    ::attr::mk_sugared_doc_attr(self.id_to_str(s),\n+                    ::attr::mk_sugared_doc_attr(self.id_to_interned_str(s),\n                                                 self.span.lo,\n                                                 self.span.hi)\n                 }\n@@ -157,7 +157,7 @@ impl ParserAttr for Parser {\n     fn parse_meta_item(&mut self) -> @ast::MetaItem {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n-        let name = self.id_to_str(ident);\n+        let name = self.id_to_interned_str(ident);\n         match self.token {\n             token::EQ => {\n                 self.bump();"}, {"sha": "7165e7b404f1c8f0db8fbc34b5f5fa57d6779250", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -54,7 +54,6 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n }\n \n pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n-\n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n         let mut i = 0u;\n@@ -348,10 +347,10 @@ pub struct Literal {\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n                                         @diagnostic::SpanHandler,\n-                                    path: @str,\n+                                    path: ~str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[Comment], ~[Literal]) {\n-    let src = str::from_utf8_owned(srdr.read_to_end()).unwrap().to_managed();\n+    let src = str::from_utf8_owned(srdr.read_to_end()).unwrap();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "8c55990289aa8067eb7f1a47328629eb85caaa40", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -42,7 +42,6 @@ pub struct TokenAndSpan {\n \n pub struct StringReader {\n     span_diagnostic: @SpanHandler,\n-    src: @str,\n     // The absolute offset within the codemap of the next character to read\n     pos: Cell<BytePos>,\n     // The absolute offset within the codemap of the last character read(curr)\n@@ -73,7 +72,6 @@ pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n     let initial_char = '\\n';\n     let r = @StringReader {\n         span_diagnostic: span_diagnostic,\n-        src: filemap.src,\n         pos: Cell::new(filemap.start_pos),\n         last_pos: Cell::new(filemap.start_pos),\n         col: Cell::new(CharPos(0)),\n@@ -93,7 +91,6 @@ pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n fn dup_string_reader(r: @StringReader) -> @StringReader {\n     @StringReader {\n         span_diagnostic: r.span_diagnostic,\n-        src: r.src,\n         pos: Cell::new(r.pos.get()),\n         last_pos: Cell::new(r.last_pos.get()),\n         col: Cell::new(r.col.get()),\n@@ -188,7 +185,7 @@ fn fatal_span_verbose(rdr: @StringReader,\n                    -> ! {\n     let mut m = m;\n     m.push_str(\": \");\n-    let s = rdr.src.slice(\n+    let s = rdr.filemap.src.slice(\n                   byte_offset(rdr, from_pos).to_uint(),\n                   byte_offset(rdr, to_pos).to_uint());\n     m.push_str(s);\n@@ -239,7 +236,7 @@ fn with_str_from_to<T>(\n                     end: BytePos,\n                     f: |s: &str| -> T)\n                     -> T {\n-    f(rdr.src.slice(\n+    f(rdr.filemap.src.slice(\n             byte_offset(rdr, start).to_uint(),\n             byte_offset(rdr, end).to_uint()))\n }\n@@ -249,12 +246,12 @@ fn with_str_from_to<T>(\n pub fn bump(rdr: &StringReader) {\n     rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if current_byte_offset < (rdr.src).len() {\n+    if current_byte_offset < (rdr.filemap.src).len() {\n         assert!(rdr.curr.get() != unsafe {\n             transmute(-1u32)\n         }); // FIXME: #8971: unsound\n         let last_char = rdr.curr.get();\n-        let next = rdr.src.char_range_at(current_byte_offset);\n+        let next = rdr.filemap.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n         rdr.curr.set(next.ch);\n@@ -277,8 +274,8 @@ pub fn is_eof(rdr: @StringReader) -> bool {\n }\n pub fn nextch(rdr: @StringReader) -> char {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if offset < (rdr.src).len() {\n-        return rdr.src.char_at(offset);\n+    if offset < (rdr.filemap.src).len() {\n+        return rdr.filemap.src.char_at(offset);\n     } else { return unsafe { transmute(-1u32) }; } // FIXME: #8971: unsound\n }\n \n@@ -975,9 +972,9 @@ mod test {\n     }\n \n     // open a string reader for the given string\n-    fn setup(teststr: @str) -> Env {\n+    fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(@\"zebra.rs\", teststr);\n+        let fm = cm.new_filemap(~\"zebra.rs\", teststr);\n         let span_handler =\n             diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n         Env {\n@@ -987,7 +984,7 @@ mod test {\n \n     #[test] fn t1 () {\n         let Env {string_reader} =\n-            setup(@\"/* my source file */ \\\n+            setup(~\"/* my source file */ \\\n                     fn main() { println!(\\\"zebra\\\"); }\\n\");\n         let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n@@ -1023,67 +1020,67 @@ mod test {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        let env = setup (@\"a b\");\n+        let env = setup (~\"a b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",false),\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n-        let env = setup (@\"a::b\");\n+        let env = setup (~\"a::b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n-        let env = setup (@\"a ::b\");\n+        let env = setup (~\"a ::b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",false),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n-        let env = setup (@\"a:: b\");\n+        let env = setup (~\"a:: b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn character_a() {\n-        let env = setup(@\"'a'\");\n+        let env = setup(~\"'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok,token::LIT_CHAR('a' as u32));\n     }\n \n     #[test] fn character_space() {\n-        let env = setup(@\"' '\");\n+        let env = setup(~\"' '\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok, token::LIT_CHAR(' ' as u32));\n     }\n \n     #[test] fn character_escaped() {\n-        let env = setup(@\"'\\\\n'\");\n+        let env = setup(~\"'\\\\n'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok, token::LIT_CHAR('\\n' as u32));\n     }\n \n     #[test] fn lifetime_name() {\n-        let env = setup(@\"'abc\");\n+        let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         let id = token::str_to_ident(\"abc\");\n         assert_eq!(tok, token::LIFETIME(id));\n     }\n \n     #[test] fn raw_string() {\n-        let env = setup(@\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\");\n+        let env = setup(~\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         let id = token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\");\n@@ -1097,7 +1094,7 @@ mod test {\n     }\n \n     #[test] fn nested_block_comments() {\n-        let env = setup(@\"/* /* */ */'a'\");\n+        let env = setup(~\"/* /* */ */'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok,token::LIT_CHAR('a' as u32));"}, {"sha": "cec9f7c2d9f11333c4f3f5f1421d10dda688bcef", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 55, "deletions": 65, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -89,25 +89,23 @@ pub fn parse_crate_attrs_from_file(\n     return inner;\n }\n \n-pub fn parse_crate_from_source_str(\n-    name: @str,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @ParseSess\n-) -> ast::Crate {\n+pub fn parse_crate_from_source_str(name: ~str,\n+                                   source: ~str,\n+                                   cfg: ast::CrateConfig,\n+                                   sess: @ParseSess)\n+                                   -> ast::Crate {\n     let mut p = new_parser_from_source_str(sess,\n                                            /*bad*/ cfg.clone(),\n                                            name,\n                                            source);\n     maybe_aborted(p.parse_crate_mod(),p)\n }\n \n-pub fn parse_crate_attrs_from_source_str(\n-    name: @str,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @ParseSess\n-) -> ~[ast::Attribute] {\n+pub fn parse_crate_attrs_from_source_str(name: ~str,\n+                                         source: ~str,\n+                                         cfg: ast::CrateConfig,\n+                                         sess: @ParseSess)\n+                                         -> ~[ast::Attribute] {\n     let mut p = new_parser_from_source_str(sess,\n                                            /*bad*/ cfg.clone(),\n                                            name,\n@@ -116,44 +114,40 @@ pub fn parse_crate_attrs_from_source_str(\n     return inner;\n }\n \n-pub fn parse_expr_from_source_str(\n-    name: @str,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @ParseSess\n-) -> @ast::Expr {\n+pub fn parse_expr_from_source_str(name: ~str,\n+                                  source: ~str,\n+                                  cfg: ast::CrateConfig,\n+                                  sess: @ParseSess)\n+                                  -> @ast::Expr {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n \n-pub fn parse_item_from_source_str(\n-    name: @str,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @ParseSess\n-) -> Option<@ast::Item> {\n+pub fn parse_item_from_source_str(name: ~str,\n+                                  source: ~str,\n+                                  cfg: ast::CrateConfig,\n+                                  sess: @ParseSess)\n+                                  -> Option<@ast::Item> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     let attrs = p.parse_outer_attributes();\n     maybe_aborted(p.parse_item(attrs),p)\n }\n \n-pub fn parse_meta_from_source_str(\n-    name: @str,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @ParseSess\n-) -> @ast::MetaItem {\n+pub fn parse_meta_from_source_str(name: ~str,\n+                                  source: ~str,\n+                                  cfg: ast::CrateConfig,\n+                                  sess: @ParseSess)\n+                                  -> @ast::MetaItem {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n \n-pub fn parse_stmt_from_source_str(\n-    name: @str,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    attrs: ~[ast::Attribute],\n-    sess: @ParseSess\n-) -> @ast::Stmt {\n+pub fn parse_stmt_from_source_str(name: ~str,\n+                                  source: ~str,\n+                                  cfg: ast::CrateConfig,\n+                                  attrs: ~[ast::Attribute],\n+                                  sess: @ParseSess)\n+                                  -> @ast::Stmt {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -163,12 +157,11 @@ pub fn parse_stmt_from_source_str(\n     maybe_aborted(p.parse_stmt(attrs),p)\n }\n \n-pub fn parse_tts_from_source_str(\n-    name: @str,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @ParseSess\n-) -> ~[ast::TokenTree] {\n+pub fn parse_tts_from_source_str(name: ~str,\n+                                 source: ~str,\n+                                 cfg: ast::CrateConfig,\n+                                 sess: @ParseSess)\n+                                 -> ~[ast::TokenTree] {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -183,9 +176,9 @@ pub fn parse_tts_from_source_str(\n // Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: @ParseSess,\n                                   cfg: ast::CrateConfig,\n-                                  name: @str,\n-                                  source: @str)\n-                               -> Parser {\n+                                  name: ~str,\n+                                  source: ~str)\n+                                  -> Parser {\n     filemap_to_parser(sess,string_to_filemap(sess,source,name),cfg)\n }\n \n@@ -248,20 +241,17 @@ pub fn file_to_filemap(sess: @ParseSess, path: &Path, spanopt: Option<Span>)\n     };\n     match str::from_utf8_owned(bytes) {\n         Some(s) => {\n-            return string_to_filemap(sess, s.to_managed(),\n-                                     path.as_str().unwrap().to_managed());\n-        }\n-        None => {\n-            err(format!(\"{} is not UTF-8 encoded\", path.display()))\n+            return string_to_filemap(sess, s, path.as_str().unwrap().to_str())\n         }\n+        None => err(format!(\"{} is not UTF-8 encoded\", path.display())),\n     }\n     unreachable!()\n }\n \n // given a session and a string, add the string to\n // the session's codemap and return the new filemap\n-pub fn string_to_filemap(sess: @ParseSess, source: @str, path: @str)\n-    -> @FileMap {\n+pub fn string_to_filemap(sess: @ParseSess, source: ~str, path: ~str)\n+                         -> @FileMap {\n     sess.cm.new_filemap(path, source)\n }\n \n@@ -324,7 +314,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_1() {\n-        assert_eq!(string_to_expr(@\"a\"),\n+        assert_eq!(string_to_expr(~\"a\"),\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -343,7 +333,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_2 () {\n-        assert_eq!(string_to_expr(@\"::a::b\"),\n+        assert_eq!(string_to_expr(~\"::a::b\"),\n                    @ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -368,12 +358,12 @@ mod test {\n \n     #[should_fail]\n     #[test] fn bad_path_expr_1() {\n-        string_to_expr(@\"::abc::def::return\");\n+        string_to_expr(~\"::abc::def::return\");\n     }\n \n     // check the token-tree-ization of macros\n     #[test] fn string_to_tts_macro () {\n-        let tts = string_to_tts(@\"macro_rules! zip (($a)=>($a))\");\n+        let tts = string_to_tts(~\"macro_rules! zip (($a)=>($a))\");\n         match tts {\n             [ast::TTTok(_,_),\n              ast::TTTok(_,token::NOT),\n@@ -417,7 +407,7 @@ mod test {\n     }\n \n     #[test] fn string_to_tts_1 () {\n-        let tts = string_to_tts(@\"fn a (b : int) { b; }\");\n+        let tts = string_to_tts(~\"fn a (b : int) { b; }\");\n         assert_eq!(to_json_str(&tts),\n         ~\"[\\\n     {\\\n@@ -546,7 +536,7 @@ mod test {\n     }\n \n     #[test] fn ret_expr() {\n-        assert_eq!(string_to_expr(@\"return d\"),\n+        assert_eq!(string_to_expr(~\"return d\"),\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(@ast::Expr{\n@@ -569,7 +559,7 @@ mod test {\n     }\n \n     #[test] fn parse_stmt_1 () {\n-        assert_eq!(string_to_stmt(@\"b;\"),\n+        assert_eq!(string_to_stmt(~\"b;\"),\n                    @Spanned{\n                        node: ast::StmtExpr(@ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n@@ -595,7 +585,7 @@ mod test {\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let mut parser = string_to_parser(@\"b\");\n+        let mut parser = string_to_parser(~\"b\");\n         assert_eq!(parser.parse_pat(),\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n@@ -619,7 +609,7 @@ mod test {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\"\n-        assert_eq!(string_to_item(@\"fn a (b : int) { b; }\"),\n+        assert_eq!(string_to_item(~\"fn a (b : int) { b; }\"),\n                   Some(\n                       @ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n@@ -711,12 +701,12 @@ mod test {\n \n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n-        string_to_expr(@\"3 + 4\");\n-        string_to_expr(@\"a::z.froob(b,@(987+3))\");\n+        string_to_expr(~\"3 + 4\");\n+        string_to_expr(~\"a::z.froob(b,@(987+3))\");\n     }\n \n     #[test] fn attrs_fix_bug () {\n-        string_to_item(@\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+        string_to_item(~\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<@Writer, ~str> {\n     #[cfg(windows)]\n     fn wb() -> c_int {"}, {"sha": "b85d89cf804a82553ca69491018631c2dd40bc2c", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -22,7 +22,6 @@ use codemap::{Span, respan};\n use parse::parser::Parser;\n use parse::token;\n \n-use std::str;\n use std::to_bytes;\n \n /// The specific types of unsupported syntax\n@@ -45,6 +44,8 @@ pub enum ObsoleteSyntax {\n     ObsoleteMultipleImport,\n     ObsoleteExternModAttributesInParens,\n     ObsoleteManagedPattern,\n+    ObsoleteManagedString,\n+    ObsoleteManagedVec,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -150,6 +151,14 @@ impl ParserObsoleteMethods for Parser {\n                 \"use a nested `match` expression instead of a managed box \\\n                  pattern\"\n             ),\n+            ObsoleteManagedString => (\n+                \"managed string\",\n+                \"use `Rc<~str>` instead of a managed string\"\n+            ),\n+            ObsoleteManagedVec => (\n+                \"managed vector\",\n+                \"use `Rc<~[T]>` instead of a managed vector\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);\n@@ -178,7 +187,8 @@ impl ParserObsoleteMethods for Parser {\n     fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n         match self.token {\n             token::IDENT(sid, _) => {\n-                str::eq_slice(self.id_to_str(sid), ident)\n+                let interned_string = token::get_ident(sid.name);\n+                interned_string.equiv(&ident)\n             }\n             _ => false\n         }"}, {"sha": "dd7cc3a2314359aa8006c6e94fa2fa763c449133", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -29,7 +29,7 @@ use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLogLevel, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n-use ast::{ExprVec, ExprVstore, ExprVstoreSlice, ExprVstoreBox};\n+use ast::{ExprVec, ExprVstore, ExprVstoreSlice};\n use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, ExternFn, Field, FnDecl};\n use ast::{ExprVstoreUniq, Onceness, Once, Many};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n@@ -71,10 +71,9 @@ use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n use parse::lexer::Reader;\n use parse::lexer::TokenAndSpan;\n use parse::obsolete::*;\n-use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident};\n-use parse::token::{is_ident_or_path};\n-use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents};\n-use parse::token::{token_to_binop};\n+use parse::token::{INTERPOLATED, InternedString, can_begin_expr, get_ident};\n+use parse::token::{get_ident_interner, is_ident, is_ident_or_path};\n+use parse::token::{is_plain_ident, keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n@@ -345,7 +344,7 @@ pub struct Parser {\n     /// extra detail when the same error is seen twice\n     obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    mod_path_stack: ~[@str],\n+    mod_path_stack: ~[InternedString],\n     /// Stack of spans of open delimiters. Used for error message.\n     open_braces: ~[Span],\n     /* do not copy the parser; its state is tied to outside state */\n@@ -531,10 +530,11 @@ impl Parser {\n     // otherwise, eat it.\n     pub fn expect_keyword(&mut self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n-            let id_str = self.id_to_str(kw.to_ident()).to_str();\n+            let id_ident = kw.to_ident();\n+            let id_interned_str = token::get_ident(id_ident.name);\n             let token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               id_str,\n+                               id_interned_str.get(),\n                                token_str))\n         }\n     }\n@@ -802,8 +802,8 @@ impl Parser {\n         self.sess.span_diagnostic.handler().abort_if_errors();\n     }\n \n-    pub fn id_to_str(&mut self, id: Ident) -> @str {\n-        get_ident_interner().get(id.name)\n+    pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n+        get_ident(id.name)\n     }\n \n     // Is the current token one of the keywords that signals a bare function\n@@ -1291,7 +1291,7 @@ impl Parser {\n         }\n \n         // other things are parsed as @/~ + a type.  Note that constructs like\n-        // @[] and @str will be resolved during typeck to slices and so forth,\n+        // ~[] and ~str will be resolved during typeck to slices and so forth,\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n         // reflected in the AST type.\n         if sigil == OwnedSigil {\n@@ -1401,11 +1401,18 @@ impl Parser {\n             token::LIT_INT(i, it) => LitInt(i, it),\n             token::LIT_UINT(u, ut) => LitUint(u, ut),\n             token::LIT_INT_UNSUFFIXED(i) => LitIntUnsuffixed(i),\n-            token::LIT_FLOAT(s, ft) => LitFloat(self.id_to_str(s), ft),\n-            token::LIT_FLOAT_UNSUFFIXED(s) =>\n-                LitFloatUnsuffixed(self.id_to_str(s)),\n-            token::LIT_STR(s) => LitStr(self.id_to_str(s), ast::CookedStr),\n-            token::LIT_STR_RAW(s, n) => LitStr(self.id_to_str(s), ast::RawStr(n)),\n+            token::LIT_FLOAT(s, ft) => {\n+                LitFloat(self.id_to_interned_str(s), ft)\n+            }\n+            token::LIT_FLOAT_UNSUFFIXED(s) => {\n+                LitFloatUnsuffixed(self.id_to_interned_str(s))\n+            }\n+            token::LIT_STR(s) => {\n+                LitStr(self.id_to_interned_str(s), ast::CookedStr)\n+            }\n+            token::LIT_STR_RAW(s, n) => {\n+                LitStr(self.id_to_interned_str(s), ast::RawStr(n))\n+            }\n             token::LPAREN => { self.expect(&token::RPAREN); LitNil },\n             _ => { self.unexpected_last(tok); }\n         }\n@@ -2284,11 +2291,19 @@ impl Parser {\n             self.bump();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn @[...] into a @-vec\n+            // HACK: pretending @[] is a (removed) @-vec\n             ex = match e.node {\n               ExprVec(..) |\n-              ExprRepeat(..) => ExprVstore(e, ExprVstoreBox),\n-              ExprLit(lit) if lit_is_str(lit) => ExprVstore(e, ExprVstoreBox),\n+              ExprRepeat(..) => {\n+                  self.obsolete(e.span, ObsoleteManagedVec);\n+                  // the above error means that no-one will know we're\n+                  // lying... hopefully.\n+                  ExprVstore(e, ExprVstoreUniq)\n+              }\n+              ExprLit(lit) if lit_is_str(lit) => {\n+                  self.obsolete(self.last_span, ObsoleteManagedString);\n+                  ExprVstore(e, ExprVstoreUniq)\n+              }\n               _ => self.mk_unary(UnBox, e)\n             };\n           }\n@@ -2806,34 +2821,11 @@ impl Parser {\n           token::AT => {\n             self.bump();\n             let sub = self.parse_pat();\n-            hi = sub.span.hi;\n-            // HACK: parse @\"...\" as a literal of a vstore @str\n-            pat = match sub.node {\n-              PatLit(e) => {\n-                  match e.node {\n-                      ExprLit(lit) if lit_is_str(lit) => {\n-                        let vst = @Expr {\n-                            id: ast::DUMMY_NODE_ID,\n-                            node: ExprVstore(e, ExprVstoreBox),\n-                            span: mk_sp(lo, hi),\n-                        };\n-                        PatLit(vst)\n-                      }\n-                      _ => {\n-                        self.obsolete(self.span, ObsoleteManagedPattern);\n-                        PatUniq(sub)\n-                      }\n-                  }\n-              }\n-              _ => {\n-                self.obsolete(self.span, ObsoleteManagedPattern);\n-                PatUniq(sub)\n-              }\n-            };\n-            hi = self.last_span.hi;\n+            self.obsolete(self.span, ObsoleteManagedPattern);\n+            let hi = self.last_span.hi;\n             return @ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n-                node: pat,\n+                node: PatUniq(sub),\n                 span: mk_sp(lo, hi)\n             }\n           }\n@@ -3429,7 +3421,9 @@ impl Parser {\n         loop {\n             match self.token {\n                 token::LIFETIME(lifetime) => {\n-                    if \"static\" == self.id_to_str(lifetime) {\n+                    let lifetime_interned_string =\n+                        token::get_ident(lifetime.name);\n+                    if lifetime_interned_string.equiv(&(\"static\")) {\n                         result.push(RegionTyParamBound);\n                     } else {\n                         self.span_err(self.span,\n@@ -3970,8 +3964,9 @@ impl Parser {\n                 fields.push(self.parse_struct_decl_field());\n             }\n             if fields.len() == 0 {\n+                let string = get_ident_interner().get(class_name.name);\n                 self.fatal(format!(\"Unit-like struct definition should be written as `struct {};`\",\n-                                get_ident_interner().get(class_name.name)));\n+                                   string.as_slice()));\n             }\n             self.bump();\n         } else if self.token == token::LPAREN {\n@@ -4142,11 +4137,11 @@ impl Parser {\n     }\n \n     fn push_mod_path(&mut self, id: Ident, attrs: &[Attribute]) {\n-        let default_path = token::interner_get(id.name);\n+        let default_path = self.id_to_interned_str(id);\n         let file_path = match ::attr::first_attr_value_str_by_name(attrs,\n                                                                    \"path\") {\n             Some(d) => d,\n-            None => default_path\n+            None => default_path,\n         };\n         self.mod_path_stack.push(file_path)\n     }\n@@ -4169,7 +4164,8 @@ impl Parser {\n                 outer_attrs, \"path\") {\n             Some(d) => dir_path.join(d),\n             None => {\n-                let mod_name = token::interner_get(id.name).to_owned();\n+                let mod_string = token::get_ident(id.name);\n+                let mod_name = mod_string.get().to_owned();\n                 let default_path_str = mod_name + \".rs\";\n                 let secondary_path_str = mod_name + \"/mod.rs\";\n                 let default_path = dir_path.join(default_path_str.as_slice());\n@@ -4524,7 +4520,8 @@ impl Parser {\n             token::LIT_STR(s)\n             | token::LIT_STR_RAW(s, _) => {\n                 self.bump();\n-                let the_string = ident_to_str(&s);\n+                let identifier_string = token::get_ident(s.name);\n+                let the_string = identifier_string.get();\n                 let mut abis = AbiSet::empty();\n                 for word in the_string.words() {\n                     match abi::lookup(word) {\n@@ -4860,7 +4857,6 @@ impl Parser {\n \n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        debug!(\"parsed view path: {}\", self.id_to_str(first_ident));\n         match self.token {\n           token::EQ => {\n             // x = foo::bar\n@@ -5119,17 +5115,20 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_optional_str(&mut self) -> Option<(@str, ast::StrStyle)> {\n+    pub fn parse_optional_str(&mut self)\n+                              -> Option<(InternedString, ast::StrStyle)> {\n         let (s, style) = match self.token {\n-            token::LIT_STR(s) => (s, ast::CookedStr),\n-            token::LIT_STR_RAW(s, n) => (s, ast::RawStr(n)),\n+            token::LIT_STR(s) => (self.id_to_interned_str(s), ast::CookedStr),\n+            token::LIT_STR_RAW(s, n) => {\n+                (self.id_to_interned_str(s), ast::RawStr(n))\n+            }\n             _ => return None\n         };\n         self.bump();\n-        Some((ident_to_str(&s), style))\n+        Some((s, style))\n     }\n \n-    pub fn parse_str(&mut self) -> (@str, StrStyle) {\n+    pub fn parse_str(&mut self) -> (InternedString, StrStyle) {\n         match self.parse_optional_str() {\n             Some(s) => { s }\n             _ =>  self.fatal(\"expected string literal\")"}, {"sha": "d6edccd33a4983aef911737d7485bee2184305b0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 111, "deletions": 59, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -12,12 +12,15 @@ use ast;\n use ast::{P, Name, Mrk};\n use ast_util;\n use parse::token;\n-use util::interner::StrInterner;\n+use util::interner::{RcStr, StrInterner};\n use util::interner;\n \n+use extra::serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::cast;\n use std::char;\n+use std::fmt;\n use std::local_data;\n+use std::path::BytesContainer;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n@@ -185,32 +188,44 @@ pub fn to_str(input: @IdentInterner, t: &Token) -> ~str {\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n       LIT_FLOAT(ref s, t) => {\n-        let mut body = ident_to_str(s).to_owned();\n+        let body_string = get_ident(s.name);\n+        let mut body = body_string.get().to_str();\n         if body.ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n       LIT_FLOAT_UNSUFFIXED(ref s) => {\n-        let mut body = ident_to_str(s).to_owned();\n+        let body_string = get_ident(s.name);\n+        let mut body = body_string.get().to_owned();\n         if body.ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n         body\n       }\n-      LIT_STR(ref s) => { format!(\"\\\"{}\\\"\", ident_to_str(s).escape_default()) }\n+      LIT_STR(ref s) => {\n+          let literal_string = get_ident(s.name);\n+          format!(\"\\\"{}\\\"\", literal_string.get().escape_default())\n+      }\n       LIT_STR_RAW(ref s, n) => {\n+          let literal_string = get_ident(s.name);\n           format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                  delim=\"#\".repeat(n), string=ident_to_str(s))\n+                  delim=\"#\".repeat(n), string=literal_string.get())\n       }\n \n       /* Name components */\n-      IDENT(s, _) => input.get(s.name).to_owned(),\n-      LIFETIME(s) => format!(\"'{}\", input.get(s.name)),\n+      IDENT(s, _) => input.get(s.name).into_owned(),\n+      LIFETIME(s) => {\n+          let name = input.get(s.name);\n+          format!(\"'{}\", name.as_slice())\n+      }\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(ref s) => ident_to_str(s).to_owned(),\n+      DOC_COMMENT(ref s) => {\n+          let comment_string = get_ident(s.name);\n+          comment_string.get().to_str()\n+      }\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n@@ -525,13 +540,101 @@ pub fn get_ident_interner() -> @IdentInterner {\n     }\n }\n \n+/// Represents a string stored in the task-local interner. Because the\n+/// interner lives for the life of the task, this can be safely treated as an\n+/// immortal string, as long as it never crosses between tasks.\n+///\n+/// FIXME(pcwalton): You must be careful about what you do in the destructors\n+/// of objects stored in TLS, because they may run after the interner is\n+/// destroyed. In particular, they must not access string contents. This can\n+/// be fixed in the future by just leaking all strings until task death\n+/// somehow.\n+#[deriving(Clone, Eq, IterBytes, Ord, TotalEq, TotalOrd)]\n+pub struct InternedString {\n+    priv string: RcStr,\n+}\n+\n+impl InternedString {\n+    #[inline]\n+    pub fn new(string: &'static str) -> InternedString {\n+        InternedString {\n+            string: RcStr::new(string),\n+        }\n+    }\n+\n+    #[inline]\n+    fn new_from_rc_str(string: RcStr) -> InternedString {\n+        InternedString {\n+            string: string,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get<'a>(&'a self) -> &'a str {\n+        self.string.as_slice()\n+    }\n+}\n+\n+impl BytesContainer for InternedString {\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        // FIXME(pcwalton): This is a workaround for the incorrect signature\n+        // of `BytesContainer`, which is itself a workaround for the lack of\n+        // DST.\n+        unsafe {\n+            let this = self.get();\n+            cast::transmute(this.container_as_bytes())\n+        }\n+    }\n+}\n+\n+impl fmt::Default for InternedString {\n+    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) {\n+        write!(f.buf, \"{}\", obj.string.as_slice());\n+    }\n+}\n+\n+impl<'a> Equiv<&'a str> for InternedString {\n+    fn equiv(&self, other: & &'a str) -> bool {\n+        (*other) == self.string.as_slice()\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for InternedString {\n+    fn decode(d: &mut D) -> InternedString {\n+        let interner = get_ident_interner();\n+        get_ident(interner.intern(d.read_str()))\n+    }\n+}\n+\n+impl<E:Encoder> Encodable<E> for InternedString {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_str(self.string.as_slice())\n+    }\n+}\n+\n+/// Returns the string contents of an identifier, using the task-local\n+/// interner.\n+#[inline]\n+pub fn get_ident(idx: Name) -> InternedString {\n+    let interner = get_ident_interner();\n+    InternedString::new_from_rc_str(interner.get(idx))\n+}\n+\n+/// Interns and returns the string contents of an identifier, using the\n+/// task-local interner.\n+#[inline]\n+pub fn intern_and_get_ident(s: &str) -> InternedString {\n+    get_ident(intern(s))\n+}\n+\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n pub fn mk_fake_ident_interner() -> @IdentInterner {\n     @interner::StrInterner::new()\n }\n \n // maps a string to its interned representation\n+#[inline]\n pub fn intern(str : &str) -> Name {\n     let interner = get_ident_interner();\n     interner.intern(str)\n@@ -543,16 +646,6 @@ pub fn gensym(str : &str) -> Name {\n     interner.gensym(str)\n }\n \n-// map an interned representation back to a string\n-pub fn interner_get(name : Name) -> @str {\n-    get_ident_interner().get(name)\n-}\n-\n-// maps an identifier to the string that it corresponds to\n-pub fn ident_to_str(id : &ast::Ident) -> @str {\n-    interner_get(id.name)\n-}\n-\n // maps a string to an identifier with an empty syntax context\n pub fn str_to_ident(str : &str) -> ast::Ident {\n     ast::Ident::new(intern(str))\n@@ -576,28 +669,6 @@ pub fn fresh_name(src : &ast::Ident) -> Name {\n     gensym(format!(\"{}_{}\",ident_to_str(src),num))*/\n }\n \n-// it looks like there oughta be a str_ptr_eq fn, but no one bothered to implement it?\n-\n-// determine whether two @str values are pointer-equal\n-pub fn str_ptr_eq(a : @str, b : @str) -> bool {\n-    unsafe {\n-        let p : uint = cast::transmute(a);\n-        let q : uint = cast::transmute(b);\n-        let result = p == q;\n-        // got to transmute them back, to make sure the ref count is correct:\n-        let _junk1 : @str = cast::transmute(p);\n-        let _junk2 : @str = cast::transmute(q);\n-        result\n-    }\n-}\n-\n-// return true when two identifiers refer (through the intern table) to the same ptr_eq\n-// string. This is used to compare identifiers in places where hygienic comparison is\n-// not wanted (i.e. not lexical vars).\n-pub fn ident_spelling_eq(a : &ast::Ident, b : &ast::Ident) -> bool {\n-    str_ptr_eq(interner_get(a.name),interner_get(b.name))\n-}\n-\n // create a fresh mark.\n pub fn fresh_mark() -> Mrk {\n     gensym(\"mark\")\n@@ -669,23 +740,4 @@ mod test {\n         let a1 = mark_ident(a,92);\n         assert!(mtwt_token_eq(&IDENT(a,true),&IDENT(a1,false)));\n     }\n-\n-\n-    #[test] fn str_ptr_eq_tests(){\n-        let a = @\"abc\";\n-        let b = @\"abc\";\n-        let c = a;\n-        assert!(str_ptr_eq(a,c));\n-        assert!(!str_ptr_eq(a,b));\n-    }\n-\n-    #[test] fn fresh_name_pointer_sharing() {\n-        let ghi = str_to_ident(\"ghi\");\n-        assert_eq!(ident_to_str(&ghi),@\"ghi\");\n-        assert!(str_ptr_eq(ident_to_str(&ghi),ident_to_str(&ghi)))\n-        let fresh = ast::Ident::new(fresh_name(&ghi));\n-        assert_eq!(ident_to_str(&fresh),@\"ghi\");\n-        assert!(str_ptr_eq(ident_to_str(&ghi),ident_to_str(&fresh)));\n-    }\n-\n }"}, {"sha": "3e1f5b4cfb353ec89f66329341f1ce1d6d850edf", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -84,7 +84,7 @@ pub struct BeginToken {\n \n #[deriving(Clone)]\n pub enum Token {\n-    String(@str, int),\n+    String(~str, int),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -131,7 +131,7 @@ pub fn buf_str(toks: ~[Token], szs: ~[int], left: uint, right: uint,\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(format!(\"{}={}\", szs[i], tok_str(toks[i])));\n+        s.push_str(format!(\"{}={}\", szs[i], tok_str(toks[i].clone())));\n         i += 1u;\n         i %= n;\n     }\n@@ -285,7 +285,9 @@ pub struct Printer {\n }\n \n impl Printer {\n-    pub fn last_token(&mut self) -> Token { self.token[self.right] }\n+    pub fn last_token(&mut self) -> Token {\n+        self.token[self.right].clone()\n+    }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n@@ -296,8 +298,8 @@ impl Printer {\n           Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                self.advance_left(self.token[self.left],\n-                                  self.size[self.left]);\n+                let left = self.token[self.left].clone();\n+                self.advance_left(left, self.size[self.left]);\n             }\n             self.indent(0);\n           }\n@@ -341,16 +343,16 @@ impl Printer {\n             self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n           }\n-          String(s, len) => {\n+          String(ref s, len) => {\n             if self.scan_stack_empty {\n                 debug!(\"pp String('{}')/print ~[{},{}]\",\n-                       s, self.left, self.right);\n-                self.print(t, len);\n+                       *s, self.left, self.right);\n+                self.print(t.clone(), len);\n             } else {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n-                       s, self.left, self.right);\n+                       *s, self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t;\n+                self.token[self.right] = t.clone();\n                 self.size[self.right] = len;\n                 self.right_total += len;\n                 self.check_stream();\n@@ -370,7 +372,8 @@ impl Printer {\n                     self.size[self.scan_pop_bottom()] = SIZE_INFINITY;\n                 }\n             }\n-            self.advance_left(self.token[self.left], self.size[self.left]);\n+            let left = self.token[self.left].clone();\n+            self.advance_left(left, self.size[self.left]);\n             if self.left != self.right { self.check_stream(); }\n         }\n     }\n@@ -414,7 +417,7 @@ impl Printer {\n         debug!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n-            self.print(x, L);\n+            self.print(x.clone(), L);\n             match x {\n               Break(b) => self.left_total += b.blank_space,\n               String(_, len) => {\n@@ -425,8 +428,8 @@ impl Printer {\n             if self.left != self.right {\n                 self.left += 1u;\n                 self.left %= self.buf_len;\n-                self.advance_left(self.token[self.left],\n-                                  self.size[self.left]);\n+                let left = self.token[self.left].clone();\n+                self.advance_left(left, self.size[self.left]);\n             }\n         }\n     }\n@@ -483,7 +486,7 @@ impl Printer {\n         write!(self.out, \"{}\", s);\n     }\n     pub fn print(&mut self, x: Token, L: int) {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(x), L,\n+        debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), L,\n                self.space);\n         debug!(\"{}\", buf_str(self.token.clone(),\n                              self.size.clone(),\n@@ -583,15 +586,15 @@ pub fn end(p: &mut Printer) { p.pretty_print(End); }\n pub fn eof(p: &mut Printer) { p.pretty_print(Eof); }\n \n pub fn word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_managed(), wrd.len() as int));\n+    p.pretty_print(String(/* bad */ wrd.to_str(), wrd.len() as int));\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_managed(), SIZE_INFINITY));\n+    p.pretty_print(String(/* bad */ wrd.to_str(), SIZE_INFINITY));\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_managed(), 0));\n+    p.pretty_print(String(/* bad */ wrd.to_str(), 0));\n }\n \n pub fn spaces(p: &mut Printer, n: uint) { break_offset(p, n, 0); }"}, {"sha": "037c69eb918d1c895592bb3260be787e13d14cef", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 38, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -19,7 +19,7 @@ use codemap::{CodeMap, BytePos};\n use codemap;\n use diagnostic;\n use parse::classify::expr_is_simple_block;\n-use parse::token::{IdentInterner, ident_to_str, interner_get};\n+use parse::token::IdentInterner;\n use parse::{comments, token};\n use parse;\n use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n@@ -117,7 +117,7 @@ pub fn print_crate(cm: @CodeMap,\n                    intr: @IdentInterner,\n                    span_diagnostic: @diagnostic::SpanHandler,\n                    crate: &ast::Crate,\n-                   filename: @str,\n+                   filename: ~str,\n                    input: &mut io::Reader,\n                    out: ~io::Writer,\n                    ann: @PpAnn,\n@@ -897,7 +897,7 @@ pub fn print_attribute(s: &mut State, attr: &ast::Attribute) {\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n         let comment = attr.value_str().unwrap();\n-        word(&mut s.s, comment);\n+        word(&mut s.s, comment.get());\n     } else {\n         word(&mut s.s, \"#[\");\n         print_meta_item(s, attr.meta());\n@@ -1058,23 +1058,9 @@ pub fn print_mac(s: &mut State, m: &ast::Mac) {\n     }\n }\n \n-pub fn print_vstore(s: &mut State, t: ast::Vstore) {\n-    match t {\n-        ast::VstoreFixed(Some(i)) => word(&mut s.s, format!(\"{}\", i)),\n-        ast::VstoreFixed(None) => word(&mut s.s, \"_\"),\n-        ast::VstoreUniq => word(&mut s.s, \"~\"),\n-        ast::VstoreBox => word(&mut s.s, \"@\"),\n-        ast::VstoreSlice(ref r) => {\n-            word(&mut s.s, \"&\");\n-            print_opt_lifetime(s, r);\n-        }\n-    }\n-}\n-\n pub fn print_expr_vstore(s: &mut State, t: ast::ExprVstore) {\n     match t {\n       ast::ExprVstoreUniq => word(&mut s.s, \"~\"),\n-      ast::ExprVstoreBox => word(&mut s.s, \"@\"),\n       ast::ExprVstoreSlice => word(&mut s.s, \"&\"),\n       ast::ExprVstoreMutSlice => {\n         word(&mut s.s, \"&\");\n@@ -1466,25 +1452,25 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) {\n             word(&mut s.s, \"asm!\");\n         }\n         popen(s);\n-        print_string(s, a.asm, a.asm_str_style);\n+        print_string(s, a.asm.get(), a.asm_str_style);\n         word_space(s, \":\");\n-        for &(co, o) in a.outputs.iter() {\n-            print_string(s, co, ast::CookedStr);\n+        for &(ref co, o) in a.outputs.iter() {\n+            print_string(s, co.get(), ast::CookedStr);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n             word_space(s, \",\");\n         }\n         word_space(s, \":\");\n-        for &(co, o) in a.inputs.iter() {\n-            print_string(s, co, ast::CookedStr);\n+        for &(ref co, o) in a.inputs.iter() {\n+            print_string(s, co.get(), ast::CookedStr);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n             word_space(s, \",\");\n         }\n         word_space(s, \":\");\n-        print_string(s, a.clobbers, ast::CookedStr);\n+        print_string(s, a.clobbers.get(), ast::CookedStr);\n         pclose(s);\n       }\n       ast::ExprMac(ref m) => print_mac(s, m),\n@@ -1539,11 +1525,13 @@ pub fn print_decl(s: &mut State, decl: &ast::Decl) {\n }\n \n pub fn print_ident(s: &mut State, ident: ast::Ident) {\n-    word(&mut s.s, ident_to_str(&ident));\n+    let string = token::get_ident(ident.name);\n+    word(&mut s.s, string.get());\n }\n \n pub fn print_name(s: &mut State, name: ast::Name) {\n-    word(&mut s.s, interner_get(name));\n+    let string = token::get_ident(name);\n+    word(&mut s.s, string.get());\n }\n \n pub fn print_for_decl(s: &mut State, loc: &ast::Local, coll: &ast::Expr) {\n@@ -1930,14 +1918,14 @@ pub fn print_generics(s: &mut State, generics: &ast::Generics) {\n pub fn print_meta_item(s: &mut State, item: &ast::MetaItem) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::MetaWord(name) => word(&mut s.s, name),\n-      ast::MetaNameValue(name, value) => {\n-        word_space(s, name);\n+      ast::MetaWord(ref name) => word(&mut s.s, name.get()),\n+      ast::MetaNameValue(ref name, ref value) => {\n+        word_space(s, name.get());\n         word_space(s, \"=\");\n-        print_literal(s, &value);\n+        print_literal(s, value);\n       }\n-      ast::MetaList(name, ref items) => {\n-        word(&mut s.s, name);\n+      ast::MetaList(ref name, ref items) => {\n+        word(&mut s.s, name.get());\n         popen(s);\n         commasep(s,\n                  Consistent,\n@@ -1998,7 +1986,7 @@ pub fn print_view_item(s: &mut State, item: &ast::ViewItem) {\n                 space(&mut s.s);\n                 word(&mut s.s, \"=\");\n                 space(&mut s.s);\n-                print_string(s, *p, style);\n+                print_string(s, p.get(), style);\n             }\n         }\n \n@@ -2172,7 +2160,7 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) {\n       _ => ()\n     }\n     match lit.node {\n-      ast::LitStr(st, style) => print_string(s, st, style),\n+      ast::LitStr(ref st, style) => print_string(s, st.get(), style),\n       ast::LitChar(ch) => {\n           let mut res = ~\"'\";\n           char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n@@ -2202,18 +2190,18 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) {\n             word(&mut s.s, (i as u64).to_str_radix(10u));\n         }\n       }\n-      ast::LitFloat(f, t) => {\n-        word(&mut s.s, f.to_owned() + ast_util::float_ty_to_str(t));\n+      ast::LitFloat(ref f, t) => {\n+        word(&mut s.s, f.get() + ast_util::float_ty_to_str(t));\n       }\n-      ast::LitFloatUnsuffixed(f) => word(&mut s.s, f),\n+      ast::LitFloatUnsuffixed(ref f) => word(&mut s.s, f.get()),\n       ast::LitNil => word(&mut s.s, \"()\"),\n       ast::LitBool(val) => {\n         if val { word(&mut s.s, \"true\"); } else { word(&mut s.s, \"false\"); }\n       }\n-      ast::LitBinary(arr) => {\n+      ast::LitBinary(ref arr) => {\n         ibox(s, indent_unit);\n         word(&mut s.s, \"[\");\n-        commasep_cmnt(s, Inconsistent, arr, |s, u| word(&mut s.s, format!(\"{}\", *u)),\n+        commasep_cmnt(s, Inconsistent, *arr.borrow(), |s, u| word(&mut s.s, format!(\"{}\", *u)),\n                       |_| lit.span);\n         word(&mut s.s, \"]\");\n         end(s);"}, {"sha": "fc3e55dcde2565dfae472bb6d6aacf0ba783554a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 90, "deletions": 36, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -14,9 +14,11 @@\n \n use ast::Name;\n \n+use std::cast;\n use std::cell::RefCell;\n use std::cmp::Equiv;\n use std::hashmap::HashMap;\n+use std::rc::Rc;\n \n pub struct Interner<T> {\n     priv map: @RefCell<HashMap<T, Name>>,\n@@ -82,11 +84,49 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n     }\n }\n \n+#[deriving(Clone, Eq, IterBytes, Ord)]\n+pub struct RcStr {\n+    priv string: Rc<~str>,\n+}\n+\n+impl TotalEq for RcStr {\n+    fn equals(&self, other: &RcStr) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl TotalOrd for RcStr {\n+    fn cmp(&self, other: &RcStr) -> Ordering {\n+        self.as_slice().cmp(&other.as_slice())\n+    }\n+}\n+\n+impl Str for RcStr {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        let s: &'a str = *self.string.borrow();\n+        s\n+    }\n+\n+    #[inline]\n+    fn into_owned(self) -> ~str {\n+        self.string.borrow().to_owned()\n+    }\n+}\n+\n+impl RcStr {\n+    pub fn new(string: &str) -> RcStr {\n+        RcStr {\n+            string: Rc::new(string.to_owned()),\n+        }\n+    }\n+}\n+\n // A StrInterner differs from Interner<String> in that it accepts\n // references rather than @ ones, resulting in less allocation.\n pub struct StrInterner {\n-    priv map: @RefCell<HashMap<@str, Name>>,\n-    priv vect: @RefCell<~[@str]>,\n+    priv map: @RefCell<HashMap<RcStr, Name>>,\n+    priv vect: @RefCell<~[RcStr]>,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n@@ -112,8 +152,8 @@ impl StrInterner {\n         }\n \n         let new_idx = self.len() as Name;\n-        let val = val.to_managed();\n-        map.get().insert(val, new_idx);\n+        let val = RcStr::new(val);\n+        map.get().insert(val.clone(), new_idx);\n         let mut vect = self.vect.borrow_mut();\n         vect.get().push(val);\n         new_idx\n@@ -123,7 +163,7 @@ impl StrInterner {\n         let new_idx = self.len() as Name;\n         // leave out of .map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        vect.get().push(val.to_managed());\n+        vect.get().push(RcStr::new(val));\n         new_idx\n     }\n \n@@ -141,22 +181,32 @@ impl StrInterner {\n         let new_idx = self.len() as Name;\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = vect.get()[idx];\n+        let existing = vect.get()[idx].clone();\n         vect.get().push(existing);\n         new_idx\n     }\n \n-    pub fn get(&self, idx: Name) -> @str {\n+    pub fn get(&self, idx: Name) -> RcStr {\n         let vect = self.vect.borrow();\n-        vect.get()[idx]\n+        vect.get()[idx].clone()\n+    }\n+\n+    /// Returns this string with lifetime tied to the interner. Since\n+    /// strings may never be removed from the interner, this is safe.\n+    pub fn get_ref<'a>(&'a self, idx: Name) -> &'a str {\n+        let vect = self.vect.borrow();\n+        let s: &str = vect.get()[idx].as_slice();\n+        unsafe {\n+            cast::transmute(s)\n+        }\n     }\n \n     pub fn len(&self) -> uint {\n         let vect = self.vect.borrow();\n         vect.get().len()\n     }\n \n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<RcStr>>(&self, val: &Q)\n                                                          -> Option<Name> {\n         let map = self.map.borrow();\n         match map.get().find_equiv(val) {\n@@ -172,42 +222,46 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn i1 () {\n-        let i : Interner<@str> = Interner::new();\n+        let i : Interner<RcStr> = Interner::new();\n         i.get(13);\n     }\n \n     #[test]\n     fn interner_tests () {\n-        let i : Interner<@str> = Interner::new();\n+        let i : Interner<RcStr> = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern(@\"dog\"), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n         // re-use gets the same entry:\n-        assert_eq!(i.intern(@\"dog\"), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n         // different string gets a different #:\n-        assert_eq!(i.intern(@\"cat\"), 1);\n-        assert_eq!(i.intern(@\"cat\"), 1);\n+        assert_eq!(i.intern(RcStr::new(\"cat\")), 1);\n+        assert_eq!(i.intern(RcStr::new(\"cat\")), 1);\n         // dog is still at zero\n-        assert_eq!(i.intern(@\"dog\"), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n         // gensym gets 3\n-        assert_eq!(i.gensym(@\"zebra\" ), 2);\n+        assert_eq!(i.gensym(RcStr::new(\"zebra\") ), 2);\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym (@\"zebra\" ), 3);\n+        assert_eq!(i.gensym (RcStr::new(\"zebra\") ), 3);\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(@\"dog\"), 4);\n-        assert_eq!(i.get(0), @\"dog\");\n-        assert_eq!(i.get(1), @\"cat\");\n-        assert_eq!(i.get(2), @\"zebra\");\n-        assert_eq!(i.get(3), @\"zebra\");\n-        assert_eq!(i.get(4), @\"dog\");\n+        assert_eq!(i.gensym(RcStr::new(\"dog\")), 4);\n+        assert_eq!(i.get(0), RcStr::new(\"dog\"));\n+        assert_eq!(i.get(1), RcStr::new(\"cat\"));\n+        assert_eq!(i.get(2), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(3), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(4), RcStr::new(\"dog\"));\n     }\n \n     #[test]\n     fn i3 () {\n-        let i : Interner<@str> = Interner::prefill([@\"Alan\",@\"Bob\",@\"Carol\"]);\n-        assert_eq!(i.get(0), @\"Alan\");\n-        assert_eq!(i.get(1), @\"Bob\");\n-        assert_eq!(i.get(2), @\"Carol\");\n-        assert_eq!(i.intern(@\"Bob\"), 1);\n+        let i : Interner<RcStr> = Interner::prefill([\n+            RcStr::new(\"Alan\"),\n+            RcStr::new(\"Bob\"),\n+            RcStr::new(\"Carol\")\n+        ]);\n+        assert_eq!(i.get(0), RcStr::new(\"Alan\"));\n+        assert_eq!(i.get(1), RcStr::new(\"Bob\"));\n+        assert_eq!(i.get(2), RcStr::new(\"Carol\"));\n+        assert_eq!(i.intern(RcStr::new(\"Bob\")), 1);\n     }\n \n     #[test]\n@@ -230,13 +284,13 @@ mod tests {\n         assert_eq!(i.gensym(\"dog\"), 4);\n         // gensym tests again with gensym_copy:\n         assert_eq!(i.gensym_copy(2), 5);\n-        assert_eq!(i.get(5), @\"zebra\");\n+        assert_eq!(i.get(5), RcStr::new(\"zebra\"));\n         assert_eq!(i.gensym_copy(2), 6);\n-        assert_eq!(i.get(6), @\"zebra\");\n-        assert_eq!(i.get(0), @\"dog\");\n-        assert_eq!(i.get(1), @\"cat\");\n-        assert_eq!(i.get(2), @\"zebra\");\n-        assert_eq!(i.get(3), @\"zebra\");\n-        assert_eq!(i.get(4), @\"dog\");\n+        assert_eq!(i.get(6), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(0), RcStr::new(\"dog\"));\n+        assert_eq!(i.get(1), RcStr::new(\"cat\"));\n+        assert_eq!(i.get(2), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(3), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(4), RcStr::new(\"dog\"));\n     }\n }"}, {"sha": "58c2bed7a45a73b60703d5bfc1b38389c570df0c", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -17,72 +17,72 @@ use parse::token;\n \n // map a string to tts, using a made-up filename: return both the TokenTree's\n // and the ParseSess\n-pub fn string_to_tts_and_sess (source_str : @str) -> (~[ast::TokenTree], @ParseSess) {\n+pub fn string_to_tts_and_sess (source_str : ~str) -> (~[ast::TokenTree], @ParseSess) {\n     let ps = new_parse_sess(None);\n-    (filemap_to_tts(ps,string_to_filemap(ps,source_str,@\"bogofile\")),ps)\n+    (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n }\n \n // map a string to tts, using a made-up filename:\n-pub fn string_to_tts(source_str : @str) -> ~[ast::TokenTree] {\n+pub fn string_to_tts(source_str : ~str) -> ~[ast::TokenTree] {\n     let (tts,_) = string_to_tts_and_sess(source_str);\n     tts\n }\n \n-pub fn string_to_parser_and_sess(source_str: @str) -> (Parser,@ParseSess) {\n+pub fn string_to_parser_and_sess(source_str: ~str) -> (Parser,@ParseSess) {\n     let ps = new_parse_sess(None);\n-    (new_parser_from_source_str(ps,~[],@\"bogofile\",source_str),ps)\n+    (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n }\n \n // map string to parser (via tts)\n-pub fn string_to_parser(source_str: @str) -> Parser {\n+pub fn string_to_parser(source_str: ~str) -> Parser {\n     let (p,_) = string_to_parser_and_sess(source_str);\n     p\n }\n \n-fn with_error_checking_parse<T>(s: @str, f: |&mut Parser| -> T) -> T {\n+fn with_error_checking_parse<T>(s: ~str, f: |&mut Parser| -> T) -> T {\n     let mut p = string_to_parser(s);\n     let x = f(&mut p);\n     p.abort_if_errors();\n     x\n }\n \n // parse a string, return a crate.\n-pub fn string_to_crate (source_str : @str) -> ast::Crate {\n+pub fn string_to_crate (source_str : ~str) -> ast::Crate {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_crate_mod()\n     })\n }\n \n // parse a string, return a crate and the ParseSess\n-pub fn string_to_crate_and_sess (source_str : @str) -> (ast::Crate,@ParseSess) {\n+pub fn string_to_crate_and_sess (source_str : ~str) -> (ast::Crate,@ParseSess) {\n     let (mut p,ps) = string_to_parser_and_sess(source_str);\n     (p.parse_crate_mod(),ps)\n }\n \n // parse a string, return an expr\n-pub fn string_to_expr (source_str : @str) -> @ast::Expr {\n+pub fn string_to_expr (source_str : ~str) -> @ast::Expr {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_expr()\n     })\n }\n \n // parse a string, return an item\n-pub fn string_to_item (source_str : @str) -> Option<@ast::Item> {\n+pub fn string_to_item (source_str : ~str) -> Option<@ast::Item> {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_item(~[])\n     })\n }\n \n // parse a string, return a stmt\n-pub fn string_to_stmt(source_str : @str) -> @ast::Stmt {\n+pub fn string_to_stmt(source_str : ~str) -> @ast::Stmt {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_stmt(~[])\n     })\n }\n \n // parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n // (currently) affect parsing.\n-pub fn string_to_pat(source_str : @str) -> @ast::Pat {\n+pub fn string_to_pat(source_str : ~str) -> @ast::Pat {\n     string_to_parser(source_str).parse_pat()\n }\n "}, {"sha": "6a0f5a39202a99d734fac887da39c46ee13708a1", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     // reference.  That would allow creating a mutable pointer to a\n     // temporary, which would be a source of confusion\n \n-    let mut a = @[0];\n+    let mut a = ~[0];\n     a.test_mut(); //~ ERROR does not implement any method in scope named `test_mut`\n }\n "}, {"sha": "0d01fe4e8c73204a83c8ae258f3f395e1b847021", "filename": "src/test/compile-fail/drop-on-non-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(managed_boxes)];\n \n-type Foo = @[u8];\n+type Foo = ~[u8];\n \n impl Drop for Foo {   //~ ERROR the Drop trait may only be implemented\n //~^ ERROR cannot provide an extension implementation"}, {"sha": "d99d29fb810803c94529d3e644d95c7f5cb63568", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -8,26 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n-fn wants_box(x: @str) { }\n fn wants_uniq(x: ~str) { }\n fn wants_slice(x: &str) { }\n \n-fn has_box(x: @str) {\n-   wants_box(x);\n-   wants_uniq(x); //~ ERROR str storage differs: expected `~` but found `@`\n-   wants_slice(x);\n-}\n-\n fn has_uniq(x: ~str) {\n-   wants_box(x); //~ ERROR str storage differs: expected `@` but found `~`\n    wants_uniq(x);\n    wants_slice(x);\n }\n \n fn has_slice(x: &str) {\n-   wants_box(x); //~ ERROR str storage differs: expected `@` but found `&`\n    wants_uniq(x); //~ ERROR str storage differs: expected `~` but found `&`\n    wants_slice(x);\n }"}, {"sha": "9a0227b7d31a21013b2e99431030fad8afdf02f4", "filename": "src/test/compile-fail/evec-subtyping.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -10,30 +10,20 @@\n \n #[feature(managed_boxes)];\n \n-fn wants_box(x: @[uint]) { }\n fn wants_uniq(x: ~[uint]) { }\n fn wants_three(x: [uint, ..3]) { }\n \n-fn has_box(x: @[uint]) {\n-   wants_box(x);\n-   wants_uniq(x); //~ ERROR [] storage differs: expected `~` but found `@`\n-   wants_three(x); //~ ERROR [] storage differs: expected `3` but found `@`\n-}\n-\n fn has_uniq(x: ~[uint]) {\n-   wants_box(x); //~ ERROR [] storage differs: expected `@` but found `~`\n    wants_uniq(x);\n    wants_three(x); //~ ERROR [] storage differs: expected `3` but found `~`\n }\n \n fn has_three(x: [uint, ..3]) {\n-   wants_box(x); //~ ERROR [] storage differs: expected `@` but found `3`\n    wants_uniq(x); //~ ERROR [] storage differs: expected `~` but found `3`\n    wants_three(x);\n }\n \n fn has_four(x: [uint, ..4]) {\n-   wants_box(x); //~ ERROR [] storage differs: expected `@` but found `4`\n    wants_uniq(x); //~ ERROR [] storage differs: expected `~` but found `4`\n    wants_three(x); //~ ERROR [] storage differs: expected `3` but found `4`\n }"}, {"sha": "3fc6106f7480b6455dc4489b50e8194ed0c3b285", "filename": "src/test/compile-fail/issue-10487.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -11,6 +11,5 @@\n #[feature(managed_boxes)];\n \n static x: ~[int] = ~[123, 456]; //~ ERROR: cannot allocate vectors in constant expressions\n-static y: @[int] = @[123, 456]; //~ ERROR: cannot allocate vectors in constant expressions\n \n fn main() {}"}, {"sha": "8899f3f5dbbcfd1b986342ab39c2295c2827422b", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -22,11 +22,8 @@ fn main() {\n     let _x : Bar = Bar {x : ~10}; //~ ERROR type uses owned\n \n     @2; //~ ERROR type uses managed\n-    @[1]; //~ ERROR type uses managed\n-    //~^ ERROR type uses managed\n+\n     fn f(_: @Clone) {} //~ ERROR type uses managed\n-    @\"\"; //~ ERROR type uses managed\n-    //~^ ERROR type uses managed\n \n     ~2; //~ ERROR type uses owned\n     ~[1]; //~ ERROR type uses owned"}, {"sha": "4e2391ea25ff2dd54c86c89f838bc8c28131f85d", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -72,12 +72,6 @@ fn f80() {\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n-fn f90() {\n-    let x = ~\"hi\";\n-    let _y = @[x];\n-    touch(&x); //~ ERROR use of moved value: `x`\n-}\n-\n fn f100() {\n     let x = ~[~\"hi\"];\n     let _y = x[0];"}, {"sha": "2c0edb783f830ff0f0a5884d571faefbb593ed3f", "filename": "src/test/debug-info/boxed-vec.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -17,21 +17,15 @@\n // debugger:run\n // debugger:finish\n \n-// debugger:print managed->val.fill\n-// check:$1 = 24\n-// debugger:print *((uint64_t[3]*)(managed->val.elements))\n-// check:$2 = {7, 8, 9}\n-\n // debugger:print unique->fill\n-// check:$3 = 32\n+// check:$1 = 32\n // debugger:print *((uint64_t[4]*)(unique->elements))\n-// check:$4 = {10, 11, 12, 13}\n+// check:$2 = {10, 11, 12, 13}\n \n #[allow(unused_variable)];\n \n fn main() {\n \n-    let managed: @[i64] = @[7, 8, 9];\n     let unique: ~[i64] = ~[10, 11, 12, 13];\n \n     zzz();"}, {"sha": "f3af7d652cde49b3757e5dda74b9823d92b9b76f", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -144,9 +144,6 @@ pub fn main() {\n     let a = &Point {x: 3u, y: 5u};\n     test_ebml(a);\n \n-    let a = &@[1u, 2u, 3u];\n-    test_ebml(a);\n-\n     let a = &Top(22u);\n     test_ebml(a);\n "}, {"sha": "c22e25e5d95be099d257932b7f5a524857bafcbf", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -30,11 +30,9 @@ pub fn main() {\n \n     ([1]).test_imm();\n     (~[1]).test_imm();\n-    (@[1]).test_imm();\n     (&[1]).test_imm();\n     (\"test\").test_imm();\n     (~\"test\").test_imm();\n-    (@\"test\").test_imm();\n     (&\"test\").test_imm();\n \n     // FIXME: Other types of mutable vecs don't currently exist"}, {"sha": "5ae959ef169998e2d3fb4030be78c8393520471e", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=60ffbeb2a495d097e38f51348ebcf5a884947c25", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-fn sum_slice(x: &[int]) -> int {\n-    let mut sum = 0;\n-    for i in x.iter() { sum += *i; }\n-    return sum;\n-}\n-\n-pub fn main() {\n-    let x = @[1, 2, 3];\n-    assert_eq!(sum_slice(x), 6);\n-}"}, {"sha": "07a13e5395fc3c1d363218db177a087691292c17", "filename": "src/test/run-pass/borrowed-ptr-pattern-infallible.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-infallible.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -11,8 +11,7 @@\n #[feature(managed_boxes)];\n \n pub fn main() {\n-    let (&x, &y, &z) = (&3, &'a', &@\"No pets!\");\n+    let (&x, &y) = (&3, &'a');\n     assert_eq!(x, 3);\n     assert_eq!(y, 'a');\n-    assert_eq!(z, @\"No pets!\");\n }"}, {"sha": "7ccb40c8e7b37b4475e735dce12ed6ae70cbee60", "filename": "src/test/run-pass/borrowed-ptr-pattern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -17,5 +17,4 @@ fn foo<T:Clone>(x: &T) -> T{\n pub fn main() {\n     assert_eq!(foo(&3), 3);\n     assert_eq!(foo(&'a'), 'a');\n-    assert_eq!(foo(&@\"Dogs rule, cats drool\"), @\"Dogs rule, cats drool\");\n }"}, {"sha": "73837a46df707be879f1f21089b7d60d34e55b94", "filename": "src/test/run-pass/estr-shared.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Festr-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Festr-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-shared.rs?ref=60ffbeb2a495d097e38f51348ebcf5a884947c25", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-pub fn main() {\n-    let _x : @str = @\"hello\";\n-}"}, {"sha": "c841297e19f2f2f357f367e80f452314254590b0", "filename": "src/test/run-pass/expr-repeat-vstore.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -7,10 +7,4 @@ pub fn main() {\n     println!(\"{}\", v[2]);\n     println!(\"{}\", v[3]);\n     println!(\"{}\", v[4]);\n-    let v: @[int] = @[ 2, ..5 ];\n-    println!(\"{}\", v[0]);\n-    println!(\"{}\", v[1]);\n-    println!(\"{}\", v[2]);\n-    println!(\"{}\", v[3]);\n-    println!(\"{}\", v[4]);\n }"}, {"sha": "cc59ce5d8b24589b384c6b94fcf06c4079e6f83b", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -58,7 +58,6 @@ pub fn main() {\n     t!(format!(\"{}\", 1.0f64), \"1\");\n     t!(format!(\"{}\", \"a\"), \"a\");\n     t!(format!(\"{}\", ~\"a\"), \"a\");\n-    t!(format!(\"{}\", @\"a\"), \"a\");\n     t!(format!(\"{}\", false), \"false\");\n     t!(format!(\"{}\", 'a'), \"a\");\n \n@@ -73,7 +72,6 @@ pub fn main() {\n     t!(format!(\"{:X}\", 10u), \"A\");\n     t!(format!(\"{:s}\", \"foo\"), \"foo\");\n     t!(format!(\"{:s}\", ~\"foo\"), \"foo\");\n-    t!(format!(\"{:s}\", @\"foo\"), \"foo\");\n     t!(format!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n     t!(format!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n     t!(format!(\"{:d}\", A), \"aloha\");"}, {"sha": "ace27c5ea11f61ad56e2f17bd20aacf367721a26", "filename": "src/test/run-pass/issue-3574.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fissue-3574.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fissue-3574.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3574.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -26,5 +26,4 @@ pub fn main()\n {\n     assert!(compare(\"foo\", \"foo\"));\n     assert!(compare(~\"foo\", ~\"foo\"));\n-    assert!(compare(@\"foo\", @\"foo\"));\n }"}, {"sha": "62174a70d07fe2983deda38134b18734ba5e1615", "filename": "src/test/run-pass/issue-4092.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fissue-4092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fissue-4092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4092.rs?ref=60ffbeb2a495d097e38f51348ebcf5a884947c25", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-use std::hashmap::HashMap;\n-\n-pub fn main() {\n-    let mut x = HashMap::new();\n-    x.insert((@\"abc\", 0), 0);\n-}"}, {"sha": "ffb7a0a5bb30e5446b5c77672fd670bba7cf66de", "filename": "src/test/run-pass/issue-5926.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fissue-5926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fissue-5926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5926.rs?ref=60ffbeb2a495d097e38f51348ebcf5a884947c25", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-#[allow(unused_mut)];\n-\n-pub fn main() {\n-    let  mut your_favorite_numbers = @[1,2,3];\n-    let  mut my_favorite_numbers = @[4,5,6];\n-    let  f = your_favorite_numbers + my_favorite_numbers;\n-    println!(\"The third favorite number is {:?}.\", f)\n-}\n-"}, {"sha": "c5123f23116251c9af2b6e91d95d37404a345c3f", "filename": "src/test/run-pass/issue-9382.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9382.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -35,10 +35,6 @@ pub fn main() {\n         baz: ~[],\n         bar: ~32,\n     };\n-    let _t1_at = Thing1 {\n-        baz: @[],\n-        bar: ~32,\n-    };\n     let _t2_fixed = Thing2 {\n         baz: &[],\n         bar: 32,\n@@ -47,8 +43,4 @@ pub fn main() {\n         baz: ~[],\n         bar: 32,\n     };\n-    let _t2_at = Thing2 {\n-        baz: @[],\n-        bar: 32,\n-    };\n }"}, {"sha": "b0f31f70f53c0e4803e68f44fedaa3abce373a7f", "filename": "src/test/run-pass/match-borrowed_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -43,19 +43,15 @@ fn g2(ref_1: &str, ref_2: &str) -> ~str {\n }\n \n pub fn main() {\n-    assert_eq!(f1(@\"a\"), ~\"found a\");\n     assert_eq!(f1(~\"b\"), ~\"found b\");\n     assert_eq!(f1(&\"c\"), ~\"not found\");\n     assert_eq!(f1(\"d\"), ~\"not found\");\n-    assert_eq!(f2(@\"a\"), ~\"found a\");\n     assert_eq!(f2(~\"b\"), ~\"found b\");\n     assert_eq!(f2(&\"c\"), ~\"not found (c)\");\n     assert_eq!(f2(\"d\"), ~\"not found (d)\");\n-    assert_eq!(g1(@\"a\", @\"b\"), ~\"found a,b\");\n     assert_eq!(g1(~\"b\", ~\"c\"), ~\"found b,c\");\n     assert_eq!(g1(&\"c\", &\"d\"), ~\"not found\");\n     assert_eq!(g1(\"d\", \"e\"), ~\"not found\");\n-    assert_eq!(g2(@\"a\", @\"b\"), ~\"found a,b\");\n     assert_eq!(g2(~\"b\", ~\"c\"), ~\"found b,c\");\n     assert_eq!(g2(&\"c\", &\"d\"), ~\"not found (c, d)\");\n     assert_eq!(g2(\"d\", \"e\"), ~\"not found (d, e)\");"}, {"sha": "7d8d5d635f904724e7bce6b064b8a6a69293296f", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -79,10 +79,7 @@ pub fn main() {\n     check_type!(~18: ~int);\n     check_type!(@19: @int);\n     check_type!(~\"foo\": ~str);\n-    check_type!(@\"bar\": @str);\n     check_type!(~[20, 22]: ~[int]);\n-    check_type!(@[]: @[int]);\n-    check_type!(@[24, 26]: @[int]);\n     let mint: uint = unsafe { cast::transmute(main) };\n     check_type!(main: extern fn(), |pthing| {\n         assert!(mint == unsafe { cast::transmute(*pthing) })"}, {"sha": "84a6baa5de8a9996f887a69f3c779c40459afcbf", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -41,8 +41,6 @@ pub fn main() {\n     check_type!(~int);\n     check_type!(@int);\n     check_type!(~str);\n-    check_type!(@str);\n     check_type!(~[int]);\n-    check_type!(@[int]);\n     check_type!(extern fn());\n }"}, {"sha": "0b6ab579e6b73299fdc5acfe5b37c55d353aeaff", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -22,6 +22,6 @@ pub fn main() {\n \n     assert_eq!(mem::size_of::<S<u64, u16>>(), 11);\n \n-    assert_eq!(mem::size_of::<S<~str, @[int]>>(),\n-               1 + mem::size_of::<~str>() + mem::size_of::<@[int]>());\n+    assert_eq!(mem::size_of::<S<~str, ~[int]>>(),\n+               1 + mem::size_of::<~str>() + mem::size_of::<~[int]>());\n }"}, {"sha": "6a817bf03d40180c3e9c724981cdfd7b4851bc44", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -180,9 +180,6 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_estr_box(&mut self) -> bool {\n-        self.align_to::<@str>();\n-        if ! self.inner().visit_estr_box() { return false; }\n-        self.bump_past::<@str>();\n         true\n     }\n \n@@ -255,9 +252,6 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@[u8]>();\n-        if ! self.inner().visit_evec_box(mtbl, inner) { return false; }\n-        self.bump_past::<@[u8]>();\n         true\n     }\n "}, {"sha": "3c0fcba2064fba9e96f9b7e2086c21023a17b92b", "filename": "src/test/run-pass/regions-borrow-evec-at.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ffbeb2a495d097e38f51348ebcf5a884947c25/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-at.rs?ref=60ffbeb2a495d097e38f51348ebcf5a884947c25", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-fn foo(x: &[uint]) -> uint {\n-    x[0]\n-}\n-\n-pub fn main() {\n-    let p = @[22u];\n-    let r = foo(p);\n-    assert_eq!(r, 22u);\n-}"}, {"sha": "9f2069908437b96e7cf30b2e02c6d0b21ffecb42", "filename": "src/test/run-pass/repeated-vector-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -16,7 +16,7 @@ struct Foo {\n }\n \n pub fn main() {\n-    let x = [ @[true], ..512 ];\n+    let x = [ [true], ..512 ];\n     let y = [ 0, ..1 ];\n \n     error!(\"{:?}\", x);"}, {"sha": "dc7e51c3c2364cb5c60c79933c4b93e71451df7e", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -63,11 +63,6 @@ pub fn main() {\n     assert_eq!(map.find_equiv(&(~\"cde\")), Some(&c));\n     assert_eq!(map.find_equiv(&(~\"def\")), Some(&d));\n \n-    assert_eq!(map.find_equiv(&(@\"abc\")), Some(&a));\n-    assert_eq!(map.find_equiv(&(@\"bcd\")), Some(&b));\n-    assert_eq!(map.find_equiv(&(@\"cde\")), Some(&c));\n-    assert_eq!(map.find_equiv(&(@\"def\")), Some(&d));\n-\n     assert_eq!(map.find_equiv(&SendStrStatic(\"abc\")), Some(&a));\n     assert_eq!(map.find_equiv(&SendStrStatic(\"bcd\")), Some(&b));\n     assert_eq!(map.find_equiv(&SendStrStatic(\"cde\")), Some(&c));"}, {"sha": "68d2ce364631c6f6aee1435722987a90394c1839", "filename": "src/test/run-pass/vec-matching-autoslice.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -1,7 +1,5 @@\n-#[feature(managed_boxes)];\n-\n pub fn main() {\n-    let x = @[1, 2, 3];\n+    let x = ~[1, 2, 3];\n     match x {\n         [2, ..] => fail!(),\n         [1, ..tail] => {"}, {"sha": "e25b4de0a11c9dc019a06a126e344843eddbdcca", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcd951749b67402ccaa31f1bb0349656f880fe2/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=2bcd951749b67402ccaa31f1bb0349656f880fe2", "patch": "@@ -8,19 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n pub fn main() {\n     assert_eq!((~[0, 1]).to_str(), ~\"[0, 1]\");\n     assert_eq!((&[1, 2]).to_str(), ~\"[1, 2]\");\n-    assert_eq!((@[2, 3]).to_str(), ~\"[2, 3]\");\n \n     let foo = ~[3, 4];\n     let bar = &[4, 5];\n-    let baz = @[5, 6];\n \n     assert_eq!(foo.to_str(), ~\"[3, 4]\");\n     assert_eq!(bar.to_str(), ~\"[4, 5]\");\n-    assert_eq!(baz.to_str(), ~\"[5, 6]\");\n-\n }"}]}