{"sha": "8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYmIyMGVkY2U4NWI3NGVhYjBlZDc4YmE1YzQ5NjllYzczM2FkMTI=", "commit": {"author": {"name": "Marco Groppo", "email": "marco.groppo@gmail.com", "date": "2019-04-17T21:40:00Z"}, "committer": {"name": "Marco Groppo", "email": "marco.groppo@gmail.com", "date": "2019-04-19T22:20:26Z"}, "message": "New krate() method in Resolver.\n\nRenamed Impl to ImplBlock.", "tree": {"sha": "eb23fc45cc395de68ad60ced6bd65d80c4945245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb23fc45cc395de68ad60ced6bd65d80c4945245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "html_url": "https://github.com/rust-lang/rust/commit/8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/comments", "author": {"login": "marcogroppo", "id": 2735511, "node_id": "MDQ6VXNlcjI3MzU1MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2735511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcogroppo", "html_url": "https://github.com/marcogroppo", "followers_url": "https://api.github.com/users/marcogroppo/followers", "following_url": "https://api.github.com/users/marcogroppo/following{/other_user}", "gists_url": "https://api.github.com/users/marcogroppo/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcogroppo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcogroppo/subscriptions", "organizations_url": "https://api.github.com/users/marcogroppo/orgs", "repos_url": "https://api.github.com/users/marcogroppo/repos", "events_url": "https://api.github.com/users/marcogroppo/events{/privacy}", "received_events_url": "https://api.github.com/users/marcogroppo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcogroppo", "id": 2735511, "node_id": "MDQ6VXNlcjI3MzU1MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2735511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcogroppo", "html_url": "https://github.com/marcogroppo", "followers_url": "https://api.github.com/users/marcogroppo/followers", "following_url": "https://api.github.com/users/marcogroppo/following{/other_user}", "gists_url": "https://api.github.com/users/marcogroppo/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcogroppo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcogroppo/subscriptions", "organizations_url": "https://api.github.com/users/marcogroppo/orgs", "repos_url": "https://api.github.com/users/marcogroppo/repos", "events_url": "https://api.github.com/users/marcogroppo/events{/privacy}", "received_events_url": "https://api.github.com/users/marcogroppo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e85ee60c42db57368e24ad9ac24840c2494d383c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e85ee60c42db57368e24ad9ac24840c2494d383c", "html_url": "https://github.com/rust-lang/rust/commit/e85ee60c42db57368e24ad9ac24840c2494d383c"}], "stats": {"total": 102, "additions": 46, "deletions": 56}, "files": [{"sha": "a25d419e7963531585fe9b00b5405648671a5c9e", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "patch": "@@ -11,7 +11,7 @@ use crate::{\n pub enum LangItemTarget {\n     Enum(Enum),\n     Function(Function),\n-    Impl(ImplBlock),\n+    ImplBlock(ImplBlock),\n     Static(Static),\n     Struct(Struct),\n     Trait(Trait),\n@@ -22,7 +22,7 @@ impl LangItemTarget {\n         match self {\n             LangItemTarget::Enum(e) => e.module(db).krate(db),\n             LangItemTarget::Function(f) => f.module(db).krate(db),\n-            LangItemTarget::Impl(i) => i.module().krate(db),\n+            LangItemTarget::ImplBlock(i) => i.module().krate(db),\n             LangItemTarget::Static(s) => s.module(db).krate(db),\n             LangItemTarget::Struct(s) => s.module(db).krate(db),\n             LangItemTarget::Trait(t) => t.module(db).krate(db),\n@@ -65,7 +65,7 @@ impl LangItems {\n                 .nth(0);\n             if let Some(lang_item_name) = lang_item_name {\n                 let imp = ImplBlock::from_id(*module, impl_id);\n-                self.items.entry(lang_item_name).or_insert(LangItemTarget::Impl(imp));\n+                self.items.entry(lang_item_name).or_insert(LangItemTarget::ImplBlock(imp));\n             }\n         }\n "}, {"sha": "f2c85eb668e4bad0375876bbaee635a83da1abd8", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "patch": "@@ -5,13 +5,15 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     ModuleDef,\n+    code_model_api::Crate,\n     db::HirDatabase,\n     name::{Name, KnownName},\n     nameres::{PerNs, CrateDefMap, CrateModuleId},\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n-    path::Path, Trait\n+    path::Path,\n+    Trait\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -190,13 +192,17 @@ impl Resolver {\n             .flatten()\n     }\n \n-    pub(crate) fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n+    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n \n             _ => None,\n         })\n     }\n+\n+    pub(crate) fn krate(&self) -> Option<Crate> {\n+        self.module().map(|t| t.0.krate())\n+    }\n }\n \n impl Resolver {"}, {"sha": "c7772a7f6d03479226a407d3d8a4744a88c97c58", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "patch": "@@ -462,7 +462,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let remaining_index = remaining_index.unwrap_or(path.segments.len());\n         let mut actual_def_ty: Option<Ty> = None;\n \n-        let krate = resolver.module().map(|t| t.0.krate());\n+        let krate = resolver.krate()?;\n         // resolve intermediate segments\n         for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n             let ty = match resolved {\n@@ -504,38 +504,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n             actual_def_ty = Some(ty.clone());\n \n-            let item: crate::ModuleDef = krate.and_then(|k| {\n-                ty.iterate_impl_items(self.db, k, |item| {\n-                    let matching_def: Option<crate::ModuleDef> = match item {\n-                        crate::ImplItem::Method(func) => {\n-                            let sig = func.signature(self.db);\n-                            if segment.name == *sig.name() {\n-                                Some(func.into())\n-                            } else {\n-                                None\n-                            }\n+            let item: crate::ModuleDef = ty.iterate_impl_items(self.db, krate, |item| {\n+                let matching_def: Option<crate::ModuleDef> = match item {\n+                    crate::ImplItem::Method(func) => {\n+                        let sig = func.signature(self.db);\n+                        if segment.name == *sig.name() {\n+                            Some(func.into())\n+                        } else {\n+                            None\n                         }\n+                    }\n \n-                        crate::ImplItem::Const(konst) => {\n-                            let sig = konst.signature(self.db);\n-                            if segment.name == *sig.name() {\n-                                Some(konst.into())\n-                            } else {\n-                                None\n-                            }\n+                    crate::ImplItem::Const(konst) => {\n+                        let sig = konst.signature(self.db);\n+                        if segment.name == *sig.name() {\n+                            Some(konst.into())\n+                        } else {\n+                            None\n                         }\n+                    }\n \n-                        // FIXME: Resolve associated types\n-                        crate::ImplItem::TypeAlias(_) => None,\n-                    };\n-                    match matching_def {\n-                        Some(_) => {\n-                            self.write_assoc_resolution(id, item);\n-                            return matching_def;\n-                        }\n-                        None => None,\n+                    // FIXME: Resolve associated types\n+                    crate::ImplItem::TypeAlias(_) => None,\n+                };\n+                match matching_def {\n+                    Some(_) => {\n+                        self.write_assoc_resolution(id, item);\n+                        return matching_def;\n                     }\n-                })\n+                    None => None,\n+                }\n             })?;\n \n             resolved = Resolution::Def(item.into());"}, {"sha": "dca56a434d5036707b4d7811a1fe461f35dc1276", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "patch": "@@ -112,33 +112,19 @@ impl CrateImplBlocks {\n     }\n }\n \n-/// Rudimentary check whether an impl exists for a given type and trait; this\n-/// will actually be done by chalk.\n-pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n-    // FIXME use all trait impls in the whole crate graph\n-    let krate = trait_ref.trait_.module(db).krate(db);\n-    let krate = match krate {\n-        Some(krate) => krate,\n-        None => return false,\n-    };\n-    let crate_impl_blocks = db.impls_in_crate(krate);\n-    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n-    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n-}\n-\n-fn def_crate(db: &impl HirDatabase, cur_krate: Crate, ty: &Ty) -> Option<Crate> {\n+fn def_crate(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n             TypeCtor::Adt(def_id) => def_id.krate(db),\n-            TypeCtor::Bool => lang_item_lookup(db, cur_krate, \"bool\")?.krate(db),\n-            TypeCtor::Char => lang_item_lookup(db, cur_krate, \"char\")?.krate(db),\n+            TypeCtor::Bool => lang_item_lookup(db, cur_crate, \"bool\")?.krate(db),\n+            TypeCtor::Char => lang_item_lookup(db, cur_crate, \"char\")?.krate(db),\n             TypeCtor::Float(UncertainFloatTy::Known(f)) => {\n-                lang_item_lookup(db, cur_krate, f.ty_to_string())?.krate(db)\n+                lang_item_lookup(db, cur_crate, f.ty_to_string())?.krate(db)\n             }\n             TypeCtor::Int(UncertainIntTy::Known(i)) => {\n-                lang_item_lookup(db, cur_krate, i.ty_to_string())?.krate(db)\n+                lang_item_lookup(db, cur_crate, i.ty_to_string())?.krate(db)\n             }\n-            TypeCtor::Str => lang_item_lookup(db, cur_krate, \"str\")?.krate(db),\n+            TypeCtor::Str => lang_item_lookup(db, cur_crate, \"str\")?.krate(db),\n             _ => None,\n         },\n         _ => None,\n@@ -175,7 +161,7 @@ impl Ty {\n         // find in the end takes &self, we still do the autoderef step (just as\n         // rustc does an autoderef and then autoref again).\n \n-        let krate = resolver.module().map(|t| t.0.krate())?;\n+        let krate = resolver.krate()?;\n         for derefed_ty in self.autoderef(db) {\n             if let Some(result) =\n                 derefed_ty.iterate_inherent_methods(db, name, krate, &mut callback)"}, {"sha": "c41752ae7fce07354b13a0a8915256d359cf571a", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebb20edce85b74eab0ed78ba5c4969ec733ad12/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=8ebb20edce85b74eab0ed78ba5c4969ec733ad12", "patch": "@@ -39,7 +39,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         hir::ModuleDef::Struct(s) => {\n             let ty = s.ty(ctx.db);\n             let krate = ctx.module.and_then(|m| m.krate(ctx.db));\n-            krate.map_or((), |krate| {\n+            if let Some(krate) = krate {\n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n                     match item {\n                         hir::ImplItem::Method(func) => {\n@@ -53,7 +53,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                     }\n                     None::<()>\n                 });\n-            });\n+            }\n         }\n         _ => return,\n     };"}]}