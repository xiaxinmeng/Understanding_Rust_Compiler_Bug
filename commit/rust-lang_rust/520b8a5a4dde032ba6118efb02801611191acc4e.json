{"sha": "520b8a5a4dde032ba6118efb02801611191acc4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMGI4YTVhNGRkZTAzMmJhNjExOGVmYjAyODAxNjExMTkxYWNjNGU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-03T08:56:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-03T08:56:17Z"}, "message": "Merge #7115\n\n7115: Migrate HasSource::source to return Option r=matklad a=nick96\n\nI've made a start on fixing #6913 based on the provided work plan, migrating `HasSource::source` to return an `Option`. The simple cases are migrated but there are a few that I'm unsure exactly how they should be handled:\r\n\r\n- Logging the processing of functions in `AnalysisStatsCmd::run`: In verbose mode it includes the path to the module containing the function and the syntax range. I've handled this with an if-let but would it be better to blow up here with `expect`? I'm not 100% on the code paths but if we're processing a function definition then the source should exist.\r\n\r\nI've handled `source()` in all code paths as `None` being a valid return value but are there some cases where we should just blow up? Also, all I've done is bubble up the returned `None`s, there may be some places where we can recover and still provide something.\n\nCo-authored-by: Nick Spain <nicholas.spain@stileeducation.com>\nCo-authored-by: Nick Spain <nicholas.spain96@gmail.com>", "tree": {"sha": "811cd86e5c9a2803bc3d38f19f4ad86e60be1d18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/811cd86e5c9a2803bc3d38f19f4ad86e60be1d18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/520b8a5a4dde032ba6118efb02801611191acc4e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf8YaxCRBK7hj4Ov3rIwAAdHIIADDmjY5DVplEtfTSps5YW6Ws\nva3ubcbYLyY6iF17S0VyBOgSXXC72JR6z7m81csP8SB2QI4bESn/cTQleG/O5nMJ\n5j+HUzrfwjJaLQSDpJjuF5wPAn8LBx6v0Z90rxMfRqainnnH7/X5GGQ5JtDWWvDE\nLiV0LyjFxR1pXXDr4rMZOMbL+tWq+q65EBok2kUux7bBHVyta9MIhpopwbyMk2Ip\nLl7iCRCC+ruWo6wzW+My29q6JFoE6BaOKuhfynU5Hki726WrvuZVCd+atKe0SbcX\nDP3xzBpw/6jHzovGmDFRBN5G0xmujsB2aVjo4Ozp84VEQihG1+thz3VFQIfKvPA=\n=6iYE\n-----END PGP SIGNATURE-----\n", "payload": "tree 811cd86e5c9a2803bc3d38f19f4ad86e60be1d18\nparent 3bf4cec79932de0a49338f6b87dc20f85dc3a509\nparent 40cd6cdf67dcfad89a80ff3a662bec2dfd983d67\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1609664177 +0000\ncommitter GitHub <noreply@github.com> 1609664177 +0000\n\nMerge #7115\n\n7115: Migrate HasSource::source to return Option r=matklad a=nick96\n\nI've made a start on fixing #6913 based on the provided work plan, migrating `HasSource::source` to return an `Option`. The simple cases are migrated but there are a few that I'm unsure exactly how they should be handled:\r\n\r\n- Logging the processing of functions in `AnalysisStatsCmd::run`: In verbose mode it includes the path to the module containing the function and the syntax range. I've handled this with an if-let but would it be better to blow up here with `expect`? I'm not 100% on the code paths but if we're processing a function definition then the source should exist.\r\n\r\nI've handled `source()` in all code paths as `None` being a valid return value but are there some cases where we should just blow up? Also, all I've done is bubble up the returned `None`s, there may be some places where we can recover and still provide something.\n\nCo-authored-by: Nick Spain <nicholas.spain@stileeducation.com>\nCo-authored-by: Nick Spain <nicholas.spain96@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/520b8a5a4dde032ba6118efb02801611191acc4e", "html_url": "https://github.com/rust-lang/rust/commit/520b8a5a4dde032ba6118efb02801611191acc4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/520b8a5a4dde032ba6118efb02801611191acc4e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf4cec79932de0a49338f6b87dc20f85dc3a509", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf4cec79932de0a49338f6b87dc20f85dc3a509", "html_url": "https://github.com/rust-lang/rust/commit/3bf4cec79932de0a49338f6b87dc20f85dc3a509"}, {"sha": "40cd6cdf67dcfad89a80ff3a662bec2dfd983d67", "url": "https://api.github.com/repos/rust-lang/rust/commits/40cd6cdf67dcfad89a80ff3a662bec2dfd983d67", "html_url": "https://github.com/rust-lang/rust/commit/40cd6cdf67dcfad89a80ff3a662bec2dfd983d67"}], "stats": {"total": 464, "additions": 239, "deletions": 225}, "files": [{"sha": "f9a62b9facd54e722696517ed4773c93891c7d50", "filename": "crates/assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fassists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fassists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -196,7 +196,7 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::Variant) -> Optio\n     let path = mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var))?);\n \n     // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n-    let pat: ast::Pat = match var.source(db).value.kind() {\n+    let pat: ast::Pat = match var.source(db)?.value.kind() {\n         ast::StructKind::Tuple(field_list) => {\n             let pats = iter::repeat(make::wildcard_pat().into()).take(field_list.fields().count());\n             make::tuple_struct_pat(path, pats).into()"}, {"sha": "de1e8f0bfa6e5fc1543955a07f72d38699c084d0", "filename": "crates/assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fassists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fassists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -97,7 +97,8 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) ->\n     let parent_name = parent.name(ctx.db());\n     let target_module = parent.module(ctx.db());\n \n-    let in_file_source = record_field_def.source(ctx.db());\n+    #[allow(deprecated)]\n+    let in_file_source = record_field_def.source(ctx.db())?;\n     let (offset, current_visibility, target) = match in_file_source.value {\n         hir::FieldSource::Named(it) => {\n             let s = it.syntax();\n@@ -145,53 +146,53 @@ fn target_data_for_def(\n     fn offset_target_and_file_id<S, Ast>(\n         db: &dyn HirDatabase,\n         x: S,\n-    ) -> (TextSize, Option<ast::Visibility>, TextRange, FileId)\n+    ) -> Option<(TextSize, Option<ast::Visibility>, TextRange, FileId)>\n     where\n         S: HasSource<Ast = Ast>,\n         Ast: AstNode + ast::VisibilityOwner,\n     {\n-        let source = x.source(db);\n+        let source = x.source(db)?;\n         let in_file_syntax = source.syntax();\n         let file_id = in_file_syntax.file_id;\n         let syntax = in_file_syntax.value;\n         let current_visibility = source.value.visibility();\n-        (\n+        Some((\n             vis_offset(syntax),\n             current_visibility,\n             syntax.text_range(),\n             file_id.original_file(db.upcast()),\n-        )\n+        ))\n     }\n \n     let target_name;\n     let (offset, current_visibility, target, target_file) = match def {\n         hir::ModuleDef::Function(f) => {\n             target_name = Some(f.name(db));\n-            offset_target_and_file_id(db, f)\n+            offset_target_and_file_id(db, f)?\n         }\n         hir::ModuleDef::Adt(adt) => {\n             target_name = Some(adt.name(db));\n             match adt {\n-                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n-                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n-                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n+                hir::Adt::Struct(s) => offset_target_and_file_id(db, s)?,\n+                hir::Adt::Union(u) => offset_target_and_file_id(db, u)?,\n+                hir::Adt::Enum(e) => offset_target_and_file_id(db, e)?,\n             }\n         }\n         hir::ModuleDef::Const(c) => {\n             target_name = c.name(db);\n-            offset_target_and_file_id(db, c)\n+            offset_target_and_file_id(db, c)?\n         }\n         hir::ModuleDef::Static(s) => {\n             target_name = s.name(db);\n-            offset_target_and_file_id(db, s)\n+            offset_target_and_file_id(db, s)?\n         }\n         hir::ModuleDef::Trait(t) => {\n             target_name = Some(t.name(db));\n-            offset_target_and_file_id(db, t)\n+            offset_target_and_file_id(db, t)?\n         }\n         hir::ModuleDef::TypeAlias(t) => {\n             target_name = Some(t.name(db));\n-            offset_target_and_file_id(db, t)\n+            offset_target_and_file_id(db, t)?\n         }\n         hir::ModuleDef::Module(m) => {\n             target_name = m.name(db);"}, {"sha": "b055964465a6a3fedc38cb74db9591f0cfeafeec", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -98,10 +98,14 @@ pub fn filter_assoc_items(\n \n     items\n         .iter()\n-        .map(|i| match i {\n-            hir::AssocItem::Function(i) => ast::AssocItem::Fn(i.source(db).value),\n-            hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAlias(i.source(db).value),\n-            hir::AssocItem::Const(i) => ast::AssocItem::Const(i.source(db).value),\n+        // Note: This throws away items with no source.\n+        .filter_map(|i| {\n+            let item = match i {\n+                hir::AssocItem::Function(i) => ast::AssocItem::Fn(i.source(db)?.value),\n+                hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAlias(i.source(db)?.value),\n+                hir::AssocItem::Const(i) => ast::AssocItem::Const(i.source(db)?.value),\n+            };\n+            Some(item)\n         })\n         .filter(has_def_name)\n         .filter(|it| match it {"}, {"sha": "00c9e76f038e1871ccc3f2b86bc0623e3cf08fde", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -106,8 +106,9 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<String>,\n     ) {\n-        let item = render_fn(RenderContext::new(ctx), None, local_name, func);\n-        self.add(item)\n+        if let Some(item) = render_fn(RenderContext::new(ctx), None, local_name, func) {\n+            self.add(item)\n+        }\n     }\n \n     pub(crate) fn add_variant_pat("}, {"sha": "54bb897e9b784cc0e288d7bcb0523c779b0d8e74", "filename": "crates/completion/src/completions/trait_impl.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -156,19 +156,21 @@ fn add_function_impl(\n     };\n     let range = TextRange::new(fn_def_node.text_range().start(), ctx.source_range().end());\n \n-    let function_decl = function_declaration(&func.source(ctx.db).value);\n-    match ctx.config.snippet_cap {\n-        Some(cap) => {\n-            let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n-            builder.snippet_edit(cap, TextEdit::replace(range, snippet))\n-        }\n-        None => {\n-            let header = format!(\"{} {{\", function_decl);\n-            builder.text_edit(TextEdit::replace(range, header))\n+    if let Some(src) = func.source(ctx.db) {\n+        let function_decl = function_declaration(&src.value);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n+                builder.snippet_edit(cap, TextEdit::replace(range, snippet))\n+            }\n+            None => {\n+                let header = format!(\"{} {{\", function_decl);\n+                builder.text_edit(TextEdit::replace(range, header))\n+            }\n         }\n+        .kind(completion_kind)\n+        .add_to(acc);\n     }\n-    .kind(completion_kind)\n-    .add_to(acc);\n }\n \n fn add_type_alias_impl(\n@@ -200,16 +202,19 @@ fn add_const_impl(\n     let const_name = const_.name(ctx.db).map(|n| n.to_string());\n \n     if let Some(const_name) = const_name {\n-        let snippet = make_const_compl_syntax(&const_.source(ctx.db).value);\n-\n-        let range = TextRange::new(const_def_node.text_range().start(), ctx.source_range().end());\n-\n-        CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone())\n-            .text_edit(TextEdit::replace(range, snippet))\n-            .lookup_by(const_name)\n-            .kind(CompletionItemKind::Const)\n-            .set_documentation(const_.docs(ctx.db))\n-            .add_to(acc);\n+        if let Some(source) = const_.source(ctx.db) {\n+            let snippet = make_const_compl_syntax(&source.value);\n+\n+            let range =\n+                TextRange::new(const_def_node.text_range().start(), ctx.source_range().end());\n+\n+            CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone())\n+                .text_edit(TextEdit::replace(range, snippet))\n+                .lookup_by(const_name)\n+                .kind(CompletionItemKind::Const)\n+                .set_documentation(const_.docs(ctx.db))\n+                .add_to(acc);\n+        }\n     }\n }\n "}, {"sha": "ac0b2a5139ec4c8cfd9e0b3c11cf7e83abf5b8c9", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -157,8 +157,7 @@ impl<'a> Render<'a> {\n \n         let kind = match resolution {\n             ScopeDef::ModuleDef(Function(func)) => {\n-                let item = render_fn(self.ctx, import_to_add, Some(local_name), *func);\n-                return Some(item);\n+                return render_fn(self.ctx, import_to_add, Some(local_name), *func);\n             }\n             ScopeDef::ModuleDef(Variant(_))\n                 if self.ctx.completion.is_pat_binding_or_const"}, {"sha": "ce924f309526885c016b5f01a32b6109fc16411e", "filename": "crates/completion/src/render/const_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fconst_.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -15,7 +15,7 @@ pub(crate) fn render_const<'a>(\n     ctx: RenderContext<'a>,\n     const_: hir::Const,\n ) -> Option<CompletionItem> {\n-    ConstRender::new(ctx, const_).render()\n+    ConstRender::new(ctx, const_)?.render()\n }\n \n #[derive(Debug)]\n@@ -26,9 +26,9 @@ struct ConstRender<'a> {\n }\n \n impl<'a> ConstRender<'a> {\n-    fn new(ctx: RenderContext<'a>, const_: hir::Const) -> ConstRender<'a> {\n-        let ast_node = const_.source(ctx.db()).value;\n-        ConstRender { ctx, const_, ast_node }\n+    fn new(ctx: RenderContext<'a>, const_: hir::Const) -> Option<ConstRender<'a>> {\n+        let ast_node = const_.source(ctx.db())?.value;\n+        Some(ConstRender { ctx, const_, ast_node })\n     }\n \n     fn render(self) -> Option<CompletionItem> {"}, {"sha": "081be14f4eb3b31203a950683e5fc2a08661e4a2", "filename": "crates/completion/src/render/function.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -14,9 +14,9 @@ pub(crate) fn render_fn<'a>(\n     import_to_add: Option<ImportEdit>,\n     local_name: Option<String>,\n     fn_: hir::Function,\n-) -> CompletionItem {\n+) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_fn\");\n-    FunctionRender::new(ctx, local_name, fn_).render(import_to_add)\n+    Some(FunctionRender::new(ctx, local_name, fn_)?.render(import_to_add))\n }\n \n #[derive(Debug)]\n@@ -32,11 +32,11 @@ impl<'a> FunctionRender<'a> {\n         ctx: RenderContext<'a>,\n         local_name: Option<String>,\n         fn_: hir::Function,\n-    ) -> FunctionRender<'a> {\n+    ) -> Option<FunctionRender<'a>> {\n         let name = local_name.unwrap_or_else(|| fn_.name(ctx.db()).to_string());\n-        let ast_node = fn_.source(ctx.db()).value;\n+        let ast_node = fn_.source(ctx.db())?.value;\n \n-        FunctionRender { ctx, name, func: fn_, ast_node }\n+        Some(FunctionRender { ctx, name, func: fn_, ast_node })\n     }\n \n     fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {"}, {"sha": "6f4f9945c1985d59152d7ba26be3ec48a835cbcd", "filename": "crates/completion/src/render/macro_.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -39,20 +39,13 @@ impl<'a> MacroRender<'a> {\n     }\n \n     fn render(&self, import_to_add: Option<ImportEdit>) -> Option<CompletionItem> {\n-        // FIXME: Currently proc-macro do not have ast-node,\n-        // such that it does not have source\n-        // more discussion: https://github.com/rust-analyzer/rust-analyzer/issues/6913\n-        if self.macro_.is_proc_macro() {\n-            return None;\n-        }\n-\n         let mut builder =\n             CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), &self.label())\n                 .kind(CompletionItemKind::Macro)\n                 .set_documentation(self.docs.clone())\n                 .set_deprecated(self.ctx.is_deprecated(self.macro_))\n                 .add_import(import_to_add)\n-                .detail(self.detail());\n+                .set_detail(self.detail());\n \n         let needs_bang = self.needs_bang();\n         builder = match self.ctx.snippet_cap() {\n@@ -95,9 +88,9 @@ impl<'a> MacroRender<'a> {\n         format!(\"{}!\", self.name)\n     }\n \n-    fn detail(&self) -> String {\n-        let ast_node = self.macro_.source(self.ctx.db()).value;\n-        macro_label(&ast_node)\n+    fn detail(&self) -> Option<String> {\n+        let ast_node = self.macro_.source(self.ctx.db())?.value;\n+        Some(macro_label(&ast_node))\n     }\n }\n "}, {"sha": "69b445b9c69de6793e0f3b817e1f73746b9cbe1f", "filename": "crates/completion/src/render/type_alias.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fcompletion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Ftype_alias.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -15,7 +15,7 @@ pub(crate) fn render_type_alias<'a>(\n     ctx: RenderContext<'a>,\n     type_alias: hir::TypeAlias,\n ) -> Option<CompletionItem> {\n-    TypeAliasRender::new(ctx, type_alias).render()\n+    TypeAliasRender::new(ctx, type_alias)?.render()\n }\n \n #[derive(Debug)]\n@@ -26,9 +26,9 @@ struct TypeAliasRender<'a> {\n }\n \n impl<'a> TypeAliasRender<'a> {\n-    fn new(ctx: RenderContext<'a>, type_alias: hir::TypeAlias) -> TypeAliasRender<'a> {\n-        let ast_node = type_alias.source(ctx.db()).value;\n-        TypeAliasRender { ctx, type_alias, ast_node }\n+    fn new(ctx: RenderContext<'a>, type_alias: hir::TypeAlias) -> Option<TypeAliasRender<'a>> {\n+        let ast_node = type_alias.source(ctx.db())?.value;\n+        Some(TypeAliasRender { ctx, type_alias, ast_node })\n     }\n \n     fn render(self) -> Option<CompletionItem> {"}, {"sha": "3c83231cf1c32d8a4ab3cbc83670fa0f919714cd", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -983,13 +983,7 @@ impl MacroDef {\n \n     /// XXX: this parses the file\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        // FIXME: Currently proc-macro do not have ast-node,\n-        // such that it does not have source\n-        // more discussion: https://github.com/rust-analyzer/rust-analyzer/issues/6913\n-        if self.is_proc_macro() {\n-            return None;\n-        }\n-        self.source(db).value.name().map(|it| it.as_name())\n+        self.source(db)?.value.name().map(|it| it.as_name())\n     }\n \n     /// Indicate it is a proc-macro\n@@ -1378,7 +1372,7 @@ impl Impl {\n     }\n \n     pub fn is_builtin_derive(self, db: &dyn HirDatabase) -> Option<InFile<ast::Attr>> {\n-        let src = self.source(db);\n+        let src = self.source(db)?;\n         let item = src.file_id.is_builtin_derive(db.upcast())?;\n         let hygenic = hir_expand::hygiene::Hygiene::new(db.upcast(), item.file_id);\n "}, {"sha": "7c57d8378cca66722795f3ec81bf9c93428884e1", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -16,7 +16,7 @@ use crate::{\n \n pub trait HasSource {\n     type Ast;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<Self::Ast>;\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>>;\n }\n \n /// NB: Module is !HasSource, because it has two source nodes at the same time:\n@@ -46,105 +46,104 @@ impl Module {\n \n impl HasSource for Field {\n     type Ast = FieldSource;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<FieldSource> {\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n         let var = VariantId::from(self.parent);\n         let src = var.child_source(db.upcast());\n-        src.map(|it| match it[self.id].clone() {\n+        let field_source = src.map(|it| match it[self.id].clone() {\n             Either::Left(it) => FieldSource::Pos(it),\n             Either::Right(it) => FieldSource::Named(it),\n-        })\n+        });\n+        Some(field_source)\n     }\n }\n impl HasSource for Struct {\n     type Ast = ast::Struct;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Struct> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for Union {\n     type Ast = ast::Union;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Union> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for Enum {\n     type Ast = ast::Enum;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Enum> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for Variant {\n     type Ast = ast::Variant;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Variant> {\n-        self.parent.id.child_source(db.upcast()).map(|map| map[self.id].clone())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<ast::Variant>> {\n+        Some(self.parent.id.child_source(db.upcast()).map(|map| map[self.id].clone()))\n     }\n }\n impl HasSource for Function {\n     type Ast = ast::Fn;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Fn> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for Const {\n     type Ast = ast::Const;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Const> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for Static {\n     type Ast = ast::Static;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Static> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for Trait {\n     type Ast = ast::Trait;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Trait> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for TypeAlias {\n     type Ast = ast::TypeAlias;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::TypeAlias> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n impl HasSource for MacroDef {\n     type Ast = ast::Macro;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Macro> {\n-        InFile {\n-            file_id: self.id.ast_id.expect(\"MacroDef without ast_id\").file_id,\n-            value: self.id.ast_id.expect(\"MacroDef without ast_id\").to_node(db.upcast()),\n-        }\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        let ast_id = self.id.ast_id?;\n+        Some(InFile { file_id: ast_id.file_id, value: ast_id.to_node(db.upcast()) })\n     }\n }\n impl HasSource for Impl {\n     type Ast = ast::Impl;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Impl> {\n-        self.id.lookup(db.upcast()).source(db.upcast())\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n \n impl HasSource for TypeParam {\n     type Ast = Either<ast::Trait, ast::TypeParam>;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<Self::Ast> {\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n         let child_source = self.id.parent.child_source(db.upcast());\n-        child_source.map(|it| it[self.id.local_id].clone())\n+        Some(child_source.map(|it| it[self.id.local_id].clone()))\n     }\n }\n \n impl HasSource for LifetimeParam {\n     type Ast = ast::LifetimeParam;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<Self::Ast> {\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n         let child_source = self.id.parent.child_source(db.upcast());\n-        child_source.map(|it| it[self.id.local_id].clone())\n+        Some(child_source.map(|it| it[self.id.local_id].clone()))\n     }\n }\n \n impl HasSource for ConstParam {\n     type Ast = ast::ConstParam;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<Self::Ast> {\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n         let child_source = self.id.parent.child_source(db.upcast());\n-        child_source.map(|it| it[self.id.local_id].clone())\n+        Some(child_source.map(|it| it[self.id.local_id].clone()))\n     }\n }"}, {"sha": "3c2d39f5dfb8890c8fc4cc4db9b5e5c4cfb106e8", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -8,7 +8,7 @@ use ide_db::RootDatabase;\n use syntax::{ast, match_ast, AstNode, TextRange};\n \n use crate::{\n-    display::ToNav, goto_definition, references, FilePosition, NavigationTarget, RangeInfo,\n+    display::TryToNav, goto_definition, references, FilePosition, NavigationTarget, RangeInfo,\n };\n \n #[derive(Debug, Clone)]\n@@ -61,7 +61,7 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n                 match node {\n                     ast::Fn(it) => {\n                         let def = sema.to_def(&it)?;\n-                        Some(def.to_nav(sema.db))\n+                        def.try_to_nav(sema.db)\n                     },\n                     _ => None,\n                 }\n@@ -99,15 +99,15 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n                     match callable.kind() {\n                         hir::CallableKind::Function(it) => {\n                             let fn_def: hir::Function = it.into();\n-                            let nav = fn_def.to_nav(db);\n+                            let nav = fn_def.try_to_nav(db)?;\n                             Some(nav)\n                         }\n                         _ => None,\n                     }\n                 }\n                 FnCallNode::MethodCallExpr(expr) => {\n                     let function = sema.resolve_method_call(&expr)?;\n-                    Some(function.to_nav(db))\n+                    function.try_to_nav(db)\n                 }\n             } {\n                 Some((func_target, name_ref.syntax().text_range()))"}, {"sha": "ec0f840e9d726550f3dd9c1c647c0f375c32a917", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -156,20 +156,23 @@ fn missing_record_expr_field_fix(\n     let record_fields = match VariantDef::from(def_id) {\n         VariantDef::Struct(s) => {\n             module = s.module(sema.db);\n-            let source = s.source(sema.db);\n+            #[allow(deprecated)]\n+            let source = s.source(sema.db)?;\n             def_file_id = source.file_id;\n             let fields = source.value.field_list()?;\n             record_field_list(fields)?\n         }\n         VariantDef::Union(u) => {\n             module = u.module(sema.db);\n-            let source = u.source(sema.db);\n+            #[allow(deprecated)]\n+            let source = u.source(sema.db)?;\n             def_file_id = source.file_id;\n             source.value.record_field_list()?\n         }\n         VariantDef::Variant(e) => {\n             module = e.module(sema.db);\n-            let source = e.source(sema.db);\n+            #[allow(deprecated)]\n+            let source = e.source(sema.db)?;\n             def_file_id = source.file_id;\n             let fields = source.value.field_list()?;\n             record_field_list(fields)?"}, {"sha": "e24c78301767e49eb2a1139ef7e5edce52fdecc4", "filename": "crates/ide/src/display/navigation_target.rs", "status": "modified", "additions": 61, "deletions": 69, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -210,41 +210,32 @@ impl ToNav for FileSymbol {\n impl TryToNav for Definition {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n         match self {\n-            Definition::Macro(it) => {\n-                // FIXME: Currently proc-macro do not have ast-node,\n-                // such that it does not have source\n-                // more discussion: https://github.com/rust-analyzer/rust-analyzer/issues/6913\n-                if it.is_proc_macro() {\n-                    return None;\n-                }\n-                Some(it.to_nav(db))\n-            }\n-            Definition::Field(it) => Some(it.to_nav(db)),\n+            Definition::Macro(it) => it.try_to_nav(db),\n+            Definition::Field(it) => it.try_to_nav(db),\n             Definition::ModuleDef(it) => it.try_to_nav(db),\n-            Definition::SelfType(it) => Some(it.to_nav(db)),\n+            Definition::SelfType(it) => it.try_to_nav(db),\n             Definition::Local(it) => Some(it.to_nav(db)),\n-            Definition::TypeParam(it) => Some(it.to_nav(db)),\n-            Definition::LifetimeParam(it) => Some(it.to_nav(db)),\n+            Definition::TypeParam(it) => it.try_to_nav(db),\n+            Definition::LifetimeParam(it) => it.try_to_nav(db),\n             Definition::Label(it) => Some(it.to_nav(db)),\n-            Definition::ConstParam(it) => Some(it.to_nav(db)),\n+            Definition::ConstParam(it) => it.try_to_nav(db),\n         }\n     }\n }\n \n impl TryToNav for hir::ModuleDef {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n-        let res = match self {\n-            hir::ModuleDef::Module(it) => it.to_nav(db),\n-            hir::ModuleDef::Function(it) => it.to_nav(db),\n-            hir::ModuleDef::Adt(it) => it.to_nav(db),\n-            hir::ModuleDef::Variant(it) => it.to_nav(db),\n-            hir::ModuleDef::Const(it) => it.to_nav(db),\n-            hir::ModuleDef::Static(it) => it.to_nav(db),\n-            hir::ModuleDef::Trait(it) => it.to_nav(db),\n-            hir::ModuleDef::TypeAlias(it) => it.to_nav(db),\n-            hir::ModuleDef::BuiltinType(_) => return None,\n-        };\n-        Some(res)\n+        match self {\n+            hir::ModuleDef::Module(it) => Some(it.to_nav(db)),\n+            hir::ModuleDef::Function(it) => it.try_to_nav(db),\n+            hir::ModuleDef::Adt(it) => it.try_to_nav(db),\n+            hir::ModuleDef::Variant(it) => it.try_to_nav(db),\n+            hir::ModuleDef::Const(it) => it.try_to_nav(db),\n+            hir::ModuleDef::Static(it) => it.try_to_nav(db),\n+            hir::ModuleDef::Trait(it) => it.try_to_nav(db),\n+            hir::ModuleDef::TypeAlias(it) => it.try_to_nav(db),\n+            hir::ModuleDef::BuiltinType(_) => None,\n+        }\n     }\n }\n \n@@ -279,21 +270,21 @@ impl ToNavFromAst for hir::Trait {\n     const KIND: SymbolKind = SymbolKind::Trait;\n }\n \n-impl<D> ToNav for D\n+impl<D> TryToNav for D\n where\n     D: HasSource + ToNavFromAst + Copy + HasAttrs,\n     D::Ast: ast::NameOwner + ShortLabel,\n {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let src = self.source(db);\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let src = self.source(db)?;\n         let mut res = NavigationTarget::from_named(\n             db,\n             src.as_ref().map(|it| it as &dyn ast::NameOwner),\n             D::KIND,\n         );\n         res.docs = self.docs(db);\n         res.description = src.value.short_label();\n-        res\n+        Some(res)\n     }\n }\n \n@@ -312,9 +303,9 @@ impl ToNav for hir::Module {\n     }\n }\n \n-impl ToNav for hir::Impl {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let src = self.source(db);\n+impl TryToNav for hir::Impl {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let src = self.source(db)?;\n         let derive_attr = self.is_builtin_derive(db);\n         let frange = if let Some(item) = &derive_attr {\n             item.syntax().original_file_range(db)\n@@ -327,21 +318,21 @@ impl ToNav for hir::Impl {\n             src.value.self_ty().map(|ty| src.with_value(ty.syntax()).original_file_range(db).range)\n         };\n \n-        NavigationTarget::from_syntax(\n+        Some(NavigationTarget::from_syntax(\n             frange.file_id,\n             \"impl\".into(),\n             focus_range,\n             frange.range,\n             SymbolKind::Impl,\n-        )\n+        ))\n     }\n }\n \n-impl ToNav for hir::Field {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let src = self.source(db);\n+impl TryToNav for hir::Field {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let src = self.source(db)?;\n \n-        match &src.value {\n+        let field_source = match &src.value {\n             FieldSource::Named(it) => {\n                 let mut res =\n                     NavigationTarget::from_named(db, src.with_value(it), SymbolKind::Field);\n@@ -359,40 +350,41 @@ impl ToNav for hir::Field {\n                     SymbolKind::Field,\n                 )\n             }\n-        }\n+        };\n+        Some(field_source)\n     }\n }\n \n-impl ToNav for hir::MacroDef {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let src = self.source(db);\n+impl TryToNav for hir::MacroDef {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let src = self.source(db)?;\n         log::debug!(\"nav target {:#?}\", src.value.syntax());\n         let mut res = NavigationTarget::from_named(\n             db,\n             src.as_ref().map(|it| it as &dyn ast::NameOwner),\n             SymbolKind::Macro,\n         );\n         res.docs = self.docs(db);\n-        res\n+        Some(res)\n     }\n }\n \n-impl ToNav for hir::Adt {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+impl TryToNav for hir::Adt {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n         match self {\n-            hir::Adt::Struct(it) => it.to_nav(db),\n-            hir::Adt::Union(it) => it.to_nav(db),\n-            hir::Adt::Enum(it) => it.to_nav(db),\n+            hir::Adt::Struct(it) => it.try_to_nav(db),\n+            hir::Adt::Union(it) => it.try_to_nav(db),\n+            hir::Adt::Enum(it) => it.try_to_nav(db),\n         }\n     }\n }\n \n-impl ToNav for hir::AssocItem {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+impl TryToNav for hir::AssocItem {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n         match self {\n-            AssocItem::Function(it) => it.to_nav(db),\n-            AssocItem::Const(it) => it.to_nav(db),\n-            AssocItem::TypeAlias(it) => it.to_nav(db),\n+            AssocItem::Function(it) => it.try_to_nav(db),\n+            AssocItem::Const(it) => it.try_to_nav(db),\n+            AssocItem::TypeAlias(it) => it.try_to_nav(db),\n         }\n     }\n }\n@@ -446,9 +438,9 @@ impl ToNav for hir::Label {\n     }\n }\n \n-impl ToNav for hir::TypeParam {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let src = self.source(db);\n+impl TryToNav for hir::TypeParam {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let src = self.source(db)?;\n         let full_range = match &src.value {\n             Either::Left(it) => it.syntax().text_range(),\n             Either::Right(it) => it.syntax().text_range(),\n@@ -457,7 +449,7 @@ impl ToNav for hir::TypeParam {\n             Either::Left(_) => None,\n             Either::Right(it) => it.name().map(|it| it.syntax().text_range()),\n         };\n-        NavigationTarget {\n+        Some(NavigationTarget {\n             file_id: src.file_id.original_file(db),\n             name: self.name(db).to_string().into(),\n             kind: Some(SymbolKind::TypeParam),\n@@ -466,15 +458,15 @@ impl ToNav for hir::TypeParam {\n             container_name: None,\n             description: None,\n             docs: None,\n-        }\n+        })\n     }\n }\n \n-impl ToNav for hir::LifetimeParam {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let src = self.source(db);\n+impl TryToNav for hir::LifetimeParam {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let src = self.source(db)?;\n         let full_range = src.value.syntax().text_range();\n-        NavigationTarget {\n+        Some(NavigationTarget {\n             file_id: src.file_id.original_file(db),\n             name: self.name(db).to_string().into(),\n             kind: Some(SymbolKind::LifetimeParam),\n@@ -483,15 +475,15 @@ impl ToNav for hir::LifetimeParam {\n             container_name: None,\n             description: None,\n             docs: None,\n-        }\n+        })\n     }\n }\n \n-impl ToNav for hir::ConstParam {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let src = self.source(db);\n+impl TryToNav for hir::ConstParam {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let src = self.source(db)?;\n         let full_range = src.value.syntax().text_range();\n-        NavigationTarget {\n+        Some(NavigationTarget {\n             file_id: src.file_id.original_file(db),\n             name: self.name(db).to_string().into(),\n             kind: Some(SymbolKind::ConstParam),\n@@ -500,7 +492,7 @@ impl ToNav for hir::ConstParam {\n             container_name: None,\n             description: None,\n             docs: None,\n-        }\n+        })\n     }\n }\n "}, {"sha": "da9378a97e638870d558ed792cd7f629157398e9", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -2,7 +2,7 @@ use hir::{Crate, Impl, Semantics};\n use ide_db::RootDatabase;\n use syntax::{algo::find_node_at_offset, ast, AstNode};\n \n-use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n+use crate::{display::TryToNav, FilePosition, NavigationTarget, RangeInfo};\n \n // Feature: Go to Implementation\n //\n@@ -55,7 +55,7 @@ fn impls_for_def(\n         impls\n             .into_iter()\n             .filter(|impl_def| ty.is_equal_for_find_impls(&impl_def.target_ty(sema.db)))\n-            .map(|imp| imp.to_nav(sema.db))\n+            .filter_map(|imp| imp.try_to_nav(sema.db))\n             .collect(),\n     )\n }\n@@ -69,7 +69,7 @@ fn impls_for_trait(\n \n     let impls = Impl::for_trait(sema.db, krate, tr);\n \n-    Some(impls.into_iter().map(|imp| imp.to_nav(sema.db)).collect())\n+    Some(impls.into_iter().filter_map(|imp| imp.try_to_nav(sema.db)).collect())\n }\n \n #[cfg(test)]"}, {"sha": "7e84e06bea4d1ebef035f0bda438a3f12febf0c7", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -1,7 +1,7 @@\n use ide_db::RootDatabase;\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n-use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n+use crate::{display::TryToNav, FilePosition, NavigationTarget, RangeInfo};\n \n // Feature: Go to Type Definition\n //\n@@ -37,7 +37,7 @@ pub(crate) fn goto_type_definition(\n \n     let adt_def = ty.autoderef(db).filter_map(|ty| ty.as_adt()).last()?;\n \n-    let nav = adt_def.to_nav(db);\n+    let nav = adt_def.try_to_nav(db)?;\n     Some(RangeInfo::new(node.text_range(), vec![nav]))\n }\n "}, {"sha": "2737c900f4c9f55664de0255bf729819dcb8f5ff", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -13,7 +13,7 @@ use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset,\n use test_utils::mark;\n \n use crate::{\n-    display::{macro_label, ShortLabel, ToNav, TryToNav},\n+    display::{macro_label, ShortLabel, TryToNav},\n     doc_links::{remove_links, rewrite_links},\n     markdown_remove::remove_markdown,\n     markup::Markup,\n@@ -183,10 +183,10 @@ fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<Hov\n \n     match def {\n         Definition::ModuleDef(it) => match it {\n-            ModuleDef::Adt(Adt::Struct(it)) => Some(to_action(it.to_nav(db))),\n-            ModuleDef::Adt(Adt::Union(it)) => Some(to_action(it.to_nav(db))),\n-            ModuleDef::Adt(Adt::Enum(it)) => Some(to_action(it.to_nav(db))),\n-            ModuleDef::Trait(it) => Some(to_action(it.to_nav(db))),\n+            ModuleDef::Adt(Adt::Struct(it)) => Some(to_action(it.try_to_nav(db)?)),\n+            ModuleDef::Adt(Adt::Union(it)) => Some(to_action(it.try_to_nav(db)?)),\n+            ModuleDef::Adt(Adt::Enum(it)) => Some(to_action(it.try_to_nav(db)?)),\n+            ModuleDef::Trait(it) => Some(to_action(it.try_to_nav(db)?)),\n             _ => None,\n         },\n         _ => None,\n@@ -206,7 +206,8 @@ fn runnable_action(\n                 _ => None,\n             },\n             ModuleDef::Function(it) => {\n-                let src = it.source(sema.db);\n+                #[allow(deprecated)]\n+                let src = it.source(sema.db)?;\n                 if src.file_id != file_id.into() {\n                     mark::hit!(hover_macro_generated_struct_fn_doc_comment);\n                     mark::hit!(hover_macro_generated_struct_fn_doc_attr);\n@@ -326,17 +327,12 @@ fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n     let mod_path = definition_mod_path(db, &def);\n     return match def {\n         Definition::Macro(it) => {\n-            // FIXME: Currently proc-macro do not have ast-node,\n-            // such that it does not have source\n-            // more discussion: https://github.com/rust-analyzer/rust-analyzer/issues/6913\n-            if it.is_proc_macro() {\n-                return None;\n-            }\n-            let label = macro_label(&it.source(db).value);\n+            let label = macro_label(&it.source(db)?.value);\n             from_def_source_labeled(db, it, Some(label), mod_path)\n         }\n         Definition::Field(def) => {\n-            let src = def.source(db).value;\n+            #[allow(deprecated)]\n+            let src = def.source(db)?.value;\n             if let FieldSource::Named(it) = src {\n                 from_def_source_labeled(db, def, it.short_label(), mod_path)\n             } else {\n@@ -385,7 +381,8 @@ fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n         D: HasSource<Ast = A> + HasAttrs + Copy,\n         A: ShortLabel,\n     {\n-        let short_label = def.source(db).value.short_label();\n+        #[allow(deprecated)]\n+        let short_label = def.source(db)?.value.short_label();\n         from_def_source_labeled(db, def, short_label, mod_path)\n     }\n "}, {"sha": "436c59d2c7bfb0cd81d892ba987525babd7e0a11", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -121,31 +121,56 @@ impl Definition {\n \n         if let Definition::Local(var) = self {\n             let range = match var.parent(db) {\n-                DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n-                DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n-                DefWithBody::Static(s) => s.source(db).value.syntax().text_range(),\n+                DefWithBody::Function(f) => {\n+                    f.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n+                DefWithBody::Const(c) => {\n+                    c.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n+                DefWithBody::Static(s) => {\n+                    s.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n             };\n             let mut res = FxHashMap::default();\n-            res.insert(file_id, Some(range));\n+            res.insert(file_id, range);\n             return SearchScope::new(res);\n         }\n \n         if let Definition::LifetimeParam(param) = self {\n+            #[allow(deprecated)]\n             let range = match param.parent(db) {\n-                hir::GenericDef::Function(it) => it.source(db).value.syntax().text_range(),\n+                hir::GenericDef::Function(it) => {\n+                    it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n                 hir::GenericDef::Adt(it) => match it {\n-                    hir::Adt::Struct(it) => it.source(db).value.syntax().text_range(),\n-                    hir::Adt::Union(it) => it.source(db).value.syntax().text_range(),\n-                    hir::Adt::Enum(it) => it.source(db).value.syntax().text_range(),\n+                    hir::Adt::Struct(it) => {\n+                        it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                    }\n+                    hir::Adt::Union(it) => {\n+                        it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                    }\n+                    hir::Adt::Enum(it) => {\n+                        it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                    }\n                 },\n-                hir::GenericDef::Trait(it) => it.source(db).value.syntax().text_range(),\n-                hir::GenericDef::TypeAlias(it) => it.source(db).value.syntax().text_range(),\n-                hir::GenericDef::Impl(it) => it.source(db).value.syntax().text_range(),\n-                hir::GenericDef::Variant(it) => it.source(db).value.syntax().text_range(),\n-                hir::GenericDef::Const(it) => it.source(db).value.syntax().text_range(),\n+                hir::GenericDef::Trait(it) => {\n+                    it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n+                hir::GenericDef::TypeAlias(it) => {\n+                    it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n+                hir::GenericDef::Impl(it) => {\n+                    it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n+                hir::GenericDef::Variant(it) => {\n+                    it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n+                hir::GenericDef::Const(it) => {\n+                    it.source(db).and_then(|src| Some(src.value.syntax().text_range()))\n+                }\n             };\n             let mut res = FxHashMap::default();\n-            res.insert(file_id, Some(range));\n+            res.insert(file_id, range);\n             return SearchScope::new(res);\n         }\n "}, {"sha": "9445aec074d411294abde492eb5589e526d2a511", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b8a5a4dde032ba6118efb02801611191acc4e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=520b8a5a4dde032ba6118efb02801611191acc4e", "patch": "@@ -161,11 +161,12 @@ impl AnalysisStatsCmd {\n             }\n             let mut msg = format!(\"processing: {}\", full_name);\n             if verbosity.is_verbose() {\n-                let src = f.source(db);\n-                let original_file = src.file_id.original_file(db);\n-                let path = vfs.file_path(original_file);\n-                let syntax_range = src.value.syntax().text_range();\n-                format_to!(msg, \" ({} {:?})\", path, syntax_range);\n+                if let Some(src) = f.source(db) {\n+                    let original_file = src.file_id.original_file(db);\n+                    let path = vfs.file_path(original_file);\n+                    let syntax_range = src.value.syntax().text_range();\n+                    format_to!(msg, \" ({} {:?})\", path, syntax_range);\n+                }\n             }\n             if verbosity.is_spammy() {\n                 bar.println(msg.to_string());"}]}