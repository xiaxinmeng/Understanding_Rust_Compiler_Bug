{"sha": "5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MjhkNDlhYTAxYmQzYWI0ZjFkMDdmMmRlYTNiNjUxNmYxZjAzODE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-19T15:51:07Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-19T15:51:07Z"}, "message": "Rollup merge of #33721 - royalstream:royalstream-doc-highlights, r=Manishearth\n\nRust syntax coloring for some ignore, should-panic and no-run snippets.\n\nIn the book, some code blocks were missing the `rust` specifier which is needed for them to highlight correctly.", "tree": {"sha": "93f13e22ad6c20ab0e4f1f800b4b068dc15adf61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93f13e22ad6c20ab0e4f1f800b4b068dc15adf61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "html_url": "https://github.com/rust-lang/rust/commit/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6f5cdfcecf776b9387ac9ab3062061c21279f23", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f5cdfcecf776b9387ac9ab3062061c21279f23", "html_url": "https://github.com/rust-lang/rust/commit/f6f5cdfcecf776b9387ac9ab3062061c21279f23"}, {"sha": "c9517189d7f0e851347859e437fc796411008e66", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9517189d7f0e851347859e437fc796411008e66", "html_url": "https://github.com/rust-lang/rust/commit/c9517189d7f0e851347859e437fc796411008e66"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "c8a9082947eea8ca4a9ae92973a25835c8214d19", "filename": "src/doc/book/advanced-linking.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fadvanced-linking.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fadvanced-linking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fadvanced-linking.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -12,7 +12,7 @@ the `link_args` attribute. This attribute is applied to `extern` blocks and\n specifies raw flags which need to get passed to the linker when producing an\n artifact. An example usage would be:\n \n-``` no_run\n+```rust,no_run\n #![feature(link_args)]\n \n #[link_args = \"-foo -bar -baz\"]\n@@ -52,7 +52,7 @@ By default, all Rust programs on Linux will link to the system `libc` along with\n a number of other libraries. Let's look at an example on a 64-bit Linux machine\n with GCC and `glibc` (by far the most common `libc` on Linux):\n \n-``` text\n+```text\n $ cat example.rs\n fn main() {}\n $ rustc example.rs"}, {"sha": "dedf9d5c28abd4d85ece1d4a13651ad3ac6c6dc8", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -391,7 +391,7 @@ assert_eq!(2, answer);\n In this example, we don\u2019t strictly need the intermediate variable `f`,\n the name of the function works just fine too:\n \n-```ignore\n+```rust,ignore\n let answer = call_with_one(&add_one);\n ```\n "}, {"sha": "2d0cc61fb11d67252755377599065b210f8b27b5", "filename": "src/doc/book/compiler-plugins.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcompiler-plugins.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -37,7 +37,7 @@ Let's write a plugin\n [`roman_numerals.rs`](https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs)\n that implements Roman numeral integer literals.\n \n-```ignore\n+```rust,ignore\n #![crate_type=\"dylib\"]\n #![feature(plugin_registrar, rustc_private)]\n \n@@ -102,7 +102,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n \n Then we can use `rn!()` like any other macro:\n \n-```ignore\n+```rust,ignore\n #![feature(plugin)]\n #![plugin(roman_numerals)]\n \n@@ -132,7 +132,7 @@ Some of the [macro debugging tips](macros.html#debugging-macro-code) are applica\n You can use `syntax::parse` to turn token trees into\n higher-level syntax elements like expressions:\n \n-```ignore\n+```rust,ignore\n fn expand_foo(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<MacResult+'static> {\n \n@@ -169,7 +169,7 @@ infrastructure](../reference.html#lint-check-attributes) with additional checks\n code style, safety, etc. Now let's write a plugin [`lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs)\n that warns about any item named `lintme`.\n \n-```ignore\n+```rust,ignore\n #![feature(plugin_registrar)]\n #![feature(box_syntax, rustc_private)]\n \n@@ -211,7 +211,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n \n Then code like\n \n-```ignore\n+```rust,ignore\n #![plugin(lint_plugin_test)]\n \n fn lintme() { }"}, {"sha": "a783650f8ea2df3b16f26be3876fc1e50c4324b5", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -165,7 +165,7 @@ concurrency bugs.\n As an example, here is a Rust program that would have a data race in many\n languages. It will not compile:\n \n-```ignore\n+```rust,ignore\n use std::thread;\n use std::time::Duration;\n \n@@ -204,7 +204,7 @@ Calling `clone()` on an `Rc<T>` will return a new owned reference and bump the\n internal reference count. We create one of these for each thread:\n \n \n-```ignore\n+```rust,ignore\n use std::thread;\n use std::time::Duration;\n use std::rc::Rc;\n@@ -250,7 +250,7 @@ In essence, `Arc<T>` is a type that lets us share ownership of data _across\n threads_.\n \n \n-```ignore\n+```rust,ignore\n use std::thread;\n use std::sync::Arc;\n use std::time::Duration;\n@@ -336,7 +336,7 @@ The lock \"release\" here is implicit; when the result of the lock (in this case,\n Note that [`lock`](../std/sync/struct.Mutex.html#method.lock) method of\n [`Mutex`](../std/sync/struct.Mutex.html) has this signature:\n \n-```ignore\n+```rust,ignore\n fn lock(&self) -> LockResult<MutexGuard<T>>\n ```\n "}, {"sha": "4a41bb7b7f37eee595870bb26f5680de4122587b", "filename": "src/doc/book/documentation.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdocumentation.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -362,7 +362,7 @@ Here\u2019s an example of documenting a macro:\n /// # }\n /// ```\n ///\n-/// ```should_panic\n+/// ```rust,should_panic\n /// # #[macro_use] extern crate foo;\n /// # fn main() {\n /// panic_unless!(true == false, \u201cI\u2019m broken.\u201d);\n@@ -429,7 +429,7 @@ There are a few more annotations that are useful to help `rustdoc` do the right\n thing when testing your code:\n \n ```rust\n-/// ```ignore\n+/// ```rust,ignore\n /// fn foo() {\n /// ```\n # fn foo() {}\n@@ -441,7 +441,7 @@ with `text` if it's not code, or using `#`s to get a working example that\n only shows the part you care about.\n \n ```rust\n-/// ```should_panic\n+/// ```rust,should_panic\n /// assert!(false);\n /// ```\n # fn foo() {}\n@@ -451,7 +451,7 @@ only shows the part you care about.\n not actually pass as a test.\n \n ```rust\n-/// ```no_run\n+/// ```rust,no_run\n /// loop {\n ///     println!(\"Hello, world\");\n /// }\n@@ -563,7 +563,7 @@ can be useful when changing some options, or when writing a macro.\n \n `rustdoc` will show the documentation for a public re-export in both places:\n \n-```ignore\n+```rust,ignore\n extern crate foo;\n \n pub use foo::bar;\n@@ -575,7 +575,7 @@ documentation in both places.\n \n This behavior can be suppressed with `no_inline`:\n \n-```ignore\n+```rust,ignore\n extern crate foo;\n \n #[doc(no_inline)]"}, {"sha": "f48e87c42245eca39af7b28289b20903f6c5369a", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -28,7 +28,7 @@ and add `extern crate libc;` to your crate root.\n The following is a minimal example of calling a foreign function which will\n compile if snappy is installed:\n \n-```no_run\n+```rust,no_run\n # #![feature(libc)]\n extern crate libc;\n use libc::size_t;\n@@ -62,7 +62,7 @@ keeping the binding correct at runtime.\n \n The `extern` block can be extended to cover the entire snappy API:\n \n-```no_run\n+```rust,no_run\n # #![feature(libc)]\n extern crate libc;\n use libc::{c_int, size_t};\n@@ -209,7 +209,7 @@ A basic example is:\n \n Rust code:\n \n-```no_run\n+```rust,no_run\n extern fn callback(a: i32) {\n     println!(\"I'm called from C with value {0}\", a);\n }\n@@ -262,7 +262,7 @@ referenced Rust object.\n \n Rust code:\n \n-```no_run\n+```rust,no_run\n #[repr(C)]\n struct RustObject {\n     a: i32,\n@@ -406,7 +406,7 @@ Foreign APIs often export a global variable which could do something like track\n global state. In order to access these variables, you declare them in `extern`\n blocks with the `static` keyword:\n \n-```no_run\n+```rust,no_run\n # #![feature(libc)]\n extern crate libc;\n \n@@ -425,7 +425,7 @@ Alternatively, you may need to alter global state provided by a foreign\n interface. To do this, statics can be declared with `mut` so we can mutate\n them.\n \n-```no_run\n+```rust,no_run\n # #![feature(libc)]\n extern crate libc;\n "}, {"sha": "3a10d2aecc25e3e3fbe364f50759629c50887ad0", "filename": "src/doc/book/functions.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ffunctions.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -134,7 +134,7 @@ x = y = 5\n In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n following will produce a compile-time error:\n \n-```ignore\n+```rust,ignore\n let x = (let y = 5); // expected identifier, found keyword `let`\n ```\n \n@@ -283,7 +283,7 @@ stack backtrace:\n \n A diverging function can be used as any type:\n \n-```should_panic\n+```rust,should_panic\n # fn diverges() -> ! {\n #    panic!(\"This function never returns!\");\n # }"}, {"sha": "2c2d89a1fbf9ed3b46c881a19c0108fde7fd2217", "filename": "src/doc/book/inline-assembly.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Finline-assembly.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -4,7 +4,7 @@ For extremely low-level manipulations and performance reasons, one\n might wish to control the CPU directly. Rust supports using inline\n assembly to do this via the `asm!` macro.\n \n-```ignore\n+```rust,ignore\n asm!(assembly template\n    : output operands\n    : input operands"}, {"sha": "97ca2e3e702f6cf926e54e88679beb1eff7dfe1a", "filename": "src/doc/book/loops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Floops.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -74,7 +74,7 @@ for x in 0..10 {\n \n In slightly more abstract terms,\n \n-```ignore\n+```rust,ignore\n for var in expression {\n     code\n }"}, {"sha": "f535fb96af89559131219cbde594a58218e50cd3", "filename": "src/doc/book/macros.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmacros.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -78,7 +78,7 @@ macro_rules! vec {\n \n Whoa, that\u2019s a lot of new syntax! Let\u2019s break it down.\n \n-```ignore\n+```rust,ignore\n macro_rules! vec { ... }\n ```\n \n@@ -92,7 +92,7 @@ syntax and serves to distinguish a macro from an ordinary function.\n The macro is defined through a series of rules, which are pattern-matching\n cases. Above, we had\n \n-```ignore\n+```rust,ignore\n ( $( $x:expr ),* ) => { ... };\n ```\n \n@@ -112,7 +112,7 @@ separated by commas.\n Aside from the special matcher syntax, any Rust tokens that appear in a matcher\n must match exactly. For example,\n \n-```rust\n+```rust,ignore\n macro_rules! foo {\n     (x => $e:expr) => (println!(\"mode X: {}\", $e));\n     (y => $e:expr) => (println!(\"mode Y: {}\", $e));\n@@ -147,7 +147,7 @@ The right-hand side of a macro rule is ordinary Rust syntax, for the most part.\n But we can splice in bits of syntax captured by the matcher. From the original\n example:\n \n-```ignore\n+```rust,ignore\n $(\n     temp_vec.push($x);\n )*\n@@ -165,7 +165,7 @@ within the repeated block.\n Another detail: the `vec!` macro has *two* pairs of braces on the right-hand\n side. They are often combined like so:\n \n-```ignore\n+```rust,ignore\n macro_rules! foo {\n     () => {{\n         ..."}, {"sha": "424e2cda6157d0609a876f7d8329c8378e729957", "filename": "src/doc/book/operators-and-overloading.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Foperators-and-overloading.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -123,7 +123,7 @@ fn main() {\n For `HasArea` and `Square`, we declare a type parameter `T` and replace\n `f64` with it. The `impl` needs more involved modifications:\n \n-```ignore\n+```rust,ignore\n impl<T> HasArea<T> for Square<T>\n         where T: Mul<Output=T> + Copy { ... }\n ```"}, {"sha": "b31a34a0425a489f246f2616b499a93cf4f8c918", "filename": "src/doc/book/trait-objects.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftrait-objects.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -306,7 +306,7 @@ let y = TraitObject {\n Not every trait can be used to make a trait object. For example, vectors implement\n `Clone`, but if we try to make a trait object:\n \n-```ignore\n+```rust,ignore\n let v = vec![1, 2, 3];\n let o = &v as &Clone;\n ```"}, {"sha": "107ef2b44d5eb07017ba08455f553239bf2e26eb", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -195,7 +195,7 @@ fn main() {\n `is_square()` needs to check that the sides are equal, so the sides must be of\n a type that implements the [`core::cmp::PartialEq`][PartialEq] trait:\n \n-```ignore\n+```rust,ignore\n impl<T: PartialEq> Rectangle<T> { ... }\n ```\n "}, {"sha": "1c44af2f21a7198db6ff597fca3bec4188a27b85", "filename": "src/doc/book/vectors.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381/src%2Fdoc%2Fbook%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvectors.md?ref=5928d49aa01bd3ab4f1d07f2dea3b6516f1f0381", "patch": "@@ -40,7 +40,7 @@ The indices count from `0`, so the third element is `v[2]`.\n \n It\u2019s also important to note that you must index with the `usize` type:\n \n-```ignore\n+```rust,ignore\n let v = vec![1, 2, 3, 4, 5];\n \n let i: usize = 0;\n@@ -71,7 +71,7 @@ you cannot index with an `i32`.\n \n If you try to access an index that doesn\u2019t exist:\n \n-```ignore\n+```rust,ignore\n let v = vec![1, 2, 3];\n println!(\"Item 7 is {}\", v[7]);\n ```"}]}