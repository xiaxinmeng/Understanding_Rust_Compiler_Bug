{"sha": "e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwN2NkNWI2ZmU0N2IxZTI2ZjE5YTFiZWRlN2MyZTQ5NjdjYjQ2ZDc=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-02T18:04:20Z"}, "committer": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-02T22:43:17Z"}, "message": "Enhance manual flatten", "tree": {"sha": "0abd635d2d33427e2002b6dd3f5171c6618c4550", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0abd635d2d33427e2002b6dd3f5171c6618c4550"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7", "html_url": "https://github.com/rust-lang/rust/commit/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b87e189694eebb5b83d758528032cf4d4db81472", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87e189694eebb5b83d758528032cf4d4db81472", "html_url": "https://github.com/rust-lang/rust/commit/b87e189694eebb5b83d758528032cf4d4db81472"}], "stats": {"total": 169, "additions": 101, "deletions": 68}, "files": [{"sha": "23dce283f28cecb7e6f429da350c3e5eb8fa2c94", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7", "patch": "@@ -1996,52 +1996,82 @@ fn check_manual_flatten<'tcx>(\n     body: &'tcx Expr<'_>,\n     span: Span,\n ) {\n-    if_chain! {\n-        // Ensure the `if let` statement is the only expression in the for-loop\n-        if let ExprKind::Block(ref block, _) = body.kind;\n-        if block.stmts.is_empty();\n-        if let Some(inner_expr) = block.expr;\n-        if let ExprKind::Match(\n-            ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n-        ) = inner_expr.kind;\n-        // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n-        if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-        if let ExprKind::Path(QPath::Resolved(None, match_expr_path)) = match_expr.kind;\n-        if let Res::Local(match_expr_path_id) = match_expr_path.res;\n-        if pat_hir_id == match_expr_path_id;\n-        // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-        if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n-        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n-        let if_let_type = if is_some_ctor(cx, path.res) {\n-            \"Some\"\n+    if let ExprKind::Block(ref block, _) = body.kind {\n+        // Ensure the `if let` statement is the only expression or statement in the for-loop\n+        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n+            let match_stmt = &block.stmts[0];\n+            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n+                Some(inner_expr)\n+            } else {\n+                None\n+            }\n+        } else if block.stmts.is_empty() {\n+            block.expr\n         } else {\n-            \"Ok\"\n+            None\n         };\n-        // Determine if `arg` is `Iterator` or implicitly calls `into_iter`\n-        let arg_ty = cx.typeck_results().expr_ty(arg);\n-        if let Some(id) = get_trait_def_id(cx, &paths::ITERATOR);\n-        if let is_iterator = implements_trait(cx, arg_ty, id, &[]);\n \n-        then {\n-            // Prepare the error message\n-            let msg = format!(\"Unnecessary `if let` since only the `{}` variant of the iterator element is used.\", if_let_type);\n+        if_chain! {\n+            if let Some(inner_expr) = inner_expr;\n+            if let ExprKind::Match(\n+                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+            ) = inner_expr.kind;\n+            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+            if let ExprKind::Path(QPath::Resolved(None, match_expr_path)) = match_expr.kind;\n+            if let Res::Local(match_expr_path_id) = match_expr_path.res;\n+            if pat_hir_id == match_expr_path_id;\n+            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n+            let some_ctor = is_some_ctor(cx, path.res);\n+            let ok_ctor = is_ok_ctor(cx, path.res);\n+            if some_ctor || ok_ctor;\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n \n-            // Prepare the help message\n-            let arg_snippet = snippet(cx, arg.span, \"..\");\n-            let hint = if is_iterator {\n-                format!(\"try: `{}.flatten()`\", arg_snippet)\n-            } else {\n-                format!(\"try: `{}.into_iter().flatten()`\", arg_snippet)\n-            };\n+            then {\n+                // Prepare the error message\n+                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n \n-            span_lint_and_help(\n-                cx,\n-                MANUAL_FLATTEN,\n-                span,\n-                &msg,\n-                Some(arg.span),\n-                &hint,\n-            );\n+                // Prepare the help message\n+                let mut applicability = Applicability::MaybeIncorrect;\n+                let arg_snippet = snippet_with_applicability(\n+                    cx,\n+                    arg.span,\n+                    \"..\",\n+                    &mut applicability,\n+                );\n+                // Determine if `arg` is by reference, an `Iterator`, or implicitly adjusted with `into_iter`\n+                let hint = match arg.kind {\n+                    ExprKind::AddrOf(_, _, arg_expr) => {\n+                        format!(\"{}.iter().flatten()\", snippet(cx, arg_expr.span, \"..\"))\n+                    },\n+                    ExprKind::MethodCall(_, _, _, _) | ExprKind::Path(QPath::Resolved(None, _)) => {\n+                        // Determine if `arg` is `Iterator` or implicitly calls `into_iter`\n+                        let arg_ty = cx.typeck_results().expr_ty(arg);\n+                        if let Some(id) = get_trait_def_id(cx, &paths::ITERATOR) {\n+                            let is_iterator = implements_trait(cx, arg_ty, id, &[]);\n+                            if is_iterator {\n+                                format!(\"{}.flatten()\", arg_snippet)\n+                            } else {\n+                                format!(\"{}.into_iter().flatten()\", arg_snippet)\n+                            }\n+                        } else {\n+                            return\n+                        }\n+                    },\n+                    _ => return,\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_FLATTEN,\n+                    span,\n+                    &msg,\n+                    \"try\",\n+                    hint,\n+                    applicability,\n+                )\n+            }\n         }\n     }\n }"}, {"sha": "b97cceb66f8e61bbf71362aab8d1122b4c6ae468", "filename": "tests/ui/manual_flatten.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7/tests%2Fui%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7/tests%2Fui%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_flatten.rs?ref=e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7", "patch": "@@ -1,20 +1,30 @@\n #![warn(clippy::manual_flatten)]\n \n fn main() {\n+    // Test for loop over implicitly adjusted `Iterator` with `if let` expression\n     let x = vec![Some(1), Some(2), Some(3)];\n     for n in x {\n         if let Some(n) = n {\n             println!(\"{}\", n);\n         }\n     }\n \n+    // Test for loop over implicitly implicitly adjusted `Iterator` with `if let` statement\n     let y: Vec<Result<i32, i32>> = vec![];\n     for n in y.clone() {\n+        if let Ok(n) = n {\n+            println!(\"{}\", n);\n+        };\n+    }\n+\n+    // Test for loop over by reference\n+    for n in &y {\n         if let Ok(n) = n {\n             println!(\"{}\", n);\n         }\n     }\n \n+    // Test for loop over `Iterator` with `if let` expression\n     let z = vec![Some(1), Some(2), Some(3)];\n     let z = z.iter();\n     for n in z {"}, {"sha": "754921eb739271586f6970de271aabf551cdd7db", "filename": "tests/ui/manual_flatten.stderr", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7/tests%2Fui%2Fmanual_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7/tests%2Fui%2Fmanual_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_flatten.stderr?ref=e07cd5b6fe47b1e26f19a1bede7c2e4967cb46d7", "patch": "@@ -1,51 +1,44 @@\n-error: Unnecessary `if let` since only the `Some` variant of the iterator element is used.\n-  --> $DIR/manual_flatten.rs:5:5\n+error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:6:5\n    |\n LL | /     for n in x {\n LL | |         if let Some(n) = n {\n LL | |             println!(\"{}\", n);\n LL | |         }\n LL | |     }\n-   | |_____^\n+   | |_____^ help: try: `x.into_iter().flatten()`\n    |\n    = note: `-D clippy::manual-flatten` implied by `-D warnings`\n-help: try: `x.into_iter().flatten()`\n-  --> $DIR/manual_flatten.rs:5:14\n-   |\n-LL |     for n in x {\n-   |              ^\n \n-error: Unnecessary `if let` since only the `Ok` variant of the iterator element is used.\n-  --> $DIR/manual_flatten.rs:12:5\n+error: unnecessary `if let` since only the `Ok` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:14:5\n    |\n LL | /     for n in y.clone() {\n LL | |         if let Ok(n) = n {\n LL | |             println!(\"{}\", n);\n-LL | |         }\n+LL | |         };\n LL | |     }\n-   | |_____^\n-   |\n-help: try: `y.clone().into_iter().flatten()`\n-  --> $DIR/manual_flatten.rs:12:14\n+   | |_____^ help: try: `y.clone().into_iter().flatten()`\n+\n+error: unnecessary `if let` since only the `Ok` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:21:5\n    |\n-LL |     for n in y.clone() {\n-   |              ^^^^^^^^^\n+LL | /     for n in &y {\n+LL | |         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+LL | |     }\n+   | |_____^ help: try: `y.iter().flatten()`\n \n-error: Unnecessary `if let` since only the `Some` variant of the iterator element is used.\n-  --> $DIR/manual_flatten.rs:20:5\n+error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:30:5\n    |\n LL | /     for n in z {\n LL | |         if let Some(n) = n {\n LL | |             println!(\"{}\", n);\n LL | |         }\n LL | |     }\n-   | |_____^\n-   |\n-help: try: `z.flatten()`\n-  --> $DIR/manual_flatten.rs:20:14\n-   |\n-LL |     for n in z {\n-   |              ^\n+   | |_____^ help: try: `z.flatten()`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n "}]}