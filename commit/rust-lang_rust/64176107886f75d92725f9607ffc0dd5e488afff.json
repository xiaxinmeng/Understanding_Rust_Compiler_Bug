{"sha": "64176107886f75d92725f9607ffc0dd5e488afff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MTc2MTA3ODg2Zjc1ZDkyNzI1Zjk2MDdmZmMwZGQ1ZTQ4OGFmZmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-19T18:14:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-19T18:14:44Z"}, "message": "rustc: Generalize variable bindings so that we can use it for locals too", "tree": {"sha": "8fb129422bc92bad1dd74564fd1b5fcc793ecdd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fb129422bc92bad1dd74564fd1b5fcc793ecdd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64176107886f75d92725f9607ffc0dd5e488afff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64176107886f75d92725f9607ffc0dd5e488afff", "html_url": "https://github.com/rust-lang/rust/commit/64176107886f75d92725f9607ffc0dd5e488afff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64176107886f75d92725f9607ffc0dd5e488afff/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c750c520e3d1034274b40d8139a41a10976f2a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c750c520e3d1034274b40d8139a41a10976f2a5d", "html_url": "https://github.com/rust-lang/rust/commit/c750c520e3d1034274b40d8139a41a10976f2a5d"}], "stats": {"total": 85, "additions": 46, "deletions": 39}, "files": [{"sha": "65d603895a3fd22435823a84302467175997ff73", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/64176107886f75d92725f9607ffc0dd5e488afff/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64176107886f75d92725f9607ffc0dd5e488afff/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=64176107886f75d92725f9607ffc0dd5e488afff", "patch": "@@ -1865,18 +1865,19 @@ mod unify {\n         ures_err(type_err, t, t);\n     }\n \n-    type var_bindings = rec(ufind::ufind sets,\n-                            hashmap[int,uint] var_ids,\n-                            mutable vec[mutable vec[t]] types);\n+    type bindings[T] = rec(ufind::ufind sets,\n+                           hashmap[T,uint] ids,\n+                           mutable vec[mutable vec[t]] types);\n \n-    fn mk_var_bindings() -> @var_bindings {\n+    fn mk_bindings[T](map::hashfn[T] hasher, map::eqfn[T] eqer)\n+            -> @bindings[T] {\n         let vec[mutable vec[t]] types = [mutable];\n         ret @rec(sets=ufind::make(),\n-                 var_ids=common::new_int_hash[uint](),\n+                 ids=map::mk_hashmap[T,uint](hasher, eqer),\n                  mutable types=types);\n     }\n \n-    type ctxt = rec(@var_bindings var_bindings,\n+    type ctxt = rec(@bindings[int] bindings,\n                     unify_handler handler,\n                     ty_ctxt tcx);\n \n@@ -2079,10 +2080,10 @@ mod unify {\n \n     fn get_or_create_set(&@ctxt cx, int id) -> uint {\n         auto set_num;\n-        alt (cx.var_bindings.var_ids.find(id)) {\n+        alt (cx.bindings.ids.find(id)) {\n             case (none[uint]) {\n-                set_num = ufind::make_set(cx.var_bindings.sets);\n-                cx.var_bindings.var_ids.insert(id, set_num);\n+                set_num = ufind::make_set(cx.bindings.sets);\n+                cx.bindings.ids.insert(id, set_num);\n             }\n             case (some[uint](?n)) { set_num = n; }\n         }\n@@ -2107,18 +2108,17 @@ mod unify {\n                 alt (struct(cx.tcx, expected)) {\n                     case (ty::ty_var(?expected_id)) {\n                         auto expected_n = get_or_create_set(cx, expected_id);\n-                        ufind::union(cx.var_bindings.sets, expected_n,\n-                                     actual_n);\n+                        ufind::union(cx.bindings.sets, expected_n, actual_n);\n                     }\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = vec::len[vec[t]](cx.var_bindings.types);\n+                        auto vlen = vec::len[vec[t]](cx.bindings.types);\n                         if (actual_n < vlen) {\n-                            cx.var_bindings.types.(actual_n) += [expected];\n+                            cx.bindings.types.(actual_n) += [expected];\n                         } else {\n                             assert (actual_n == vlen);\n-                            cx.var_bindings.types += [mutable [expected]];\n+                            cx.bindings.types += [mutable [expected]];\n                         }\n                     }\n                 }\n@@ -2482,12 +2482,12 @@ mod unify {\n             case (ty::ty_var(?expected_id)) {\n                 // Add a binding.\n                 auto expected_n = get_or_create_set(cx, expected_id);\n-                auto vlen = vec::len[vec[t]](cx.var_bindings.types);\n+                auto vlen = vec::len[vec[t]](cx.bindings.types);\n                 if (expected_n < vlen) {\n-                    cx.var_bindings.types.(expected_n) += [actual];\n+                    cx.bindings.types.(expected_n) += [actual];\n                 } else {\n                     assert (expected_n == vlen);\n-                    cx.var_bindings.types += [mutable [actual]];\n+                    cx.bindings.types += [mutable [actual]];\n                 }\n                 ret ures_ok(expected);\n             }\n@@ -2519,19 +2519,23 @@ mod unify {\n     }\n \n     // Performs type binding substitution.\n-    fn substitute(&ty_ctxt tcx, &@var_bindings var_bindings,\n-                  &vec[t] set_types, &t typ) -> t {\n+    fn substitute(&ty_ctxt tcx,\n+                  &@bindings[int] bindings,\n+                  &vec[t] set_types,\n+                  &t typ) -> t {\n         if (!type_contains_vars(tcx, typ)) {\n             ret typ;\n         }\n \n-        fn substituter(ty_ctxt tcx, @var_bindings var_bindings, vec[t] types,\n+        fn substituter(ty_ctxt tcx,\n+                       @bindings[int] bindings,\n+                       vec[t] types,\n                        t typ) -> t {\n             alt (struct(tcx, typ)) {\n                 case (ty_var(?id)) {\n-                    alt (var_bindings.var_ids.find(id)) {\n+                    alt (bindings.ids.find(id)) {\n                         case (some[uint](?n)) {\n-                            auto root = ufind::find(var_bindings.sets, n);\n+                            auto root = ufind::find(bindings.sets, n);\n                             ret types.(root);\n                         }\n                         case (none[uint]) { ret typ; }\n@@ -2541,24 +2545,22 @@ mod unify {\n             }\n         }\n \n-        auto f = bind substituter(tcx, var_bindings, set_types, _);\n+        auto f = bind substituter(tcx, bindings, set_types, _);\n         ret fold_ty(tcx, f, typ);\n     }\n \n-    fn unify_sets(&@var_bindings var_bindings) -> vec[t] {\n-        let vec[t] throwaway = [];\n-        let vec[mutable vec[t]] set_types = [mutable throwaway];\n-        vec::pop[vec[t]](set_types);   // FIXME: botch\n+    fn unify_sets[T](&@bindings[T] bindings) -> vec[t] {\n+        let vec[mutable vec[t]] set_types = [mutable];\n \n-        for (ufind::node node in var_bindings.sets.nodes) {\n+        for (ufind::node node in bindings.sets.nodes) {\n             let vec[t] v = [];\n             set_types += [mutable v];\n         }\n \n         auto i = 0u;\n         while (i < vec::len[vec[t]](set_types)) {\n-            auto root = ufind::find(var_bindings.sets, i);\n-            set_types.(root) += var_bindings.types.(i);\n+            auto root = ufind::find(bindings.sets, i);\n+            set_types.(root) += bindings.types.(i);\n             i += 1u;\n         }\n \n@@ -2578,15 +2580,15 @@ mod unify {\n     fn unify(&t expected,\n              &t actual,\n              &unify_handler handler,\n-             &@var_bindings var_bindings,\n+             &@bindings[int] bindings,\n              &ty_ctxt tcx) -> result {\n-        auto cx = @rec(var_bindings=var_bindings, handler=handler, tcx=tcx);\n+        auto cx = @rec(bindings=bindings, handler=handler, tcx=tcx);\n         ret unify_step(cx, expected, actual);\n     }\n \n-    fn fixup(&ty_ctxt tcx, &@var_bindings var_bindings, t typ) -> t {\n-        auto set_types = unify_sets(var_bindings);\n-        ret substitute(tcx, var_bindings, set_types, typ);\n+    fn fixup(&ty_ctxt tcx, &@bindings[int] bindings, t typ) -> t {\n+        auto set_types = unify_sets[int](bindings);\n+        ret substitute(tcx, bindings, set_types, typ);\n     }\n }\n "}, {"sha": "72c22ab691c4ecd648fafbe22de03bd1fa28503f", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64176107886f75d92725f9607ffc0dd5e488afff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64176107886f75d92725f9607ffc0dd5e488afff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=64176107886f75d92725f9607ffc0dd5e488afff", "patch": "@@ -37,6 +37,7 @@ import middle::ty::ty_nil;\n import middle::ty::unify::ures_ok;\n import middle::ty::unify::ures_err;\n \n+import std::int;\n import std::str;\n import std::uint;\n import std::vec;\n@@ -969,15 +970,15 @@ mod unify {\n \n         auto handler = unify_handler(scx, param_substs);\n \n-        auto var_bindings = ty::unify::mk_var_bindings();\n-        auto result = ty::unify::unify(expected, actual, handler,\n-                                       var_bindings, scx.fcx.ccx.tcx);\n+        auto bindings = ty::unify::mk_bindings[int](int::hash, int::eq_alias);\n+        auto result = ty::unify::unify(expected, actual, handler, bindings,\n+                                       scx.fcx.ccx.tcx);\n \n         alt (result) {\n             case (ures_ok(?rty)) {\n                 if (ty::type_contains_vars(scx.fcx.ccx.tcx, rty)) {\n                     result = ures_ok(ty::unify::fixup(scx.fcx.ccx.tcx,\n-                                                      var_bindings, rty));\n+                                                      bindings, rty));\n                 }\n             }\n             case (_) { /* nothing */ }"}, {"sha": "23aabbc6cd9812bb5173b2900c318f4530ef5552", "filename": "src/lib/int.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64176107886f75d92725f9607ffc0dd5e488afff/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64176107886f75d92725f9607ffc0dd5e488afff/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=64176107886f75d92725f9607ffc0dd5e488afff", "patch": "@@ -17,6 +17,10 @@ fn negative(int x) -> bool { ret x < 0; }\n fn nonpositive(int x) -> bool { ret x <= 0; }\n fn nonnegative(int x) -> bool { ret x >= 0; }\n \n+// FIXME: Make sure this works with negative integers.\n+fn hash(&int x) -> uint { ret x as uint; }\n+fn eq_alias(&int x, &int y) -> bool { ret x == y; }\n+\n iter range(int lo, int hi) -> int {\n     let int lo_ = lo;\n     while (lo_ < hi) {"}]}