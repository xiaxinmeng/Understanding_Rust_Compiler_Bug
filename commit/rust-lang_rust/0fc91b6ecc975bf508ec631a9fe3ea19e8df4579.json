{"sha": "0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYzkxYjZlY2M5NzViZjUwOGVjNjMxYTlmZTNlYTE5ZThkZjQ1Nzk=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-05-24T21:00:45Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-05-24T21:00:45Z"}, "message": "There is only one activate function now.", "tree": {"sha": "81be13418125f2b093da0a6554ed1ab1364bcb1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81be13418125f2b093da0a6554ed1ab1364bcb1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "html_url": "https://github.com/rust-lang/rust/commit/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/comments", "author": null, "committer": null, "parents": [{"sha": "2e8afc7b471e7a455d27e02079d7950d41a4c020", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8afc7b471e7a455d27e02079d7950d41a4c020", "html_url": "https://github.com/rust-lang/rust/commit/2e8afc7b471e7a455d27e02079d7950d41a4c020"}], "stats": {"total": 218, "additions": 105, "deletions": 113}, "files": [{"sha": "d858fec0976eca33e08017c0271b4ec53cb3a9c0", "filename": "mk/rt.mk", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -33,6 +33,8 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n \n RUNTIME_LL := rt/new_exit.ll\n \n+RUNTIME_S := rt/activate_glue.s\n+\n RUNTIME_HDR := rt/globals.h \\\n                rt/rust.h \\\n                rt/rust_dwarf.h \\\n@@ -65,14 +67,18 @@ RUNTIME_HDR := rt/globals.h \\\n \n RUNTIME_DEF := rt/rustrt$(CFG_DEF_SUFFIX)\n RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash\n-RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o) $(RUNTIME_LL:.ll=.o)\n+RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o) $(RUNTIME_LL:.ll=.o) $(RUNTIME_S:.s=.o)\n RUNTIME_LIBS := $(CFG_GCCISH_POST_LIB_FLAGS)\n \n \n rt/%.o: rt/%.cpp $(MKFILES)\n \t@$(call E, compile: $@)\n \t$(Q)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n \n+rt/%.o: rt/%.s $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n+\n rt/%.o: rt/%.ll $(MKFILES)\n \t@$(call E, llc: $@)\n \t$(Q)$(LLC) -filetype=obj -relocation-model=pic -march=x86 -o $@ $<"}, {"sha": "b508309e1a212a5d53377ec35f6965eff5dc2143", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -99,10 +99,6 @@ fn native_glue_name(int n, native_glue_type ngt) -> str {\n     ret prefix + util::common::istr(n);\n }\n \n-fn activate_glue_name() -> str {\n-    ret \"rust_activate_glue\";\n-}\n-\n fn yield_glue_name() -> str {\n     ret \"rust_yield_glue\";\n }"}, {"sha": "7d32a21caa30922c622f75537f8357a9bf99cf8d", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 2, "deletions": 92, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -87,92 +87,6 @@ fn store_esp_to_runtime_sp_second_arg() -> vec[str] {\n }\n \n \n-/*\n- * This is a bit of glue-code. It should be emitted once per\n- * compilation unit.\n- *\n- *   - save regs on C stack\n- *   - align sp on a 16-byte boundary\n- *   - save sp to task.runtime_sp (runtime_sp is thus always aligned)\n- *   - load saved task sp (switch stack)\n- *   - restore saved task regs\n- *   - return to saved task pc\n- *\n- * Our incoming stack looks like this:\n- *\n- *   *esp+4        = [arg1   ] = task ptr\n- *   *esp          = [retpc  ]\n- */\n-\n-fn rust_activate_glue() -> vec[str] {\n-    ret [\"movl  4(%esp), %ecx    # ecx = rust_task\"]\n-        + save_callee_saves()\n-        + store_esp_to_runtime_sp_first_arg()\n-        + load_esp_from_rust_sp_first_arg()\n-\n-        /*\n-         * There are two paths we can arrive at this code from:\n-         *\n-         *\n-         *   1. We are activating a task for the first time. When we switch\n-         *      into the task stack and 'ret' to its first instruction, we'll\n-         *      start doing whatever the first instruction says. Probably\n-         *      saving registers and starting to establish a frame. Harmless\n-         *      stuff, doesn't look at task->rust_sp again except when it\n-         *      clobbers it during a later native call.\n-         *\n-         *\n-         *   2. We are resuming a task that was descheduled by the yield glue\n-         *      below.  When we switch into the task stack and 'ret', we'll be\n-         *      ret'ing to a very particular instruction:\n-         *\n-         *              \"esp <- task->rust_sp\"\n-         *\n-         *      this is the first instruction we 'ret' to after this glue,\n-         *      because it is the first instruction following *any* native\n-         *      call, and the task we are activating was descheduled\n-         *      mid-native-call.\n-         *\n-         *      Unfortunately for us, we have already restored esp from\n-         *      task->rust_sp and are about to eat the 5 words off the top of\n-         *      it.\n-         *\n-         *\n-         *      | ...    | <-- where esp will be once we restore + ret, below,\n-         *      | retpc  |     and where we'd *like* task->rust_sp to wind up.\n-         *      | ebp    |\n-         *      | edi    |\n-         *      | esi    |\n-         *      | ebx    | <-- current task->rust_sp == current esp\n-         *\n-         *\n-         *      This is a problem. If we return to \"esp <- task->rust_sp\" it\n-         *      will push esp back down by 5 words. This manifests as a rust\n-         *      stack that grows by 5 words on each yield/reactivate. Not\n-         *      good.\n-         *\n-         *      So what we do here is just adjust task->rust_sp up 5 words as\n-         *      well, to mirror the movement in esp we're about to\n-         *      perform. That way the \"esp <- task->rust_sp\" we 'ret' to below\n-         *      will be a no-op. Esp won't move, and the task's stack won't\n-         *      grow.\n-         */\n-        + [\"addl  $20, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\"]\n-\n-\n-        /*\n-         * In most cases, the function we're returning to (activating)\n-         * will have saved any caller-saves before it yielded via native call,\n-         * so no work to do here. With one exception: when we're initially\n-         * activating, the task needs to be in the fastcall 2nd parameter\n-         * expected by the rust main function. That's edx.\n-         */\n-        + [\"mov  %ecx, %edx\"]\n-\n-        + restore_callee_saves()\n-        + [\"ret\"];\n-}\n-\n /* More glue code, this time the 'bottom half' of yielding.\n  *\n  * We arrived here because an native call decided to deschedule the\n@@ -306,12 +220,8 @@ fn get_module_asm() -> str {\n \n     auto glues =\n         [decl_glue(align, prefix,\n-                      abi::activate_glue_name(),\n-                      rust_activate_glue()),\n-\n-            decl_glue(align, prefix,\n-                      abi::yield_glue_name(),\n-                      rust_yield_glue())]\n+                   abi::yield_glue_name(),\n+                   rust_yield_glue())]\n \n         + vec::init_fn[str](bind decl_native_glue(align, prefix,\n             abi::ngt_rust, _), (abi::n_native_glues + 1) as uint)"}, {"sha": "880187df4585d8637c231d5b6416fac4b0372a2c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -55,8 +55,7 @@ state obj namegen(mutable int i) {\n \n type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n \n-type glue_fns = rec(ValueRef activate_glue,\n-                    ValueRef yield_glue,\n+type glue_fns = rec(ValueRef yield_glue,\n                     vec[ValueRef] native_glues_rust,\n                     vec[ValueRef] native_glues_pure_rust,\n                     vec[ValueRef] native_glues_cdecl,\n@@ -7661,9 +7660,6 @@ fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n \n     let ValueRef crate_addr = p2i(crate_ptr);\n \n-    let ValueRef activate_glue_off =\n-        llvm::LLVMConstSub(p2i(glues.activate_glue), crate_addr);\n-\n     let ValueRef yield_glue_off =\n         llvm::LLVMConstSub(p2i(glues.yield_glue), crate_addr);\n \n@@ -7674,7 +7670,7 @@ fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n                      C_null(T_int()),     // size_t debug_abbrev_sz\n                      C_null(T_int()),     // ptrdiff_t debug_info_off\n                      C_null(T_int()),     // size_t debug_info_sz\n-                     activate_glue_off,   // size_t activate_glue_off\n+                     C_null(T_int()),     // size_t pad\n                      yield_glue_off,      // size_t yield_glue_off\n                      C_null(T_int()),     // size_t unwind_glue_off\n                      C_null(T_int()),     // size_t gc_glue_off\n@@ -8030,8 +8026,7 @@ fn trans_vec_append_glue(@local_ctxt cx, &ast::span sp) {\n \n \n fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n-    ret @rec(activate_glue = decl_glue(llmod, tn, abi::activate_glue_name()),\n-             yield_glue = decl_glue(llmod, tn, abi::yield_glue_name()),\n+    ret @rec(yield_glue = decl_glue(llmod, tn, abi::yield_glue_name()),\n \n              native_glues_rust =\n                  vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,"}, {"sha": "5b55f56888032872c4c5c7d5f5b32751f6b613f4", "filename": "src/rt/activate_glue.s", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Factivate_glue.s", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Factivate_glue.s", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Factivate_glue.s?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -0,0 +1,89 @@\n+/*\n+ * This is a bit of glue-code.\n+ *\n+ *   - save regs on C stack\n+ *   - save sp to task.runtime_sp (runtime_sp is thus always aligned)\n+ *   - load saved task sp (switch stack)\n+ *   - restore saved task regs\n+ *   - return to saved task pc\n+ *\n+ * Our incoming stack looks like this:\n+ *\n+ *   *esp+4        = [arg1   ] = task ptr\n+ *   *esp          = [retpc  ]\n+ */\n+\n+\t.globl new_rust_activate_glue\n+\t.balign 4\n+new_rust_activate_glue:\n+\tmovl  4(%esp), %ecx    # ecx = rust_task\n+\tpushl %ebp\n+\tpushl %edi\n+\tpushl %esi\n+\tpushl %ebx\n+\tmovl  %esp, 12(%ecx)\n+\tmovl  16(%ecx), %esp\n+\n+        /*\n+         * There are two paths we can arrive at this code from:\n+         *\n+         *\n+         *   1. We are activating a task for the first time. When we switch\n+         *      into the task stack and 'ret' to its first instruction, we'll\n+         *      start doing whatever the first instruction says. Probably\n+         *      saving registers and starting to establish a frame. Harmless\n+         *      stuff, doesn't look at task->rust_sp again except when it\n+         *      clobbers it during a later native call.\n+         *\n+         *\n+         *   2. We are resuming a task that was descheduled by the yield glue\n+         *      below.  When we switch into the task stack and 'ret', we'll be\n+         *      ret'ing to a very particular instruction:\n+         *\n+         *              \"esp <- task->rust_sp\"\n+         *\n+         *      this is the first instruction we 'ret' to after this glue,\n+         *      because it is the first instruction following *any* native\n+         *      call, and the task we are activating was descheduled\n+         *      mid-native-call.\n+         *\n+         *      Unfortunately for us, we have already restored esp from\n+         *      task->rust_sp and are about to eat the 5 words off the top of\n+         *      it.\n+         *\n+         *\n+         *      | ...    | <-- where esp will be once we restore + ret, below,\n+         *      | retpc  |     and where we'd *like* task->rust_sp to wind up.\n+         *      | ebp    |\n+         *      | edi    |\n+         *      | esi    |\n+         *      | ebx    | <-- current task->rust_sp == current esp\n+         *\n+         *\n+         *      This is a problem. If we return to \"esp <- task->rust_sp\" it\n+         *      will push esp back down by 5 words. This manifests as a rust\n+         *      stack that grows by 5 words on each yield/reactivate. Not\n+         *      good.\n+         *\n+         *      So what we do here is just adjust task->rust_sp up 5 words as\n+         *      well, to mirror the movement in esp we're about to\n+         *      perform. That way the \"esp <- task->rust_sp\" we 'ret' to below\n+         *      will be a no-op. Esp won't move, and the task's stack won't\n+         *      grow.\n+         */\n+\taddl  $20, 16(%ecx)\n+\n+        /*\n+         * In most cases, the function we're returning to (activating)\n+         * will have saved any caller-saves before it yielded via native call,\n+         * so no work to do here. With one exception: when we're initially\n+         * activating, the task needs to be in the fastcall 2nd parameter\n+         * expected by the rust main function. That's edx.\n+         */\n+        mov  %ecx, %edx\n+\n+\tpopl  %ebx\n+\tpopl  %esi\n+\tpopl  %edi\n+\tpopl  %ebp\n+\tret"}, {"sha": "410f2bd0be9f5397d1a7446e0a5e78496b4e4ae4", "filename": "src/rt/rust_crate.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Frust_crate.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Frust_crate.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate.cpp?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -11,11 +11,6 @@ rust_crate::get_relocation_diff() const {\n   return ((uintptr_t)this - self_addr);\n }\n \n-activate_glue_ty\n-rust_crate::get_activate_glue() const {\n-  return (activate_glue_ty) ((uintptr_t)this + activate_glue_off);\n-}\n-\n uintptr_t\n rust_crate::get_unwind_glue() const {\n   return ((uintptr_t)this + unwind_glue_off);"}, {"sha": "e3bbfe394499ade33ac1578ab9b923fa5eeb112b", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -48,10 +48,13 @@ rust_dom::~rust_dom() {\n     }\n }\n \n+extern \"C\" void new_rust_activate_glue(rust_task *)\n+    asm(\"new_rust_activate_glue\");\n+\n void\n rust_dom::activate(rust_task *task) {\n     curr_task = task;\n-    root_crate->get_activate_glue()(task);\n+    new_rust_activate_glue(task);\n     curr_task = NULL;\n }\n \n@@ -262,7 +265,6 @@ rust_dom::start_main_loop() {\n     rust_timer timer(this);\n \n     DLOG(this, dom, \"started domain loop\");\n-    DLOG(this, dom, \"activate glue: \" PTR, root_crate->get_activate_glue());\n \n     while (number_of_live_tasks() > 0) {\n         A(this, kernel->is_deadlocked() == false, \"deadlock\");"}, {"sha": "cb6dd162594ae96625b5474c55bdf9a6d71ed9d0", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/0fc91b6ecc975bf508ec631a9fe3ea19e8df4579/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=0fc91b6ecc975bf508ec631a9fe3ea19e8df4579", "patch": "@@ -247,7 +247,6 @@ class rust_crate {\n \n     uintptr_t get_image_base() const;\n     ptrdiff_t get_relocation_diff() const;\n-    activate_glue_ty get_activate_glue() const;\n     uintptr_t get_yield_glue() const;\n     uintptr_t get_unwind_glue() const;\n     uintptr_t get_gc_glue() const;"}]}