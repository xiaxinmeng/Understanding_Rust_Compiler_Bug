{"sha": "22f751f0f398c508be6966b9d6d1a498cd05baac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZjc1MWYwZjM5OGM1MDhiZTY5NjZiOWQ2ZDFhNDk4Y2QwNWJhYWM=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-31T22:55:30Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-04-22T15:50:27Z"}, "message": "Use nullable pointers to represent enums like Option<~T>.\n\nSee comments in adt.rs for details.", "tree": {"sha": "76578283fec1f2e259b85c0d16ac4fdfaf6bb205", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76578283fec1f2e259b85c0d16ac4fdfaf6bb205"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f751f0f398c508be6966b9d6d1a498cd05baac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f751f0f398c508be6966b9d6d1a498cd05baac", "html_url": "https://github.com/rust-lang/rust/commit/22f751f0f398c508be6966b9d6d1a498cd05baac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f751f0f398c508be6966b9d6d1a498cd05baac/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70452e5231d4101811b2ea6a2c4be4adc2b5460b", "url": "https://api.github.com/repos/rust-lang/rust/commits/70452e5231d4101811b2ea6a2c4be4adc2b5460b", "html_url": "https://github.com/rust-lang/rust/commit/70452e5231d4101811b2ea6a2c4be4adc2b5460b"}], "stats": {"total": 192, "additions": 156, "deletions": 36}, "files": [{"sha": "7db6e44adcf160983bc194f5d39f2a7793a2e880", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 150, "deletions": 36, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/22f751f0f398c508be6966b9d6d1a498cd05baac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f751f0f398c508be6966b9d6d1a498cd05baac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=22f751f0f398c508be6966b9d6d1a498cd05baac", "patch": "@@ -29,11 +29,6 @@\n  *   that might contain one and adjust GEP indices accordingly.  See\n  *   issue #4578.\n  *\n- * - Rendering `Option<&T>` as a possibly-null `*T` instead of using\n- *   an extra word (and likewise for `@T` and `~T`).  Can and probably\n- *   should also apply to any enum with one empty case and one case\n- *   starting with a non-null pointer (e.g., `Result<(), ~str>`).\n- *\n  * - Using smaller integer types for discriminants.\n  *\n  * - Store nested enums' discriminants in the same word.  Rather, if\n@@ -54,7 +49,8 @@ use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n use core::vec;\n \n-use lib::llvm::{ValueRef, TypeRef, True};\n+use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};\n+use lib::llvm::llvm::LLVMDumpValue;\n use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -81,7 +77,20 @@ pub enum Repr {\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n      */\n-    General(~[Struct])\n+    General(~[Struct]),\n+    /**\n+     * Two cases distinguished by a nullable pointer: the case with discriminant\n+     * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n+     * field is known to be nonnull due to its type; if that field is null, then\n+     * it represents the other case, which is inhabited by at most one value\n+     * (and all other fields are undefined/unused).\n+     *\n+     * For example, `core::option::Option` instantiated at a safe pointer type\n+     * is represented such that `None` is a null pointer and `Some` is the\n+     * identity function.\n+     */\n+    NullablePointer{ nonnull: Struct, nndiscr: int, ptrfield: uint,\n+                     nullfields: ~[ty::t] }\n }\n \n /// For structs, and struct-like parts of anything fancier.\n@@ -108,9 +117,16 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n         Some(repr) => return *repr,\n         None => { }\n     }\n-    let repr = @match ty::get(t).sty {\n+    let repr = @represent_type_uncached(cx, t);\n+    debug!(\"Represented as: %?\", repr)\n+    cx.adt_reprs.insert(t, repr);\n+    return repr;\n+}\n+\n+fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n+    match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, *elems, false), false)\n+            return Univariant(mk_struct(cx, *elems, false), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n@@ -121,45 +137,78 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n             let dtor = ty::ty_dtor(cx.tcx, def_id).is_present();\n             let ftys =\n                 if dtor { ftys + [ty::mk_bool(cx.tcx)] } else { ftys };\n-            Univariant(mk_struct(cx, ftys, packed), dtor)\n+            return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             struct Case { discr: int, tys: ~[ty::t] };\n+            impl Case {\n+                fn is_zerolen(&self, cx: @CrateContext) -> bool {\n+                    mk_struct(cx, self.tys, false).size == 0\n+                }\n+                fn find_ptr(&self) -> Option<uint> {\n+                    self.tys.position(|&ty| mono_data_classify(ty) == MonoNonNull)\n+                }\n+            }\n \n             let cases = do ty::enum_variants(cx.tcx, def_id).map |vi| {\n                 let arg_tys = do vi.args.map |&raw_ty| {\n                     ty::subst(cx.tcx, substs, raw_ty)\n                 };\n                 Case { discr: vi.disr_val, tys: arg_tys }\n             };\n+\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n-                Univariant(mk_struct(cx, ~[], false), false)\n-            } else if cases.all(|c| c.tys.len() == 0) {\n+                return Univariant(mk_struct(cx, ~[], false), false);\n+            }\n+\n+            if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n-                CEnum(discrs.min(), discrs.max())\n-            } else if cases.len() == 1 {\n+                return CEnum(discrs.min(), discrs.max());\n+            }\n+\n+            if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n                 assert!(cases[0].discr == 0);\n-                Univariant(mk_struct(cx, cases[0].tys, false), false)\n-            } else {\n-                // The general case.  Since there's at least one\n-                // non-empty body, explicit discriminants should have\n-                // been rejected by a checker before this point.\n-                if !cases.alli(|i,c| c.discr == (i as int)) {\n-                    cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n-                                      discriminants\",\n-                                     ty::item_path_str(cx.tcx, def_id)))\n+                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n+            }\n+\n+            // Since there's at least one\n+            // non-empty body, explicit discriminants should have\n+            // been rejected by a checker before this point.\n+            if !cases.alli(|i,c| c.discr == (i as int)) {\n+                cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n+                                  discriminants\",\n+                                 ty::item_path_str(cx.tcx, def_id)))\n+            }\n+\n+            if cases.len() == 2 {\n+                let mut discr = 0;\n+                while discr < 2 {\n+                    if cases[1 - discr].is_zerolen(cx) {\n+                        match cases[discr].find_ptr() {\n+                            Some(ptrfield) => {\n+                                return NullablePointer {\n+                                    nndiscr: discr,\n+                                    nonnull: mk_struct(cx, cases[discr].tys, false),\n+                                    ptrfield: ptrfield,\n+                                    nullfields: copy cases[1 - discr].tys\n+                                }\n+                            }\n+                            None => { }\n+                        }\n+                    }\n+                    discr += 1;\n                 }\n-                let discr = ~[ty::mk_int(cx.tcx)];\n-                General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n             }\n+\n+            // The general case.\n+            let discr = ~[ty::mk_int(cx.tcx)];\n+            return General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n         _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n-    };\n-    cx.adt_reprs.insert(t, repr);\n-    return repr;\n+    }\n }\n \n fn mk_struct(cx: @CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n@@ -190,6 +239,7 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     match *r {\n         CEnum(*) => ~[T_enum_discrim(cx)],\n         Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n+        NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n         General(ref sts) => {\n             // To get \"the\" type of a general enum, we pick the case\n             // with the largest alignment (so it will always align\n@@ -239,23 +289,40 @@ pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n         CEnum(*) | General(*) => {\n             (_match::switch, Some(trans_get_discr(bcx, r, scrutinee)))\n         }\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n+        }\n         Univariant(*) => {\n             (_match::single, None)\n         }\n     }\n }\n \n+\n+\n /// Obtain the actual discriminant of a value.\n pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n     -> ValueRef {\n     match *r {\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n         Univariant(*) => C_int(bcx.ccx(), 0),\n         General(ref cases) => load_discr(bcx, scrutinee, 0,\n-                                         (cases.len() - 1) as int)\n+                                         (cases.len() - 1) as int),\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n+                 T_enum_discrim(bcx.ccx()))\n+        }\n     }\n }\n \n+fn nullable_bitdiscr(bcx: block, nonnull: &Struct, nndiscr: int, ptrfield: uint,\n+                     scrutinee: ValueRef) -> ValueRef {\n+    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+    let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n+    let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+    ICmp(bcx, cmp, llptr, C_null(llptrty))\n+}\n+\n /// Helper for cases where the discriminant is simply loaded.\n fn load_discr(bcx: block, scrutinee: ValueRef, min: int, max: int)\n     -> ValueRef {\n@@ -286,12 +353,16 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n         CEnum(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n-        Univariant(*)=> {\n+        Univariant(*) => {\n             bcx.ccx().sess.bug(~\"no cases for univariants or structs\")\n         }\n         General(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n+        NullablePointer{ _ } => {\n+            assert!(discr == 0 || discr == 1);\n+            _match::single_result(rslt(bcx, C_i1(discr != 0)))\n+        }\n     }\n }\n \n@@ -317,6 +388,13 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n         General(*) => {\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            if discr != nndiscr {\n+                let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n+                let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+                Store(bcx, C_null(llptrty), llptrptr)\n+            }\n+        }\n     }\n }\n \n@@ -331,7 +409,10 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n             assert!(discr == 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(ref cases) => cases[discr as uint].fields.len() - 1\n+        General(ref cases) => cases[discr as uint].fields.len() - 1,\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, _ } => {\n+            if discr == nndiscr { nonnull.fields.len() } else { 0 }\n+        }\n     }\n }\n \n@@ -352,6 +433,19 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n         General(ref cases) => {\n             struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n         }\n+        NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields, nndiscr, _ } => {\n+            if (discr == nndiscr) {\n+                struct_field_ptr(bcx, nonnull, val, ix, false)\n+            } else {\n+                // The unit-like case might have a nonzero number of unit-like fields.\n+                // (e.g., Result or Either with () as one side.)\n+                let llty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n+                assert!(machine::llsize_of_alloc(bcx.ccx(), llty) == 0);\n+                // The contents of memory at this pointer can't matter, but use\n+                // the value that's \"reasonable\" in case of pointer comparison.\n+                PointerCast(bcx, val, T_ptr(llty))\n+            }\n+        }\n     }\n }\n \n@@ -420,6 +514,18 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                                               ~[C_int(ccx, discr)] + vals);\n             C_struct(contents + [padding(max_sz - case.size)])\n         }\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+            if discr == nndiscr {\n+                C_struct(build_const_struct(ccx, nonnull, vals))\n+            } else {\n+                assert!(vals.len() == 0);\n+                let vals = do nonnull.fields.mapi |i, &ty| {\n+                    let llty = type_of::sizing_type_of(ccx, ty);\n+                    if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n+                };\n+                C_struct(build_const_struct(ccx, nonnull, vals))\n+            }\n+        }\n     }\n }\n \n@@ -451,10 +557,14 @@ fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n             cfields.push(padding(target_offset - offset));\n             offset = target_offset;\n         }\n-        assert!(!is_undef(vals[i]));\n-        // If that assert fails, could change it to wrap in a struct?\n-        // (See `const_struct_field` for why real fields must not be undef.)\n-        cfields.push(vals[i]);\n+        let val = if is_undef(vals[i]) {\n+            let wrapped = C_struct([vals[i]]);\n+            assert!(!is_undef(wrapped));\n+            wrapped\n+        } else {\n+            vals[i]\n+        };\n+        cfields.push(val);\n     }\n \n     return cfields;\n@@ -475,6 +585,9 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n         CEnum(*) => const_to_int(val) as int,\n         Univariant(*) => 0,\n         General(*) => const_to_int(const_get_elt(ccx, val, [0])) as int,\n+        NullablePointer{ nndiscr, ptrfield, _ } => {\n+            if is_null(const_struct_field(ccx, val, ptrfield)) { 1 - nndiscr } else { nndiscr }\n+        }\n     }\n }\n \n@@ -490,7 +603,8 @@ pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n     match *r {\n         CEnum(*) => ccx.sess.bug(~\"element access in C-like enum const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),\n-        General(*) => const_struct_field(ccx, val, ix + 1)\n+        General(*) => const_struct_field(ccx, val, ix + 1),\n+        NullablePointer{ _ } => const_struct_field(ccx, val, ix)\n     }\n }\n "}, {"sha": "83fe135d8721f4e6fe2d270488bc2c67d95434c5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22f751f0f398c508be6966b9d6d1a498cd05baac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f751f0f398c508be6966b9d6d1a498cd05baac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=22f751f0f398c508be6966b9d6d1a498cd05baac", "patch": "@@ -1304,6 +1304,12 @@ pub fn is_undef(val: ValueRef) -> bool {\n     }\n }\n \n+pub fn is_null(val: ValueRef) -> bool {\n+    unsafe {\n+        llvm::LLVMIsNull(val) != False\n+    }\n+}\n+\n // Used to identify cached monomorphized functions and vtables\n #[deriving(Eq)]\n pub enum mono_param_id {"}]}