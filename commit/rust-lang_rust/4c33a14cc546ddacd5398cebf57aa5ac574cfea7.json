{"sha": "4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMzNhMTRjYzU0NmRkYWNkNTM5OGNlYmY1N2FhNWFjNTc0Y2ZlYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-26T19:46:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-26T19:46:25Z"}, "message": "auto merge of #14886 : alexcrichton/rust/rt-improvements, r=brson\n\nMost of the comments are available on the Task structure itself, but this commit\r\nis aimed at making FFI-style usage of Rust tasks a little nicer.\r\n\r\nPrimarily, this commit enables re-use of tasks across multiple invocations. The\r\nmethod `run` will no longer unconditionally destroy the task itself. Rather, the\r\ntask will be internally re-usable if the closure specified did not fail. Once a\r\ntask has failed once it is considered poisoned and it can never be used again.\r\n\r\nAlong the way I tried to document shortcomings of the current method of tearing\r\ndown a task, opening a few issues as well. For now none of the behavior is a\r\nshowstopper, but it's useful to acknowledge it. Also along the way I attempted\r\nto remove as much `unsafe` code as possible, opting for safer abstractions.", "tree": {"sha": "21d47ac21cd9785976f1551a459df6e033f37712", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21d47ac21cd9785976f1551a459df6e033f37712"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "html_url": "https://github.com/rust-lang/rust/commit/4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b20f968ed2a4808f98ffce52ce95398009565ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/b20f968ed2a4808f98ffce52ce95398009565ece", "html_url": "https://github.com/rust-lang/rust/commit/b20f968ed2a4808f98ffce52ce95398009565ece"}, {"sha": "7d756e44a96c1e28f63cab1ea328d01984ac07d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d756e44a96c1e28f63cab1ea328d01984ac07d2", "html_url": "https://github.com/rust-lang/rust/commit/7d756e44a96c1e28f63cab1ea328d01984ac07d2"}], "stats": {"total": 455, "additions": 337, "deletions": 118}, "files": [{"sha": "e0e9187a409c67db48408555e8ba2090a184b068", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -299,7 +299,7 @@ pub fn start(argc: int, argv: **u8,\n     let mut ret = None;\n     simple::task().run(|| {\n         ret = Some(run(event_loop_factory, main.take_unwrap()));\n-    });\n+    }).destroy();\n     // unsafe is ok b/c we're sure that the runtime is gone\n     unsafe { rt::cleanup() }\n     ret.unwrap()"}, {"sha": "25c2a952341925928f30886ecf91bb9cae7b7dff", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -110,7 +110,7 @@ extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n     // requested. This is the \"try/catch\" block for this green task and\n     // is the wrapper for *all* code run in the task.\n     let mut start = Some(start);\n-    let task = task.swap().run(|| start.take_unwrap()());\n+    let task = task.swap().run(|| start.take_unwrap()()).destroy();\n \n     // Once the function has exited, it's time to run the termination\n     // routine. This means we need to context switch one more time but\n@@ -120,7 +120,7 @@ extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n     // this we could add a `terminate` function to the `Runtime` trait\n     // in libstd, but that seems less appropriate since the coversion\n     // method exists.\n-    GreenTask::convert(task).terminate()\n+    GreenTask::convert(task).terminate();\n }\n \n impl GreenTask {"}, {"sha": "9b2bcbbdb0ee355b1718237f5063b8a93ad46cf1", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -134,13 +134,12 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n     let mut main = Some(main);\n     let mut task = task::new((my_stack_bottom, my_stack_top));\n     task.name = Some(str::Slice(\"<main>\"));\n-    let t = task.run(|| {\n+    drop(task.run(|| {\n         unsafe {\n             rt::stack::record_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n         exit_code = Some(run(main.take_unwrap()));\n-    });\n-    drop(t);\n+    }).destroy());\n     unsafe { rt::cleanup(); }\n     // If the exit code wasn't set, then the task block must have failed.\n     return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);"}, {"sha": "0b863d9f69401cfd2255700652ad6f759ce50c72", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -92,8 +92,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n         let mut f = Some(f);\n         let mut task = task;\n         task.put_runtime(ops);\n-        let t = task.run(|| { f.take_unwrap()() });\n-        drop(t);\n+        drop(task.run(|| { f.take_unwrap()() }).destroy());\n         bookkeeping::decrement();\n     })\n }"}, {"sha": "d95a4ba49de9d2dfc66ad6466faaad935193d65f", "filename": "src/librustrt/local_heap.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibrustrt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibrustrt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_heap.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -110,7 +110,12 @@ impl LocalHeap {\n         self.memory_region.free(alloc);\n     }\n \n-    pub unsafe fn annihilate(&mut self) {\n+    /// Immortalize all pending allocations, forcing them to live forever.\n+    ///\n+    /// This function will freeze all allocations to prevent all pending\n+    /// allocations from being deallocated. This is used in preparation for when\n+    /// a task is about to destroy TLD.\n+    pub unsafe fn immortalize(&mut self) {\n         let mut n_total_boxes = 0u;\n \n         // Pass 1: Make all boxes immortal.\n@@ -122,6 +127,17 @@ impl LocalHeap {\n             (*alloc).ref_count = RC_IMMORTAL;\n         });\n \n+        if debug_mem() {\n+            // We do logging here w/o allocation.\n+            rterrln!(\"total boxes annihilated: {}\", n_total_boxes);\n+        }\n+    }\n+\n+    /// Continues deallocation of the all pending allocations in this arena.\n+    ///\n+    /// This is invoked from the destructor, and requires that `immortalize` has\n+    /// been called previously.\n+    unsafe fn annihilate(&mut self) {\n         // Pass 2: Drop all boxes.\n         //\n         // In this pass, unique-managed boxes may get freed, but not\n@@ -142,11 +158,6 @@ impl LocalHeap {\n         self.each_live_alloc(true, |me, alloc| {\n             me.free(alloc);\n         });\n-\n-        if debug_mem() {\n-            // We do logging here w/o allocation.\n-            rterrln!(\"total boxes annihilated: {}\", n_total_boxes);\n-        }\n     }\n \n     unsafe fn each_live_alloc(&mut self, read_next_before: bool,\n@@ -170,6 +181,7 @@ impl LocalHeap {\n \n impl Drop for LocalHeap {\n     fn drop(&mut self) {\n+        unsafe { self.annihilate() }\n         assert!(self.live_allocs.is_null());\n     }\n }"}, {"sha": "6e27310f09ac92c838d94e00fa7b80e36d5d3340", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 247, "deletions": 88, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -19,8 +19,8 @@ use alloc::arc::Arc;\n use alloc::owned::{AnyOwnExt, Box};\n use core::any::Any;\n use core::atomics::{AtomicUint, SeqCst};\n-use core::finally::Finally;\n use core::iter::Take;\n+use core::kinds::marker;\n use core::mem;\n use core::raw;\n \n@@ -29,14 +29,71 @@ use Runtime;\n use local::Local;\n use local_heap::LocalHeap;\n use rtio::LocalIo;\n+use unwind;\n use unwind::Unwinder;\n use collections::str::SendStr;\n \n-/// The Task struct represents all state associated with a rust\n-/// task. There are at this point two primary \"subtypes\" of task,\n-/// however instead of using a subtype we just have a \"task_type\" field\n-/// in the struct. This contains a pointer to another struct that holds\n-/// the type-specific state.\n+/// State associated with Rust tasks.\n+///\n+/// Rust tasks are primarily built with two separate components. One is this\n+/// structure which handles standard services such as TLD, unwinding support,\n+/// naming of a task, etc. The second component is the runtime of this task, a\n+/// `Runtime` trait object.\n+///\n+/// The `Runtime` object instructs this task how it can perform critical\n+/// operations such as blocking, rescheduling, I/O constructors, etc. The two\n+/// halves are separately owned, but one is often found contained in the other.\n+/// A task's runtime can be reflected upon with the `maybe_take_runtime` method,\n+/// and otherwise its ownership is managed with `take_runtime` and\n+/// `put_runtime`.\n+///\n+/// In general, this structure should not be used. This is meant to be an\n+/// unstable internal detail of the runtime itself. From time-to-time, however,\n+/// it is useful to manage tasks directly. An example of this would be\n+/// interoperating with the Rust runtime from FFI callbacks or such. For this\n+/// reason, there are two methods of note with the `Task` structure.\n+///\n+/// * `run` - This function will execute a closure inside the context of a task.\n+///           Failure is caught and handled via the task's on_exit callback. If\n+///           this fails, the task is still returned, but it can no longer be\n+///           used, it is poisoned.\n+///\n+/// * `destroy` - This is a required function to call to destroy a task. If a\n+///               task falls out of scope without calling `destroy`, its\n+///               destructor bomb will go off, aborting the process.\n+///\n+/// With these two methods, tasks can be re-used to execute code inside of its\n+/// context while having a point in the future where destruction is allowed.\n+/// More information can be found on these specific methods.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// extern crate native;\n+/// use std::uint;\n+/// # fn main() {\n+///\n+/// // Create a task using a native runtime\n+/// let task = native::task::new((0, uint::MAX));\n+///\n+/// // Run some code, catching any possible failures\n+/// let task = task.run(|| {\n+///     // Run some code inside this task\n+///     println!(\"Hello with a native runtime!\");\n+/// });\n+///\n+/// // Run some code again, catching the failure\n+/// let task = task.run(|| {\n+///     fail!(\"oh no, what to do!\");\n+/// });\n+///\n+/// // Now that the task is failed, it can never be used again\n+/// assert!(task.is_destroyed());\n+///\n+/// // Deallocate the resources associated with this task\n+/// task.destroy();\n+/// # }\n+/// ```\n pub struct Task {\n     pub heap: LocalHeap,\n     pub gc: GarbageCollector,\n@@ -79,14 +136,22 @@ pub enum BlockedTask {\n \n /// Per-task state related to task death, killing, failure, etc.\n pub struct Death {\n-    pub on_exit: Option<proc(Result): Send>,\n+    pub on_exit: Option<proc(Result):Send>,\n+    marker: marker::NoCopy,\n }\n \n pub struct BlockedTasks {\n     inner: Arc<AtomicUint>,\n }\n \n impl Task {\n+    /// Creates a new uninitialized task.\n+    ///\n+    /// This method cannot be used to immediately invoke `run` because the task\n+    /// itself will likely require a runtime to be inserted via `put_runtime`.\n+    ///\n+    /// Note that you likely don't want to call this function, but rather the\n+    /// task creation functions through libnative or libgreen.\n     pub fn new() -> Task {\n         Task {\n             heap: LocalHeap::new(),\n@@ -100,80 +165,181 @@ impl Task {\n         }\n     }\n \n-    /// Executes the given closure as if it's running inside this task. The task\n-    /// is consumed upon entry, and the destroyed task is returned from this\n-    /// function in order for the caller to free. This function is guaranteed to\n-    /// not unwind because the closure specified is run inside of a `rust_try`\n-    /// block. (this is the only try/catch block in the world).\n+    /// Consumes ownership of a task, runs some code, and returns the task back.\n     ///\n-    /// This function is *not* meant to be abused as a \"try/catch\" block. This\n-    /// is meant to be used at the absolute boundaries of a task's lifetime, and\n-    /// only for that purpose.\n-    pub fn run(~self, mut f: ||) -> Box<Task> {\n-        // Need to put ourselves into TLS, but also need access to the unwinder.\n-        // Unsafely get a handle to the task so we can continue to use it after\n-        // putting it in tls (so we can invoke the unwinder).\n-        let handle: *mut Task = unsafe {\n-            *mem::transmute::<&Box<Task>, &*mut Task>(&self)\n-        };\n+    /// This function can be used as an emulated \"try/catch\" to interoperate\n+    /// with the rust runtime at the outermost boundary. It is not possible to\n+    /// use this function in a nested fashion (a try/catch inside of another\n+    /// try/catch). Invoking this funciton is quite cheap.\n+    ///\n+    /// If the closure `f` succeeds, then the returned task can be used again\n+    /// for another invocation of `run`. If the closure `f` fails then `self`\n+    /// will be internally destroyed along with all of the other associated\n+    /// resources of this task. The `on_exit` callback is invoked with the\n+    /// cause of failure (not returned here). This can be discovered by querying\n+    /// `is_destroyed()`.\n+    ///\n+    /// Note that it is possible to view partial execution of the closure `f`\n+    /// because it is not guaranteed to run to completion, but this function is\n+    /// guaranteed to return if it fails. Care should be taken to ensure that\n+    /// stack references made by `f` are handled appropriately.\n+    ///\n+    /// It is invalid to call this function with a task that has been previously\n+    /// destroyed via a failed call to `run`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// extern crate native;\n+    /// use std::uint;\n+    /// # fn main() {\n+    ///\n+    /// // Create a new native task\n+    /// let task = native::task::new((0, uint::MAX));\n+    ///\n+    /// // Run some code once and then destroy this task\n+    /// task.run(|| {\n+    ///     println!(\"Hello with a native runtime!\");\n+    /// }).destroy();\n+    /// # }\n+    /// ```\n+    pub fn run(~self, f: ||) -> Box<Task> {\n+        assert!(!self.is_destroyed(), \"cannot re-use a destroyed task\");\n+\n+        // First, make sure that no one else is in TLS. This does not allow\n+        // recursive invocations of run(). If there's no one else, then\n+        // relinquish ownership of ourselves back into TLS.\n+        if Local::exists(None::<Task>) {\n+            fail!(\"cannot run a task recursively inside another\");\n+        }\n         Local::put(self);\n \n-        // The only try/catch block in the world. Attempt to run the task's\n-        // client-specified code and catch any failures.\n-        let try_block = || {\n-\n-            // Run the task main function, then do some cleanup.\n-            f.finally(|| {\n-                // First, destroy task-local storage. This may run user dtors.\n-                //\n-                // FIXME #8302: Dear diary. I'm so tired and confused.\n-                // There's some interaction in rustc between the box\n-                // annihilator and the TLS dtor by which TLS is\n-                // accessed from annihilated box dtors *after* TLS is\n-                // destroyed. Somehow setting TLS back to null, as the\n-                // old runtime did, makes this work, but I don't currently\n-                // understand how. I would expect that, if the annihilator\n-                // reinvokes TLS while TLS is uninitialized, that\n-                // TLS would be reinitialized but never destroyed,\n-                // but somehow this works. I have no idea what's going\n-                // on but this seems to make things magically work. FML.\n-                //\n-                // (added after initial comment) A possible interaction here is\n-                // that the destructors for the objects in TLS themselves invoke\n-                // TLS, or possibly some destructors for those objects being\n-                // annihilated invoke TLS. Sadly these two operations seemed to\n-                // be intertwined, and miraculously work for now...\n-                drop({\n-                    let mut task = Local::borrow(None::<Task>);\n-                    let &LocalStorage(ref mut optmap) = &mut task.storage;\n-                    optmap.take()\n-                });\n-\n-                // Destroy remaining boxes. Also may run user dtors.\n-                let mut heap = {\n-                    let mut task = Local::borrow(None::<Task>);\n-                    mem::replace(&mut task.heap, LocalHeap::new())\n-                };\n-                unsafe { heap.annihilate() }\n-                drop(heap);\n-            })\n-        };\n+        // There are two primary reasons that general try/catch is unsafe. The\n+        // first is that we do not support nested try/catch. The above check for\n+        // an existing task in TLS is sufficient for this invariant to be\n+        // upheld. The second is that unwinding while unwinding is not defined.\n+        // We take care of that by having an 'unwinding' flag in the task\n+        // itself. For these reasons, this unsafety should be ok.\n+        let result = unsafe { unwind::try(f) };\n+\n+        // After running the closure given return the task back out if it ran\n+        // successfully, or clean up the task if it failed.\n+        let task: Box<Task> = Local::take();\n+        match result {\n+            Ok(()) => task,\n+            Err(cause) => { task.cleanup(Err(cause)) }\n+        }\n+    }\n \n-        unsafe { (*handle).unwinder.try(try_block); }\n+    /// Destroy all associated resources of this task.\n+    ///\n+    /// This function will perform any necessary clean up to prepare the task\n+    /// for destruction. It is required that this is called before a `Task`\n+    /// falls out of scope.\n+    ///\n+    /// The returned task cannot be used for running any more code, but it may\n+    /// be used to extract the runtime as necessary.\n+    pub fn destroy(~self) -> Box<Task> {\n+        if self.is_destroyed() {\n+            self\n+        } else {\n+            self.cleanup(Ok(()))\n+        }\n+    }\n \n-        // Here we must unsafely borrow the task in order to not remove it from\n-        // TLS. When collecting failure, we may attempt to send on a channel (or\n-        // just run arbitrary code), so we must be sure to still have a local\n-        // task in TLS.\n-        unsafe {\n-            let me: *mut Task = Local::unsafe_borrow();\n-            (*me).death.collect_failure((*me).unwinder.result());\n+    /// Cleans up a task, processing the result of the task as appropriate.\n+    ///\n+    /// This function consumes ownership of the task, deallocating it once it's\n+    /// done being processed. It is assumed that TLD and the local heap have\n+    /// already been destroyed and/or annihilated.\n+    fn cleanup(~self, result: Result) -> Box<Task> {\n+        // The first thing to do when cleaning up is to deallocate our local\n+        // resources, such as TLD and GC data.\n+        //\n+        // FIXME: there are a number of problems with this code\n+        //\n+        // 1. If any TLD object fails destruction, then all of TLD will leak.\n+        //    This appears to be a consequence of #14875.\n+        //\n+        // 2. Failing during GC annihilation aborts the runtime #14876.\n+        //\n+        // 3. Setting a TLD key while destroying TLD or while destroying GC will\n+        //    abort the runtime #14807.\n+        //\n+        // 4. Invoking GC in GC destructors will abort the runtime #6996.\n+        //\n+        // 5. The order of destruction of TLD and GC matters, but either way is\n+        //    susceptible to leaks (see 3/4) #8302.\n+        //\n+        // That being said, there are a few upshots to this code\n+        //\n+        // 1. If TLD destruction fails, heap destruction will be attempted.\n+        //    There is a test for this at fail-during-tld-destroy.rs. Sadly the\n+        //    other way can't be tested due to point 2 above. Note that we must\n+        //    immortalize the heap first becuase if any deallocations are\n+        //    attempted while TLD is being dropped it will attempt to free the\n+        //    allocation from the wrong heap (because the current one has been\n+        //    replaced).\n+        //\n+        // 2. One failure in destruction is tolerable, so long as the task\n+        //    didn't originally fail while it was running.\n+        //\n+        // And with all that in mind, we attempt to clean things up!\n+        let mut task = self.run(|| {\n+            let mut task = Local::borrow(None::<Task>);\n+            let tld = {\n+                let &LocalStorage(ref mut optmap) = &mut task.storage;\n+                optmap.take()\n+            };\n+            let mut heap = mem::replace(&mut task.heap, LocalHeap::new());\n+            unsafe { heap.immortalize() }\n+            drop(task);\n+\n+            // First, destroy task-local storage. This may run user dtors.\n+            drop(tld);\n+\n+            // Destroy remaining boxes. Also may run user dtors.\n+            drop(heap);\n+        });\n+\n+        // If the above `run` block failed, then it must be the case that the\n+        // task had previously succeeded. This also means that the code below\n+        // was recursively run via the `run` method invoking this method. In\n+        // this case, we just make sure the world is as we thought, and return.\n+        if task.is_destroyed() {\n+            rtassert!(result.is_ok())\n+            return task\n+        }\n+\n+        // After taking care of the data above, we need to transmit the result\n+        // of this task.\n+        let what_to_do = task.death.on_exit.take();\n+        Local::put(task);\n+\n+        // FIXME: this is running in a seriously constrained context. If this\n+        //        allocates GC or allocates TLD then it will likely abort the\n+        //        runtime. Similarly, if this fails, this will also likely abort\n+        //        the runtime.\n+        //\n+        //        This closure is currently limited to a channel send via the\n+        //        standard library's task interface, but this needs\n+        //        reconsideration to whether it's a reasonable thing to let a\n+        //        task to do or not.\n+        match what_to_do {\n+            Some(f) => { f(result) }\n+            None => { drop(result) }\n         }\n-        let mut me: Box<Task> = Local::take();\n-        me.destroyed = true;\n-        return me;\n+\n+        // Now that we're done, we remove the task from TLS and flag it for\n+        // destruction.\n+        let mut task: Box<Task> = Local::take();\n+        task.destroyed = true;\n+        return task;\n     }\n \n+    /// Queries whether this can be destroyed or not.\n+    pub fn is_destroyed(&self) -> bool { self.destroyed }\n+\n     /// Inserts a runtime object into this task, transferring ownership to the\n     /// task. It is illegal to replace a previous runtime object in this task\n     /// with this argument.\n@@ -182,6 +348,13 @@ impl Task {\n         self.imp = Some(ops);\n     }\n \n+    /// Removes the runtime from this task, transferring ownership to the\n+    /// caller.\n+    pub fn take_runtime(&mut self) -> Box<Runtime + Send> {\n+        assert!(self.imp.is_some());\n+        self.imp.take().unwrap()\n+    }\n+\n     /// Attempts to extract the runtime as a specific type. If the runtime does\n     /// not have the provided type, then the runtime is not removed. If the\n     /// runtime does have the specified type, then it is removed and returned\n@@ -374,21 +547,7 @@ impl BlockedTask {\n \n impl Death {\n     pub fn new() -> Death {\n-        Death { on_exit: None, }\n-    }\n-\n-    /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, result: Result) {\n-        match self.on_exit.take() {\n-            Some(f) => f(result),\n-            None => {}\n-        }\n-    }\n-}\n-\n-impl Drop for Death {\n-    fn drop(&mut self) {\n-        // make this type noncopyable\n+        Death { on_exit: None, marker: marker::NoCopy }\n     }\n }\n "}, {"sha": "657d604fcad4bfe6dd36ad817d1a8e150a6a0801", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -78,7 +78,6 @@ use uw = libunwind;\n \n pub struct Unwinder {\n     unwinding: bool,\n-    cause: Option<Box<Any + Send>>\n }\n \n struct Exception {\n@@ -107,25 +106,12 @@ impl Unwinder {\n     pub fn new() -> Unwinder {\n         Unwinder {\n             unwinding: false,\n-            cause: None,\n         }\n     }\n \n     pub fn unwinding(&self) -> bool {\n         self.unwinding\n     }\n-\n-    pub fn try(&mut self, f: ||) {\n-        self.cause = unsafe { try(f) }.err();\n-    }\n-\n-    pub fn result(&mut self) -> Result {\n-        if self.unwinding {\n-            Err(self.cause.take().unwrap())\n-        } else {\n-            Ok(())\n-        }\n-    }\n }\n \n /// Invoke a closure, capturing the cause of failure if one occurs."}, {"sha": "dad241002f86ceb1e0de54110af724d62ea6698a", "filename": "src/libstd/task.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -295,8 +295,8 @@ impl<S: Spawner> TaskBuilder<S> {\n         let (tx_done, rx_done) = channel(); // signal that task has exited\n         let (tx_retv, rx_retv) = channel(); // return value from task\n \n-        let on_exit = proc(res) { tx_done.send(res) };\n-        self.spawn_internal(proc() { tx_retv.send(f()) },\n+        let on_exit = proc(res) { let _ = tx_done.send_opt(res); };\n+        self.spawn_internal(proc() { let _ = tx_retv.send_opt(f()); },\n                             Some(on_exit));\n \n         Future::from_fn(proc() {\n@@ -641,3 +641,14 @@ mod test {\n     // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n     // to the test harness apparently interfering with stderr configuration.\n }\n+\n+#[test]\n+fn task_abort_no_kill_runtime() {\n+    use std::io::timer;\n+    use mem;\n+\n+    let mut tb = TaskBuilder::new();\n+    let rx = tb.try_future(proc() {});\n+    mem::drop(rx);\n+    timer::sleep(1000);\n+}"}, {"sha": "835f1fe4d4a80dcf33711d25343ce66cf108b7fd", "filename": "src/test/run-pass/fail-during-tld-destroy.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Ftest%2Frun-pass%2Ffail-during-tld-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c33a14cc546ddacd5398cebf57aa5ac574cfea7/src%2Ftest%2Frun-pass%2Ffail-during-tld-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffail-during-tld-destroy.rs?ref=4c33a14cc546ddacd5398cebf57aa5ac574cfea7", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::task;\n+use std::gc::{GC, Gc};\n+use std::cell::RefCell;\n+\n+static mut DROPS: uint = 0;\n+\n+struct Foo(bool);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        let Foo(fail) = *self;\n+        unsafe { DROPS += 1; }\n+        if fail { fail!() }\n+    }\n+}\n+\n+fn tld_fail(fail: bool) {\n+    local_data_key!(foo: Foo);\n+    foo.replace(Some(Foo(fail)));\n+}\n+\n+fn gc_fail(fail: bool) {\n+    struct A {\n+        inner: RefCell<Option<Gc<A>>>,\n+        other: Foo,\n+    }\n+    let a = box(GC) A {\n+        inner: RefCell::new(None),\n+        other: Foo(fail),\n+    };\n+    *a.inner.borrow_mut() = Some(a.clone());\n+}\n+\n+fn main() {\n+    let _ = task::try(proc() {\n+        tld_fail(true);\n+        gc_fail(false);\n+    });\n+\n+    unsafe {\n+        assert_eq!(DROPS, 2);\n+    }\n+}\n+"}]}