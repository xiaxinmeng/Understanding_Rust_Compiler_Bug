{"sha": "9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNzdlMGZiODAxZmQzNTNlNjZlMWY0NTRmZjdiNjkxNmQ0ZmJkYjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-15T22:11:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-15T22:11:32Z"}, "message": "rollup merge of #21005: huonw/deriving-docs\n\nSyntax and a few fixed bugs etc.", "tree": {"sha": "4b7a3d8c52e2103402cbca7ad0d766333f234a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b7a3d8c52e2103402cbca7ad0d766333f234a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5", "html_url": "https://github.com/rust-lang/rust/commit/9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbbe506c10bb07ea2ca6ee6b05ca85ca2177f283", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbbe506c10bb07ea2ca6ee6b05ca85ca2177f283", "html_url": "https://github.com/rust-lang/rust/commit/dbbe506c10bb07ea2ca6ee6b05ca85ca2177f283"}, {"sha": "933303413e4fe97dbfd7e7f0a6f26dfb077696e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/933303413e4fe97dbfd7e7f0a6f26dfb077696e8", "html_url": "https://github.com/rust-lang/rust/commit/933303413e4fe97dbfd7e7f0a6f26dfb077696e8"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "161b27d7abb597e3245c9cb7b0b0c38e476c1bb2", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9a77e0fb801fd353e66e1f454ff7b6916d4fbdb5", "patch": "@@ -21,13 +21,7 @@\n //!   (e.g. `Option<T>`), the parameters are automatically given the\n //!   current trait as a bound. (This includes separate type parameters\n //!   and lifetimes for methods.)\n-//! - Additional bounds on the type parameters, e.g. the `Ord` instance\n-//!   requires an explicit `PartialEq` bound at the\n-//!   moment. (`TraitDef.additional_bounds`)\n-//!\n-//! Unsupported: FIXME #6257: calling methods on reference fields,\n-//! e.g. derive Eq/Ord/Clone don't work on `struct A(&int)`,\n-//! because of how the auto-dereferencing happens.\n+//! - Additional bounds on the type parameters (`TraitDef.additional_bounds`)\n //!\n //! The most important thing for implementers is the `Substructure` and\n //! `SubstructureFields` objects. The latter groups 5 possibilities of the\n@@ -79,6 +73,15 @@\n //! enums (one for each variant). For empty struct and empty enum\n //! variants, it is represented as a count of 0.\n //!\n+//! # \"`cs`\" functions\n+//!\n+//! The `cs_...` functions (\"combine substructure) are designed to\n+//! make life easier by providing some pre-made recipes for common\n+//! tasks; mostly calling the function being derived on all the\n+//! arguments and then combining them back together in some way (or\n+//! letting the user chose that). They are not meant to be the only\n+//! way to handle the structures that this code creates.\n+//!\n //! # Examples\n //!\n //! The following simplified `PartialEq` is used for in-code examples:\n@@ -102,22 +105,22 @@\n //! When generating the `expr` for the `A` impl, the `SubstructureFields` is\n //!\n //! ```{.text}\n-//! Struct(~[FieldInfo {\n+//! Struct(vec![FieldInfo {\n //!            span: <span of x>\n //!            name: Some(<ident of x>),\n //!            self_: <expr for &self.x>,\n-//!            other: ~[<expr for &other.x]\n+//!            other: vec![<expr for &other.x]\n //!          }])\n //! ```\n //!\n //! For the `B` impl, called with `B(a)` and `B(b)`,\n //!\n //! ```{.text}\n-//! Struct(~[FieldInfo {\n+//! Struct(vec![FieldInfo {\n //!           span: <span of `int`>,\n //!           name: None,\n-//!           <expr for &a>\n-//!           ~[<expr for &b>]\n+//!           self_: <expr for &a>\n+//!           other: vec![<expr for &b>]\n //!          }])\n //! ```\n //!\n@@ -128,31 +131,31 @@\n //!\n //! ```{.text}\n //! EnumMatching(0, <ast::Variant for C0>,\n-//!              ~[FieldInfo {\n+//!              vec![FieldInfo {\n //!                 span: <span of int>\n //!                 name: None,\n //!                 self_: <expr for &a>,\n-//!                 other: ~[<expr for &b>]\n+//!                 other: vec![<expr for &b>]\n //!               }])\n //! ```\n //!\n //! For `C1 {x}` and `C1 {x}`,\n //!\n //! ```{.text}\n //! EnumMatching(1, <ast::Variant for C1>,\n-//!              ~[FieldInfo {\n+//!              vec![FieldInfo {\n //!                 span: <span of x>\n //!                 name: Some(<ident of x>),\n //!                 self_: <expr for &self.x>,\n-//!                 other: ~[<expr for &other.x>]\n+//!                 other: vec![<expr for &other.x>]\n //!                }])\n //! ```\n //!\n //! For `C0(a)` and `C1 {x}` ,\n //!\n //! ```{.text}\n //! EnumNonMatchingCollapsed(\n-//!     ~[<ident of self>, <ident of __arg_1>],\n+//!     vec![<ident of self>, <ident of __arg_1>],\n //!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n //!     &[<ident for self index value>, <ident of __arg_1 index value>])\n //! ```\n@@ -168,16 +171,16 @@\n //!\n //! ## Static\n //!\n-//! A static method on the above would result in,\n+//! A static method on the types above would result in,\n //!\n //! ```{.text}\n-//! StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n+//! StaticStruct(<ast::StructDef of A>, Named(vec![(<ident of x>, <span of x>)]))\n //!\n-//! StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n+//! StaticStruct(<ast::StructDef of B>, Unnamed(vec![<span of x>]))\n //!\n-//! StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span of int>])),\n-//!                                   (<ident of C1>, <span of C1>,\n-//!                                    Named(~[(<ident of x>, <span of x>)]))])\n+//! StaticEnum(<ast::EnumDef of C>,\n+//!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of int>])),\n+//!                 (<ident of C1>, <span of C1>, Named(vec![(<ident of x>, <span of x>)]))])\n //! ```\n \n pub use self::StaticFields::*;\n@@ -1378,8 +1381,8 @@ pub fn cs_fold<F>(use_foldl: bool,\n /// process the collected results. i.e.\n ///\n /// ```\n-/// f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n-///              self_2.method(__arg_1_2, __arg_2_2)])\n+/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n+///                  self_2.method(__arg_1_2, __arg_2_2)])\n /// ```\n #[inline]\n pub fn cs_same_method<F>(f: F,"}]}