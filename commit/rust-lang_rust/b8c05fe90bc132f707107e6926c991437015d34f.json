{"sha": "b8c05fe90bc132f707107e6926c991437015d34f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzA1ZmU5MGJjMTMyZjcwNzEwN2U2OTI2Yzk5MTQzNzAxNWQzNGY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-07-21T11:01:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-28T06:27:05Z"}, "message": "rustc: use rvalue scope semantics for constant initializers.", "tree": {"sha": "975ebf9d0a8f261bab2a153974837b61188061af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/975ebf9d0a8f261bab2a153974837b61188061af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c05fe90bc132f707107e6926c991437015d34f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c05fe90bc132f707107e6926c991437015d34f", "html_url": "https://github.com/rust-lang/rust/commit/b8c05fe90bc132f707107e6926c991437015d34f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c05fe90bc132f707107e6926c991437015d34f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2668882406b68739c6ed33d420358d5d710e67b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2668882406b68739c6ed33d420358d5d710e67b", "html_url": "https://github.com/rust-lang/rust/commit/e2668882406b68739c6ed33d420358d5d710e67b"}], "stats": {"total": 76, "additions": 50, "deletions": 26}, "files": [{"sha": "89c7655d944521c9d237a16661e7d2d9383f9d5b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b8c05fe90bc132f707107e6926c991437015d34f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c05fe90bc132f707107e6926c991437015d34f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b8c05fe90bc132f707107e6926c991437015d34f", "patch": "@@ -221,7 +221,9 @@ pub struct RegionMaps {\n     /// table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n-    rvalue_scopes: NodeMap<CodeExtent>,\n+    /// In constants, None is used to indicate that certain expressions\n+    /// escape into 'static and should have no local cleanup scope.\n+    rvalue_scopes: NodeMap<Option<CodeExtent>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -356,9 +358,11 @@ impl<'tcx> RegionMaps {\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: Option<CodeExtent>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        if let Some(lifetime) = lifetime {\n+            assert!(var != lifetime.node_id());\n+        }\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n@@ -387,7 +391,7 @@ impl<'tcx> RegionMaps {\n         // check for a designated rvalue scope\n         if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n             debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n-            return Some(s);\n+            return s;\n         }\n \n         // else, locate the innermost terminating scope\n@@ -801,16 +805,11 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n }\n \n fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n-                           local: &'tcx hir::Local) {\n-    debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n-           local.id,local.init.is_some());\n+                           pat: Option<&'tcx hir::Pat>,\n+                           init: Option<&'tcx hir::Expr>) {\n+    debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n-    // For convenience in trans, associate with the local-id the var\n-    // scope that will be used for any bindings declared in this\n-    // pattern.\n     let blk_scope = visitor.cx.var_parent;\n-    let blk_scope = blk_scope.expect(\"locals must be within a block\");\n-    visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n     // lifetimes, initializers in a let have a temporary lifetime\n@@ -870,15 +869,22 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     //\n     // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n-    if let Some(ref expr) = local.init {\n+    if let Some(expr) = init {\n         record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n \n-        if is_binding_pat(&local.pat) {\n-            record_rvalue_scope(visitor, &expr, blk_scope);\n+        if let Some(pat) = pat {\n+            if is_binding_pat(pat) {\n+                record_rvalue_scope(visitor, &expr, blk_scope);\n+            }\n         }\n     }\n \n-    intravisit::walk_local(visitor, local);\n+    if let Some(pat) = pat {\n+        visitor.visit_pat(pat);\n+    }\n+    if let Some(expr) = init {\n+        visitor.visit_expr(expr);\n+    }\n \n     /// True if `pat` match the `P&` nonterminal:\n     ///\n@@ -952,7 +958,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n         visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         expr: &hir::Expr,\n-        blk_id: CodeExtent)\n+        blk_id: Option<CodeExtent>)\n     {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n@@ -1002,7 +1008,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n-                                     blk_scope: CodeExtent) {\n+                                     blk_scope: Option<CodeExtent>) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n@@ -1075,12 +1081,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         let outer_cx = self.cx;\n         let outer_ts = mem::replace(&mut self.terminating_scopes, NodeSet());\n-\n-        // Only functions have an outer terminating (drop) scope,\n-        // while temporaries in constant initializers are 'static.\n-        if let MirSource::Fn(_) = MirSource::from_node(self.tcx, owner_id) {\n-            self.terminating_scopes.insert(body_id.node_id);\n-        }\n+        self.terminating_scopes.insert(body_id.node_id);\n \n         if let Some(root_id) = self.cx.root_id {\n             self.region_maps.record_fn_parent(body_id.node_id, root_id);\n@@ -1098,7 +1099,30 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         // The body of the every fn is a root scope.\n         self.cx.parent = self.cx.var_parent;\n-        self.visit_expr(&body.value);\n+        if let MirSource::Fn(_) = MirSource::from_node(self.tcx, owner_id) {\n+            self.visit_expr(&body.value);\n+        } else {\n+            // Only functions have an outer terminating (drop) scope, while\n+            // temporaries in constant initializers may be 'static, but only\n+            // according to rvalue lifetime semantics, using the same\n+            // syntactical rules used for let initializers.\n+            //\n+            // E.g. in `let x = &f();`, the temporary holding the result from\n+            // the `f()` call lives for the entirety of the surrounding block.\n+            //\n+            // Similarly, `const X: ... = &f();` would have the result of `f()`\n+            // live for `'static`, implying (if Drop restrictions on constants\n+            // ever get lifted) that the value *could* have a destructor, but\n+            // it'd get leaked instead of the destructor running during the\n+            // evaluation of `X` (if at all allowed by CTFE).\n+            //\n+            // However, `const Y: ... = g(&f());`, like `let y = g(&f());`,\n+            // would *not* let the `f()` temporary escape into an outer scope\n+            // (i.e. `'static`), which means that after `g` returns, it drops,\n+            // and all the associated destruction scope rules apply.\n+            self.cx.var_parent = None;\n+            resolve_local(self, None, Some(&body.value));\n+        }\n \n         // Restore context we had at the start.\n         self.cx = outer_cx;\n@@ -1118,7 +1142,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         resolve_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &'tcx Local) {\n-        resolve_local(self, l);\n+        resolve_local(self, Some(&l.pat), l.init.as_ref().map(|e| &**e));\n     }\n }\n "}]}