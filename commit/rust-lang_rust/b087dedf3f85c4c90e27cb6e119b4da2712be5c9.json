{"sha": "b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwODdkZWRmM2Y4NWM0YzkwZTI3Y2I2ZTExOWI0ZGEyNzEyYmU1Yzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-12T07:31:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-12T07:31:08Z"}, "message": "Auto merge of #45870 - mikeyhew:arbitrary_self_types, r=arielb1\n\nImplement arbitrary_self_types\n\nr? @arielb1\ncc @nikomatsakis\n\nPartial implementation of #44874.  Supports trait and struct methods with arbitrary self types, as long as the type derefs (transitively) to `Self`. Doesn't support raw-pointer `self` yet.\n\nMethods with non-standard self types (i.e. anything other than `&self, &mut self, and Box<Self>`) are not object safe, because dynamic dispatch hasn't been implemented for them yet.\n\nI believe this is also a (partial) fix for #27941.", "tree": {"sha": "d1f64b53857070ed6095261689772904933a1700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1f64b53857070ed6095261689772904933a1700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "html_url": "https://github.com/rust-lang/rust/commit/b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "html_url": "https://github.com/rust-lang/rust/commit/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502"}, {"sha": "77cd993fd1582680cc01ce86d07e52b2e4b34fec", "url": "https://api.github.com/repos/rust-lang/rust/commits/77cd993fd1582680cc01ce86d07e52b2e4b34fec", "html_url": "https://github.com/rust-lang/rust/commit/77cd993fd1582680cc01ce86d07e52b2e4b34fec"}], "stats": {"total": 462, "additions": 349, "deletions": 113}, "files": [{"sha": "4c8a72512f1d0d868579a4c7f384adbbecaaf301", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -633,11 +633,15 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n-        if self.constraints.borrow_mut().insert(constraint, origin).is_none() {\n+        // never overwrite an existing (constraint, origin) - only insert one if it isn't\n+        // present in the map yet. This prevents origins from outside the snapshot being\n+        // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n+        self.constraints.borrow_mut().entry(constraint).or_insert_with(|| {\n             if self.in_snapshot() {\n                 self.undo_log.borrow_mut().push(AddConstraint(constraint));\n             }\n-        }\n+            origin\n+        });\n     }\n \n     fn add_verify(&self, verify: Verify<'tcx>) {"}, {"sha": "facd6350e196c2eda53a83343f2efdab64a38c6b", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -23,6 +23,7 @@ use hir::def_id::DefId;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::subst::Substs;\n+use ty::util::ExplicitSelf;\n use std::borrow::Cow;\n use syntax::ast;\n \n@@ -57,6 +58,10 @@ impl ObjectSafetyViolation {\n                          in its arguments or return type\", name).into(),\n             ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n                 format!(\"method `{}` has generic type parameters\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::NonStandardSelfType) =>\n+                format!(\"method `{}` has a non-standard `self` type. Only `&self`, \\\n+                        `&mut self`, and `Box<Self>` are currently supported \\\n+                        for trait objects\", name).into(),\n             ObjectSafetyViolation::AssociatedConst(name) =>\n                 format!(\"the trait cannot contain associated consts like `{}`\", name).into(),\n         }\n@@ -74,6 +79,9 @@ pub enum MethodViolationCode {\n \n     /// e.g., `fn foo<A>()`\n     Generic,\n+\n+    /// arbitrary `self` type, e.g. `self: Rc<Self>`\n+    NonStandardSelfType,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -260,9 +268,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return Some(MethodViolationCode::StaticMethod);\n         }\n \n+        let sig = self.fn_sig(method.def_id);\n+\n+        let self_ty = self.mk_self_type();\n+        let self_arg_ty = sig.skip_binder().inputs()[0];\n+        if let ExplicitSelf::Other = ExplicitSelf::determine(self_arg_ty, |ty| ty == self_ty) {\n+            return Some(MethodViolationCode::NonStandardSelfType);\n+        }\n+\n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.fn_sig(method.def_id);\n         for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);"}, {"sha": "d12a973017d9bd64856bf89b4d7e14f8598c7195", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -12,6 +12,7 @@\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n+use hir;\n use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n@@ -1178,6 +1179,58 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     layout\n }\n \n+pub enum ExplicitSelf<'tcx> {\n+    ByValue,\n+    ByReference(ty::Region<'tcx>, hir::Mutability),\n+    ByBox,\n+    Other\n+}\n+\n+impl<'tcx> ExplicitSelf<'tcx> {\n+    /// Categorizes an explicit self declaration like `self: SomeType`\n+    /// into either `self`, `&self`, `&mut self`, `Box<self>`, or\n+    /// `Other`.\n+    /// This is mainly used to require the arbitrary_self_types feature\n+    /// in the case of `Other`, to improve error messages in the common cases,\n+    /// and to make `Other` non-object-safe.\n+    ///\n+    /// Examples:\n+    ///\n+    /// ```\n+    /// impl<'a> Foo for &'a T {\n+    ///     // Legal declarations:\n+    ///     fn method1(self: &&'a T); // ExplicitSelf::ByReference\n+    ///     fn method2(self: &'a T); // ExplicitSelf::ByValue\n+    ///     fn method3(self: Box<&'a T>); // ExplicitSelf::ByBox\n+    ///     fn method4(self: Rc<&'a T>); // ExplicitSelf::Other\n+    ///\n+    ///     // Invalid cases will be caught by `check_method_receiver`:\n+    ///     fn method_err1(self: &'a mut T); // ExplicitSelf::Other\n+    ///     fn method_err2(self: &'static T) // ExplicitSelf::ByValue\n+    ///     fn method_err3(self: &&T) // ExplicitSelf::ByReference\n+    /// }\n+    /// ```\n+    ///\n+    pub fn determine<P>(\n+        self_arg_ty: Ty<'tcx>,\n+        is_self_ty: P\n+    ) -> ExplicitSelf<'tcx>\n+    where\n+        P: Fn(Ty<'tcx>) -> bool\n+    {\n+        use self::ExplicitSelf::*;\n+\n+        match self_arg_ty.sty {\n+            _ if is_self_ty(self_arg_ty) => ByValue,\n+            ty::TyRef(region, ty::TypeAndMut { ty, mutbl}) if is_self_ty(ty) => {\n+                ByReference(region, mutbl)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => ByBox,\n+            _ => Other\n+        }\n+    }\n+}\n+\n pub fn provide(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         is_copy_raw,"}, {"sha": "95b19616e5e631e5d75b31ffde1b737cd114915d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -1386,64 +1386,3 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n         vec\n     }\n }\n-\n-pub enum ExplicitSelf<'tcx> {\n-    ByValue,\n-    ByReference(ty::Region<'tcx>, hir::Mutability),\n-    ByBox\n-}\n-\n-impl<'tcx> ExplicitSelf<'tcx> {\n-    /// We wish to (for now) categorize an explicit self\n-    /// declaration like `self: SomeType` into either `self`,\n-    /// `&self`, `&mut self`, or `Box<self>`. We do this here\n-    /// by some simple pattern matching. A more precise check\n-    /// is done later in `check_method_receiver()`.\n-    ///\n-    /// Examples:\n-    ///\n-    /// ```\n-    /// impl Foo for &T {\n-    ///     // Legal declarations:\n-    ///     fn method1(self: &&T); // ExplicitSelf::ByReference\n-    ///     fn method2(self: &T); // ExplicitSelf::ByValue\n-    ///     fn method3(self: Box<&T>); // ExplicitSelf::ByBox\n-    ///\n-    ///     // Invalid cases will be caught later by `check_method_receiver`:\n-    ///     fn method_err1(self: &mut T); // ExplicitSelf::ByReference\n-    /// }\n-    /// ```\n-    ///\n-    /// To do the check we just count the number of \"modifiers\"\n-    /// on each type and compare them. If they are the same or\n-    /// the impl has more, we call it \"by value\". Otherwise, we\n-    /// look at the outermost modifier on the method decl and\n-    /// call it by-ref, by-box as appropriate. For method1, for\n-    /// example, the impl type has one modifier, but the method\n-    /// type has two, so we end up with\n-    /// ExplicitSelf::ByReference.\n-    pub fn determine(untransformed_self_ty: Ty<'tcx>,\n-                     self_arg_ty: Ty<'tcx>)\n-                     -> ExplicitSelf<'tcx> {\n-        fn count_modifiers(ty: Ty) -> usize {\n-            match ty.sty {\n-                ty::TyRef(_, mt) => count_modifiers(mt.ty) + 1,\n-                ty::TyAdt(def, _) if def.is_box() => count_modifiers(ty.boxed_ty()) + 1,\n-                _ => 0,\n-            }\n-        }\n-\n-        let impl_modifiers = count_modifiers(untransformed_self_ty);\n-        let method_modifiers = count_modifiers(self_arg_ty);\n-\n-        if impl_modifiers >= method_modifiers {\n-            ExplicitSelf::ByValue\n-        } else {\n-            match self_arg_ty.sty {\n-                ty::TyRef(r, mt) => ExplicitSelf::ByReference(r, mt.mutbl),\n-                ty::TyAdt(def, _) if def.is_box() => ExplicitSelf::ByBox,\n-                _ => ExplicitSelf::ByValue,\n-            }\n-        }\n-    }\n-}"}, {"sha": "2c44c40d83d49012d860fa4c9f719e4fd7c93354", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -13,6 +13,7 @@ use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n+use rustc::ty::util::ExplicitSelf;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n@@ -21,7 +22,6 @@ use rustc::util::common::ErrorReported;\n use syntax_pos::Span;\n \n use super::{Inherited, FnCtxt};\n-use astconv::ExplicitSelf;\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -503,12 +503,17 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n         let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n-        match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n-            ExplicitSelf::ByValue => \"self\".to_string(),\n-            ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n-            ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_string(),\n-            _ => format!(\"self: {}\", self_arg_ty)\n-        }\n+        let param_env = ty::ParamEnv::empty(Reveal::All);\n+\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n+            match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n+                ExplicitSelf::ByValue => \"self\".to_string(),\n+                ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n+                ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_string(),\n+                _ => format!(\"self: {}\", self_arg_ty)\n+            }\n+        })\n     };\n \n     match (trait_m.method_has_self_argument, impl_m.method_has_self_argument) {"}, {"sha": "37cf67fe53ef646de897fcab94d7e2fa6f4ef550", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -8,19 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use astconv::ExplicitSelf;\n use check::{Inherited, FnCtxt};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n use hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::util::ExplicitSelf;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::middle::lang_items;\n \n use syntax::ast;\n+use syntax::feature_gate::{self, GateIssue};\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use errors::{DiagnosticBuilder, DiagnosticId};\n \n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n@@ -451,8 +452,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                          method: &ty::AssociatedItem,\n                                          self_ty: Ty<'tcx>)\n     {\n-        // check that the type of the method's receiver matches the\n-        // method's first parameter.\n+        // check that the method has a valid receiver type, given the type `Self`\n         debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n                method, self_ty);\n \n@@ -468,26 +468,57 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n \n+        let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n+        let self_ty = fcx.liberate_late_bound_regions(\n+            method.def_id,\n+            &ty::Binder(self_ty)\n+        );\n+\n         let self_arg_ty = sig.inputs()[0];\n-        let rcvr_ty = match ExplicitSelf::determine(self_ty, self_arg_ty) {\n-            ExplicitSelf::ByValue => self_ty,\n-            ExplicitSelf::ByReference(region, mutbl) => {\n-                fcx.tcx.mk_ref(region, ty::TypeAndMut {\n-                    ty: self_ty,\n-                    mutbl,\n-                })\n+\n+        let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n+        let self_arg_ty = fcx.normalize_associated_types_in(span, &self_arg_ty);\n+        let self_arg_ty = fcx.liberate_late_bound_regions(\n+            method.def_id,\n+            &ty::Binder(self_arg_ty)\n+        );\n+\n+        let mut autoderef = fcx.autoderef(span, self_arg_ty);\n+\n+        loop {\n+            if let Some((potential_self_ty, _)) = autoderef.next() {\n+                debug!(\"check_method_receiver: potential self type `{:?}` to match `{:?}`\",\n+                    potential_self_ty, self_ty);\n+\n+                if fcx.infcx.can_eq(fcx.param_env, self_ty, potential_self_ty).is_ok() {\n+                    autoderef.finalize();\n+                    if let Some(mut err) = fcx.demand_eqtype_with_origin(\n+                        &cause, self_ty, potential_self_ty) {\n+                        err.emit();\n+                    }\n+                    break\n+                }\n+            } else {\n+                fcx.tcx.sess.diagnostic().mut_span_err(\n+                    span, &format!(\"invalid `self` type: {:?}\", self_arg_ty))\n+                .note(&format!(\"type must be `{:?}` or a type that dereferences to it`\", self_ty))\n+                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                .code(DiagnosticId::Error(\"E0307\".into()))\n+                .emit();\n+                return\n             }\n-            ExplicitSelf::ByBox => fcx.tcx.mk_box(self_ty)\n-        };\n-        let rcvr_ty = fcx.normalize_associated_types_in(span, &rcvr_ty);\n-        let rcvr_ty = fcx.liberate_late_bound_regions(method.def_id,\n-                                                      &ty::Binder(rcvr_ty));\n+        }\n \n-        debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n+        let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n+        let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n \n-        let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n-        if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, rcvr_ty, self_arg_ty) {\n-            err.emit();\n+        if let ExplicitSelf::Other = self_kind {\n+            if !fcx.tcx.sess.features.borrow().arbitrary_self_types {\n+                feature_gate::feature_err(&fcx.tcx.sess.parse_sess, \"arbitrary_self_types\", span,\n+                    GateIssue::Language, \"arbitrary `self` types are unstable\")\n+                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                .emit();\n+            }\n         }\n     }\n "}, {"sha": "73bec697d492e408c9bfe43c00efb137587f906e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -4724,6 +4724,7 @@ register_diagnostics! {\n //  E0247,\n //  E0248, // value used as a type, now reported earlier during resolution as E0412\n //  E0249,\n+    E0307, // invalid method `self` type\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n //  E0372, // coherence not object safe\n     E0377, // the trait `CoerceUnsized` may only be implemented for a coercion"}, {"sha": "b6cb3ac13081f462c731c2bc8bb1f4b1972881b2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -409,6 +409,9 @@ declare_features! (\n \n     // extern types\n     (active, extern_types, \"1.23.0\", Some(43467)),\n+\n+    // Allow trait methods with arbitrary self types\n+    (active, arbitrary_self_types, \"1.23.0\", Some(44874)),\n );\n \n declare_features! ("}, {"sha": "6b10739bd8e59ef6e6e6398d66148bf2c447d32d", "filename": "src/test/compile-fail/arbitrary-self-types-not-object-safe.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Farbitrary-self-types-not-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Farbitrary-self-types-not-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farbitrary-self-types-not-object-safe.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(arbitrary_self_types)]\n+\n+use std::rc::Rc;\n+\n+trait Foo {\n+    fn foo(self: Rc<Self>) -> usize;\n+}\n+\n+trait Bar {\n+    fn foo(self: Rc<Self>) -> usize where Self: Sized;\n+    fn bar(self: Box<Self>) -> usize;\n+}\n+\n+impl Foo for usize {\n+    fn foo(self: Rc<Self>) -> usize {\n+        *self\n+    }\n+}\n+\n+impl Bar for usize {\n+    fn foo(self: Rc<Self>) -> usize {\n+        *self\n+    }\n+\n+    fn bar(self: Box<Self>) -> usize {\n+        *self\n+    }\n+}\n+\n+fn make_foo() {\n+    let x = Box::new(5usize) as Box<Foo>;\n+    //~^ ERROR E0038\n+    //~| NOTE method `foo` has a non-standard `self` type\n+    //~| NOTE the trait `Foo` cannot be made into an object\n+    //~| ERROR E0038\n+    //~| NOTE method `foo` has a non-standard `self` type\n+    //~| NOTE the trait `Foo` cannot be made into an object\n+    //~| NOTE requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<Foo>>`\n+}\n+\n+fn make_bar() {\n+    let x = Box::new(5usize) as Box<Bar>;\n+    x.bar();\n+}\n+\n+fn main() {}"}, {"sha": "ff0306f199310c271a112045bf5073571661f927", "filename": "src/test/compile-fail/feature-gate-arbitrary-self-types.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-arbitrary-self-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-arbitrary-self-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-arbitrary-self-types.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+trait Foo {\n+    fn foo(self: Rc<Box<Self>>); //~ ERROR arbitrary `self` types are unstable\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn foo(self: Rc<Box<Self>>) {} //~ ERROR arbitrary `self` types are unstable\n+}\n+\n+impl Bar {\n+    fn bar(self: Box<Rc<Self>>) {} //~ ERROR arbitrary `self` types are unstable\n+}\n+\n+fn main() {}"}, {"sha": "1d5ef4360dc1ebc9134451f2cdd0b70eab6c7f66", "filename": "src/test/compile-fail/issue-17740.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -15,12 +15,12 @@ struct Foo<'a> {\n impl <'a> Foo<'a>{\n     fn bar(self: &mut Foo) {\n     //~^ mismatched method receiver\n-    //~| expected type `&mut Foo<'a>`\n-    //~| found type `&mut Foo<'_>`\n+    //~| expected type `Foo<'a>`\n+    //~| found type `Foo<'_>`\n     //~| lifetime mismatch\n     //~| mismatched method receiver\n-    //~| expected type `&mut Foo<'a>`\n-    //~| found type `&mut Foo<'_>`\n+    //~| expected type `Foo<'a>`\n+    //~| found type `Foo<'_>`\n     //~| lifetime mismatch\n     }\n }"}, {"sha": "7ddd56229ceb772c0a7dd04864b905949a000e92", "filename": "src/test/compile-fail/issue-26194.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Fissue-26194.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Fissue-26194.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26194.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -12,7 +12,7 @@ struct S(String);\n \n impl S {\n     fn f(self: *mut S) -> String { self.0 }\n-    //~^ ERROR mismatched method receiver\n+    //~^ ERROR invalid `self` type\n }\n \n fn main() { S(\"\".to_owned()).f(); }"}, {"sha": "a0d1f2dc3312e4b5784ac7d726303659ef0b6b48", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -15,7 +15,8 @@ struct Foo {\n }\n \n impl Foo {\n-    fn foo(self: isize, x: isize) -> isize {  //~ ERROR mismatched method receiver\n+    fn foo(self: isize, x: isize) -> isize {\n+        //~^ ERROR invalid `self` type\n         self.f + x\n     }\n }\n@@ -25,10 +26,12 @@ struct Bar<T> {\n }\n \n impl<T> Bar<T> {\n-    fn foo(self: Bar<isize>, x: isize) -> isize { //~ ERROR mismatched method receiver\n+    fn foo(self: Bar<isize>, x: isize) -> isize {\n+        //~^ ERROR invalid `self` type\n         x\n     }\n-    fn bar(self: &Bar<usize>, x: isize) -> isize {   //~ ERROR mismatched method receiver\n+    fn bar(self: &Bar<usize>, x: isize) -> isize {\n+        //~^ ERROR invalid `self` type\n         x\n     }\n }\n@@ -45,12 +48,12 @@ impl<'a, T> SomeTrait for &'a Bar<T> {\n     //~^ ERROR mismatched method receiver\n     fn dummy3(self: &&Bar<T>) {}\n     //~^ ERROR mismatched method receiver\n-    //~| expected type `&&'a Bar<T>`\n-    //~| found type `&&Bar<T>`\n+    //~| expected type `&'a Bar<T>`\n+    //~| found type `&Bar<T>`\n     //~| lifetime mismatch\n     //~| ERROR mismatched method receiver\n-    //~| expected type `&&'a Bar<T>`\n-    //~| found type `&&Bar<T>`\n+    //~| expected type `&'a Bar<T>`\n+    //~| found type `&Bar<T>`\n     //~| lifetime mismatch\n }\n "}, {"sha": "755a8d7ea294fc4786010e9f63fb5cc5269eb968", "filename": "src/test/run-pass/arbitrary_self_types_silly.rs", "status": "renamed", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_silly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_silly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_silly.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,14 +7,23 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-use std::rc::Rc;\n+#![feature(arbitrary_self_types)]\n \n struct Foo;\n+struct Bar;\n+\n+impl std::ops::Deref for Bar {\n+    type Target = Foo;\n+\n+    fn deref(&self) -> &Foo {\n+        &Foo\n+    }\n+}\n \n impl Foo {\n-    fn x(self: Rc<Foo>) {} //~ ERROR E0308\n+    fn bar(self: Bar) -> i32 { 3 }\n }\n \n fn main() {\n+    assert_eq!(3, Bar.bar());\n }", "previous_filename": "src/test/compile-fail/E0308-2.rs"}, {"sha": "961717de0463e32e7e862ea32930c6d81b7b6d38", "filename": "src/test/run-pass/arbitrary_self_types_struct.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_struct.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(arbitrary_self_types)]\n+\n+use std::rc::Rc;\n+\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+\n+impl Foo {\n+    fn x(self: &Rc<Self>) -> i32 {\n+        self.x\n+    }\n+\n+    fn y(self: Rc<Self>) -> i32 {\n+        self.y\n+    }\n+}\n+\n+fn main() {\n+    let foo = Rc::new(Foo {x: 3, y: 4});\n+    assert_eq!(3, foo.x());\n+    assert_eq!(4, foo.y());\n+}"}, {"sha": "e74d614dd6bd9eb1aa1a316d1a19a884906259ce", "filename": "src/test/run-pass/arbitrary_self_types_trait.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_trait.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(arbitrary_self_types)]\n+\n+use std::rc::Rc;\n+\n+trait Trait {\n+    fn trait_method<'a>(self: &'a Box<Rc<Self>>) -> &'a [i32];\n+}\n+\n+impl Trait for Vec<i32> {\n+    fn trait_method<'a>(self: &'a Box<Rc<Self>>) -> &'a [i32] {\n+        &***self\n+    }\n+}\n+\n+fn main() {\n+    let v = vec![1,2,3];\n+\n+    assert_eq!(&[1,2,3], Box::new(Rc::new(v)).trait_method());\n+}"}, {"sha": "8dc40e7aab111b8a9f6a2f4e3c992446bdf7a8e0", "filename": "src/test/run-pass/arbitrary_self_types_unsized_struct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_unsized_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_unsized_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_unsized_struct.rs?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(arbitrary_self_types)]\n+\n+use std::rc::Rc;\n+\n+struct Foo<T: ?Sized>(T);\n+\n+impl Foo<[u8]> {\n+    fn len(self: Rc<Self>) -> usize {\n+        self.0.len()\n+    }\n+}\n+\n+fn main() {\n+    let rc = Rc::new(Foo([1u8,2,3])) as Rc<Foo<[u8]>>;\n+    assert_eq!(3, rc.len());\n+}"}, {"sha": "e12fb57f15dc9aa45d74746b009e6613a362fa2d", "filename": "src/test/ui/span/issue-27522.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fui%2Fspan%2Fissue-27522.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fui%2Fspan%2Fissue-27522.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-27522.stderr?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -1,11 +1,11 @@\n-error[E0308]: mismatched method receiver\n+error[E0307]: invalid `self` type: &SomeType\n   --> $DIR/issue-27522.rs:16:22\n    |\n 16 |     fn handler(self: &SomeType);\n-   |                      ^^^^^^^^^ expected Self, found struct `SomeType`\n+   |                      ^^^^^^^^^\n    |\n-   = note: expected type `&Self`\n-              found type `&SomeType`\n+   = note: type must be `Self` or a type that dereferences to it`\n+   = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n \n error: aborting due to previous error\n "}, {"sha": "adeabd91302ce9e6925b1d95e4c5f800337f5cd9", "filename": "src/test/ui/static-lifetime.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fui%2Fstatic-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b087dedf3f85c4c90e27cb6e119b4da2712be5c9/src%2Ftest%2Fui%2Fstatic-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic-lifetime.stderr?ref=b087dedf3f85c4c90e27cb6e119b4da2712be5c9", "patch": "@@ -1,10 +1,15 @@\n-error[E0477]: the type `std::borrow::Cow<'a, A>` does not fulfill the required lifetime\n+error[E0478]: lifetime bound not satisfied\n   --> $DIR/static-lifetime.rs:13:20\n    |\n 13 | impl<'a, A: Clone> Arbitrary for ::std::borrow::Cow<'a, A> {}\n    |                    ^^^^^^^^^\n    |\n-   = note: type must satisfy the static lifetime\n+note: lifetime parameter instantiated with the lifetime 'a as defined on the impl at 13:1\n+  --> $DIR/static-lifetime.rs:13:1\n+   |\n+13 | impl<'a, A: Clone> Arbitrary for ::std::borrow::Cow<'a, A> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: but lifetime parameter must outlive the static lifetime\n \n error: aborting due to previous error\n "}]}