{"sha": "00c87a6486428b072199809b051beea1124f616f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYzg3YTY0ODY0MjhiMDcyMTk5ODA5YjA1MWJlZWExMTI0ZjYxNmY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-05-25T01:50:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-25T01:50:01Z"}, "message": "Rollup merge of #42134 - scottmcm:rangeinclusive-struct, r=aturon\n\nMake RangeInclusive just a two-field struct\n\nNot being an enum improves ergonomics and consistency, especially since NonEmpty variant wasn't prevented from being empty.  It can still be iterable without an extra \"done\" bit by making the range have !(start <= end), which is even possible without changing the Step trait.\n\nImplements merged https://github.com/rust-lang/rfcs/pull/1980; tracking issue https://github.com/rust-lang/rust/issues/28237.\n\nThis is definitely a breaking change to anything consuming `RangeInclusive` directly (not as an Iterator) or constructing it without using the sugar.  Is there some change that would make sense before this so compilation failures could be compatibly fixed ahead of time?\n\nr? @aturon (as FCP proposer on the RFC)", "tree": {"sha": "bf99a9d33045f51496702bbf61788d8e4adf6b68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf99a9d33045f51496702bbf61788d8e4adf6b68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00c87a6486428b072199809b051beea1124f616f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00c87a6486428b072199809b051beea1124f616f", "html_url": "https://github.com/rust-lang/rust/commit/00c87a6486428b072199809b051beea1124f616f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00c87a6486428b072199809b051beea1124f616f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989c8e86e16ddfa146cd3ba2557d9becb2841a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/989c8e86e16ddfa146cd3ba2557d9becb2841a89", "html_url": "https://github.com/rust-lang/rust/commit/989c8e86e16ddfa146cd3ba2557d9becb2841a89"}, {"sha": "7eaca60f3b3b783ffa1e80ccf91e820f9436b3a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eaca60f3b3b783ffa1e80ccf91e820f9436b3a3", "html_url": "https://github.com/rust-lang/rust/commit/7eaca60f3b3b783ffa1e80ccf91e820f9436b3a3"}], "stats": {"total": 404, "additions": 149, "deletions": 255}, "files": [{"sha": "bc8566e8cbeb375b6b066b0ddd368eb7ee883dfb", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -106,16 +106,10 @@ impl<T> RangeArgument<T> for Range<T> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<T> RangeArgument<T> for RangeInclusive<T> {\n     fn start(&self) -> Bound<&T> {\n-        match *self {\n-            RangeInclusive::Empty{ ref at }            => Included(at),\n-            RangeInclusive::NonEmpty { ref start, .. } => Included(start),\n-        }\n+        Included(&self.start)\n     }\n     fn end(&self) -> Bound<&T> {\n-        match *self {\n-            RangeInclusive::Empty{ ref at }            => Excluded(at),\n-            RangeInclusive::NonEmpty { ref end, .. }   => Included(end),\n-        }\n+        Included(&self.end)\n     }\n }\n "}, {"sha": "02d38ccea44eadcb2b95caee0450fbecd7d8d279", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 55, "deletions": 119, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -403,61 +403,35 @@ impl<A: Step + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        use ops::RangeInclusive::*;\n-\n-        // this function has a sort of odd structure due to borrowck issues\n-        // we may need to replace self.range, so borrows of start and end need to end early\n-\n-        let (finishing, n) = match self.range {\n-            Empty { .. } => return None, // empty iterators yield no values\n-\n-            NonEmpty { ref mut start, ref mut end } => {\n-                let rev = self.step_by.is_negative();\n-\n-                // march start towards (maybe past!) end and yield the old value\n-                if (rev && start >= end) ||\n-                   (!rev && start <= end)\n-                {\n-                    match start.step(&self.step_by) {\n-                        Some(mut n) => {\n-                            mem::swap(start, &mut n);\n-                            (None, Some(n)) // yield old value, remain non-empty\n-                        },\n-                        None => {\n-                            let mut n = end.clone();\n-                            mem::swap(start, &mut n);\n-                            (None, Some(n)) // yield old value, remain non-empty\n-                        }\n-                    }\n-                } else {\n-                    // found range in inconsistent state (start at or past end), so become empty\n-                    (Some(end.replace_zero()), None)\n-                }\n-            }\n-        };\n+        let rev = self.step_by.is_negative();\n \n-        // turn into an empty iterator if we've reached the end\n-        if let Some(end) = finishing {\n-            self.range = Empty { at: end };\n+        if (rev && self.range.start >= self.range.end) ||\n+           (!rev && self.range.start <= self.range.end)\n+        {\n+            match self.range.start.step(&self.step_by) {\n+                Some(n) => {\n+                    Some(mem::replace(&mut self.range.start, n))\n+                },\n+                None => {\n+                    let last = self.range.start.replace_one();\n+                    self.range.end.replace_zero();\n+                    self.step_by.replace_one();\n+                    Some(last)\n+                },\n+            }\n+        }\n+        else {\n+            None\n         }\n-\n-        n\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        use ops::RangeInclusive::*;\n-\n-        match self.range {\n-            Empty { .. } => (0, Some(0)),\n-\n-            NonEmpty { ref start, ref end } =>\n-                match Step::steps_between(start,\n-                                          end,\n-                                          &self.step_by) {\n-                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n-                    None       => (0, None)\n-                }\n+        match Step::steps_between(&self.range.start,\n+                                  &self.range.end,\n+                                  &self.step_by) {\n+            Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+            None       => (0, None)\n         }\n     }\n }\n@@ -583,56 +557,31 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> where\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        use ops::RangeInclusive::*;\n-\n-        // this function has a sort of odd structure due to borrowck issues\n-        // we may need to replace self, so borrows of self.start and self.end need to end early\n-\n-        let (finishing, n) = match *self {\n-            Empty { .. } => (None, None), // empty iterators yield no values\n-\n-            NonEmpty { ref mut start, ref mut end } => {\n-                if start == end {\n-                    (Some(end.replace_one()), Some(start.replace_one()))\n-                } else if start < end {\n-                    let mut n = start.add_one();\n-                    mem::swap(&mut n, start);\n-\n-                    // if the iterator is done iterating, it will change from\n-                    // NonEmpty to Empty to avoid unnecessary drops or clones,\n-                    // we'll reuse either start or end (they are equal now, so\n-                    // it doesn't matter which) to pull out end, we need to swap\n-                    // something back in\n-\n-                    (if n == *end { Some(end.replace_one()) } else { None },\n-                    // ^ are we done yet?\n-                    Some(n)) // < the value to output\n-                } else {\n-                    (Some(start.replace_one()), None)\n-                }\n-            }\n-        };\n-\n-        // turn into an empty iterator if this is the last value\n-        if let Some(end) = finishing {\n-            *self = Empty { at: end };\n+        use cmp::Ordering::*;\n+\n+        match self.start.partial_cmp(&self.end) {\n+            Some(Less) => {\n+                let n = self.start.add_one();\n+                Some(mem::replace(&mut self.start, n))\n+            },\n+            Some(Equal) => {\n+                let last = self.start.replace_one();\n+                self.end.replace_zero();\n+                Some(last)\n+            },\n+            _ => None,\n         }\n-\n-        n\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        use ops::RangeInclusive::*;\n-\n-        match *self {\n-            Empty { .. } => (0, Some(0)),\n+        if !(self.start <= self.end) {\n+            return (0, Some(0));\n+        }\n \n-            NonEmpty { ref start, ref end } =>\n-                match Step::steps_between_by_one(start, end) {\n-                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n-                    None => (0, None),\n-                }\n+        match Step::steps_between_by_one(&self.start, &self.end) {\n+            Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+            None => (0, None),\n         }\n     }\n }\n@@ -644,33 +593,20 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        use ops::RangeInclusive::*;\n-\n-        // see Iterator::next for comments\n-\n-        let (finishing, n) = match *self {\n-            Empty { .. } => return None,\n-\n-            NonEmpty { ref mut start, ref mut end } => {\n-                if start == end {\n-                    (Some(start.replace_one()), Some(end.replace_one()))\n-                } else if start < end {\n-                    let mut n = end.sub_one();\n-                    mem::swap(&mut n, end);\n-\n-                    (if n == *start { Some(start.replace_one()) } else { None },\n-                     Some(n))\n-                } else {\n-                    (Some(end.replace_one()), None)\n-                }\n-            }\n-        };\n-\n-        if let Some(start) = finishing {\n-            *self = Empty { at: start };\n+        use cmp::Ordering::*;\n+\n+        match self.start.partial_cmp(&self.end) {\n+            Some(Less) => {\n+                let n = self.end.sub_one();\n+                Some(mem::replace(&mut self.end, n))\n+            },\n+            Some(Equal) => {\n+                let last = self.end.replace_zero();\n+                self.start.replace_one();\n+                Some(last)\n+            },\n+            _ => None,\n         }\n-\n-        n\n     }\n }\n "}, {"sha": "59c3a9a8afa02ed2a0c6623a1aafb1a3078211b8", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -2271,7 +2271,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n /// fn main() {\n-///     assert_eq!((3...5), std::ops::RangeInclusive::NonEmpty{ start: 3, end: 5 });\n+///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n ///     assert_eq!(3+4+5, (3...5).sum());\n ///\n ///     let arr = [0, 1, 2, 3];\n@@ -2281,45 +2281,23 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-pub enum RangeInclusive<Idx> {\n-    /// Empty range (iteration has finished)\n+pub struct RangeInclusive<Idx> {\n+    /// The lower bound of the range (inclusive).\n     #[unstable(feature = \"inclusive_range\",\n                reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n-    Empty {\n-        /// The point at which iteration finished\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n-        at: Idx\n-    },\n-    /// Non-empty range (iteration will yield value(s))\n+    pub start: Idx,\n+    /// The upper bound of the range (inclusive).\n     #[unstable(feature = \"inclusive_range\",\n                reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n-    NonEmpty {\n-        /// The lower bound of the range (inclusive).\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n-        start: Idx,\n-        /// The upper bound of the range (inclusive).\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n-        end: Idx,\n-    },\n+    pub end: Idx,\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        use self::RangeInclusive::*;\n-\n-        match *self {\n-            Empty { ref at } => write!(fmt, \"[empty range @ {:?}]\", at),\n-            NonEmpty { ref start, ref end } => write!(fmt, \"{:?}...{:?}\", start, end),\n-        }\n+        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n     }\n }\n \n@@ -2341,9 +2319,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n-        if let &RangeInclusive::NonEmpty{ref start, ref end} = self {\n-            (*start <= item) && (item <= *end)\n-        } else { false }\n+        self.start <= item && item <= self.end\n     }\n }\n "}, {"sha": "cef3682fd94d74859a69f0207b2796555520154a", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -981,95 +981,82 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => Some(&[]),\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get(slice),\n-        }\n+        if self.end == usize::max_value() { None }\n+        else { (self.start..self.end + 1).get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => Some(&mut []),\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_mut(slice),\n-        }\n+        if self.end == usize::max_value() { None }\n+        else { (self.start..self.end + 1).get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &[],\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_unchecked(slice),\n-        }\n+        (self.start..self.end + 1).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &mut [],\n-            ops::RangeInclusive::NonEmpty { start, end } => {\n-                (start..end + 1).get_unchecked_mut(slice)\n-            }\n-        }\n+        (self.start..self.end + 1).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &[],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n-                panic!(\"attempted to index slice up to maximum usize\");\n-            },\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index(slice),\n-        }\n+        assert!(self.end != usize::max_value(),\n+            \"attempted to index slice up to maximum usize\");\n+        (self.start..self.end + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        match self {\n-            ops::RangeInclusive::Empty { .. } => &mut [],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n-                panic!(\"attempted to index slice up to maximum usize\");\n-            },\n-            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index_mut(slice),\n-        }\n+        assert!(self.end != usize::max_value(),\n+            \"attempted to index slice up to maximum usize\");\n+        (self.start..self.end + 1).index_mut(slice)\n     }\n }\n \n+#[cfg(stage0)] // The bootstrap compiler has a different `...` desugar\n+fn inclusive(start: usize, end: usize) -> ops::RangeInclusive<usize> {\n+    ops::RangeInclusive { start, end }\n+}\n+#[cfg(not(stage0))]\n+fn inclusive(start: usize, end: usize) -> ops::RangeInclusive<usize> {\n+    start...end\n+}\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        (0...self.end).get(slice)\n+        inclusive(0, self.end).get(slice)\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        (0...self.end).get_mut(slice)\n+        inclusive(0, self.end).get_mut(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0...self.end).get_unchecked(slice)\n+        inclusive(0, self.end).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0...self.end).get_unchecked_mut(slice)\n+        inclusive(0, self.end).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        (0...self.end).index(slice)\n+        inclusive(0, self.end).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0...self.end).index_mut(slice)\n+        inclusive(0, self.end).index_mut(slice)\n     }\n }\n "}, {"sha": "547a4899c7118c85e9bf6ceffaaab190401ac988", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -1724,15 +1724,12 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n-            match index {\n-                ops::RangeInclusive::Empty { .. } => \"\",\n-                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                    panic!(\"attempted to index slice up to maximum usize\"),\n-                ops::RangeInclusive::NonEmpty { start, end } =>\n-                    self.index(start .. end+1)\n-            }\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index(index.start .. index.end+1)\n         }\n     }\n+\n     #[unstable(feature = \"inclusive_range\",\n                reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n@@ -1741,7 +1738,9 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n-            self.index(0...index.end)\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index(.. index.end+1)\n         }\n     }\n \n@@ -1751,13 +1750,9 @@ mod traits {\n     impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n-            match index {\n-                ops::RangeInclusive::Empty { .. } => &mut self[0..0], // `&mut \"\"` doesn't work\n-                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                    panic!(\"attempted to index str up to maximum usize\"),\n-                    ops::RangeInclusive::NonEmpty { start, end } =>\n-                        self.index_mut(start .. end+1)\n-            }\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index_mut(index.start .. index.end+1)\n         }\n     }\n     #[unstable(feature = \"inclusive_range\",\n@@ -1766,7 +1761,9 @@ mod traits {\n     impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n-            self.index_mut(0...index.end)\n+            assert!(index.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n+            self.index_mut(.. index.end+1)\n         }\n     }\n \n@@ -1948,45 +1945,27 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get(slice)\n+            (self.start..self.end+1).get(slice)\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get_mut(slice)\n+            (self.start..self.end+1).get_mut(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get_unchecked(slice)\n+            (self.start..self.end+1).get_unchecked(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.get_unchecked_mut(slice)\n+            (self.start..self.end+1).get_unchecked_mut(slice)\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.index(slice)\n+            (self.start..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            match self {\n-                ops::RangeInclusive::Empty { .. } => 0..0,\n-                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n-            }.index_mut(slice)\n+            (self.start..self.end+1).index_mut(slice)\n         }\n     }\n "}, {"sha": "8c4cd1d0c84583b20e961f9151c0e363686dbcac", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -22,6 +22,7 @@\n #![feature(fmt_internals)]\n #![feature(iterator_step_by)]\n #![feature(i128_type)]\n+#![feature(inclusive_range)]\n #![feature(iter_rfind)]\n #![feature(libc)]\n #![feature(nonzero)]"}, {"sha": "b81b3878c9d6e1d4c82a117f46107a17cf170b0b", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::ops::{Range, RangeFull, RangeFrom, RangeTo};\n+use core::ops::{Range, RangeFull, RangeFrom, RangeTo, RangeInclusive};\n \n // Test the Range structs without the syntactic sugar.\n \n@@ -47,3 +47,24 @@ fn test_full_range() {\n     // Not much to test.\n     let _ = RangeFull;\n }\n+\n+#[test]\n+fn test_range_inclusive() {\n+    let mut r = RangeInclusive { start: 1i8, end: 2 };\n+    assert_eq!(r.next(), Some(1));\n+    assert_eq!(r.next(), Some(2));\n+    assert_eq!(r.next(), None);\n+\n+    r = RangeInclusive { start: 127i8, end: 127 };\n+    assert_eq!(r.next(), Some(127));\n+    assert_eq!(r.next(), None);\n+\n+    r = RangeInclusive { start: -128i8, end: -128 };\n+    assert_eq!(r.next_back(), Some(-128));\n+    assert_eq!(r.next_back(), None);\n+\n+    // degenerate\n+    r = RangeInclusive { start: 1, end: -1 };\n+    assert_eq!(r.size_hint(), (0, Some(0)));\n+    assert_eq!(r.next(), None);\n+}\n\\ No newline at end of file"}, {"sha": "d359c69d3a092842e8868c63b03d9c3fa43b9d9d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -1934,13 +1934,13 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Range(ref e1, ref e2, lims) => {\n                 use syntax::ast::RangeLimits::*;\n \n-                let (path, variant) = match (e1, e2, lims) {\n-                    (&None, &None, HalfOpen) => (\"RangeFull\", None),\n-                    (&Some(..), &None, HalfOpen) => (\"RangeFrom\", None),\n-                    (&None, &Some(..), HalfOpen) => (\"RangeTo\", None),\n-                    (&Some(..), &Some(..), HalfOpen) => (\"Range\", None),\n-                    (&None, &Some(..), Closed) => (\"RangeToInclusive\", None),\n-                    (&Some(..), &Some(..), Closed) => (\"RangeInclusive\", Some(\"NonEmpty\")),\n+                let path = match (e1, e2, lims) {\n+                    (&None, &None, HalfOpen) => \"RangeFull\",\n+                    (&Some(..), &None, HalfOpen) => \"RangeFrom\",\n+                    (&None, &Some(..), HalfOpen) => \"RangeTo\",\n+                    (&Some(..), &Some(..), HalfOpen) => \"Range\",\n+                    (&None, &Some(..), Closed) => \"RangeToInclusive\",\n+                    (&Some(..), &Some(..), Closed) => \"RangeInclusive\",\n                     (_, &None, Closed) =>\n                         panic!(self.diagnostic().span_fatal(\n                             e.span, \"inclusive range with no end\")),\n@@ -1957,7 +1957,7 @@ impl<'a> LoweringContext<'a> {\n                 let is_unit = fields.is_empty();\n                 let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n                 let struct_path =\n-                    iter::once(\"ops\").chain(iter::once(path)).chain(variant)\n+                    iter::once(\"ops\").chain(iter::once(path))\n                     .collect::<Vec<_>>();\n                 let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));"}, {"sha": "372d4a8b732acfb44151cd560e3d489653ffd179", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00c87a6486428b072199809b051beea1124f616f/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c87a6486428b072199809b051beea1124f616f/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=00c87a6486428b072199809b051beea1124f616f", "patch": "@@ -82,7 +82,7 @@ pub fn main() {\n     short.next();\n     assert_eq!(long.size_hint(), (255, Some(255)));\n     assert_eq!(short.size_hint(), (0, Some(0)));\n-    assert_eq!(short, RangeInclusive::Empty { at: 42 });\n+    assert_eq!(short, 1...0);\n \n     assert_eq!(long.len(), 255);\n     assert_eq!(short.len(), 0);\n@@ -97,28 +97,28 @@ pub fn main() {\n     for i in 3...251 {\n         assert_eq!(long.next(), Some(i));\n     }\n-    assert_eq!(long, RangeInclusive::Empty { at: 251 });\n+    assert_eq!(long, 1...0);\n \n     // check underflow\n     let mut narrow = 1...0;\n     assert_eq!(narrow.next_back(), None);\n-    assert_eq!(narrow, RangeInclusive::Empty { at: 0 });\n+    assert_eq!(narrow, 1...0);\n     let mut zero = 0u8...0;\n     assert_eq!(zero.next_back(), Some(0));\n     assert_eq!(zero.next_back(), None);\n-    assert_eq!(zero, RangeInclusive::Empty { at: 0 });\n+    assert_eq!(zero, 1...0);\n     let mut high = 255u8...255;\n     assert_eq!(high.next_back(), Some(255));\n     assert_eq!(high.next_back(), None);\n-    assert_eq!(high, RangeInclusive::Empty { at: 255 });\n+    assert_eq!(high, 1...0);\n \n     // what happens if you have a nonsense range?\n     let mut nonsense = 10...5;\n     assert_eq!(nonsense.next(), None);\n-    assert_eq!(nonsense, RangeInclusive::Empty { at: 10 });\n+    assert_eq!(nonsense, 10...5);\n \n     // output\n     assert_eq!(format!(\"{:?}\", 0...10), \"0...10\");\n     assert_eq!(format!(\"{:?}\", ...10), \"...10\");\n-    assert_eq!(format!(\"{:?}\", long), \"[empty range @ 251]\");\n+    assert_eq!(format!(\"{:?}\", long), \"1...0\");\n }"}]}