{"sha": "38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YWM5ZTM5ODQzOTJhYjExZTMzYjc3ZDVlMTkyN2MxZmExN2ZiMDc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-23T13:07:30Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-21T14:27:25Z"}, "message": "syntax: merge ast::ViewItem into ast::Item.", "tree": {"sha": "f7774cf08fe13f6d5afa8b6e230627dc8eb3eea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7774cf08fe13f6d5afa8b6e230627dc8eb3eea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "html_url": "https://github.com/rust-lang/rust/commit/38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38ac9e3984392ab11e33b77d5e1927c1fa17fb07/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53edd767b42d81efc64a018ad93efc2bf1e37f4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/53edd767b42d81efc64a018ad93efc2bf1e37f4b", "html_url": "https://github.com/rust-lang/rust/commit/53edd767b42d81efc64a018ad93efc2bf1e37f4b"}], "stats": {"total": 483, "additions": 130, "deletions": 353}, "files": [{"sha": "9d0675388131f1ba7972c51a00aff199d1442a77", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/38ac9e3984392ab11e33b77d5e1927c1fa17fb07/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ac9e3984392ab11e33b77d5e1927c1fa17fb07/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "patch": "@@ -53,7 +53,6 @@ pub use self::UnboxedClosureKind::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n-pub use self::ViewItem_::*;\n pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n@@ -511,7 +510,6 @@ impl PartialEq for MetaItem_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct Block {\n-    pub view_items: Vec<ViewItem>,\n     pub stmts: Vec<P<Stmt>>,\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n@@ -1452,14 +1450,12 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub view_items: Vec<ViewItem>,\n     pub items: Vec<P<Item>>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct ForeignMod {\n     pub abi: Abi,\n-    pub view_items: Vec<ViewItem>,\n     pub items: Vec<P<ForeignItem>>,\n }\n \n@@ -1518,44 +1514,13 @@ pub enum ViewPath_ {\n     /// or just\n     ///\n     /// `foo::bar::baz` (with `as baz` implicitly on the right)\n-    ViewPathSimple(Ident, Path, NodeId),\n+    ViewPathSimple(Ident, Path),\n \n     /// `foo::bar::*`\n-    ViewPathGlob(Path, NodeId),\n+    ViewPathGlob(Path),\n \n     /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem> , NodeId)\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub struct ViewItem {\n-    pub node: ViewItem_,\n-    pub attrs: Vec<Attribute>,\n-    pub vis: Visibility,\n-    pub span: Span,\n-}\n-\n-impl ViewItem {\n-    pub fn id(&self) -> NodeId {\n-        match self.node {\n-            ViewItemExternCrate(_, _, id) => id,\n-            ViewItemUse(ref vp) => match vp.node {\n-                ViewPathSimple(_, _, id) => id,\n-                ViewPathGlob(_, id) => id,\n-                ViewPathList(_, _, id) => id,\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub enum ViewItem_ {\n-    /// Ident: name used to refer to this crate in the code\n-    /// optional (InternedString,StrStyle): if present, this is a location\n-    /// (containing arbitrary characters) from which to fetch the crate sources\n-    /// For example, extern crate whatever = \"github.com/rust-lang/rust\"\n-    ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(P<ViewPath>),\n+    ViewPathList(Path, Vec<PathListItem>)\n }\n \n /// Meta-data associated with an item\n@@ -1677,6 +1642,12 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum Item_ {\n+    // Optional location (containing arbitrary characters) from which\n+    // to fetch the crate sources.\n+    // For example, extern crate whatever = \"github.com/rust-lang/rust\".\n+    ItemExternCrate(Option<(InternedString, StrStyle)>),\n+    ItemUse(P<ViewPath>),\n+\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n     ItemConst(P<Ty>, P<Expr>),\n     ItemFn(P<FnDecl>, Unsafety, Abi, Generics, P<Block>),\n@@ -1703,6 +1674,8 @@ pub enum Item_ {\n impl Item_ {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n+            ItemExternCrate(..) => \"extern crate\",\n+            ItemUse(..) => \"use\",\n             ItemStatic(..) => \"static item\",\n             ItemConst(..) => \"constant item\",\n             ItemFn(..) => \"function\","}, {"sha": "a474e4c2bad93737acd04e77d077a26bd127a25f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 119, "deletions": 315, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/38ac9e3984392ab11e33b77d5e1927c1fa17fb07/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ac9e3984392ab11e33b77d5e1927c1fa17fb07/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n pub use self::PathParsingMode::*;\n-use self::ItemOrViewItem::*;\n \n use abi;\n use ast::{AssociatedType, BareFnTy};\n@@ -35,6 +34,7 @@ use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRet\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n+use ast::{ItemExternCrate, ItemUse};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitStr, LitInt, Local, LocalLet};\n@@ -59,7 +59,6 @@ use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n-use ast::{ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n@@ -122,14 +121,9 @@ pub enum BoundParsingMode {\n     Modified,\n }\n \n-enum ItemOrViewItem {\n-    /// Indicates a failure to parse any kind of item. The attributes are\n-    /// returned.\n-    IoviNone(Vec<Attribute>),\n-    IoviItem(P<Item>),\n-    IoviForeignItem(P<ForeignItem>),\n-    IoviViewItem(ViewItem)\n-}\n+/// The `Err` case indicates a failure to parse any kind of item.\n+/// The attributes are returned.\n+type MaybeItem = Result<P<Item>, Vec<Attribute>>;\n \n \n /// Possibly accept an `token::Interpolated` expression (a pre-parsed expression\n@@ -231,19 +225,6 @@ macro_rules! maybe_whole {\n             }\n         }\n     );\n-    (iovi $p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return IoviItem(x.clone());\n-            }\n-        }\n-    );\n     (pair_empty $p:expr, $constructor:ident) => (\n         {\n             let found = match ($p).token {\n@@ -269,14 +250,6 @@ fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n     lhs\n }\n \n-\n-struct ParsedItemsAndViewItems {\n-    attrs_remaining: Vec<Attribute>,\n-    view_items: Vec<ViewItem>,\n-    items: Vec<P<Item>> ,\n-    foreign_items: Vec<P<ForeignItem>>\n-}\n-\n /* ident is handled by common.rs */\n \n pub struct Parser<'a> {\n@@ -3032,8 +3005,7 @@ impl<'a> Parser<'a> {\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             id: ast::DUMMY_NODE_ID,\n-            view_items: Vec::new(),\n-            stmts: Vec::new(),\n+            stmts: vec![],\n             span: body.span,\n             expr: Some(body),\n             rules: DefaultBlock,\n@@ -3731,20 +3703,13 @@ impl<'a> Parser<'a> {\n         } else {\n             let found_attrs = !item_attrs.is_empty();\n             let item_err = Parser::expected_item_err(&item_attrs[]);\n-            match self.parse_item_or_view_item(item_attrs, false) {\n-                IoviItem(i) => {\n+            match self.parse_item_(item_attrs, false) {\n+                Ok(i) => {\n                     let hi = i.span.hi;\n                     let decl = P(spanned(lo, hi, DeclItem(i)));\n                     P(spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n                 }\n-                IoviViewItem(vi) => {\n-                    self.span_fatal(vi.span,\n-                                    \"view items must be declared at the top of the block\");\n-                }\n-                IoviForeignItem(_) => {\n-                    self.fatal(\"foreign items are not allowed here\");\n-                }\n-                IoviNone(_) => {\n+                Err(_) => {\n                     if found_attrs {\n                         let last_span = self.last_span;\n                         self.span_err(last_span, item_err);\n@@ -3794,36 +3759,17 @@ impl<'a> Parser<'a> {\n         (inner, self.parse_block_tail_(lo, DefaultBlock, next))\n     }\n \n-    /// Precondition: already parsed the '{' or '#{'\n-    /// I guess that also means \"already parsed the 'impure'\" if\n-    /// necessary, and this should take a qualifier.\n-    /// Some blocks start with \"#{\"...\n+    /// Precondition: already parsed the '{'.\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n         self.parse_block_tail_(lo, s, Vec::new())\n     }\n \n     /// Parse the rest of a block expression or function body\n     fn parse_block_tail_(&mut self, lo: BytePos, s: BlockCheckMode,\n-                         first_item_attrs: Vec<Attribute> ) -> P<Block> {\n-        let mut stmts = Vec::new();\n+                         first_item_attrs: Vec<Attribute>) -> P<Block> {\n+        let mut stmts = vec![];\n         let mut expr = None;\n-\n-        // wouldn't it be more uniform to parse view items only, here?\n-        let ParsedItemsAndViewItems {\n-            attrs_remaining,\n-            view_items,\n-            items,\n-            ..\n-        } = self.parse_items_and_view_items(first_item_attrs,\n-                                            false, false);\n-\n-        for item in items.into_iter() {\n-            let span = item.span;\n-            let decl = P(spanned(span.lo, span.hi, DeclItem(item)));\n-            stmts.push(P(spanned(span.lo, span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID))));\n-        }\n-\n-        let mut attributes_box = attrs_remaining;\n+        let mut attributes_box = first_item_attrs;\n \n         while self.token != token::CloseDelim(token::Brace) {\n             // parsing items even when they're not allowed lets us give\n@@ -3932,7 +3878,6 @@ impl<'a> Parser<'a> {\n         let hi = self.span.hi;\n         self.bump();\n         P(ast::Block {\n-            view_items: view_items,\n             stmts: stmts,\n             expr: expr,\n             id: ast::DUMMY_NODE_ID,\n@@ -5031,56 +4976,50 @@ impl<'a> Parser<'a> {\n                        first_item_attrs: Vec<Attribute>,\n                        inner_lo: BytePos)\n                        -> Mod {\n-        // parse all of the items up to closing or an attribute.\n-        // view items are legal here.\n-        let ParsedItemsAndViewItems {\n-            attrs_remaining,\n-            view_items,\n-            items: starting_items,\n-            ..\n-        } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: Vec<P<Item>> = starting_items;\n-        let attrs_remaining_len = attrs_remaining.len();\n+        // Parse all of the items up to closing or an attribute.\n+\n+        let mut attrs = first_item_attrs;\n+        attrs.push_all(&self.parse_outer_attributes()[]);\n+        let mut items = vec![];\n+\n+        loop {\n+            match self.parse_item_(attrs, true) {\n+                Err(returned_attrs) => {\n+                    attrs = returned_attrs;\n+                    break\n+                }\n+                Ok(item) => {\n+                    attrs = self.parse_outer_attributes();\n+                    items.push(item)\n+                }\n+            }\n+        }\n \n         // don't think this other loop is even necessary....\n \n-        let mut first = true;\n         while self.token != term {\n-            let mut attrs = self.parse_outer_attributes();\n-            if first {\n-                let mut tmp = attrs_remaining.clone();\n-                tmp.push_all(&attrs[]);\n-                attrs = tmp;\n-                first = false;\n-            }\n-            debug!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n-                   attrs);\n-            match self.parse_item_or_view_item(attrs,\n-                                               true /* macros allowed */) {\n-              IoviItem(item) => items.push(item),\n-              IoviViewItem(view_item) => {\n-                self.span_fatal(view_item.span,\n-                                \"view items must be declared at the top of \\\n-                                 the module\");\n-              }\n-              _ => {\n+            let mut attrs = mem::replace(&mut attrs, vec![]);\n+            attrs.push_all(&self.parse_outer_attributes()[]);\n+            debug!(\"parse_mod_items: parse_item_(attrs={:?})\", attrs);\n+            match self.parse_item_(attrs, true /* macros allowed */) {\n+              Ok(item) => items.push(item),\n+              Err(_) => {\n                   let token_str = self.this_token_to_string();\n                   self.fatal(&format!(\"expected item, found `{}`\",\n                                      token_str)[])\n               }\n             }\n         }\n \n-        if first && attrs_remaining_len > 0u {\n+        if !attrs.is_empty() {\n             // We parsed attributes for the first item but didn't find it\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs_remaining[]));\n+                          Parser::expected_item_err(&attrs[]));\n         }\n \n         ast::Mod {\n             inner: mk_sp(inner_lo, self.span.lo),\n-            view_items: view_items,\n             items: items\n         }\n     }\n@@ -5298,23 +5237,12 @@ impl<'a> Parser<'a> {\n     /// parse_foreign_items.\n     fn parse_foreign_mod_items(&mut self,\n                                abi: abi::Abi,\n-                               first_item_attrs: Vec<Attribute> )\n+                               first_item_attrs: Vec<Attribute>)\n                                -> ForeignMod {\n-        let ParsedItemsAndViewItems {\n-            attrs_remaining,\n-            view_items,\n-            items: _,\n-            foreign_items,\n-        } = self.parse_foreign_items(first_item_attrs, true);\n-        if !attrs_remaining.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs_remaining[]));\n-        }\n+        let foreign_items = self.parse_foreign_items(first_item_attrs);\n         assert!(self.token == token::CloseDelim(token::Brace));\n         ast::ForeignMod {\n             abi: abi,\n-            view_items: view_items,\n             items: foreign_items\n         }\n     }\n@@ -5329,8 +5257,8 @@ impl<'a> Parser<'a> {\n     fn parse_item_extern_crate(&mut self,\n                                 lo: BytePos,\n                                 visibility: Visibility,\n-                                attrs: Vec<Attribute> )\n-                                -> ItemOrViewItem {\n+                                attrs: Vec<Attribute>)\n+                                -> P<Item> {\n \n         let span = self.span;\n         let (maybe_path, ident) = match self.token {\n@@ -5374,12 +5302,13 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        IoviViewItem(ast::ViewItem {\n-                node: ViewItemExternCrate(ident, maybe_path, ast::DUMMY_NODE_ID),\n-                attrs: attrs,\n-                vis: visibility,\n-                span: mk_sp(lo, self.last_span.hi)\n-            })\n+        let last_span = self.last_span;\n+        self.mk_item(lo,\n+                     last_span.hi,\n+                     ident,\n+                     ItemExternCrate(maybe_path),\n+                     visibility,\n+                     attrs)\n     }\n \n     /// Parse `extern` for foreign ABIs\n@@ -5396,8 +5325,8 @@ impl<'a> Parser<'a> {\n                               lo: BytePos,\n                               opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n-                              attrs: Vec<Attribute> )\n-                              -> ItemOrViewItem {\n+                              attrs: Vec<Attribute>)\n+                              -> P<Item> {\n \n         self.expect(&token::OpenDelim(token::Brace));\n \n@@ -5408,13 +5337,12 @@ impl<'a> Parser<'a> {\n         self.expect(&token::CloseDelim(token::Brace));\n \n         let last_span = self.last_span;\n-        let item = self.mk_item(lo,\n-                                last_span.hi,\n-                                special_idents::invalid,\n-                                ItemForeignMod(m),\n-                                visibility,\n-                                maybe_append(attrs, Some(inner)));\n-        return IoviItem(item);\n+        self.mk_item(lo,\n+                     last_span.hi,\n+                     special_idents::invalid,\n+                     ItemForeignMod(m),\n+                     visibility,\n+                     maybe_append(attrs, Some(inner)))\n     }\n \n     /// Parse type Foo = Bar;\n@@ -5556,14 +5484,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse one of the items or view items allowed by the\n-    /// flags; on failure, return IoviNone.\n+    /// Parse one of the items allowed by the flags; on failure,\n+    /// return `Err(remaining_attrs)`.\n     /// NB: this function no longer parses the items inside an\n     /// extern crate.\n-    fn parse_item_or_view_item(&mut self,\n-                               attrs: Vec<Attribute> ,\n-                               macros_allowed: bool)\n-                               -> ItemOrViewItem {\n+    fn parse_item_(&mut self, attrs: Vec<Attribute>,\n+                   macros_allowed: bool) -> MaybeItem {\n         let nt_item = match self.token {\n             token::Interpolated(token::NtItem(ref item)) => {\n                 Some((**item).clone())\n@@ -5576,7 +5502,7 @@ impl<'a> Parser<'a> {\n                 let mut attrs = attrs;\n                 mem::swap(&mut item.attrs, &mut attrs);\n                 item.attrs.extend(attrs.into_iter());\n-                return IoviItem(P(item));\n+                return Ok(P(item));\n             }\n             None => {}\n         }\n@@ -5585,22 +5511,24 @@ impl<'a> Parser<'a> {\n \n         let visibility = self.parse_visibility();\n \n-        // must be a view item:\n         if self.eat_keyword(keywords::Use) {\n-            // USE ITEM (IoviViewItem)\n-            let view_item = self.parse_use();\n+            // USE ITEM\n+            let item_ = ItemUse(self.parse_view_path());\n             self.expect(&token::Semi);\n-            return IoviViewItem(ast::ViewItem {\n-                node: view_item,\n-                attrs: attrs,\n-                vis: visibility,\n-                span: mk_sp(lo, self.last_span.hi)\n-            });\n+\n+            let last_span = self.last_span;\n+            let item = self.mk_item(lo,\n+                                    last_span.hi,\n+                                    token::special_idents::invalid,\n+                                    item_,\n+                                    visibility,\n+                                    attrs);\n+            return Ok(item);\n         }\n-        // either a view item or an item:\n+\n         if self.eat_keyword(keywords::Extern) {\n             if self.eat_keyword(keywords::Crate) {\n-                return self.parse_item_extern_crate(lo, visibility, attrs);\n+                return Ok(self.parse_item_extern_crate(lo, visibility, attrs));\n             }\n \n             let opt_abi = self.parse_opt_abi();\n@@ -5617,9 +5545,9 @@ impl<'a> Parser<'a> {\n                                         item_,\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n-                return IoviItem(item);\n+                return Ok(item);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n-                return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n+                return Ok(self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs));\n             }\n \n             let span = self.span;\n@@ -5634,7 +5562,6 @@ impl<'a> Parser<'a> {\n             self.span_err(span, \"`virtual` structs have been removed from the language\");\n         }\n \n-        // the rest are all guaranteed to be items:\n         if self.token.is_keyword(keywords::Static) {\n             // STATIC ITEM\n             self.bump();\n@@ -5647,7 +5574,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Const) {\n             // CONST ITEM\n@@ -5665,7 +5592,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe) &&\n             self.look_ahead(1u, |t| t.is_keyword(keywords::Trait))\n@@ -5682,7 +5609,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe) &&\n             self.look_ahead(1u, |t| t.is_keyword(keywords::Impl))\n@@ -5698,7 +5625,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Fn) {\n             // FUNCTION ITEM\n@@ -5712,7 +5639,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe)\n             && self.look_ahead(1u, |t| *t != token::OpenDelim(token::Brace)) {\n@@ -5733,7 +5660,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n@@ -5746,7 +5673,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n@@ -5758,7 +5685,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n@@ -5770,7 +5697,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n@@ -5783,7 +5710,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n@@ -5795,7 +5722,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n@@ -5807,32 +5734,30 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n     }\n \n-    /// Parse a foreign item; on failure, return IoviNone.\n-    fn parse_foreign_item(&mut self,\n-                          attrs: Vec<Attribute> ,\n-                          macros_allowed: bool)\n-                          -> ItemOrViewItem {\n-        maybe_whole!(iovi self, NtItem);\n+    /// Parse a foreign item; on failure, return `Err(remaining_attrs)`.\n+    fn parse_foreign_item(&mut self, attrs: Vec<Attribute>)\n+                          -> Result<P<ForeignItem>, Vec<Attribute>> {\n         let lo = self.span.lo;\n \n         let visibility = self.parse_visibility();\n \n         if self.token.is_keyword(keywords::Static) {\n             // FOREIGN STATIC ITEM\n-            let item = self.parse_item_foreign_static(visibility, attrs);\n-            return IoviForeignItem(item);\n+            return Ok(self.parse_item_foreign_static(visibility, attrs));\n         }\n         if self.token.is_keyword(keywords::Fn) || self.token.is_keyword(keywords::Unsafe) {\n             // FOREIGN FUNCTION ITEM\n-            let item = self.parse_item_foreign_fn(visibility, attrs);\n-            return IoviForeignItem(item);\n+            return Ok(self.parse_item_foreign_fn(visibility, attrs));\n         }\n-        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+\n+        // FIXME #5668: this will occur for a macro invocation:\n+        let item = try!(self.parse_macro_use_or_failure(attrs, true, lo, visibility));\n+        self.span_fatal(item.span, \"macros cannot expand to foreign items\");\n     }\n \n     /// This is the fall-through for parsing items.\n@@ -5842,7 +5767,7 @@ impl<'a> Parser<'a> {\n         macros_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n-    ) -> ItemOrViewItem {\n+    ) -> MaybeItem {\n         if macros_allowed && !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n                 && (self.look_ahead(2, |t| t.is_plain_ident())\n@@ -5891,7 +5816,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     attrs);\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n \n         // FAILURE TO PARSE ITEM\n@@ -5902,7 +5827,7 @@ impl<'a> Parser<'a> {\n                 self.span_fatal(last_span, \"unmatched visibility `pub`\");\n             }\n         }\n-        return IoviNone(attrs);\n+        Err(attrs)\n     }\n \n     pub fn parse_item_with_outer_attributes(&mut self) -> Option<P<Item>> {\n@@ -5911,30 +5836,9 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_item(&mut self, attrs: Vec<Attribute>) -> Option<P<Item>> {\n-        match self.parse_item_or_view_item(attrs, true) {\n-            IoviNone(_) => None,\n-            IoviViewItem(_) =>\n-                self.fatal(\"view items are not allowed here\"),\n-            IoviForeignItem(_) =>\n-                self.fatal(\"foreign items are not allowed here\"),\n-            IoviItem(item) => Some(item)\n-        }\n+        self.parse_item_(attrs, true).ok()\n     }\n \n-    /// Parse a ViewItem, e.g. `use foo::bar` or `extern crate foo`\n-    pub fn parse_view_item(&mut self, attrs: Vec<Attribute>) -> ViewItem {\n-        match self.parse_item_or_view_item(attrs, false) {\n-            IoviViewItem(vi) => vi,\n-            _ => self.fatal(\"expected `use` or `extern crate`\"),\n-        }\n-    }\n-\n-    /// Parse, e.g., \"use a::b::{z,y}\"\n-    fn parse_use(&mut self) -> ViewItem_ {\n-        return ViewItemUse(self.parse_view_path());\n-    }\n-\n-\n     /// Matches view_path : MOD? non_global_path as IDENT\n     /// | MOD? non_global_path MOD_SEP LBRACE RBRACE\n     /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n@@ -5959,8 +5863,7 @@ impl<'a> Parser<'a> {\n                 global: false,\n                 segments: Vec::new()\n             };\n-            return P(spanned(lo, self.span.hi,\n-                             ViewPathList(path, idents, ast::DUMMY_NODE_ID)));\n+            return P(spanned(lo, self.span.hi, ViewPathList(path, idents)));\n         }\n \n         let first_ident = self.parse_ident();\n@@ -5994,8 +5897,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return P(spanned(lo, self.span.hi,\n-                                     ViewPathList(path, idents, ast::DUMMY_NODE_ID)));\n+                    return P(spanned(lo, self.span.hi, ViewPathList(path, idents)));\n                   }\n \n                   // foo::bar::*\n@@ -6011,8 +5913,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return P(spanned(lo, self.span.hi,\n-                                     ViewPathGlob(path, ast::DUMMY_NODE_ID)));\n+                    return P(spanned(lo, self.span.hi, ViewPathGlob(path)));\n                   }\n \n                   _ => break\n@@ -6033,136 +5934,39 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::As) {\n             rename_to = self.parse_ident()\n         }\n-        P(spanned(lo,\n-                  self.last_span.hi,\n-                  ViewPathSimple(rename_to, path, ast::DUMMY_NODE_ID)))\n-    }\n-\n-    /// Parses a sequence of items. Stops when it finds program\n-    /// text that can't be parsed as an item\n-    /// - mod_items uses extern_mod_allowed = true\n-    /// - block_tail_ uses extern_mod_allowed = false\n-    fn parse_items_and_view_items(&mut self,\n-                                  first_item_attrs: Vec<Attribute> ,\n-                                  mut extern_mod_allowed: bool,\n-                                  macros_allowed: bool)\n-                                  -> ParsedItemsAndViewItems {\n-        let mut attrs = first_item_attrs;\n-        attrs.push_all(&self.parse_outer_attributes()[]);\n-        // First, parse view items.\n-        let mut view_items : Vec<ast::ViewItem> = Vec::new();\n-        let mut items = Vec::new();\n-\n-        // I think this code would probably read better as a single\n-        // loop with a mutable three-state-variable (for extern crates,\n-        // view items, and regular items) ... except that because\n-        // of macros, I'd like to delay that entire check until later.\n-        loop {\n-            match self.parse_item_or_view_item(attrs, macros_allowed) {\n-                IoviNone(attrs) => {\n-                    return ParsedItemsAndViewItems {\n-                        attrs_remaining: attrs,\n-                        view_items: view_items,\n-                        items: items,\n-                        foreign_items: Vec::new()\n-                    }\n-                }\n-                IoviViewItem(view_item) => {\n-                    match view_item.node {\n-                        ViewItemUse(..) => {\n-                            // `extern crate` must precede `use`.\n-                            extern_mod_allowed = false;\n-                        }\n-                        ViewItemExternCrate(..) if !extern_mod_allowed => {\n-                            self.span_err(view_item.span,\n-                                          \"\\\"extern crate\\\" declarations are \\\n-                                           not allowed here\");\n-                        }\n-                        ViewItemExternCrate(..) => {}\n-                    }\n-                    view_items.push(view_item);\n-                }\n-                IoviItem(item) => {\n-                    items.push(item);\n-                    attrs = self.parse_outer_attributes();\n-                    break;\n-                }\n-                IoviForeignItem(_) => {\n-                    panic!();\n-                }\n-            }\n-            attrs = self.parse_outer_attributes();\n-        }\n-\n-        // Next, parse items.\n-        loop {\n-            match self.parse_item_or_view_item(attrs, macros_allowed) {\n-                IoviNone(returned_attrs) => {\n-                    attrs = returned_attrs;\n-                    break\n-                }\n-                IoviViewItem(view_item) => {\n-                    attrs = self.parse_outer_attributes();\n-                    self.span_err(view_item.span,\n-                                  \"`use` and `extern crate` declarations must precede items\");\n-                }\n-                IoviItem(item) => {\n-                    attrs = self.parse_outer_attributes();\n-                    items.push(item)\n-                }\n-                IoviForeignItem(_) => {\n-                    panic!();\n-                }\n-            }\n-        }\n-\n-        ParsedItemsAndViewItems {\n-            attrs_remaining: attrs,\n-            view_items: view_items,\n-            items: items,\n-            foreign_items: Vec::new()\n-        }\n+        P(spanned(lo, self.last_span.hi, ViewPathSimple(rename_to, path)))\n     }\n \n     /// Parses a sequence of foreign items. Stops when it finds program\n     /// text that can't be parsed as an item\n-    fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute> ,\n-                           macros_allowed: bool)\n-        -> ParsedItemsAndViewItems {\n+    fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute>)\n+                           -> Vec<P<ForeignItem>> {\n         let mut attrs = first_item_attrs;\n         attrs.push_all(&self.parse_outer_attributes()[]);\n         let mut foreign_items = Vec::new();\n         loop {\n-            match self.parse_foreign_item(attrs, macros_allowed) {\n-                IoviNone(returned_attrs) => {\n+            match self.parse_foreign_item(attrs) {\n+                Ok(foreign_item) => {\n+                    foreign_items.push(foreign_item);\n+                }\n+                Err(returned_attrs) => {\n                     if self.check(&token::CloseDelim(token::Brace)) {\n                         attrs = returned_attrs;\n                         break\n                     }\n                     self.unexpected();\n-                },\n-                IoviViewItem(view_item) => {\n-                    // I think this can't occur:\n-                    self.span_err(view_item.span,\n-                                  \"`use` and `extern crate` declarations must precede items\");\n-                }\n-                IoviItem(item) => {\n-                    // FIXME #5668: this will occur for a macro invocation:\n-                    self.span_fatal(item.span, \"macros cannot expand to foreign items\");\n-                }\n-                IoviForeignItem(foreign_item) => {\n-                    foreign_items.push(foreign_item);\n                 }\n             }\n             attrs = self.parse_outer_attributes();\n         }\n \n-        ParsedItemsAndViewItems {\n-            attrs_remaining: attrs,\n-            view_items: Vec::new(),\n-            items: Vec::new(),\n-            foreign_items: foreign_items\n+        if !attrs.is_empty() {\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n+                          Parser::expected_item_err(&attrs[]));\n         }\n+\n+        foreign_items\n     }\n \n     /// Parses a source module as a crate. This is the main"}]}