{"sha": "19e718966d0d3660df374f60022f219f5bf48469", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZTcxODk2NmQwZDM2NjBkZjM3NGY2MDAyMmYyMTlmNWJmNDg0Njk=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-06-07T10:05:14Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-06-07T10:05:14Z"}, "message": "forgot to update utils, there are a few new s", "tree": {"sha": "0b8ceed1a9e791f6995daf27df505807dc951cb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b8ceed1a9e791f6995daf27df505807dc951cb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19e718966d0d3660df374f60022f219f5bf48469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19e718966d0d3660df374f60022f219f5bf48469", "html_url": "https://github.com/rust-lang/rust/commit/19e718966d0d3660df374f60022f219f5bf48469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19e718966d0d3660df374f60022f219f5bf48469/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f74c4b3597d9062f3e6d8f908758598b3f904db", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f74c4b3597d9062f3e6d8f908758598b3f904db", "html_url": "https://github.com/rust-lang/rust/commit/1f74c4b3597d9062f3e6d8f908758598b3f904db"}], "stats": {"total": 32, "additions": 31, "deletions": 1}, "files": [{"sha": "b99ed45b3c38c0ea3d9c4f4c85df5e2cc034bf47", "filename": "src/utils.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/19e718966d0d3660df374f60022f219f5bf48469/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e718966d0d3660df374f60022f219f5bf48469/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=19e718966d0d3660df374f60022f219f5bf48469", "patch": "@@ -1,12 +1,42 @@\n use rustc::lint::Context;\n-use syntax::codemap::ExpnInfo;\n+use syntax::ast::{DefId, Name, Path};\n+use syntax::codemap::{ExpnInfo, Span};\n+use rustc::middle::ty;\n \n+/// returns true if the macro that expanded the crate was outside of\n+/// the current crate or was a compiler plugin\n pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n+\t// no ExpnInfo = no macro\n \topt_info.map_or(false, |info| {\n+\t\t// no span for the callee = external macro\n \t\tinfo.callee.span.map_or(true, |span| {\n+\t\t\t// no snippet = external macro or compiler-builtin expansion\n \t\t\tcx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| \n+\t\t\t\t// macro doesn't start with \"macro_rules\"\n+\t\t\t\t// = compiler plugin\n \t\t\t\t!code.starts_with(\"macro_rules\")\n \t\t\t)\n \t\t})\n \t})\n }\n+\n+/// invokes in_macro with the expansion info of the given span\n+pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n+\tcx.sess().codemap().with_expn_info(span.expn_id, \n+\t\t\t|info| in_macro(cx, info))\n+}\n+\n+/// check if a DefId's path matches the given absolute type path\n+/// usage e.g. with\n+/// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n+pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n+\tty::with_path(cx.tcx, def_id, |iter| iter.map(|elem| elem.name())\n+\t\t.zip(path.iter()).all(|(nm, p)| &nm.as_str() == p))\n+}\n+\n+/// match a Path against a slice of segment string literals, e.g.\n+/// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n+pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n+\tpath.segments.iter().rev().zip(segments.iter().rev()).all(\n+\t\t|(a,b)| a.identifier.as_str() == *b)\n+}"}]}