{"sha": "d3b3c56b07ee480ea4633e21e33207b4e239950d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYjNjNTZiMDdlZTQ4MGVhNDYzM2UyMWUzMzIwN2I0ZTIzOTk1MGQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-21T09:39:39Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-21T09:39:39Z"}, "message": "rename statics/Constant/ConstantId/ConstantKind to [gG]lobal*", "tree": {"sha": "e7b3abab9067f35ff910cefc1c1b44155113e6dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7b3abab9067f35ff910cefc1c1b44155113e6dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3b3c56b07ee480ea4633e21e33207b4e239950d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYCeJbAAoJEFbW7qD8Z6xGjHoP/RTW3XClyoBpnl9HyyGHqx4U\nT3krVqVVZhFBKLNSDFeGpYgIz+In83YwajwPhQfMxuJS/yYAp1bOGU/of3umLweL\nOmofASc/Y8aGtJwVXNG8LwstR7Lblfl0+BTdCjwBjzw0PEgJqUp/XmDSjS8Rnksi\nyHuLY8qC5xls7eUP9l9X7XGEiHcP6dw4ZiMIW5qyCKYMV4rhl+513UAnGtvpcB/E\nEDSFJGfPnrPBSwz+anYM581OQLZcvskdFnUTvdeKRJQA6NPCKV0uFotnhcrIuy+E\nTeB24StQR8exTiw0DxLhzl2AbnjxOZ9xRl8HNB9KSrQbSzvVAQrpF9Ym454C4OZW\nG9Y6XY1coILgKsdFK5ywMyjggQAlbyyiGe+Fcn3uMED2OdbuYRD6kr2D6oh3AXYC\nl9kQ/twWuM9f0HuxWPmAk1J8rCcOpcU09+stQ0YQx6VOuwOib4FiVu2HzfmQIyXM\nn18stLWC27pJqNWHEuB6ebaCujEMUamy3uGfcHYjkzWsudWpkVuxjeQ+tNZwSe7p\nnuEGMcymIvT3BDJ6bWoDJ0p7XCp/6JJDeY6TJn2DQRN+9AM+jK9d8jciA5a+mRXv\nGK5p/uUyCVZ4XyR08XlKcP329XhELbywIWvjK8Ty4BrB8hwVWGKviJSJsJPyec9U\nDeKrCL3l/MK5pVLJ6hU8\n=jVi5\n-----END PGP SIGNATURE-----", "payload": "tree e7b3abab9067f35ff910cefc1c1b44155113e6dc\nparent f6bbea0f08469fde3e7b9f1b7b4e81690a9482a8\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477042779 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477042779 +0200\n\nrename statics/Constant/ConstantId/ConstantKind to [gG]lobal*"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b3c56b07ee480ea4633e21e33207b4e239950d", "html_url": "https://github.com/rust-lang/rust/commit/d3b3c56b07ee480ea4633e21e33207b4e239950d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3b3c56b07ee480ea4633e21e33207b4e239950d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6bbea0f08469fde3e7b9f1b7b4e81690a9482a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6bbea0f08469fde3e7b9f1b7b4e81690a9482a8", "html_url": "https://github.com/rust-lang/rust/commit/f6bbea0f08469fde3e7b9f1b7b4e81690a9482a8"}], "stats": {"total": 68, "additions": 34, "deletions": 34}, "files": [{"sha": "4e6c80f9aab67c0c32d069fc2cff129012219707", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d3b3c56b07ee480ea4633e21e33207b4e239950d/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b3c56b07ee480ea4633e21e33207b4e239950d/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=d3b3c56b07ee480ea4633e21e33207b4e239950d", "patch": "@@ -41,7 +41,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     memory: Memory<'a, 'tcx>,\n \n     /// Precomputed statics, constants and promoteds.\n-    statics: HashMap<ConstantId<'tcx>, Constant<'tcx>>,\n+    globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n     /// The virtual call stack.\n     stack: Vec<Frame<'a, 'tcx>>,\n@@ -112,7 +112,7 @@ pub enum Lvalue<'tcx> {\n         local: mir::Local,\n     },\n \n-    Static(ConstantId<'tcx>),\n+    Static(GlobalId<'tcx>),\n \n     // TODO(solson): None/Never?\n }\n@@ -133,34 +133,34 @@ pub enum CachedMir<'mir, 'tcx: 'mir> {\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n /// Uniquely identifies a specific constant or static\n-pub struct ConstantId<'tcx> {\n+pub struct GlobalId<'tcx> {\n     /// the def id of the constant/static or in case of promoteds, the def id of the function they belong to\n     def_id: DefId,\n     /// In case of statics and constants this is `Substs::empty()`, so only promoteds and associated\n     /// constants actually have something useful here. We could special case statics and constants,\n     /// but that would only require more branching when working with constants, and not bring any\n     /// real benefits.\n     substs: &'tcx Substs<'tcx>,\n-    kind: ConstantKind,\n+    kind: GlobalKind,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n-enum ConstantKind {\n+enum GlobalKind {\n     Promoted(mir::Promoted),\n     /// Statics, constants and associated constants\n     Global,\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct Constant<'tcx> {\n+pub struct Global<'tcx> {\n     data: Option<Value>,\n     mutable: bool,\n     ty: Ty<'tcx>,\n }\n \n-impl<'tcx> Constant<'tcx> {\n+impl<'tcx> Global<'tcx> {\n     fn uninitialized(ty: Ty<'tcx>) -> Self {\n-        Constant {\n+        Global {\n             data: None,\n             mutable: true,\n             ty: ty,\n@@ -188,7 +188,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n             memory: Memory::new(&tcx.data_layout, memory_size),\n-            statics: HashMap::new(),\n+            globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: stack_limit,\n         }\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         match frame.return_to_block {\n             StackPopCleanup::Freeze => if let Lvalue::Static(id) = frame.return_lvalue {\n-                let static_value = self.statics\n+                let static_value = self.globals\n                                        .get_mut(&id)\n                                        .expect(\"static should have been cached (freeze)\");\n                 if let Value::ByRef(ptr) = static_value.data.expect(\"static should have been initialized\") {\n@@ -842,20 +842,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             // function items are zero sized\n                             Value::ByRef(self.memory.allocate(0, 0)?)\n                         } else {\n-                            let cid = ConstantId {\n+                            let cid = GlobalId {\n                                 def_id: def_id,\n                                 substs: substs,\n-                                kind: ConstantKind::Global,\n+                                kind: GlobalKind::Global,\n                             };\n                             self.read_lvalue(Lvalue::Static(cid))?\n                         }\n                     }\n \n                     Literal::Promoted { index } => {\n-                        let cid = ConstantId {\n+                        let cid = GlobalId {\n                             def_id: self.frame().def_id,\n                             substs: self.substs(),\n-                            kind: ConstantKind::Promoted(index),\n+                            kind: GlobalKind::Promoted(index),\n                         };\n                         self.read_lvalue(Lvalue::Static(cid))?\n                     }\n@@ -890,7 +890,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local).ok_or(EvalError::ReadUndefBytes)\n             }\n-            Lvalue::Static(cid) => self.statics\n+            Lvalue::Static(cid) => self.globals\n                                        .get(&cid)\n                                        .expect(\"static not cached\")\n                                        .data\n@@ -912,10 +912,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Static(def_id) => {\n                 let substs = subst::Substs::empty(self.tcx);\n-                let cid = ConstantId {\n+                let cid = GlobalId {\n                     def_id: def_id,\n                     substs: substs,\n-                    kind: ConstantKind::Global,\n+                    kind: GlobalKind::Global,\n                 };\n                 Lvalue::Static(cid)\n             }\n@@ -1123,7 +1123,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n             Lvalue::Ptr { .. } => lvalue,\n             Lvalue::Static(cid) => {\n-                let static_val = *self.statics.get(&cid).expect(\"static not cached\");\n+                let static_val = *self.globals.get(&cid).expect(\"static not cached\");\n                 match static_val.data {\n                     Some(Value::ByRef(ptr)) => Lvalue::from_ptr(ptr),\n                     _ => {\n@@ -1134,8 +1134,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         if !static_val.mutable {\n                             self.memory.freeze(ptr.alloc_id)?;\n                         }\n-                        let lval = self.statics.get_mut(&cid).expect(\"already checked\");\n-                        *lval = Constant {\n+                        let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n+                        *lval = Global {\n                             data: Some(Value::ByRef(ptr)),\n                             .. static_val\n                         };\n@@ -1223,7 +1223,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(())\n             }\n             Lvalue::Static(cid) => {\n-                let static_val = self.statics.get_mut(&cid).expect(\"static not cached\");\n+                let static_val = self.globals.get_mut(&cid).expect(\"static not cached\");\n                 assert!(static_val.mutable);\n                 static_val.data = Some(Value::ByVal(val));\n                 Ok(())\n@@ -1239,11 +1239,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         match dest {\n             Lvalue::Static(cid) => {\n-                let dest = *self.statics.get_mut(&cid).expect(\"static should be cached\");\n+                let dest = *self.globals.get_mut(&cid).expect(\"static should be cached\");\n                 assert!(dest.mutable);\n                 self.write_value_possibly_by_val(\n                     src_val,\n-                    |this, val| *this.statics.get_mut(&cid).expect(\"already checked\") = Constant { data: Some(val), ..dest },\n+                    |this, val| *this.globals.get_mut(&cid).expect(\"already checked\") = Global { data: Some(val), ..dest },\n                     dest.data,\n                     dest_ty,\n                 )"}, {"sha": "f25eea875fc32d5d91bc981c69599096fa20d00b", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d3b3c56b07ee480ea4633e21e33207b4e239950d/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b3c56b07ee480ea4633e21e33207b4e239950d/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=d3b3c56b07ee480ea4633e21e33207b4e239950d", "patch": "@@ -4,12 +4,12 @@\n \n use super::{\n     CachedMir,\n-    ConstantId,\n+    GlobalId,\n     EvalContext,\n     Lvalue,\n-    ConstantKind,\n+    GlobalKind,\n     StackPopCleanup,\n-    Constant,\n+    Global,\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n@@ -119,17 +119,17 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n     fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span, immutable: bool) {\n-        let cid = ConstantId {\n+        let cid = GlobalId {\n             def_id: def_id,\n             substs: substs,\n-            kind: ConstantKind::Global,\n+            kind: GlobalKind::Global,\n         };\n-        if self.ecx.statics.contains_key(&cid) {\n+        if self.ecx.globals.contains_key(&cid) {\n             return;\n         }\n         self.try(|this| {\n             let mir = this.ecx.load_mir(def_id)?;\n-            this.ecx.statics.insert(cid, Constant::uninitialized(mir.return_ty));\n+            this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n             let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n                 StackPopCleanup::Freeze\n             } else {\n@@ -167,18 +167,18 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             },\n             mir::Literal::Promoted { index } => {\n                 let mir = self.mir.promoted[index].clone();\n-                let cid = ConstantId {\n+                let cid = GlobalId {\n                     def_id: self.def_id,\n                     substs: self.substs,\n-                    kind: ConstantKind::Promoted(index),\n+                    kind: GlobalKind::Promoted(index),\n                 };\n-                if self.ecx.statics.contains_key(&cid) {\n+                if self.ecx.globals.contains_key(&cid) {\n                     return;\n                 }\n                 self.try(|this| {\n                     let mir = CachedMir::Owned(Rc::new(mir));\n                     let ty = this.ecx.monomorphize(mir.return_ty, this.substs);\n-                    this.ecx.statics.insert(cid, Constant::uninitialized(ty));\n+                    this.ecx.globals.insert(cid, Global::uninitialized(ty));\n                     this.ecx.push_stack_frame(this.def_id,\n                                               constant.span,\n                                               mir,"}]}