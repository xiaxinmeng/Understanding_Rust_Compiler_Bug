{"sha": "7bdb93266d3a88e407f7996d374a8364b84b8e01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZGI5MzI2NmQzYTg4ZTQwN2Y3OTk2ZDM3NGE4MzY0Yjg0YjhlMDE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-03T03:30:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-03T18:24:55Z"}, "message": "rustc: Translate nullary tag constructors", "tree": {"sha": "ba3e129ca4a29f813dc31bce8f99f2b45dcf7e78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba3e129ca4a29f813dc31bce8f99f2b45dcf7e78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bdb93266d3a88e407f7996d374a8364b84b8e01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bdb93266d3a88e407f7996d374a8364b84b8e01", "html_url": "https://github.com/rust-lang/rust/commit/7bdb93266d3a88e407f7996d374a8364b84b8e01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bdb93266d3a88e407f7996d374a8364b84b8e01/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d922b0ad9c126e416b1d6d68a567e0dcbabbbf29", "url": "https://api.github.com/repos/rust-lang/rust/commits/d922b0ad9c126e416b1d6d68a567e0dcbabbbf29", "html_url": "https://github.com/rust-lang/rust/commit/d922b0ad9c126e416b1d6d68a567e0dcbabbbf29"}], "stats": {"total": 246, "additions": 174, "deletions": 72}, "files": [{"sha": "27dfa44314c8ce46eccd8765e0aff764599ad571", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 174, "deletions": 72, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/7bdb93266d3a88e407f7996d374a8364b84b8e01/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdb93266d3a88e407f7996d374a8364b84b8e01/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7bdb93266d3a88e407f7996d374a8364b84b8e01", "patch": "@@ -1,4 +1,5 @@\n import std._str;\n+import std._uint;\n import std._vec;\n import std._str.rustrt.sbuf;\n import std._vec.rustrt.vbuf;\n@@ -387,6 +388,10 @@ fn C_tydesc(TypeRef t) -> ValueRef {\n                      C_null(T_ptr(T_opaque()))));      // is_stateful\n }\n \n+fn C_union(TypeRef ty, ValueRef val) -> ValueRef {\n+    ret llvm.LLVMConstUnion(ty, val);\n+}\n+\n fn decl_fn(ModuleRef llmod, str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn =\n         llvm.LLVMAddFunction(llmod, _str.buf(name), llty);\n@@ -560,10 +565,69 @@ fn iter_structural_ty(@block_ctxt cx,\n                 i += 1;\n             }\n         }\n+        case (typeck.ty_tag(?tid)) {\n+            check (cx.fcx.ccx.tags.contains_key(tid));\n+            auto info = cx.fcx.ccx.tags.get(tid);\n+            auto n_variants = _vec.len[tup(ast.def_id,arity)](info.variants);\n+\n+            // Look up the tag in the typechecked AST.\n+            check (cx.fcx.ccx.items.contains_key(tid));\n+            auto tag_item = cx.fcx.ccx.items.get(tid);\n+            let vec[ast.variant] variants = vec();  // FIXME: typestate bug\n+            alt (tag_item.node) {\n+                case (ast.item_tag(_, ?vs, _, _)) {\n+                    variants = vs;\n+                }\n+                case (_) {\n+                    log \"trans: ty_tag doesn't actually refer to a tag\";\n+                    fail;\n+                }\n+            }\n+\n+            auto lldiscrim_ptr = cx.build.GEP(v, vec(C_int(0), C_int(0)));\n+            auto llunion_ptr = cx.build.GEP(v, vec(C_int(0), C_int(1)));\n+            auto lldiscrim = cx.build.Load(lldiscrim_ptr);\n+          \n+            auto unr_cx = new_sub_block_ctxt(cx, \"tag-iter-unr\");\n+            unr_cx.build.Unreachable();\n+\n+            auto llswitch = cx.build.Switch(lldiscrim, unr_cx.llbb,\n+                                            n_variants);\n+           \n+            auto next_cx = new_sub_block_ctxt(cx, \"tag-iter-next\");\n+\n+            auto i = 0u;\n+            for (tup(ast.def_id,arity) variant in info.variants) {\n+                auto variant_cx = new_sub_block_ctxt(cx, \"tag-iter-variant-\" +\n+                                                     _uint.to_str(i, 10u));\n+                llvm.LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n+\n+                alt (variant._1) {\n+                    case (n_ary) {\n+                        // FIXME: broken at the moment, causes type_is_binding\n+                        // errors; need to unpack the fn type returned by\n+                        // ann_to_type.\n+                        let vec[ValueRef] vals = vec(C_int(0), C_int(1),\n+                                                     C_int(i as int));\n+                        auto llfld = r.bcx.build.GEP(v, vals);\n+                        auto ty = typeck.ann_to_type(variants.(i).ann);\n+                        r = f(variant_cx, llfld, ty);\n+                        r.bcx.build.Br(next_cx.llbb);\n+                    }\n+                    case (nullary) {\n+                        // Nothing to do.\n+                        variant_cx.build.Br(next_cx.llbb);\n+                    }\n+                }\n+\n+                i += 1u;\n+            }\n+\n+            ret res(next_cx, C_nil());\n+        }\n         case (_) {\n             cx.fcx.ccx.sess.unimpl(\"type in iter_structural_ty\");\n         }\n-        // FIXME: handle records and tags when we support them.\n     }\n     ret r;\n }\n@@ -1191,24 +1255,9 @@ fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt)\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n                     check (cx.fcx.ccx.tags.contains_key(tid));\n-                    auto info = cx.fcx.ccx.tags.get(tid);\n-                    auto i = 0;\n-                    for (tup(ast.def_id,arity) v in info.variants) {\n-                        if (vid == v._0) {\n-                            alt (v._1) {\n-                                case (nullary) {\n-                                    auto elems = vec(C_int(i));\n-                                    ret tup(res(cx, C_struct(elems)), false);\n-                                }\n-                                case (n_ary) {\n-                                    cx.fcx.ccx.sess.unimpl(\"n-ary tag \" +\n-                                                           \"constructor in \" +\n-                                                           \"trans\");\n-                                }\n-                            }\n-                        }\n-                        i += 1;\n-                    }\n+                    check (cx.fcx.ccx.item_ids.contains_key(vid));\n+                    ret tup(res(cx, cx.fcx.ccx.item_ids.get(vid)),\n+                            false);\n                 }\n                 case (_) {\n                     cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n@@ -1791,59 +1840,6 @@ impure fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n }\n \n \n-fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n-    alt (i.node) {\n-        case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n-            let vec[TypeRef] variant_tys = vec();\n-\n-            auto info = cx.tags.get(tag_id);\n-            let vec[tup(ast.def_id,arity)] variant_info = vec();\n-\n-            auto tag_ty;\n-            if (_vec.len[ast.variant](variants) == 0u) {\n-                tag_ty = T_struct(vec(T_int()));\n-            } else {\n-                auto n_ary_idx = 0u;\n-                for (ast.variant variant in variants) {\n-                    auto arity_info;\n-                    if (_vec.len[@ast.ty](variant.args) > 0u) {\n-                        let vec[TypeRef] lltys = vec();\n-\n-                        alt (typeck.ann_to_type(variant.ann).struct) {\n-                            case (typeck.ty_fn(?args, _)) {\n-                                for (typeck.arg arg in args) {\n-                                    lltys += vec(type_of(cx, arg.ty));\n-                                }\n-                            }\n-                            case (_) { fail; }\n-                        }\n-\n-                        variant_tys += vec(T_struct(lltys));\n-                        arity_info = n_ary;\n-                    } else {\n-                        variant_tys += vec(T_nil());\n-                        arity_info = nullary;\n-                    }\n-\n-                    variant_info += vec(tup(variant.id, arity_info));\n-                }\n-\n-                tag_ty = T_struct(vec(T_int(), T_union(variant_tys)));\n-            }\n-\n-            info.variants = variant_info;\n-\n-            auto th = cx.tags.get(tag_id).th.llth;\n-            llvm.LLVMRefineType(llvm.LLVMResolveTypeHandle(th), tag_ty);\n-        }\n-        case (_) {\n-            // fall through\n-        }\n-    }\n-\n-    ret cx;\n-}\n-\n fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, _, ?fid, ?ann)) {\n@@ -1865,6 +1861,7 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n             let vec[tup(ast.def_id,arity)] variant_info = vec();\n             cx.tags.insert(tag_id, @rec(th=mk_type_handle(),\n                                         mutable variants=variant_info));\n+            cx.items.insert(tag_id, i);\n         }\n \n         case (_) { /* fall through */ }\n@@ -1884,6 +1881,55 @@ fn collect_items(@crate_ctxt cx, @ast.crate crate) {\n     fold.fold_crate[@crate_ctxt](cx, fld, crate);\n }\n \n+// The tag type resolution pass, which determines all the LLVM types that\n+// correspond to each tag type in the crate.\n+\n+fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+    alt (i.node) {\n+        case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n+            let vec[TypeRef] variant_tys = vec();\n+\n+            auto info = cx.tags.get(tag_id);\n+            let vec[tup(ast.def_id,arity)] variant_info = vec();\n+\n+            for (ast.variant variant in variants) {\n+                auto arity_info;\n+                if (_vec.len[@ast.ty](variant.args) > 0u) {\n+                    let vec[TypeRef] lltys = vec();\n+\n+                    alt (typeck.ann_to_type(variant.ann).struct) {\n+                        case (typeck.ty_fn(?args, _)) {\n+                            for (typeck.arg arg in args) {\n+                                lltys += vec(type_of(cx, arg.ty));\n+                            }\n+                        }\n+                        case (_) { fail; }\n+                    }\n+\n+                    variant_tys += vec(T_struct(lltys));\n+                    arity_info = n_ary;\n+                } else {\n+                    variant_tys += vec(T_nil());\n+                    arity_info = nullary;\n+                }\n+\n+                variant_info += vec(tup(variant.id, arity_info));\n+            }\n+\n+            info.variants = variant_info;\n+\n+            auto tag_ty = T_struct(vec(T_int(), T_union(variant_tys)));\n+            auto th = cx.tags.get(tag_id).th.llth;\n+            llvm.LLVMRefineType(llvm.LLVMResolveTypeHandle(th), tag_ty);\n+        }\n+        case (_) {\n+            // fall through\n+        }\n+    }\n+\n+    ret cx;\n+}\n+\n fn resolve_tag_types(@crate_ctxt cx, @ast.crate crate) {\n     let fold.ast_fold[@crate_ctxt] fld =\n         fold.new_identity_fold[@crate_ctxt]();\n@@ -1894,6 +1940,61 @@ fn resolve_tag_types(@crate_ctxt cx, @ast.crate crate) {\n     fold.fold_crate[@crate_ctxt](cx, fld, crate);\n }\n \n+// The constant translation pass.\n+\n+fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n+    alt (it.node) {\n+        case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n+            auto info = cx.tags.get(tag_id);\n+\n+            auto tag_ty = llvm.LLVMResolveTypeHandle(info.th.llth);\n+            check (llvm.LLVMCountStructElementTypes(tag_ty) == 2u);\n+            auto elts = vec(0 as TypeRef, 0 as TypeRef);\n+            llvm.LLVMGetStructElementTypes(tag_ty, _vec.buf[TypeRef](elts));\n+            auto union_ty = elts.(1);\n+\n+            auto i = 0u;\n+            while (i < _vec.len[tup(ast.def_id,arity)](info.variants)) {\n+                auto variant_info = info.variants.(i);\n+                alt (variant_info._1) {\n+                    case (nullary) {\n+                        // Nullary tags become constants.\n+                        auto union_val = C_union(union_ty, C_nil());\n+                        auto val = C_struct(vec(C_int(i as int), union_val));\n+                        \n+                        // FIXME: better name\n+                        auto gvar = llvm.LLVMAddGlobal(cx.llmod, val_ty(val),\n+                                                       _str.buf(\"tag\"));\n+                        llvm.LLVMSetInitializer(gvar, val);\n+                        llvm.LLVMSetGlobalConstant(gvar, True);\n+                        cx.item_ids.insert(variant_info._0, gvar);\n+                    }\n+                    case (n_ary) {\n+                        // N-ary tags are treated as functions and generated\n+                        // later.\n+                    }\n+                }\n+\n+                i += 1u;\n+            }\n+        }\n+        case (_) {\n+            // empty\n+        }\n+    }\n+\n+    ret cx;\n+}\n+\n+fn trans_constants(@crate_ctxt cx, @ast.crate crate) {\n+    let fold.ast_fold[@crate_ctxt] fld =\n+        fold.new_identity_fold[@crate_ctxt]();\n+\n+    fld = @rec(update_env_for_item = bind trans_constant(_,_) with *fld);\n+\n+    fold.fold_crate[@crate_ctxt](cx, fld, crate);\n+}\n+\n fn p2i(ValueRef v) -> ValueRef {\n     ret llvm.LLVMConstPtrToInt(v, T_int());\n }\n@@ -2060,6 +2161,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n \n     collect_items(cx, crate);\n     resolve_tag_types(cx, crate);\n+    trans_constants(cx, crate);\n \n     trans_mod(cx, crate.node.module);\n     trans_exit_task_glue(cx);"}]}