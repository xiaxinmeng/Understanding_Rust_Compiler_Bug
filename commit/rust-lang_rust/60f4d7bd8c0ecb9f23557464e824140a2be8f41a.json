{"sha": "60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZjRkN2JkOGMwZWNiOWYyMzU1NzQ2NGU4MjQxNDBhMmJlOGY0MWE=", "commit": {"author": {"name": "Luca Barbieri", "email": "luca@luca-barbieri.com", "date": "2020-04-03T19:12:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T09:50:37Z"}, "message": "Provide more complete AST accessors to support usage in rustc", "tree": {"sha": "00aea343b133272e1df072bd7c839fddf07f36f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00aea343b133272e1df072bd7c839fddf07f36f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "html_url": "https://github.com/rust-lang/rust/commit/60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/comments", "author": {"login": "luca-barbieri", "id": 298418, "node_id": "MDQ6VXNlcjI5ODQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/298418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luca-barbieri", "html_url": "https://github.com/luca-barbieri", "followers_url": "https://api.github.com/users/luca-barbieri/followers", "following_url": "https://api.github.com/users/luca-barbieri/following{/other_user}", "gists_url": "https://api.github.com/users/luca-barbieri/gists{/gist_id}", "starred_url": "https://api.github.com/users/luca-barbieri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luca-barbieri/subscriptions", "organizations_url": "https://api.github.com/users/luca-barbieri/orgs", "repos_url": "https://api.github.com/users/luca-barbieri/repos", "events_url": "https://api.github.com/users/luca-barbieri/events{/privacy}", "received_events_url": "https://api.github.com/users/luca-barbieri/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85956932872481cf4813c5e7794d981a9edb4623", "url": "https://api.github.com/repos/rust-lang/rust/commits/85956932872481cf4813c5e7794d981a9edb4623", "html_url": "https://github.com/rust-lang/rust/commit/85956932872481cf4813c5e7794d981a9edb4623"}], "stats": {"total": 650, "additions": 436, "deletions": 214}, "files": [{"sha": "72a201b6d2e6a27f0368e15c975c2153b11f70a8", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -1,5 +1,5 @@\n use ra_syntax::{\n-    ast::{self, AstNode, NameOwner, TypeParamsOwner},\n+    ast::{self, AstNode, AstToken, NameOwner, TypeParamsOwner},\n     TextUnit,\n };\n use stdx::{format_to, SepBy};\n@@ -42,7 +42,7 @@ pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n         if let Some(type_params) = type_params {\n             let lifetime_params = type_params\n                 .lifetime_params()\n-                .filter_map(|it| it.lifetime_token())\n+                .filter_map(|it| it.lifetime())\n                 .map(|it| it.text().clone());\n             let type_params =\n                 type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "c10397249fd18b993c7df343c545498128c7cb8b", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -1,7 +1,8 @@\n use hir::Adt;\n use ra_syntax::{\n     ast::{\n-        self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n+        self, AstNode, AstToken, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner,\n+        VisibilityOwner,\n     },\n     TextUnit, T,\n };\n@@ -105,7 +106,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n     if let Some(type_params) = type_params {\n         let lifetime_params = type_params\n             .lifetime_params()\n-            .filter_map(|it| it.lifetime_token())\n+            .filter_map(|it| it.lifetime())\n             .map(|it| it.text().clone());\n         let type_params =\n             type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "9963f884bb1d77e6f6af06c7262b537d56c7836e", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -1,5 +1,5 @@\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstElement, AstNode},\n     SyntaxKind::{\n         BLOCK_EXPR, BREAK_EXPR, COMMENT, LAMBDA_EXPR, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n         WHITESPACE,\n@@ -124,7 +124,7 @@ fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n             }\n         }\n \n-        if ast::Stmt::cast(node.clone()).is_some() {\n+        if ast::Stmt::cast_element(node.clone().into()).is_some() {\n             return Some((node, false));\n         }\n "}, {"sha": "f8b3ddb4e18f3c50dbcb1bce073719ff1f8b7428", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -3,7 +3,7 @@ use std::iter::successors;\n use ra_syntax::{\n     algo::{neighbor, SyntaxRewriter},\n     ast::{self, edit::AstNodeEdit, make},\n-    AstNode, Direction, InsertPosition, SyntaxElement, T,\n+    AstNode, AstToken, Direction, InsertPosition, SyntaxElement, T,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -82,7 +82,7 @@ fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTre\n             .filter(|it| it.kind() != T!['{'] && it.kind() != T!['}']),\n     );\n     let use_tree_list = lhs.use_tree_list()?;\n-    let pos = InsertPosition::Before(use_tree_list.r_curly()?.into());\n+    let pos = InsertPosition::Before(use_tree_list.r_curly()?.syntax().clone().into());\n     let use_tree_list = use_tree_list.insert_children(pos, to_insert);\n     Some(lhs.with_use_tree_list(use_tree_list))\n }"}, {"sha": "0b4ba1bbe6541a05fddcf1418c34e4526287e4e2", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -60,10 +60,10 @@ pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n     } else {\n         // Unwrap `{ continue; }`\n         let (stmt,) = block.statements().next_tuple()?;\n-        if has_anything_else(stmt.syntax()) {\n-            return None;\n-        }\n         if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n+            if has_anything_else(expr_stmt.syntax()) {\n+                return None;\n+            }\n             let expr = expr_stmt.expr()?;\n             match expr.syntax().kind() {\n                 CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),"}, {"sha": "8338414faacc666edc82d04fde154a4329ad0d6c", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -482,14 +482,17 @@ impl ExprCollector<'_> {\n         self.collect_block_items(&block);\n         let statements = block\n             .statements()\n-            .map(|s| match s {\n+            .filter_map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let { pat, type_ref, initializer }\n+                    Some(Statement::Let { pat, type_ref, initializer })\n                 }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+                ast::Stmt::ExprStmt(stmt) => {\n+                    Some(Statement::Expr(self.collect_expr_opt(stmt.expr())))\n+                }\n+                ast::Stmt::ModuleItem(_) => None,\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n@@ -541,6 +544,7 @@ impl ExprCollector<'_> {\n                     let ast_id = self.expander.ast_id(&def);\n                     (TraitLoc { container, ast_id }.intern(self.db).into(), def.name())\n                 }\n+                ast::ModuleItem::ExternBlock(_) => continue, // FIXME: collect from extern blocks\n                 ast::ModuleItem::ImplDef(_)\n                 | ast::ModuleItem::UseItem(_)\n                 | ast::ModuleItem::ExternCrateItem(_)"}, {"sha": "a9dff3a5d5a712d9b8e93fefcc76048c89882684", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -266,6 +266,10 @@ impl RawItemsCollector {\n                 self.add_macro(current_module, it);\n                 return;\n             }\n+            ast::ModuleItem::ExternBlock(_) => {\n+                // FIXME: add extern block\n+                return;\n+            }\n         };\n         if let Some(name) = name {\n             let name = name.as_name();"}, {"sha": "3c13cb2c788162a649d2fb8f33a6ba4954eef0ee", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -28,7 +28,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     loop {\n         let segment = path.segment()?;\n \n-        if segment.has_colon_colon() {\n+        if segment.coloncolon().is_some() {\n             kind = PathKind::Abs;\n         }\n "}, {"sha": "6ec944228cf69951143e3b52f48f75363decf8f6", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn lower_use_tree(\n         let alias = tree.alias().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n-        let is_glob = tree.has_star();\n+        let is_glob = tree.star().is_some();\n         if let Some(ast_path) = tree.path() {\n             // Handle self in a path.\n             // E.g. `use something::{self, <...>}`"}, {"sha": "1482d3be04da0610288e2bd5932143b452223696", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -84,6 +84,10 @@ impl RawVisibility {\n                 let path = ModPath { kind: PathKind::Super(1), segments: Vec::new() };\n                 RawVisibility::Module(path)\n             }\n+            ast::VisibilityKind::PubSelf => {\n+                let path = ModPath { kind: PathKind::Plain, segments: Vec::new() };\n+                RawVisibility::Module(path)\n+            }\n             ast::VisibilityKind::Pub => RawVisibility::Public,\n         }\n     }"}, {"sha": "ac096623682f812f92ce92b961ac2e1450889db4", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -23,7 +23,7 @@ use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, AstToken},\n };\n use stdx::format_to;\n \n@@ -101,7 +101,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let node = src_ptr.value.to_node(&src_ptr.file_syntax(&db));\n \n             let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n-                (self_param.self_kw_token().text_range(), \"self\".to_string())\n+                (self_param.self_kw().unwrap().syntax().text_range(), \"self\".to_string())\n             } else {\n                 (src_ptr.value.range(), node.text().to_string().replace(\"\\n\", \" \"))\n             };"}, {"sha": "004f4e564310a58f805008863b7f96e5e7cb118a", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -105,6 +105,7 @@ pub enum SyntaxKind {\n     DEFAULT_KW,\n     EXISTENTIAL_KW,\n     UNION_KW,\n+    RAW_KW,\n     INT_NUMBER,\n     FLOAT_NUMBER,\n     CHAR,\n@@ -258,7 +259,7 @@ impl SyntaxKind {\n             | IMPL_KW | IN_KW | LET_KW | LOOP_KW | MACRO_KW | MATCH_KW | MOD_KW | MOVE_KW\n             | MUT_KW | PUB_KW | REF_KW | RETURN_KW | SELF_KW | STATIC_KW | STRUCT_KW | SUPER_KW\n             | TRAIT_KW | TRUE_KW | TRY_KW | TYPE_KW | UNSAFE_KW | USE_KW | WHERE_KW | WHILE_KW\n-            | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW => true,\n+            | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW | RAW_KW => true,\n             _ => false,\n         }\n     }\n@@ -651,4 +652,7 @@ macro_rules! T {\n     ( union ) => {\n         $crate::SyntaxKind::UNION_KW\n     };\n+    ( raw ) => {\n+        $crate::SyntaxKind::RAW_KW\n+    };\n }"}, {"sha": "c81b68d3e29c2ddc6d1f0d7f0c80f05aea95196a", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -271,7 +271,7 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"'a\", pred.lifetime_token().unwrap().text());\n+    assert_eq!(\"'a\", pred.lifetime().unwrap().text());\n \n     assert_bound(\"'b\", bounds.next());\n     assert_bound(\"'c\", bounds.next());"}, {"sha": "d7931099535bf181d042d50713b9f85316ed23df", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -99,7 +99,7 @@ impl ast::ItemList {\n             None => match self.l_curly() {\n                 Some(it) => (\n                     \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n-                    InsertPosition::After(it),\n+                    InsertPosition::After(it.syntax().clone().into()),\n                 ),\n                 None => return self.clone(),\n             },\n@@ -109,10 +109,6 @@ impl ast::ItemList {\n             [ws.ws().into(), item.syntax().clone().into()].into();\n         self.insert_children(position, to_insert)\n     }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n }\n \n impl ast::RecordFieldList {\n@@ -147,7 +143,7 @@ impl ast::RecordFieldList {\n         macro_rules! after_l_curly {\n             () => {{\n                 let anchor = match self.l_curly() {\n-                    Some(it) => it,\n+                    Some(it) => it.syntax().clone().into(),\n                     None => return self.clone(),\n                 };\n                 InsertPosition::After(anchor)\n@@ -189,24 +185,20 @@ impl ast::RecordFieldList {\n \n         self.insert_children(position, to_insert)\n     }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n }\n \n impl ast::TypeParam {\n     #[must_use]\n     pub fn remove_bounds(&self) -> ast::TypeParam {\n-        let colon = match self.colon_token() {\n+        let colon = match self.colon() {\n             Some(it) => it,\n             None => return self.clone(),\n         };\n         let end = match self.type_bound_list() {\n             Some(it) => it.syntax().clone().into(),\n-            None => colon.clone().into(),\n+            None => colon.syntax().clone().into(),\n         };\n-        self.replace_children(colon.into()..=end, iter::empty())\n+        self.replace_children(colon.syntax().clone().into()..=end, iter::empty())\n     }\n }\n \n@@ -305,8 +297,12 @@ impl ast::UseTree {\n             Some(it) => it,\n             None => return self.clone(),\n         };\n-        let use_tree =\n-            make::use_tree(suffix.clone(), self.use_tree_list(), self.alias(), self.has_star());\n+        let use_tree = make::use_tree(\n+            suffix.clone(),\n+            self.use_tree_list(),\n+            self.alias(),\n+            self.star().is_some(),\n+        );\n         let nested = make::use_tree_list(iter::once(use_tree));\n         return make::use_tree(prefix.clone(), Some(nested), None, false);\n "}, {"sha": "40c8fca3be3fffb2ca87109ff7713c446f17e81b", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -52,6 +52,10 @@ impl ast::RefExpr {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n+\n+    pub fn raw_token(&self) -> Option<SyntaxToken> {\n+        None // FIXME: implement &raw\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "400eba210af03edcb5c91189ee116809516697b0", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -4,7 +4,10 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstNode, AttrInput, NameOwner, SyntaxNode},\n+    ast::{\n+        self, child_opt, child_token_opt, children, AstElement, AstNode, AstToken, AttrInput,\n+        NameOwner, SyntaxNode,\n+    },\n     SmolStr, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, T,\n@@ -130,13 +133,6 @@ impl ast::PathSegment {\n         };\n         Some(res)\n     }\n-\n-    pub fn has_colon_colon(&self) -> bool {\n-        match self.syntax.first_child_or_token().map(|s| s.kind()) {\n-            Some(T![::]) => true,\n-            _ => false,\n-        }\n-    }\n }\n \n impl ast::Path {\n@@ -154,33 +150,13 @@ impl ast::Module {\n     }\n }\n \n-impl ast::UseTree {\n-    pub fn has_star(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![*])\n-    }\n-}\n-\n impl ast::UseTreeList {\n     pub fn parent_use_tree(&self) -> ast::UseTree {\n         self.syntax()\n             .parent()\n             .and_then(ast::UseTree::cast)\n             .expect(\"UseTreeLists are always nested in UseTrees\")\n     }\n-    pub fn l_curly(&self) -> Option<SyntaxToken> {\n-        self.token(T!['{'])\n-    }\n-\n-    pub fn r_curly(&self) -> Option<SyntaxToken> {\n-        self.token(T!['}'])\n-    }\n-\n-    fn token(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == kind)\n-    }\n }\n \n impl ast::ImplDef {\n@@ -387,24 +363,9 @@ pub enum SelfParamKind {\n }\n \n impl ast::SelfParam {\n-    pub fn self_kw_token(&self) -> SyntaxToken {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![self])\n-            .expect(\"invalid tree: self param must have self\")\n-    }\n-\n     pub fn kind(&self) -> SelfParamKind {\n-        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == T![&]);\n-        if borrowed {\n-            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n-            if self\n-                .syntax()\n-                .children_with_tokens()\n-                .skip_while(|n| n.kind() != T![&])\n-                .any(|n| n.kind() == T![mut])\n-            {\n+        if self.amp().is_some() {\n+            if self.amp_mut_kw().is_some() {\n                 SelfParamKind::MutRef\n             } else {\n                 SelfParamKind::Ref\n@@ -413,32 +374,23 @@ impl ast::SelfParam {\n             SelfParamKind::Owned\n         }\n     }\n-}\n \n-impl ast::LifetimeParam {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+    /// the \"mut\" in \"mut self\", not the one in \"&mut self\"\n+    pub fn mut_kw(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+            .take_while(|it| it.kind() != T![&])\n+            .find_map(ast::MutKw::cast)\n     }\n-}\n \n-impl ast::TypeParam {\n-    pub fn colon_token(&self) -> Option<SyntaxToken> {\n+    /// the \"mut\" in \"&mut self\", not the one in \"mut self\"\n+    pub fn amp_mut_kw(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![:])\n-    }\n-}\n-\n-impl ast::WherePred {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+            .skip_while(|it| it.kind() != T![&])\n+            .find_map(ast::MutKw::cast)\n     }\n }\n \n@@ -449,7 +401,7 @@ pub enum TypeBoundKind {\n     /// for<'a> ...\n     ForType(ast::ForType),\n     /// 'a\n-    Lifetime(ast::SyntaxToken),\n+    Lifetime(ast::Lifetime),\n }\n \n impl ast::TypeBound {\n@@ -465,21 +417,28 @@ impl ast::TypeBound {\n         }\n     }\n \n-    fn lifetime(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+    pub fn has_question_mark(&self) -> bool {\n+        self.question().is_some()\n     }\n \n-    pub fn question_mark_token(&self) -> Option<SyntaxToken> {\n+    pub fn const_question(&self) -> Option<ast::Question> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![?])\n+            .take_while(|it| it.kind() != T![const])\n+            .find_map(ast::Question::cast)\n     }\n-    pub fn has_question_mark(&self) -> bool {\n-        self.question_mark_token().is_some()\n+\n+    pub fn question(&self) -> Option<ast::Question> {\n+        if self.const_kw().is_some() {\n+            self.syntax()\n+                .children_with_tokens()\n+                .filter_map(|it| it.into_token())\n+                .skip_while(|it| it.kind() != T![const])\n+                .find_map(ast::Question::cast)\n+        } else {\n+            child_token_opt(self)\n+        }\n     }\n }\n \n@@ -493,6 +452,7 @@ pub enum VisibilityKind {\n     In(ast::Path),\n     PubCrate,\n     PubSuper,\n+    PubSelf,\n     Pub,\n }\n \n@@ -504,6 +464,8 @@ impl ast::Visibility {\n             VisibilityKind::PubCrate\n         } else if self.is_pub_super() {\n             VisibilityKind::PubSuper\n+        } else if self.is_pub_self() {\n+            VisibilityKind::PubSuper\n         } else {\n             VisibilityKind::Pub\n         }\n@@ -516,6 +478,10 @@ impl ast::Visibility {\n     fn is_pub_super(&self) -> bool {\n         self.syntax().children_with_tokens().any(|it| it.kind() == T![super])\n     }\n+\n+    fn is_pub_self(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![self])\n+    }\n }\n \n impl ast::MacroCall {\n@@ -528,3 +494,41 @@ impl ast::MacroCall {\n         }\n     }\n }\n+\n+impl ast::LifetimeParam {\n+    pub fn lifetime_bounds(&self) -> impl Iterator<Item = ast::Lifetime> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .skip_while(|x| x.kind() != T![:])\n+            .filter_map(ast::Lifetime::cast)\n+    }\n+}\n+\n+impl ast::RangePat {\n+    pub fn start(&self) -> Option<ast::Pat> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .take_while(|it| !ast::RangeSeparator::can_cast_element(it.kind()))\n+            .filter_map(|it| it.into_node())\n+            .find_map(ast::Pat::cast)\n+    }\n+\n+    pub fn end(&self) -> Option<ast::Pat> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .skip_while(|it| !ast::RangeSeparator::can_cast_element(it.kind()))\n+            .filter_map(|it| it.into_node())\n+            .find_map(ast::Pat::cast)\n+    }\n+}\n+\n+impl ast::TokenTree {\n+    pub fn left_delimiter(&self) -> Option<ast::LeftDelimiter> {\n+        self.syntax().first_child_or_token().and_then(ast::LeftDelimiter::cast_element)\n+    }\n+\n+    pub fn right_delimiter(&self) -> Option<ast::RightDelimiter> {\n+        self.syntax().last_child_or_token().and_then(ast::RightDelimiter::cast_element)\n+    }\n+}"}, {"sha": "e6f3a4ebb7cf04ed5e4dcba81d5cad4dd522aeb1", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -4,9 +4,9 @@\n \n use itertools::Itertools;\n \n-use crate::{\n-    ast::{self, child_opt, children, AstChildren, AstNode, AstToken},\n-    syntax_node::SyntaxElementChildren,\n+use crate::ast::{\n+    self, child_elements, child_opt, child_token_opt, child_tokens, children, AstChildElements,\n+    AstChildTokens, AstChildren, AstNode, AstToken,\n };\n \n pub trait TypeAscriptionOwner: AstNode {\n@@ -31,6 +31,10 @@ pub trait LoopBodyOwner: AstNode {\n     fn loop_body(&self) -> Option<ast::BlockExpr> {\n         child_opt(self)\n     }\n+\n+    fn label(&self) -> Option<ast::Label> {\n+        child_opt(self)\n+    }\n }\n \n pub trait ArgListOwner: AstNode {\n@@ -65,6 +69,10 @@ pub trait TypeBoundsOwner: AstNode {\n     fn type_bound_list(&self) -> Option<ast::TypeBoundList> {\n         child_opt(self)\n     }\n+\n+    fn colon(&self) -> Option<ast::Colon> {\n+        child_token_opt(self)\n+    }\n }\n \n pub trait AttrsOwner: AstNode {\n@@ -74,11 +82,14 @@ pub trait AttrsOwner: AstNode {\n     fn has_atom_attr(&self, atom: &str) -> bool {\n         self.attrs().filter_map(|x| x.as_simple_atom()).any(|x| x == atom)\n     }\n+    fn attr_or_comments(&self) -> AstChildElements<ast::AttrOrComment> {\n+        child_elements(self)\n+    }\n }\n \n pub trait DocCommentsOwner: AstNode {\n-    fn doc_comments(&self) -> CommentIter {\n-        CommentIter { iter: self.syntax().children_with_tokens() }\n+    fn doc_comments(&self) -> AstChildTokens<ast::Comment> {\n+        child_tokens(self)\n     }\n \n     /// Returns the textual content of a doc comment block as a single string.\n@@ -123,14 +134,3 @@ pub trait DocCommentsOwner: AstNode {\n         }\n     }\n }\n-\n-pub struct CommentIter {\n-    iter: SyntaxElementChildren,\n-}\n-\n-impl Iterator for CommentIter {\n-    type Item = ast::Comment;\n-    fn next(&mut self) -> Option<ast::Comment> {\n-        self.iter.by_ref().find_map(|el| el.into_token().and_then(ast::Comment::cast))\n-    }\n-}"}, {"sha": "3200acc8676a878da578bdf73ffa537cd0a831ca", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 292, "deletions": 91, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f4d7bd8c0ecb9f23557464e824140a2be8f41a/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=60f4d7bd8c0ecb9f23557464e824140a2be8f41a", "patch": "@@ -70,7 +70,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"match\", \"mod\", \"move\", \"mut\", \"pub\", \"ref\", \"return\", \"self\", \"static\", \"struct\", \"super\",\n         \"trait\", \"true\", \"try\", \"type\", \"unsafe\", \"use\", \"where\", \"while\",\n     ],\n-    contextual_keywords: &[\"auto\", \"default\", \"existential\", \"union\"],\n+    contextual_keywords: &[\"auto\", \"default\", \"existential\", \"union\", \"raw\"],\n     literals: &[\n         \"INT_NUMBER\",\n         \"FLOAT_NUMBER\",\n@@ -297,248 +297,356 @@ macro_rules! ast_enums {\n \n pub(crate) const AST_SRC: AstSrc = AstSrc {\n     nodes: &ast_nodes! {\n-        struct SourceFile: ModuleItemOwner, FnDefOwner {\n+        struct SourceFile: ModuleItemOwner, FnDefOwner, AttrsOwner {\n             modules: [Module],\n         }\n \n         struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n+            Abi,\n+            ConstKw,\n+            DefaultKw,\n+            AsyncKw,\n+            UnsafeKw,\n+            FnKw,\n             ParamList,\n             RetType,\n             body: BlockExpr,\n+            Semi\n         }\n \n-        struct RetType { TypeRef }\n+        struct RetType { ThinArrow, TypeRef }\n \n         struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            StructKw,\n+            FieldDefList,\n+            Semi\n         }\n \n         struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            UnionKw,\n             RecordFieldDefList,\n         }\n \n-        struct RecordFieldDefList { fields: [RecordFieldDef] }\n+        struct RecordFieldDefList { LCurly, fields: [RecordFieldDef], RCurly }\n         struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n \n-        struct TupleFieldDefList { fields: [TupleFieldDef] }\n+        struct TupleFieldDefList { LParen, fields: [TupleFieldDef], RParen }\n         struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n             TypeRef,\n         }\n \n         struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            EnumKw,\n             variant_list: EnumVariantList,\n         }\n         struct EnumVariantList {\n+            LCurly,\n             variants: [EnumVariant],\n+            RCurly\n         }\n-        struct EnumVariant: NameOwner, DocCommentsOwner, AttrsOwner {\n+        struct EnumVariant: VisibilityOwner, NameOwner, DocCommentsOwner, AttrsOwner {\n+            FieldDefList,\n+            Eq,\n             Expr\n         }\n \n         struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n+            UnsafeKw,\n+            AutoKw,\n+            TraitKw,\n             ItemList,\n         }\n \n         struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n+            ModKw,\n             ItemList,\n+            Semi\n         }\n \n         struct ItemList: FnDefOwner, ModuleItemOwner {\n+            LCurly,\n             impl_items: [ImplItem],\n+            RCurly\n         }\n \n         struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            DefaultKw,\n+            ConstKw,\n+            Eq,\n             body: Expr,\n+            Semi\n         }\n \n         struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            StaticKw,\n+            MutKw,\n+            Eq,\n             body: Expr,\n+            Semi\n         }\n \n         struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n+            DefaultKw,\n+            TypeKw,\n+            Eq,\n             TypeRef,\n+            Semi\n         }\n \n         struct ImplDef: TypeParamsOwner, AttrsOwner {\n+            DefaultKw,\n+            ConstKw,\n+            UnsafeKw,\n+            ImplKw,\n+            Excl,\n+            ForKw,\n             ItemList,\n         }\n \n-        struct ParenType { TypeRef }\n-        struct TupleType { fields: [TypeRef] }\n-        struct NeverType { }\n+        struct ParenType { LParen, TypeRef, RParen }\n+        struct TupleType { LParen, fields: [TypeRef], RParen }\n+        struct NeverType { Excl }\n         struct PathType { Path }\n-        struct PointerType { TypeRef }\n-        struct ArrayType { TypeRef, Expr }\n-        struct SliceType { TypeRef }\n-        struct ReferenceType { TypeRef }\n-        struct PlaceholderType {  }\n-        struct FnPointerType { ParamList, RetType }\n-        struct ForType { TypeRef }\n-        struct ImplTraitType: TypeBoundsOwner {}\n-        struct DynTraitType: TypeBoundsOwner {}\n-\n-        struct TupleExpr { exprs: [Expr] }\n-        struct ArrayExpr { exprs: [Expr] }\n-        struct ParenExpr { Expr }\n+        struct PointerType { Star, ConstKw, TypeRef }\n+        struct ArrayType { LBrack, TypeRef, Semi, Expr, RBrack }\n+        struct SliceType { LBrack, TypeRef, RBrack }\n+        struct ReferenceType { Amp, Lifetime, MutKw, TypeRef }\n+        struct PlaceholderType { Underscore }\n+        struct FnPointerType { Abi, UnsafeKw, FnKw, ParamList, RetType }\n+        struct ForType { ForKw, TypeParamList, TypeRef }\n+        struct ImplTraitType: TypeBoundsOwner { ImplKw }\n+        struct DynTraitType: TypeBoundsOwner { DynKw }\n+\n+        struct TupleExpr: AttrsOwner { LParen, exprs: [Expr], RParen }\n+        struct ArrayExpr: AttrsOwner { LBrack, exprs: [Expr], Semi, RBrack }\n+        struct ParenExpr: AttrsOwner { LParen, Expr, RParen }\n         struct PathExpr  { Path }\n-        struct LambdaExpr {\n+        struct LambdaExpr: AttrsOwner {\n+            StaticKw,\n+            AsyncKw,\n+            MoveKw,\n             ParamList,\n             RetType,\n             body: Expr,\n         }\n-        struct IfExpr { Condition }\n-        struct LoopExpr: LoopBodyOwner { }\n-        struct TryBlockExpr { body: BlockExpr }\n-        struct ForExpr: LoopBodyOwner {\n+        struct IfExpr: AttrsOwner { IfKw, Condition }\n+        struct LoopExpr: AttrsOwner, LoopBodyOwner { LoopKw }\n+        struct TryBlockExpr: AttrsOwner { TryKw, body: BlockExpr }\n+        struct ForExpr: AttrsOwner, LoopBodyOwner {\n+            ForKw,\n             Pat,\n+            InKw,\n             iterable: Expr,\n         }\n-        struct WhileExpr: LoopBodyOwner { Condition }\n-        struct ContinueExpr {}\n-        struct BreakExpr { Expr }\n-        struct Label {}\n-        struct BlockExpr { Block  }\n-        struct ReturnExpr { Expr }\n+        struct WhileExpr: AttrsOwner, LoopBodyOwner { WhileKw, Condition }\n+        struct ContinueExpr: AttrsOwner { ContinueKw, Lifetime }\n+        struct BreakExpr: AttrsOwner { BreakKw, Lifetime, Expr }\n+        struct Label { Lifetime }\n+        struct BlockExpr: AttrsOwner { Label, UnsafeKw, Block  }\n+        struct ReturnExpr: AttrsOwner { Expr }\n         struct CallExpr: ArgListOwner { Expr }\n-        struct MethodCallExpr: ArgListOwner {\n-            Expr, NameRef, TypeArgList,\n-        }\n-        struct IndexExpr {}\n-        struct FieldExpr { Expr, NameRef }\n-        struct AwaitExpr { Expr }\n-        struct TryExpr { Expr }\n-        struct CastExpr { Expr, TypeRef }\n-        struct RefExpr { Expr }\n-        struct PrefixExpr { Expr }\n-        struct BoxExpr { Expr }\n-        struct RangeExpr {}\n-        struct BinExpr {}\n-        struct Literal {}\n-\n-        struct MatchExpr { Expr, MatchArmList }\n-        struct MatchArmList: AttrsOwner { arms: [MatchArm] }\n+        struct MethodCallExpr: AttrsOwner, ArgListOwner {\n+            Expr, Dot, NameRef, TypeArgList,\n+        }\n+        struct IndexExpr: AttrsOwner { LBrack, RBrack }\n+        struct FieldExpr: AttrsOwner { Expr, Dot, NameRef }\n+        struct AwaitExpr: AttrsOwner { Expr, Dot, AwaitKw }\n+        struct TryExpr: AttrsOwner { TryKw, Expr }\n+        struct CastExpr: AttrsOwner { Expr, AsKw, TypeRef }\n+        struct RefExpr: AttrsOwner { Amp, RawKw, MutKw, Expr }\n+        struct PrefixExpr: AttrsOwner { PrefixOp, Expr }\n+        struct BoxExpr: AttrsOwner { BoxKw, Expr }\n+        struct RangeExpr: AttrsOwner { RangeOp }\n+        struct BinExpr: AttrsOwner { BinOp }\n+        struct Literal { LiteralToken }\n+\n+        struct MatchExpr: AttrsOwner { MatchKw, Expr, MatchArmList }\n+        struct MatchArmList: AttrsOwner { LCurly, arms: [MatchArm], RCurly }\n         struct MatchArm: AttrsOwner {\n             pat: Pat,\n             guard: MatchGuard,\n+            FatArrow,\n             Expr,\n         }\n-        struct MatchGuard { Expr }\n+        struct MatchGuard { IfKw, Expr }\n \n-        struct RecordLit { Path, RecordFieldList }\n+        struct RecordLit { Path, RecordFieldList}\n         struct RecordFieldList {\n+            LCurly,\n             fields: [RecordField],\n+            Dotdot,\n             spread: Expr,\n+            RCurly\n         }\n-        struct RecordField { NameRef, Expr }\n+        struct RecordField: AttrsOwner { NameRef, Colon, Expr }\n \n         struct OrPat { pats: [Pat] }\n-        struct ParenPat { Pat }\n-        struct RefPat { Pat }\n-        struct BoxPat { Pat }\n-        struct BindPat: NameOwner { Pat }\n-        struct PlaceholderPat { }\n-        struct DotDotPat { }\n+        struct ParenPat { LParen, Pat, RParen }\n+        struct RefPat { Amp, MutKw, Pat }\n+        struct BoxPat { BoxKw, Pat }\n+        struct BindPat: AttrsOwner, NameOwner { RefKw, MutKw, Pat }\n+        struct PlaceholderPat { Underscore }\n+        struct DotDotPat { Dotdot }\n         struct PathPat { Path }\n-        struct SlicePat { args: [Pat] }\n-        struct RangePat {}\n+        struct SlicePat { LBrack, args: [Pat], RBrack }\n+        struct RangePat { RangeSeparator }\n         struct LiteralPat { Literal }\n         struct MacroPat { MacroCall }\n \n         struct RecordPat { RecordFieldPatList, Path }\n         struct RecordFieldPatList {\n+            LCurly,\n+            pats: [RecordInnerPat],\n             record_field_pats: [RecordFieldPat],\n             bind_pats: [BindPat],\n+            Dotdot,\n+            RCurly\n         }\n-        struct RecordFieldPat: NameOwner { Pat }\n+        struct RecordFieldPat: AttrsOwner, NameOwner { Colon, Pat }\n \n-        struct TupleStructPat { Path, args: [Pat] }\n-        struct TuplePat { args: [Pat] }\n+        struct TupleStructPat { Path, LParen, args: [Pat], RParen }\n+        struct TuplePat { LParen, args: [Pat], RParen }\n \n-        struct Visibility {}\n-        struct Name {}\n-        struct NameRef {}\n+        struct Visibility { PubKw, SuperKw, SelfKw, CrateKw }\n+        struct Name { Ident }\n+        struct NameRef { NameRefToken }\n \n         struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n-            TokenTree, Path\n+            Path, Excl, TokenTree, Semi\n         }\n-        struct Attr { Path, input: AttrInput }\n+        struct Attr { Pound, Excl, LBrack, Path, Eq, input: AttrInput, RBrack }\n         struct TokenTree {}\n         struct TypeParamList {\n+            LAngle,\n+            generic_params: [GenericParam],\n             type_params: [TypeParam],\n             lifetime_params: [LifetimeParam],\n+            const_params: [ConstParam],\n+            RAngle\n         }\n         struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n+            Eq,\n             default_type: TypeRef,\n         }\n         struct ConstParam: NameOwner, AttrsOwner, TypeAscriptionOwner {\n+            Eq,\n             default_val: Expr,\n         }\n-        struct LifetimeParam: AttrsOwner { }\n-        struct TypeBound { TypeRef}\n+        struct LifetimeParam: AttrsOwner { Lifetime}\n+        struct TypeBound { Lifetime, /* Question,  */ ConstKw, /* Question,  */ TypeRef}\n         struct TypeBoundList { bounds: [TypeBound] }\n-        struct WherePred: TypeBoundsOwner { TypeRef }\n-        struct WhereClause { predicates: [WherePred] }\n-        struct ExprStmt { Expr }\n-        struct LetStmt: TypeAscriptionOwner {\n+        struct WherePred: TypeBoundsOwner { Lifetime, TypeRef }\n+        struct WhereClause { WhereKw, predicates: [WherePred] }\n+        struct Abi { String }\n+        struct ExprStmt: AttrsOwner { Expr, Semi }\n+        struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n+            LetKw,\n             Pat,\n+            Eq,\n             initializer: Expr,\n         }\n-        struct Condition { Pat, Expr }\n+        struct Condition { LetKw, Pat, Eq, Expr }\n         struct Block: AttrsOwner, ModuleItemOwner {\n+            LCurly,\n             statements: [Stmt],\n+            statements_or_semi: [StmtOrSemi],\n             Expr,\n+            RCurly,\n         }\n         struct ParamList {\n+            LParen,\n             SelfParam,\n             params: [Param],\n+            RParen\n         }\n-        struct SelfParam: TypeAscriptionOwner, AttrsOwner { }\n+        struct SelfParam: TypeAscriptionOwner, AttrsOwner { Amp, Lifetime, SelfKw }\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n             Pat,\n+            Dotdotdot\n         }\n         struct UseItem: AttrsOwner, VisibilityOwner {\n+            UseKw,\n             UseTree,\n         }\n         struct UseTree {\n-            Path, UseTreeList, Alias\n+            Path, Star, UseTreeList, Alias\n         }\n-        struct Alias: NameOwner { }\n-        struct UseTreeList { use_trees: [UseTree] }\n+        struct Alias: NameOwner { AsKw }\n+        struct UseTreeList { LCurly, use_trees: [UseTree], RCurly }\n         struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n-            NameRef, Alias,\n+            ExternKw, CrateKw, NameRef, Alias,\n         }\n         struct ArgList {\n+            LParen,\n             args: [Expr],\n+            RParen\n         }\n         struct Path {\n             segment: PathSegment,\n             qualifier: Path,\n         }\n         struct PathSegment {\n-            NameRef, TypeArgList, ParamList, RetType, PathType,\n+            Coloncolon, LAngle, NameRef, TypeArgList, ParamList, RetType, PathType, RAngle\n         }\n         struct TypeArgList {\n+            Coloncolon,\n+            LAngle,\n+            generic_args: [GenericArg],\n             type_args: [TypeArg],\n             lifetime_args: [LifetimeArg],\n             assoc_type_args: [AssocTypeArg],\n-            const_arg: [ConstArg],\n+            const_args: [ConstArg],\n+            RAngle\n         }\n         struct TypeArg { TypeRef }\n-        struct AssocTypeArg { NameRef, TypeRef }\n-        struct LifetimeArg {}\n-        struct ConstArg { Literal, BlockExpr }\n+        struct AssocTypeArg : TypeBoundsOwner { NameRef, Eq, TypeRef }\n+        struct LifetimeArg { Lifetime }\n+        struct ConstArg { Literal, Eq, BlockExpr }\n \n         struct MacroItems: ModuleItemOwner, FnDefOwner { }\n \n         struct MacroStmts {\n             statements: [Stmt],\n             Expr,\n         }\n+\n+        struct ExternItemList: FnDefOwner, ModuleItemOwner {\n+            LCurly,\n+            extern_items: [ExternItem],\n+            RCurly\n+        }\n+\n+        struct ExternBlock {\n+            Abi,\n+            ExternItemList\n+        }\n+\n+        struct MetaItem {\n+            Path, Eq, AttrInput, nested_meta_items: [MetaItem]\n+        }\n+\n+        struct MacroDef {\n+            Name, TokenTree\n+        }\n     },\n     enums: &ast_enums! {\n         enum NominalDef: NameOwner, TypeParamsOwner, AttrsOwner {\n             StructDef, EnumDef, UnionDef,\n         }\n \n+        enum GenericParam {\n+            LifetimeParam,\n+            TypeParam,\n+            ConstParam\n+        }\n+\n+        enum GenericArg {\n+            LifetimeArg,\n+            TypeArg,\n+            ConstArg,\n+            AssocTypeArg\n+        }\n+\n         enum TypeRef {\n             ParenType,\n             TupleType,\n@@ -555,7 +663,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             DynTraitType,\n         }\n \n-        enum ModuleItem: AttrsOwner, VisibilityOwner {\n+        enum ModuleItem: NameOwner, AttrsOwner, VisibilityOwner {\n             StructDef,\n             UnionDef,\n             EnumDef,\n@@ -569,13 +677,20 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             StaticDef,\n             Module,\n             MacroCall,\n+            ExternBlock\n         }\n \n-        enum ImplItem: AttrsOwner {\n-            FnDef, TypeAliasDef, ConstDef,\n+        /* impl blocks can also contain MacroCall */\n+        enum ImplItem: NameOwner, AttrsOwner {\n+            FnDef, TypeAliasDef, ConstDef\n         }\n \n-        enum Expr {\n+        /* extern blocks can also contain MacroCall */\n+        enum ExternItem: NameOwner, AttrsOwner, VisibilityOwner {\n+            FnDef, StaticDef\n+        }\n+\n+        enum Expr: AttrsOwner {\n             TupleExpr,\n             ArrayExpr,\n             ParenExpr,\n@@ -627,7 +742,93 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             MacroPat,\n         }\n \n+        enum RecordInnerPat {\n+            RecordFieldPat,\n+            BindPat\n+        }\n+\n         enum AttrInput { Literal, TokenTree }\n-        enum Stmt { ExprStmt, LetStmt }\n+        enum Stmt {\n+            ModuleItem,\n+            LetStmt,\n+            ExprStmt,\n+            // macro calls are parsed as expression statements */\n+        }\n+        enum StmtOrSemi {Stmt, Semi}\n+\n+        enum LeftDelimiter { LParen, LBrack, LCurly }\n+        enum RightDelimiter { RParen, RBrack, RCurly }\n+        enum RangeSeparator { Dotdot, Dotdotdot, Dotdoteq}\n+\n+        enum BinOp {\n+            Pipepipe,\n+            Ampamp,\n+            Eqeq,\n+            Neq,\n+            Lteq,\n+            Gteq,\n+            LAngle,\n+            RAngle,\n+            Plus,\n+            Star,\n+            Minus,\n+            Slash,\n+            Percent,\n+            Shl,\n+            Shr,\n+            Caret,\n+            Pipe,\n+            Amp,\n+            Eq,\n+            Pluseq,\n+            Slasheq,\n+            Stareq,\n+            Percenteq,\n+            Shreq,\n+            Shleq,\n+            Minuseq,\n+            Pipeeq,\n+            Ampeq,\n+            Careteq,\n+        }\n+\n+        enum PrefixOp {\n+            Minus,\n+            Excl,\n+            Star\n+        }\n+\n+        enum RangeOp {\n+            Dotdot,\n+            Dotdoteq\n+        }\n+\n+        enum LiteralToken {\n+            IntNumber,\n+            FloatNumber,\n+            String,\n+            RawString,\n+            TrueKw,\n+            FalseKw,\n+            ByteString,\n+            RawByteString,\n+            Char,\n+            Byte\n+        }\n+\n+        enum NameRefToken {\n+            Ident,\n+            IntNumber\n+        }\n+\n+        enum FieldDefList {\n+            RecordFieldDefList,\n+            TupleFieldDefList,\n+        }\n+\n+        enum AttrOrComment {\n+            Attr,\n+            Comment\n+        }\n     },\n };"}]}