{"sha": "00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZGFlYjQ4NWM5YTZkMmQzY2RhYWFjZDRhYzYxMGUyZjhiZmYxNGU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T10:23:58Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T10:23:58Z"}, "message": "Move type_is_immediate into ty.rs", "tree": {"sha": "bfb401bdad06098e141660535b76deda258f6259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfb401bdad06098e141660535b76deda258f6259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e", "html_url": "https://github.com/rust-lang/rust/commit/00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a35dbf3fd51fd0807c6d914dcadc85471188486b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a35dbf3fd51fd0807c6d914dcadc85471188486b", "html_url": "https://github.com/rust-lang/rust/commit/a35dbf3fd51fd0807c6d914dcadc85471188486b"}], "stats": {"total": 22, "additions": 6, "deletions": 16}, "files": [{"sha": "92cd1f76e611f4625f5c546de823f2dc3dca8fd6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=00daeb485c9a6d2d3cdaaacd4ac610e2f8bff14e", "patch": "@@ -3724,7 +3724,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n     } else if arg.mode == ast::by_ref || arg.mode == ast::by_val {\n-        let copied = false, imm = type_is_immediate(ccx, e_ty);\n+        let copied = false, imm = ty::type_is_immediate(ccx.tcx, e_ty);\n         if arg.mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n@@ -3741,7 +3741,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n         if arg.mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n-    } else if type_is_immediate(ccx, e_ty) && lv.kind != owned {\n+    } else if ty::type_is_immediate(ccx.tcx, e_ty) && lv.kind != owned {\n         let r = do_spill(bcx, val, e_ty);\n         val = r.val;\n         bcx = r.bcx;\n@@ -4243,7 +4243,7 @@ fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n         if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n             bcx = trans_expr(bcx, e, ignore);\n             ret {bcx: bcx, val: C_nil(), kind: temporary};\n-        } else if type_is_immediate(bcx_ccx(bcx), ty) {\n+        } else if ty::type_is_immediate(bcx_tcx(bcx), ty) {\n             let cell = empty_dest_cell();\n             bcx = trans_expr(bcx, e, by_val(cell));\n             add_clean_temp(bcx, *cell, ty);\n@@ -4467,16 +4467,6 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     ret bcx;\n }\n \n-// We pass structural values around the compiler \"by pointer\" and\n-// non-structural values (scalars, boxes, pointers) \"by value\". We call the\n-// latter group \"immediates\" and, in some circumstances when we know we have a\n-// pointer (or need one), perform load/store operations based on the\n-// immediate-ness of the type.\n-// FIXME simply call the version in ty.rs immediately\n-fn type_is_immediate(ccx: @crate_ctxt, t: ty::t) -> bool {\n-    ty::type_is_immediate(ccx.tcx, t)\n-}\n-\n fn do_spill(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n     // We have a value but we have to spill it, and root it, to pass by alias.\n     let bcx = cx;\n@@ -4503,12 +4493,12 @@ fn do_spill_noroot(cx: @block_ctxt, v: ValueRef) -> ValueRef {\n }\n \n fn spill_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n-    if type_is_immediate(bcx_ccx(cx), t) { ret do_spill(cx, v, t); }\n+    if ty::type_is_immediate(bcx_tcx(cx), t) { ret do_spill(cx, v, t); }\n     ret rslt(cx, v);\n }\n \n fn load_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n-    if type_is_immediate(bcx_ccx(cx), t) { ret Load(cx, v); }\n+    if ty::type_is_immediate(bcx_tcx(cx), t) { ret Load(cx, v); }\n     ret v;\n }\n \n@@ -5343,7 +5333,7 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n        f.proto == ast::proto_iter ||\n        option::is_none(f.body.node.expr) {\n         bcx = trans_block_dps(bcx, f.body, ignore);\n-    } else if type_is_immediate(cx.ccx, block_ty) {\n+    } else if ty::type_is_immediate(cx.ccx.tcx, block_ty) {\n         let cell = empty_dest_cell();\n         bcx = trans_block_dps(bcx, f.body, by_val(cell));\n         Store(bcx, *cell, fcx.llretptr);"}]}