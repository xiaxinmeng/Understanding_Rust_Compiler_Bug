{"sha": "e240eb67a86bb4deff2762e3c46f47278ccd975c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNDBlYjY3YTg2YmI0ZGVmZjI3NjJlM2M0NmY0NzI3OGNjZDk3NWM=", "commit": {"author": {"name": "Alex Good", "email": "alex@memoryandthought.me", "date": "2021-07-12T14:47:47Z"}, "committer": {"name": "Alex Good", "email": "alex@memoryandthought.me", "date": "2021-07-12T15:05:45Z"}, "message": "Introduce proc_macro_srv::abis, impl 1.47 and 1.55\n\nRather than a \"Stable\" and \"Nightly\" ABI we instead name ABIs based on\nthe version of the rust compiler in which they were introduced. We place\nthese ABIs in a new module - `proc_macro_srv::abis` - where we also add\nsome mchinery to abstract over ABIs. This should make it easy to add new\nABIs at a later date as the rust compiler evolves.", "tree": {"sha": "23791831e4261758d72f3cf8b992d73788bd5ee8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23791831e4261758d72f3cf8b992d73788bd5ee8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e240eb67a86bb4deff2762e3c46f47278ccd975c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e240eb67a86bb4deff2762e3c46f47278ccd975c", "html_url": "https://github.com/rust-lang/rust/commit/e240eb67a86bb4deff2762e3c46f47278ccd975c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e240eb67a86bb4deff2762e3c46f47278ccd975c/comments", "author": {"login": "alexjg", "id": 224635, "node_id": "MDQ6VXNlcjIyNDYzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/224635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexjg", "html_url": "https://github.com/alexjg", "followers_url": "https://api.github.com/users/alexjg/followers", "following_url": "https://api.github.com/users/alexjg/following{/other_user}", "gists_url": "https://api.github.com/users/alexjg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexjg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexjg/subscriptions", "organizations_url": "https://api.github.com/users/alexjg/orgs", "repos_url": "https://api.github.com/users/alexjg/repos", "events_url": "https://api.github.com/users/alexjg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexjg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexjg", "id": 224635, "node_id": "MDQ6VXNlcjIyNDYzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/224635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexjg", "html_url": "https://github.com/alexjg", "followers_url": "https://api.github.com/users/alexjg/followers", "following_url": "https://api.github.com/users/alexjg/following{/other_user}", "gists_url": "https://api.github.com/users/alexjg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexjg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexjg/subscriptions", "organizations_url": "https://api.github.com/users/alexjg/orgs", "repos_url": "https://api.github.com/users/alexjg/repos", "events_url": "https://api.github.com/users/alexjg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexjg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14a51d28b530331151e636986e57912da7e406ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a51d28b530331151e636986e57912da7e406ec", "html_url": "https://github.com/rust-lang/rust/commit/14a51d28b530331151e636986e57912da7e406ec"}], "stats": {"total": 717, "additions": 390, "deletions": 327}, "files": [{"sha": "6bbdcc5868658a0a61039c104a068154c47ccbaf", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/mod.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fmod.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -0,0 +1,106 @@\n+//! Macro ABI for version 1.47 of rustc\n+\n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod proc_macro;\n+\n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod rustc_server;\n+use libloading::Library;\n+\n+use proc_macro_api::ProcMacroKind;\n+\n+use super::PanicMessage;\n+\n+pub use rustc_server::TokenStream;\n+\n+pub(crate) struct Abi {\n+    exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n+}\n+\n+impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n+    fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n+        Self { message: p.as_str().map(|s| s.to_string()) }\n+    }\n+}\n+\n+impl Abi {\n+    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n+        let macros: libloading::Symbol<&&[proc_macro::bridge::client::ProcMacro]> =\n+            lib.get(symbol_name.as_bytes())?;\n+        Ok(Self { exported_macros: macros.to_vec() })\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        macro_name: &str,\n+        macro_body: &tt::Subtree,\n+        attributes: Option<&tt::Subtree>,\n+    ) -> Result<tt::Subtree, PanicMessage> {\n+        let parsed_body = rustc_server::TokenStream::with_subtree(macro_body.clone());\n+\n+        let parsed_attributes = attributes.map_or(rustc_server::TokenStream::new(), |attr| {\n+            rustc_server::TokenStream::with_subtree(attr.clone())\n+        });\n+\n+        for proc_macro in &self.exported_macros {\n+            match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive {\n+                    trait_name, client, ..\n+                } if *trait_name == macro_name => {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_attributes,\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                _ => continue,\n+            }\n+        }\n+\n+        Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n+    }\n+\n+    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+        self.exported_macros\n+            .iter()\n+            .map(|proc_macro| match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::FuncLike)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::Attr)\n+                }\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "3b2afe01f5bfb94104a12c66bc2360df52428a6e", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/buffer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/buffer.rs"}, {"sha": "9f74fb06689f5aef9b3e965338c01384f044ef19", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/client.rs", "status": "renamed", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fclient.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -3,6 +3,7 @@\n //! Copy from <https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/client.rs>\n //! augmented with removing unstable features\n \n+use super::super::TokenStream as CrateTokenStream;\n use super::*;\n \n macro_rules! define_handles {\n@@ -401,26 +402,26 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     b\n }\n \n-impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n-    pub fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+impl Client<fn(CrateTokenStream) -> CrateTokenStream> {\n+    pub fn expand1(f: fn(CrateTokenStream) -> CrateTokenStream) -> Self {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n-            f: impl FnOnce(crate::TokenStream) -> crate::TokenStream,\n+            f: impl FnOnce(CrateTokenStream) -> CrateTokenStream,\n         ) -> Buffer<u8> {\n-            run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+            run_client(bridge, |input| f(CrateTokenStream(input)).0)\n         }\n         Client { get_handle_counters: HandleCounters::get, run, f }\n     }\n }\n \n-impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n-    pub fn expand2(f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream) -> Self {\n+impl Client<fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream> {\n+    pub fn expand2(f: fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream) -> Self {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n-            f: impl FnOnce(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+            f: impl FnOnce(CrateTokenStream, CrateTokenStream) -> CrateTokenStream,\n         ) -> Buffer<u8> {\n             run_client(bridge, |(input, input2)| {\n-                f(crate::TokenStream(input), crate::TokenStream(input2)).0\n+                f(CrateTokenStream(input), CrateTokenStream(input2)).0\n             })\n         }\n         Client { get_handle_counters: HandleCounters::get, run, f }\n@@ -433,17 +434,17 @@ pub enum ProcMacro {\n     CustomDerive {\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<fn(CrateTokenStream) -> CrateTokenStream>,\n     },\n \n     Attr {\n         name: &'static str,\n-        client: Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream>,\n     },\n \n     Bang {\n         name: &'static str,\n-        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<fn(CrateTokenStream) -> CrateTokenStream>,\n     },\n }\n \n@@ -465,19 +466,19 @@ impl ProcMacro {\n     pub fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        expand: fn(crate::TokenStream) -> crate::TokenStream,\n+        expand: fn(CrateTokenStream) -> CrateTokenStream,\n     ) -> Self {\n         ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n     }\n \n     pub fn attr(\n         name: &'static str,\n-        expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+        expand: fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream,\n     ) -> Self {\n         ProcMacro::Attr { name, client: Client::expand2(expand) }\n     }\n \n-    pub fn bang(name: &'static str, expand: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+    pub fn bang(name: &'static str, expand: fn(CrateTokenStream) -> CrateTokenStream) -> Self {\n         ProcMacro::Bang { name, client: Client::expand1(expand) }\n     }\n }", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/client.rs"}, {"sha": "f5b6d897e43cbc2110bd45e44f2c84ff6b54fa8f", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/closure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/closure.rs"}, {"sha": "d2a65d249b5edf5b77ee160f4b1294fb7253186a", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/handle.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/handle.rs"}, {"sha": "be5402d6eed4fb6c2b2cc50d3f5caddc86bb9d1f", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fmod.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -13,7 +13,7 @@\n \n #![deny(unsafe_code)]\n \n-pub use crate::proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+pub use super::{Delimiter, Level, LineColumn, Spacing};\n use std::fmt;\n use std::hash::Hash;\n use std::marker;", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/mod.rs"}, {"sha": "69928ec845aba45f38c9992942486e098ea3f674", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/rpc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Frpc.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/rpc.rs"}, {"sha": "0436bc41836c2176d846ba9946ff0b8bd6103b5e", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/scoped_cell.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/scoped_cell.rs"}, {"sha": "a580419fd13f8fd7ca488ef9b9b3053f6ca065c9", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/bridge/server.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fbridge%2Fserver.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -3,6 +3,7 @@\n //! Copy from <https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/server.rs>\n //! augmented with removing unstable features\n \n+use super::super::TokenStream as ProcMacroTokenStream;\n use super::*;\n \n // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n@@ -308,7 +309,7 @@ fn run_server<\n     Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n }\n \n-impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+impl client::Client<fn(ProcMacroTokenStream) -> ProcMacroTokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n@@ -330,7 +331,7 @@ impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n     }\n }\n \n-impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+impl client::Client<fn(ProcMacroTokenStream, ProcMacroTokenStream) -> ProcMacroTokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,", "previous_filename": "crates/proc_macro_srv/src/proc_macro/bridge/server.rs"}, {"sha": "6953b1ecf4cb1ac459c7b83f9b96b4a9a01af367", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/diagnostic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fdiagnostic.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/diagnostic.rs"}, {"sha": "aaa7103756710bff99406d01cf780f92ffd5988e", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/proc_macro/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fproc_macro%2Fmod.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -133,7 +133,7 @@ impl Extend<TokenStream> for TokenStream {\n \n /// Public implementation details for the `TokenStream` type, such as iterators.\n pub mod token_stream {\n-    use crate::proc_macro::{bridge, Group, Ident, Literal, Punct, TokenStream, TokenTree};\n+    use super::{bridge, Group, Ident, Literal, Punct, TokenStream, TokenTree};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n     /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,", "previous_filename": "crates/proc_macro_srv/src/proc_macro/mod.rs"}, {"sha": "088cc694e83988c3f495b197c54cda9b9bdf386e", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/rustc_server.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Frustc_server.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -8,7 +8,7 @@\n //!\n //! FIXME: No span and source file information is implemented yet\n \n-use crate::proc_macro::bridge::{self, server};\n+use super::proc_macro::bridge::{self, server};\n \n use std::collections::HashMap;\n use std::hash::Hash;\n@@ -97,9 +97,9 @@ impl Extend<TokenStream> for TokenStream {\n     }\n }\n \n-type Level = crate::proc_macro::Level;\n-type LineColumn = crate::proc_macro::LineColumn;\n-type SourceFile = crate::proc_macro::SourceFile;\n+type Level = super::proc_macro::Level;\n+type LineColumn = super::proc_macro::LineColumn;\n+type SourceFile = super::proc_macro::SourceFile;\n \n /// A structure representing a diagnostic message and associated children\n /// messages.\n@@ -734,8 +734,8 @@ impl server::MultiSpan for Rustc {\n \n #[cfg(test)]\n mod tests {\n+    use super::super::proc_macro::bridge::server::Literal;\n     use super::*;\n-    use crate::proc_macro::bridge::server::Literal;\n \n     #[test]\n     fn test_rustc_server_literals() {", "previous_filename": "crates/proc_macro_srv/src/rustc_server.rs"}, {"sha": "812601620756eaa194a01ba98af5ef3086510a95", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/mod.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fmod.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -0,0 +1,104 @@\n+//! Macro ABI for version 1.55 of rustc\n+\n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod proc_macro;\n+\n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod rustc_server;\n+use libloading::Library;\n+\n+use proc_macro_api::ProcMacroKind;\n+\n+use super::PanicMessage;\n+\n+pub(crate) struct Abi {\n+    exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n+}\n+\n+impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n+    fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n+        Self { message: p.as_str().map(|s| s.to_string()) }\n+    }\n+}\n+\n+impl Abi {\n+    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n+        let macros: libloading::Symbol<&&[proc_macro::bridge::client::ProcMacro]> =\n+            lib.get(symbol_name.as_bytes())?;\n+        Ok(Self { exported_macros: macros.to_vec() })\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        macro_name: &str,\n+        macro_body: &tt::Subtree,\n+        attributes: Option<&tt::Subtree>,\n+    ) -> Result<tt::Subtree, PanicMessage> {\n+        let parsed_body = rustc_server::TokenStream::with_subtree(macro_body.clone());\n+\n+        let parsed_attributes = attributes.map_or(rustc_server::TokenStream::new(), |attr| {\n+            rustc_server::TokenStream::with_subtree(attr.clone())\n+        });\n+\n+        for proc_macro in &self.exported_macros {\n+            match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive {\n+                    trait_name, client, ..\n+                } if *trait_name == macro_name => {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_attributes,\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                _ => continue,\n+            }\n+        }\n+\n+        Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n+    }\n+\n+    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+        self.exported_macros\n+            .iter()\n+            .map(|proc_macro| match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::FuncLike)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::Attr)\n+                }\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "1565db187c6d704dc4113cdad0d712dd03867b24", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/buffer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/buffer.rs"}, {"sha": "9f74fb06689f5aef9b3e965338c01384f044ef19", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/client.rs", "status": "renamed", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fclient.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -3,6 +3,7 @@\n //! Copy from <https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/client.rs>\n //! augmented with removing unstable features\n \n+use super::super::TokenStream as CrateTokenStream;\n use super::*;\n \n macro_rules! define_handles {\n@@ -401,26 +402,26 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     b\n }\n \n-impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n-    pub fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+impl Client<fn(CrateTokenStream) -> CrateTokenStream> {\n+    pub fn expand1(f: fn(CrateTokenStream) -> CrateTokenStream) -> Self {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n-            f: impl FnOnce(crate::TokenStream) -> crate::TokenStream,\n+            f: impl FnOnce(CrateTokenStream) -> CrateTokenStream,\n         ) -> Buffer<u8> {\n-            run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+            run_client(bridge, |input| f(CrateTokenStream(input)).0)\n         }\n         Client { get_handle_counters: HandleCounters::get, run, f }\n     }\n }\n \n-impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n-    pub fn expand2(f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream) -> Self {\n+impl Client<fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream> {\n+    pub fn expand2(f: fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream) -> Self {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n-            f: impl FnOnce(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+            f: impl FnOnce(CrateTokenStream, CrateTokenStream) -> CrateTokenStream,\n         ) -> Buffer<u8> {\n             run_client(bridge, |(input, input2)| {\n-                f(crate::TokenStream(input), crate::TokenStream(input2)).0\n+                f(CrateTokenStream(input), CrateTokenStream(input2)).0\n             })\n         }\n         Client { get_handle_counters: HandleCounters::get, run, f }\n@@ -433,17 +434,17 @@ pub enum ProcMacro {\n     CustomDerive {\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<fn(CrateTokenStream) -> CrateTokenStream>,\n     },\n \n     Attr {\n         name: &'static str,\n-        client: Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream>,\n     },\n \n     Bang {\n         name: &'static str,\n-        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<fn(CrateTokenStream) -> CrateTokenStream>,\n     },\n }\n \n@@ -465,19 +466,19 @@ impl ProcMacro {\n     pub fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        expand: fn(crate::TokenStream) -> crate::TokenStream,\n+        expand: fn(CrateTokenStream) -> CrateTokenStream,\n     ) -> Self {\n         ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n     }\n \n     pub fn attr(\n         name: &'static str,\n-        expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+        expand: fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream,\n     ) -> Self {\n         ProcMacro::Attr { name, client: Client::expand2(expand) }\n     }\n \n-    pub fn bang(name: &'static str, expand: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+    pub fn bang(name: &'static str, expand: fn(CrateTokenStream) -> CrateTokenStream) -> Self {\n         ProcMacro::Bang { name, client: Client::expand1(expand) }\n     }\n }", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/client.rs"}, {"sha": "f5b6d897e43cbc2110bd45e44f2c84ff6b54fa8f", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/closure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/closure.rs"}, {"sha": "d2a65d249b5edf5b77ee160f4b1294fb7253186a", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/handle.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/handle.rs"}, {"sha": "8d97bddfd389a7d3f94302999b87f91e3c771510", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fmod.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/mod.rs"}, {"sha": "69928ec845aba45f38c9992942486e098ea3f674", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/rpc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Frpc.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/rpc.rs"}, {"sha": "0436bc41836c2176d846ba9946ff0b8bd6103b5e", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/scoped_cell.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/scoped_cell.rs"}, {"sha": "21563fe604980cf4f11ffa590740b2847532d329", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/bridge/server.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fbridge%2Fserver.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -3,6 +3,7 @@\n //! Copy from <https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/server.rs>\n //! augmented with removing unstable features\n \n+use super::super::TokenStream as CrateTokenStream;\n use super::*;\n \n // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n@@ -302,7 +303,7 @@ fn run_server<\n     Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n }\n \n-impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+impl client::Client<fn(CrateTokenStream) -> CrateTokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n@@ -324,7 +325,7 @@ impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n     }\n }\n \n-impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+impl client::Client<fn(CrateTokenStream, CrateTokenStream) -> CrateTokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/server.rs"}, {"sha": "6953b1ecf4cb1ac459c7b83f9b96b4a9a01af367", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/diagnostic.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fdiagnostic.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -3,7 +3,7 @@\n //! Copy from <https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/diagnostic.rs>\n //! augmented with removing unstable features\n \n-use crate::proc_macro::Span;\n+use super::Span;\n \n /// An enum representing a diagnostic level.\n #[derive(Copy, Clone, Debug)]\n@@ -146,15 +146,15 @@ impl Diagnostic {\n \n     /// Emit the diagnostic.\n     pub fn emit(self) {\n-        fn to_internal(spans: Vec<Span>) -> crate::proc_macro::bridge::client::MultiSpan {\n-            let mut multi_span = crate::proc_macro::bridge::client::MultiSpan::new();\n+        fn to_internal(spans: Vec<Span>) -> super::bridge::client::MultiSpan {\n+            let mut multi_span = super::bridge::client::MultiSpan::new();\n             for span in spans {\n                 multi_span.push(span.0);\n             }\n             multi_span\n         }\n \n-        let mut diag = crate::proc_macro::bridge::client::Diagnostic::new(\n+        let mut diag = super::bridge::client::Diagnostic::new(\n             self.level,\n             &self.message[..],\n             to_internal(self.spans),", "previous_filename": "crates/proc_macro_srv/src/proc_macro/diagnostic.rs"}, {"sha": "5814267cfc576e19ca1ef4ede40b7559baa8c309", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/proc_macro/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fproc_macro%2Fmod.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "previous_filename": "crates/proc_macro_srv/src/proc_macro_nightly/mod.rs"}, {"sha": "8dfd65ade1c8f0c2e8f733216c1e2733e0950b92", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/rustc_server.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Frustc_server.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -8,7 +8,7 @@\n //!\n //! FIXME: No span and source file information is implemented yet\n \n-use crate::proc_macro_nightly::bridge::{self, server};\n+use super::proc_macro::bridge::{self, server};\n \n use std::collections::HashMap;\n use std::hash::Hash;\n@@ -97,9 +97,9 @@ impl Extend<TokenStream> for TokenStream {\n     }\n }\n \n-type Level = crate::proc_macro_nightly::Level;\n-type LineColumn = crate::proc_macro_nightly::LineColumn;\n-type SourceFile = crate::proc_macro_nightly::SourceFile;\n+type Level = super::proc_macro::Level;\n+type LineColumn = super::proc_macro::LineColumn;\n+type SourceFile = super::proc_macro::SourceFile;\n \n /// A structure representing a diagnostic message and associated children\n /// messages.\n@@ -737,8 +737,8 @@ impl server::MultiSpan for Rustc {\n \n #[cfg(test)]\n mod tests {\n+    use super::super::proc_macro::bridge::server::Literal;\n     use super::*;\n-    use crate::proc_macro_nightly::bridge::server::Literal;\n \n     #[test]\n     fn test_rustc_server_literals() {", "previous_filename": "crates/proc_macro_srv/src/rustc_server_nightly.rs"}, {"sha": "3b30aaa90bd2f0da6be86aaf2676d8f4612ad716", "filename": "crates/proc_macro_srv/src/abis/mod.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fmod.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -0,0 +1,97 @@\n+//! Procedural macros are implemented by compiling the macro providing crate\n+//! to a dynamic library with a particular ABI which the compiler uses to expand\n+//! macros. Unfortunately this ABI is not specified and can change from version\n+//! to version of the compiler. To support this we copy the ABI from the rust\n+//! compiler into submodules of this module (e.g proc_macro_srv::abis::abi_1_47).\n+//!\n+//! All of these ABIs are subsumed in the `Abi` enum, which exposes a simple\n+//! interface the rest of rust analyzer can use to talk to the macro\n+//! provider.\n+//!\n+//! # Adding a new ABI\n+//!\n+//! To add a new ABI you'll need to copy the source of the target proc_macro\n+//! crate from the source tree of the Rust compiler into this directory tree.\n+//! Then you'll need to modify it\n+//! - Remove any feature! or other things which won't compile on stable\n+//! - change any absolute imports to relative imports within the ABI tree\n+//!\n+//! Then you'll need to add a branch to the `Abi` enum and an implementation of\n+//! `Abi::expand`, `Abi::list_macros` and `Abi::from_lib` for the new ABI. See\n+//! `proc_macro_srv/src/abis/abi_1_47/mod.rs` for an example. Finally you'll\n+//! need to update the conditionals in `Abi::from_lib` to return your new ABI\n+//! for the relevant versions of the rust compiler\n+//!\n+\n+// pub(crate) so tests can use the TokenStream, more notes in test/utils.rs\n+pub(crate) mod abi_1_47;\n+mod abi_1_55;\n+\n+use super::dylib::LoadProcMacroDylibError;\n+pub(crate) use abi_1_47::Abi as Abi_1_47;\n+pub(crate) use abi_1_55::Abi as Abi_1_55;\n+use libloading::Library;\n+use proc_macro_api::{ProcMacroKind, RustCInfo};\n+\n+pub struct PanicMessage {\n+    message: Option<String>,\n+}\n+\n+impl PanicMessage {\n+    pub fn as_str(&self) -> Option<String> {\n+        self.message.clone()\n+    }\n+}\n+\n+pub(crate) enum Abi {\n+    Abi1_47(Abi_1_47),\n+    Abi1_55(Abi_1_55),\n+}\n+\n+impl Abi {\n+    /// Load a new ABI.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// *`lib` - The dynamic library containing the macro implementations\n+    /// *`symbol_name` - The symbol name the macros can be found attributes\n+    /// *`info` - RustCInfo about the compiler that was used to compile the\n+    ///           macro crate. This is the information we use to figure out\n+    ///           which ABI to return\n+    pub fn from_lib(\n+        lib: &Library,\n+        symbol_name: String,\n+        info: RustCInfo,\n+    ) -> Result<Abi, LoadProcMacroDylibError> {\n+        if info.version.0 != 1 {\n+            Err(LoadProcMacroDylibError::UnsupportedABI)\n+        } else if info.version.1 < 47 {\n+            Err(LoadProcMacroDylibError::UnsupportedABI)\n+        } else if info.version.1 < 54 {\n+            let inner = unsafe { Abi_1_47::from_lib(lib, symbol_name) }?;\n+            Ok(Abi::Abi1_47(inner))\n+        } else {\n+            let inner = unsafe { Abi_1_55::from_lib(lib, symbol_name) }?;\n+            Ok(Abi::Abi1_55(inner))\n+        }\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        macro_name: &str,\n+        macro_body: &tt::Subtree,\n+        attributes: Option<&tt::Subtree>,\n+    ) -> Result<tt::Subtree, PanicMessage> {\n+        match self {\n+            Self::Abi1_55(abi) => abi.expand(macro_name, macro_body, attributes),\n+            Self::Abi1_47(abi) => abi.expand(macro_name, macro_body, attributes),\n+        }\n+    }\n+\n+    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+        match self {\n+            Self::Abi1_47(abi) => abi.list_macros(),\n+            Self::Abi1_55(abi) => abi.list_macros(),\n+        }\n+    }\n+}"}, {"sha": "5f0b0b061e19c5c125bfe1600f4f837ccd5eb4a5", "filename": "crates/proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 20, "deletions": 258, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -1,7 +1,6 @@\n //! Handles dynamic library loading for proc macro\n \n use std::{\n-    convert::{TryFrom, TryInto},\n     fmt,\n     fs::File,\n     io,\n@@ -11,16 +10,9 @@ use std::{\n use libloading::Library;\n use memmap2::Mmap;\n use object::Object;\n-use proc_macro_api::{read_dylib_info, ProcMacroKind, RustCInfo};\n+use proc_macro_api::{read_dylib_info, ProcMacroKind};\n \n-use crate::{\n-    proc_macro::bridge::{self as stable_bridge, client::ProcMacro as StableProcMacro},\n-    rustc_server::TokenStream as StableTokenStream,\n-};\n-use crate::{\n-    proc_macro_nightly::bridge::{self as nightly_bridge, client::ProcMacro as NightlyProcMacro},\n-    rustc_server_nightly::TokenStream as NightlyTokenStream,\n-};\n+use super::abis::Abi;\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n \n@@ -83,30 +75,10 @@ fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n     unsafe { UnixLibrary::open(Some(file), RTLD_NOW | RTLD_DEEPBIND).map(|lib| lib.into()) }\n }\n \n-enum ProcMacroABI {\n-    Stable,\n-    Nightly,\n-}\n-\n-impl TryFrom<RustCInfo> for ProcMacroABI {\n-    type Error = LoadProcMacroDylibError;\n-\n-    fn try_from(info: RustCInfo) -> Result<Self, Self::Error> {\n-        if info.version.0 != 1 {\n-            Err(LoadProcMacroDylibError::UnsupportedABI)\n-        } else if info.version.1 < 47 {\n-            Err(LoadProcMacroDylibError::UnsupportedABI)\n-        } else if info.version.1 < 54 {\n-            Ok(ProcMacroABI::Stable)\n-        } else {\n-            Ok(ProcMacroABI::Nightly)\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n pub enum LoadProcMacroDylibError {\n     Io(io::Error),\n+    LibLoading(libloading::Error),\n     UnsupportedABI,\n }\n \n@@ -115,6 +87,7 @@ impl fmt::Display for LoadProcMacroDylibError {\n         match self {\n             Self::Io(e) => e.fmt(f),\n             Self::UnsupportedABI => write!(f, \"unsupported ABI version\"),\n+            Self::LibLoading(e) => e.fmt(f),\n         }\n     }\n }\n@@ -125,15 +98,16 @@ impl From<io::Error> for LoadProcMacroDylibError {\n     }\n }\n \n-enum ProcMacroLibraryLibloading {\n-    StableProcMacroLibrary {\n-        _lib: Library,\n-        exported_macros: Vec<crate::proc_macro::bridge::client::ProcMacro>,\n-    },\n-    NightlyProcMacroLibrary {\n-        _lib: Library,\n-        exported_macros: Vec<crate::proc_macro_nightly::bridge::client::ProcMacro>,\n-    },\n+impl From<libloading::Error> for LoadProcMacroDylibError {\n+    fn from(e: libloading::Error) -> Self {\n+        LoadProcMacroDylibError::LibLoading(e)\n+    }\n+}\n+\n+struct ProcMacroLibraryLibloading {\n+    // Hold on to the library so it doesn't unload\n+    _lib: Library,\n+    abi: Abi,\n }\n \n impl ProcMacroLibraryLibloading {\n@@ -143,57 +117,10 @@ impl ProcMacroLibraryLibloading {\n         })?;\n \n         let version_info = read_dylib_info(file)?;\n-        let macro_abi: ProcMacroABI = version_info.try_into()?;\n \n         let lib = load_library(file).map_err(invalid_data_err)?;\n-        match macro_abi {\n-            ProcMacroABI::Stable => {\n-                let macros: libloading::Symbol<&&[crate::proc_macro::bridge::client::ProcMacro]> =\n-                    unsafe { lib.get(symbol_name.as_bytes()) }.map_err(invalid_data_err)?;\n-                let macros_vec = macros.to_vec();\n-                Ok(ProcMacroLibraryLibloading::StableProcMacroLibrary {\n-                    _lib: lib,\n-                    exported_macros: macros_vec,\n-                })\n-            }\n-            ProcMacroABI::Nightly => {\n-                let macros: libloading::Symbol<\n-                    &&[crate::proc_macro_nightly::bridge::client::ProcMacro],\n-                > = unsafe { lib.get(symbol_name.as_bytes()) }.map_err(invalid_data_err)?;\n-                let macros_vec = macros.to_vec();\n-                Ok(ProcMacroLibraryLibloading::NightlyProcMacroLibrary {\n-                    _lib: lib,\n-                    exported_macros: macros_vec,\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub enum PanicMessage {\n-    Stable(stable_bridge::PanicMessage),\n-    Nightly(nightly_bridge::PanicMessage),\n-}\n-\n-impl From<stable_bridge::PanicMessage> for PanicMessage {\n-    fn from(p: stable_bridge::PanicMessage) -> Self {\n-        PanicMessage::Stable(p)\n-    }\n-}\n-\n-impl From<nightly_bridge::PanicMessage> for PanicMessage {\n-    fn from(p: nightly_bridge::PanicMessage) -> Self {\n-        PanicMessage::Nightly(p)\n-    }\n-}\n-\n-impl PanicMessage {\n-    pub fn as_str(&self) -> Option<&str> {\n-        match self {\n-            Self::Stable(p) => p.as_str(),\n-            Self::Nightly(p) => p.as_str(),\n-        }\n+        let abi = Abi::from_lib(&lib, symbol_name, version_info)?;\n+        Ok(ProcMacroLibraryLibloading { _lib: lib, abi })\n     }\n }\n \n@@ -219,28 +146,13 @@ impl Expander {\n         macro_name: &str,\n         macro_body: &tt::Subtree,\n         attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, PanicMessage> {\n-        match &self.inner {\n-            ProcMacroLibraryLibloading::StableProcMacroLibrary { exported_macros, .. } => {\n-                expand_stable(macro_name, macro_body, attributes, &exported_macros[..])\n-                    .map_err(PanicMessage::from)\n-            }\n-            ProcMacroLibraryLibloading::NightlyProcMacroLibrary { exported_macros, .. } => {\n-                expand_nightly(macro_name, macro_body, attributes, &exported_macros[..])\n-                    .map_err(PanicMessage::from)\n-            }\n-        }\n+    ) -> Result<tt::Subtree, String> {\n+        let result = self.inner.abi.expand(macro_name, macro_body, attributes);\n+        result.map_err(|e| e.as_str().unwrap_or_else(|| \"<unknown error>\".to_string()))\n     }\n \n     pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        match &self.inner {\n-            ProcMacroLibraryLibloading::StableProcMacroLibrary { exported_macros, .. } => {\n-                list_macros_stable(&exported_macros[..])\n-            }\n-            ProcMacroLibraryLibloading::NightlyProcMacroLibrary { exported_macros, .. } => {\n-                list_macros_nightly(&exported_macros[..])\n-            }\n-        }\n+        self.inner.abi.list_macros()\n     }\n }\n \n@@ -276,153 +188,3 @@ fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n     Ok(path.to_path_buf())\n }\n-\n-fn expand_nightly(\n-    macro_name: &str,\n-    macro_body: &tt::Subtree,\n-    attributes: Option<&tt::Subtree>,\n-    macros: &[NightlyProcMacro],\n-) -> Result<tt::Subtree, crate::proc_macro_nightly::bridge::PanicMessage> {\n-    let parsed_body = NightlyTokenStream::with_subtree(macro_body.clone());\n-\n-    let parsed_attributes = attributes\n-        .map_or(crate::rustc_server_nightly::TokenStream::new(), |attr| {\n-            NightlyTokenStream::with_subtree(attr.clone())\n-        });\n-\n-    for proc_macro in macros {\n-        match proc_macro {\n-            crate::proc_macro_nightly::bridge::client::ProcMacro::CustomDerive {\n-                trait_name,\n-                client,\n-                ..\n-            } if *trait_name == macro_name => {\n-                let res = client.run(\n-                    &crate::proc_macro_nightly::bridge::server::SameThread,\n-                    crate::rustc_server_nightly::Rustc::default(),\n-                    parsed_body,\n-                    false,\n-                );\n-                return res.map(|it| it.into_subtree());\n-            }\n-            crate::proc_macro_nightly::bridge::client::ProcMacro::Bang { name, client }\n-                if *name == macro_name =>\n-            {\n-                let res = client.run(\n-                    &crate::proc_macro_nightly::bridge::server::SameThread,\n-                    crate::rustc_server_nightly::Rustc::default(),\n-                    parsed_body,\n-                    false,\n-                );\n-                return res.map(|it| it.into_subtree());\n-            }\n-            crate::proc_macro_nightly::bridge::client::ProcMacro::Attr { name, client }\n-                if *name == macro_name =>\n-            {\n-                let res = client.run(\n-                    &crate::proc_macro_nightly::bridge::server::SameThread,\n-                    crate::rustc_server_nightly::Rustc::default(),\n-                    parsed_attributes,\n-                    parsed_body,\n-                    false,\n-                );\n-                return res.map(|it| it.into_subtree());\n-            }\n-            _ => continue,\n-        }\n-    }\n-\n-    Err(crate::proc_macro_nightly::bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n-}\n-\n-fn expand_stable(\n-    macro_name: &str,\n-    macro_body: &tt::Subtree,\n-    attributes: Option<&tt::Subtree>,\n-    macros: &[StableProcMacro],\n-) -> Result<tt::Subtree, crate::proc_macro::bridge::PanicMessage> {\n-    let parsed_body = StableTokenStream::with_subtree(macro_body.clone());\n-\n-    let parsed_attributes = attributes.map_or(crate::rustc_server::TokenStream::new(), |attr| {\n-        StableTokenStream::with_subtree(attr.clone())\n-    });\n-\n-    for proc_macro in macros {\n-        match proc_macro {\n-            crate::proc_macro::bridge::client::ProcMacro::CustomDerive {\n-                trait_name,\n-                client,\n-                ..\n-            } if *trait_name == macro_name => {\n-                let res = client.run(\n-                    &crate::proc_macro::bridge::server::SameThread,\n-                    crate::rustc_server::Rustc::default(),\n-                    parsed_body,\n-                    false,\n-                );\n-                return res.map(|it| it.into_subtree());\n-            }\n-            crate::proc_macro::bridge::client::ProcMacro::Bang { name, client }\n-                if *name == macro_name =>\n-            {\n-                let res = client.run(\n-                    &crate::proc_macro::bridge::server::SameThread,\n-                    crate::rustc_server::Rustc::default(),\n-                    parsed_body,\n-                    false,\n-                );\n-                return res.map(|it| it.into_subtree());\n-            }\n-            crate::proc_macro::bridge::client::ProcMacro::Attr { name, client }\n-                if *name == macro_name =>\n-            {\n-                let res = client.run(\n-                    &crate::proc_macro::bridge::server::SameThread,\n-                    crate::rustc_server::Rustc::default(),\n-                    parsed_attributes,\n-                    parsed_body,\n-                    false,\n-                );\n-                return res.map(|it| it.into_subtree());\n-            }\n-            _ => continue,\n-        }\n-    }\n-\n-    Err(crate::proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n-}\n-\n-pub fn list_macros_stable(macros: &[StableProcMacro]) -> Vec<(String, ProcMacroKind)> {\n-    macros\n-        .iter()\n-        .map(|proc_macro| match proc_macro {\n-            crate::proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n-                (trait_name.to_string(), ProcMacroKind::CustomDerive)\n-            }\n-            crate::proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n-                (name.to_string(), ProcMacroKind::FuncLike)\n-            }\n-            crate::proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n-                (name.to_string(), ProcMacroKind::Attr)\n-            }\n-        })\n-        .collect()\n-}\n-\n-pub fn list_macros_nightly(macros: &[NightlyProcMacro]) -> Vec<(String, ProcMacroKind)> {\n-    macros\n-        .iter()\n-        .map(|proc_macro| match proc_macro {\n-            crate::proc_macro_nightly::bridge::client::ProcMacro::CustomDerive {\n-                trait_name,\n-                ..\n-            } => (trait_name.to_string(), ProcMacroKind::CustomDerive),\n-            crate::proc_macro_nightly::bridge::client::ProcMacro::Bang { name, .. } => {\n-                (name.to_string(), ProcMacroKind::FuncLike)\n-            }\n-            crate::proc_macro_nightly::bridge::client::ProcMacro::Attr { name, .. } => {\n-                (name.to_string(), ProcMacroKind::Attr)\n-            }\n-        })\n-        .collect()\n-}"}, {"sha": "eb9080e998e05fea84e419d0b516b1e948c54d8b", "filename": "crates/proc_macro_srv/src/lib.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -11,23 +11,10 @@\n //!   rustc rather than `unstable`. (Although in general ABI compatibility is still an issue)\u2026\n #![allow(unreachable_pub)]\n \n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod proc_macro;\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod proc_macro_nightly;\n-\n-#[doc(hidden)]\n-mod rustc_server;\n-\n-#[doc(hidden)]\n-mod rustc_server_nightly;\n-\n mod dylib;\n \n-use proc_macro::bridge::client::TokenStream;\n+mod abis;\n+\n use proc_macro_api::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n use std::{\n     collections::{hash_map::Entry, HashMap},\n@@ -62,10 +49,7 @@ impl ProcMacroSrv {\n \n         match result {\n             Ok(expansion) => Ok(ExpansionResult { expansion }),\n-            Err(msg) => {\n-                let msg = msg.as_str().unwrap_or(\"<unknown error>\");\n-                Err(format!(\"proc-macro panicked: {}\", msg))\n-            }\n+            Err(msg) => Err(format!(\"proc-macro panicked: {}\", msg)),\n         }\n     }\n "}, {"sha": "150e26fe7590110d8a868f39608157603e3e277b", "filename": "crates/proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e240eb67a86bb4deff2762e3c46f47278ccd975c/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=e240eb67a86bb4deff2762e3c46f47278ccd975c", "patch": "@@ -12,8 +12,14 @@ pub mod fixtures {\n     }\n }\n \n-fn parse_string(code: &str) -> Option<crate::rustc_server::TokenStream> {\n-    Some(crate::rustc_server::TokenStream::from_str(code).unwrap())\n+fn parse_string(code: &str) -> Option<crate::abis::abi_1_47::TokenStream> {\n+    // This is a bit strange. We need to parse a string into a token stream into\n+    // order to create a tt::SubTree from it in fixtures. `into_subtree` is\n+    // implemented by all the ABIs we have so we arbitrarily choose one ABI to\n+    // write a `parse_string` function for and use that. The tests don't really\n+    // care which ABI we're using as the `into_subtree` function isn't part of\n+    // the ABI and shouldn't change between ABI versions.\n+    crate::abis::abi_1_47::TokenStream::from_str(code).ok()\n }\n \n pub fn assert_expand(macro_name: &str, ra_fixture: &str, expect: Expect) {"}]}