{"sha": "4fe735b3209388788176606e10b0bfe953008862", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZTczNWIzMjA5Mzg4Nzg4MTc2NjA2ZTEwYjBiZmU5NTMwMDg4NjI=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-10-21T12:24:35Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-10-30T11:27:34Z"}, "message": "TypeVisitor: use `ControlFlow` in rustc_{infer,lint,trait_selection}", "tree": {"sha": "d28c2194af9485abed54ca506e375915f3812b0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d28c2194af9485abed54ca506e375915f3812b0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fe735b3209388788176606e10b0bfe953008862", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe735b3209388788176606e10b0bfe953008862", "html_url": "https://github.com/rust-lang/rust/commit/4fe735b3209388788176606e10b0bfe953008862", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fe735b3209388788176606e10b0bfe953008862/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c85b6fae0b2dbb1af91fd8c5fdd2c0140a43915", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c85b6fae0b2dbb1af91fd8c5fdd2c0140a43915", "html_url": "https://github.com/rust-lang/rust/commit/2c85b6fae0b2dbb1af91fd8c5fdd2c0140a43915"}], "stats": {"total": 188, "additions": 106, "deletions": 82}, "files": [{"sha": "535b722cb37e5db35a5170ca1868229621d68a18", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -71,6 +71,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::{BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n+use std::ops::ControlFlow;\n use std::{cmp, fmt};\n \n mod note;\n@@ -1497,7 +1498,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypesVisitor<'tcx> {\n-            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n                 if let Some((kind, def_id)) = TyCategory::from_ty(t) {\n                     let span = self.tcx.def_span(def_id);\n                     // Avoid cluttering the output when the \"found\" and error span overlap:"}, {"sha": "3ac72295d917c5d4b6bda894ec21b3c3033cbe4c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -15,6 +15,8 @@ use rustc_middle::ty::{self, AssocItemContainer, RegionKind, Ty, TypeFoldable, T\n use rustc_span::symbol::Ident;\n use rustc_span::{MultiSpan, Span};\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static `impl Trait`,\n     /// `dyn Trait` or if a method call on a trait object introduces a static requirement.\n@@ -472,13 +474,13 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n struct TraitObjectVisitor(Vec<DefId>);\n \n impl TypeVisitor<'_> for TraitObjectVisitor {\n-    fn visit_ty(&mut self, t: Ty<'_>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<(), ()> {\n         match t.kind() {\n             ty::Dynamic(preds, RegionKind::ReStatic) => {\n                 if let Some(def_id) = preds.principal_def_id() {\n                     self.0.push(def_id);\n                 }\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => t.super_visit_with(self),\n         }"}, {"sha": "2f5b44e7c17323e5c049fce9bf18d75f1aada694", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -30,6 +30,7 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use std::fmt::Debug;\n+use std::ops::ControlFlow;\n \n #[derive(PartialEq)]\n pub enum NormalizationStrategy {\n@@ -740,15 +741,15 @@ struct ScopeInstantiator<'me, 'tcx> {\n }\n \n impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ControlFlow<(), ()> {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n         self.target_index.shift_out(1);\n \n-        false\n+        ControlFlow::CONTINUE\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<(), ()> {\n         let ScopeInstantiator { bound_region_scope, next_region, .. } = self;\n \n         match r {\n@@ -759,7 +760,7 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n             _ => {}\n         }\n \n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "e4145045b92e1504f846d4c460f4d4cec9f7157e", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -3,6 +3,8 @@ use super::{FixupError, FixupResult, InferCtxt, Span};\n use rustc_middle::ty::fold::{TypeFolder, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n \n+use std::ops::ControlFlow;\n+\n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC VAR RESOLVER\n \n@@ -121,7 +123,7 @@ impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n             if let ty::Infer(infer_ty) = *t.kind() {\n@@ -143,15 +145,15 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n                     None\n                 };\n                 self.first_unresolved = Some((t, ty_var_span));\n-                true // Halt visiting.\n+                ControlFlow::BREAK\n             } else {\n                 // Otherwise, visit its contents.\n                 t.super_visit_with(self)\n             }\n         } else {\n             // All type variables in inference types must already be resolved,\n             // - no need to visit the contents, continue visiting.\n-            false\n+            ControlFlow::CONTINUE\n         }\n     }\n }"}, {"sha": "3690a88c0d9730eb0660273896ce83a988facb68", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -22,6 +22,7 @@\n #![feature(never_type)]\n #![feature(or_patterns)]\n #![feature(in_band_lifetimes)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "046bc11801a63ef69cc28aa55295ed30a8d0431f", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::ty;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n+use std::ops::ControlFlow;\n \n // Structural impls for the structs in `traits`.\n \n@@ -68,7 +69,7 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<(), ()> {\n         self.predicate.visit_with(visitor)\n     }\n }"}, {"sha": "7297a6de4204645766e85dec9456159d1122b38b", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -37,6 +37,7 @@\n #![feature(or_patterns)]\n #![feature(half_open_range_patterns)]\n #![feature(exclusive_range_pattern)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "2bfa17b121961d9df7716bd954d8c2090b6ef74f", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -18,6 +18,7 @@ use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n use std::cmp;\n+use std::ops::ControlFlow;\n use tracing::debug;\n \n declare_lint! {\n@@ -1135,11 +1136,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         };\n \n         impl<'a, 'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'a, 'tcx> {\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n                 match ty.kind() {\n                     ty::Opaque(..) => {\n                         self.ty = Some(ty);\n-                        true\n+                        ControlFlow::BREAK\n                     }\n                     // Consider opaque types within projections FFI-safe if they do not normalize\n                     // to more opaque types.\n@@ -1148,7 +1149,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         // If `ty` is a opaque type directly then `super_visit_with` won't invoke\n                         // this function again.\n-                        if ty.has_opaque_types() { self.visit_ty(ty) } else { false }\n+                        if ty.has_opaque_types() {\n+                            self.visit_ty(ty)\n+                        } else {\n+                            ControlFlow::CONTINUE\n+                        }\n                     }\n                     _ => ty.super_visit_with(self),\n                 }"}, {"sha": "42509cd8975828a9f269e5329cd70f1c801791a5", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -19,6 +19,7 @@\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "f1efec07e08be36101033165e8f486f2f4c3f4f5", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -15,6 +15,8 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config::nightly_options;\n use rustc_span::Span;\n \n+use std::ops::ControlFlow;\n+\n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n /// Information about the opaque types whose values we\n@@ -691,26 +693,26 @@ impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<OP>\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ControlFlow<(), ()> {\n         t.as_ref().skip_binder().visit_with(self);\n-        false // keep visiting\n+        ControlFlow::CONTINUE\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<(), ()> {\n         match *r {\n             // ignore bound regions, keep visiting\n-            ty::ReLateBound(_, _) => false,\n+            ty::ReLateBound(_, _) => ControlFlow::CONTINUE,\n             _ => {\n                 (self.op)(r);\n-                false\n+                ControlFlow::CONTINUE\n             }\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n         // We're only interested in types involving regions\n         if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n-            return false; // keep visiting\n+            return ControlFlow::CONTINUE;\n         }\n \n         match ty.kind() {\n@@ -745,7 +747,7 @@ where\n             }\n         }\n \n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "10ddcf35b30a72764c04cc6b71cea9cfaee3f222", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -24,6 +24,7 @@ use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n use std::cmp;\n+use std::ops::ControlFlow;\n \n /// Check if a given constant can be evaluated.\n pub fn is_const_evaluatable<'cx, 'tcx>(\n@@ -86,9 +87,11 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n \n-                        false\n+                        ControlFlow::CONTINUE\n+                    }\n+                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n+                        ControlFlow::CONTINUE\n                     }\n-                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => false,\n                 });\n \n                 match failure_kind {\n@@ -564,29 +567,33 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorReported`.\n }\n \n-// FIXME: Use `std::ops::ControlFlow` instead of `bool` here.\n-pub fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F) -> bool\n+pub fn walk_abstract_const<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n+    ct: AbstractConst<'tcx>,\n+    mut f: F,\n+) -> ControlFlow<(), ()>\n where\n-    F: FnMut(Node<'tcx>) -> bool,\n+    F: FnMut(Node<'tcx>) -> ControlFlow<(), ()>,\n {\n     fn recurse<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(Node<'tcx>) -> bool,\n-    ) -> bool {\n+        f: &mut dyn FnMut(Node<'tcx>) -> ControlFlow<(), ()>,\n+    ) -> ControlFlow<(), ()> {\n         let root = ct.root();\n-        f(root)\n-            || match root {\n-                Node::Leaf(_) => false,\n-                Node::Binop(_, l, r) => {\n-                    recurse(tcx, ct.subtree(l), f) || recurse(tcx, ct.subtree(r), f)\n-                }\n-                Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n-                Node::FunctionCall(func, args) => {\n-                    recurse(tcx, ct.subtree(func), f)\n-                        || args.iter().any(|&arg| recurse(tcx, ct.subtree(arg), f))\n-                }\n+        f(root)?;\n+        match root {\n+            Node::Leaf(_) => ControlFlow::CONTINUE,\n+            Node::Binop(_, l, r) => {\n+                recurse(tcx, ct.subtree(l), f)?;\n+                recurse(tcx, ct.subtree(r), f)\n+            }\n+            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n+            Node::FunctionCall(func, args) => {\n+                recurse(tcx, ct.subtree(func), f)?;\n+                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n             }\n+        }\n     }\n \n     recurse(tcx, ct, &mut f)"}, {"sha": "5bbad7aab0cc1e9a485a9761975a5c206e5ff455", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -27,6 +27,7 @@ use smallvec::SmallVec;\n \n use std::array;\n use std::iter;\n+use std::ops::ControlFlow;\n \n pub use crate::traits::{MethodViolationCode, ObjectSafetyViolation};\n \n@@ -770,9 +771,15 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n-        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n             match t.kind() {\n-                ty::Param(_) => t == self.tcx.types.self_param,\n+                ty::Param(_) => {\n+                    if t == self.tcx.types.self_param {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        ControlFlow::CONTINUE\n+                    }\n+                }\n                 ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n@@ -796,7 +803,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                         self.supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n \n                     if is_supertrait_of_current_trait {\n-                        false // do not walk contained types, do not report error, do collect $200\n+                        ControlFlow::CONTINUE // do not walk contained types, do not report error, do collect $200\n                     } else {\n                         t.super_visit_with(self) // DO walk contained types, POSSIBLY reporting an error\n                     }\n@@ -805,11 +812,9 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             }\n         }\n \n-        fn visit_const(&mut self, ct: &ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, ct: &ty::Const<'tcx>) -> ControlFlow<(), ()> {\n             // First check if the type of this constant references `Self`.\n-            if self.visit_ty(ct.ty) {\n-                return true;\n-            }\n+            self.visit_ty(ct.ty)?;\n \n             // Constants can only influence object safety if they reference `Self`.\n             // This is only possible for unevaluated constants, so we walk these here.\n@@ -830,14 +835,16 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                         let leaf = leaf.subst(self.tcx, ct.substs);\n                         self.visit_const(leaf)\n                     }\n-                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n+                        ControlFlow::CONTINUE\n+                    }\n                 })\n             } else {\n-                false\n+                ControlFlow::CONTINUE\n             }\n         }\n \n-        fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n+        fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ControlFlow<(), ()> {\n             if let ty::PredicateAtom::ConstEvaluatable(def, substs) = pred.skip_binders() {\n                 // FIXME(const_evaluatable_checked): We should probably deduplicate the logic for\n                 // `AbstractConst`s here, it might make sense to change `ConstEvaluatable` to\n@@ -849,10 +856,12 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                             let leaf = leaf.subst(self.tcx, ct.substs);\n                             self.visit_const(leaf)\n                         }\n-                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n+                            ControlFlow::CONTINUE\n+                        }\n                     })\n                 } else {\n-                    false\n+                    ControlFlow::CONTINUE\n                 }\n             } else {\n                 pred.super_visit_with(self)\n@@ -861,6 +870,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n     }\n \n     value.visit_with(&mut IllegalSelfTypeVisitor { tcx, trait_def_id, supertraits: None })\n+        == ControlFlow::BREAK\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "c15cb9a7d12ff5b5819e004dcef1e80e4600607a", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe735b3209388788176606e10b0bfe953008862/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=4fe735b3209388788176606e10b0bfe953008862", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n+use std::ops::ControlFlow;\n \n #[derive(Debug)]\n pub enum NonStructuralMatchTy<'tcx> {\n@@ -134,38 +135,38 @@ impl Search<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n         debug!(\"Search visiting ty: {:?}\", ty);\n \n         let (adt_def, substs) = match *ty.kind() {\n             ty::Adt(adt_def, substs) => (adt_def, substs),\n             ty::Param(_) => {\n                 self.found = Some(NonStructuralMatchTy::Param);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Dynamic(..) => {\n                 self.found = Some(NonStructuralMatchTy::Dynamic);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Foreign(_) => {\n                 self.found = Some(NonStructuralMatchTy::Foreign);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Opaque(..) => {\n                 self.found = Some(NonStructuralMatchTy::Opaque);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Projection(..) => {\n                 self.found = Some(NonStructuralMatchTy::Projection);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Generator(..) | ty::GeneratorWitness(..) => {\n                 self.found = Some(NonStructuralMatchTy::Generator);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Closure(..) => {\n                 self.found = Some(NonStructuralMatchTy::Closure);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::RawPtr(..) => {\n                 // structural-match ignores substructure of\n@@ -182,39 +183,31 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 // Even though `NonStructural` does not implement `PartialEq`,\n                 // structural equality on `T` does not recur into the raw\n                 // pointer. Therefore, one can still use `C` in a pattern.\n-\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::FnDef(..) | ty::FnPtr(..) => {\n                 // Types of formals and return in `fn(_) -> _` are also irrelevant;\n                 // so we do not recur into them via `super_visit_with`\n-                //\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Array(_, n)\n                 if { n.try_eval_usize(self.tcx(), ty::ParamEnv::reveal_all()) == Some(0) } =>\n             {\n                 // rust-lang/rust#62336: ignore type of contents\n                 // for empty array.\n-                //\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => {\n                 // These primitive types are always structural match.\n                 //\n                 // `Never` is kind of special here, but as it is not inhabitable, this should be fine.\n-                //\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n \n             ty::Array(..) | ty::Slice(_) | ty::Ref(..) | ty::Tuple(..) => {\n                 // First check all contained types and then tell the caller to continue searching.\n                 ty.super_visit_with(self);\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n                 bug!(\"unexpected type during structural-match checking: {:?}\", ty);\n@@ -223,22 +216,19 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 self.tcx().sess.delay_span_bug(self.span, \"ty::Error in structural-match check\");\n                 // We still want to check other types after encountering an error,\n                 // as this may still emit relevant errors.\n-                //\n-                // So we continue searching here.\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n         };\n \n         if !self.seen.insert(adt_def.did) {\n             debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-            // Let caller continue its search.\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         if !self.type_marked_structural(ty) {\n             debug!(\"Search found ty: {:?}\", ty);\n             self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n-            return true; // Halt visiting!\n+            return ControlFlow::BREAK;\n         }\n \n         // structural-match does not care about the\n@@ -258,16 +248,16 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n             let ty = self.tcx().normalize_erasing_regions(ty::ParamEnv::empty(), field_ty);\n             debug!(\"structural-match ADT: field_ty={:?}, ty={:?}\", field_ty, ty);\n \n-            if ty.visit_with(self) {\n+            if ty.visit_with(self) == ControlFlow::BREAK {\n                 // found an ADT without structural-match; halt visiting!\n                 assert!(self.found.is_some());\n-                return true;\n+                return ControlFlow::BREAK;\n             }\n         }\n \n         // Even though we do not want to recur on substs, we do\n         // want our caller to continue its own search.\n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n "}]}