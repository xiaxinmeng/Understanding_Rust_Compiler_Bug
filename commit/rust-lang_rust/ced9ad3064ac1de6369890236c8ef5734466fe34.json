{"sha": "ced9ad3064ac1de6369890236c8ef5734466fe34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZDlhZDMwNjRhYzFkZTYzNjk4OTAyMzZjOGVmNTczNDQ2NmZlMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-22T04:13:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-22T04:13:49Z"}, "message": "Auto merge of #29968 - Manishearth:bang-macro-diag, r=eddyb\n\nr? @eddyb\n\nfixes #5780", "tree": {"sha": "1aab2a39f4c8c87d141c7108f92ee88a2b79bdfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aab2a39f4c8c87d141c7108f92ee88a2b79bdfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ced9ad3064ac1de6369890236c8ef5734466fe34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ced9ad3064ac1de6369890236c8ef5734466fe34", "html_url": "https://github.com/rust-lang/rust/commit/ced9ad3064ac1de6369890236c8ef5734466fe34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ced9ad3064ac1de6369890236c8ef5734466fe34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb19d024a9902ff551f4839a1d9bd13a7998b75b", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb19d024a9902ff551f4839a1d9bd13a7998b75b", "html_url": "https://github.com/rust-lang/rust/commit/eb19d024a9902ff551f4839a1d9bd13a7998b75b"}, {"sha": "99925fb562086ff789df95220104f9d8d5fc8b3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/99925fb562086ff789df95220104f9d8d5fc8b3c", "html_url": "https://github.com/rust-lang/rust/commit/99925fb562086ff789df95220104f9d8d5fc8b3c"}], "stats": {"total": 106, "additions": 76, "deletions": 30}, "files": [{"sha": "cab61b96b075b298613bf706f9333127e856692e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ced9ad3064ac1de6369890236c8ef5734466fe34", "patch": "@@ -15,7 +15,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeMap, FnvHashMap};\n \n-use syntax::ast::{NodeId, NodeIdAssigner};\n+use syntax::ast::{NodeId, NodeIdAssigner, Name};\n use syntax::codemap::Span;\n use syntax::diagnostic::{self, Emitter};\n use syntax::diagnostics;\n@@ -30,6 +30,7 @@ use rustc_back::target::Target;\n \n use std::path::{Path, PathBuf};\n use std::cell::{Cell, RefCell};\n+use std::collections::HashSet;\n use std::env;\n \n pub mod config;\n@@ -74,6 +75,10 @@ pub struct Session {\n     /// didn't already find one, and this tracks what was injected.\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n \n+    /// Names of all bang-style macros and syntax extensions\n+    /// available in this crate\n+    pub available_macros: RefCell<HashSet<Name>>,\n+\n     next_node_id: Cell<ast::NodeId>,\n }\n \n@@ -468,6 +473,7 @@ pub fn build_session_(sopts: config::Options,\n         can_print_warnings: can_print_warnings,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n+        available_macros: RefCell::new(HashSet::new()),\n     };\n \n     sess"}, {"sha": "a1bec7e78a3adb5622ad63d55d9711337172ef9a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ced9ad3064ac1de6369890236c8ef5734466fe34", "patch": "@@ -553,15 +553,16 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             recursion_limit: sess.recursion_limit.get(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n         };\n-        let ret = syntax::ext::expand::expand_crate(&sess.parse_sess,\n-                                                    cfg,\n-                                                    macros,\n-                                                    syntax_exts,\n-                                                    &mut feature_gated_cfgs,\n-                                                    krate);\n+        let (ret, macro_names) = syntax::ext::expand::expand_crate(&sess.parse_sess,\n+                                                                    cfg,\n+                                                                    macros,\n+                                                                    syntax_exts,\n+                                                                    &mut feature_gated_cfgs,\n+                                                                    krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &_old_path);\n         }\n+        *sess.available_macros.borrow_mut() = macro_names;\n         ret\n     });\n "}, {"sha": "5b68142746ca30fd64bdbe40aa26c8497de12d8d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ced9ad3064ac1de6369890236c8ef5734466fe34", "patch": "@@ -124,6 +124,12 @@ macro_rules! execute_callback {\n     )\n }\n \n+enum SuggestionType {\n+    Macro(String),\n+    Function(String),\n+    NotFound,\n+}\n+\n pub enum ResolutionError<'a> {\n     /// error E0401: can't use type parameters from outer function\n     TypeParametersFromOuterFunction,\n@@ -3616,10 +3622,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         NoSuggestion\n     }\n \n-    fn find_best_match_for_name(&mut self, name: &str) -> Option<String> {\n+    fn find_best_match_for_name(&mut self, name: &str) -> SuggestionType {\n         let mut maybes: Vec<token::InternedString> = Vec::new();\n         let mut values: Vec<usize> = Vec::new();\n \n+        if let Some(macro_name) = self.session.available_macros\n+                                 .borrow().iter().find(|n| n.as_str() == name) {\n+            return SuggestionType::Macro(format!(\"{}!\", macro_name));\n+        }\n+\n         for rib in self.value_ribs.iter().rev() {\n             for (&k, _) in &rib.bindings {\n                 maybes.push(k.as_str());\n@@ -3643,10 +3654,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         if !values.is_empty() && values[smallest] <= max_distance && name != &maybes[smallest][..] {\n \n-            Some(maybes[smallest].to_string())\n+            SuggestionType::Function(maybes[smallest].to_string())\n \n         } else {\n-            None\n+            SuggestionType::NotFound\n         }\n     }\n \n@@ -3758,8 +3769,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     NoSuggestion => {\n                                         // limit search to 5 to reduce the number\n                                         // of stupid suggestions\n-                                        self.find_best_match_for_name(&path_name)\n-                                            .map_or(\"\".to_string(), |x| format!(\"`{}`\", x))\n+                                        match self.find_best_match_for_name(&path_name) {\n+                                            SuggestionType::Macro(s) => {\n+                                                format!(\"the macro `{}`\", s)\n+                                            }\n+                                            SuggestionType::Function(s) => format!(\"`{}`\", s),\n+                                            SuggestionType::NotFound => \"\".to_string(),\n+                                        }\n                                     }\n                                     Field => format!(\"`self.{}`\", path_name),\n                                     Method |"}, {"sha": "0dba15760cd3d286d78347fdc18b34ad8daa309e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ced9ad3064ac1de6369890236c8ef5734466fe34", "patch": "@@ -27,7 +27,7 @@ use util::small_vector::SmallVector;\n use ext::mtwt;\n use fold::Folder;\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n use std::default::Default;\n \n@@ -856,7 +856,10 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n ///\n /// This environment maps Names to SyntaxExtensions.\n pub struct SyntaxEnv {\n-    chain: Vec<MapChainFrame> ,\n+    chain: Vec<MapChainFrame>,\n+    /// All bang-style macro/extension names\n+    /// encountered so far; to be used for diagnostics in resolve\n+    pub names: HashSet<Name>,\n }\n \n // impl question: how to implement it? Initially, the\n@@ -876,7 +879,7 @@ struct MapChainFrame {\n \n impl SyntaxEnv {\n     fn new() -> SyntaxEnv {\n-        let mut map = SyntaxEnv { chain: Vec::new() };\n+        let mut map = SyntaxEnv { chain: Vec::new() , names: HashSet::new()};\n         map.push_frame();\n         map\n     }\n@@ -913,6 +916,9 @@ impl SyntaxEnv {\n     }\n \n     pub fn insert(&mut self, k: Name, v: SyntaxExtension) {\n+        if let NormalTT(..) = v {\n+            self.names.insert(k);\n+        }\n         self.find_escape_frame().map.insert(k, Rc::new(v));\n     }\n "}, {"sha": "9b1a7a50201b022aee19c636107c7dc3acf0b27a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ced9ad3064ac1de6369890236c8ef5734466fe34", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{Block, Crate, DeclLocal, ExprMac, PatMac};\n-use ast::{Local, Ident, Mac_};\n+use ast::{Local, Ident, Mac_, Name};\n use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtDecl, StmtMac};\n use ast::{StmtExpr, StmtSemi};\n use ast::TokenTree;\n@@ -32,6 +32,8 @@ use visit;\n use visit::Visitor;\n use std_inject;\n \n+use std::collections::HashSet;\n+\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     let expr_span = e.span;\n@@ -1261,7 +1263,7 @@ pub fn expand_crate<'feat>(parse_sess: &parse::ParseSess,\n                            imported_macros: Vec<ast::MacroDef>,\n                            user_exts: Vec<NamedSyntaxExtension>,\n                            feature_gated_cfgs: &mut Vec<GatedCfg>,\n-                           c: Crate) -> Crate {\n+                           c: Crate) -> (Crate, HashSet<Name>) {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg,\n                               feature_gated_cfgs);\n     if std_inject::no_core(&c) {\n@@ -1271,21 +1273,23 @@ pub fn expand_crate<'feat>(parse_sess: &parse::ParseSess,\n     } else {\n         cx.crate_root = Some(\"std\");\n     }\n+    let ret = {\n+        let mut expander = MacroExpander::new(&mut cx);\n \n-    let mut expander = MacroExpander::new(&mut cx);\n-\n-    for def in imported_macros {\n-        expander.cx.insert_macro(def);\n-    }\n+        for def in imported_macros {\n+            expander.cx.insert_macro(def);\n+        }\n \n-    for (name, extension) in user_exts {\n-        expander.cx.syntax_env.insert(name, extension);\n-    }\n+        for (name, extension) in user_exts {\n+            expander.cx.syntax_env.insert(name, extension);\n+        }\n \n-    let mut ret = expander.fold_crate(c);\n-    ret.exported_macros = expander.cx.exported_macros.clone();\n-    parse_sess.span_diagnostic.handler().abort_if_errors();\n-    return ret;\n+        let mut ret = expander.fold_crate(c);\n+        ret.exported_macros = expander.cx.exported_macros.clone();\n+        parse_sess.span_diagnostic.handler().abort_if_errors();\n+        ret\n+    };\n+    return (ret, cx.syntax_env.names);\n }\n \n // HYGIENIC CONTEXT EXTENSION:\n@@ -1480,7 +1484,7 @@ mod tests {\n         let ps = parse::ParseSess::new();\n         let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n         // the cfg argument actually does matter, here...\n-        expand_crate(&ps,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast)\n+        expand_crate(&ps,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast).0\n     }\n \n     // find the pat_ident paths in a crate"}, {"sha": "f05f1cd544a10802b5b841567d8787fe58178245", "filename": "src/test/compile-fail/resolve-hint-macro.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Ftest%2Fcompile-fail%2Fresolve-hint-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced9ad3064ac1de6369890236c8ef5734466fe34/src%2Ftest%2Fcompile-fail%2Fresolve-hint-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-hint-macro.rs?ref=ced9ad3064ac1de6369890236c8ef5734466fe34", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert(true); //~ERROR unresolved name `assert`. Did you mean the macro `assert!`?\n+}"}]}