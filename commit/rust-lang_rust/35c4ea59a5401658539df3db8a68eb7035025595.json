{"sha": "35c4ea59a5401658539df3db8a68eb7035025595", "node_id": "C_kwDOAAsO6NoAKDM1YzRlYTU5YTU0MDE2NTg1MzlkZjNkYjhhNjhlYjcwMzUwMjU1OTU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-13T09:21:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-13T09:21:01Z"}, "message": "Rollup merge of #110218 - nnethercote:rm-ToRegionVid, r=compiler-errors\n\nRemove `ToRegionVid`\n\nr? ```@compiler-errors```", "tree": {"sha": "ef69133b2c664e9d1f7af7caa9ae6fa57142288d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef69133b2c664e9d1f7af7caa9ae6fa57142288d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35c4ea59a5401658539df3db8a68eb7035025595", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkN8l9CRBK7hj4Ov3rIwAAZJUIAGzHc0A97CFfDt6XS6TpheT3\nOkwOyC0cG4DwpMxsWzIknTG5bZwasybZZ6vr69zkeWfjoSPH2fpOa0RSsnCQg7IO\nXE0MvXANUn3t5Tg62WfiZivckWd3LwdPe62xAmTDWNyDGcrxNa7F6zSdgNWcg17P\nDv4vwkPaFbXO2ULF/nTwspU/t55jlBI1Y1kW1653TIr/A576oQI/OMwvlMb2Y423\nE2+VQVAdYnTuxvlXqWQrWayEtlRA/N0v8lW00D24mcI99WhAW5HzIgkWVI473Jv+\nVcMzkDsBhi+x9PBOkNbAjL5QMidlZHRN6Ihvy+idkIfM7fbtKnQBf1Kdo6ztTjI=\n=DeFJ\n-----END PGP SIGNATURE-----\n", "payload": "tree ef69133b2c664e9d1f7af7caa9ae6fa57142288d\nparent 958413cc0807c2a850d5ba1abe8171ab70219b3b\nparent 72605cd267fa0a812e74ad8412738b4db37aca9d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681377661 +0200\ncommitter GitHub <noreply@github.com> 1681377661 +0200\n\nRollup merge of #110218 - nnethercote:rm-ToRegionVid, r=compiler-errors\n\nRemove `ToRegionVid`\n\nr? ```@compiler-errors```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35c4ea59a5401658539df3db8a68eb7035025595", "html_url": "https://github.com/rust-lang/rust/commit/35c4ea59a5401658539df3db8a68eb7035025595", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35c4ea59a5401658539df3db8a68eb7035025595/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "958413cc0807c2a850d5ba1abe8171ab70219b3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/958413cc0807c2a850d5ba1abe8171ab70219b3b", "html_url": "https://github.com/rust-lang/rust/commit/958413cc0807c2a850d5ba1abe8171ab70219b3b"}, {"sha": "72605cd267fa0a812e74ad8412738b4db37aca9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/72605cd267fa0a812e74ad8412738b4db37aca9d", "html_url": "https://github.com/rust-lang/rust/commit/72605cd267fa0a812e74ad8412738b4db37aca9d"}], "stats": {"total": 296, "additions": 55, "deletions": 241}, "files": [{"sha": "4824f6346d4c87b1b7474cda90c07e1fda572c4d", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -1,6 +1,5 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;\n use crate::BorrowIndex;\n@@ -204,7 +203,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 return;\n             }\n \n-            let region = region.to_region_vid();\n+            let region = region.as_var();\n \n             let borrow = BorrowData {\n                 kind,\n@@ -279,7 +278,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n             let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n-            assert_eq!(borrow_data.region, region.to_region_vid());\n+            assert_eq!(borrow_data.region, region.as_var());\n             assert_eq!(borrow_data.borrowed_place, place);\n         }\n "}, {"sha": "2aa09a3f26c1758d6dc76f2d06f239a2efeada8c", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -12,8 +12,8 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n \n use crate::{\n-    borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, nll::ToRegionVid,\n-    places_conflict, region_infer::values::LivenessValues,\n+    borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, places_conflict,\n+    region_infer::values::LivenessValues,\n };\n \n pub(super) fn generate_constraints<'tcx>(\n@@ -170,7 +170,7 @@ impl<'cx, 'tcx> ConstraintGeneration<'cx, 'tcx> {\n         debug!(\"add_regular_live_constraint(live_ty={:?}, location={:?})\", live_ty, location);\n \n         self.infcx.tcx.for_each_free_region(&live_ty, |live_region| {\n-            let vid = live_region.to_region_vid();\n+            let vid = live_region.as_var();\n             self.liveness_constraints.add_element(vid, location);\n         });\n     }"}, {"sha": "94939c7e4cd72ea0824baf09b64670e9fe2cae99", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -11,9 +11,7 @@ use rustc_mir_dataflow::{self, fmt::DebugWithContext, CallReturnPlaces, GenKill}\n use rustc_mir_dataflow::{Analysis, Direction, Results};\n use std::fmt;\n \n-use crate::{\n-    places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n-};\n+use crate::{places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext};\n \n /// A tuple with named fields that can hold either the results or the transient state of the\n /// dataflow analyses used by the borrow checker.\n@@ -242,7 +240,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     ) -> Self {\n         let mut prec = OutOfScopePrecomputer::new(body, nonlexical_regioncx);\n         for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n-            let borrow_region = borrow_data.region.to_region_vid();\n+            let borrow_region = borrow_data.region;\n             let location = borrow_data.reserve_location;\n \n             prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);"}, {"sha": "2495613fea1d2c9e6473f7a299c9199c6630f0cf", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -6,7 +6,6 @@ use std::rc::Rc;\n \n use crate::{\n     def_use::{self, DefUse},\n-    nll::ToRegionVid,\n     region_infer::{Cause, RegionInferenceContext},\n };\n use rustc_data_structures::fx::FxIndexSet;\n@@ -117,7 +116,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'tcx> {\n \n         let mut found_it = false;\n         self.tcx.for_each_free_region(&local_ty, |r| {\n-            if r.to_region_vid() == self.region_vid {\n+            if r.as_var() == self.region_vid {\n                 found_it = true;\n             }\n         });"}, {"sha": "f69c4829ae2999ba9df9f39c02f8da69b86b10e4", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n-use crate::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n+use crate::{universal_regions::DefiningTy, MirBorrowckCtxt};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n@@ -497,7 +497,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n                 (ty::Ref(region, referent_ty, _), hir::TyKind::Ref(_lifetime, referent_hir_ty)) => {\n-                    if region.to_region_vid() == needle_fr {\n+                    if region.as_var() == needle_fr {\n                         // Just grab the first character, the `&`.\n                         let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n@@ -598,7 +598,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         for (kind, hir_arg) in iter::zip(substs, args.args) {\n             match (kind.unpack(), hir_arg) {\n                 (GenericArgKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n-                    if r.to_region_vid() == needle_fr {\n+                    if r.as_var() == needle_fr {\n                         return Some(lt);\n                     }\n                 }\n@@ -666,7 +666,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n-        if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n+        if !tcx.any_free_region_meets(&return_ty, |r| r.as_var() == fr) {\n             return None;\n         }\n \n@@ -803,7 +803,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n \n-        if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n+        if !tcx.any_free_region_meets(&yield_ty, |r| r.as_var() == fr) {\n             return None;\n         }\n "}, {"sha": "376415e3d3208466ca69af129d650beb154ae6e2", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -1,8 +1,8 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n+use crate::region_infer::RegionInferenceContext;\n use crate::Upvar;\n-use crate::{nll::ToRegionVid, region_infer::RegionInferenceContext};\n use rustc_index::vec::{Idx, IndexSlice};\n use rustc_middle::mir::{Body, Local};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n@@ -46,7 +46,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={upvar_ty:?}\");\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n-                    let r = r.to_region_vid();\n+                    let r = r.as_var();\n                     debug!(\"get_upvar_index_for_region: r={r:?} fr={fr:?}\");\n                     r == fr\n                 })\n@@ -96,7 +96,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n                     debug!(\"get_argument_index_for_region: arg_ty = {arg_ty:?}\");\n-                    tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n+                    tcx.any_free_region_meets(arg_ty, |r| r.as_var() == fr)\n                 },\n             )?;\n "}, {"sha": "a4b285a34fa4654eac10e3934274415fe20f2ba3", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -94,7 +94,7 @@ pub mod consumers;\n \n use borrow_set::{BorrowData, BorrowSet};\n use dataflow::{BorrowIndex, BorrowckFlowState as Flows, BorrowckResults, Borrows};\n-use nll::{PoloniusOutput, ToRegionVid};\n+use nll::PoloniusOutput;\n use place_ext::PlaceExt;\n use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n@@ -507,9 +507,7 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         F: Fn() -> RegionCtxt,\n     {\n         let next_region = self.infcx.next_region_var(origin);\n-        let vid = next_region\n-            .as_var()\n-            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+        let vid = next_region.as_var();\n \n         if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n@@ -531,9 +529,7 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         F: Fn() -> RegionCtxt,\n     {\n         let next_region = self.infcx.next_nll_region_var(origin.clone());\n-        let vid = next_region\n-            .as_var()\n-            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+        let vid = next_region.as_var();\n \n         if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);"}, {"sha": "59a3ab3189d75628e48a0849f882ab6b8fa6a686", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueHiddenType, TyCtxt};\n use rustc_span::symbol::sym;\n use std::env;\n use std::io;\n@@ -444,27 +444,6 @@ fn for_each_region_constraint<'tcx>(\n     Ok(())\n }\n \n-/// Right now, we piggy back on the `ReVar` to store our NLL inference\n-/// regions. These are indexed with `RegionVid`. This method will\n-/// assert that the region is a `ReVar` and extract its internal index.\n-/// This is reasonable because in our MIR we replace all universal regions\n-/// with inference variables.\n-pub trait ToRegionVid {\n-    fn to_region_vid(self) -> RegionVid;\n-}\n-\n-impl<'tcx> ToRegionVid for Region<'tcx> {\n-    fn to_region_vid(self) -> RegionVid {\n-        if let ty::ReVar(vid) = *self { vid } else { bug!(\"region is not an ReVar: {:?}\", self) }\n-    }\n-}\n-\n-impl ToRegionVid for RegionVid {\n-    fn to_region_vid(self) -> RegionVid {\n-        self\n-    }\n-}\n-\n pub(crate) trait ConstraintDescription {\n     fn description(&self) -> &'static str;\n }"}, {"sha": "729f3dbff3b46b1050128075f5c091cf86f8ba65", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     },\n     diagnostics::{RegionErrorKind, RegionErrors, UniverseInfo},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n-    nll::{PoloniusOutput, ToRegionVid},\n+    nll::PoloniusOutput,\n     region_infer::reverse_sccs::ReverseSccGraph,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndices, RegionElement, RegionValueElements, RegionValues,\n@@ -593,39 +593,36 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Returns `true` if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    pub(crate) fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+    pub(crate) fn region_contains(&self, r: RegionVid, p: impl ToElementIndex) -> bool {\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.contains(scc, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.region_value_str(scc)\n     }\n \n     pub(crate) fn placeholders_contained_in<'a>(\n         &'a self,\n         r: RegionVid,\n     ) -> impl Iterator<Item = ty::PlaceholderRegion> + 'a {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.placeholders_contained_in(scc)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_universes[scc]\n     }\n \n     /// Once region solving has completed, this function will return\n     /// the member constraints that were applied to the value of a given\n     /// region `r`. See `AppliedMemberConstraint`.\n-    pub(crate) fn applied_member_constraints(\n-        &self,\n-        r: impl ToRegionVid,\n-    ) -> &[AppliedMemberConstraint] {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+    pub(crate) fn applied_member_constraints(&self, r: RegionVid) -> &[AppliedMemberConstraint] {\n+        let scc = self.constraint_sccs.scc(r);\n         binary_search_util::binary_search_slice(\n             &self.member_constraints_applied,\n             |applied| applied.member_region_scc,\n@@ -1133,7 +1130,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let r_vid = self.to_region_vid(r);\n             let r_scc = self.constraint_sccs.scc(r_vid);\n \n-            // The challenge if this. We have some region variable `r`\n+            // The challenge is this. We have some region variable `r`\n             // whose value is a set of CFG points and universal\n             // regions. We want to find if that set is *equivalent* to\n             // any of the named regions found in the closure.\n@@ -2234,7 +2231,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         r: RegionVid,\n         body: &Body<'_>,\n     ) -> Option<Location> {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         let locations = self.scc_values.locations_outlived_by(scc);\n         for location in locations {\n             let bb = &body[location.block];"}, {"sha": "71eae7b27d1db7835d8e4625781d9b6f3f9013ac", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -12,7 +12,6 @@ use rustc_span::{Span, DUMMY_SP};\n \n use crate::{\n     constraints::OutlivesConstraint,\n-    nll::ToRegionVid,\n     region_infer::TypeTest,\n     type_check::{Locations, MirTypeckRegionConstraints},\n     universal_regions::UniversalRegions,\n@@ -198,7 +197,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n \n     fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n         if let ty::RePlaceholder(placeholder) = *r {\n-            self.constraints.placeholder_region(self.infcx, placeholder).to_region_vid()\n+            self.constraints.placeholder_region(self.infcx, placeholder).as_var()\n         } else {\n             self.universal_regions.to_region_vid(r)\n         }"}, {"sha": "f1ad0ca55ccfd45b0a9dc8bdc11345dcbb286984", "filename": "compiler/rustc_borrowck/src/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -11,7 +11,6 @@ use crate::{\n     constraints::OutlivesConstraintSet,\n     facts::{AllFacts, AllFactsExt},\n     location::LocationTable,\n-    nll::ToRegionVid,\n     region_infer::values::RegionValueElements,\n     universal_regions::UniversalRegions,\n };\n@@ -80,9 +79,7 @@ fn compute_relevant_live_locals<'tcx>(\n ) -> (Vec<Local>, Vec<Local>) {\n     let (boring_locals, relevant_live_locals): (Vec<_>, Vec<_>) =\n         body.local_decls.iter_enumerated().partition_map(|(local, local_decl)| {\n-            if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n-                free_regions.contains(&r.to_region_vid())\n-            }) {\n+            if tcx.all_free_regions_meet(&local_decl.ty, |r| free_regions.contains(&r.as_var())) {\n                 Either::Left(local)\n             } else {\n                 Either::Right(local)"}, {"sha": "375eca1b29d3daf841f5b0d184d2a0976276cde0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -56,7 +56,6 @@ use crate::{\n     facts::AllFacts,\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n-    nll::ToRegionVid,\n     path_utils,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n@@ -2419,7 +2418,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if let Some(all_facts) = all_facts {\n             let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n             if let Some(borrow_index) = borrow_set.get_index_of(&location) {\n-                let region_vid = borrow_region.to_region_vid();\n+                let region_vid = borrow_region.as_var();\n                 all_facts.loan_issued_at.push((\n                     region_vid,\n                     borrow_index,\n@@ -2465,8 +2464,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     match base_ty.kind() {\n                         ty::Ref(ref_region, _, mutbl) => {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n-                                sup: ref_region.to_region_vid(),\n-                                sub: borrow_region.to_region_vid(),\n+                                sup: ref_region.as_var(),\n+                                sub: borrow_region.as_var(),\n                                 locations: location.to_locations(),\n                                 span: location.to_locations().span(body),\n                                 category,"}, {"sha": "7e6d17ec3437e7062680df9557b1843f80d27506", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -131,13 +131,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(sym::env),\n         };\n \n-        let reg_var =\n-            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-\n         if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            debug!(?reg_var);\n-            var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+            var_to_origin.insert(reg.as_var(), RegionCtxt::Placeholder(reg_info));\n         }\n \n         reg\n@@ -150,12 +146,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             universe,\n         );\n \n-        let reg_var =\n-            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-\n         if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n+            var_to_origin.insert(reg.as_var(), RegionCtxt::Existential(None));\n         }\n \n         reg"}, {"sha": "70fddb1057c09c86f69a7f5f03c6773648b0b52d", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -28,7 +28,6 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::Symbol;\n use std::iter;\n \n-use crate::nll::ToRegionVid;\n use crate::renumber::{BoundRegionInfo, RegionCtxt};\n use crate::BorrowckInferCtxt;\n \n@@ -406,7 +405,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         // Create the \"global\" region that is always free in all contexts: 'static.\n         let fr_static =\n-            self.infcx.next_nll_region_var(FR, || RegionCtxt::Free(kw::Static)).to_region_vid();\n+            self.infcx.next_nll_region_var(FR, || RegionCtxt::Free(kw::Static)).as_var();\n \n         // We've now added all the global regions. The next ones we\n         // add will be external.\n@@ -446,7 +445,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                         };\n \n                         debug!(?region_vid);\n-                        indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                        indices.insert_late_bound_region(r, region_vid.as_var());\n                     }\n                 },\n             );\n@@ -480,7 +479,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 };\n \n                 debug!(?region_vid);\n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n \n@@ -499,7 +498,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let reg_vid = self\n                     .infcx\n                     .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"c-variadic\")))\n-                    .to_region_vid();\n+                    .as_var();\n \n                 let region = self.infcx.tcx.mk_re_var(reg_vid);\n                 let va_list_ty =\n@@ -514,7 +513,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let fr_fn_body = self\n             .infcx\n             .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"fn_body\")))\n-            .to_region_vid();\n+            .as_var();\n \n         let num_universals = self.infcx.num_region_vars();\n \n@@ -635,7 +634,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let global_mapping = iter::once((tcx.lifetimes.re_static, fr_static));\n         let subst_mapping =\n-            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.to_region_vid()));\n+            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.as_var()));\n \n         UniversalRegionIndices { indices: global_mapping.chain(subst_mapping).collect(), fr_static }\n     }\n@@ -789,7 +788,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n                 self.next_nll_region_var(origin, || RegionCtxt::Bound(BoundRegionInfo::Name(name)))\n             };\n \n-            indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n+            indices.insert_late_bound_region(liberated_region, region_vid.as_var());\n             debug!(?liberated_region, ?region_vid);\n             region_vid\n         });\n@@ -822,7 +821,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n                 };\n \n                 debug!(?region_vid);\n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n     }\n@@ -843,7 +842,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n                     })\n                 };\n \n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n     }\n@@ -861,7 +860,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n \n     /// Converts `r` into a local inference variable: `r` can either\n-    /// by a `ReVar` (i.e., already a reference to an inference\n+    /// be a `ReVar` (i.e., already a reference to an inference\n     /// variable) or it can be `'static` or some early-bound\n     /// region. This is useful when taking the results from\n     /// type-checking and trait-matching, which may sometimes\n@@ -870,7 +869,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     /// fully initialized.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n         if let ty::ReVar(..) = *r {\n-            r.to_region_vid()\n+            r.as_var()\n         } else if r.is_error() {\n             // We use the `'static` `RegionVid` because `ReError` doesn't actually exist in the\n             // `UniversalRegionIndices`. This is fine because 1) it is a fallback only used if"}, {"sha": "c173bd913a84c416d807f6ac77f2ccee5d58786e", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -8,10 +8,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{\n-    self, ImplTraitInTraitData, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable,\n-    TypeVisitableExt,\n-};\n+use rustc_middle::ty::{self, ImplTraitInTraitData, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -874,28 +871,6 @@ fn infer_placeholder_type<'a>(\n     item_ident: Ident,\n     kind: &'static str,\n ) -> Ty<'a> {\n-    // Attempts to make the type nameable by turning FnDefs into FnPtrs.\n-    struct MakeNameable<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-    }\n-\n-    impl<'tcx> TypeFolder<TyCtxt<'tcx>> for MakeNameable<'tcx> {\n-        fn interner(&self) -> TyCtxt<'tcx> {\n-            self.tcx\n-        }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            let ty = match *ty.kind() {\n-                ty::FnDef(def_id, substs) => {\n-                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(def_id).subst(self.tcx, substs))\n-                }\n-                _ => ty,\n-            };\n-\n-            ty.super_fold_with(self)\n-        }\n-    }\n-\n     let ty = tcx.diagnostic_only_typeck(def_id).node_type(body_id.hir_id);\n \n     // If this came from a free `const` or `static mut?` item,"}, {"sha": "a52c94cb00c531621f9834b66a666d688a17bc5c", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -12,9 +12,7 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{\n-    self, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n-};\n+use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n@@ -965,21 +963,3 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n         }\n     }\n }\n-\n-struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n-\n-impl<'tcx> TypeFolder<TyCtxt<'tcx>> for TypeParamEraser<'_, 'tcx> {\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.0.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.kind() {\n-            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::MiscVariable,\n-                span: self.1,\n-            }),\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-}"}, {"sha": "96c1577d52bcb42aa08646552cc8cca24fd0e068", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -7,8 +7,8 @@ use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::visit::ValidateBoundVars;\n use crate::ty::InferTy::*;\n use crate::ty::{\n-    self, AdtDef, Discr, FallibleTypeFolder, Term, Ty, TyCtxt, TypeFlags, TypeFoldable,\n-    TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,\n+    self, AdtDef, Discr, Term, Ty, TyCtxt, TypeFlags, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitableExt, TypeVisitor,\n };\n use crate::ty::{List, ParamEnv};\n use hir::def::DefKind;\n@@ -1156,81 +1156,6 @@ where\n     }\n }\n \n-struct SkipBindersAt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    index: ty::DebruijnIndex,\n-}\n-\n-impl<'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for SkipBindersAt<'tcx> {\n-    type Error = ();\n-\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n-    where\n-        T: ty::TypeFoldable<TyCtxt<'tcx>>,\n-    {\n-        self.index.shift_in(1);\n-        let value = t.try_map_bound(|t| t.try_fold_with(self));\n-        self.index.shift_out(1);\n-        value\n-    }\n-\n-    fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        if !ty.has_escaping_bound_vars() {\n-            Ok(ty)\n-        } else if let ty::Bound(index, bv) = *ty.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_bound(index.shifted_out(1), bv))\n-            }\n-        } else {\n-            ty.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        if !r.has_escaping_bound_vars() {\n-            Ok(r)\n-        } else if let ty::ReLateBound(index, bv) = r.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_re_late_bound(index.shifted_out(1), bv))\n-            }\n-        } else {\n-            r.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_const(&mut self, ct: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n-        if !ct.has_escaping_bound_vars() {\n-            Ok(ct)\n-        } else if let ty::ConstKind::Bound(index, bv) = ct.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_const(\n-                    ty::ConstKind::Bound(index.shifted_out(1), bv),\n-                    ct.ty().try_fold_with(self)?,\n-                ))\n-            }\n-        } else {\n-            ct.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_predicate(\n-        &mut self,\n-        p: ty::Predicate<'tcx>,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n-        if !p.has_escaping_bound_vars() { Ok(p) } else { p.try_super_fold_with(self) }\n-    }\n-}\n-\n /// Represents the projection of an associated type.\n ///\n /// For a projection, this would be `<Ty as Trait<...>>::N`.\n@@ -1772,10 +1697,10 @@ impl<'tcx> Region<'tcx> {\n         matches!(self.kind(), ty::ReVar(_))\n     }\n \n-    pub fn as_var(self) -> Option<RegionVid> {\n+    pub fn as_var(self) -> RegionVid {\n         match self.kind() {\n-            ty::ReVar(vid) => Some(vid),\n-            _ => None,\n+            ty::ReVar(vid) => vid,\n+            _ => bug!(\"expected region {:?} to be of kind ReVar\", self),\n         }\n     }\n }"}, {"sha": "686631e5369fb7b658628e622c7b48b7dd85d12e", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4ea59a5401658539df3db8a68eb7035025595/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=35c4ea59a5401658539df3db8a68eb7035025595", "patch": "@@ -9,7 +9,6 @@ use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{ImplPolarity, Region, RegionVid};\n \n@@ -851,23 +850,3 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         infcx.freshen(p)\n     }\n }\n-\n-/// Replaces all ReVars in a type with ty::Region's, using the provided map\n-pub struct RegionReplacer<'a, 'tcx> {\n-    vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for RegionReplacer<'a, 'tcx> {\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match *r {\n-            ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n-            _ => None,\n-        })\n-        .unwrap_or_else(|| r.super_fold_with(self))\n-    }\n-}"}]}