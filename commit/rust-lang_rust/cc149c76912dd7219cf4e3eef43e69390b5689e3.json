{"sha": "cc149c76912dd7219cf4e3eef43e69390b5689e3", "node_id": "C_kwDOAAsO6NoAKGNjMTQ5Yzc2OTEyZGQ3MjE5Y2Y0ZTNlZWY0M2U2OTM5MGI1Njg5ZTM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-19T12:43:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-20T06:37:20Z"}, "message": "put a tcx into the Machine so that we have to pass around fewer things", "tree": {"sha": "541bdb294f5d1519e3e2405260669a14202a15b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/541bdb294f5d1519e3e2405260669a14202a15b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc149c76912dd7219cf4e3eef43e69390b5689e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc149c76912dd7219cf4e3eef43e69390b5689e3", "html_url": "https://github.com/rust-lang/rust/commit/cc149c76912dd7219cf4e3eef43e69390b5689e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc149c76912dd7219cf4e3eef43e69390b5689e3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "html_url": "https://github.com/rust-lang/rust/commit/3cb27f584b70fa8dc4f89768df2860e0092a6eeb"}], "stats": {"total": 262, "additions": 130, "deletions": 132}, "files": [{"sha": "5e0da17ade8511138aaf3ed3b0a9bb3b4f01c5ab", "filename": "src/diagnostics.rs", "status": "modified", "additions": 93, "deletions": 95, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=cc149c76912dd7219cf4e3eef43e69390b5689e3", "patch": "@@ -3,7 +3,6 @@ use std::num::NonZeroU64;\n \n use log::trace;\n \n-use rustc_middle::ty::TyCtxt;\n use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n@@ -91,13 +90,12 @@ enum DiagLevel {\n fn prune_stacktrace<'tcx>(\n     mut stacktrace: Vec<FrameInfo<'tcx>>,\n     machine: &Evaluator<'_, 'tcx>,\n-    tcx: TyCtxt<'tcx>,\n ) -> (Vec<FrameInfo<'tcx>>, bool) {\n     match machine.backtrace_style {\n         BacktraceStyle::Off => {\n             // Remove all frames marked with `caller_location` -- that attribute indicates we\n             // usually want to point at the caller, not them.\n-            stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(tcx));\n+            stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(machine.tcx));\n             // Retain one frame so that we can print a span for the error itself\n             stacktrace.truncate(1);\n             (stacktrace, false)\n@@ -111,7 +109,7 @@ fn prune_stacktrace<'tcx>(\n             if has_local_frame {\n                 // Remove all frames marked with `caller_location` -- that attribute indicates we\n                 // usually want to point at the caller, not them.\n-                stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(tcx));\n+                stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(machine.tcx));\n \n                 // This is part of the logic that `std` uses to select the relevant part of a\n                 // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n@@ -121,7 +119,7 @@ fn prune_stacktrace<'tcx>(\n                     .into_iter()\n                     .take_while(|frame| {\n                         let def_id = frame.instance.def_id();\n-                        let path = tcx.def_path_str(def_id);\n+                        let path = machine.tcx.def_path_str(def_id);\n                         !path.contains(\"__rust_begin_short_backtrace\")\n                     })\n                     .collect::<Vec<_>>();\n@@ -256,7 +254,7 @@ pub fn report_error<'tcx, 'mir>(\n     };\n \n     let stacktrace = ecx.generate_stacktrace();\n-    let (stacktrace, was_pruned) = prune_stacktrace(stacktrace, &ecx.machine, *ecx.tcx);\n+    let (stacktrace, was_pruned) = prune_stacktrace(stacktrace, &ecx.machine);\n     e.print_backtrace();\n     msg.insert(0, e.to_string());\n     report_msg(\n@@ -267,7 +265,6 @@ pub fn report_error<'tcx, 'mir>(\n         helps,\n         &stacktrace,\n         &ecx.machine,\n-        *ecx.tcx,\n     );\n \n     // Include a note like `std` does when we omit frames from a backtrace\n@@ -315,13 +312,13 @@ fn report_msg<'tcx>(\n     helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n     machine: &Evaluator<'_, 'tcx>,\n-    tcx: TyCtxt<'tcx>,\n ) {\n     let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n+    let sess = machine.tcx.sess;\n     let mut err = match diag_level {\n-        DiagLevel::Error => tcx.sess.struct_span_err(span, title).forget_guarantee(),\n-        DiagLevel::Warning => tcx.sess.struct_span_warn(span, title),\n-        DiagLevel::Note => tcx.sess.diagnostic().span_note_diag(span, title),\n+        DiagLevel::Error => sess.struct_span_err(span, title).forget_guarantee(),\n+        DiagLevel::Warning => sess.struct_span_warn(span, title),\n+        DiagLevel::Note => sess.diagnostic().span_note_diag(span, title),\n     };\n \n     // Show main message.\n@@ -370,95 +367,97 @@ fn report_msg<'tcx>(\n     err.emit();\n }\n \n-pub fn emit_diagnostic<'tcx>(e: NonHaltingDiagnostic, machine: &Evaluator<'_, 'tcx>, tcx: TyCtxt<'tcx>) {\n-    use NonHaltingDiagnostic::*;\n-\n-    let stacktrace = MiriEvalContext::generate_stacktrace_from_stack(machine.threads.active_thread_stack());\n-    let (stacktrace, _was_pruned) = prune_stacktrace(stacktrace, machine, tcx);\n-\n-    let (title, diag_level) = match e {\n-        RejectedIsolatedOp(_) =>\n-            (\"operation rejected by isolation\", DiagLevel::Warning),\n-        Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n-        CreatedPointerTag(..)\n-        | PoppedPointerTag(..)\n-        | CreatedCallId(..)\n-        | CreatedAlloc(..)\n-        | FreedAlloc(..)\n-        | ProgressReport { .. }\n-        | WeakMemoryOutdatedLoad =>\n-            (\"tracking was triggered\", DiagLevel::Note),\n-    };\n-\n-    let msg = match e {\n-        CreatedPointerTag(tag, None) =>\n-            format!(\"created tag {tag:?}\"),\n-        CreatedPointerTag(tag, Some((alloc_id, range))) =>\n-            format!(\"created tag {tag:?} at {alloc_id:?}{range:?}\"),\n-        PoppedPointerTag(item, tag) =>\n-            match tag {\n-                None =>\n-                    format!(\n-                        \"popped tracked tag for item {item:?} due to deallocation\",\n-                    ),\n-                Some((tag, access)) => {\n-                    format!(\n-                        \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n-                    )\n-                }\n-            },\n-        CreatedCallId(id) =>\n-            format!(\"function call with id {id}\"),\n-        CreatedAlloc(AllocId(id), size, align, kind) =>\n-            format!(\n-                \"created {kind} allocation of {size} bytes (alignment {align} bytes) with id {id}\",\n-                size = size.bytes(),\n-                align = align.bytes(),\n-            ),\n-        FreedAlloc(AllocId(id)) =>\n-            format!(\"freed allocation with id {id}\"),\n-        RejectedIsolatedOp(ref op) =>\n-            format!(\"{op} was made to return an error due to isolation\"),\n-        ProgressReport { .. } =>\n-            format!(\"progress report: current operation being executed is here\"),\n-        Int2Ptr { .. } =>\n-            format!(\"integer-to-pointer cast\"),\n-        WeakMemoryOutdatedLoad =>\n-            format!(\"weak memory emulation: outdated value returned from load\"),\n-    };\n-\n-    let notes = match e {\n-        ProgressReport { block_count } => {\n-            // It is important that each progress report is slightly different, since\n-            // identical diagnostics are being deduplicated.\n-            vec![\n-                (None, format!(\"so far, {block_count} basic blocks have been executed\")),\n-            ]\n-        }\n-        _ => vec![],\n-    };\n-\n-    let helps = match e {\n-        Int2Ptr { details: true } =>\n-            vec![\n-                (None, format!(\"This program is using integer-to-pointer casts or (equivalently) `ptr::from_exposed_addr`,\")),\n-                (None, format!(\"which means that Miri might miss pointer bugs in this program.\")),\n-                (None, format!(\"See https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation.\")),\n-                (None, format!(\"To ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead.\")),\n-                (None, format!(\"You can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics.\")),\n-                (None, format!(\"Alternatively, the `-Zmiri-permissive-provenance` flag disables this warning.\")),\n-            ],\n-        _ => vec![],\n-    };\n-\n-    report_msg(diag_level, title, vec![msg], notes, helps, &stacktrace, machine, tcx);\n+impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n+    pub fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n+        use NonHaltingDiagnostic::*;\n+\n+        let stacktrace = MiriEvalContext::generate_stacktrace_from_stack(self.threads.active_thread_stack());\n+        let (stacktrace, _was_pruned) = prune_stacktrace(stacktrace, self);\n+\n+        let (title, diag_level) = match e {\n+            RejectedIsolatedOp(_) =>\n+                (\"operation rejected by isolation\", DiagLevel::Warning),\n+            Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n+            CreatedPointerTag(..)\n+            | PoppedPointerTag(..)\n+            | CreatedCallId(..)\n+            | CreatedAlloc(..)\n+            | FreedAlloc(..)\n+            | ProgressReport { .. }\n+            | WeakMemoryOutdatedLoad =>\n+                (\"tracking was triggered\", DiagLevel::Note),\n+        };\n+\n+        let msg = match e {\n+            CreatedPointerTag(tag, None) =>\n+                format!(\"created tag {tag:?}\"),\n+            CreatedPointerTag(tag, Some((alloc_id, range))) =>\n+                format!(\"created tag {tag:?} at {alloc_id:?}{range:?}\"),\n+            PoppedPointerTag(item, tag) =>\n+                match tag {\n+                    None =>\n+                        format!(\n+                            \"popped tracked tag for item {item:?} due to deallocation\",\n+                        ),\n+                    Some((tag, access)) => {\n+                        format!(\n+                            \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n+                        )\n+                    }\n+                },\n+            CreatedCallId(id) =>\n+                format!(\"function call with id {id}\"),\n+            CreatedAlloc(AllocId(id), size, align, kind) =>\n+                format!(\n+                    \"created {kind} allocation of {size} bytes (alignment {align} bytes) with id {id}\",\n+                    size = size.bytes(),\n+                    align = align.bytes(),\n+                ),\n+            FreedAlloc(AllocId(id)) =>\n+                format!(\"freed allocation with id {id}\"),\n+            RejectedIsolatedOp(ref op) =>\n+                format!(\"{op} was made to return an error due to isolation\"),\n+            ProgressReport { .. } =>\n+                format!(\"progress report: current operation being executed is here\"),\n+            Int2Ptr { .. } =>\n+                format!(\"integer-to-pointer cast\"),\n+            WeakMemoryOutdatedLoad =>\n+                format!(\"weak memory emulation: outdated value returned from load\"),\n+        };\n+\n+        let notes = match e {\n+            ProgressReport { block_count } => {\n+                // It is important that each progress report is slightly different, since\n+                // identical diagnostics are being deduplicated.\n+                vec![\n+                    (None, format!(\"so far, {block_count} basic blocks have been executed\")),\n+                ]\n+            }\n+            _ => vec![],\n+        };\n+\n+        let helps = match e {\n+            Int2Ptr { details: true } =>\n+                vec![\n+                    (None, format!(\"This program is using integer-to-pointer casts or (equivalently) `ptr::from_exposed_addr`,\")),\n+                    (None, format!(\"which means that Miri might miss pointer bugs in this program.\")),\n+                    (None, format!(\"See https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation.\")),\n+                    (None, format!(\"To ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead.\")),\n+                    (None, format!(\"You can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics.\")),\n+                    (None, format!(\"Alternatively, the `-Zmiri-permissive-provenance` flag disables this warning.\")),\n+                ],\n+            _ => vec![],\n+        };\n+\n+        report_msg(diag_level, title, vec![msg], notes, helps, &stacktrace, self);\n+    }\n }\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n         let this = self.eval_context_ref();\n-        emit_diagnostic(e, &this.machine, *this.tcx);\n+        this.machine.emit_diagnostic(e);\n     }\n \n     /// We had a panic in Miri itself, try to print something useful.\n@@ -477,7 +476,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             vec![],\n             &stacktrace,\n             &this.machine,\n-            *this.tcx,\n         );\n     }\n }"}, {"sha": "ee972bf685856a21c3837d220c63d1c3a1e5d16b", "filename": "src/helpers.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=cc149c76912dd7219cf4e3eef43e69390b5689e3", "patch": "@@ -881,16 +881,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             None => tcx.item_name(def_id),\n         }\n     }\n-\n-    fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        let this = self.eval_context_ref();\n-        CurrentSpan { current_frame_idx: None, machine: &this.machine, tcx: *this.tcx }\n-    }\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n-    pub fn current_span(&self, tcx: TyCtxt<'tcx>) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { current_frame_idx: None, machine: self, tcx }\n+    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n+        CurrentSpan { current_frame_idx: None, machine: self }\n     }\n }\n \n@@ -901,15 +896,12 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n #[derive(Clone)]\n pub struct CurrentSpan<'a, 'mir, 'tcx> {\n     current_frame_idx: Option<usize>,\n-    tcx: TyCtxt<'tcx>,\n     machine: &'a Evaluator<'mir, 'tcx>,\n }\n \n impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n-    /// Not really about the `CurrentSpan`, but we just happen to have all the things needed to emit\n-    /// diagnostics like that.\n-    pub fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n-        emit_diagnostic(e, self.machine, self.tcx);\n+    pub fn machine(&self) -> &'a Evaluator<'mir, 'tcx> {\n+        self.machine\n     }\n \n     /// Get the current span, skipping non-local frames.\n@@ -939,13 +931,13 @@ impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n     fn current_frame_idx(&mut self) -> usize {\n         *self\n             .current_frame_idx\n-            .get_or_insert_with(|| Self::compute_current_frame_index(self.tcx, self.machine))\n+            .get_or_insert_with(|| Self::compute_current_frame_index(self.machine))\n     }\n \n     // Find the position of the inner-most frame which is part of the crate being\n     // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n     #[inline(never)]\n-    fn compute_current_frame_index(tcx: TyCtxt<'_>, machine: &Evaluator<'_, '_>) -> usize {\n+    fn compute_current_frame_index(machine: &Evaluator<'_, '_>) -> usize {\n         machine\n             .threads\n             .active_thread_stack()\n@@ -955,7 +947,7 @@ impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n             .find_map(|(idx, frame)| {\n                 let def_id = frame.instance.def_id();\n                 if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n-                    && !frame.instance.def.requires_caller_location(tcx)\n+                    && !frame.instance.def.requires_caller_location(machine.tcx)\n                 {\n                     Some(idx)\n                 } else {"}, {"sha": "7cea752b10e933d765ac2ce0bac111c5d587e709", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=cc149c76912dd7219cf4e3eef43e69390b5689e3", "patch": "@@ -94,7 +94,7 @@ pub use crate::concurrency::{\n     },\n };\n pub use crate::diagnostics::{\n-    emit_diagnostic, report_error, EvalContextExt as DiagnosticsEvalContextExt,\n+    report_error, EvalContextExt as DiagnosticsEvalContextExt,\n     NonHaltingDiagnostic, TerminationInfo,\n };\n pub use crate::eval::{"}, {"sha": "a7fdf8c35ab0d37c1a51094b3bf0238faa95be50", "filename": "src/machine.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=cc149c76912dd7219cf4e3eef43e69390b5689e3", "patch": "@@ -292,8 +292,16 @@ impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n \n /// The machine itself.\n pub struct Evaluator<'mir, 'tcx> {\n+    // We carry a copy of the global `TyCtxt` for convenience, so methods taking just `&Evaluator` have `tcx` access.\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// Stacked Borrows global data.\n     pub stacked_borrows: Option<stacked_borrows::GlobalState>,\n+\n+    /// Data race detector global data.\n     pub data_race: Option<data_race::GlobalState>,\n+\n+    /// Ptr-int-cast module global data.\n     pub intptrcast: intptrcast::GlobalState,\n \n     /// Environment variables set by `setenv`.\n@@ -419,6 +427,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n         });\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n         Evaluator {\n+            tcx: layout_cx.tcx,\n             stacked_borrows,\n             data_race,\n             intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n@@ -770,7 +779,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc.size(),\n                 stacked_borrows,\n                 kind,\n-                ecx.machine.current_span(*ecx.tcx),\n+                ecx.machine.current_span(),\n             )\n         });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n@@ -813,7 +822,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n         let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.current_span())\n+            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n             SbTag::default()\n@@ -866,7 +875,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_read(\n-        tcx: TyCtxt<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         machine: &Self,\n         alloc_extra: &AllocExtra,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n@@ -886,7 +895,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(tcx),\n+                machine.current_span(),\n                 &machine.threads,\n             )?;\n         }\n@@ -898,7 +907,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_write(\n-        tcx: TyCtxt<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n@@ -918,7 +927,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(tcx),\n+                machine.current_span(),\n                 &machine.threads,\n             )?;\n         }\n@@ -930,14 +939,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_deallocation(\n-        tcx: TyCtxt<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if machine.tracked_alloc_ids.contains(&alloc_id) {\n-            emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id), machine, tcx);\n+            machine.emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.deallocate(\n@@ -953,7 +962,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prove_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(tcx),\n+                machine.current_span(),\n                 &machine.threads,\n             )\n         } else {\n@@ -993,7 +1002,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n \n         let extra = FrameData {\n-            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.current_span())),\n+            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n         };"}, {"sha": "7148c489090eb0d350bdb2bedc926e584d6ea164", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=cc149c76912dd7219cf4e3eef43e69390b5689e3", "patch": "@@ -471,7 +471,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                 Some((orig_tag, kind))\n             }\n         };\n-        self.current_span.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+        self.current_span.machine().emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n     }\n }\n "}, {"sha": "de9ca2808382d5cb85d14e45ff25b14628c481f9", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc149c76912dd7219cf4e3eef43e69390b5689e3/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=cc149c76912dd7219cf4e3eef43e69390b5689e3", "patch": "@@ -178,11 +178,11 @@ impl GlobalStateInner {\n         id\n     }\n \n-    pub fn new_frame(&mut self, current_span: &CurrentSpan<'_, '_, '_>) -> FrameExtra {\n+    pub fn new_frame(&mut self, machine: &Evaluator<'_, '_>) -> FrameExtra {\n         let call_id = self.next_call_id;\n         trace!(\"new_frame: Assigning call ID {}\", call_id);\n         if self.tracked_call_ids.contains(&call_id) {\n-            current_span.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n+            machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n         }\n         self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n         FrameExtra { call_id, protected_tags: SmallVec::new() }\n@@ -199,11 +199,11 @@ impl GlobalStateInner {\n         }\n     }\n \n-    pub fn base_ptr_tag(&mut self, id: AllocId, current_span: &CurrentSpan<'_, '_, '_>) -> SbTag {\n+    pub fn base_ptr_tag(&mut self, id: AllocId, machine: &Evaluator<'_, '_>) -> SbTag {\n         self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n             let tag = self.new_ptr();\n             if self.tracked_pointer_tags.contains(&tag) {\n-                current_span.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None));\n+                machine.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None));\n             }\n             trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n             self.base_ptr_tags.try_insert(id, tag).unwrap();\n@@ -572,9 +572,9 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (extra.base_ptr_tag(id, &current_span), Permission::Unique),\n+            MemoryKind::Stack => (extra.base_ptr_tag(id, current_span.machine()), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id, &current_span), Permission::SharedReadWrite),\n+            _ => (extra.base_ptr_tag(id, current_span.machine()), Permission::SharedReadWrite),\n         };\n         Stacks::new(size, perm, base_tag, id, &mut current_span)\n     }\n@@ -688,7 +688,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n             let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n             match alloc_kind {\n                 AllocKind::LiveData => {\n-                    let current_span = &mut this.machine.current_span(*this.tcx);\n+                    let current_span = &mut this.machine.current_span();\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n                     // uncovers a non-supported `extern static`.\n@@ -805,7 +805,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n                 // FIXME: can't share this with the current_span inside log_creation\n-                let mut current_span = this.machine.current_span(*this.tcx);\n+                let mut current_span = this.machine.current_span();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -843,7 +843,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n-        let tcx = *this.tcx;\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n         let mut stacked_borrows = alloc_extra\n             .stacked_borrows\n@@ -854,7 +853,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         // FIXME: can't share this with the current_span inside log_creation\n-        let current_span = &mut machine.current_span(tcx);\n+        let current_span = &mut machine.current_span();\n         let dcx = DiagnosticCxBuilder::retag(\n             current_span,\n             &machine.threads,"}]}