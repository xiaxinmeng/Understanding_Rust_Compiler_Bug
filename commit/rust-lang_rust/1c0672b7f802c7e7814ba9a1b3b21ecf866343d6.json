{"sha": "1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMDY3MmI3ZjgwMmM3ZTc4MTRiYTlhMWIzYjIxZWNmODY2MzQzZDY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-03T10:38:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-03T10:38:47Z"}, "message": "Merge #1756\n\n1756: Correctly build BodySourceMap for macro-expanded expressions r=flodiebold a=matklad\n\nr? @flodiebold \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "df19e2603745c348e2e5d8289be80c2f511b0b0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df19e2603745c348e2e5d8289be80c2f511b0b0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdbkK3CRBK7hj4Ov3rIwAAdHIIACxFOpeDtkL0il725dQyRFEE\nQN9XSYmPNCLdCfA08mcc+wgyRNcFO7UaTlcRkzzW9YdL/qutZDQps/XbR8WTjWk4\nsFgSb+R1pqMKBR8oEM0F4LtStzOxqLC/6NGehSuDhuCI5MX9jeWeMiBRxQpepub9\nTV6srHmOilN8NR/M9k0TFxtkc/V0HuTN6Gss17bjKjh3vhgRAQi9GAHt697x+Nfj\npGFsW7QQkQV4GHmjeYgTzJcrv7h+hw2DHtvkVFauXi//e42lyOWqFzELHJem4SXl\nmBa89sluONAePI7bDjy7Fm2TCnh68P7oRYRSiBD84szWIB1po7k22ct1TnITFwY=\n=Gy3M\n-----END PGP SIGNATURE-----\n", "payload": "tree df19e2603745c348e2e5d8289be80c2f511b0b0d\nparent f5b60a53f68100937d561acae51e06b5ebb6bd18\nparent 9c3b25177e3c8d609dd24d2c2e01cbb82cab665f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567507127 +0000\ncommitter GitHub <noreply@github.com> 1567507127 +0000\n\nMerge #1756\n\n1756: Correctly build BodySourceMap for macro-expanded expressions r=flodiebold a=matklad\n\nr? @flodiebold \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "html_url": "https://github.com/rust-lang/rust/commit/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5b60a53f68100937d561acae51e06b5ebb6bd18", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b60a53f68100937d561acae51e06b5ebb6bd18", "html_url": "https://github.com/rust-lang/rust/commit/f5b60a53f68100937d561acae51e06b5ebb6bd18"}, {"sha": "9c3b25177e3c8d609dd24d2c2e01cbb82cab665f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3b25177e3c8d609dd24d2c2e01cbb82cab665f", "html_url": "https://github.com/rust-lang/rust/commit/9c3b25177e3c8d609dd24d2c2e01cbb82cab665f"}], "stats": {"total": 197, "additions": 127, "deletions": 70}, "files": [{"sha": "5c0a9dd984bfa527729191a686dea8fc0ac2da0c", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -110,9 +110,12 @@ pub fn run(verbose: bool, memory_usage: bool, path: &Path, only: Option<&str>) -\n                         let original_file = src.file_id.original_file(db);\n                         let path = db.file_relative_path(original_file);\n                         let line_index = host.analysis().file_line_index(original_file).unwrap();\n+                        let text_range = src\n+                            .ast\n+                            .either(|it| it.syntax().text_range(), |it| it.syntax().text_range());\n                         let (start, end) = (\n-                            line_index.line_col(src.ast.syntax().text_range().start()),\n-                            line_index.line_col(src.ast.syntax().text_range().end()),\n+                            line_index.line_col(text_range.start()),\n+                            line_index.line_col(text_range.end()),\n                         );\n                         bar.println(format!(\n                             \"{} {}:{}-{}:{}: Expected {}, got {}\","}, {"sha": "b9ffb0c7a8e30206f140850e9978cff490d4a996", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -1,11 +1,15 @@\n-use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SyntaxNode,\n+};\n \n use crate::{\n-    ids::AstItemDef, AstDatabase, Const, DefDatabase, Enum, EnumVariant, FieldSource, Function,\n-    HasBody, HirDatabase, HirFileId, MacroDef, Module, ModuleSource, Static, Struct, StructField,\n-    Trait, TypeAlias, Union,\n+    ids::AstItemDef, AstDatabase, Const, DefDatabase, Either, Enum, EnumVariant, FieldSource,\n+    Function, HasBody, HirDatabase, HirFileId, MacroDef, Module, ModuleSource, Static, Struct,\n+    StructField, Trait, TypeAlias, Union,\n };\n \n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub struct Source<T> {\n     pub file_id: HirFileId,\n     pub ast: T,\n@@ -16,6 +20,15 @@ pub trait HasSource {\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<Self::Ast>;\n }\n \n+impl<T> Source<T> {\n+    pub(crate) fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n+        Source { file_id: self.file_id, ast: f(self.ast) }\n+    }\n+    pub(crate) fn file_syntax(&self, db: &impl AstDatabase) -> SyntaxNode {\n+        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n+    }\n+}\n+\n /// NB: Module is !HasSource, because it has two source nodes at the same time:\n /// definition and declaration.\n impl Module {\n@@ -117,12 +130,12 @@ where\n         self,\n         db: &impl HirDatabase,\n         expr_id: crate::expr::ExprId,\n-    ) -> Option<Source<ast::Expr>> {\n+    ) -> Option<Source<Either<ast::Expr, ast::RecordField>>> {\n         let source_map = self.body_source_map(db);\n-        let expr_syntax = source_map.expr_syntax(expr_id)?.a()?;\n-        let source = self.source(db);\n-        let ast = expr_syntax.to_node(&source.ast.syntax());\n-        Some(Source { file_id: source.file_id, ast })\n+        let source_ptr = source_map.expr_syntax(expr_id)?;\n+        let root = source_ptr.file_syntax(db);\n+        let source = source_ptr.map(|ast| ast.map(|it| it.to_node(&root), |it| it.to_node(&root)));\n+        Some(source)\n     }\n }\n "}, {"sha": "fc21e269f460809f20ac085a5c8d163fd0c5561b", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     path::GenericArgs,\n     ty::primitive::{UncertainFloatTy, UncertainIntTy},\n     type_ref::{Mutability, TypeRef},\n-    DefWithBody, Either, HasSource, HirDatabase, Name, Path, Resolver,\n+    DefWithBody, Either, HasSource, HirDatabase, Name, Path, Resolver, Source,\n };\n \n pub use self::scope::ExprScopes;\n@@ -43,23 +43,32 @@ pub struct Body {\n     body_expr: ExprId,\n }\n \n+type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n+type ExprSource = Source<ExprPtr>;\n+\n+type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n+type PatSource = Source<PatPtr>;\n+\n /// An item body together with the mapping from syntax nodes to HIR expression\n /// IDs. This is needed to go from e.g. a position in a file to the HIR\n /// expression containing it; but for type inference etc., we want to operate on\n /// a structure that is agnostic to the actual positions of expressions in the\n /// file, so that we don't recompute types whenever some whitespace is typed.\n+///\n+/// One complication here is that, due to macro expansion, a single `Body` might\n+/// be spread across several files. So, for each ExprId and PatId, we record\n+/// both the HirFileId and the position inside the file. However, we only store\n+/// AST -> ExprId mapping for non-macro files, as it is not clear how to handle\n+/// this properly for macros.\n #[derive(Default, Debug, Eq, PartialEq)]\n pub struct BodySourceMap {\n     expr_map: FxHashMap<ExprPtr, ExprId>,\n-    expr_map_back: ArenaMap<ExprId, ExprPtr>,\n+    expr_map_back: ArenaMap<ExprId, ExprSource>,\n     pat_map: FxHashMap<PatPtr, PatId>,\n-    pat_map_back: ArenaMap<PatId, PatPtr>,\n+    pat_map_back: ArenaMap<PatId, PatSource>,\n     field_map: FxHashMap<(ExprId, usize), AstPtr<ast::RecordField>>,\n }\n \n-type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n-type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n-\n impl Body {\n     pub fn params(&self) -> &[PatId] {\n         &self.params\n@@ -123,16 +132,16 @@ impl Index<PatId> for Body {\n }\n \n impl BodySourceMap {\n-    pub(crate) fn expr_syntax(&self, expr: ExprId) -> Option<ExprPtr> {\n-        self.expr_map_back.get(expr).cloned()\n+    pub(crate) fn expr_syntax(&self, expr: ExprId) -> Option<ExprSource> {\n+        self.expr_map_back.get(expr).copied()\n     }\n \n     pub(crate) fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n         self.expr_map.get(&Either::A(AstPtr::new(node))).cloned()\n     }\n \n-    pub(crate) fn pat_syntax(&self, pat: PatId) -> Option<PatPtr> {\n-        self.pat_map_back.get(pat).cloned()\n+    pub(crate) fn pat_syntax(&self, pat: PatId) -> Option<PatSource> {\n+        self.pat_map_back.get(pat).copied()\n     }\n \n     pub(crate) fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {"}, {"sha": "6afd80989d614ba3864805fe1a2ae401b968fde2", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n     type_ref::TypeRef,\n     DefWithBody, Either, HirDatabase, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path,\n-    Resolver,\n+    Resolver, Source,\n };\n \n use super::{\n@@ -103,11 +103,13 @@ where\n         let id = self.body.exprs.alloc(expr);\n         if self.current_file_id == self.original_file_id {\n             self.source_map.expr_map.insert(ptr, id);\n-            self.source_map.expr_map_back.insert(id, ptr);\n         }\n+        self.source_map\n+            .expr_map_back\n+            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n         id\n     }\n-    // deshugared exprs don't have ptr, that's wrong and should be fixed\n+    // desugared exprs don't have ptr, that's wrong and should be fixed\n     // somehow.\n     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n         self.body.exprs.alloc(expr)\n@@ -117,18 +119,18 @@ where\n         let id = self.body.exprs.alloc(expr);\n         if self.current_file_id == self.original_file_id {\n             self.source_map.expr_map.insert(ptr, id);\n-            self.source_map.expr_map_back.insert(id, ptr);\n         }\n+        self.source_map\n+            .expr_map_back\n+            .insert(id, Source { file_id: self.current_file_id, ast: ptr });\n         id\n     }\n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let id = self.body.pats.alloc(pat);\n-\n         if self.current_file_id == self.original_file_id {\n             self.source_map.pat_map.insert(ptr, id);\n-            self.source_map.pat_map_back.insert(id, ptr);\n         }\n-\n+        self.source_map.pat_map_back.insert(id, Source { file_id: self.current_file_id, ast: ptr });\n         id\n     }\n "}, {"sha": "1202913e2fd3e0e179a01faef849c8aa00fc16e1", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -1,19 +1,20 @@\n use std::sync::Arc;\n \n-use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::ast;\n use rustc_hash::FxHashSet;\n \n-use super::{Expr, ExprId, RecordLitField};\n use crate::{\n     adt::AdtDef,\n     diagnostics::{DiagnosticSink, MissingFields, MissingOkInTailExpr},\n     expr::AstPtr,\n     name,\n     path::{PathKind, PathSegment},\n     ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n-    Function, HasSource, HirDatabase, ModuleDef, Name, Path, PerNs, Resolution,\n+    Function, HirDatabase, ModuleDef, Name, Path, PerNs, Resolution,\n };\n \n+use super::{Expr, ExprId, RecordLitField};\n+\n pub(crate) struct ExprValidator<'a, 'b: 'a> {\n     func: Function,\n     infer: Arc<InferenceResult>,\n@@ -78,25 +79,20 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             return;\n         }\n         let source_map = self.func.body_source_map(db);\n-        let file_id = self.func.source(db).file_id;\n-        let parse = db.parse(file_id.original_file(db));\n-        let source_file = parse.tree();\n-        if let Some(field_list_node) = source_map\n-            .expr_syntax(id)\n-            .and_then(|ptr| ptr.a())\n-            .map(|ptr| ptr.to_node(source_file.syntax()))\n-            .and_then(|expr| match expr {\n-                ast::Expr::RecordLit(it) => Some(it),\n-                _ => None,\n-            })\n-            .and_then(|lit| lit.record_field_list())\n-        {\n-            let field_list_ptr = AstPtr::new(&field_list_node);\n-            self.sink.push(MissingFields {\n-                file: file_id,\n-                field_list: field_list_ptr,\n-                missed_fields,\n-            })\n+\n+        if let Some(source_ptr) = source_map.expr_syntax(id) {\n+            if let Some(expr) = source_ptr.ast.a() {\n+                let root = source_ptr.file_syntax(db);\n+                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n+                    if let Some(field_list) = record_lit.record_field_list() {\n+                        self.sink.push(MissingFields {\n+                            file: source_ptr.file_id,\n+                            field_list: AstPtr::new(&field_list),\n+                            missed_fields,\n+                        })\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -136,10 +132,11 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         if params.len() == 2 && &params[0] == &mismatch.actual {\n             let source_map = self.func.body_source_map(db);\n-            let file_id = self.func.source(db).file_id;\n \n-            if let Some(expr) = source_map.expr_syntax(id).and_then(|n| n.a()) {\n-                self.sink.push(MissingOkInTailExpr { file: file_id, expr });\n+            if let Some(source_ptr) = source_map.expr_syntax(id) {\n+                if let Some(expr) = source_ptr.ast.a() {\n+                    self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n+                }\n             }\n         }\n     }"}, {"sha": "fdbe5e8b056bc35e883768be6a3e12997b5f0329", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -228,7 +228,7 @@ impl SourceAnalyzer {\n             let scopes = db.expr_scopes(def);\n             let scope = match offset {\n                 None => scope_for(&scopes, &source_map, &node),\n-                Some(offset) => scope_for_offset(&scopes, &source_map, offset),\n+                Some(offset) => scope_for_offset(&scopes, &source_map, file_id.into(), offset),\n             };\n             let resolver = expr::resolver_for_scope(def.body(db), db, scope);\n             SourceAnalyzer {\n@@ -330,6 +330,7 @@ impl SourceAnalyzer {\n                     .body_source_map\n                     .as_ref()?\n                     .pat_syntax(it)?\n+                    .ast // FIXME: ignoring file_id here is definitelly wrong\n                     .map_a(|ptr| ptr.cast::<ast::BindPat>().unwrap());\n                 PathResolution::LocalBinding(pat_ptr)\n             }\n@@ -354,7 +355,7 @@ impl SourceAnalyzer {\n         ret.and_then(|entry| {\n             Some(ScopeEntryWithSyntax {\n                 name: entry.name().clone(),\n-                ptr: source_map.pat_syntax(entry.pat())?,\n+                ptr: source_map.pat_syntax(entry.pat())?.ast,\n             })\n         })\n     }\n@@ -470,20 +471,27 @@ fn scope_for(\n fn scope_for_offset(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n+    file_id: HirFileId,\n     offset: TextUnit,\n ) -> Option<ScopeId> {\n     scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n-            let ast_ptr = source_map.expr_syntax(*id)?.a()?;\n-            Some((ast_ptr.syntax_node_ptr(), scope))\n+            let source = source_map.expr_syntax(*id)?;\n+            // FIXME: correctly handle macro expansion\n+            if source.file_id != file_id {\n+                return None;\n+            }\n+            let syntax_node_ptr =\n+                source.ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+            Some((syntax_node_ptr, scope))\n         })\n         // find containing scope\n         .min_by_key(|(ptr, _scope)| {\n             (!(ptr.range().start() <= offset && offset <= ptr.range().end()), ptr.range().len())\n         })\n-        .map(|(ptr, scope)| adjust(scopes, source_map, ptr, offset).unwrap_or(*scope))\n+        .map(|(ptr, scope)| adjust(scopes, source_map, ptr, file_id, offset).unwrap_or(*scope))\n }\n \n // XXX: during completion, cursor might be outside of any particular\n@@ -492,15 +500,22 @@ fn adjust(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n     ptr: SyntaxNodePtr,\n+    file_id: HirFileId,\n     offset: TextUnit,\n ) -> Option<ScopeId> {\n     let r = ptr.range();\n     let child_scopes = scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n-            let ast_ptr = source_map.expr_syntax(*id)?.a()?;\n-            Some((ast_ptr.syntax_node_ptr(), scope))\n+            let source = source_map.expr_syntax(*id)?;\n+            // FIXME: correctly handle macro expansion\n+            if source.file_id != file_id {\n+                return None;\n+            }\n+            let syntax_node_ptr =\n+                source.ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+            Some((syntax_node_ptr, scope))\n         })\n         .map(|(ptr, scope)| (ptr.range(), scope))\n         .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);"}, {"sha": "cde9801f6aa25ab64a785fef3342db9fbf625734", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -2793,6 +2793,10 @@ fn main() {\n }\n \"#),\n         @r###\"\n+    ![0; 17) '{Foo(v...,2,])}': Foo\n+    ![1; 4) 'Foo': Foo({unknown}) -> Foo\n+    ![1; 16) 'Foo(vec![1,2,])': Foo\n+    ![5; 15) 'vec![1,2,]': {unknown}\n     [156; 182) '{     ...,2); }': ()\n     [166; 167) 'x': Foo\n     \"###\n@@ -3566,38 +3570,51 @@ fn infer(content: &str) -> String {\n     let source_file = db.parse(file_id).ok().unwrap();\n \n     let mut acc = String::new();\n-    // acc.push_str(\"\\n\");\n \n     let mut infer_def = |inference_result: Arc<InferenceResult>,\n                          body_source_map: Arc<BodySourceMap>| {\n         let mut types = Vec::new();\n \n         for (pat, ty) in inference_result.type_of_pat.iter() {\n             let syntax_ptr = match body_source_map.pat_syntax(pat) {\n-                Some(sp) => sp.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr()),\n+                Some(sp) => {\n+                    sp.map(|ast| ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr()))\n+                }\n                 None => continue,\n             };\n             types.push((syntax_ptr, ty));\n         }\n \n         for (expr, ty) in inference_result.type_of_expr.iter() {\n             let syntax_ptr = match body_source_map.expr_syntax(expr) {\n-                Some(sp) => sp.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr()),\n+                Some(sp) => {\n+                    sp.map(|ast| ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr()))\n+                }\n                 None => continue,\n             };\n             types.push((syntax_ptr, ty));\n         }\n \n         // sort ranges for consistency\n-        types.sort_by_key(|(ptr, _)| (ptr.range().start(), ptr.range().end()));\n-        for (syntax_ptr, ty) in &types {\n-            let node = syntax_ptr.to_node(source_file.syntax());\n+        types.sort_by_key(|(src_ptr, _)| (src_ptr.ast.range().start(), src_ptr.ast.range().end()));\n+        for (src_ptr, ty) in &types {\n+            let node = src_ptr.ast.to_node(&src_ptr.file_syntax(&db));\n+\n             let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n                 (self_param.self_kw_token().text_range(), \"self\".to_string())\n             } else {\n-                (syntax_ptr.range(), node.text().to_string().replace(\"\\n\", \" \"))\n+                (src_ptr.ast.range(), node.text().to_string().replace(\"\\n\", \" \"))\n             };\n-            write!(acc, \"{} '{}': {}\\n\", range, ellipsize(text, 15), ty.display(&db)).unwrap();\n+            let macro_prefix = if src_ptr.file_id != file_id.into() { \"!\" } else { \"\" };\n+            write!(\n+                acc,\n+                \"{}{} '{}': {}\\n\",\n+                macro_prefix,\n+                range,\n+                ellipsize(text, 15),\n+                ty.display(&db)\n+            )\n+            .unwrap();\n         }\n     };\n "}, {"sha": "992034ef0ff66318ff4ac6f3e0de8eac36b5ebdc", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "patch": "@@ -15,8 +15,9 @@ impl SyntaxNodePtr {\n         SyntaxNodePtr { range: node.text_range(), kind: node.kind() }\n     }\n \n-    pub fn to_node(self, parent: &SyntaxNode) -> SyntaxNode {\n-        successors(Some(parent.clone()), |node| {\n+    pub fn to_node(self, root: &SyntaxNode) -> SyntaxNode {\n+        assert!(root.parent().is_none());\n+        successors(Some(root.clone()), |node| {\n             node.children().find(|it| self.range.is_subrange(&it.text_range()))\n         })\n         .find(|it| it.text_range() == self.range && it.kind() == self.kind)"}]}