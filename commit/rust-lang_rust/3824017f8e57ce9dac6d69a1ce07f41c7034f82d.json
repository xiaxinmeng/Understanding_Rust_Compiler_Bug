{"sha": "3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MjQwMTdmOGU1N2NlOWRhYzZkNjlhMWNlMDdmNDFjNzAzNGY4MmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-21T04:03:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-21T04:03:51Z"}, "message": "Auto merge of #86166 - tmiasko:no-alloca-for-zsts, r=nagisa\n\nDo not emit alloca for ZST locals with multiple assignments\n\nThis extends 35566bfd7dd2e316d190078703de54a4dadda062 to additionally stop emitting unnecessary allocas for zero sized locals that are assigned multiple times.\n\nWhen rebuilding the standard library with `-Zbuild-std` this reduces the number of locals that require an allocation from 62315 to 61767.", "tree": {"sha": "f4f4fad8bdb771e4e2e3910ecb430d6fb7b9d60b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4f4fad8bdb771e4e2e3910ecb430d6fb7b9d60b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "html_url": "https://github.com/rust-lang/rust/commit/3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3824017f8e57ce9dac6d69a1ce07f41c7034f82d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "html_url": "https://github.com/rust-lang/rust/commit/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946"}, {"sha": "40c9aaee138be57bbc98fdb5ccb4c4b70a63e5cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/40c9aaee138be57bbc98fdb5ccb4c4b70a63e5cf", "html_url": "https://github.com/rust-lang/rust/commit/40c9aaee138be57bbc98fdb5ccb4c4b70a63e5cf"}], "stats": {"total": 171, "additions": 76, "deletions": 95}, "files": [{"sha": "b6def164fac631002bc920ed071bf2fb10eba5a2", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 74, "deletions": 93, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/3824017f8e57ce9dac6d69a1ce07f41c7034f82d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3824017f8e57ce9dac6d69a1ce07f41c7034f82d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "patch": "@@ -5,7 +5,7 @@ use super::FunctionCx;\n use crate::traits::*;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{self, Location, TerminatorKind};\n@@ -16,7 +16,29 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n ) -> BitSet<mir::Local> {\n     let mir = fx.mir;\n-    let mut analyzer = LocalAnalyzer::new(fx);\n+    let dominators = mir.dominators();\n+    let locals = mir\n+        .local_decls\n+        .iter()\n+        .map(|decl| {\n+            let ty = fx.monomorphize(decl.ty);\n+            let layout = fx.cx.spanned_layout_of(ty, decl.source_info.span);\n+            if layout.is_zst() {\n+                LocalKind::ZST\n+            } else if fx.cx.is_backend_immediate(layout) || fx.cx.is_backend_scalar_pair(layout) {\n+                LocalKind::Unused\n+            } else {\n+                LocalKind::Memory\n+            }\n+        })\n+        .collect();\n+\n+    let mut analyzer = LocalAnalyzer { fx, dominators, locals };\n+\n+    // Arguments get assigned to by means of the function being called\n+    for arg in mir.args_iter() {\n+        analyzer.assign(arg, mir::START_BLOCK.start_location());\n+    }\n \n     // If there exists a local definition that dominates all uses of that local,\n     // the definition should be visited first. Traverse blocks in preorder which\n@@ -25,76 +47,45 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         analyzer.visit_basic_block_data(bb, data);\n     }\n \n-    for (local, decl) in mir.local_decls.iter_enumerated() {\n-        let ty = fx.monomorphize(decl.ty);\n-        debug!(\"local {:?} has type `{}`\", local, ty);\n-        let layout = fx.cx.spanned_layout_of(ty, decl.source_info.span);\n-        if fx.cx.is_backend_immediate(layout) {\n-            // These sorts of types are immediates that we can store\n-            // in an Value without an alloca.\n-        } else if fx.cx.is_backend_scalar_pair(layout) {\n-            // We allow pairs and uses of any of their 2 fields.\n-        } else {\n-            // These sorts of types require an alloca. Note that\n-            // is_llvm_immediate() may *still* be true, particularly\n-            // for newtypes, but we currently force some types\n-            // (e.g., structs) into an alloca unconditionally, just so\n-            // that we don't have to deal with having two pathways\n-            // (gep vs extractvalue etc).\n-            analyzer.not_ssa(local);\n+    let mut non_ssa_locals = BitSet::new_empty(analyzer.locals.len());\n+    for (local, kind) in analyzer.locals.iter_enumerated() {\n+        if matches!(kind, LocalKind::Memory) {\n+            non_ssa_locals.insert(local);\n         }\n     }\n \n-    analyzer.non_ssa_locals\n+    non_ssa_locals\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum LocalKind {\n+    ZST,\n+    /// A local that requires an alloca.\n+    Memory,\n+    /// A scalar or a scalar pair local that is neither defined nor used.\n+    Unused,\n+    /// A scalar or a scalar pair local with a single definition that dominates all uses.\n+    SSA(mir::Location),\n }\n \n struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n     dominators: Dominators<mir::BasicBlock>,\n-    non_ssa_locals: BitSet<mir::Local>,\n-    // The location of the first visited direct assignment to each\n-    // local, or an invalid location (out of bounds `block` index).\n-    first_assignment: IndexVec<mir::Local, Location>,\n+    locals: IndexVec<mir::Local, LocalKind>,\n }\n \n impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n-    fn new(fx: &'mir FunctionCx<'a, 'tcx, Bx>) -> Self {\n-        let invalid_location = mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n-        let dominators = fx.mir.dominators();\n-        let mut analyzer = LocalAnalyzer {\n-            fx,\n-            dominators,\n-            non_ssa_locals: BitSet::new_empty(fx.mir.local_decls.len()),\n-            first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls),\n-        };\n-\n-        // Arguments get assigned to by means of the function being called\n-        for arg in fx.mir.args_iter() {\n-            analyzer.first_assignment[arg] = mir::START_BLOCK.start_location();\n-        }\n-\n-        analyzer\n-    }\n-\n-    fn first_assignment(&self, local: mir::Local) -> Option<Location> {\n-        let location = self.first_assignment[local];\n-        if location.block.index() < self.fx.mir.basic_blocks().len() {\n-            Some(location)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn not_ssa(&mut self, local: mir::Local) {\n-        debug!(\"marking {:?} as non-SSA\", local);\n-        self.non_ssa_locals.insert(local);\n-    }\n-\n     fn assign(&mut self, local: mir::Local, location: Location) {\n-        if self.first_assignment(local).is_some() {\n-            self.not_ssa(local);\n-        } else {\n-            self.first_assignment[local] = location;\n+        let kind = &mut self.locals[local];\n+        match *kind {\n+            LocalKind::ZST => {}\n+            LocalKind::Memory => {}\n+            LocalKind::Unused => {\n+                *kind = LocalKind::SSA(location);\n+            }\n+            LocalKind::SSA(_) => {\n+                *kind = LocalKind::Memory;\n+            }\n         }\n     }\n \n@@ -175,11 +166,13 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n     ) {\n         debug!(\"visit_assign(place={:?}, rvalue={:?})\", place, rvalue);\n \n-        if let Some(index) = place.as_local() {\n-            self.assign(index, location);\n-            let decl_span = self.fx.mir.local_decls[index].source_info.span;\n-            if !self.fx.rvalue_creates_operand(rvalue, decl_span) {\n-                self.not_ssa(index);\n+        if let Some(local) = place.as_local() {\n+            self.assign(local, location);\n+            if self.locals[local] != LocalKind::Memory {\n+                let decl_span = self.fx.mir.local_decls[local].source_info.span;\n+                if !self.fx.rvalue_creates_operand(rvalue, decl_span) {\n+                    self.locals[local] = LocalKind::Memory;\n+                }\n             }\n         } else {\n             self.visit_place(place, PlaceContext::MutatingUse(MutatingUseContext::Store), location);\n@@ -204,32 +197,18 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n             PlaceContext::NonMutatingUse(\n                 NonMutatingUseContext::Copy | NonMutatingUseContext::Move,\n-            ) => {\n+            ) => match &mut self.locals[local] {\n+                LocalKind::ZST => {}\n+                LocalKind::Memory => {}\n+                LocalKind::SSA(def) if def.dominates(location, &self.dominators) => {}\n                 // Reads from uninitialized variables (e.g., in dead code, after\n                 // optimizations) require locals to be in (uninitialized) memory.\n                 // N.B., there can be uninitialized reads of a local visited after\n                 // an assignment to that local, if they happen on disjoint paths.\n-                let ssa_read = match self.first_assignment(local) {\n-                    Some(assignment_location) => {\n-                        assignment_location.dominates(location, &self.dominators)\n-                    }\n-                    None => {\n-                        debug!(\"No first assignment found for {:?}\", local);\n-                        // We have not seen any assignment to the local yet,\n-                        // but before marking not_ssa, check if it is a ZST,\n-                        // in which case we don't need to initialize the local.\n-                        let ty = self.fx.mir.local_decls[local].ty;\n-                        let ty = self.fx.monomorphize(ty);\n-\n-                        let is_zst = self.fx.cx.layout_of(ty).is_zst();\n-                        debug!(\"is_zst: {}\", is_zst);\n-                        is_zst\n-                    }\n-                };\n-                if !ssa_read {\n-                    self.not_ssa(local);\n+                kind @ (LocalKind::Unused | LocalKind::SSA(_)) => {\n+                    *kind = LocalKind::Memory;\n                 }\n-            }\n+            },\n \n             PlaceContext::MutatingUse(\n                 MutatingUseContext::Store\n@@ -246,16 +225,18 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 | NonMutatingUseContext::AddressOf\n                 | NonMutatingUseContext::Projection,\n             ) => {\n-                self.not_ssa(local);\n+                self.locals[local] = LocalKind::Memory;\n             }\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n-                let ty = self.fx.mir.local_decls[local].ty;\n-                let ty = self.fx.monomorphize(ty);\n-\n-                // Only need the place if we're actually dropping it.\n-                if self.fx.cx.type_needs_drop(ty) {\n-                    self.not_ssa(local);\n+                let kind = &mut self.locals[local];\n+                if *kind != LocalKind::Memory {\n+                    let ty = self.fx.mir.local_decls[local].ty;\n+                    let ty = self.fx.monomorphize(ty);\n+                    if self.fx.cx.type_needs_drop(ty) {\n+                        // Only need the place if we're actually dropping it.\n+                        *kind = LocalKind::Memory;\n+                    }\n                 }\n             }\n         }"}, {"sha": "f7923bd47439f114235b3f16846ae7a56c24e56b", "filename": "src/test/ui/limits/issue-69485-var-size-diffs-too-large.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3824017f8e57ce9dac6d69a1ce07f41c7034f82d/src%2Ftest%2Fui%2Flimits%2Fissue-69485-var-size-diffs-too-large.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3824017f8e57ce9dac6d69a1ce07f41c7034f82d/src%2Ftest%2Fui%2Flimits%2Fissue-69485-var-size-diffs-too-large.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flimits%2Fissue-69485-var-size-diffs-too-large.stderr?ref=3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "patch": "@@ -1,8 +1,8 @@\n error: values of the type `[u8; 18446744073709551615]` are too big for the current architecture\n-  --> $DIR/issue-69485-var-size-diffs-too-large.rs:6:12\n+  --> $DIR/issue-69485-var-size-diffs-too-large.rs:6:5\n    |\n LL |     Bug::V([0; !0]);\n-   |            ^^^^^^^\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}