{"sha": "653f5d98d81da9725593f21787f802562b44346a", "node_id": "C_kwDOAAsO6NoAKDY1M2Y1ZDk4ZDgxZGE5NzI1NTkzZjIxNzg3ZjgwMjU2MmI0NDM0NmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-02T22:44:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-02T22:44:15Z"}, "message": "Auto merge of #10139 - chansuke:chore/fix-if_chain_ident, r=Jarcho\n\nchore: fix identation of `if_chain` in `filter_map`\n\nThis is a really small fix.\nIf someone could take a look at it, I would appreciate it:pray:\n\n---\n\nchangelog: none\n<!-- changelog_checked -->", "tree": {"sha": "a55ec6c7b84450b87f1de502161539a777732d26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a55ec6c7b84450b87f1de502161539a777732d26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653f5d98d81da9725593f21787f802562b44346a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653f5d98d81da9725593f21787f802562b44346a", "html_url": "https://github.com/rust-lang/rust/commit/653f5d98d81da9725593f21787f802562b44346a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653f5d98d81da9725593f21787f802562b44346a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3006c7cd4fdf1f72d2b3707d63be4198f4e76781", "url": "https://api.github.com/repos/rust-lang/rust/commits/3006c7cd4fdf1f72d2b3707d63be4198f4e76781", "html_url": "https://github.com/rust-lang/rust/commit/3006c7cd4fdf1f72d2b3707d63be4198f4e76781"}, {"sha": "5b46f2db594fc3f2e8c6d8c7f9274ba77736b67c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b46f2db594fc3f2e8c6d8c7f9274ba77736b67c", "html_url": "https://github.com/rust-lang/rust/commit/5b46f2db594fc3f2e8c6d8c7f9274ba77736b67c"}], "stats": {"total": 174, "additions": 87, "deletions": 87}, "files": [{"sha": "fc80f2eeae0152825267c2bfe39375bf771325a4", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/653f5d98d81da9725593f21787f802562b44346a/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653f5d98d81da9725593f21787f802562b44346a/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=653f5d98d81da9725593f21787f802562b44346a", "patch": "@@ -30,12 +30,12 @@ fn is_method(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol) ->\n             match closure_expr.kind {\n                 hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, receiver, ..) => {\n                     if_chain! {\n-                    if ident.name == method_name;\n-                    if let hir::ExprKind::Path(path) = &receiver.kind;\n-                    if let Res::Local(ref local) = cx.qpath_res(path, receiver.hir_id);\n-                    then {\n-                        return arg_id == *local\n-                    }\n+                        if ident.name == method_name;\n+                        if let hir::ExprKind::Path(path) = &receiver.kind;\n+                        if let Res::Local(ref local) = cx.qpath_res(path, receiver.hir_id);\n+                        then {\n+                            return arg_id == *local\n+                        }\n                     }\n                     false\n                 },\n@@ -92,92 +92,92 @@ pub(super) fn check(\n     }\n \n     if_chain! {\n-            if is_trait_method(cx, map_recv, sym::Iterator);\n-\n-            // filter(|x| ...is_some())...\n-            if let ExprKind::Closure(&Closure { body: filter_body_id, .. }) = filter_arg.kind;\n-            let filter_body = cx.tcx.hir().body(filter_body_id);\n-            if let [filter_param] = filter_body.params;\n-            // optional ref pattern: `filter(|&x| ..)`\n-            let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n-                (ref_pat, true)\n-            } else {\n-                (filter_param.pat, false)\n+        if is_trait_method(cx, map_recv, sym::Iterator);\n+\n+        // filter(|x| ...is_some())...\n+        if let ExprKind::Closure(&Closure { body: filter_body_id, .. }) = filter_arg.kind;\n+        let filter_body = cx.tcx.hir().body(filter_body_id);\n+        if let [filter_param] = filter_body.params;\n+        // optional ref pattern: `filter(|&x| ..)`\n+        let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n+            (ref_pat, true)\n+        } else {\n+            (filter_param.pat, false)\n+        };\n+        // closure ends with is_some() or is_ok()\n+        if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n+        if let ExprKind::MethodCall(path, filter_arg, [], _) = filter_body.value.kind;\n+        if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).peel_refs().ty_adt_def();\n+        if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did()) {\n+            Some(false)\n+        } else if cx.tcx.is_diagnostic_item(sym::Result, opt_ty.did()) {\n+            Some(true)\n+        } else {\n+            None\n+        };\n+        if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n+\n+        // ...map(|x| ...unwrap())\n+        if let ExprKind::Closure(&Closure { body: map_body_id, .. }) = map_arg.kind;\n+        let map_body = cx.tcx.hir().body(map_body_id);\n+        if let [map_param] = map_body.params;\n+        if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n+        // closure ends with expect() or unwrap()\n+        if let ExprKind::MethodCall(seg, map_arg, ..) = map_body.value.kind;\n+        if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n+\n+        // .filter(..).map(|y| f(y).copied().unwrap())\n+        //                     ~~~~\n+        let map_arg_peeled = match map_arg.kind {\n+            ExprKind::MethodCall(method, original_arg, [], _) if acceptable_methods(method) => {\n+                original_arg\n+            },\n+            _ => map_arg,\n+        };\n+\n+        // .filter(|x| x.is_some()).map(|y| y[.acceptable_method()].unwrap())\n+        let simple_equal = path_to_local_id(filter_arg, filter_param_id)\n+            && path_to_local_id(map_arg_peeled, map_param_id);\n+\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            // in `filter(|x| ..)`, replace `*x` with `x`\n+            let a_path = if_chain! {\n+                if !is_filter_param_ref;\n+                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n+                then { expr_path } else { a }\n             };\n-            // closure ends with is_some() or is_ok()\n-            if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-            if let ExprKind::MethodCall(path, filter_arg, [], _) = filter_body.value.kind;\n-            if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).peel_refs().ty_adt_def();\n-            if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did()) {\n-                Some(false)\n-            } else if cx.tcx.is_diagnostic_item(sym::Result, opt_ty.did()) {\n-                Some(true)\n+            // let the filter closure arg and the map closure arg be equal\n+            path_to_local_id(a_path, filter_param_id)\n+                && path_to_local_id(b, map_param_id)\n+                && cx.typeck_results().expr_ty_adjusted(a) == cx.typeck_results().expr_ty_adjusted(b)\n+        };\n+\n+        if simple_equal || SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg_peeled);\n+        then {\n+            let span = filter_span.with_hi(expr.span.hi());\n+            let (filter_name, lint) = if is_find {\n+                (\"find\", MANUAL_FIND_MAP)\n             } else {\n-                None\n-            };\n-            if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n-\n-            // ...map(|x| ...unwrap())\n-            if let ExprKind::Closure(&Closure { body: map_body_id, .. }) = map_arg.kind;\n-            let map_body = cx.tcx.hir().body(map_body_id);\n-            if let [map_param] = map_body.params;\n-            if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n-            // closure ends with expect() or unwrap()\n-            if let ExprKind::MethodCall(seg, map_arg, ..) = map_body.value.kind;\n-            if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n-\n-            // .filter(..).map(|y| f(y).copied().unwrap())\n-            //                     ~~~~\n-            let map_arg_peeled = match map_arg.kind {\n-                ExprKind::MethodCall(method, original_arg, [], _) if acceptable_methods(method) => {\n-                    original_arg\n-                },\n-                _ => map_arg,\n+                (\"filter\", MANUAL_FILTER_MAP)\n             };\n+            let msg = format!(\"`{filter_name}(..).map(..)` can be simplified as `{filter_name}_map(..)`\");\n+            let (to_opt, deref) = if is_result {\n+                (\".ok()\", String::new())\n+            } else {\n+                let derefs = cx.typeck_results()\n+                    .expr_adjustments(map_arg)\n+                    .iter()\n+                    .filter(|adj| matches!(adj.kind, Adjust::Deref(_)))\n+                    .count();\n \n-            // .filter(|x| x.is_some()).map(|y| y[.acceptable_method()].unwrap())\n-            let simple_equal = path_to_local_id(filter_arg, filter_param_id)\n-                && path_to_local_id(map_arg_peeled, map_param_id);\n-\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                // in `filter(|x| ..)`, replace `*x` with `x`\n-                let a_path = if_chain! {\n-                    if !is_filter_param_ref;\n-                    if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n-                    then { expr_path } else { a }\n-                };\n-                // let the filter closure arg and the map closure arg be equal\n-                path_to_local_id(a_path, filter_param_id)\n-                    && path_to_local_id(b, map_param_id)\n-                    && cx.typeck_results().expr_ty_adjusted(a) == cx.typeck_results().expr_ty_adjusted(b)\n+                (\"\", \"*\".repeat(derefs))\n             };\n-\n-            if simple_equal || SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg_peeled);\n-            then {\n-                let span = filter_span.with_hi(expr.span.hi());\n-                let (filter_name, lint) = if is_find {\n-                    (\"find\", MANUAL_FIND_MAP)\n-                } else {\n-                    (\"filter\", MANUAL_FILTER_MAP)\n-                };\n-                let msg = format!(\"`{filter_name}(..).map(..)` can be simplified as `{filter_name}_map(..)`\");\n-                let (to_opt, deref) = if is_result {\n-                    (\".ok()\", String::new())\n-                } else {\n-                    let derefs = cx.typeck_results()\n-                        .expr_adjustments(map_arg)\n-                        .iter()\n-                        .filter(|adj| matches!(adj.kind, Adjust::Deref(_)))\n-                        .count();\n-\n-                    (\"\", \"*\".repeat(derefs))\n-                };\n-                let sugg = format!(\n-                    \"{filter_name}_map(|{map_param_ident}| {deref}{}{to_opt})\",\n-                    snippet(cx, map_arg.span, \"..\"),\n-                );\n-                span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n-            }\n+            let sugg = format!(\n+                \"{filter_name}_map(|{map_param_ident}| {deref}{}{to_opt})\",\n+                snippet(cx, map_arg.span, \"..\"),\n+            );\n+            span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n+        }\n     }\n }\n "}]}