{"sha": "ff2798840cbad2ddfaad24dde4b0fa434a48826c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMjc5ODg0MGNiYWQyZGRmYWFkMjRkZGU0YjBmYTQzNGE0ODgyNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-27T08:28:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-27T08:28:48Z"}, "message": "Auto merge of #3666 - detrumi:map-or-on-non-copy, r=flip1995\n\nOnly suggest map_or for copy types\n\nFixes #2686", "tree": {"sha": "e3ca99d7362ea76290a18f72380ff326148121df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ca99d7362ea76290a18f72380ff326148121df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff2798840cbad2ddfaad24dde4b0fa434a48826c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2798840cbad2ddfaad24dde4b0fa434a48826c", "html_url": "https://github.com/rust-lang/rust/commit/ff2798840cbad2ddfaad24dde4b0fa434a48826c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff2798840cbad2ddfaad24dde4b0fa434a48826c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58c0dc1db6ae37be6f96616c2a8a06e9b98db674", "url": "https://api.github.com/repos/rust-lang/rust/commits/58c0dc1db6ae37be6f96616c2a8a06e9b98db674", "html_url": "https://github.com/rust-lang/rust/commit/58c0dc1db6ae37be6f96616c2a8a06e9b98db674"}, {"sha": "eb70a72459816dc0bd187c7e2961f790f928a2f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb70a72459816dc0bd187c7e2961f790f928a2f8", "html_url": "https://github.com/rust-lang/rust/commit/eb70a72459816dc0bd187c7e2961f790f928a2f8"}], "stats": {"total": 250, "additions": 173, "deletions": 77}, "files": [{"sha": "8d4bb06e59be63e951034e742295330aab33bdf2", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ff2798840cbad2ddfaad24dde4b0fa434a48826c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2798840cbad2ddfaad24dde4b0fa434a48826c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ff2798840cbad2ddfaad24dde4b0fa434a48826c", "patch": "@@ -22,6 +22,7 @@ use syntax::ast;\n use syntax::source_map::{BytePos, Span};\n use syntax::symbol::LocalInternedString;\n \n+mod option_map_unwrap_or;\n mod unnecessary_filter_map;\n \n #[derive(Clone)]\n@@ -836,7 +837,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             [\"unwrap\", \"get_mut\"] => lint_get_unwrap(cx, expr, arg_lists[1], true),\n             [\"unwrap\", ..] => lint_unwrap(cx, expr, arg_lists[0]),\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n-            [\"unwrap_or\", \"map\"] => lint_map_unwrap_or(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -1769,48 +1770,6 @@ fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Ex\n     }\n }\n \n-/// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n-    // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n-        // get snippets for args to map() and unwrap_or()\n-        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n-        // lint message\n-        // comparing the snippet from source to raw text (\"None\") below is safe\n-        // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n-        let suggest = if unwrap_snippet == \"None\" {\n-            \"and_then(f)\"\n-        } else {\n-            \"map_or(a, f)\"\n-        };\n-        let msg = &format!(\n-            \"called `map(f).unwrap_or({})` on an Option value. \\\n-             This can be done more directly by calling `{}` instead\",\n-            arg, suggest\n-        );\n-        // lint, with note if neither arg is > 1 line and both map() and\n-        // unwrap_or() have the same span\n-        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n-        if same_span && !multiline {\n-            let suggest = if unwrap_snippet == \"None\" {\n-                format!(\"and_then({})\", map_snippet)\n-            } else {\n-                format!(\"map_or({}, {})\", unwrap_snippet, map_snippet)\n-            };\n-            let note = format!(\n-                \"replace `map({}).unwrap_or({})` with `{}`\",\n-                map_snippet, unwrap_snippet, suggest\n-            );\n-            span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n-        } else if same_span && multiline {\n-            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n-        };\n-    }\n-}\n-\n /// lint use of `map().flatten()` for `Iterators`\n fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.map().flatten()` is an Iterator"}, {"sha": "9a8880a7960a7778a5a42a180bdc24630a04be99", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ff2798840cbad2ddfaad24dde4b0fa434a48826c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2798840cbad2ddfaad24dde4b0fa434a48826c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=ff2798840cbad2ddfaad24dde4b0fa434a48826c", "patch": "@@ -0,0 +1,122 @@\n+use crate::utils::paths;\n+use crate::utils::{is_copy, match_type, snippet, span_lint, span_note_and_lint};\n+use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n+use rustc::hir::{self, *};\n+use rustc::lint::LateContext;\n+use rustc_data_structures::fx::FxHashSet;\n+use syntax::symbol::Symbol;\n+\n+use super::OPTION_MAP_UNWRAP_OR;\n+\n+/// lint use of `map().unwrap_or()` for `Option`s\n+pub(super) fn lint<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &hir::Expr,\n+    map_args: &'tcx [hir::Expr],\n+    unwrap_args: &'tcx [hir::Expr],\n+) {\n+    // lint if the caller of `map()` is an `Option`\n+    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n+        if !is_copy(cx, cx.tables.expr_ty(&unwrap_args[1])) {\n+            // Do not lint if the `map` argument uses identifiers in the `map`\n+            // argument that are also used in the `unwrap_or` argument\n+\n+            let mut unwrap_visitor = UnwrapVisitor {\n+                cx,\n+                identifiers: FxHashSet::default(),\n+            };\n+            unwrap_visitor.visit_expr(&unwrap_args[1]);\n+\n+            let mut map_expr_visitor = MapExprVisitor {\n+                cx,\n+                identifiers: unwrap_visitor.identifiers,\n+                found_identifier: false,\n+            };\n+            map_expr_visitor.visit_expr(&map_args[1]);\n+\n+            if map_expr_visitor.found_identifier {\n+                return;\n+            }\n+        }\n+\n+        // get snippets for args to map() and unwrap_or()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint message\n+        // comparing the snippet from source to raw text (\"None\") below is safe\n+        // because we already have checked the type.\n+        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n+        let suggest = if unwrap_snippet == \"None\" {\n+            \"and_then(f)\"\n+        } else {\n+            \"map_or(a, f)\"\n+        };\n+        let msg = &format!(\n+            \"called `map(f).unwrap_or({})` on an Option value. \\\n+             This can be done more directly by calling `{}` instead\",\n+            arg, suggest\n+        );\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or() have the same span\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        if same_span && !multiline {\n+            let suggest = if unwrap_snippet == \"None\" {\n+                format!(\"and_then({})\", map_snippet)\n+            } else {\n+                format!(\"map_or({}, {})\", unwrap_snippet, map_snippet)\n+            };\n+            let note = format!(\n+                \"replace `map({}).unwrap_or({})` with `{}`\",\n+                map_snippet, unwrap_snippet, suggest\n+            );\n+            span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n+        } else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n+        };\n+    }\n+}\n+\n+struct UnwrapVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    identifiers: FxHashSet<Symbol>,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrapVisitor<'a, 'tcx> {\n+    fn visit_path(&mut self, path: &'tcx Path, _id: HirId) {\n+        self.identifiers.insert(ident(path));\n+        walk_path(self, path);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n+    }\n+}\n+\n+struct MapExprVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    identifiers: FxHashSet<Symbol>,\n+    found_identifier: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for MapExprVisitor<'a, 'tcx> {\n+    fn visit_path(&mut self, path: &'tcx Path, _id: HirId) {\n+        if self.identifiers.contains(&ident(path)) {\n+            self.found_identifier = true;\n+            return;\n+        }\n+        walk_path(self, path);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n+    }\n+}\n+\n+fn ident(path: &Path) -> Symbol {\n+    path.segments\n+        .last()\n+        .expect(\"segments should be composed of at least 1 element\")\n+        .ident\n+        .name\n+}"}, {"sha": "b93cd6150d784044b91731eb966c0494739221a8", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff2798840cbad2ddfaad24dde4b0fa434a48826c/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff2798840cbad2ddfaad24dde4b0fa434a48826c/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=ff2798840cbad2ddfaad24dde4b0fa434a48826c", "patch": "@@ -179,6 +179,13 @@ fn option_methods() {\n     // macro case\n     let _ = opt_map!(opt, |x| x + 1).unwrap_or(0); // should not lint\n \n+    // Should not lint if not copyable\n+    let id: String = \"identifier\".to_string();\n+    let _ = Some(\"prefix\").map(|p| format!(\"{}.{}\", p, id)).unwrap_or(id);\n+    // ...but DO lint if the `unwrap_or` argument is not used in the `map`\n+    let id: String = \"identifier\".to_string();\n+    let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n+\n     // Check OPTION_MAP_UNWRAP_OR_ELSE\n     // single line case\n     let _ = opt.map(|x| x + 1)"}, {"sha": "fb617c0cb26518855eacc77f09e61a6caecc9242", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ff2798840cbad2ddfaad24dde4b0fa434a48826c/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff2798840cbad2ddfaad24dde4b0fa434a48826c/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=ff2798840cbad2ddfaad24dde4b0fa434a48826c", "patch": "@@ -89,8 +89,16 @@ LL | |         .unwrap_or(None);\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n+error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n+  --> $DIR/methods.rs:187:13\n+   |\n+LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n+\n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:184:13\n+  --> $DIR/methods.rs:191:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -102,7 +110,7 @@ LL | |                .unwrap_or_else(|| 0); // should lint even though this cal\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:188:13\n+  --> $DIR/methods.rs:195:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -112,7 +120,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:192:13\n+  --> $DIR/methods.rs:199:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -122,15 +130,15 @@ LL | |                 );\n    | |_________________^\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:201:13\n+  --> $DIR/methods.rs:208:13\n    |\n LL |     let _ = opt.map_or(None, |x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using and_then instead: `opt.and_then(|x| Some(x + 1))`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:203:13\n+  --> $DIR/methods.rs:210:13\n    |\n LL |       let _ = opt.map_or(None, |x| {\n    |  _____________^\n@@ -146,7 +154,7 @@ LL |                        });\n    |\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:229:13\n+  --> $DIR/methods.rs:236:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -155,7 +163,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:232:13\n+  --> $DIR/methods.rs:239:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -165,7 +173,7 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:248:13\n+  --> $DIR/methods.rs:255:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -174,7 +182,7 @@ LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    = note: replace `find(|&x| *x < 0).is_some()` with `any(|&x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:251:13\n+  --> $DIR/methods.rs:258:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -184,15 +192,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:257:13\n+  --> $DIR/methods.rs:264:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:260:13\n+  --> $DIR/methods.rs:267:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -202,15 +210,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:266:13\n+  --> $DIR/methods.rs:273:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:269:13\n+  --> $DIR/methods.rs:276:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -220,130 +228,130 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:306:22\n+  --> $DIR/methods.rs:313:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n    |\n    = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/methods.rs:309:5\n+  --> $DIR/methods.rs:316:5\n    |\n LL |     with_new.unwrap_or(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:312:21\n+  --> $DIR/methods.rs:319:21\n    |\n LL |     with_const_args.unwrap_or(Vec::with_capacity(12));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:315:14\n+  --> $DIR/methods.rs:322:14\n    |\n LL |     with_err.unwrap_or(make());\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:318:19\n+  --> $DIR/methods.rs:325:19\n    |\n LL |     with_err_args.unwrap_or(Vec::with_capacity(12));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:321:5\n+  --> $DIR/methods.rs:328:5\n    |\n LL |     with_default_trait.unwrap_or(Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:324:5\n+  --> $DIR/methods.rs:331:5\n    |\n LL |     with_default_type.unwrap_or(u64::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:327:14\n+  --> $DIR/methods.rs:334:14\n    |\n LL |     with_vec.unwrap_or(vec![]);\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| vec![])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:332:21\n+  --> $DIR/methods.rs:339:21\n    |\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:335:19\n+  --> $DIR/methods.rs:342:19\n    |\n LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:338:21\n+  --> $DIR/methods.rs:345:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:341:21\n+  --> $DIR/methods.rs:348:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:352:23\n+  --> $DIR/methods.rs:359:23\n    |\n LL |         let bad_vec = some_vec.iter().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:353:26\n+  --> $DIR/methods.rs:360:26\n    |\n LL |         let bad_slice = &some_vec[..].iter().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:354:31\n+  --> $DIR/methods.rs:361:31\n    |\n LL |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:355:29\n+  --> $DIR/methods.rs:362:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:360:23\n+  --> $DIR/methods.rs:367:23\n    |\n LL |         let bad_vec = some_vec.iter_mut().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:363:26\n+  --> $DIR/methods.rs:370:26\n    |\n LL |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:366:29\n+  --> $DIR/methods.rs:373:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:378:13\n+  --> $DIR/methods.rs:385:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^\n    |\n    = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 43 previous errors\n+error: aborting due to 44 previous errors\n "}]}