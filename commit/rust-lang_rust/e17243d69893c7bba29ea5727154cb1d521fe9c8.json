{"sha": "e17243d69893c7bba29ea5727154cb1d521fe9c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNzI0M2Q2OTg5M2M3YmJhMjllYTU3MjcxNTRjYjFkNTIxZmU5Yzg=", "commit": {"author": {"name": "L\u00fac\u00e1s Meier", "email": "cronokirby@gmail.com", "date": "2019-10-04T08:51:41Z"}, "committer": {"name": "L\u00fac\u00e1s Meier", "email": "cronokirby@gmail.com", "date": "2019-10-04T08:51:41Z"}, "message": "[#1807] Refactor file structure\n\nUse the more conventional way of importing the ast types, and\nput the assist at the top of the file.", "tree": {"sha": "71726560decb1bd2443783f5452ccaf570ee8dc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71726560decb1bd2443783f5452ccaf570ee8dc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e17243d69893c7bba29ea5727154cb1d521fe9c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e17243d69893c7bba29ea5727154cb1d521fe9c8", "html_url": "https://github.com/rust-lang/rust/commit/e17243d69893c7bba29ea5727154cb1d521fe9c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e17243d69893c7bba29ea5727154cb1d521fe9c8/comments", "author": {"login": "cronokirby", "id": 22821947, "node_id": "MDQ6VXNlcjIyODIxOTQ3", "avatar_url": "https://avatars.githubusercontent.com/u/22821947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cronokirby", "html_url": "https://github.com/cronokirby", "followers_url": "https://api.github.com/users/cronokirby/followers", "following_url": "https://api.github.com/users/cronokirby/following{/other_user}", "gists_url": "https://api.github.com/users/cronokirby/gists{/gist_id}", "starred_url": "https://api.github.com/users/cronokirby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cronokirby/subscriptions", "organizations_url": "https://api.github.com/users/cronokirby/orgs", "repos_url": "https://api.github.com/users/cronokirby/repos", "events_url": "https://api.github.com/users/cronokirby/events{/privacy}", "received_events_url": "https://api.github.com/users/cronokirby/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cronokirby", "id": 22821947, "node_id": "MDQ6VXNlcjIyODIxOTQ3", "avatar_url": "https://avatars.githubusercontent.com/u/22821947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cronokirby", "html_url": "https://github.com/cronokirby", "followers_url": "https://api.github.com/users/cronokirby/followers", "following_url": "https://api.github.com/users/cronokirby/following{/other_user}", "gists_url": "https://api.github.com/users/cronokirby/gists{/gist_id}", "starred_url": "https://api.github.com/users/cronokirby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cronokirby/subscriptions", "organizations_url": "https://api.github.com/users/cronokirby/orgs", "repos_url": "https://api.github.com/users/cronokirby/repos", "events_url": "https://api.github.com/users/cronokirby/events{/privacy}", "received_events_url": "https://api.github.com/users/cronokirby/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ed1e3d4a757b8f57cb7c727d66703713cdc0bdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed1e3d4a757b8f57cb7c727d66703713cdc0bdf", "html_url": "https://github.com/rust-lang/rust/commit/1ed1e3d4a757b8f57cb7c727d66703713cdc0bdf"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "5f2b0dd189b3b054169a4d7af441733f97613949", "filename": "crates/ra_assists/src/assists/apply_demorgan.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e17243d69893c7bba29ea5727154cb1d521fe9c8/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17243d69893c7bba29ea5727154cb1d521fe9c8/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs?ref=e17243d69893c7bba29ea5727154cb1d521fe9c8", "patch": "@@ -2,50 +2,19 @@\n //! This assist transforms boolean expressions of the form `!a || !b` into\n //! `!(a && b)`.\n use hir::db::HirDatabase;\n-use ra_syntax::ast::{AstNode, BinExpr, BinOp, Expr, PrefixOp};\n+use ra_syntax::ast::{self, AstNode};\n use ra_syntax::SyntaxNode;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-// Return the opposite text for a given logical operator, if it makes sense\n-fn opposite_logic_op(kind: BinOp) -> Option<&'static str> {\n-    match kind {\n-        BinOp::BooleanOr => Some(\"&&\"),\n-        BinOp::BooleanAnd => Some(\"||\"),\n-        _ => None,\n-    }\n-}\n-\n-// This function tries to undo unary negation, or inequality\n-fn undo_negation(node: SyntaxNode) -> Option<String> {\n-    match Expr::cast(node)? {\n-        Expr::BinExpr(bin) => match bin.op_kind()? {\n-            BinOp::NegatedEqualityTest => {\n-                let lhs = bin.lhs()?.syntax().text();\n-                let rhs = bin.rhs()?.syntax().text();\n-                Some(format!(\"{} == {}\", lhs, rhs))\n-            }\n-            _ => None,\n-        },\n-        Expr::PrefixExpr(pe) => match pe.op_kind()? {\n-            PrefixOp::Not => {\n-                let child = pe.expr()?.syntax().text();\n-                Some(String::from(child))\n-            }\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n /// Assist for applying demorgan's law\n ///\n /// This transforms expressions of the form `!l || !r` into `!(l && r)`.\n /// This also works with `&&`. This assist can only be applied with the cursor\n /// on either `||` or `&&`, with both operands being a negation of some kind.\n /// This means something of the form `!x` or `x != y`.\n pub(crate) fn apply_demorgan(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let expr = ctx.node_at_offset::<BinExpr>()?;\n+    let expr = ctx.node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n     let opposite_op = opposite_logic_op(op)?;\n@@ -69,6 +38,37 @@ pub(crate) fn apply_demorgan(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Ass\n     ctx.build()\n }\n \n+// Return the opposite text for a given logical operator, if it makes sense\n+fn opposite_logic_op(kind: ast::BinOp) -> Option<&'static str> {\n+    match kind {\n+        ast::BinOp::BooleanOr => Some(\"&&\"),\n+        ast::BinOp::BooleanAnd => Some(\"||\"),\n+        _ => None,\n+    }\n+}\n+\n+// This function tries to undo unary negation, or inequality\n+fn undo_negation(node: SyntaxNode) -> Option<String> {\n+    match ast::Expr::cast(node)? {\n+        ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n+            ast::BinOp::NegatedEqualityTest => {\n+                let lhs = bin.lhs()?.syntax().text();\n+                let rhs = bin.rhs()?.syntax().text();\n+                Some(format!(\"{} == {}\", lhs, rhs))\n+            }\n+            _ => None,\n+        },\n+        ast::Expr::PrefixExpr(pe) => match pe.op_kind()? {\n+            ast::PrefixOp::Not => {\n+                let child = pe.expr()?.syntax().text();\n+                Some(String::from(child))\n+            }\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}]}