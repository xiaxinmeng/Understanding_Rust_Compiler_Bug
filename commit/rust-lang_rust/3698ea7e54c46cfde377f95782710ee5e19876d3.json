{"sha": "3698ea7e54c46cfde377f95782710ee5e19876d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2OThlYTdlNTRjNDZjZmRlMzc3Zjk1NzgyNzEwZWU1ZTE5ODc2ZDM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-03-28T10:50:10Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-12T07:10:26Z"}, "message": "libsyntax: abstract most of the deriving boilerplate into a simpler(r) interface.\n\nPulls out many of the common patterns from the Eq and Clone deriving code (and\ninvents a few of its own), so that deriving instances are very easy to write\nfor a certain class of traits. (Basically, those which don't have parameters\nand where all methods only take arguments of type `&Self` and return either\n`Self` or types with no parameters.)", "tree": {"sha": "626552177fa333905788bb996b9d3941d5966e83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/626552177fa333905788bb996b9d3941d5966e83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3698ea7e54c46cfde377f95782710ee5e19876d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3698ea7e54c46cfde377f95782710ee5e19876d3", "html_url": "https://github.com/rust-lang/rust/commit/3698ea7e54c46cfde377f95782710ee5e19876d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3698ea7e54c46cfde377f95782710ee5e19876d3/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf34b31704257ef79cd0f9286314c10fa15b7bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf34b31704257ef79cd0f9286314c10fa15b7bf9", "html_url": "https://github.com/rust-lang/rust/commit/cf34b31704257ef79cd0f9286314c10fa15b7bf9"}], "stats": {"total": 957, "additions": 915, "deletions": 42}, "files": [{"sha": "390b72da3314b524b0cead6f588f559ee78a590c", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=3698ea7e54c46cfde377f95782710ee5e19876d3", "patch": "@@ -55,7 +55,8 @@ fn create_derived_clone_impl(cx: @ext_ctxt,\n         cx.ident_of(~\"Clone\"),\n     ];\n     let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path,\n+                        opt_vec::Empty, opt_vec::Empty)\n }\n // Creates a method from the given expression conforming to the signature of\n // the `clone` method.\n@@ -219,7 +220,7 @@ fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n     let mut subcalls = ~[];\n     for uint::range(0, struct_def.fields.len()) |i| {\n         // Create the expression for this field.\n-        let field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+        let field_ident = cx.ident_of(~\"__self_\" + i.to_str());\n         let field = build::mk_path(cx, span, ~[ field_ident ]);\n \n         // Call the substructure method.\n@@ -262,7 +263,7 @@ fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n         let mut subcalls = ~[];\n         for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n             // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n             let field = build::mk_path(cx, span, ~[ field_ident ]);\n \n             // Call the substructure method."}, {"sha": "df3536a3caef7a99bfa43b311bdb887d14b24267", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=3698ea7e54c46cfde377f95782710ee5e19876d3", "patch": "@@ -81,7 +81,8 @@ fn create_derived_decodable_impl(\n         generics,\n         methods,\n         trait_path,\n-        generic_ty_params\n+        generic_ty_params,\n+        opt_vec::Empty\n     )\n }\n "}, {"sha": "9776f484818ccb47bcf2d1653459402b85b378c8", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=3698ea7e54c46cfde377f95782710ee5e19876d3", "patch": "@@ -81,7 +81,8 @@ fn create_derived_encodable_impl(\n         generics,\n         methods,\n         trait_path,\n-        generic_ty_params\n+        generic_ty_params,\n+        opt_vec::Empty\n     )\n }\n \n@@ -306,7 +307,7 @@ fn expand_deriving_encodable_enum_method(\n         let variant_arg_len = variant_arg_count(cx, span, variant);\n         for uint::range(0, variant_arg_len) |j| {\n             // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n             let field = build::mk_path(cx, span, ~[ field_ident ]);\n \n             // Call the substructure method."}, {"sha": "0afb667c69ab9d521ff57da9cf095f0ebf8e7bcc", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=3698ea7e54c46cfde377f95782710ee5e19876d3", "patch": "@@ -131,7 +131,7 @@ fn create_derived_eq_impl(cx: @ext_ctxt,\n         cx.ident_of(~\"Eq\")\n     ];\n     let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty, [])\n }\n \n fn call_substructure_eq_method(cx: @ext_ctxt,\n@@ -338,13 +338,13 @@ fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n         let mut matching_body_expr = None;\n         for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n             // Create the expression for the other field.\n-            let other_field_ident = cx.ident_of(~\"__other\" + i.to_str());\n+            let other_field_ident = cx.ident_of(~\"__other_\" + i.to_str());\n             let other_field = build::mk_path(cx,\n                                              span,\n                                              ~[ other_field_ident ]);\n \n             // Create the expression for this field.\n-            let self_field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+            let self_field_ident = cx.ident_of(~\"__self_\" + i.to_str());\n             let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n \n             // Call the substructure method.\n@@ -456,10 +456,10 @@ fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n     // Create comparison expression, comparing each of the fields\n     let mut match_body = None;\n     for fields.eachi |i, _| {\n-        let other_field_ident = cx.ident_of(other_str + i.to_str());\n+        let other_field_ident = cx.ident_of(fmt!(\"%s_%u\", other_str, i));\n         let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n \n-        let self_field_ident = cx.ident_of(self_str + i.to_str());\n+        let self_field_ident = cx.ident_of(fmt!(\"%s_%u\", self_str, i));\n         let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n \n         call_substructure_eq_method(cx, span, self_field, other_field,"}, {"sha": "23a075ef001f66b8ae5e5c3837306de0bf0aaae2", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "added", "additions": 826, "deletions": 0, "changes": 826, "blob_url": "https://github.com/rust-lang/rust/blob/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=3698ea7e54c46cfde377f95782710ee5e19876d3", "patch": "@@ -0,0 +1,826 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Some code that abstracts away much of the boilerplate of writing\n+`deriving` instances for traits. Among other things it manages getting\n+access to the fields of the 4 different sorts of structs and enum\n+variants, as well as creating the method and impl ast instances.\n+\n+Supported features (fairly exhaustive):\n+- Methods taking any number of parameters of type `&Self`, including\n+  none other than `self`. (`MethodDef.nargs`)\n+- Methods returning `Self` or a non-parameterised type\n+  (e.g. `bool` or `core::cmp::Ordering`). (`MethodDef.output_type`)\n+- Generating `impl`s for types with type parameters\n+  (e.g. `Option<T>`), the parameters are automatically given the\n+  current trait as a bound.\n+- Additional bounds on the type parameters, e.g. the `Ord` instance\n+  requires an explicit `Eq` bound at the\n+  moment. (`TraitDef.additional_bounds`)\n+\n+(Key unsupported things: methods with arguments of non-`&Self` type,\n+traits with parameters, methods returning parameterised types, static\n+methods.)\n+\n+The most important thing for implementers is the `Substructure` and\n+`SubstructureFields` objects. The latter groups 3 possibilities of the\n+arguments:\n+\n+- `Struct`, when `Self` is a struct (including tuple structs, e.g\n+  `struct T(int, char)`).\n+- `EnumMatching`, when `Self` is an enum and all the arguments are the\n+  same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`)\n+- `EnumNonMatching` when `Self` is an enum and the arguments are not\n+  the same variant (e.g. `None`, `Some(1)` and `None`)\n+\n+In the first two cases, the values from the corresponding fields in\n+all the arguments are grouped together. In the `EnumNonMatching` case\n+this isn't possible (different variants have different fields), so the\n+fields are grouped by which argument they come from.\n+\n+All of the cases have `Option<ident>` in several places associated\n+with field `expr`s. This represents the name of the field it is\n+associated with. It is only not `None` when the associated field has\n+an identifier in the source code. For example, the `x`s in the\n+following snippet\n+\n+    struct A { x : int }\n+\n+    struct B(int);\n+\n+    enum C {\n+        C0(int),\n+        C1 { x: int }\n+    }\n+\n+The `int`s in `B` and `C0` don't have an identifier, so the\n+`Option<ident>`s would be `None` for them.\n+\n+# Examples\n+\n+The following simplified `Eq` is used for in-code examples:\n+\n+    trait Eq {\n+        fn eq(&self, other: &Self);\n+    }\n+    impl Eq for int {\n+        fn eq(&self, other: &int) -> bool {\n+            *self == *other\n+        }\n+    }\n+\n+Some examples of the values of `SubstructureFields` follow, using the\n+above `Eq`, `A`, `B` and `C`.\n+\n+## Structs\n+\n+When generating the `expr` for the `A` impl, the `SubstructureFields` is\n+\n+    Struct(~[(Some(<ident of x>),\n+             <expr for self.x>,\n+             ~[<expr for other.x])])\n+\n+For the `B` impl, called with `B(a)` and `B(b)`,\n+\n+    Struct(~[(None,\n+              <expr for a>\n+              ~[<expr for b>])])\n+\n+## Enums\n+\n+When generating the `expr` for a call with `self == C0(a)` and `other\n+== C0(b)`, the SubstructureFields is\n+\n+    EnumMatching(0, <ast::variant for C0>,\n+                 ~[None,\n+                   <expr for a>,\n+                   ~[<expr for b>]])\n+\n+For `C1 {x}` and `C1 {x}`,\n+\n+    EnumMatching(1, <ast::variant for C1>,\n+                 ~[Some(<ident of x>),\n+                   <expr for self.x>,\n+                   ~[<expr for other.x>]])\n+\n+For `C0(a)` and `C1 {x}` ,\n+\n+    EnumNonMatching(~[(0, <ast::variant for B0>,\n+                       ~[(None, <expr for a>)]),\n+                      (1, <ast::variant for B1>,\n+                       ~[(Some(<ident of x>),\n+                          <expr for other.x>)])])\n+\n+(and vice verse, but with the order of the outermost list flipped.)\n+\n+*/\n+\n+use core::prelude::*;\n+\n+use ast;\n+\n+use ast::{\n+    and, binop, deref, enum_def, expr, expr_match, ident, impure_fn,\n+    item, Generics, m_imm, meta_item, method, named_field, or, public,\n+    struct_def, sty_region, ty_rptr, ty_path, variant};\n+\n+use ast_util;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span,respan};\n+use opt_vec;\n+\n+pub fn expand_deriving_generic(cx: @ext_ctxt,\n+                               span: span,\n+                               _mitem: @meta_item,\n+                               in_items: ~[@item],\n+                               trait_def: &TraitDef) -> ~[@item] {\n+    let expand_enum: ExpandDerivingEnumDefFn =\n+        |cx, span, enum_def, type_ident, generics| {\n+        trait_def.expand_enum_def(cx, span, enum_def, type_ident, generics)\n+    };\n+    let expand_struct: ExpandDerivingStructDefFn =\n+        |cx, span, struct_def, type_ident, generics| {\n+        trait_def.expand_struct_def(cx, span, struct_def, type_ident, generics)\n+    };\n+\n+    expand_deriving(cx, span, in_items,\n+                    expand_struct,\n+                    expand_enum)\n+}\n+\n+pub struct TraitDef<'self> {\n+    /// Path of the trait\n+    path: ~[~str],\n+    /// Additional bounds required of any type parameters, other than\n+    /// the current trait\n+    additional_bounds: ~[~[~str]],\n+    methods: ~[MethodDef<'self>]\n+}\n+\n+pub struct MethodDef<'self> {\n+    /// name of the method\n+    name: ~str,\n+    /// The path of return type of the method, e.g. `~[~\"core\",\n+    /// ~\"cmp\", ~\"Eq\"]`. `None` for `Self`.\n+    output_type: Option<~[~str]>,\n+    /// Number of arguments other than `self` (all of type `&Self`)\n+    nargs: uint,\n+\n+    combine_substructure: CombineSubstructureFunc<'self>\n+}\n+\n+/// All the data about the data structure/method being derived upon.\n+pub struct Substructure<'self> {\n+    type_ident: ident,\n+    method_ident: ident,\n+    fields: &'self SubstructureFields\n+}\n+\n+/// A summary of the possible sets of fields. See above for details\n+/// and examples\n+pub enum SubstructureFields {\n+    /**\n+    Vec of `(field ident, self, [others])` where the field ident is\n+    the ident of the current field (`None` for all fields in tuple\n+    structs)\n+    */\n+    Struct(~[(Option<ident>, @expr, ~[@expr])]),\n+\n+    /**\n+    Matching variants of the enum: variant index, ast::variant,\n+    fields: `(field ident, self, [others])`, where the field ident is\n+    only non-`None` in the case of a struct variant.\n+    */\n+    EnumMatching(uint, variant, ~[(Option<ident>, @expr, ~[@expr])]),\n+\n+    /**\n+    non-matching variants of the enum, [(variant index, ast::variant,\n+    [field ident, fields])] (i.e. all fields for self are in the\n+    first tuple, for other1 are in the second tuple, etc.)\n+    */\n+    EnumNonMatching(~[(uint, variant, ~[(Option<ident>, @expr)])])\n+}\n+\n+\n+/**\n+Combine the values of all the fields together. The last argument is\n+all the fields of all the structures, see above for details.\n+*/\n+pub type CombineSubstructureFunc<'self> =\n+    &'self fn(@ext_ctxt, span, &Substructure) -> @expr;\n+\n+/**\n+Deal with non-matching enum variants, the argument is a list\n+representing each variant: (variant index, ast::variant instance,\n+[variant fields])\n+*/\n+pub type EnumNonMatchFunc<'self> =\n+    &'self fn(@ext_ctxt, span, ~[(uint, variant, ~[(Option<ident>, @expr)])]) -> @expr;\n+\n+\n+\n+impl<'self> TraitDef<'self> {\n+    fn create_derived_impl(&self, cx: @ext_ctxt, span: span,\n+                           type_ident: ident, generics: &Generics,\n+                           methods: ~[@method]) -> @item {\n+        let trait_path = build::mk_raw_path_global(\n+            span,\n+            do self.path.map |&s| { cx.ident_of(s) });\n+\n+        let additional_bounds = opt_vec::from(\n+            do self.additional_bounds.map |v| {\n+                do v.map |&s| { cx.ident_of(s) }\n+            });\n+        create_derived_impl(cx, span,\n+                            type_ident, generics,\n+                            methods, trait_path,\n+                            opt_vec::Empty,\n+                            additional_bounds)\n+    }\n+\n+    fn expand_struct_def(&self, cx: @ext_ctxt,\n+                         span: span,\n+                         struct_def: &struct_def,\n+                         type_ident: ident,\n+                         generics: &Generics)\n+    -> @item {\n+        let is_tuple = is_struct_tuple(struct_def);\n+\n+        let methods = do self.methods.map |method_def| {\n+            let body = if is_tuple {\n+                method_def.expand_struct_tuple_method_body(cx, span,\n+                                                           struct_def,\n+                                                           type_ident)\n+            } else {\n+                method_def.expand_struct_method_body(cx, span,\n+                                                     struct_def,\n+                                                     type_ident)\n+            };\n+\n+            method_def.create_method(cx, span, type_ident, generics, body)\n+        };\n+\n+        self.create_derived_impl(cx, span, type_ident, generics, methods)\n+    }\n+\n+    fn expand_enum_def(&self,\n+                       cx: @ext_ctxt, span: span,\n+                       enum_def: &enum_def,\n+                       type_ident: ident,\n+                       generics: &Generics) -> @item {\n+        let methods = do self.methods.map |method_def| {\n+            let body = method_def.expand_enum_method_body(cx, span,\n+                                                          enum_def,\n+                                                          type_ident);\n+\n+            method_def.create_method(cx, span, type_ident, generics, body)\n+        };\n+\n+        self.create_derived_impl(cx, span, type_ident, generics, methods)\n+    }\n+}\n+\n+impl<'self> MethodDef<'self> {\n+    fn call_substructure_method(&self,\n+                                cx: @ext_ctxt,\n+                                span: span,\n+                                type_ident: ident,\n+                                fields: &SubstructureFields)\n+        -> @expr {\n+        let substructure = Substructure {\n+            type_ident: type_ident,\n+            method_ident: cx.ident_of(self.name),\n+            fields: fields\n+        };\n+        (self.combine_substructure)(cx, span,\n+                                    &substructure)\n+    }\n+\n+    fn get_output_type_path(&self, cx: @ext_ctxt, span: span,\n+                              generics: &Generics, type_ident: ident) -> @ast::Path {\n+        match self.output_type {\n+            None => { // Self, add any type parameters\n+                let out_ty_params = do vec::build |push| {\n+                    for generics.ty_params.each |ty_param| {\n+                        push(build::mk_ty_path(cx, span, ~[ ty_param.ident ]));\n+                    }\n+                };\n+\n+                build::mk_raw_path_(span, ~[ type_ident ], out_ty_params)\n+            }\n+            Some(str_path) => {\n+                let p = do str_path.map |&s| { cx.ident_of(s) };\n+                build::mk_raw_path(span, p)\n+            }\n+        }\n+    }\n+\n+    fn create_method(&self, cx: @ext_ctxt, span: span,\n+                     type_ident: ident,\n+                     generics: &Generics, body: @expr) -> @method {\n+        // Create the `Self` type of the `other` parameters.\n+        let arg_path_type = create_self_type_with_params(cx,\n+                                                         span,\n+                                                         type_ident,\n+                                                         generics);\n+        let arg_type = ty_rptr(\n+            None,\n+            ast::mt { ty: arg_path_type, mutbl: m_imm }\n+        );\n+        let arg_type = @ast::Ty {\n+            id: cx.next_id(),\n+            node: arg_type,\n+            span: span,\n+        };\n+\n+        // create the arguments\n+        let other_idents = create_other_idents(cx, self.nargs);\n+        let args = do other_idents.map |&id| {\n+            build::mk_arg(cx, span, id, arg_type)\n+        };\n+\n+        let output_type = self.get_output_type_path(cx, span, generics, type_ident);\n+        let output_type = ty_path(output_type, cx.next_id());\n+        let output_type = @ast::Ty {\n+            id: cx.next_id(),\n+            node: output_type,\n+            span: span,\n+        };\n+\n+        let method_ident = cx.ident_of(self.name);\n+        let fn_decl = build::mk_fn_decl(args, output_type);\n+        let body_block = build::mk_simple_block(cx, span, body);\n+\n+        // Create the method.\n+        let self_ty = respan(span, sty_region(None, m_imm));\n+        @ast::method {\n+            ident: method_ident,\n+            attrs: ~[],\n+            generics: ast_util::empty_generics(),\n+            self_ty: self_ty,\n+            purity: impure_fn,\n+            decl: fn_decl,\n+            body: body_block,\n+            id: cx.next_id(),\n+            span: span,\n+            self_id: cx.next_id(),\n+            vis: public\n+        }\n+    }\n+\n+    /**\n+    ```\n+    #[deriving(Eq)]\n+    struct A(int, int);\n+\n+    // equivalent to:\n+\n+    impl Eq for A {\n+        fn eq(&self, __other_1: &A) -> bool {\n+            match *self {\n+                (ref self_1, ref self_2) => {\n+                    match *__other_1 {\n+                        (ref __other_1_1, ref __other_1_2) => {\n+                            self_1.eq(__other_1_1) && self_2.eq(__other_1_2)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    ```\n+    */\n+    fn expand_struct_tuple_method_body(&self,\n+                                           cx: @ext_ctxt,\n+                                               span: span,\n+                                               struct_def: &struct_def,\n+                                           type_ident: ident) -> @expr {\n+        let self_str = ~\"self\";\n+        let other_strs = create_other_strs(self.nargs);\n+        let num_fields = struct_def.fields.len();\n+\n+\n+        let fields = do struct_def.fields.mapi |i, _| {\n+            let other_fields = do other_strs.map |&other_str| {\n+                let other_field_ident = cx.ident_of(fmt!(\"%s_%u\", other_str, i));\n+                build::mk_path(cx, span, ~[ other_field_ident ])\n+            };\n+\n+            let self_field_ident = cx.ident_of(fmt!(\"%s_%u\", self_str, i));\n+            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+            (None, self_field, other_fields)\n+        };\n+\n+        let mut match_body = self.call_substructure_method(cx, span, type_ident, &Struct(fields));\n+\n+        let type_path = build::mk_raw_path(span, ~[type_ident]);\n+\n+        // create the matches from inside to out (i.e. other_{self.nargs} to other_1)\n+        for other_strs.each_reverse |&other_str| {\n+            match_body = create_deref_match(cx, span, type_path,\n+                                            other_str, num_fields,\n+                                            match_body)\n+        }\n+\n+        // create the match on self\n+        return create_deref_match(cx, span, type_path,\n+                                  ~\"self\", num_fields, match_body);\n+\n+        /**\n+        Creates a match expression against a tuple that needs to\n+        be dereferenced, but nothing else\n+\n+        ```\n+        match *`to_match` {\n+            (`to_match`_1, ..., `to_match`_`num_fields`) => `match_body`\n+        }\n+        ```\n+        */\n+        fn create_deref_match(cx: @ext_ctxt,\n+                              span: span,\n+                              type_path: @ast::Path,\n+                              to_match: ~str,\n+                              num_fields: uint,\n+                              match_body: @expr) -> @expr {\n+            let match_subpats = create_subpatterns(cx, span, to_match, num_fields);\n+            let match_arm = ast::arm {\n+                pats: ~[ build::mk_pat_enum(cx, span, type_path, match_subpats) ],\n+                guard: None,\n+                body: build::mk_simple_block(cx, span, match_body),\n+            };\n+\n+            let deref_expr = build::mk_unary(cx, span, deref,\n+                                             build::mk_path(cx, span,\n+                                                            ~[ cx.ident_of(to_match)]));\n+            let match_expr = build::mk_expr(cx, span, expr_match(deref_expr, ~[match_arm]));\n+\n+            match_expr\n+        }\n+    }\n+\n+    /**\n+    ```\n+    #[deriving(Eq)]\n+    struct A { x: int, y: int }\n+\n+    // equivalent to:\n+\n+    impl Eq for A {\n+        fn eq(&self, __other_1: &A) -> bool {\n+            self.x.eq(&__other_1.x) &&\n+                self.y.eq(&__other_1.y)\n+        }\n+    }\n+    ```\n+    */\n+    fn expand_struct_method_body(&self,\n+                                     cx: @ext_ctxt,\n+                                     span: span,\n+                                     struct_def: &struct_def,\n+                                     type_ident: ident)\n+        -> @expr {\n+        let self_ident = cx.ident_of(~\"self\");\n+        let other_idents = create_other_idents(cx, self.nargs);\n+\n+        let fields = do struct_def.fields.map |struct_field| {\n+            match struct_field.node.kind {\n+                named_field(ident, _, _) => {\n+                    // Create the accessor for this field in the other args.\n+                    let other_fields = do other_idents.map |&id| {\n+                        build::mk_access(cx, span, ~[id], ident)\n+                    };\n+                    let other_field_refs = do other_fields.map |&other_field| {\n+                        build::mk_addr_of(cx, span, other_field)\n+                    };\n+\n+                    // Create the accessor for this field in self.\n+                    let self_field =\n+                        build::mk_access(\n+                            cx, span,\n+                            ~[ self_ident ],\n+                            ident);\n+\n+                    (Some(ident), self_field, other_field_refs)\n+                }\n+                unnamed_field => {\n+                    cx.span_unimpl(span, ~\"unnamed fields with `deriving_generic`\");\n+                }\n+            }\n+        };\n+\n+        self.call_substructure_method(cx, span, type_ident, &Struct(fields))\n+    }\n+\n+    /**\n+    ```\n+    #[deriving(Eq)]\n+    enum A {\n+        A1\n+        A2(int)\n+    }\n+\n+    // is equivalent to\n+\n+    impl Eq for A {\n+        fn eq(&self, __other_1: &A) {\n+            match *self {\n+                A1 => match *__other_1 {\n+                    A1 => true,\n+                    A2(ref __other_1_1) => false\n+                },\n+                A2(self_1) => match *__other_1 {\n+                    A1 => false,\n+                    A2(ref __other_1_1) => self_1.eq(__other_1_1)\n+                }\n+            }\n+        }\n+    }\n+    ```\n+    */\n+    fn expand_enum_method_body(&self,\n+                               cx: @ext_ctxt,\n+                               span: span,\n+                               enum_def: &enum_def,\n+                               type_ident: ident)\n+        -> @expr {\n+        self.build_enum_match(cx, span, enum_def, type_ident, ~[])\n+    }\n+\n+\n+    /**\n+    Creates the nested matches for an enum definition, i.e.\n+\n+    ```\n+    match self {\n+       Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n+       Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n+       ...\n+    }\n+    ```\n+\n+    It acts in the most naive way, so every branch (and subbranch,\n+    subsubbranch, etc) exists, not just the ones where all the variants in\n+    the tree are the same. Hopefully the optimisers get rid of any\n+    repetition, otherwise derived methods with many Self arguments will be\n+    exponentially large.\n+    */\n+    fn build_enum_match(&self,\n+                        cx: @ext_ctxt, span: span,\n+                        enum_def: &enum_def,\n+                        type_ident: ident,\n+                        matches_so_far: ~[(uint, variant,\n+                                           ~[(Option<ident>, @expr)])]) -> @expr {\n+        if matches_so_far.len() == self.nargs + 1 {\n+            // we've matched against all arguments, so make the final\n+            // expression at the bottom of the match tree\n+            match matches_so_far {\n+                [] => cx.bug(~\"no self match on an enum in `deriving_generic`\"),\n+                _ => {\n+                    // we currently have a vec of vecs, where each\n+                    // subvec is the fields of one of the arguments,\n+                    // but if the variants all match, we want this as\n+                    // vec of tuples, where each tuple represents a\n+                    // field.\n+\n+                    // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+                    // let (variant_index, ref self_vec) = matches_so_far[0];\n+                    let (variant_index, variant, self_vec) = match matches_so_far[0] {\n+                        (i, v, ref s) => (i, v, s)\n+                    };\n+\n+                    let substructure;\n+\n+                    // most arms don't have matching variants, so do a\n+                    // quick check to see if they match (even though\n+                    // this means iterating twice) instead of being\n+                    // optimistic and doing a pile of allocations etc.\n+                    if matches_so_far.all(|&(v_i, _, _)| v_i == variant_index) {\n+                        let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n+\n+                        for matches_so_far.tail().each |&(_, _, other_fields)| {\n+                            for other_fields.eachi |i, &(_, other_field)| {\n+                                enum_matching_fields[i].push(other_field);\n+                            }\n+                        }\n+                        let field_tuples =\n+                            do vec::map2(*self_vec,\n+                                         enum_matching_fields) |&(id, self_f), &other| {\n+                            (id, self_f, other)\n+                        };\n+                        substructure = EnumMatching(variant_index, variant, field_tuples);\n+                    } else {\n+                        substructure = EnumNonMatching(matches_so_far);\n+                    }\n+                    self.call_substructure_method(cx, span, type_ident, &substructure)\n+                }\n+            }\n+\n+        } else {  // there are still matches to create\n+            let (current_match_ident, current_match_str) = if matches_so_far.is_empty() {\n+                (cx.ident_of(~\"self\"), ~\"__self\")\n+            } else {\n+                let s = fmt!(\"__other_%u\", matches_so_far.len() - 1);\n+                (cx.ident_of(s), s)\n+            };\n+\n+            let mut arms = ~[];\n+\n+            // this is used as a stack\n+            let mut matches_so_far = matches_so_far;\n+\n+            // create an arm matching on each variant\n+            for enum_def.variants.eachi |index, variant| {\n+                let pattern = create_enum_variant_pattern(cx, span,\n+                                                          variant,\n+                                                          current_match_str);\n+\n+                let idents = do vec::build |push| {\n+                    for each_variant_arg_ident(cx, span, variant) |i, field_id| {\n+                        let id = cx.ident_of(fmt!(\"%s_%u\", current_match_str, i));\n+                        push((field_id, build::mk_path(cx, span, ~[ id ])));\n+                    }\n+                };\n+\n+\n+                matches_so_far.push((index, *variant, idents));\n+                let arm_expr = self.build_enum_match(cx, span,\n+                                                     enum_def,\n+                                                     type_ident,\n+                                                     matches_so_far);\n+                matches_so_far.pop();\n+\n+                let arm_block = build::mk_simple_block(cx, span, arm_expr);\n+                let arm = ast::arm {\n+                    pats: ~[ pattern ],\n+                    guard: None,\n+                    body: arm_block\n+                };\n+                arms.push(arm);\n+            }\n+\n+            let deref_expr = build::mk_unary(cx, span, deref,\n+                                             build::mk_path(cx, span,\n+                                                            ~[ current_match_ident ]));\n+            let match_expr = build::mk_expr(cx, span,\n+                                            expr_match(deref_expr, arms));\n+\n+            match_expr\n+        }\n+    }\n+}\n+\n+/// Create variable names (as strings) to refer to the non-self\n+/// parameters\n+fn create_other_strs(n: uint) -> ~[~str] {\n+    do vec::build |push| {\n+        for uint::range(0, n) |i| {\n+            push(fmt!(\"__other_%u\", i));\n+        }\n+    }\n+}\n+/// Like `create_other_strs`, but returns idents for the strings\n+fn create_other_idents(cx: @ext_ctxt, n: uint) -> ~[ident] {\n+    do create_other_strs(n).map |&s| {\n+        cx.ident_of(s)\n+    }\n+}\n+\n+\n+\n+/* helpful premade recipes */\n+\n+/**\n+Fold the fields. `use_foldl` controls whether this is done\n+left-to-right (`true`) or right-to-left (`false`).\n+*/\n+pub fn cs_fold(use_foldl: bool,\n+               f: &fn(@ext_ctxt, span,\n+                      old: @expr,\n+                      self_f: @expr, other_fs: ~[@expr]) -> @expr,\n+               base: @expr,\n+               enum_nonmatch_f: EnumNonMatchFunc,\n+               cx: @ext_ctxt, span: span,\n+               substructure: &Substructure) -> @expr {\n+    match *substructure.fields {\n+        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+            if use_foldl {\n+                do all_fields.foldl(base) |&old, &(_, self_f, other_fs)| {\n+                    f(cx, span, old, self_f, other_fs)\n+                }\n+            } else {\n+                do all_fields.foldr(base) |&(_, self_f, other_fs), old| {\n+                    f(cx, span, old, self_f, other_fs)\n+                }\n+            }\n+        },\n+        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span, all_enums)\n+    }\n+}\n+\n+\n+/**\n+Call the method that is being derived on all the fields, and then\n+process the collected results. i.e.\n+\n+```\n+f(cx, span, ~[self_1.method(__other_1_1, __other_2_1),\n+              self_2.method(__other_1_2, __other_2_2)])\n+```\n+*/\n+pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n+                      enum_nonmatch_f: EnumNonMatchFunc,\n+                      cx: @ext_ctxt, span: span,\n+                      substructure: &Substructure) -> @expr {\n+    match *substructure.fields {\n+        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+            // call self_n.method(other_1_n, other_2_n, ...)\n+            let called = do all_fields.map |&(_, self_field, other_fields)| {\n+                build::mk_method_call(cx, span,\n+                                      self_field,\n+                                      substructure.method_ident,\n+                                      other_fields)\n+            };\n+\n+            f(cx, span, called)\n+        },\n+        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span, all_enums)\n+    }\n+}\n+\n+/**\n+Fold together the results of calling the derived method on all the\n+fields. `use_foldl` controls whether this is done left-to-right\n+(`true`) or right-to-left (`false`).\n+*/\n+pub fn cs_same_method_fold(use_foldl: bool,\n+                           f: &fn(@ext_ctxt, span, @expr, @expr) -> @expr,\n+                           base: @expr,\n+                           enum_nonmatch_f: EnumNonMatchFunc,\n+                           cx: @ext_ctxt, span: span,\n+                           substructure: &Substructure) -> @expr {\n+    cs_same_method(\n+        |cx, span, vals| {\n+            if use_foldl {\n+                do vals.foldl(base) |&old, &new| {\n+                    f(cx, span, old, new)\n+                }\n+            } else {\n+                do vals.foldr(base) |&new, old| {\n+                    f(cx, span, old, new)\n+                }\n+            }\n+        },\n+        enum_nonmatch_f,\n+        cx, span, substructure)\n+\n+}\n+\n+/**\n+Use a given binop to combine the result of calling the derived method\n+on all the fields.\n+*/\n+pub fn cs_binop(binop: binop, base: @expr,\n+                enum_nonmatch_f: EnumNonMatchFunc,\n+                cx: @ext_ctxt, span: span,\n+                substructure: &Substructure) -> @expr {\n+    cs_same_method_fold(\n+        true, // foldl is good enough\n+        |cx, span, old, new| {\n+            build::mk_binary(cx, span,\n+                             binop,\n+                             old, new)\n+\n+        },\n+        base,\n+        enum_nonmatch_f,\n+        cx, span, substructure)\n+}\n+\n+/// cs_binop with binop == or\n+pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n+             cx: @ext_ctxt, span: span,\n+             substructure: &Substructure) -> @expr {\n+    cs_binop(or, build::mk_bool(cx, span, false),\n+             enum_nonmatch_f,\n+             cx, span, substructure)\n+}\n+/// cs_binop with binop == and\n+pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n+              cx: @ext_ctxt, span: span,\n+              substructure: &Substructure) -> @expr {\n+    cs_binop(and, build::mk_bool(cx, span, true),\n+             enum_nonmatch_f,\n+             cx, span, substructure)\n+}"}, {"sha": "75215b90eb0da715bceebe8f105fb73f110fb40f", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=3698ea7e54c46cfde377f95782710ee5e19876d3", "patch": "@@ -56,7 +56,8 @@ fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n         cx.ident_of(~\"IterBytes\")\n     ];\n     let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path,\n+                        opt_vec::Empty, opt_vec::Empty)\n }\n \n // Creates a method from the given set of statements conforming to the\n@@ -230,7 +231,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n         // as well.\n         for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n             // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n             let field = build::mk_path(cx, span, ~[ field_ident ]);\n \n             // Call the substructure method."}, {"sha": "1241d4fa711392eb9cad59456b70fe2130245791", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698ea7e54c46cfde377f95782710ee5e19876d3/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=3698ea7e54c46cfde377f95782710ee5e19876d3", "patch": "@@ -24,30 +24,32 @@ use ast::{tuple_variant_kind};\n use ast::{ty_path, unnamed_field, variant};\n use ext::base::ext_ctxt;\n use ext::build;\n-use codemap::span;\n+use codemap::{span, respan};\n use parse::token::special_idents::clownshoes_extensions;\n use opt_vec;\n \n use core::uint;\n \n-pub mod clone;\n pub mod eq;\n+pub mod clone;\n pub mod iter_bytes;\n pub mod encodable;\n pub mod decodable;\n \n-type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n-                                                  span,\n-                                                  x: &struct_def,\n-                                                  ident,\n-                                                  y: &Generics)\n-                                               -> @item;\n-type ExpandDerivingEnumDefFn<'self> = &'self fn(@ext_ctxt,\n-                                                span,\n-                                                x: &enum_def,\n-                                                ident,\n-                                                y: &Generics)\n-                                             -> @item;\n+pub mod generic;\n+\n+pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n+                                                       span,\n+                                                       x: &struct_def,\n+                                                       ident,\n+                                                       y: &Generics)\n+                                                 -> @item;\n+pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ext_ctxt,\n+                                                    span,\n+                                                    x: &enum_def,\n+                                                    ident,\n+                                                    y: &Generics)\n+                                                 -> @item;\n \n pub fn expand_meta_deriving(cx: @ext_ctxt,\n                             _span: span,\n@@ -72,10 +74,10 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                     meta_list(tname, _) |\n                     meta_word(tname) => {\n                         match *tname {\n+                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n+                                                            titem, in_items),\n                             ~\"Clone\" => clone::expand_deriving_clone(cx,\n                                 titem.span, titem, in_items),\n-                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n-                                titem, in_items),\n                             ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n                                 titem.span, titem, in_items),\n                             ~\"Encodable\" => encodable::expand_deriving_encodable(cx,\n@@ -126,9 +128,19 @@ pub fn expand_deriving(cx: @ext_ctxt,\n }\n \n fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n+    let doc_attr = respan(span,\n+                          ast::lit_str(@~\"Automatically derived.\"));\n+    let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));\n+    let doc_attr = ast::attribute_ {\n+        style: ast::attr_outer,\n+        value: @doc_attr,\n+        is_sugared_doc: false\n+    };\n+    let doc_attr = respan(span, doc_attr);\n+\n     @ast::item {\n         ident: clownshoes_extensions,\n-        attrs: ~[],\n+        attrs: ~[doc_attr],\n         id: cx.next_id(),\n         node: item,\n         vis: public,\n@@ -164,14 +176,17 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n                            generics: &Generics,\n                            methods: &[@method],\n                            trait_path: @ast::Path,\n-                           mut impl_ty_params: opt_vec::OptVec<ast::TyParam>)\n+                           mut impl_ty_params: opt_vec::OptVec<ast::TyParam>,\n+                           bounds_paths: opt_vec::OptVec<~[ident]>)\n                         -> @item {\n     /*!\n      *\n      * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n      * 'z, A, ..., Z>`, creates an impl like:\n      *\n-     *      impl<'a, ..., 'z, A:Tr, ..., Z: Tr> Tr for T<A, ..., Z> { ... }\n+     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n+     *\n+     * where B1, B2, ... are the bounds given by `bounds_paths`.\n      *\n      * FIXME(#5090): Remove code duplication between this and the\n      * code in auto_encode.rs\n@@ -182,16 +197,21 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n         build::mk_lifetime(cx, l.span, l.ident)\n     });\n \n-    // Create the reference to the trait.\n-    let trait_ref = build::mk_trait_ref_(cx, trait_path);\n-\n     // Create the type parameters.\n     for generics.ty_params.each |ty_param| {\n-        let bounds = @opt_vec::with(\n-            build::mk_trait_ty_param_bound_(cx, trait_path)\n-        );\n-        impl_ty_params.push(build::mk_ty_param(cx, ty_param.ident, bounds));\n-    };\n+        let mut bounds = do bounds_paths.map |&bound_path| {\n+            build::mk_trait_ty_param_bound_global(cx, span, bound_path)\n+        };\n+\n+        let this_trait_bound =\n+            build::mk_trait_ty_param_bound_(cx, trait_path);\n+        bounds.push(this_trait_bound);\n+\n+        impl_ty_params.push(build::mk_ty_param(cx, ty_param.ident, @bounds));\n+    }\n+\n+    // Create the reference to the trait.\n+    let trait_ref = build::mk_trait_ref_(cx, trait_path);\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,\n@@ -216,8 +236,8 @@ pub fn create_subpatterns(cx: @ext_ctxt,\n     let mut subpats = ~[];\n     for uint::range(0, n) |_i| {\n         // Create the subidentifier.\n-        let index = subpats.len().to_str();\n-        let ident = cx.ident_of(prefix + index);\n+        let index = subpats.len();\n+        let ident = cx.ident_of(fmt!(\"%s_%u\", prefix, index));\n \n         // Create the subpattern.\n         let subpath = build::mk_raw_path(span, ~[ ident ]);\n@@ -287,6 +307,29 @@ pub fn variant_arg_count(_cx: @ext_ctxt, _span: span, variant: &variant) -> uint\n     }\n }\n \n+/// Iterate through the idents of the variant arguments. The field is\n+/// unnamed (i.e. it's not a struct-like enum), then `None`.\n+pub fn each_variant_arg_ident(_cx: @ext_ctxt, _span: span,\n+                              variant: &variant, it: &fn(uint, Option<ident>) -> bool) {\n+    match variant.node.kind {\n+        tuple_variant_kind(ref args) => {\n+            for uint::range(0, args.len()) |i| {\n+                if !it(i, None) { break }\n+            }\n+        }\n+        struct_variant_kind(ref struct_def) => {\n+            for struct_def.fields.eachi |i, f| {\n+                let id = match f.node.kind {\n+                    named_field(ident, _, _) => Some(ident),\n+                    unnamed_field => None\n+                };\n+                if !it(i, id) { break }\n+            }\n+        }\n+    }\n+}\n+\n+\n pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n                                span: span,\n                                arms: ~[ ast::arm ])"}]}