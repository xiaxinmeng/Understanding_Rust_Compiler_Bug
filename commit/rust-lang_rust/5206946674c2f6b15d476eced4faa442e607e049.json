{"sha": "5206946674c2f6b15d476eced4faa442e607e049", "node_id": "C_kwDOAAsO6NoAKDUyMDY5NDY2NzRjMmY2YjE1ZDQ3NmVjZWQ0ZmFhNDQyZTYwN2UwNDk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-20T16:48:47Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-20T16:48:47Z"}, "message": "fix: Partially fix `ide_db::search` for crate roots", "tree": {"sha": "7e5d82fb7315e659264e62662e9fe828675e9a0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e5d82fb7315e659264e62662e9fe828675e9a0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5206946674c2f6b15d476eced4faa442e607e049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5206946674c2f6b15d476eced4faa442e607e049", "html_url": "https://github.com/rust-lang/rust/commit/5206946674c2f6b15d476eced4faa442e607e049", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5206946674c2f6b15d476eced4faa442e607e049/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ca3834c9f15027fa68a0d0f70f7abf75a26d750", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca3834c9f15027fa68a0d0f70f7abf75a26d750", "html_url": "https://github.com/rust-lang/rust/commit/2ca3834c9f15027fa68a0d0f70f7abf75a26d750"}], "stats": {"total": 152, "additions": 118, "deletions": 34}, "files": [{"sha": "08d3bc93ffe19a229ddf8ff1245d5e2a09c92096", "filename": "crates/base_db/src/input.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fbase_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fbase_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Finput.rs?ref=5206946674c2f6b15d476eced4faa442e607e049", "patch": "@@ -97,6 +97,10 @@ impl CrateName {\n     pub fn normalize_dashes(name: &str) -> CrateName {\n         Self(SmolStr::new(name.replace('-', \"_\")))\n     }\n+\n+    pub fn as_smol_str(&self) -> &SmolStr {\n+        &self.0\n+    }\n }\n \n impl fmt::Display for CrateName {"}, {"sha": "054b8f297b5fb0b666441562c05e8687a64c380e", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=5206946674c2f6b15d476eced4faa442e607e049", "patch": "@@ -378,7 +378,22 @@ struct Foo;\n     fn test_hl_self_in_crate_root() {\n         check(\n             r#\"\n-use self$0;\n+use crate$0;\n+  //^^^^^\n+use self;\n+  //^^^^\n+mod __ {\n+    use super;\n+      //^^^^^\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+//- /main.rs crate:main deps:lib\n+use lib$0;\n+  //^^^\n+//- /lib.rs crate:lib\n \"#,\n         );\n     }"}, {"sha": "949c6dc686bb023581352bc26b95311753148d46", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=5206946674c2f6b15d476eced4faa442e607e049", "patch": "@@ -756,7 +756,7 @@ use self$0;\n             expect![[r#\"\n                 Module FileId(0) 0..10\n \n-                (no references)\n+                FileId(0) 4..8\n             \"#]],\n         );\n     }"}, {"sha": "dcfc2b7bfc7a5f5af72c820e58e98ba5ef0f911a", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 97, "deletions": 32, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5206946674c2f6b15d476eced4faa442e607e049/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=5206946674c2f6b15d476eced4faa442e607e049", "patch": "@@ -4,7 +4,7 @@\n //! get a super-set of matches. Then, we we confirm each match using precise\n //! name resolution.\n \n-use std::{convert::TryInto, mem};\n+use std::{convert::TryInto, mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{\n@@ -376,32 +376,63 @@ impl<'a> FindUsages<'a> {\n             }\n         };\n \n-        let name = self.def.name(sema.db).or_else(|| {\n-            self.include_self_kw_refs.as_ref().and_then(|ty| {\n-                ty.as_adt()\n-                    .map(|adt| adt.name(self.sema.db))\n-                    .or_else(|| ty.as_builtin().map(|builtin| builtin.name()))\n-            })\n-        });\n-        let name = match name {\n-            Some(name) => name.to_smol_str(),\n+        let name = match self.def {\n+            // special case crate modules as these do not have a proper name\n+            Definition::Module(module) if module.crate_root(self.sema.db) == module => {\n+                // FIXME: This assumes the crate name is always equal to its display name when it really isn't\n+                module\n+                    .krate()\n+                    .display_name(self.sema.db)\n+                    .map(|crate_name| crate_name.crate_name().as_smol_str().clone())\n+            }\n+            _ => {\n+                let self_kw_refs = || {\n+                    self.include_self_kw_refs.as_ref().and_then(|ty| {\n+                        ty.as_adt()\n+                            .map(|adt| adt.name(self.sema.db))\n+                            .or_else(|| ty.as_builtin().map(|builtin| builtin.name()))\n+                    })\n+                };\n+                self.def.name(sema.db).or_else(self_kw_refs).map(|it| it.to_smol_str())\n+            }\n+        };\n+        let name = match &name {\n+            Some(s) => s.as_str(),\n             None => return,\n         };\n-        let name = name.as_str();\n-\n-        for (file_id, search_range) in search_scope {\n-            let text = sema.db.file_text(file_id);\n-            let search_range =\n-                search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n-\n-            let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-            for (idx, _) in text.match_indices(name) {\n+        // these can't be closures because rust infers the lifetimes wrong ...\n+        fn match_indices<'a>(\n+            text: &'a str,\n+            name: &'a str,\n+            search_range: TextRange,\n+        ) -> impl Iterator<Item = TextSize> + 'a {\n+            text.match_indices(name).filter_map(move |(idx, _)| {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n-                    continue;\n+                    return None;\n                 }\n+                Some(offset)\n+            })\n+        }\n+        fn scope_files<'a>(\n+            sema: &'a Semantics<RootDatabase>,\n+            scope: &'a SearchScope,\n+        ) -> impl Iterator<Item = (Arc<String>, FileId, TextRange)> + 'a {\n+            scope.entries.iter().map(|(&file_id, &search_range)| {\n+                let text = sema.db.file_text(file_id);\n+                let search_range =\n+                    search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n+\n+                (text, file_id, search_range)\n+            })\n+        }\n+\n+        for (text, file_id, search_range) in scope_files(sema, &search_scope) {\n+            let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n+            // Search for occurrences of the items name\n+            for offset in match_indices(&text, name, search_range) {\n                 for name in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                     if match name {\n                         ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n@@ -412,13 +443,9 @@ impl<'a> FindUsages<'a> {\n                     }\n                 }\n             }\n+            // Search for occurrences of the `Self` referring to our type\n             if let Some(self_ty) = &self.include_self_kw_refs {\n-                for (idx, _) in text.match_indices(\"Self\") {\n-                    let offset: TextSize = idx.try_into().unwrap();\n-                    if !search_range.contains_inclusive(offset) {\n-                        continue;\n-                    }\n-\n+                for offset in match_indices(&text, \"Self\", search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n                             return;\n@@ -428,6 +455,37 @@ impl<'a> FindUsages<'a> {\n             }\n         }\n \n+        // Search for `super` and `crate` resolving to our module\n+        match self.def {\n+            Definition::Module(module) => {\n+                let scope = search_scope.intersection(&SearchScope::module(self.sema.db, module));\n+\n+                let is_crate_root = module.crate_root(self.sema.db) == module;\n+\n+                for (text, file_id, search_range) in scope_files(sema, &scope) {\n+                    let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n+\n+                    for offset in match_indices(&text, \"super\", search_range) {\n+                        for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n+                            if self.found_name_ref(&name_ref, sink) {\n+                                return;\n+                            }\n+                        }\n+                    }\n+                    if is_crate_root {\n+                        for offset in match_indices(&text, \"crate\", search_range) {\n+                            for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n+                                if self.found_name_ref(&name_ref, sink) {\n+                                    return;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+\n         // search for module `self` references in our module's definition source\n         match self.def {\n             Definition::Module(module) if self.search_self_mod => {\n@@ -439,18 +497,25 @@ impl<'a> FindUsages<'a> {\n                     ModuleSource::SourceFile(_) => (file_id, None),\n                 };\n \n+                let search_range = if let Some(&range) = search_scope.entries.get(&file_id) {\n+                    match (range, search_range) {\n+                        (None, range) | (range, None) => range,\n+                        (Some(range), Some(search_range)) => match range.intersect(search_range) {\n+                            Some(range) => Some(range),\n+                            None => return,\n+                        },\n+                    }\n+                } else {\n+                    return;\n+                };\n+\n                 let text = sema.db.file_text(file_id);\n                 let search_range =\n                     search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n \n                 let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-                for (idx, _) in text.match_indices(\"self\") {\n-                    let offset: TextSize = idx.try_into().unwrap();\n-                    if !search_range.contains_inclusive(offset) {\n-                        continue;\n-                    }\n-\n+                for offset in match_indices(&text, \"self\", search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_module_name_ref(&name_ref, sink) {\n                             return;"}]}