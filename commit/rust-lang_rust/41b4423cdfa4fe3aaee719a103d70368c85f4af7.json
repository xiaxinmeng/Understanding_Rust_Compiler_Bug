{"sha": "41b4423cdfa4fe3aaee719a103d70368c85f4af7", "node_id": "C_kwDOAAsO6NoAKDQxYjQ0MjNjZGZhNGZlM2FhZWU3MTlhMTAzZDcwMzY4Yzg1ZjRhZjc", "commit": {"author": {"name": "Hans Kratz", "email": "hans@appfour.com", "date": "2022-02-28T11:53:12Z"}, "committer": {"name": "Hans Kratz", "email": "hans@appfour.com", "date": "2022-03-04T12:47:36Z"}, "message": "Integrate macos x86-64 remove_dir_all() impl. Step 1: remove", "tree": {"sha": "025d1022e76fde7df53fe56d01147b0587fbef15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/025d1022e76fde7df53fe56d01147b0587fbef15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41b4423cdfa4fe3aaee719a103d70368c85f4af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41b4423cdfa4fe3aaee719a103d70368c85f4af7", "html_url": "https://github.com/rust-lang/rust/commit/41b4423cdfa4fe3aaee719a103d70368c85f4af7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41b4423cdfa4fe3aaee719a103d70368c85f4af7/comments", "author": {"login": "hkratz", "id": 3736990, "node_id": "MDQ6VXNlcjM3MzY5OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3736990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkratz", "html_url": "https://github.com/hkratz", "followers_url": "https://api.github.com/users/hkratz/followers", "following_url": "https://api.github.com/users/hkratz/following{/other_user}", "gists_url": "https://api.github.com/users/hkratz/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkratz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkratz/subscriptions", "organizations_url": "https://api.github.com/users/hkratz/orgs", "repos_url": "https://api.github.com/users/hkratz/repos", "events_url": "https://api.github.com/users/hkratz/events{/privacy}", "received_events_url": "https://api.github.com/users/hkratz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hkratz", "id": 3736990, "node_id": "MDQ6VXNlcjM3MzY5OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3736990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkratz", "html_url": "https://github.com/hkratz", "followers_url": "https://api.github.com/users/hkratz/followers", "following_url": "https://api.github.com/users/hkratz/following{/other_user}", "gists_url": "https://api.github.com/users/hkratz/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkratz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkratz/subscriptions", "organizations_url": "https://api.github.com/users/hkratz/orgs", "repos_url": "https://api.github.com/users/hkratz/repos", "events_url": "https://api.github.com/users/hkratz/events{/privacy}", "received_events_url": "https://api.github.com/users/hkratz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42733307169708d78f4373c32ecfd4019c279ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42733307169708d78f4373c32ecfd4019c279ca", "html_url": "https://github.com/rust-lang/rust/commit/e42733307169708d78f4373c32ecfd4019c279ca"}], "stats": {"total": 118, "additions": 0, "deletions": 118}, "files": [{"sha": "d83160db2f23c3a19d0e0b3f67af99712dc349ba", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/41b4423cdfa4fe3aaee719a103d70368c85f4af7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b4423cdfa4fe3aaee719a103d70368c85f4af7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=41b4423cdfa4fe3aaee719a103d70368c85f4af7", "patch": "@@ -1482,124 +1482,6 @@ mod remove_dir_impl {\n     pub use crate::sys_common::fs::remove_dir_all;\n }\n \n-// Dynamically choose implementation Macos x86-64: modern for 10.10+, fallback for older versions\n-#[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n-mod remove_dir_impl {\n-    use super::{cstr, lstat, Dir, InnerReadDir, ReadDir};\n-    use crate::ffi::CStr;\n-    use crate::io;\n-    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n-    use crate::os::unix::prelude::{OwnedFd, RawFd};\n-    use crate::path::{Path, PathBuf};\n-    use crate::sync::Arc;\n-    use crate::sys::weak::weak;\n-    use crate::sys::{cvt, cvt_r};\n-    use libc::{c_char, c_int, DIR};\n-\n-    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n-        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n-        let fd = cvt_r(|| unsafe {\n-            openat.get().unwrap()(\n-                parent_fd.unwrap_or(libc::AT_FDCWD),\n-                p.as_ptr(),\n-                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n-            )\n-        })?;\n-        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n-    }\n-\n-    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n-        weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n-        let ptr = unsafe { fdopendir.get().unwrap()(dir_fd.as_raw_fd()) };\n-        if ptr.is_null() {\n-            return Err(io::Error::last_os_error());\n-        }\n-        let dirp = Dir(ptr);\n-        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n-        let new_parent_fd = dir_fd.into_raw_fd();\n-        // a valid root is not needed because we do not call any functions involving the full path\n-        // of the DirEntrys.\n-        let dummy_root = PathBuf::new();\n-        Ok((\n-            ReadDir {\n-                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n-                end_of_stream: false,\n-            },\n-            new_parent_fd,\n-        ))\n-    }\n-\n-    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n-        weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n-\n-        let pcstr = cstr(p)?;\n-\n-        // entry is expected to be a directory, open as such\n-        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n-\n-        // open the directory passing ownership of the fd\n-        let (dir, fd) = fdreaddir(fd)?;\n-        for child in dir {\n-            let child = child?;\n-            match child.entry.d_type {\n-                libc::DT_DIR => {\n-                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                }\n-                libc::DT_UNKNOWN => {\n-                    match cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })\n-                    {\n-                        // type unknown - try to unlink\n-                        Err(err) if err.raw_os_error() == Some(libc::EPERM) => {\n-                            // if the file is a directory unlink fails with EPERM\n-                            remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n-                        }\n-                        result => {\n-                            result?;\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // not a directory -> unlink\n-                    cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })?;\n-                }\n-            }\n-        }\n-\n-        // unlink the directory after removing its contents\n-        cvt(unsafe {\n-            unlinkat.get().unwrap()(\n-                parent_fd.unwrap_or(libc::AT_FDCWD),\n-                pcstr.as_ptr(),\n-                libc::AT_REMOVEDIR,\n-            )\n-        })?;\n-        Ok(())\n-    }\n-\n-    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n-        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n-        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n-        // into symlinks.\n-        let attr = lstat(p)?;\n-        if attr.file_type().is_symlink() {\n-            crate::fs::remove_file(p)\n-        } else {\n-            remove_dir_all_recursive(None, p)\n-        }\n-    }\n-\n-    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n-        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n-        if openat.get().is_some() {\n-            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n-            remove_dir_all_modern(p)\n-        } else {\n-            // fall back to classic implementation\n-            crate::sys_common::fs::remove_dir_all(p)\n-        }\n-    }\n-}\n-\n // Modern implementation using openat(), unlinkat() and fdopendir()\n #[cfg(not(any(\n     all(target_os = \"macos\", target_arch = \"x86_64\"),"}]}