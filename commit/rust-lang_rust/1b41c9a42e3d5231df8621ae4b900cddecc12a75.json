{"sha": "1b41c9a42e3d5231df8621ae4b900cddecc12a75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNDFjOWE0MmUzZDUyMzFkZjg2MjFhZTRiOTAwY2RkZWNjMTJhNzU=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2019-01-15T01:14:02Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-02-07T18:15:31Z"}, "message": "error on duplicate matcher bindings", "tree": {"sha": "5e49be60e8392e4f5caabc4064ca2fae606d4cb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e49be60e8392e4f5caabc4064ca2fae606d4cb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b41c9a42e3d5231df8621ae4b900cddecc12a75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b41c9a42e3d5231df8621ae4b900cddecc12a75", "html_url": "https://github.com/rust-lang/rust/commit/1b41c9a42e3d5231df8621ae4b900cddecc12a75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b41c9a42e3d5231df8621ae4b900cddecc12a75/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1731801163df1d3a8d4ddfa68adac2ec833ef7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1731801163df1d3a8d4ddfa68adac2ec833ef7f", "html_url": "https://github.com/rust-lang/rust/commit/d1731801163df1d3a8d4ddfa68adac2ec833ef7f"}], "stats": {"total": 54, "additions": 49, "deletions": 5}, "files": [{"sha": "61a5b2cb0d2004b1899d5b0ecb0947032a100a7c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1b41c9a42e3d5231df8621ae4b900cddecc12a75/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b41c9a42e3d5231df8621ae4b900cddecc12a75/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1b41c9a42e3d5231df8621ae4b900cddecc12a75", "patch": "@@ -17,10 +17,10 @@ use crate::parse::token::Token::*;\n use crate::symbol::Symbol;\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP, symbol::Ident};\n use log::debug;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap};\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n \n@@ -246,8 +246,12 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt<'_>,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition: Edition)\n-               -> SyntaxExtension {\n+pub fn compile(\n+    sess: &ParseSess,\n+    features: &Features,\n+    def: &ast::Item,\n+    edition: Edition\n+) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -355,7 +359,9 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n \n     // don't abort iteration early, so that errors for multiple lhses can be reported\n     for lhs in &lhses {\n-        valid &= check_lhs_no_empty_seq(sess, &[lhs.clone()])\n+        valid &= check_lhs_no_empty_seq(sess, &[lhs.clone()]);\n+        valid &=\n+            check_lhs_duplicate_matcher_bindings(sess, &[lhs.clone()], &mut FxHashMap::default());\n     }\n \n     let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n@@ -456,6 +462,44 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n     true\n }\n \n+/// Check that the LHS contains no duplicate matcher bindings. e.g. `$a:expr, $a:expr` would be\n+/// illegal, since it would be ambiguous which `$a` to use if we ever needed to.\n+fn check_lhs_duplicate_matcher_bindings(\n+    sess: &ParseSess,\n+    tts: &[quoted::TokenTree],\n+    metavar_names: &mut FxHashMap<Ident, Span>\n+) -> bool {\n+    use self::quoted::TokenTree;\n+    for tt in tts {\n+        match *tt {\n+            TokenTree::MetaVarDecl(span, name, _kind) => {\n+                if let Some(&prev_span) = metavar_names.get(&name) {\n+                    sess.span_diagnostic\n+                        .struct_span_err(span, \"duplicate matcher binding\")\n+                        .span_note(prev_span, \"previous declaration was here\")\n+                        .emit();\n+                    return false;\n+                } else {\n+                    metavar_names.insert(name, span);\n+                }\n+            }\n+            TokenTree::Delimited(_, ref del) => {\n+                if !check_lhs_duplicate_matcher_bindings(sess, &del.tts, metavar_names) {\n+                    return false;\n+                }\n+            },\n+            TokenTree::Sequence(_, ref seq) => {\n+                if !check_lhs_duplicate_matcher_bindings(sess, &seq.tts, metavar_names) {\n+                    return false;\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    true\n+}\n+\n fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n     match *rhs {\n         quoted::TokenTree::Delimited(..) => return true,"}]}