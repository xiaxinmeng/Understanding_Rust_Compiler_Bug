{"sha": "2569adc5ea0b950c6e41a1c72d9eb7efdba49f05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NjlhZGM1ZWEwYjk1MGM2ZTQxYTFjNzJkOWViN2VmZGJhNDlmMDU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-01T15:12:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-02T03:44:30Z"}, "message": "Split auto_serialize2 into two macros", "tree": {"sha": "0809baef6e0089b39e953269ca5a1e92638916e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0809baef6e0089b39e953269ca5a1e92638916e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05", "html_url": "https://github.com/rust-lang/rust/commit/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "372c7de20104bd3f968cda6429dfad2c1d559a35", "url": "https://api.github.com/repos/rust-lang/rust/commits/372c7de20104bd3f968cda6429dfad2c1d559a35", "html_url": "https://github.com/rust-lang/rust/commit/372c7de20104bd3f968cda6429dfad2c1d559a35"}], "stats": {"total": 214, "additions": 137, "deletions": 77}, "files": [{"sha": "99f837a4c8446d61151e631acf5ffe5134ccf9c4", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 124, "deletions": 75, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=2569adc5ea0b950c6e41a1c72d9eb7efdba49f05", "patch": "@@ -1,13 +1,14 @@\n /*\n \n-The compiler code necessary to implement the #[auto_serialize2]\n-extension.  The idea here is that type-defining items may be tagged\n-with #[auto_serialize2], which will cause us to generate a little\n-companion module with the same name as the item.\n+The compiler code necessary to implement the #[auto_serialize2] and\n+#[auto_deserialize2] extension.  The idea here is that type-defining items may\n+be tagged with #[auto_serialize2] and #[auto_deserialize2], which will cause\n+us to generate a little companion module with the same name as the item.\n \n For example, a type like:\n \n     #[auto_serialize2]\n+    #[auto_deserialize2]\n     struct Node {id: uint}\n \n would generate two implementations like:\n@@ -34,6 +35,7 @@ Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n \n     #[auto_serialize2]\n+    #[auto_deserialize2]\n     type spanned<T> = {node: T, span: span};\n \n would yield functions like:\n@@ -75,92 +77,139 @@ use codemap::span;\n use std::map;\n use std::map::HashMap;\n \n-export expand;\n+export expand_auto_serialize;\n+export expand_auto_deserialize;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n     pub use ext;\n     pub use parse;\n }\n \n-fn expand(cx: ext_ctxt,\n-          span: span,\n-          _mitem: ast::meta_item,\n-          in_items: ~[@ast::item]) -> ~[@ast::item] {\n-    fn not_auto_serialize2(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) != ~\"auto_serialize2\"\n+fn expand_auto_serialize(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_serialize2(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_serialize2\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @{attrs: vec::filter(item.attrs, not_auto_serialize2),\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_serialize2(a)),\n           .. *item}\n     }\n \n     do vec::flat_map(in_items) |item| {\n-        match item.node {\n-            ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n-                let ser_impl = mk_rec_ser_impl(\n-                    cx,\n-                    item.span,\n-                    item.ident,\n-                    fields,\n-                    tps\n-                );\n-\n-                let deser_impl = mk_rec_deser_impl(\n-                    cx,\n-                    item.span,\n-                    item.ident,\n-                    fields,\n-                    tps\n-                );\n-\n-                ~[filter_attrs(*item), ser_impl, deser_impl]\n-            },\n-            ast::item_class(@{ fields, _}, tps) => {\n-                let ser_impl = mk_struct_ser_impl(\n-                    cx,\n-                    item.span,\n-                    item.ident,\n-                    fields,\n-                    tps\n-                );\n-\n-                let deser_impl = mk_struct_deser_impl(\n-                    cx,\n-                    item.span,\n-                    item.ident,\n-                    fields,\n-                    tps\n-                );\n-\n-                ~[filter_attrs(*item), ser_impl, deser_impl]\n-            },\n-            ast::item_enum(enum_def, tps) => {\n-                let ser_impl = mk_enum_ser_impl(\n-                    cx,\n-                    item.span,\n-                    item.ident,\n-                    enum_def,\n-                    tps\n-                );\n-\n-                let deser_impl = mk_enum_deser_impl(\n-                    cx,\n-                    item.span,\n-                    item.ident,\n-                    enum_def,\n-                    tps\n-                );\n-\n-                ~[filter_attrs(*item), ser_impl, deser_impl]\n-            },\n-            _ => {\n-                cx.span_err(span, ~\"#[auto_serialize2] can only be applied \\\n-                                    to structs, record types, and enum \\\n-                                    definitions\");\n-                ~[*item]\n+        if item.attrs.any(is_auto_serialize2) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                    let ser_impl = mk_rec_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_class(@{ fields, _}, tps) => {\n+                    let ser_impl = mk_struct_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_enum(enum_def, tps) => {\n+                    let ser_impl = mk_enum_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        enum_def,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_serialize2] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n+            }\n+        } else {\n+            ~[*item]\n+        }\n+    }\n+}\n+\n+fn expand_auto_deserialize(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_deserialize2(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_deserialize2\"\n+    }\n+\n+    fn filter_attrs(item: @ast::item) -> @ast::item {\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_deserialize2(a)),\n+          .. *item}\n+    }\n+\n+    do vec::flat_map(in_items) |item| {\n+        if item.attrs.any(is_auto_deserialize2) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                    let deser_impl = mk_rec_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_class(@{ fields, _}, tps) => {\n+                    let deser_impl = mk_struct_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_enum(enum_def, tps) => {\n+                    let deser_impl = mk_enum_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        enum_def,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_deserialize2] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n             }\n+        } else {\n+            ~[*item]\n         }\n     }\n }"}, {"sha": "9a31cc1d8f672d45252072d0917e792a959fdc47", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2569adc5ea0b950c6e41a1c72d9eb7efdba49f05", "patch": "@@ -82,8 +82,12 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(~\"auto_serialize\",\n                             item_decorator(ext::auto_serialize::expand));\n-    syntax_expanders.insert(~\"auto_serialize2\",\n-                            item_decorator(ext::auto_serialize2::expand));\n+    syntax_expanders.insert(\n+        ~\"auto_serialize2\",\n+        item_decorator(ext::auto_serialize2::expand_auto_serialize));\n+    syntax_expanders.insert(\n+        ~\"auto_deserialize2\",\n+        item_decorator(ext::auto_serialize2::expand_auto_deserialize));\n     syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"concat_idents\",\n                             builtin(ext::concat_idents::expand_syntax_ext));"}, {"sha": "4503ea6c7e01b82bd702721a383e89fe979d525a", "filename": "src/test/run-pass/auto_serialize2.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2569adc5ea0b950c6e41a1c72d9eb7efdba49f05/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs?ref=2569adc5ea0b950c6e41a1c72d9eb7efdba49f05", "patch": "@@ -31,6 +31,7 @@ fn test_ser_and_deser<A:Eq Serializable Deserializable>(\n }\n \n #[auto_serialize2]\n+#[auto_deserialize2]\n enum Expr {\n     Val(uint),\n     Plus(@Expr, @Expr),\n@@ -105,6 +106,7 @@ impl CLike : cmp::Eq {\n }\n \n #[auto_serialize2]\n+#[auto_deserialize2]\n type Spanned<T> = {lo: uint, hi: uint, node: T};\n \n impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n@@ -115,21 +117,26 @@ impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n }\n \n #[auto_serialize2]\n+#[auto_deserialize2]\n type SomeRec = {v: ~[uint]};\n \n #[auto_serialize2]\n+#[auto_deserialize2]\n enum AnEnum = SomeRec;\n \n #[auto_serialize2]\n+#[auto_deserialize2]\n struct Point {x: uint, y: uint}\n \n #[auto_serialize2]\n+#[auto_deserialize2]\n enum Quark<T> {\n     Top(T),\n     Bottom(T)\n }\n \n #[auto_serialize2]\n+#[auto_deserialize2]\n enum CLike { A, B, C }\n \n fn main() {"}]}