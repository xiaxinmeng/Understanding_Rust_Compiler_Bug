{"sha": "3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYmE1MDNiZjUwYjRhODNkYmMyMGUwMDJiMWUxZTJjMDBmZTEwNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-02T02:38:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-02T02:38:16Z"}, "message": "Auto merge of #37514 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\n- Successful merges: #36849, #37059, #37296, #37316, #37484, #37485, #37495\n- Failed merges:", "tree": {"sha": "889f76780cf9967c5d16dbcf924d7549dd38e23d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/889f76780cf9967c5d16dbcf924d7549dd38e23d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "html_url": "https://github.com/rust-lang/rust/commit/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c69b0d5ae8c404c4847fa214126ebd7c0246277", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c69b0d5ae8c404c4847fa214126ebd7c0246277", "html_url": "https://github.com/rust-lang/rust/commit/7c69b0d5ae8c404c4847fa214126ebd7c0246277"}, {"sha": "f5c192a4b7f1bb7661c1625d9ff66771a79c9e6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c192a4b7f1bb7661c1625d9ff66771a79c9e6e", "html_url": "https://github.com/rust-lang/rust/commit/f5c192a4b7f1bb7661c1625d9ff66771a79c9e6e"}], "stats": {"total": 500, "additions": 251, "deletions": 249}, "files": [{"sha": "b7b67a9f1d0988822646bde66c7e7850d1c9a767", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -510,12 +510,11 @@ fn factory() -> Box<Fn(i32) -> i32> {\n \n     Box::new(|x| x + num)\n }\n-# fn main() {\n+\n let f = factory();\n \n let answer = f(1);\n assert_eq!(6, answer);\n-# }\n ```\n \n There\u2019s just one last problem:\n@@ -540,12 +539,11 @@ fn factory() -> Box<Fn(i32) -> i32> {\n \n     Box::new(move |x| x + num)\n }\n-fn main() {\n+\n let f = factory();\n \n let answer = f(1);\n assert_eq!(6, answer);\n-}\n ```\n \n By making the inner closure a `move Fn`, we create a new stack frame for our"}, {"sha": "a3ab4803bc4d1d27bbd7eb53333aded8f27b0e28", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -362,7 +362,6 @@ numbers. A bare number like above is actually shorthand for `^0.3.0`,\n meaning \"anything compatible with 0.3.0\".\n If we wanted to use only `0.3.0` exactly, we could say `rand=\"=0.3.0\"`\n (note the two equal signs).\n-And if we wanted to use the latest version we could use `rand=\"*\"`.\n We could also use a range of versions.\n [Cargo\u2019s documentation][cargodoc] contains more details.\n "}, {"sha": "0e6cdb8f09ddcdcb6f752f03b5df555695f0d392", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -24,9 +24,11 @@ Cargo will automatically generate a simple test when you make a new project.\n Here's the contents of `src/lib.rs`:\n \n ```rust\n-# fn main() {}\n-#[test]\n-fn it_works() {\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn it_works() {\n+    }\n }\n ```\n \n@@ -36,11 +38,11 @@ currently has no body. That's good enough to pass! We can run the tests with\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -56,7 +58,7 @@ for the test we wrote, and another for documentation tests. We'll talk about\n those later. For now, see this line:\n \n ```text\n-test it_works ... ok\n+test tests::it_works ... ok\n ```\n \n Note the `it_works`. This comes from the name of our function:\n@@ -89,31 +91,30 @@ run our tests again:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... FAILED\n+test tests::it_works ... FAILED\n \n failures:\n \n----- it_works stdout ----\n-        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3\n-\n+---- test::it_works stdout ----\n+        thread 'tests::it_works' panicked at 'assertion failed: false', src/lib.rs:5\n \n \n failures:\n-    it_works\n+    tests::it_works\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-thread 'main' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247\n+error: test failed\n ```\n \n Rust indicates that our test failed:\n \n ```text\n-test it_works ... FAILED\n+test tests::it_works ... FAILED\n ```\n \n And that's reflected in the summary line:\n@@ -159,11 +160,11 @@ This test will now succeed if we `panic!` and fail if we complete. Let's try it:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -191,11 +192,11 @@ passes:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -262,8 +263,8 @@ not:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 2 tests\n test expensive_test ... ignored\n@@ -282,7 +283,7 @@ The expensive tests can be run explicitly using `cargo test -- --ignored`:\n \n ```bash\n $ cargo test -- --ignored\n-     Running target/adder-91b3e234d4ed382a\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test expensive_test ... ok\n@@ -302,8 +303,11 @@ which is why the command is `cargo test -- --ignored`.\n # The `tests` module\n \n There is one way in which our existing example is not idiomatic: it's\n-missing the `tests` module. The idiomatic way of writing our example\n-looks like this:\n+missing the `tests` module. You might have noticed this test module was\n+present in the code that was initially generated with `cargo new` but\n+was missing from our last example. Let's explain what this does.\n+\n+The idiomatic way of writing our example looks like this:\n \n ```rust,ignore\n # fn main() {}\n@@ -356,8 +360,8 @@ Note the different `use` line. Now we run our tests:\n ```bash\n $ cargo test\n     Updating registry `https://github.com/rust-lang/crates.io-index`\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test tests::it_works ... ok\n@@ -404,15 +408,15 @@ Let's run them:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n-     Running target/lib-c18e7d3494509e74\n+     Running target/debug/integration_test-68064b69521c828a\n \n running 1 test\n test it_works ... ok\n@@ -490,15 +494,15 @@ Let's run the tests again:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0. (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n-     Running target/lib-c18e7d3494509e74\n+     Running target/debug/integration_test-68064b69521c828a\n \n running 1 test\n test it_works ... ok"}, {"sha": "830bbc079ad1e81cc242c5dbf2f7771d16dc8f09", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -145,7 +145,7 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// # Generic Impls\n ///\n-/// - `[From<T>][From] for U` implies `Into<U> for T`\n+/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n /// - [`into()`] is reflexive, which means that `Into<T> for T` is implemented\n ///\n /// [`TryInto`]: trait.TryInto.html\n@@ -178,14 +178,14 @@ pub trait Into<T>: Sized {\n /// ```\n /// # Generic impls\n ///\n-/// - `From<T> for U` implies `[Into<U>] for T`\n+/// - `From<T> for U` implies [`Into<U>`]` for T`\n /// - [`from()`] is reflexive, which means that `From<T> for T` is implemented\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [Into<U>]: trait.Into.html\n+/// [`Into<U>`]: trait.Into.html\n /// [`from()`]: trait.From.html#tymethod.from\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {"}, {"sha": "f69a60d9e1f7403d5c015b64e189b072841590b2", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -42,12 +42,13 @@ macro_rules! panic {\n /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n /// violated could lead to unsafety.\n ///\n-/// Other use-cases of `assert!` include\n-/// [testing](https://doc.rust-lang.org/book/testing.html) and enforcing\n-/// run-time invariants in safe code (whose violation cannot result in unsafety).\n+/// Other use-cases of `assert!` include [testing] and enforcing run-time\n+/// invariants in safe code (whose violation cannot result in unsafety).\n ///\n /// This macro has a second version, where a custom panic message can be provided.\n ///\n+/// [testing]: ../book/testing.html\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "bdb0dd8e7d1a9e0a371164c582b2aaa4af9276fe", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -241,8 +241,8 @@ pub trait Unsize<T: ?Sized> {\n /// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n /// [E0205].\n ///\n-/// [E0204]: https://doc.rust-lang.org/error-index.html#E0204\n-/// [E0205]: https://doc.rust-lang.org/error-index.html#E0205\n+/// [E0204]: ../../error-index.html#E0204\n+/// [E0205]: ../../error-index.html#E0205\n ///\n /// ## When *should* my type be `Copy`?\n ///"}, {"sha": "e177963fade8497ad02ce5b2791c2596b7520888", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -182,11 +182,11 @@ pub trait Drop {\n     /// After this function is over, the memory of `self` will be deallocated.\n     ///\n     /// This function cannot be called explicitly. This is compiler error\n-    /// [0040]. However, the [`std::mem::drop`] function in the prelude can be\n+    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n     /// used to call the argument's `Drop` implementation.\n     ///\n-    /// [0040]: https://doc.rust-lang.org/error-index.html#E0040\n-    /// [`std::mem::drop`]: https://doc.rust-lang.org/std/mem/fn.drop.html\n+    /// [E0040]: ../../error-index.html#E0040\n+    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n     ///\n     /// # Panics\n     ///"}, {"sha": "196750254af30eacadeb20f8594a0208dc319f92", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -132,7 +132,7 @@ impl Utf8Error {\n     /// verified.\n     ///\n     /// It is the maximum index such that `from_utf8(input[..index])`\n-    /// would return `Some(_)`.\n+    /// would return `Ok(_)`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "4c097965bb06abe05852e93f437bbdf7f0a5a1a1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -199,9 +199,6 @@ pub enum TypeOrigin {\n     // Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse(Span),\n \n-    // Computing common supertype in a range expression\n-    RangeExpression(Span),\n-\n     // `where a == b`\n     EquatePredicate(Span),\n \n@@ -231,7 +228,6 @@ impl TypeOrigin {\n             },\n             &TypeOrigin::IfExpression(_) => \"if and else have incompatible types\",\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n-            &TypeOrigin::RangeExpression(_) => \"start and end of range have incompatible types\",\n             &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n             &TypeOrigin::MainFunctionType(_) => \"main function has wrong type\",\n             &TypeOrigin::StartFunctionType(_) => \"start function has wrong type\",\n@@ -251,7 +247,6 @@ impl TypeOrigin {\n             &TypeOrigin::MatchExpressionArm(..) => \"match arms have compatible types\",\n             &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n-            &TypeOrigin::RangeExpression(_) => \"start and end of range have compatible types\",\n             &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n             &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n             &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n@@ -1755,7 +1750,6 @@ impl TypeOrigin {\n             TypeOrigin::MatchExpressionArm(match_span, ..) => match_span,\n             TypeOrigin::IfExpression(span) => span,\n             TypeOrigin::IfExpressionWithNoElse(span) => span,\n-            TypeOrigin::RangeExpression(span) => span,\n             TypeOrigin::EquatePredicate(span) => span,\n             TypeOrigin::MainFunctionType(span) => span,\n             TypeOrigin::StartFunctionType(span) => span,"}, {"sha": "289a7348cc8dd6b525855fff5046d9e9f285d13e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 145, "deletions": 133, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -101,8 +101,8 @@ impl PpMode {\n \n     pub fn needs_analysis(&self) -> bool {\n         match *self {\n-             PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n-             _ => false,\n+            PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n+            _ => false,\n         }\n     }\n }\n@@ -233,14 +233,11 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let annotation = TypedAnnotation {\n-                        tcx: tcx,\n-                    };\n+                    let annotation = TypedAnnotation { tcx: tcx };\n                     let _ignore = tcx.dep_graph.in_ignore();\n-                    f(&annotation,\n-                      payload,\n-                      ast_map.forest.krate())\n-                }), sess)\n+                    f(&annotation, payload, ast_map.forest.krate())\n+                }),\n+                             sess)\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -281,9 +278,11 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n     /// Computes an user-readable representation of a path, if possible.\n     fn node_path(&self, id: ast::NodeId) -> Option<String> {\n         self.ast_map().and_then(|map| map.def_path_from_id(id)).map(|path| {\n-            path.data.into_iter().map(|elem| {\n-                elem.data.to_string()\n-            }).collect::<Vec<_>>().join(\"::\")\n+            path.data\n+                .into_iter()\n+                .map(|elem| elem.data.to_string())\n+                .collect::<Vec<_>>()\n+                .join(\"::\")\n         })\n     }\n }\n@@ -352,7 +351,8 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(_) | pprust::NodeName(_) => Ok(()),\n+            pprust::NodeIdent(_) |\n+            pprust::NodeName(_) => Ok(()),\n \n             pprust::NodeItem(item) => {\n                 pp::space(&mut s.s)?;\n@@ -617,15 +617,14 @@ impl ReplaceBodyWithLoop {\n impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n         match i {\n-            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n+            ast::ItemKind::Static(..) |\n+            ast::ItemKind::Const(..) => {\n                 self.within_static_or_const = true;\n                 let ret = fold::noop_fold_item_kind(i, self);\n                 self.within_static_or_const = false;\n                 return ret;\n             }\n-            _ => {\n-                fold::noop_fold_item_kind(i, self)\n-            }\n+            _ => fold::noop_fold_item_kind(i, self),\n         }\n     }\n \n@@ -656,11 +655,15 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode, e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-                stmts: e.map(|e| ast::Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: e.span,\n-                    node: ast::StmtKind::Expr(e),\n-                }).into_iter().collect(),\n+                stmts: e.map(|e| {\n+                        ast::Stmt {\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: e.span,\n+                            node: ast::StmtKind::Expr(e),\n+                        }\n+                    })\n+                    .into_iter()\n+                    .collect(),\n                 rules: rules,\n                 id: ast::DUMMY_NODE_ID,\n                 span: syntax_pos::DUMMY_SP,\n@@ -721,9 +724,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         }\n         blocks::FnLikeCode(fn_like) => {\n             let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n-                                                              fn_like.to_fn_parts(),\n-                                                              &cfg);\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,\n@@ -756,13 +757,13 @@ pub fn fold_crate(krate: ast::Crate, ppm: PpMode) -> ast::Crate {\n fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, String) {\n     let src_name = driver::source_name(input);\n     let src = sess.codemap()\n-                  .get_filemap(&src_name)\n-                  .unwrap()\n-                  .src\n-                  .as_ref()\n-                  .unwrap()\n-                  .as_bytes()\n-                  .to_vec();\n+        .get_filemap(&src_name)\n+        .unwrap()\n+        .src\n+        .as_ref()\n+        .unwrap()\n+        .as_bytes()\n+        .to_vec();\n     (src, src_name)\n }\n \n@@ -795,17 +796,18 @@ pub fn print_after_parsing(sess: &Session,\n         // Silently ignores an identified node.\n         let out: &mut Write = &mut out;\n         s.call_with_pp_support(sess, None, box out, |annotation, out| {\n-            debug!(\"pretty printing source code {:?}\", s);\n-            let sess = annotation.sess();\n-            pprust::print_crate(sess.codemap(),\n-                                sess.diagnostic(),\n-                                krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                annotation.pp_ann(),\n-                                false)\n-        }).unwrap()\n+                debug!(\"pretty printing source code {:?}\", s);\n+                let sess = annotation.sess();\n+                pprust::print_crate(sess.codemap(),\n+                                    sess.diagnostic(),\n+                                    krate,\n+                                    src_name.to_string(),\n+                                    &mut rdr,\n+                                    out,\n+                                    annotation.pp_ann(),\n+                                    false)\n+            })\n+            .unwrap()\n     } else {\n         unreachable!();\n     };\n@@ -828,8 +830,15 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let _ignore = dep_graph.in_ignore();\n \n     if ppm.needs_analysis() {\n-        print_with_analysis(sess, ast_map, analysis, resolutions,\n-                            crate_name, arenas, ppm, opt_uii, ofile);\n+        print_with_analysis(sess,\n+                            ast_map,\n+                            analysis,\n+                            resolutions,\n+                            crate_name,\n+                            arenas,\n+                            ppm,\n+                            opt_uii,\n+                            ofile);\n         return;\n     }\n \n@@ -839,82 +848,82 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     match (ppm, opt_uii) {\n-        (PpmSource(s), _) => {\n-            // Silently ignores an identified node.\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                pprust::print_crate(sess.codemap(),\n-                                    sess.diagnostic(),\n-                                    krate,\n-                                    src_name.to_string(),\n-                                    &mut rdr,\n-                                    out,\n-                                    annotation.pp_ann(),\n-                                    true)\n-            })\n-        }\n+            (PpmSource(s), _) => {\n+                // Silently ignores an identified node.\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    pprust::print_crate(sess.codemap(),\n+                                        sess.diagnostic(),\n+                                        krate,\n+                                        src_name.to_string(),\n+                                        &mut rdr,\n+                                        out,\n+                                        annotation.pp_ann(),\n+                                        true)\n+                })\n+            }\n \n-        (PpmHir(s), None) => {\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n-                                       ast_map,\n-                                       analysis,\n-                                       resolutions,\n-                                       arenas,\n-                                       crate_name,\n-                                       box out,\n-                                       |annotation, out, krate| {\n-                                           debug!(\"pretty printing source code {:?}\", s);\n-                                           let sess = annotation.sess();\n-                                           pprust_hir::print_crate(sess.codemap(),\n-                                                                   sess.diagnostic(),\n-                                                                   krate,\n-                                                                   src_name.to_string(),\n-                                                                   &mut rdr,\n-                                                                   out,\n-                                                                   annotation.pp_ann(),\n-                                                                   true)\n-                                       })\n-        }\n+            (PpmHir(s), None) => {\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support_hir(sess,\n+                                           ast_map,\n+                                           analysis,\n+                                           resolutions,\n+                                           arenas,\n+                                           crate_name,\n+                                           box out,\n+                                           |annotation, out, krate| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    pprust_hir::print_crate(sess.codemap(),\n+                                            sess.diagnostic(),\n+                                            krate,\n+                                            src_name.to_string(),\n+                                            &mut rdr,\n+                                            out,\n+                                            annotation.pp_ann(),\n+                                            true)\n+                })\n+            }\n \n-        (PpmHir(s), Some(uii)) => {\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n-                                       ast_map,\n-                                       analysis,\n-                                       resolutions,\n-                                       arenas,\n-                                       crate_name,\n-                                       (out,uii),\n-                                       |annotation, (out,uii), _| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n-                let mut pp_state =\n-                    pprust_hir::State::new_from_input(sess.codemap(),\n-                                                      sess.diagnostic(),\n-                                                      src_name.to_string(),\n-                                                      &mut rdr,\n-                                                      box out,\n-                                                      annotation.pp_ann(),\n-                                                      true,\n-                                                      Some(ast_map.krate()));\n-                for node_id in uii.all_matching_node_ids(ast_map) {\n-                    let node = ast_map.get(node_id);\n-                    pp_state.print_node(&node)?;\n-                    pp::space(&mut pp_state.s)?;\n-                    let path = annotation.node_path(node_id)\n-                                         .expect(\"--unpretty missing node paths\");\n-                    pp_state.synth_comment(path)?;\n-                    pp::hardbreak(&mut pp_state.s)?;\n-                }\n-                pp::eof(&mut pp_state.s)\n-            })\n-       }\n-       _ => unreachable!(),\n-    }.unwrap();\n+            (PpmHir(s), Some(uii)) => {\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support_hir(sess,\n+                                           ast_map,\n+                                           analysis,\n+                                           resolutions,\n+                                           arenas,\n+                                           crate_name,\n+                                           (out, uii),\n+                                           |annotation, (out, uii), _| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n+                    let mut pp_state = pprust_hir::State::new_from_input(sess.codemap(),\n+                                                                         sess.diagnostic(),\n+                                                                         src_name.to_string(),\n+                                                                         &mut rdr,\n+                                                                         box out,\n+                                                                         annotation.pp_ann(),\n+                                                                         true,\n+                                                                         Some(ast_map.krate()));\n+                    for node_id in uii.all_matching_node_ids(ast_map) {\n+                        let node = ast_map.get(node_id);\n+                        pp_state.print_node(&node)?;\n+                        pp::space(&mut pp_state.s)?;\n+                        let path = annotation.node_path(node_id)\n+                            .expect(\"--unpretty missing node paths\");\n+                        pp_state.synth_comment(path)?;\n+                        pp::hardbreak(&mut pp_state.s)?;\n+                    }\n+                    pp::eof(&mut pp_state.s)\n+                })\n+            }\n+            _ => unreachable!(),\n+        }\n+        .unwrap();\n \n     write_output(out, ofile);\n }\n@@ -955,27 +964,28 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     let def_id = tcx.map.local_def_id(nodeid);\n                     match ppm {\n                         PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n-                        PpmMirCFG => {\n-                            write_mir_graphviz(tcx, iter::once(def_id), &mut out)\n-                        }\n+                        PpmMirCFG => write_mir_graphviz(tcx, iter::once(def_id), &mut out),\n                         _ => unreachable!(),\n                     }?;\n                 } else {\n                     match ppm {\n-                        PpmMir => write_mir_pretty(tcx,\n-                                                   tcx.mir_map.borrow().keys().into_iter(),\n-                                                   &mut out),\n-                        PpmMirCFG => write_mir_graphviz(tcx,\n-                                                        tcx.mir_map.borrow().keys().into_iter(),\n-                                                        &mut out),\n+                        PpmMir => {\n+                            write_mir_pretty(tcx, tcx.mir_map.borrow().keys().into_iter(), &mut out)\n+                        }\n+                        PpmMirCFG => {\n+                            write_mir_graphviz(tcx,\n+                                               tcx.mir_map.borrow().keys().into_iter(),\n+                                               &mut out)\n+                        }\n                         _ => unreachable!(),\n                     }?;\n                 }\n                 Ok(())\n             }\n             PpmFlowGraph(mode) => {\n-                let nodeid = nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or \\\n-                                            unique path suffix (b::c::d)\");\n+                let nodeid =\n+                    nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n+                                   suffix (b::c::d)\");\n                 let node = tcx.map.find(nodeid).unwrap_or_else(|| {\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n@@ -990,8 +1000,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                         print_flowgraph(variants, tcx, code, mode, out)\n                     }\n                     None => {\n-                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n-                                               {:?}\",\n+                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; \\\n+                                               got {:?}\",\n                                               node);\n \n                         // Point to what was found, if there's an accessible span.\n@@ -1004,7 +1014,9 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n             }\n             _ => unreachable!(),\n         }\n-    }), sess).unwrap();\n+    }),\n+                 sess)\n+        .unwrap();\n \n     write_output(out, ofile);\n }"}, {"sha": "ba51947a3330177b6385d8fb11d5e8e32395fbf0", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -20,26 +20,11 @@ use libc::c_char;\n // detection code will walk past the end of the feature array,\n // leading to crashes.\n \n-const ARM_WHITELIST: &'static [&'static str] = &[\n-    \"neon\\0\",\n-    \"vfp2\\0\",\n-    \"vfp3\\0\",\n-    \"vfp4\\0\",\n-];\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n \n-const X86_WHITELIST: &'static [&'static str] = &[\n-    \"avx\\0\",\n-    \"avx2\\0\",\n-    \"bmi\\0\",\n-    \"bmi2\\0\",\n-    \"sse\\0\",\n-    \"sse2\\0\",\n-    \"sse3\\0\",\n-    \"sse4.1\\0\",\n-    \"sse4.2\\0\",\n-    \"ssse3\\0\",\n-    \"tbm\\0\",\n-];\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n+                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n+                                                 \"ssse3\\0\", \"tbm\\0\"];\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n@@ -59,7 +44,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len()-1])))\n+            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len() - 1])))\n         }\n     }\n }"}, {"sha": "8dc21550148c0d9a54c8955c0c68e8187e564029", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -40,7 +40,7 @@ use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n-struct Env<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n@@ -86,8 +86,7 @@ impl Emitter for ExpectErrorEmitter {\n \n fn errors(msgs: &[&str]) -> (Box<Emitter + Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n-    (box ExpectErrorEmitter { messages: v } as Box<Emitter + Send>,\n-     msgs.len())\n+    (box ExpectErrorEmitter { messages: v } as Box<Emitter + Send>, msgs.len())\n }\n \n fn test_env<F>(source_string: &str,\n@@ -103,18 +102,28 @@ fn test_env<F>(source_string: &str,\n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n-                                       Rc::new(CodeMap::new()), cstore.clone());\n+    let sess = session::build_session_(options,\n+                                       &dep_graph,\n+                                       None,\n+                                       diagnostic_handler,\n+                                       Rc::new(CodeMap::new()),\n+                                       cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: driver::anon_src(),\n         input: source_string.to_string(),\n     };\n     let krate = driver::phase_1_parse_input(&sess, &input).unwrap();\n     let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n-        driver::phase_2_configure_and_expand(\n-            &sess, &cstore, krate, None, \"test\", None, MakeGlobMap::No, |_| Ok(()),\n-        ).expect(\"phase 2 aborted\")\n+        driver::phase_2_configure_and_expand(&sess,\n+                                             &cstore,\n+                                             krate,\n+                                             None,\n+                                             \"test\",\n+                                             None,\n+                                             MakeGlobMap::No,\n+                                             |_| Ok(()))\n+            .expect(\"phase 2 aborted\")\n     };\n     let _ignore = dep_graph.in_ignore();\n \n@@ -167,14 +176,22 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n         let node = ast::NodeId::from_u32;\n         let dscope = self.infcx\n-                         .tcx\n-                         .region_maps\n-                         .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n-                                             region::ROOT_CODE_EXTENT);\n+            .tcx\n+            .region_maps\n+            .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n+                                region::ROOT_CODE_EXTENT);\n         self.create_region_hierarchy(&RH {\n-            id: node(1),\n-            sub: &[RH { id: node(10), sub: &[] }, RH { id: node(11), sub: &[] }],\n-        }, dscope);\n+                                         id: node(1),\n+                                         sub: &[RH {\n+                                                    id: node(10),\n+                                                    sub: &[],\n+                                                },\n+                                                RH {\n+                                                    id: node(11),\n+                                                    sub: &[],\n+                                                }],\n+                                     },\n+                                     dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -213,22 +230,16 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                 hir::ItemStatic(..) |\n                 hir::ItemFn(..) |\n                 hir::ItemForeignMod(..) |\n-                hir::ItemTy(..) => {\n-                    None\n-                }\n+                hir::ItemTy(..) => None,\n \n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemTrait(..) |\n                 hir::ItemImpl(..) |\n-                hir::ItemDefaultImpl(..) => {\n-                    None\n-                }\n+                hir::ItemDefaultImpl(..) => None,\n \n-                hir::ItemMod(ref m) => {\n-                    search_mod(this, m, idx, names)\n-                }\n+                hir::ItemMod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }\n@@ -281,18 +292,17 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n     }\n \n-    pub fn re_early_bound(&self,\n-                          index: u32,\n-                          name: &'static str)\n-                          -> &'tcx ty::Region {\n+    pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n         let name = token::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,\n         }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex)\n+    pub fn re_late_bound_with_debruijn(&self,\n+                                       id: u32,\n+                                       debruijn: ty::DebruijnIndex)\n                                        -> &'tcx ty::Region {\n         self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n@@ -394,19 +404,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n                 self.assert_eq(t, t_lub);\n             }\n-            Err(ref e) => {\n-                panic!(\"unexpected error in LUB: {}\", e)\n-            }\n+            Err(ref e) => panic!(\"unexpected error in LUB: {}\", e),\n         }\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n         match self.glb(t1, t2) {\n-            Err(e) => {\n-                panic!(\"unexpected error computing LUB: {:?}\", e)\n-            }\n+            Err(e) => panic!(\"unexpected error computing LUB: {:?}\", e),\n             Ok(InferOk { obligations, value: t }) => {\n                 // FIXME(#32730) once obligations are being propagated, assert the right thing.\n                 assert!(obligations.is_empty());"}, {"sha": "454fa47cfbc99f4277cfab407759e5d18ad0c132", "filename": "src/libstd/error.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -69,7 +69,9 @@ pub trait Error: Debug + Display {\n     /// It should not contain newlines or sentence-ending punctuation,\n     /// to facilitate embedding in larger user-facing strings.\n     /// For showing formatted error messages with more information see\n-    /// [Display](https://doc.rust-lang.org/std/fmt/trait.Display.html).\n+    /// [`Display`].\n+    ///\n+    /// [`Display`]: ../fmt/trait.Display.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "1b5023380a7833c9adc13422817cb75d2b0098fb", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -23,7 +23,7 @@ use io::{self, SeekFrom, Error, ErrorKind};\n ///\n /// The standard library implements some I/O traits on various types which\n /// are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and\n-/// `Cursor<`[`&[u8]`]`>`.\n+/// `Cursor<`[`&[u8]`][bytes]`>`.\n ///\n /// # Examples\n ///\n@@ -35,7 +35,7 @@ use io::{self, SeekFrom, Error, ErrorKind};\n /// [`Read`]: ../../std/io/trait.Read.html\n /// [`Write`]: ../../std/io/trait.Write.html\n /// [`Vec`]: ../../std/vec/struct.Vec.html\n-/// [`&[u8]`]: ../../std/primitive.slice.html\n+/// [bytes]: ../../std/primitive.slice.html\n /// [`File`]: ../fs/struct.File.html\n ///\n /// ```no_run"}, {"sha": "9b7f9980cc0af5873664bd5d43f5d6aa716bbd65", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fba503bf50b4a83dbc20e002b1e1e2c00fe1054/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3fba503bf50b4a83dbc20e002b1e1e2c00fe1054", "patch": "@@ -914,6 +914,7 @@ impl<'a> cmp::Ord for Components<'a> {\n /// [`Path`]: struct.Path.html\n /// [`push`]: struct.PathBuf.html#method.push\n /// [`set_extension`]: struct.PathBuf.html#method.set_extension\n+/// [`Deref`]: ../ops/trait.Deref.html\n ///\n /// More details about the overall approach can be found in\n /// the module documentation."}]}