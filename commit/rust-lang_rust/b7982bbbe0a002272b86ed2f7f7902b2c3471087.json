{"sha": "b7982bbbe0a002272b86ed2f7f7902b2c3471087", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OTgyYmJiZTBhMDAyMjcyYjg2ZWQyZjdmNzkwMmIyYzM0NzEwODc=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-11-23T07:32:16Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-11-24T07:44:17Z"}, "message": "review comments", "tree": {"sha": "e73b2abe3a40ed5c0d2e32e02e903812acdb02c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e73b2abe3a40ed5c0d2e32e02e903812acdb02c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7982bbbe0a002272b86ed2f7f7902b2c3471087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7982bbbe0a002272b86ed2f7f7902b2c3471087", "html_url": "https://github.com/rust-lang/rust/commit/b7982bbbe0a002272b86ed2f7f7902b2c3471087", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7982bbbe0a002272b86ed2f7f7902b2c3471087/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "html_url": "https://github.com/rust-lang/rust/commit/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c"}], "stats": {"total": 305, "additions": 191, "deletions": 114}, "files": [{"sha": "808fe504b95cdc241f231604587e50d2125e8795", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 28, "deletions": 54, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=b7982bbbe0a002272b86ed2f7f7902b2c3471087", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper};\n use RenderSpan::*;\n-use snippet::{Annotation, AnnotationType, Line, StyledString, Style};\n+use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n use std::io::prelude::*;\n@@ -181,12 +181,17 @@ impl EmitterWriter {\n                 if is_minimized {\n                     ann.annotation_type = AnnotationType::Minimized;\n                 } else if lo.line != hi.line {\n-                    ann.annotation_type = AnnotationType::Multiline {\n+                    let ml = MultilineAnnotation {\n                         depth: 1,\n                         line_start: lo.line,\n                         line_end: hi.line,\n+                        start_col: lo.col.0,\n+                        end_col: hi.col.0,\n+                        is_primary: span_label.is_primary,\n+                        label: span_label.label.clone(),\n                     };\n-                    multiline_annotations.push((lo.file.clone(), ann.clone()));\n+                    ann.annotation_type = AnnotationType::Multiline(ml.clone());\n+                    multiline_annotations.push((lo.file.clone(), ml));\n                 };\n \n                 if !ann.is_multiline() {\n@@ -200,65 +205,34 @@ impl EmitterWriter {\n \n         // Find overlapping multiline annotations, put them at different depths\n         multiline_annotations.sort_by(|a, b| {\n-            if let AnnotationType::Multiline {\n-                line_start: a_start,\n-                line_end: a_end,\n-                ..\n-            } = a.1.annotation_type {\n-                if let AnnotationType::Multiline {\n-                    line_start: b_start,\n-                    line_end: b_end,\n-                    ..\n-                } = b.1.annotation_type {\n-                    (a_start, a_end).cmp(&(b_start, b_end))\n-                } else {\n-                    panic!(\"tried to sort multiline annotations, but found `{:?}`\", b)\n-                }\n-            } else {\n-                panic!(\"tried to sort multiline annotations, but found `{:?}`\", a)\n-            }\n+            (a.1.line_start, a.1.line_end).cmp(&(b.1.line_start, b.1.line_end))\n         });\n         for item in multiline_annotations.clone() {\n             let ann = item.1;\n-            if let AnnotationType::Multiline {line_start, line_end, ..} = ann.annotation_type {\n-                for item in multiline_annotations.iter_mut() {\n-                    let ref mut a = item.1;\n-                    if let AnnotationType::Multiline {\n-                        line_start: start,\n-                        line_end: end,\n-                        ..\n-                    } = a.annotation_type {\n-                        // Move all other multiline annotations overlapping with this one\n-                        // one level to the right.\n-                        if &ann != a && num_overlap(line_start, line_end, start, end, true) {\n-                            a.annotation_type.increase_depth();\n-                        } else {\n-                            break;\n-                        }\n-                    } else {\n-                        panic!(\"tried to find depth for multiline annotation, but found `{:?}`\",\n-                               ann)\n-                    };\n+            for item in multiline_annotations.iter_mut() {\n+                let ref mut a = item.1;\n+                // Move all other multiline annotations overlapping with this one\n+                // one level to the right.\n+                if &ann != a &&\n+                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n+                {\n+                    a.increase_depth();\n+                } else {\n+                    break;\n                 }\n-            } else {\n-                panic!(\"tried to find depth for multiline annotation, but found `{:?}`\", ann)\n-            };\n+            }\n         }\n \n         let mut max_depth = 0;  // max overlapping multiline spans\n         for (file, ann) in multiline_annotations {\n-            if let AnnotationType::Multiline {line_start, line_end, depth} = ann.annotation_type {\n-                if depth > max_depth {\n-                    max_depth = depth;\n-                }\n-                add_annotation_to_file(&mut output, file.clone(), line_start, ann.as_start());\n-                for line in line_start + 1..line_end {\n-                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n-                }\n-                add_annotation_to_file(&mut output, file, line_end, ann.as_end());\n-            } else {\n-                panic!(\"non-multiline annotation `{:?}` in `multiline_annotations`!\", ann);\n+            if ann.depth > max_depth {\n+                max_depth = ann.depth;\n+            }\n+            add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n+            for line in ann.line_start + 1..ann.line_end {\n+                add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n             }\n+            add_annotation_to_file(&mut output, file, ann.line_end, ann.as_end());\n         }\n         for file_vec in output.iter_mut() {\n             file_vec.multiline_depth = max_depth;\n@@ -572,7 +546,7 @@ impl EmitterWriter {\n         //   | |  something about `foo`\n         //   | something about `fn foo()`\n         annotations_position.sort_by(|a, b| {\n-            fn len(a: Annotation) -> usize {\n+            fn len(a: &Annotation) -> usize {\n                 // Account for usize underflows\n                 if a.end_col > a.start_col {\n                     a.end_col - a.start_col"}, {"sha": "b8c1726443db350a84451f716577ae8217f82e0e", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=b7982bbbe0a002272b86ed2f7f7902b2c3471087", "patch": "@@ -41,6 +41,57 @@ pub struct Line {\n     pub annotations: Vec<Annotation>,\n }\n \n+\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct MultilineAnnotation {\n+    pub depth: usize,\n+    pub line_start: usize,\n+    pub line_end: usize,\n+    pub start_col: usize,\n+    pub end_col: usize,\n+    pub is_primary: bool,\n+    pub label: Option<String>,\n+}\n+\n+impl MultilineAnnotation {\n+    pub fn increase_depth(&mut self) {\n+        self.depth += 1;\n+    }\n+\n+    pub fn as_start(&self) -> Annotation {\n+        Annotation {\n+            start_col: self.start_col,\n+            end_col: self.start_col + 1,\n+            is_primary: self.is_primary,\n+            label: Some(\"starting here...\".to_owned()),\n+            annotation_type: AnnotationType::MultilineStart(self.depth)\n+        }\n+    }\n+\n+    pub fn as_end(&self) -> Annotation {\n+        Annotation {\n+            start_col: self.end_col - 1,\n+            end_col: self.end_col,\n+            is_primary: self.is_primary,\n+            label: match self.label {\n+                Some(ref label) => Some(format!(\"...ending here: {}\", label)),\n+                None => Some(\"...ending here\".to_owned()),\n+            },\n+            annotation_type: AnnotationType::MultilineEnd(self.depth)\n+        }\n+    }\n+\n+    pub fn as_line(&self) -> Annotation {\n+        Annotation {\n+            start_col: 0,\n+            end_col: 0,\n+            is_primary: self.is_primary,\n+            label: None,\n+            annotation_type: AnnotationType::MultilineLine(self.depth)\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub enum AnnotationType {\n     /// Annotation under a single line of code\n@@ -50,11 +101,7 @@ pub enum AnnotationType {\n     Minimized,\n \n     /// Annotation enclosing the first and last character of a multiline span\n-    Multiline {\n-        depth: usize,\n-        line_start: usize,\n-        line_end: usize,\n-    },\n+    Multiline(MultilineAnnotation),\n \n     // The Multiline type above is replaced with the following three in order\n     // to reuse the current label drawing code.\n@@ -74,24 +121,6 @@ pub enum AnnotationType {\n     MultilineLine(usize),\n }\n \n-impl AnnotationType {\n-    pub fn depth(&self) -> usize {\n-        match self {\n-            &AnnotationType::Multiline {depth, ..} |\n-                &AnnotationType::MultilineStart(depth) |\n-                &AnnotationType::MultilineLine(depth) |\n-                &AnnotationType::MultilineEnd(depth) => depth,\n-            _ => 0,\n-        }\n-    }\n-\n-    pub fn increase_depth(&mut self) {\n-        if let AnnotationType::Multiline {ref mut depth, ..} = *self {\n-            *depth += 1;\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub struct Annotation {\n     /// Start column, 0-based indexing -- counting *characters*, not\n@@ -124,39 +153,14 @@ impl Annotation {\n \n     pub fn is_multiline(&self) -> bool {\n         match self.annotation_type {\n-            AnnotationType::Multiline {..} |\n-                AnnotationType::MultilineStart(_) |\n-                AnnotationType::MultilineLine(_) |\n-                AnnotationType::MultilineEnd(_) => true,\n+            AnnotationType::Multiline(_) |\n+            AnnotationType::MultilineStart(_) |\n+            AnnotationType::MultilineLine(_) |\n+            AnnotationType::MultilineEnd(_) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn as_start(&self) -> Annotation {\n-        let mut a = self.clone();\n-        a.annotation_type = AnnotationType::MultilineStart(self.annotation_type.depth());\n-        a.end_col = a.start_col + 1;\n-        a.label = Some(\"starting here...\".to_owned());\n-        a\n-    }\n-\n-    pub fn as_end(&self) -> Annotation {\n-        let mut a = self.clone();\n-        a.annotation_type = AnnotationType::MultilineEnd(self.annotation_type.depth());\n-        a.start_col = a.end_col - 1;\n-        a.label = match a.label {\n-            Some(l) => Some(format!(\"...ending here: {}\", l)),\n-            None => Some(\"..ending here\".to_owned()),\n-        };\n-        a\n-    }\n-\n-    pub fn as_line(&self) -> Annotation {\n-        let mut a = self.clone();\n-        a.annotation_type = AnnotationType::MultilineLine(self.annotation_type.depth());\n-        a.label = None;\n-        a\n-    }\n }\n \n #[derive(Debug)]"}, {"sha": "98e574867b491e3b35a22824cccf6bc628db06ac", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=b7982bbbe0a002272b86ed2f7f7902b2c3471087", "patch": "@@ -444,3 +444,103 @@ error: foo\n \n \"#);\n }\n+\n+#[test]\n+fn non_overlaping() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0 Z0\n+  X1 Y1 Z1\n+  X2 Y2 Z2\n+  X3 Y3 Z3\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X1\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y2\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Z3\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:6\n+  |\n+3 |     X0 Y0 Z0\n+  |  ______^ starting here...\n+4 | |   X1 Y1 Z1\n+  | |____^ ...ending here: `X` is a good letter\n+5 |     X2 Y2 Z2\n+  |  ______- starting here...\n+6 | |   X3 Y3 Z3\n+  | |__________- ...ending here: `Y` is a good letter too\n+\n+\"#);\n+}\n+#[test]\n+fn overlaping_start_and_end() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0 Z0\n+  X1 Y1 Z1\n+  X2 Y2 Z2\n+  X3 Y3 Z3\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X1\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Z1\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Z3\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:6\n+  |\n+3 |      X0 Y0 Z0\n+  |   ______^ starting here...\n+4 |  |   X1 Y1 Z1\n+  |  |____^____- starting here...\n+  | ||____|\n+  | |     ...ending here: `X` is a good letter\n+5 | |    X2 Y2 Z2\n+6 | |    X3 Y3 Z3\n+  | |___________- ...ending here: `Y` is a good letter too\n+\n+\"#);\n+}"}, {"sha": "92e2fe8e9367e855f39a4ce10dc12f7e96818753", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr?ref=b7982bbbe0a002272b86ed2f7f7902b2c3471087", "patch": "@@ -8,7 +8,7 @@ error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attri\n 35 | |     // (unsafe to access self.1  due to #[may_dangle] on A)\n 36 | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n 37 | | }\n-   | |_^ ..ending here\n+   | |_^ ...ending here\n \n error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n   --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:38:1\n@@ -20,7 +20,7 @@ error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attri\n 41 | |     // (unsafe to access self.1 due to #[may_dangle] on 'a)\n 42 | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n 43 | | }\n-   | |_^ ..ending here\n+   | |_^ ...ending here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "153aaa07833a8a08ee73586deec3859420bff3d3", "filename": "src/test/ui/lifetimes/consider-using-explicit-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr?ref=b7982bbbe0a002272b86ed2f7f7902b2c3471087", "patch": "@@ -19,7 +19,7 @@ help: consider using an explicit lifetime parameter as shown: fn from_str(path:\n    |  _____^ starting here...\n 26 | |         Ok(Foo { field: path })\n 27 | |     }\n-   | |_____^ ..ending here\n+   | |_____^ ...ending here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "451492ba6930b9f8e88d6a725fe57bed262b66b4", "filename": "src/test/ui/span/multiline-span-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.rs?ref=b7982bbbe0a002272b86ed2f7f7902b2c3471087", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     let x = 1;\n     let y = 2;\n     let z = 3;\n-    foo(1 +\n+    foo(1 as u32 +\n \n         bar(x,\n "}, {"sha": "b801325114ccd68207f6c126d150ea6e0d1f587f", "filename": "src/test/ui/span/multiline-span-simple.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7982bbbe0a002272b86ed2f7f7902b2c3471087/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr?ref=b7982bbbe0a002272b86ed2f7f7902b2c3471087", "patch": "@@ -1,20 +1,19 @@\n-error[E0277]: the trait bound `{integer}: std::ops::Add<()>` is not satisfied\n+error[E0277]: the trait bound `u32: std::ops::Add<()>` is not satisfied\n   --> $DIR/multiline-span-simple.rs:23:9\n    |\n-23 |       foo(1 +\n+23 |       foo(1 as u32 +\n    |  _________^ starting here...\n 24 | |\n 25 | |         bar(x,\n 26 | |\n 27 | |             y),\n-   | |______________^ ...ending here: the trait `std::ops::Add<()>` is not implemented for `{integer}`\n+   | |______________^ ...ending here: the trait `std::ops::Add<()>` is not implemented for `u32`\n    |\n    = help: the following implementations were found:\n    = help:   <u32 as std::ops::Add>\n    = help:   <&'a u32 as std::ops::Add<u32>>\n    = help:   <u32 as std::ops::Add<&'a u32>>\n    = help:   <&'b u32 as std::ops::Add<&'a u32>>\n-   = help: and 90 others\n \n error: aborting due to previous error\n "}]}