{"sha": "d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "node_id": "C_kwDOAAsO6NoAKGQxZWIzOGY1YjVhM2VkMDRmNTUxODk2NDFiMWQzMGVjZDg2YjRhMDE", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-05-28T10:43:51Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-03-01T00:24:11Z"}, "message": "Rewrite LLVM's archive writer in Rust\n\nThis allows it to be used by other codegen backends", "tree": {"sha": "bfb3e78f10a1c0d60741ed3c5c9dcbdb8490e9aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfb3e78f10a1c0d60741ed3c5c9dcbdb8490e9aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "html_url": "https://github.com/rust-lang/rust/commit/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "634a709549db03962700b24619253f9965ea864a", "url": "https://api.github.com/repos/rust-lang/rust/commits/634a709549db03962700b24619253f9965ea864a", "html_url": "https://github.com/rust-lang/rust/commit/634a709549db03962700b24619253f9965ea864a"}], "stats": {"total": 210, "additions": 8, "deletions": 202}, "files": [{"sha": "b2013db3e3b3260495eab593352af56a8c2d227f", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "patch": "@@ -11,12 +11,6 @@ dependencies = [\n  \"memchr\",\n ]\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n-\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -212,11 +206,9 @@ dependencies = [\n name = \"rustc_codegen_gcc\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n  \"smallvec\",\n- \"target-lexicon\",\n  \"tempfile\",\n ]\n \n@@ -235,12 +227,6 @@ version = \"1.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83\"\n \n-[[package]]\n-name = \"target-lexicon\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab0e7238dcc7b40a7be719a25365910f6807bd864f4cce6b2e6b873658e2b19d\"\n-\n [[package]]\n name = \"tempfile\"\n version = \"3.2.0\""}, {"sha": "81066d9ce1f0acd9686f452d201db46eee17bc77", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "patch": "@@ -28,9 +28,6 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n #gccjit = { path = \"../gccjit.rs\" }\n \n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n-target-lexicon = \"0.10.0\"\n-\n-ar = \"0.8.0\"\n \n [dev-dependencies]\n lang_tester = \"0.3.9\""}, {"sha": "11fa074f5ac79e81a9902d8b93c5ce9839727423", "filename": "src/archive.rs", "status": "modified", "additions": 6, "deletions": 171, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "patch": "@@ -1,44 +1,17 @@\n-use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use crate::errors::RanlibFailure;\n-\n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n use rustc_session::cstore::DllImport;\n \n-struct ArchiveConfig<'a> {\n-    sess: &'a Session,\n-    use_native_ar: bool,\n-    use_gnu_style_archive: bool,\n-}\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n-    File(PathBuf),\n-}\n-\n-pub struct ArArchiveBuilderBuilder;\n+pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        let config = ArchiveConfig {\n-            sess,\n-            use_native_ar: false,\n-            // FIXME test for linux and System V derivatives instead\n-            use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n-        };\n-\n-        Box::new(ArArchiveBuilder {\n-            config,\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -49,144 +22,6 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _tmpdir: &Path,\n         _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        unimplemented!();\n-    }\n-}\n-\n-pub struct ArArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n-        let archive_index = self.src_archives.len();\n-\n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n-                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries\n-                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n-            }\n-            i += 1;\n-        }\n-\n-        self.src_archives.push((archive_path.to_owned(), archive));\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        use std::process::Command;\n-\n-        fn add_file_using_ar(archive: &Path, file: &Path) {\n-            Command::new(\"ar\")\n-                .arg(\"r\") // add or replace file\n-                .arg(\"-c\") // silence created file message\n-                .arg(archive)\n-                .arg(&file)\n-                .status()\n-                .unwrap();\n-        }\n-\n-        enum BuilderKind<'a> {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-            NativeAr(&'a Path),\n-        }\n-\n-        let mut builder = if self.config.use_native_ar {\n-            BuilderKind::NativeAr(output)\n-        } else if self.config.use_gnu_style_archive {\n-            BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(output).unwrap(),\n-                self.entries\n-                    .iter()\n-                    .map(|(name, _)| name.as_bytes().to_vec())\n-                    .collect(),\n-            ))\n-        } else {\n-            BuilderKind::Bsd(ar::Builder::new(File::create(output).unwrap()))\n-        };\n-\n-        let any_members = !self.entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, entry) in self.entries.into_iter() {\n-            match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n-                    let (ref src_archive_path, ref mut src_archive) =\n-                        self.src_archives[archive_index];\n-                    let entry = src_archive.jump_to_entry(entry_index).unwrap();\n-                    let header = entry.header().clone();\n-\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::NativeAr(archive_file) => {\n-                            Command::new(\"ar\")\n-                                .arg(\"x\")\n-                                .arg(src_archive_path)\n-                                .arg(&entry_name)\n-                                .status()\n-                                .unwrap();\n-                            add_file_using_ar(archive_file, Path::new(&entry_name));\n-                            std::fs::remove_file(entry_name).unwrap();\n-                        }\n-                    }\n-                }\n-                ArchiveEntry::File(file) =>\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(file).expect(\"file for bsd builder\"))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(&file).expect(&format!(\"file {:?} for gnu builder\", file)))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n-                    },\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        // Run ranlib to be able to link the archive\n-        let status =\n-            std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n-\n-        if !status.success() {\n-            self.config.sess.emit_fatal(RanlibFailure::new(status.code()));\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}, {"sha": "89fed7be1315614e91331d4b2c05fb58ff320989", "filename": "src/errors.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/src%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01/src%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferrors.rs?ref=d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "patch": "@@ -16,18 +16,6 @@ impl IntoDiagnosticArg for ExitCode {\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_gcc_ranlib_failure)]\n-pub(crate) struct RanlibFailure {\n-    exit_code: ExitCode,\n-}\n-\n-impl RanlibFailure {\n-    pub fn new(exit_code: Option<i32>) -> Self {\n-        RanlibFailure { exit_code: ExitCode(exit_code) }\n-    }\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_gcc_invalid_monomorphization_basic_integer, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n@@ -227,7 +215,7 @@ pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n #[diag(codegen_gcc_linkage_const_or_mut_type)]\n pub(crate) struct LinkageConstOrMutType {\n     #[primary_span]\n-    pub span: Span\n+    pub span: Span,\n }\n \n #[derive(Diagnostic)]\n@@ -238,5 +226,5 @@ pub(crate) struct LTONotSupported;\n #[diag(codegen_gcc_unwinding_inline_asm)]\n pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n-    pub span: Span\n+    pub span: Span,\n }"}]}