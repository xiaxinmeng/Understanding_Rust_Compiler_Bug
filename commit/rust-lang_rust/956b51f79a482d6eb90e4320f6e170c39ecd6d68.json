{"sha": "956b51f79a482d6eb90e4320f6e170c39ecd6d68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NmI1MWY3OWE0ODJkNmViOTBlNDMyMGY2ZTE3MGMzOWVjZDZkNjg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-17T15:47:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T11:08:39Z"}, "message": "optimize validation iterating over the elements of an array\n\nThis is still roughly 45ns slower than the old state, because it now works with\nan MPlaceTy and uses the appropriate abstractions, instead of working with a\nptr-align pair directly.", "tree": {"sha": "31dec4dacff14c4b10836369d8c454daa18c02c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31dec4dacff14c4b10836369d8c454daa18c02c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/956b51f79a482d6eb90e4320f6e170c39ecd6d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/956b51f79a482d6eb90e4320f6e170c39ecd6d68", "html_url": "https://github.com/rust-lang/rust/commit/956b51f79a482d6eb90e4320f6e170c39ecd6d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/956b51f79a482d6eb90e4320f6e170c39ecd6d68/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f5cf1289431ceb32ec652b7c26962e2f3048263", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f5cf1289431ceb32ec652b7c26962e2f3048263", "html_url": "https://github.com/rust-lang/rust/commit/6f5cf1289431ceb32ec652b7c26962e2f3048263"}], "stats": {"total": 102, "additions": 72, "deletions": 30}, "files": [{"sha": "b7e951a78f518d724e0f6078df09c4d9df6aa9f1", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=956b51f79a482d6eb90e4320f6e170c39ecd6d68", "patch": "@@ -494,6 +494,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Byte accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+    /// This checks alignment!\n     fn get_bytes_unchecked(\n         &self,\n         ptr: Pointer,\n@@ -514,6 +515,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n+    /// This checks alignment!\n     fn get_bytes_unchecked_mut(\n         &mut self,\n         ptr: Pointer,\n@@ -551,7 +553,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0);\n         self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(ptr.into(), size, true)?;\n+        self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n     }\n }\n@@ -749,9 +751,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    /// Read a *non-ZST* scalar\n     pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, ScalarMaybeUndef> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n+        // get_bytes_unchecked tests alignment\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n@@ -784,16 +788,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n+    /// Write a *non-ZST* scalar\n     pub fn write_scalar(\n         &mut self,\n-        ptr: Scalar,\n+        ptr: Pointer,\n         ptr_align: Align,\n         val: ScalarMaybeUndef,\n         type_size: Size,\n-        type_align: Align,\n     ) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n-        self.check_align(ptr, ptr_align)?;\n \n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n@@ -806,12 +809,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 val.offset.bytes() as u128\n             }\n \n-            Scalar::Bits { size: 0, .. } => {\n-                // nothing to do for ZSTs\n-                assert_eq!(type_size.bytes(), 0);\n-                return Ok(());\n-            }\n-\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, type_size.bytes());\n                 assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n@@ -820,10 +817,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             },\n         };\n \n-        let ptr = ptr.to_ptr()?;\n-\n         {\n-            let dst = self.get_bytes_mut(ptr, type_size, ptr_align.min(type_align))?;\n+            // get_bytes_mut checks alignment\n+            let dst = self.get_bytes_mut(ptr, type_size, ptr_align)?;\n             write_target_uint(endianness, dst, bytes).unwrap();\n         }\n \n@@ -843,7 +839,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, ptr_align)\n+        self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n     }\n \n     fn int_align(&self, size: Size) -> Align {\n@@ -959,14 +955,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Scalar,\n+        ptr: Pointer,\n         size: Size,\n         new_state: bool,\n     ) -> EvalResult<'tcx> {\n         if size.bytes() == 0 {\n             return Ok(());\n         }\n-        let ptr = ptr.to_ptr()?;\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(\n             ptr.offset,"}, {"sha": "1907b2beeafcb9ee963dc553491a0070bf5fef74", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=956b51f79a482d6eb90e4320f6e170c39ecd6d68", "patch": "@@ -41,18 +41,22 @@ impl<'tcx> Value {\n         Value::ScalarPair(val.into(), Scalar::Ptr(vtable).into())\n     }\n \n+    #[inline]\n     pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef {\n         match self {\n             Value::Scalar(val) => val,\n             Value::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n         }\n     }\n \n+    #[inline]\n     pub fn to_scalar(self) -> EvalResult<'tcx, Scalar> {\n         self.to_scalar_or_undef().not_undef()\n     }\n \n     /// Convert the value into a pointer (or a pointer-sized integer).\n+    /// Throws away the second half of a ScalarPair!\n+    #[inline]\n     pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar> {\n         match self {\n             Value::Scalar(ptr) |\n@@ -89,6 +93,7 @@ pub struct ValTy<'tcx> {\n \n impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n     type Target = Value;\n+    #[inline(always)]\n     fn deref(&self) -> &Value {\n         &self.value\n     }\n@@ -141,12 +146,14 @@ pub struct OpTy<'tcx> {\n \n impl<'tcx> ::std::ops::Deref for OpTy<'tcx> {\n     type Target = Operand;\n+    #[inline(always)]\n     fn deref(&self) -> &Operand {\n         &self.op\n     }\n }\n \n impl<'tcx> From<MPlaceTy<'tcx>> for OpTy<'tcx> {\n+    #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx>) -> Self {\n         OpTy {\n             op: Operand::Indirect(*mplace),\n@@ -156,6 +163,7 @@ impl<'tcx> From<MPlaceTy<'tcx>> for OpTy<'tcx> {\n }\n \n impl<'tcx> From<ValTy<'tcx>> for OpTy<'tcx> {\n+    #[inline(always)]\n     fn from(val: ValTy<'tcx>) -> Self {\n         OpTy {\n             op: Operand::Immediate(val.value),\n@@ -192,14 +200,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return Ok(None);\n         }\n         let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n-        self.memory.check_align(ptr, ptr_align)?;\n \n         if mplace.layout.size.bytes() == 0 {\n+            // Not all ZSTs have a layout we would handle below, so just short-circuit them\n+            // all here.\n+            self.memory.check_align(ptr, ptr_align)?;\n             return Ok(Some(Value::Scalar(Scalar::zst().into())));\n         }\n \n         let ptr = ptr.to_ptr()?;\n-\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory.read_scalar(ptr, ptr_align, mplace.layout.size)?;\n@@ -264,7 +273,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // This decides which types we will use the Immediate optimization for, and hence should\n         // match what `try_read_value` and `eval_place_to_op` support.\n         if layout.is_zst() {\n-            return Ok(Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)));\n+            return Ok(Operand::Immediate(Value::Scalar(Scalar::zst().into())));\n         }\n \n         Ok(match layout.abi {"}, {"sha": "58c976086bbd8ac209e5077d70cf386ddd498cd5", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=956b51f79a482d6eb90e4320f6e170c39ecd6d68", "patch": "@@ -54,6 +54,7 @@ pub struct PlaceTy<'tcx> {\n \n impl<'tcx> ::std::ops::Deref for PlaceTy<'tcx> {\n     type Target = Place;\n+    #[inline(always)]\n     fn deref(&self) -> &Place {\n         &self.place\n     }\n@@ -68,12 +69,14 @@ pub struct MPlaceTy<'tcx> {\n \n impl<'tcx> ::std::ops::Deref for MPlaceTy<'tcx> {\n     type Target = MemPlace;\n+    #[inline(always)]\n     fn deref(&self) -> &MemPlace {\n         &self.mplace\n     }\n }\n \n impl<'tcx> From<MPlaceTy<'tcx>> for PlaceTy<'tcx> {\n+    #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx>) -> Self {\n         PlaceTy {\n             place: Place::Ptr(mplace.mplace),\n@@ -160,14 +163,15 @@ impl<'tcx> PartialEq for MPlaceTy<'tcx> {\n impl<'tcx> Eq for MPlaceTy<'tcx> {}\n \n impl<'tcx> OpTy<'tcx> {\n+    #[inline(always)]\n     pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx>, Value> {\n         match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n             Operand::Immediate(value) => Err(value),\n         }\n     }\n \n-    #[inline]\n+    #[inline(always)]\n     pub fn to_mem_place(self) -> MPlaceTy<'tcx> {\n         self.try_as_mplace().unwrap()\n     }\n@@ -311,6 +315,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(MPlaceTy { mplace: MemPlace { ptr, align, extra }, layout: field_layout })\n     }\n \n+    // Iterates over all fields of an array. Much more efficient than doing the\n+    // same by repeatedly calling `mplace_array`.\n+    pub fn mplace_array_fields(\n+        &self,\n+        base: MPlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx>>> + 'a> {\n+        let len = base.len();\n+        let stride = match base.layout.fields {\n+            layout::FieldPlacement::Array { stride, .. } => stride,\n+            _ => bug!(\"mplace_array_fields: expected an array layout\"),\n+        };\n+        let layout = base.layout.field(self, 0)?;\n+        let dl = &self.tcx.data_layout;\n+        Ok((0..len).map(move |i| {\n+            let ptr = base.ptr.ptr_offset(i * stride, dl)?;\n+            Ok(MPlaceTy {\n+                mplace: MemPlace { ptr, align: base.align, extra: PlaceExtra::None },\n+                layout\n+            })\n+        }))\n+    }\n+\n     pub fn mplace_subslice(\n         &self,\n         base: MPlaceTy<'tcx>,\n@@ -545,14 +571,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         value: Value,\n         dest: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        assert_eq!(dest.extra, PlaceExtra::None);\n+        let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n         // Note that it is really important that the type here is the right one, and matches the type things are read at.\n         // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n         // correct if we never look at this data with the wrong type.\n+\n+        // Nothing to do for ZSTs, other than checking alignment\n+        if dest.layout.size.bytes() == 0 {\n+            self.memory.check_align(ptr, ptr_align)?;\n+            return Ok(());\n+        }\n+\n+        let ptr = ptr.to_ptr()?;\n         match value {\n             Value::Scalar(scalar) => {\n                 self.memory.write_scalar(\n-                    dest.ptr, dest.align, scalar, dest.layout.size, dest.layout.align\n+                    ptr, ptr_align.min(dest.layout.align), scalar, dest.layout.size\n                 )\n             }\n             Value::ScalarPair(a_val, b_val) => {\n@@ -562,12 +596,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n                 let (a_align, b_align) = (a.align(&self), b.align(&self));\n-                let a_ptr = dest.ptr;\n                 let b_offset = a_size.abi_align(b_align);\n-                let b_ptr = a_ptr.ptr_offset(b_offset, &self)?.into();\n+                let b_ptr = ptr.offset(b_offset, &self)?.into();\n \n-                self.memory.write_scalar(a_ptr, dest.align, a_val, a_size, a_align)?;\n-                self.memory.write_scalar(b_ptr, dest.align, b_val, b_size, b_align)\n+                self.memory.write_scalar(ptr, ptr_align.min(a_align), a_val, a_size)?;\n+                self.memory.write_scalar(b_ptr, ptr_align.min(b_align), b_val, b_size)\n             }\n         }\n     }\n@@ -608,6 +641,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         let mplace = match place.place {\n             Place::Local { frame, local } => {\n+                // FIXME: Consider not doing anything for a ZST, and just returning\n+                // a fake pointer?\n+\n                 // We need the layout of the local.  We can NOT use the layout we got,\n                 // that might e.g. be a downcast variant!\n                 let local_layout = self.layout_of_local(frame, local)?;\n@@ -707,6 +743,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Every place can be read from, so we can turm them into an operand\n+    #[inline(always)]\n     pub fn place_to_op(&self, place: PlaceTy<'tcx>) -> EvalResult<'tcx, OpTy<'tcx>> {\n         let op = match place.place {\n             Place::Ptr(mplace) => {"}, {"sha": "12ea3ed09ffd76536cd7b9b6382be3a02f1f7722", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956b51f79a482d6eb90e4320f6e170c39ecd6d68/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=956b51f79a482d6eb90e4320f6e170c39ecd6d68", "patch": "@@ -124,7 +124,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    /// This function checks the memory where `ptr` points to.\n+    /// This function checks the memory where `dest` points to.  The place must be sized\n+    /// (i.e., dest.extra == PlaceExtra::None).\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     pub fn validate_mplace(\n         &self,\n@@ -205,11 +206,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n                 Ok(())\n             },\n-            layout::FieldPlacement::Array { count, .. } => {\n-                for i in 0..count {\n+            layout::FieldPlacement::Array { .. } => {\n+                for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n+                    let field = field?;\n                     let mut path = path.clone();\n                     self.dump_field_name(&mut path, dest.layout.ty, i as usize, variant).unwrap();\n-                    let field = self.mplace_field(dest, i)?;\n                     self.validate_mplace(field, path, seen, todo)?;\n                 }\n                 Ok(())"}]}