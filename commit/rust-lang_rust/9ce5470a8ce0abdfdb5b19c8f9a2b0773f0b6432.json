{"sha": "9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432", "node_id": "C_kwDOAAsO6NoAKDljZTU0NzBhOGNlMGFiZGZkYjViMTljOGY5YTJiMDc3M2YwYjY0MzI", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2021-12-21T00:59:01Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-12-21T16:55:39Z"}, "message": "refactor: move macro arg parsing to parse mod", "tree": {"sha": "29c6293e5ebd213fc53fbd236e730e59ad78d20b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29c6293e5ebd213fc53fbd236e730e59ad78d20b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432", "html_url": "https://github.com/rust-lang/rust/commit/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40b73d8feec5938a4b6d542840641eceb563930c", "url": "https://api.github.com/repos/rust-lang/rust/commits/40b73d8feec5938a4b6d542840641eceb563930c", "html_url": "https://github.com/rust-lang/rust/commit/40b73d8feec5938a4b6d542840641eceb563930c"}], "stats": {"total": 433, "additions": 234, "deletions": 199}, "files": [{"sha": "26a68dfdcf26d9b307fef61c9eb13cfb6d51eed6", "filename": "src/macros.rs", "status": "modified", "additions": 17, "deletions": 199, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432", "patch": "@@ -16,8 +16,6 @@ use rustc_ast::token::{BinOpToken, DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{Cursor, Spacing, TokenStream, TokenTree};\n use rustc_ast::{ast, ptr};\n use rustc_ast_pretty::pprust;\n-use rustc_parse::parser::{ForceCollect, Parser};\n-use rustc_parse::{stream_to_parser, MACRO_ARGUMENTS};\n use rustc_span::{\n     symbol::{self, kw},\n     BytePos, Span, Symbol, DUMMY_SP,\n@@ -30,6 +28,7 @@ use crate::config::lists::*;\n use crate::expr::{rewrite_array, rewrite_assign_rhs, RhsAssignKind};\n use crate::lists::{itemize_list, write_list, ListFormatting};\n use crate::overflow;\n+use crate::parse::macros::{build_parser, parse_macro_args, ParsedMacroArgs};\n use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::source_map::SpanUtils;\n@@ -60,7 +59,7 @@ pub(crate) enum MacroArg {\n }\n \n impl MacroArg {\n-    fn is_item(&self) -> bool {\n+    pub(crate) fn is_item(&self) -> bool {\n         match self {\n             MacroArg::Item(..) => true,\n             _ => false,\n@@ -90,61 +89,6 @@ impl Rewrite for MacroArg {\n     }\n }\n \n-fn build_parser<'a>(context: &RewriteContext<'a>, cursor: Cursor) -> Parser<'a> {\n-    stream_to_parser(\n-        context.parse_sess.inner(),\n-        cursor.collect(),\n-        MACRO_ARGUMENTS,\n-    )\n-}\n-\n-fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n-    macro_rules! parse_macro_arg {\n-        ($macro_arg:ident, $parser:expr, $f:expr) => {\n-            let mut cloned_parser = (*parser).clone();\n-            match $parser(&mut cloned_parser) {\n-                Ok(x) => {\n-                    if parser.sess.span_diagnostic.has_errors() {\n-                        parser.sess.span_diagnostic.reset_err_count();\n-                    } else {\n-                        // Parsing succeeded.\n-                        *parser = cloned_parser;\n-                        return Some(MacroArg::$macro_arg($f(x)?));\n-                    }\n-                }\n-                Err(mut e) => {\n-                    e.cancel();\n-                    parser.sess.span_diagnostic.reset_err_count();\n-                }\n-            }\n-        };\n-    }\n-\n-    parse_macro_arg!(\n-        Expr,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_expr(),\n-        |x: ptr::P<ast::Expr>| Some(x)\n-    );\n-    parse_macro_arg!(\n-        Ty,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_ty(),\n-        |x: ptr::P<ast::Ty>| Some(x)\n-    );\n-    parse_macro_arg!(\n-        Pat,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_pat_no_top_alt(None),\n-        |x: ptr::P<ast::Pat>| Some(x)\n-    );\n-    // `parse_item` returns `Option<ptr::P<ast::Item>>`.\n-    parse_macro_arg!(\n-        Item,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_item(ForceCollect::No),\n-        |x: Option<ptr::P<ast::Item>>| x\n-    );\n-\n-    None\n-}\n-\n /// Rewrite macro name without using pretty-printer if possible.\n fn rewrite_macro_name(\n     context: &RewriteContext<'_>,\n@@ -232,25 +176,6 @@ pub(crate) fn rewrite_macro(\n     }\n }\n \n-fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n-    for &keyword in RUST_KW.iter() {\n-        if parser.token.is_keyword(keyword)\n-            && parser.look_ahead(1, |t| {\n-                t.kind == TokenKind::Eof\n-                    || t.kind == TokenKind::Comma\n-                    || t.kind == TokenKind::CloseDelim(DelimToken::NoDelim)\n-            })\n-        {\n-            parser.bump();\n-            return Some(MacroArg::Keyword(\n-                symbol::Ident::with_dummy_span(keyword),\n-                parser.prev_token.span,\n-            ));\n-        }\n-    }\n-    None\n-}\n-\n fn rewrite_macro_inner(\n     mac: &ast::MacCall,\n     extra_ident: Option<symbol::Ident>,\n@@ -269,8 +194,9 @@ fn rewrite_macro_inner(\n     let original_style = macro_style(mac, context);\n \n     let macro_name = rewrite_macro_name(context, &mac.path, extra_ident);\n+    let is_forced_bracket = FORCED_BRACKET_MACROS.contains(&&macro_name[..]);\n \n-    let style = if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) && !is_nested_macro {\n+    let style = if is_forced_bracket && !is_nested_macro {\n         DelimToken::Bracket\n     } else {\n         original_style\n@@ -294,67 +220,21 @@ fn rewrite_macro_inner(\n     }\n     // Format well-known macros which cannot be parsed as a valid AST.\n     if macro_name == \"lazy_static!\" && !has_comment {\n-        if let success @ Some(..) = format_lazy_static(context, shape, &ts) {\n+        if let success @ Some(..) = format_lazy_static(context, shape, ts.trees().collect()) {\n             return success;\n         }\n     }\n \n-    let mut parser = build_parser(context, ts.trees());\n-    let mut arg_vec = Vec::new();\n-    let mut vec_with_semi = false;\n-    let mut trailing_comma = false;\n-\n-    if DelimToken::Brace != style {\n-        loop {\n-            if let Some(arg) = check_keyword(&mut parser) {\n-                arg_vec.push(arg);\n-            } else if let Some(arg) = parse_macro_arg(&mut parser) {\n-                arg_vec.push(arg);\n-            } else {\n-                return return_macro_parse_failure_fallback(context, shape.indent, mac.span());\n-            }\n-\n-            match parser.token.kind {\n-                TokenKind::Eof => break,\n-                TokenKind::Comma => (),\n-                TokenKind::Semi => {\n-                    // Try to parse `vec![expr; expr]`\n-                    if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {\n-                        parser.bump();\n-                        if parser.token.kind != TokenKind::Eof {\n-                            match parse_macro_arg(&mut parser) {\n-                                Some(arg) => {\n-                                    arg_vec.push(arg);\n-                                    parser.bump();\n-                                    if parser.token.kind == TokenKind::Eof && arg_vec.len() == 2 {\n-                                        vec_with_semi = true;\n-                                        break;\n-                                    }\n-                                }\n-                                None => {\n-                                    return return_macro_parse_failure_fallback(\n-                                        context,\n-                                        shape.indent,\n-                                        mac.span(),\n-                                    );\n-                                }\n-                            }\n-                        }\n-                    }\n-                    return return_macro_parse_failure_fallback(context, shape.indent, mac.span());\n-                }\n-                _ if arg_vec.last().map_or(false, MacroArg::is_item) => continue,\n-                _ => return return_macro_parse_failure_fallback(context, shape.indent, mac.span()),\n-            }\n-\n-            parser.bump();\n-\n-            if parser.token.kind == TokenKind::Eof {\n-                trailing_comma = true;\n-                break;\n-            }\n+    let ParsedMacroArgs {\n+        args: arg_vec,\n+        vec_with_semi,\n+        trailing_comma,\n+    } = match parse_macro_args(context, ts, style, is_forced_bracket) {\n+        Some(args) => args,\n+        None => {\n+            return return_macro_parse_failure_fallback(context, shape.indent, mac.span());\n         }\n-    }\n+    };\n \n     if !arg_vec.is_empty() && arg_vec.iter().all(MacroArg::is_item) {\n         return rewrite_macro_with_items(\n@@ -1179,7 +1059,7 @@ pub(crate) fn convert_try_mac(\n     let path = &pprust::path_to_string(&mac.path);\n     if path == \"try\" || path == \"r#try\" {\n         let ts = mac.args.inner_tokens();\n-        let mut parser = build_parser(context, ts.trees());\n+        let mut parser = build_parser(context, ts);\n \n         Some(ast::Expr {\n             id: ast::NodeId::root(), // dummy value\n@@ -1414,10 +1294,10 @@ impl MacroBranch {\n fn format_lazy_static(\n     context: &RewriteContext<'_>,\n     shape: Shape,\n-    ts: &TokenStream,\n+    ts: TokenStream,\n ) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n-    let mut parser = build_parser(context, ts.trees());\n+    let mut parser = build_parser(context, ts);\n     let nested_shape = shape\n         .block_indent(context.config.tab_spaces())\n         .with_max_width(context.config);\n@@ -1528,65 +1408,3 @@ fn rewrite_macro_with_items(\n     result.push_str(trailing_semicolon);\n     Some(result)\n }\n-\n-const RUST_KW: [Symbol; 59] = [\n-    kw::PathRoot,\n-    kw::DollarCrate,\n-    kw::Underscore,\n-    kw::As,\n-    kw::Box,\n-    kw::Break,\n-    kw::Const,\n-    kw::Continue,\n-    kw::Crate,\n-    kw::Else,\n-    kw::Enum,\n-    kw::Extern,\n-    kw::False,\n-    kw::Fn,\n-    kw::For,\n-    kw::If,\n-    kw::Impl,\n-    kw::In,\n-    kw::Let,\n-    kw::Loop,\n-    kw::Match,\n-    kw::Mod,\n-    kw::Move,\n-    kw::Mut,\n-    kw::Pub,\n-    kw::Ref,\n-    kw::Return,\n-    kw::SelfLower,\n-    kw::SelfUpper,\n-    kw::Static,\n-    kw::Struct,\n-    kw::Super,\n-    kw::Trait,\n-    kw::True,\n-    kw::Type,\n-    kw::Unsafe,\n-    kw::Use,\n-    kw::Where,\n-    kw::While,\n-    kw::Abstract,\n-    kw::Become,\n-    kw::Do,\n-    kw::Final,\n-    kw::Macro,\n-    kw::Override,\n-    kw::Priv,\n-    kw::Typeof,\n-    kw::Unsized,\n-    kw::Virtual,\n-    kw::Yield,\n-    kw::Dyn,\n-    kw::Async,\n-    kw::Try,\n-    kw::UnderscoreLifetime,\n-    kw::StaticLifetime,\n-    kw::Auto,\n-    kw::Catch,\n-    kw::Default,\n-    kw::Union,\n-];"}, {"sha": "e7844c9a4dce21dd2846bb81296b07820980273a", "filename": "src/parse/macros/mod.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432/src%2Fparse%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432/src%2Fparse%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Fmod.rs?ref=9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432", "patch": "@@ -0,0 +1,216 @@\n+use rustc_ast::token::{BinOpToken, DelimToken, Token, TokenKind};\n+use rustc_ast::tokenstream::{Cursor, Spacing, TokenStream, TokenTree};\n+use rustc_ast::{ast, ptr};\n+use rustc_parse::parser::{ForceCollect, Parser};\n+use rustc_parse::{stream_to_parser, MACRO_ARGUMENTS};\n+use rustc_span::{\n+    symbol::{self, kw},\n+    BytePos, Span, Symbol, DUMMY_SP,\n+};\n+\n+use crate::macros::MacroArg;\n+use crate::rewrite::{Rewrite, RewriteContext};\n+\n+pub(crate) fn build_parser<'a>(context: &RewriteContext<'a>, tokens: TokenStream) -> Parser<'a> {\n+    stream_to_parser(context.parse_sess.inner(), tokens, MACRO_ARGUMENTS)\n+}\n+\n+fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n+    macro_rules! parse_macro_arg {\n+        ($macro_arg:ident, $parser:expr, $f:expr) => {\n+            let mut cloned_parser = (*parser).clone();\n+            match $parser(&mut cloned_parser) {\n+                Ok(x) => {\n+                    if parser.sess.span_diagnostic.has_errors() {\n+                        parser.sess.span_diagnostic.reset_err_count();\n+                    } else {\n+                        // Parsing succeeded.\n+                        *parser = cloned_parser;\n+                        return Some(MacroArg::$macro_arg($f(x)?));\n+                    }\n+                }\n+                Err(mut e) => {\n+                    e.cancel();\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                }\n+            }\n+        };\n+    }\n+\n+    parse_macro_arg!(\n+        Expr,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_expr(),\n+        |x: ptr::P<ast::Expr>| Some(x)\n+    );\n+    parse_macro_arg!(\n+        Ty,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_ty(),\n+        |x: ptr::P<ast::Ty>| Some(x)\n+    );\n+    parse_macro_arg!(\n+        Pat,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_pat_no_top_alt(None),\n+        |x: ptr::P<ast::Pat>| Some(x)\n+    );\n+    // `parse_item` returns `Option<ptr::P<ast::Item>>`.\n+    parse_macro_arg!(\n+        Item,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_item(ForceCollect::No),\n+        |x: Option<ptr::P<ast::Item>>| x\n+    );\n+\n+    None\n+}\n+\n+pub(crate) struct ParsedMacroArgs {\n+    pub(crate) vec_with_semi: bool,\n+    pub(crate) trailing_comma: bool,\n+    pub(crate) args: Vec<MacroArg>,\n+}\n+\n+fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n+    for &keyword in RUST_KW.iter() {\n+        if parser.token.is_keyword(keyword)\n+            && parser.look_ahead(1, |t| {\n+                t.kind == TokenKind::Eof\n+                    || t.kind == TokenKind::Comma\n+                    || t.kind == TokenKind::CloseDelim(DelimToken::NoDelim)\n+            })\n+        {\n+            parser.bump();\n+            return Some(MacroArg::Keyword(\n+                symbol::Ident::with_dummy_span(keyword),\n+                parser.prev_token.span,\n+            ));\n+        }\n+    }\n+    None\n+}\n+\n+pub(crate) fn parse_macro_args(\n+    context: &RewriteContext<'_>,\n+    tokens: TokenStream,\n+    style: DelimToken,\n+    forced_bracket: bool,\n+) -> Option<ParsedMacroArgs> {\n+    let mut parser = build_parser(context, tokens);\n+    let mut args = Vec::new();\n+    let mut vec_with_semi = false;\n+    let mut trailing_comma = false;\n+\n+    if DelimToken::Brace != style {\n+        loop {\n+            if let Some(arg) = check_keyword(&mut parser) {\n+                args.push(arg);\n+            } else if let Some(arg) = parse_macro_arg(&mut parser) {\n+                args.push(arg);\n+            } else {\n+                return None;\n+            }\n+\n+            match parser.token.kind {\n+                TokenKind::Eof => break,\n+                TokenKind::Comma => (),\n+                TokenKind::Semi => {\n+                    // Try to parse `vec![expr; expr]`\n+                    if forced_bracket {\n+                        parser.bump();\n+                        if parser.token.kind != TokenKind::Eof {\n+                            match parse_macro_arg(&mut parser) {\n+                                Some(arg) => {\n+                                    args.push(arg);\n+                                    parser.bump();\n+                                    if parser.token.kind == TokenKind::Eof && args.len() == 2 {\n+                                        vec_with_semi = true;\n+                                        break;\n+                                    }\n+                                }\n+                                None => {\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    return None;\n+                }\n+                _ if args.last().map_or(false, MacroArg::is_item) => continue,\n+                _ => return None,\n+            }\n+\n+            parser.bump();\n+\n+            if parser.token.kind == TokenKind::Eof {\n+                trailing_comma = true;\n+                break;\n+            }\n+        }\n+    }\n+\n+    Some(ParsedMacroArgs {\n+        vec_with_semi,\n+        trailing_comma,\n+        args,\n+    })\n+}\n+\n+const RUST_KW: [Symbol; 59] = [\n+    kw::PathRoot,\n+    kw::DollarCrate,\n+    kw::Underscore,\n+    kw::As,\n+    kw::Box,\n+    kw::Break,\n+    kw::Const,\n+    kw::Continue,\n+    kw::Crate,\n+    kw::Else,\n+    kw::Enum,\n+    kw::Extern,\n+    kw::False,\n+    kw::Fn,\n+    kw::For,\n+    kw::If,\n+    kw::Impl,\n+    kw::In,\n+    kw::Let,\n+    kw::Loop,\n+    kw::Match,\n+    kw::Mod,\n+    kw::Move,\n+    kw::Mut,\n+    kw::Pub,\n+    kw::Ref,\n+    kw::Return,\n+    kw::SelfLower,\n+    kw::SelfUpper,\n+    kw::Static,\n+    kw::Struct,\n+    kw::Super,\n+    kw::Trait,\n+    kw::True,\n+    kw::Type,\n+    kw::Unsafe,\n+    kw::Use,\n+    kw::Where,\n+    kw::While,\n+    kw::Abstract,\n+    kw::Become,\n+    kw::Do,\n+    kw::Final,\n+    kw::Macro,\n+    kw::Override,\n+    kw::Priv,\n+    kw::Typeof,\n+    kw::Unsized,\n+    kw::Virtual,\n+    kw::Yield,\n+    kw::Dyn,\n+    kw::Async,\n+    kw::Try,\n+    kw::UnderscoreLifetime,\n+    kw::StaticLifetime,\n+    kw::Auto,\n+    kw::Catch,\n+    kw::Default,\n+    kw::Union,\n+];"}, {"sha": "5e88826ea8cc5f6f9470d53069989b02b74967c1", "filename": "src/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432/src%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432/src%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmod.rs?ref=9ce5470a8ce0abdfdb5b19c8f9a2b0773f0b6432", "patch": "@@ -1,2 +1,3 @@\n+pub(crate) mod macros;\n pub(crate) mod parser;\n pub(crate) mod session;"}]}