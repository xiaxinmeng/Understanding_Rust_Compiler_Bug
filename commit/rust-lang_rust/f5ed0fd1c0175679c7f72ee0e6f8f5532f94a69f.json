{"sha": "f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZWQwZmQxYzAxNzU2NzljN2Y3MmVlMGU2ZjhmNTUzMmY5NGE2OWY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-13T15:22:12Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-13T23:44:45Z"}, "message": "Move `Cache` generation to separate module", "tree": {"sha": "5f08596512dbe0ca0a1ff968fec37229ab525630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f08596512dbe0ca0a1ff968fec37229ab525630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "html_url": "https://github.com/rust-lang/rust/commit/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4bb5a7c1a3183f1af14695a48258331b0360860", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4bb5a7c1a3183f1af14695a48258331b0360860", "html_url": "https://github.com/rust-lang/rust/commit/f4bb5a7c1a3183f1af14695a48258331b0360860"}], "stats": {"total": 1343, "additions": 689, "deletions": 654}, "files": [{"sha": "ff7134ab7c0d5265adbe8720c2e785a37e6e06be", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 654, "changes": 668, "blob_url": "https://github.com/rust-lang/rust/blob/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "patch": "@@ -25,8 +25,6 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-pub use self::ExternalLocation::*;\n-\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n@@ -38,7 +36,6 @@ use std::ffi::OsStr;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n-use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n use std::sync::Arc;\n@@ -52,7 +49,7 @@ use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::{Symbol, sym};\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n@@ -63,7 +60,6 @@ use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutabilit\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n-use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n use crate::html::format::{Buffer, PrintWithSpace, print_abi_with_space};\n use crate::html::format::{print_generic_bounds, WhereClause, href, print_default_space};\n@@ -79,6 +75,11 @@ use minifier;\n #[cfg(test)]\n mod tests;\n \n+mod cache;\n+\n+use cache::Cache;\n+crate use cache::ExternalLocation::{self, *};\n+\n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n \n@@ -234,16 +235,6 @@ impl SharedContext {\n     }\n }\n \n-/// Indicates where an external crate can be found.\n-pub enum ExternalLocation {\n-    /// Remote URL root of the external crate\n-    Remote(String),\n-    /// This external crate can be found in the local doc/ folder\n-    Local,\n-    /// The external crate could not be found.\n-    Unknown,\n-}\n-\n /// Metadata about implementations for a type or trait.\n #[derive(Clone, Debug)]\n pub struct Impl {\n@@ -263,106 +254,6 @@ impl Impl {\n     }\n }\n \n-/// This cache is used to store information about the `clean::Crate` being\n-/// rendered in order to provide more useful documentation. This contains\n-/// information like all implementors of a trait, all traits a type implements,\n-/// documentation for all known traits, etc.\n-///\n-/// This structure purposefully does not implement `Clone` because it's intended\n-/// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering threads.\n-#[derive(Default)]\n-pub struct Cache {\n-    /// Maps a type ID to all known implementations for that type. This is only\n-    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n-    /// out extra documentation on the page of an enum/struct.\n-    ///\n-    /// The values of the map are a list of implementations and documentation\n-    /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Maintains a mapping of local crate `NodeId`s to the fully qualified name\n-    /// and \"short type description\" of that node. This is used when generating\n-    /// URLs when a type is being linked to. External paths are not located in\n-    /// this map because the `External` type itself has all the information\n-    /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Similar to `paths`, but only holds external paths. This is only used for\n-    /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Maps local `DefId`s of exported types to fully qualified paths.\n-    /// Unlike 'paths', this mapping ignores any renames that occur\n-    /// due to 'use' statements.\n-    ///\n-    /// This map is used when writing out the special 'implementors'\n-    /// javascript file. By using the exact path that the type\n-    /// is declared with, we ensure that each path will be identical\n-    /// to the path used if the corresponding type is inlined. By\n-    /// doing this, we can detect duplicate impls on a trait page, and only display\n-    /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-\n-    /// This map contains information about all known traits of this crate.\n-    /// Implementations of a crate should inherit the documentation of the\n-    /// parent trait if no extra documentation is specified, and default methods\n-    /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n-\n-    /// When rendering traits, it's often useful to be able to list all\n-    /// implementors of the trait, and this mapping is exactly, that: a mapping\n-    /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n-\n-    /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n-\n-    // Note that external items for which `doc(hidden)` applies to are shown as\n-    // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n-\n-    /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n-\n-    // Private fields only used when initially crawling a crate to build a cache\n-\n-    stack: Vec<String>,\n-    parent_stack: Vec<DefId>,\n-    parent_is_trait_impl: bool,\n-    search_index: Vec<IndexItem>,\n-    stripped_mod: bool,\n-    deref_trait_did: Option<DefId>,\n-    deref_mut_trait_did: Option<DefId>,\n-    owned_box_did: Option<DefId>,\n-    masked_crates: FxHashSet<CrateNum>,\n-\n-    // In rare case where a structure is defined in one module but implemented\n-    // in another, if the implementing module is parsed before defining module,\n-    // then the fully qualified name of the structure isn't presented in `paths`\n-    // yet when its implementation methods are being indexed. Caches such methods\n-    // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_impl_items: Vec<(DefId, clean::Item)>,\n-\n-    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n-    // even though the trait itself is not exported. This can happen if a trait\n-    // was defined in function/expression scope, since the impl will be picked\n-    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n-    // crawl. In order to prevent crashes when looking for spotlight traits or\n-    // when gathering trait documentation on a type, hold impls here while\n-    // folding and add them to the cache later on if we find the trait.\n-    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n-\n-    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n-    /// we need the alias element to have an array of items.\n-    aliases: FxHashMap<String, Vec<IndexItem>>,\n-}\n-\n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default)]\n@@ -594,89 +485,13 @@ pub fn run(mut krate: clean::Crate,\n         shared: Arc::new(scx),\n     };\n \n-    // Crawl the crate to build various caches used for the output\n-    let RenderInfo {\n-        inlined: _,\n-        external_paths,\n-        exact_paths,\n-        access_levels,\n-        deref_trait_did,\n-        deref_mut_trait_did,\n-        owned_box_did,\n-    } = renderinfo;\n-\n-    let external_paths = external_paths.into_iter()\n-        .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n-        .collect();\n-\n-    let mut cache = Cache {\n-        impls: Default::default(),\n-        external_paths,\n-        exact_paths,\n-        paths: Default::default(),\n-        implementors: Default::default(),\n-        stack: Vec::new(),\n-        parent_stack: Vec::new(),\n-        search_index: Vec::new(),\n-        parent_is_trait_impl: false,\n-        extern_locations: Default::default(),\n-        primitive_locations: Default::default(),\n-        stripped_mod: false,\n-        access_levels,\n-        crate_version: krate.version.take(),\n-        orphan_impl_items: Vec::new(),\n-        orphan_trait_impls: Vec::new(),\n-        traits: krate.external_traits.replace(Default::default()),\n-        deref_trait_did,\n-        deref_mut_trait_did,\n-        owned_box_did,\n-        masked_crates: mem::take(&mut krate.masked_crates),\n-        aliases: Default::default(),\n-    };\n-\n-    // Cache where all our extern crates are located\n-    for &(n, ref e) in &krate.externs {\n-        let src_root = match e.src {\n-            FileName::Real(ref p) => match p.parent() {\n-                Some(p) => p.to_path_buf(),\n-                None => PathBuf::new(),\n-            },\n-            _ => PathBuf::new(),\n-        };\n-        let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n-        cache.extern_locations.insert(n, (e.name.clone(), src_root,\n-                                          extern_location(e, extern_url, &cx.dst)));\n-\n-        let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-        cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n-    }\n-\n-    // Cache where all known primitives have their documentation located.\n-    //\n-    // Favor linking to as local extern as possible, so iterate all crates in\n-    // reverse topological order.\n-    for &(_, ref e) in krate.externs.iter().rev() {\n-        for &(def_id, prim, _) in &e.primitives {\n-            cache.primitive_locations.insert(prim, def_id);\n-        }\n-    }\n-    for &(def_id, prim, _) in &krate.primitives {\n-        cache.primitive_locations.insert(prim, def_id);\n-    }\n-\n-    cache.stack.push(krate.name.clone());\n-    krate = cache.fold_crate(krate);\n-\n-    for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n-        if cache.traits.contains_key(&trait_did) {\n-            for did in dids {\n-                cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n-            }\n-        }\n-    }\n-\n-    // Build our search index\n-    let index = build_index(&krate, &mut cache);\n+    let (new_crate, index, cache) = Cache::from_krate(\n+        renderinfo,\n+        &extern_html_root_urls,\n+        &cx.dst,\n+        krate,\n+    );\n+    krate = new_crate;\n \n     // Freeze the cache now that the index has been built. Put an Arc into TLS\n     // for future parallelization opportunities\n@@ -701,76 +516,6 @@ pub fn run(mut krate: clean::Crate,\n     }\n }\n \n-/// Builds the search index from the collected metadata\n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n-    let mut nodeid_to_pathid = FxHashMap::default();\n-    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n-    let mut crate_paths = Vec::<Json>::new();\n-\n-    let Cache { ref mut search_index,\n-                ref orphan_impl_items,\n-                ref mut paths, .. } = *cache;\n-\n-    // Attach all orphan items to the type's definition if the type\n-    // has since been learned.\n-    for &(did, ref item) in orphan_impl_items {\n-        if let Some(&(ref fqp, _)) = paths.get(&did) {\n-            search_index.push(IndexItem {\n-                ty: item.type_(),\n-                name: item.name.clone().unwrap(),\n-                path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: shorten(plain_summary_line(item.doc_value())),\n-                parent: Some(did),\n-                parent_idx: None,\n-                search_type: get_index_search_type(&item),\n-            });\n-        }\n-    }\n-\n-    // Reduce `NodeId` in paths into smaller sequential numbers,\n-    // and prune the paths that do not appear in the index.\n-    let mut lastpath = String::new();\n-    let mut lastpathid = 0usize;\n-\n-    for item in search_index {\n-        item.parent_idx = item.parent.map(|nodeid| {\n-            if nodeid_to_pathid.contains_key(&nodeid) {\n-                *nodeid_to_pathid.get(&nodeid).unwrap()\n-            } else {\n-                let pathid = lastpathid;\n-                nodeid_to_pathid.insert(nodeid, pathid);\n-                lastpathid += 1;\n-\n-                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n-                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n-                pathid\n-            }\n-        });\n-\n-        // Omit the parent path if it is same to that of the prior item.\n-        if lastpath == item.path {\n-            item.path.clear();\n-        } else {\n-            lastpath = item.path.clone();\n-        }\n-        crate_items.push(item.to_json());\n-    }\n-\n-    let crate_doc = krate.module.as_ref().map(|module| {\n-        shorten(plain_summary_line(module.doc_value()))\n-    }).unwrap_or(String::new());\n-\n-    let mut crate_data = BTreeMap::new();\n-    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n-    crate_data.insert(\"i\".to_owned(), Json::Array(crate_items));\n-    crate_data.insert(\"p\".to_owned(), Json::Array(crate_paths));\n-\n-    // Collect the index into a string\n-    format!(\"searchIndex[{}] = {};\",\n-            as_json(&krate.name),\n-            Json::Object(crate_data))\n-}\n-\n fn write_shared(\n     cx: &Context,\n     krate: &clean::Crate,\n@@ -1327,327 +1072,6 @@ fn minify_replacer(\n     }\n }\n \n-/// Attempts to find where an external crate is located, given that we're\n-/// rendering in to the specified source destination.\n-fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n-    -> ExternalLocation\n-{\n-    // See if there's documentation generated into the local directory\n-    let local_location = dst.join(&e.name);\n-    if local_location.is_dir() {\n-        return Local;\n-    }\n-\n-    if let Some(url) = extern_url {\n-        let mut url = url.to_string();\n-        if !url.ends_with(\"/\") {\n-            url.push('/');\n-        }\n-        return Remote(url);\n-    }\n-\n-    // Failing that, see if there's an attribute specifying where to find this\n-    // external crate\n-    e.attrs.lists(sym::doc)\n-     .filter(|a| a.check_name(sym::html_root_url))\n-     .filter_map(|a| a.value_str())\n-     .map(|url| {\n-        let mut url = url.to_string();\n-        if !url.ends_with(\"/\") {\n-            url.push('/')\n-        }\n-        Remote(url)\n-    }).next().unwrap_or(Unknown) // Well, at least we tried.\n-}\n-\n-impl DocFolder for Cache {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n-        }\n-\n-        // If this is a stripped module,\n-        // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n-            clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n-            }\n-            _ => self.stripped_mod,\n-        };\n-\n-        // If the impl is from a masked crate or references something from a\n-        // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if self.masked_crates.contains(&item.def_id.krate) ||\n-               i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) ||\n-               i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) {\n-                return None;\n-            }\n-        }\n-\n-        // Propagate a trait method's documentation to all implementors of the\n-        // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n-        }\n-\n-        // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(did) = i.trait_.def_id() {\n-                if i.blanket_impl.is_none() {\n-                    self.implementors.entry(did).or_default().push(Impl {\n-                        impl_item: item.clone(),\n-                    });\n-                }\n-            }\n-        }\n-\n-        // Index this method for searching later on.\n-        if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n-                clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) |\n-                clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n-                    // skip associated items in trait impls\n-                    ((None, None), false)\n-                }\n-                clean::AssocTypeItem(..) |\n-                clean::TyMethodItem(..) |\n-                clean::StructFieldItem(..) |\n-                clean::VariantItem(..) => {\n-                    ((Some(*self.parent_stack.last().unwrap()),\n-                      Some(&self.stack[..self.stack.len() - 1])),\n-                     false)\n-                }\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n-                        ((None, None), false)\n-                    } else {\n-                        let last = self.parent_stack.last().unwrap();\n-                        let did = *last;\n-                        let path = match self.paths.get(&did) {\n-                            // The current stack not necessarily has correlation\n-                            // for where the type was defined. On the other\n-                            // hand, `paths` always has the right\n-                            // information if present.\n-                            Some(&(ref fqp, ItemType::Trait)) |\n-                            Some(&(ref fqp, ItemType::Struct)) |\n-                            Some(&(ref fqp, ItemType::Union)) |\n-                            Some(&(ref fqp, ItemType::Enum)) =>\n-                                Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n-                            None => None\n-                        };\n-                        ((Some(*last), path), true)\n-                    }\n-                }\n-                _ => ((None, Some(&*self.stack)), false)\n-            };\n-\n-            match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n-                    debug_assert!(!item.is_stripped());\n-\n-                    // A crate has a module at its root, containing all items,\n-                    // which should not be indexed. The crate-item itself is\n-                    // inserted later on when serializing the search-index.\n-                    if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n-                            ty: item.type_(),\n-                            name: s.to_string(),\n-                            path: path.join(\"::\"),\n-                            desc: shorten(plain_summary_line(item.doc_value())),\n-                            parent,\n-                            parent_idx: None,\n-                            search_type: get_index_search_type(&item),\n-                        });\n-                    }\n-                }\n-                (Some(parent), None) if is_inherent_impl_item => {\n-                    // We have a parent, but we don't know where they're\n-                    // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        // Keep track of the fully qualified path for this item.\n-        let pushed = match item.name {\n-            Some(ref n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        match item.inner {\n-            clean::StructItem(..) | clean::EnumItem(..) |\n-            clean::TypedefItem(..) | clean::TraitItem(..) |\n-            clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) | clean::StaticItem(..) |\n-            clean::UnionItem(..) | clean::ForeignTypeItem |\n-            clean::MacroItem(..) | clean::ProcMacroItem(..)\n-            if !self.stripped_mod => {\n-                // Re-exported items mean that the same id can show up twice\n-                // in the rustdoc ast that we're looking at. We know,\n-                // however, that a re-exported item doesn't show up in the\n-                // `public_items` map, so we can skip inserting into the\n-                // paths map if there was already an entry present and we're\n-                // not a public item.\n-                if !self.paths.contains_key(&item.def_id) ||\n-                   self.access_levels.is_public(item.def_id)\n-                {\n-                    self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), item.type_()));\n-                }\n-                self.add_aliases(&item);\n-            }\n-            // Link variants to their parent enum because pages aren't emitted\n-            // for each variant.\n-            clean::VariantItem(..) if !self.stripped_mod => {\n-                let mut stack = self.stack.clone();\n-                stack.pop();\n-                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n-            }\n-\n-            clean::PrimitiveItem(..) => {\n-                self.add_aliases(&item);\n-                self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                item.type_()));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n-            clean::TraitItem(..) | clean::EnumItem(..) | clean::ForeignTypeItem |\n-            clean::StructItem(..) | clean::UnionItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::ResolvedPath{ did, .. } => {\n-                        self.parent_stack.push(did);\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t.primitive_type().and_then(|t| {\n-                            self.primitive_locations.get(&t).cloned()\n-                        });\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n-            }\n-            _ => false\n-        };\n-\n-        // Once we've recursively found all the generics, hoard off all the\n-        // implementations elsewhere.\n-        let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n-                // Figure out the id of this impl. This may map to a\n-                // primitive rather than always to a struct/enum.\n-                // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n-                    match i.for_ {\n-                        clean::ResolvedPath { did, .. } |\n-                        clean::BorrowedRef {\n-                            type_: box clean::ResolvedPath { did, .. }, ..\n-                        } => {\n-                            dids.insert(did);\n-                        }\n-                        ref t => {\n-                            let did = t.primitive_type().and_then(|t| {\n-                                self.primitive_locations.get(&t).cloned()\n-                            });\n-\n-                            if let Some(did) = did {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                        for bound in generics {\n-                            if let Some(did) = bound.def_id() {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    unreachable!()\n-                };\n-                let impl_item = Impl {\n-                    impl_item: item,\n-                };\n-                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n-                    for did in dids {\n-                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n-                    }\n-                } else {\n-                    let trait_did = impl_item.trait_did().unwrap();\n-                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n-                }\n-                None\n-            } else {\n-                Some(item)\n-            }\n-        });\n-\n-        if pushed { self.stack.pop().unwrap(); }\n-        if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n-        ret\n-    }\n-}\n-\n-impl Cache {\n-    fn add_aliases(&mut self, item: &clean::Item) {\n-        if item.def_id.index == CRATE_DEF_INDEX {\n-            return\n-        }\n-        if let Some(ref item_name) = item.name {\n-            let path = self.paths.get(&item.def_id)\n-                                 .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n-                                 .unwrap_or(\"std\".to_owned());\n-            for alias in item.attrs.lists(sym::doc)\n-                                   .filter(|a| a.check_name(sym::alias))\n-                                   .filter_map(|a| a.value_str()\n-                                                    .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n-                                   .filter(|v| !v.is_empty())\n-                                   .collect::<FxHashSet<_>>()\n-                                   .into_iter() {\n-                self.aliases.entry(alias)\n-                            .or_insert(Vec::with_capacity(1))\n-                            .push(IndexItem {\n-                                ty: item.type_(),\n-                                name: item_name.to_string(),\n-                                path: path.clone(),\n-                                desc: shorten(plain_summary_line(item.doc_value())),\n-                                parent: None,\n-                                parent_idx: None,\n-                                search_type: get_index_search_type(&item),\n-                            });\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Eq, PartialEq, Hash)]\n struct ItemEntry {\n     url: String,\n@@ -4805,37 +4229,6 @@ fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n }\n \n-fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let (all_types, ret_types) = match item.inner {\n-        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n-        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n-        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n-        _ => return None,\n-    };\n-\n-    let inputs = all_types.iter().map(|arg| {\n-        get_index_type(&arg)\n-    }).filter(|a| a.name.is_some()).collect();\n-    let output = ret_types.iter().map(|arg| {\n-        get_index_type(&arg)\n-    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n-    let output = if output.is_empty() {\n-        None\n-    } else {\n-        Some(output)\n-    };\n-\n-    Some(IndexItemFunctionType { inputs, output })\n-}\n-\n-fn get_index_type(clean_type: &clean::Type) -> Type {\n-    let t = Type {\n-        name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n-        generics: get_generics(clean_type),\n-    };\n-    t\n-}\n-\n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls\n /// for reexported types. If any of the contained\n@@ -4893,39 +4286,6 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n     out\n }\n \n-fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n-    match *clean_type {\n-        clean::ResolvedPath { ref path, .. } => {\n-            let segments = &path.segments;\n-            let path_segment = segments.into_iter().last().unwrap_or_else(|| panic!(\n-                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n-                clean_type, accept_generic\n-            ));\n-            Some(path_segment.name.clone())\n-        }\n-        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n-        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n-        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n-        // FIXME: add all from clean::Type.\n-        _ => None\n-    }\n-}\n-\n-fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n-    clean_type.generics()\n-              .and_then(|types| {\n-                  let r = types.iter()\n-                               .filter_map(|t| get_index_type_name(t, false))\n-                               .map(|s| s.to_ascii_lowercase())\n-                               .collect::<Vec<_>>();\n-                  if r.is_empty() {\n-                      None\n-                  } else {\n-                      Some(r)\n-                  }\n-              })\n-}\n-\n-pub fn cache() -> Arc<Cache> {\n+crate fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }"}, {"sha": "e9f0955c54126639630d0dc5321fef65c409bda1", "filename": "src/librustdoc/html/render/cache.rs", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "patch": "@@ -0,0 +1,675 @@\n+use crate::clean::{self, GetDefId, AttributesExt};\n+use crate::fold::DocFolder;\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::middle::privacy::AccessLevels;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::collections::BTreeMap;\n+use syntax::source_map::FileName;\n+use syntax::symbol::sym;\n+use serialize::json::{ToJson, Json, as_json};\n+\n+use super::{ItemType, IndexItem, IndexItemFunctionType, Impl, shorten, plain_summary_line};\n+use super::{Type, RenderInfo};\n+\n+/// Indicates where an external crate can be found.\n+pub enum ExternalLocation {\n+    /// Remote URL root of the external crate\n+    Remote(String),\n+    /// This external crate can be found in the local doc/ folder\n+    Local,\n+    /// The external crate could not be found.\n+    Unknown,\n+}\n+\n+/// This cache is used to store information about the `clean::Crate` being\n+/// rendered in order to provide more useful documentation. This contains\n+/// information like all implementors of a trait, all traits a type implements,\n+/// documentation for all known traits, etc.\n+///\n+/// This structure purposefully does not implement `Clone` because it's intended\n+/// to be a fairly large and expensive structure to clone. Instead this adheres\n+/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n+/// rendering threads.\n+#[derive(Default)]\n+crate struct Cache {\n+    /// Maps a type ID to all known implementations for that type. This is only\n+    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n+    /// out extra documentation on the page of an enum/struct.\n+    ///\n+    /// The values of the map are a list of implementations and documentation\n+    /// found on that implementation.\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Maintains a mapping of local crate `NodeId`s to the fully qualified name\n+    /// and \"short type description\" of that node. This is used when generating\n+    /// URLs when a type is being linked to. External paths are not located in\n+    /// this map because the `External` type itself has all the information\n+    /// necessary.\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Maps local `DefId`s of exported types to fully qualified paths.\n+    /// Unlike 'paths', this mapping ignores any renames that occur\n+    /// due to 'use' statements.\n+    ///\n+    /// This map is used when writing out the special 'implementors'\n+    /// javascript file. By using the exact path that the type\n+    /// is declared with, we ensure that each path will be identical\n+    /// to the path used if the corresponding type is inlined. By\n+    /// doing this, we can detect duplicate impls on a trait page, and only display\n+    /// the impl for the inlined type.\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+\n+    /// This map contains information about all known traits of this crate.\n+    /// Implementations of a crate should inherit the documentation of the\n+    /// parent trait if no extra documentation is specified, and default methods\n+    /// should show up in documentation about trait implementations.\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n+\n+    /// When rendering traits, it's often useful to be able to list all\n+    /// implementors of the trait, and this mapping is exactly, that: a mapping\n+    /// of trait ids to the list of known implementors of the trait\n+    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Cache of where external crate documentation can be found.\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+\n+    /// Cache of where documentation for primitives can be found.\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+\n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from the privacy check pass.\n+    pub access_levels: AccessLevels<DefId>,\n+\n+    /// The version of the crate being documented, if given from the `--crate-version` flag.\n+    pub crate_version: Option<String>,\n+\n+    // Private fields only used when initially crawling a crate to build a cache\n+\n+    stack: Vec<String>,\n+    parent_stack: Vec<DefId>,\n+    parent_is_trait_impl: bool,\n+    search_index: Vec<IndexItem>,\n+    stripped_mod: bool,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+    masked_crates: FxHashSet<CrateNum>,\n+\n+    // In rare case where a structure is defined in one module but implemented\n+    // in another, if the implementing module is parsed before defining module,\n+    // then the fully qualified name of the structure isn't presented in `paths`\n+    // yet when its implementation methods are being indexed. Caches such methods\n+    // and their parent id here and indexes them at the end of crate parsing.\n+    orphan_impl_items: Vec<(DefId, clean::Item)>,\n+\n+    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n+    // even though the trait itself is not exported. This can happen if a trait\n+    // was defined in function/expression scope, since the impl will be picked\n+    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n+    // crawl. In order to prevent crashes when looking for spotlight traits or\n+    // when gathering trait documentation on a type, hold impls here while\n+    // folding and add them to the cache later on if we find the trait.\n+    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n+    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n+    /// we need the alias element to have an array of items.\n+    pub(super) aliases: FxHashMap<String, Vec<IndexItem>>,\n+}\n+\n+impl Cache {\n+    pub fn from_krate(\n+        renderinfo: RenderInfo,\n+        extern_html_root_urls: &BTreeMap<String, String>,\n+        dst: &Path,\n+        mut krate: clean::Crate,\n+    ) -> (clean::Crate, String, Cache) {\n+        // Crawl the crate to build various caches used for the output\n+        let RenderInfo {\n+            inlined: _,\n+            external_paths,\n+            exact_paths,\n+            access_levels,\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+        } = renderinfo;\n+\n+        let external_paths = external_paths.into_iter()\n+            .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n+            .collect();\n+\n+        let mut cache = Cache {\n+            impls: Default::default(),\n+            external_paths,\n+            exact_paths,\n+            paths: Default::default(),\n+            implementors: Default::default(),\n+            stack: Vec::new(),\n+            parent_stack: Vec::new(),\n+            search_index: Vec::new(),\n+            parent_is_trait_impl: false,\n+            extern_locations: Default::default(),\n+            primitive_locations: Default::default(),\n+            stripped_mod: false,\n+            access_levels,\n+            crate_version: krate.version.take(),\n+            orphan_impl_items: Vec::new(),\n+            orphan_trait_impls: Vec::new(),\n+            traits: krate.external_traits.replace(Default::default()),\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            masked_crates: mem::take(&mut krate.masked_crates),\n+            aliases: Default::default(),\n+        };\n+\n+        // Cache where all our extern crates are located\n+        for &(n, ref e) in &krate.externs {\n+            let src_root = match e.src {\n+                FileName::Real(ref p) => match p.parent() {\n+                    Some(p) => p.to_path_buf(),\n+                    None => PathBuf::new(),\n+                },\n+                _ => PathBuf::new(),\n+            };\n+            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n+            cache.extern_locations.insert(n, (e.name.clone(), src_root,\n+                                            extern_location(e, extern_url, &dst)));\n+\n+            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n+            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        }\n+\n+        // Cache where all known primitives have their documentation located.\n+        //\n+        // Favor linking to as local extern as possible, so iterate all crates in\n+        // reverse topological order.\n+        for &(_, ref e) in krate.externs.iter().rev() {\n+            for &(def_id, prim, _) in &e.primitives {\n+                cache.primitive_locations.insert(prim, def_id);\n+            }\n+        }\n+        for &(def_id, prim, _) in &krate.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n+        }\n+\n+        cache.stack.push(krate.name.clone());\n+        krate = cache.fold_crate(krate);\n+\n+        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n+            if cache.traits.contains_key(&trait_did) {\n+                for did in dids {\n+                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n+                }\n+            }\n+        }\n+\n+        // Build our search index\n+        let index = build_index(&krate, &mut cache);\n+\n+        (krate, index, cache)\n+    }\n+}\n+\n+impl DocFolder for Cache {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if item.def_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                mem::replace(&mut self.stripped_mod, true)\n+            }\n+            _ => self.stripped_mod,\n+        };\n+\n+        // If the impl is from a masked crate or references something from a\n+        // masked crate then remove it completely.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if self.masked_crates.contains(&item.def_id.krate) ||\n+               i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) ||\n+               i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) {\n+                return None;\n+            }\n+        }\n+\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+        }\n+\n+        // Collect all the implementors of traits.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if let Some(did) = i.trait_.def_id() {\n+                if i.blanket_impl.is_none() {\n+                    self.implementors.entry(did).or_default().push(Impl {\n+                        impl_item: item.clone(),\n+                    });\n+                }\n+            }\n+        }\n+\n+        // Index this method for searching later on.\n+        if let Some(ref s) = item.name {\n+            let (parent, is_inherent_impl_item) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n+                clean::AssocConstItem(..) |\n+                clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n+                    // skip associated items in trait impls\n+                    ((None, None), false)\n+                }\n+                clean::AssocTypeItem(..) |\n+                clean::TyMethodItem(..) |\n+                clean::StructFieldItem(..) |\n+                clean::VariantItem(..) => {\n+                    ((Some(*self.parent_stack.last().unwrap()),\n+                      Some(&self.stack[..self.stack.len() - 1])),\n+                     false)\n+                }\n+                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                    if self.parent_stack.is_empty() {\n+                        ((None, None), false)\n+                    } else {\n+                        let last = self.parent_stack.last().unwrap();\n+                        let did = *last;\n+                        let path = match self.paths.get(&did) {\n+                            // The current stack not necessarily has correlation\n+                            // for where the type was defined. On the other\n+                            // hand, `paths` always has the right\n+                            // information if present.\n+                            Some(&(ref fqp, ItemType::Trait)) |\n+                            Some(&(ref fqp, ItemType::Struct)) |\n+                            Some(&(ref fqp, ItemType::Union)) |\n+                            Some(&(ref fqp, ItemType::Enum)) =>\n+                                Some(&fqp[..fqp.len() - 1]),\n+                            Some(..) => Some(&*self.stack),\n+                            None => None\n+                        };\n+                        ((Some(*last), path), true)\n+                    }\n+                }\n+                _ => ((None, Some(&*self.stack)), false)\n+            };\n+\n+            match parent {\n+                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n+                    debug_assert!(!item.is_stripped());\n+\n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n+                    if item.def_id.index != CRATE_DEF_INDEX {\n+                        self.search_index.push(IndexItem {\n+                            ty: item.type_(),\n+                            name: s.to_string(),\n+                            path: path.join(\"::\"),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n+                            parent,\n+                            parent_idx: None,\n+                            search_type: get_index_search_type(&item),\n+                        });\n+                    }\n+                }\n+                (Some(parent), None) if is_inherent_impl_item => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_impl_items.push((parent, item.clone()));\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Keep track of the fully qualified path for this item.\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n+                self.stack.push(n.to_string());\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        match item.inner {\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TypedefItem(..) | clean::TraitItem(..) |\n+            clean::FunctionItem(..) | clean::ModuleItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) | clean::StaticItem(..) |\n+            clean::UnionItem(..) | clean::ForeignTypeItem |\n+            clean::MacroItem(..) | clean::ProcMacroItem(..)\n+            if !self.stripped_mod => {\n+                // Re-exported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a re-exported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                if !self.paths.contains_key(&item.def_id) ||\n+                   self.access_levels.is_public(item.def_id)\n+                {\n+                    self.paths.insert(item.def_id,\n+                                      (self.stack.clone(), item.type_()));\n+                }\n+                self.add_aliases(&item);\n+            }\n+            // Link variants to their parent enum because pages aren't emitted\n+            // for each variant.\n+            clean::VariantItem(..) if !self.stripped_mod => {\n+                let mut stack = self.stack.clone();\n+                stack.pop();\n+                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n+            }\n+\n+            clean::PrimitiveItem(..) => {\n+                self.add_aliases(&item);\n+                self.paths.insert(item.def_id, (self.stack.clone(),\n+                                                item.type_()));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        // Maintain the parent stack\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let parent_pushed = match item.inner {\n+            clean::TraitItem(..) | clean::EnumItem(..) | clean::ForeignTypeItem |\n+            clean::StructItem(..) | clean::UnionItem(..) => {\n+                self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n+                true\n+            }\n+            clean::ImplItem(ref i) => {\n+                self.parent_is_trait_impl = i.trait_.is_some();\n+                match i.for_ {\n+                    clean::ResolvedPath{ did, .. } => {\n+                        self.parent_stack.push(did);\n+                        true\n+                    }\n+                    ref t => {\n+                        let prim_did = t.primitive_type().and_then(|t| {\n+                            self.primitive_locations.get(&t).cloned()\n+                        });\n+                        match prim_did {\n+                            Some(did) => {\n+                                self.parent_stack.push(did);\n+                                true\n+                            }\n+                            None => false,\n+                        }\n+                    }\n+                }\n+            }\n+            _ => false\n+        };\n+\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let mut dids = FxHashSet::default();\n+                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. } |\n+                        clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            dids.insert(did);\n+                        }\n+                        ref t => {\n+                            let did = t.primitive_type().and_then(|t| {\n+                                self.primitive_locations.get(&t).cloned()\n+                            });\n+\n+                            if let Some(did) = did {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+\n+                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                        for bound in generics {\n+                            if let Some(did) = bound.def_id() {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    unreachable!()\n+                };\n+                let impl_item = Impl {\n+                    impl_item: item,\n+                };\n+                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                    for did in dids {\n+                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    }\n+                } else {\n+                    let trait_did = impl_item.trait_did().unwrap();\n+                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                }\n+                None\n+            } else {\n+                Some(item)\n+            }\n+        });\n+\n+        if pushed { self.stack.pop().unwrap(); }\n+        if parent_pushed { self.parent_stack.pop().unwrap(); }\n+        self.stripped_mod = orig_stripped_mod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        ret\n+    }\n+}\n+\n+impl Cache {\n+    fn add_aliases(&mut self, item: &clean::Item) {\n+        if item.def_id.index == CRATE_DEF_INDEX {\n+            return\n+        }\n+        if let Some(ref item_name) = item.name {\n+            let path = self.paths.get(&item.def_id)\n+                                 .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n+                                 .unwrap_or(\"std\".to_owned());\n+            for alias in item.attrs.lists(sym::doc)\n+                                   .filter(|a| a.check_name(sym::alias))\n+                                   .filter_map(|a| a.value_str()\n+                                                    .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n+                                   .filter(|v| !v.is_empty())\n+                                   .collect::<FxHashSet<_>>()\n+                                   .into_iter() {\n+                self.aliases.entry(alias)\n+                            .or_insert(Vec::with_capacity(1))\n+                            .push(IndexItem {\n+                                ty: item.type_(),\n+                                name: item_name.to_string(),\n+                                path: path.clone(),\n+                                desc: shorten(plain_summary_line(item.doc_value())),\n+                                parent: None,\n+                                parent_idx: None,\n+                                search_type: get_index_search_type(&item),\n+                            });\n+            }\n+        }\n+    }\n+}\n+\n+/// Attempts to find where an external crate is located, given that we're\n+/// rendering in to the specified source destination.\n+fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n+    -> ExternalLocation\n+{\n+    use ExternalLocation::*;\n+    // See if there's documentation generated into the local directory\n+    let local_location = dst.join(&e.name);\n+    if local_location.is_dir() {\n+        return Local;\n+    }\n+\n+    if let Some(url) = extern_url {\n+        let mut url = url.to_string();\n+        if !url.ends_with(\"/\") {\n+            url.push('/');\n+        }\n+        return Remote(url);\n+    }\n+\n+    // Failing that, see if there's an attribute specifying where to find this\n+    // external crate\n+    e.attrs.lists(sym::doc)\n+     .filter(|a| a.check_name(sym::html_root_url))\n+     .filter_map(|a| a.value_str())\n+     .map(|url| {\n+        let mut url = url.to_string();\n+        if !url.ends_with(\"/\") {\n+            url.push('/')\n+        }\n+        Remote(url)\n+    }).next().unwrap_or(Unknown) // Well, at least we tried.\n+}\n+\n+/// Builds the search index from the collected metadata\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+    let mut nodeid_to_pathid = FxHashMap::default();\n+    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n+    let mut crate_paths = Vec::<Json>::new();\n+\n+    let Cache { ref mut search_index,\n+                ref orphan_impl_items,\n+                ref mut paths, .. } = *cache;\n+\n+    // Attach all orphan items to the type's definition if the type\n+    // has since been learned.\n+    for &(did, ref item) in orphan_impl_items {\n+        if let Some(&(ref fqp, _)) = paths.get(&did) {\n+            search_index.push(IndexItem {\n+                ty: item.type_(),\n+                name: item.name.clone().unwrap(),\n+                path: fqp[..fqp.len() - 1].join(\"::\"),\n+                desc: shorten(plain_summary_line(item.doc_value())),\n+                parent: Some(did),\n+                parent_idx: None,\n+                search_type: get_index_search_type(&item),\n+            });\n+        }\n+    }\n+\n+    // Reduce `NodeId` in paths into smaller sequential numbers,\n+    // and prune the paths that do not appear in the index.\n+    let mut lastpath = String::new();\n+    let mut lastpathid = 0usize;\n+\n+    for item in search_index {\n+        item.parent_idx = item.parent.map(|nodeid| {\n+            if nodeid_to_pathid.contains_key(&nodeid) {\n+                *nodeid_to_pathid.get(&nodeid).unwrap()\n+            } else {\n+                let pathid = lastpathid;\n+                nodeid_to_pathid.insert(nodeid, pathid);\n+                lastpathid += 1;\n+\n+                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n+                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n+                pathid\n+            }\n+        });\n+\n+        // Omit the parent path if it is same to that of the prior item.\n+        if lastpath == item.path {\n+            item.path.clear();\n+        } else {\n+            lastpath = item.path.clone();\n+        }\n+        crate_items.push(item.to_json());\n+    }\n+\n+    let crate_doc = krate.module.as_ref().map(|module| {\n+        shorten(plain_summary_line(module.doc_value()))\n+    }).unwrap_or(String::new());\n+\n+    let mut crate_data = BTreeMap::new();\n+    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n+    crate_data.insert(\"i\".to_owned(), Json::Array(crate_items));\n+    crate_data.insert(\"p\".to_owned(), Json::Array(crate_paths));\n+\n+    // Collect the index into a string\n+    format!(\"searchIndex[{}] = {};\",\n+            as_json(&krate.name),\n+            Json::Object(crate_data))\n+}\n+\n+fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+    let (all_types, ret_types) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n+        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        _ => return None,\n+    };\n+\n+    let inputs = all_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect();\n+    let output = ret_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n+    let output = if output.is_empty() {\n+        None\n+    } else {\n+        Some(output)\n+    };\n+\n+    Some(IndexItemFunctionType { inputs, output })\n+}\n+\n+fn get_index_type(clean_type: &clean::Type) -> Type {\n+    let t = Type {\n+        name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n+        generics: get_generics(clean_type),\n+    };\n+    t\n+}\n+\n+fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n+    match *clean_type {\n+        clean::ResolvedPath { ref path, .. } => {\n+            let segments = &path.segments;\n+            let path_segment = segments.into_iter().last().unwrap_or_else(|| panic!(\n+                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n+                clean_type, accept_generic\n+            ));\n+            Some(path_segment.name.clone())\n+        }\n+        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n+        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n+        // FIXME: add all from clean::Type.\n+        _ => None\n+    }\n+}\n+\n+fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n+    clean_type.generics()\n+              .and_then(|types| {\n+                  let r = types.iter()\n+                               .filter_map(|t| get_index_type_name(t, false))\n+                               .map(|s| s.to_ascii_lowercase())\n+                               .collect::<Vec<_>>();\n+                  if r.is_empty() {\n+                      None\n+                  } else {\n+                      Some(r)\n+                  }\n+              })\n+}"}]}