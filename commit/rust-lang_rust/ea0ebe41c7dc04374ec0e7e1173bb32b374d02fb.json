{"sha": "ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMGViZTQxYzdkYzA0Mzc0ZWMwZTdlMTE3M2JiMzJiMzc0ZDAyZmI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-02T16:06:01Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:37:42Z"}, "message": "Change trans_field_ptr to utilize LvalueTy to determine discriminant.", "tree": {"sha": "e4ceb6d2bc2e4282107fdcef0c0f62cfe5477d16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4ceb6d2bc2e4282107fdcef0c0f62cfe5477d16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "html_url": "https://github.com/rust-lang/rust/commit/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8038489357b5262645760a24673597486d71c1df", "url": "https://api.github.com/repos/rust-lang/rust/commits/8038489357b5262645760a24673597486d71c1df", "html_url": "https://github.com/rust-lang/rust/commit/8038489357b5262645760a24673597486d71c1df"}], "stats": {"total": 121, "additions": 72, "deletions": 49}, "files": [{"sha": "a541306f99a12ad234248210f55495639fb176b0", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "patch": "@@ -48,6 +48,7 @@ use std;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n+use rustc::mir::tcx::LvalueTy;\n use mir::lvalue::LvalueRef;\n use common::*;\n use builder::Builder;\n@@ -476,31 +477,33 @@ fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n pub fn trans_field_ptr<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     val: LvalueRef<'tcx>,\n-    discr: Disr,\n-    ix: usize\n+    ix: usize,\n ) -> ValueRef {\n+    let discr = match val.ty {\n+        LvalueTy::Ty { .. } => 0,\n+        LvalueTy::Downcast { variant_index, .. } => variant_index,\n+    };\n     let t = val.ty.to_ty(bcx.tcx());\n     let l = bcx.ccx.layout_of(t);\n-    debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n     match *l {\n         layout::Univariant { ref variant, .. } => {\n-            assert_eq!(discr, Disr(0));\n+            assert_eq!(discr, 0);\n             struct_field_ptr(bcx, &variant,\n              &compute_fields(bcx.ccx, t, 0, false),\n              val, ix, false)\n         }\n         layout::Vector { count, .. } => {\n-            assert_eq!(discr.0, 0);\n+            assert_eq!(discr, 0);\n             assert!((ix as u64) < count);\n             bcx.struct_gep(val.llval, ix)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n-            let mut fields = compute_fields(bcx.ccx, t, discr.0 as usize, false);\n+            let mut fields = compute_fields(bcx.ccx, t, discr, false);\n             fields.insert(0, d.to_ty(&bcx.tcx(), false));\n-            struct_field_ptr(bcx, &variants[discr.0 as usize],\n+            struct_field_ptr(bcx, &variants[discr],\n              &fields,\n              val, ix + 1, true)\n         }\n@@ -510,7 +513,7 @@ pub fn trans_field_ptr<'a, 'tcx>(\n             bcx.pointercast(val.llval, ty.ptr_to())\n         }\n         layout::RawNullablePointer { nndiscr, .. } |\n-        layout::StructWrappedNullablePointer { nndiscr,  .. } if discr.0 != nndiscr => {\n+        layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n             let nullfields = compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n             // The unit-like case might have a nonzero number of unit-like fields.\n             // (e.d., Result of Either with (), as one side.)\n@@ -521,14 +524,14 @@ pub fn trans_field_ptr<'a, 'tcx>(\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             assert_eq!(ix, 0);\n-            assert_eq!(discr.0, nndiscr);\n+            assert_eq!(discr as u64, nndiscr);\n             let ty = type_of::type_of(bcx.ccx, nnty);\n             bcx.pointercast(val.llval, ty.ptr_to())\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            assert_eq!(discr.0, nndiscr);\n+            assert_eq!(discr as u64, nndiscr);\n             struct_field_ptr(bcx, &nonnull,\n-             &compute_fields(bcx.ccx, t, discr.0 as usize, false),\n+             &compute_fields(bcx.ccx, t, discr, false),\n              val, ix, false)\n         }\n         _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)"}, {"sha": "581406476763934da2406da29d7d13b434ca1163", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "patch": "@@ -37,6 +37,7 @@ use llvm;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::StartFnLangItem;\n use rustc::ty::subst::Substs;\n+use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n@@ -288,8 +289,8 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     continue;\n                 }\n \n-                let src_f = adt::trans_field_ptr(bcx, src, Disr(0), i);\n-                let dst_f = adt::trans_field_ptr(bcx, dst, Disr(0), i);\n+                let src_f = adt::trans_field_ptr(bcx, src, i);\n+                let dst_f = adt::trans_field_ptr(bcx, dst, i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n                 } else {\n@@ -622,11 +623,16 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n         };\n         // Can return unsized value\n-        let dest_val = LvalueRef::new_sized_ty(dest, sig.output());\n+        let mut dest_val = LvalueRef::new_sized_ty(dest, sig.output());\n+        dest_val.ty = LvalueTy::Downcast {\n+            adt_def: sig.output().ty_adt_def().unwrap(),\n+            substs: substs,\n+            variant_index: disr.0 as usize,\n+        };\n         let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(&bcx, dest_val, Disr::from(disr), i);\n+            let lldestptr = adt::trans_field_ptr(&bcx, dest_val, i);\n             let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {"}, {"sha": "0b186d4938ba77fb248b365c553990a9015017be", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "patch": "@@ -20,8 +20,9 @@ use llvm::{ValueRef, get_param};\n use middle::lang_items::BoxFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n-use rustc::ty::{self, AdtKind, Ty, TypeFoldable};\n+use rustc::ty::{self, AdtDef, AdtKind, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n+use rustc::mir::tcx::LvalueTy;\n use mir::lvalue::LvalueRef;\n use adt;\n use base::*;\n@@ -395,14 +396,22 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n // Iterates through the elements of a structural type, dropping them.\n fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) -> Builder<'a, 'tcx> {\n-    fn iter_variant<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n+    fn iter_variant<'a, 'tcx>(cx: &'a Builder<'a, 'tcx>,\n                               av: LvalueRef<'tcx>,\n-                              variant: &'tcx ty::VariantDef,\n-                              substs: &Substs<'tcx>) {\n+                              adt_def: &'tcx AdtDef,\n+                              variant_index: usize,\n+                              substs: &'tcx Substs<'tcx>) {\n+        let variant = &adt_def.variants[variant_index];\n         let tcx = cx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n-            let field_ptr = adt::trans_field_ptr(&cx, av, Disr::from(variant.disr_val), i);\n+            let mut av = av.clone();\n+            av.ty = LvalueTy::Downcast {\n+                adt_def: adt_def,\n+                substs: substs,\n+                variant_index: variant_index,\n+            };\n+            let field_ptr = adt::trans_field_ptr(&cx, av, i);\n             drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg));\n         }\n     }\n@@ -412,7 +421,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = adt::trans_field_ptr(&cx, ptr, Disr(0), i);\n+                let llupvar = adt::trans_field_ptr(&cx, ptr, i);\n                 drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty));\n             }\n         }\n@@ -430,15 +439,21 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(&cx, ptr, Disr(0), i);\n+                let llfld_a = adt::trans_field_ptr(&cx, ptr, i);\n                 drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg));\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n                 let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                    let llfld_a = adt::trans_field_ptr(&cx, ptr, Disr::from(discr), i);\n+                    let mut ptr = ptr.clone();\n+                    ptr.ty = LvalueTy::Downcast {\n+                        adt_def: adt,\n+                        substs: substs,\n+                        variant_index: Disr::from(discr).0 as usize,\n+                    };\n+                    let llfld_a = adt::trans_field_ptr(&cx, ptr, i);\n                     let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n                         LvalueRef::new_sized_ty(llfld_a, field_ty)\n                     } else {\n@@ -460,7 +475,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n                     (adt::BranchKind::Single, None) => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            iter_variant(&cx, ptr, &adt.variants[0], substs);\n+                            iter_variant(&cx, ptr, &adt, 0, substs);\n                         }\n                     }\n                     (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n@@ -485,13 +500,13 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n                         let next_cx = cx.build_new_block(\"enum-iter-next\");\n \n-                        for variant in &adt.variants {\n+                        for (i, variant) in adt.variants.iter().enumerate() {\n                             let variant_cx_name = format!(\"enum-iter-variant-{}\",\n                                 &variant.disr_val.to_string());\n                             let variant_cx = cx.build_new_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            iter_variant(&variant_cx, ptr, variant, substs);\n+                            iter_variant(&variant_cx, ptr, &adt, i, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;"}, {"sha": "9a06a242aa7575cc2ee573e8e951bc9ec4a626e1", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "patch": "@@ -25,7 +25,6 @@ use type_of;\n use machine;\n use type_::Type;\n use rustc::ty::{self, Ty};\n-use Disr;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -553,7 +552,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         let arg = LvalueRef::new_sized_ty(llarg, arg_type);\n                         (0..contents.len())\n                             .map(|i| {\n-                                bcx.load(adt::trans_field_ptr(bcx, arg, Disr(0), i))\n+                                bcx.load(adt::trans_field_ptr(bcx, arg, i))\n                             })\n                             .collect()\n                     }"}, {"sha": "ccaa4140122bd04e4d2104aacb5e85d57e5898bb", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "patch": "@@ -709,7 +709,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Ref(llval) => {\n                 for (n, &ty) in arg_types.iter().enumerate() {\n                     let ptr = adt::trans_field_ptr(\n-                        bcx, LvalueRef::new_sized_ty(llval, tuple.ty), Disr(0), n\n+                        bcx, LvalueRef::new_sized_ty(llval, tuple.ty), n\n                     );\n                     let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);"}, {"sha": "5f97dfa22cd549b23d71038d9a61978cf3854aa1", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "patch": "@@ -20,7 +20,6 @@ use consts;\n use machine;\n use type_of::type_of;\n use type_of;\n-use Disr;\n \n use std::ptr;\n \n@@ -48,6 +47,13 @@ impl<'tcx> LvalueRef<'tcx> {\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(ty))\n     }\n \n+    pub fn new_unsized(llval: ValueRef, llextra: ValueRef, ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef {\n+            llval: llval,\n+            llextra: llextra,\n+            ty: ty,\n+        }\n+    }\n     pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n         LvalueRef {\n             llval: llval,\n@@ -140,26 +146,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n-                        let discr = match tr_base.ty {\n-                            LvalueTy::Ty { .. } => 0,\n-                            LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n-                        };\n-                        let discr = discr as u64;\n                         let is_sized = self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx));\n                         let base = if is_sized {\n-                            LvalueRef::new_sized_ty(tr_base.llval, base_ty)\n-                        } else {\n-                            LvalueRef::new_unsized_ty(tr_base.llval, tr_base.llextra, base_ty)\n-                        };\n-                        let llprojected = adt::trans_field_ptr(bcx, base, Disr(discr),\n-                            field.index());\n-                        let llextra = if is_sized {\n-                            ptr::null_mut()\n+                            LvalueRef::new_sized(tr_base.llval, tr_base.ty)\n                         } else {\n-                            tr_base.llextra\n+                            LvalueRef::new_unsized(tr_base.llval, tr_base.llextra, tr_base.ty)\n                         };\n-                        (llprojected, llextra)\n+                        let llprojected = adt::trans_field_ptr(bcx, base, field.index());\n+                        (llprojected, base.llextra)\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);"}, {"sha": "cc468ac18fdd9c2bcca468a79b9ef3504e29ea1e", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "patch": "@@ -12,6 +12,7 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n+use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n \n@@ -102,17 +103,22 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n                         let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n                         let dest_ty = dest.ty.to_ty(bcx.tcx());\n                         adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                let val = LvalueRef::new_sized_ty(dest.llval, dest_ty);\n+                                let mut val = LvalueRef::new_sized(dest.llval, dest.ty);\n                                 let field_index = active_field_index.unwrap_or(i);\n-                                let lldest_i = adt::trans_field_ptr(&bcx, val, disr, field_index);\n+                                val.ty = LvalueTy::Downcast {\n+                                    adt_def: adt_def,\n+                                    substs: self.monomorphize(&substs),\n+                                    variant_index: disr.0 as usize,\n+                                };\n+                                let lldest_i = adt::trans_field_ptr(&bcx, val, field_index);\n                                 self.store_operand(&bcx, lldest_i, op, None);\n                             }\n                         }"}]}