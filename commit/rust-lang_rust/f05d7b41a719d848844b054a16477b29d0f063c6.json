{"sha": "f05d7b41a719d848844b054a16477b29d0f063c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNWQ3YjQxYTcxOWQ4NDg4NDRiMDU0YTE2NDc3YjI5ZDBmMDYzYzY=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-07-31T02:12:44Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-07-31T02:12:44Z"}, "message": "Merge remote-tracking branch 'upstream/master' into 503-hover-doc-links\n\nHasn't fixed tests yet.", "tree": {"sha": "0a8a0946e8aef2ce64d4c13d0035ba41cce2daf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a8a0946e8aef2ce64d4c13d0035ba41cce2daf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f05d7b41a719d848844b054a16477b29d0f063c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f05d7b41a719d848844b054a16477b29d0f063c6", "html_url": "https://github.com/rust-lang/rust/commit/f05d7b41a719d848844b054a16477b29d0f063c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f05d7b41a719d848844b054a16477b29d0f063c6/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73ff610e41959e3e7c78a2b4b25b086883132956", "url": "https://api.github.com/repos/rust-lang/rust/commits/73ff610e41959e3e7c78a2b4b25b086883132956", "html_url": "https://github.com/rust-lang/rust/commit/73ff610e41959e3e7c78a2b4b25b086883132956"}, {"sha": "6b7cb8b5ab539fc4333ce34bc29bf77c976f232a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b7cb8b5ab539fc4333ce34bc29bf77c976f232a", "html_url": "https://github.com/rust-lang/rust/commit/6b7cb8b5ab539fc4333ce34bc29bf77c976f232a"}], "stats": {"total": 69801, "additions": 33815, "deletions": 35986}, "files": [{"sha": "4cd50e48109ff8dba52072d555d9feeaaf4916cd", "filename": ".gitattributes", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,2 +1,6 @@\n * text=auto eol=lf\n crates/ra_syntax/test_data/** -text eof=LF\n+# Older git versions try to fix line endings on images, this prevents it.\n+*.png binary\n+*.jpg binary\n+*.ico binary"}, {"sha": "2acd440122b670e57905c12ef15401b92ee22d2c", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -16,25 +16,25 @@ env:\n   RUSTUP_MAX_RETRIES: 10\n \n jobs:\n-  rust-audit:\n-    name: Audit Rust vulnerabilities\n-    runs-on: ubuntu-latest\n-    steps:\n-    - name: Checkout repository\n-      uses: actions/checkout@v2\n+  # rust-audit:\n+  #   name: Audit Rust vulnerabilities\n+  #   runs-on: ubuntu-latest\n+  #   steps:\n+  #   - name: Checkout repository\n+  #     uses: actions/checkout@v2\n \n-    - uses: actions-rs/install@v0.1\n-      with:\n-        crate: cargo-audit\n-        use-tool-cache: true\n+  #   - uses: actions-rs/install@v0.1\n+  #     with:\n+  #       crate: cargo-audit\n+  #       use-tool-cache: true\n \n-    - run: cargo audit\n+  #   - run: cargo audit\n \n   rust:\n     name: Rust\n     runs-on: ${{ matrix.os }}\n     env:\n-     CC: deny_c\n+      CC: deny_c\n \n     strategy:\n       fail-fast: false\n@@ -61,29 +61,22 @@ jobs:\n         override: true\n         components: rustfmt, rust-src\n \n-    - if: matrix.os == 'ubuntu-latest'\n-      run: sudo chown -R $(whoami):$(id -ng) ~/.cargo/\n-\n-    - name: Cache cargo registry\n-      uses: actions/cache@v1\n+    - name: Cache cargo directories\n+      uses: actions/cache@v2\n       with:\n-        path: ~/.cargo/registry\n-        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}\n-\n-    - name: Cache cargo index\n-      uses: actions/cache@v1\n-      with:\n-        path: ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+        path: |\n+          ~/.cargo/registry\n+          ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v1\n+      uses: actions/cache@v2\n       with:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Compile\n-      run: cargo test --no-run\n+      run: cargo test --no-run --locked\n \n     - name: Test\n       run: cargo test\n@@ -95,6 +88,34 @@ jobs:\n       if: matrix.os == 'windows-latest'\n       run: Remove-Item ./target/debug/xtask.exe, ./target/debug/deps/xtask.exe\n \n+  # Weird target to catch non-portable code\n+  rust-power:\n+    name: Rust Power\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v2\n+\n+    - name: Install Rust toolchain\n+      uses: actions-rs/toolchain@v1\n+      with:\n+        toolchain: stable\n+        profile: minimal\n+        override: true\n+        target: 'powerpc-unknown-linux-gnu'\n+\n+    - name: Cache cargo directories\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+          ~/.cargo/registry\n+          ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Check\n+      run: cargo check --target=powerpc-unknown-linux-gnu --all-targets\n+\n   typescript:\n     name: TypeScript\n     strategy:\n@@ -103,7 +124,7 @@ jobs:\n         os: [ubuntu-latest, windows-latest, macos-latest]\n \n     runs-on: ${{ matrix.os }}\n-    \n+\n     steps:\n     - name: Checkout repository\n       uses: actions/checkout@v2\n@@ -116,9 +137,9 @@ jobs:\n     - run: npm ci\n       working-directory: ./editors/code\n \n-    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n-      if: runner.os == 'Linux'\n-      working-directory: ./editors/code\n+#    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n+#      if: runner.os == 'Linux'\n+#      working-directory: ./editors/code\n \n     - run: npm run lint\n       working-directory: ./editors/code"}, {"sha": "ea780e8756e7c13cfa9adcafed4f9f26889f2375", "filename": ".github/workflows/metrics.yaml", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/.github%2Fworkflows%2Fmetrics.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/.github%2Fworkflows%2Fmetrics.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmetrics.yaml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -0,0 +1,32 @@\n+name: metrics\n+on:\n+  push:\n+   branches:\n+   - master\n+\n+env:\n+  CARGO_INCREMENTAL: 0\n+  CARGO_NET_RETRY: 10\n+  RUSTFLAGS: -D warnings\n+  RUSTUP_MAX_RETRIES: 10\n+\n+jobs:\n+  metrics:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v2\n+\n+    - name: Install Rust toolchain\n+      uses: actions-rs/toolchain@v1\n+      with:\n+        toolchain: stable\n+        profile: minimal\n+        override: true\n+        components: rust-src\n+\n+    - name: Collect metrics\n+      run: cargo xtask metrics\n+      env:\n+        METRICS_TOKEN: ${{ secrets.METRICS_TOKEN }}"}, {"sha": "572fb868e60dcf47b762b7034154c6aa1b2da410", "filename": "Cargo.lock", "status": "modified", "additions": 229, "deletions": 309, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,18 +2,18 @@\n # It is not intended for manual editing.\n [[package]]\n name = \"addr2line\"\n-version = \"0.12.2\"\n+version = \"0.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"602d785912f476e480434627e8732e6766b760c045bbf897d9dfaa9f4fbd399c\"\n+checksum = \"1b6a2d3371669ab3ca9797670853d61402b03d0b4b9ebf33d677dfa720203072\"\n dependencies = [\n  \"gimli\",\n ]\n \n [[package]]\n-name = \"adler32\"\n-version = \"1.1.0\"\n+name = \"adler\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"567b077b825e468cc974f0020d4082ee6e03132512f207ef1a02fd5d00d1f32d\"\n+checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n \n [[package]]\n name = \"aho-corasick\"\n@@ -26,18 +26,18 @@ dependencies = [\n \n [[package]]\n name = \"ansi_term\"\n-version = \"0.11.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n+checksum = \"d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2\"\n dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.31\"\n+version = \"1.0.32\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"85bb70cc08ec97ca5450e6eba421deeea5f172c0fc61f78b5357b2a8e8be195f\"\n+checksum = \"6b602bfe940d21c130f3895acd65221e8a61270debe89d628b9cb4e3ccb8569b\"\n \n [[package]]\n name = \"anymap\"\n@@ -51,6 +51,17 @@ version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \n+[[package]]\n+name = \"atty\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.0.0\"\n@@ -59,9 +70,9 @@ checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.49\"\n+version = \"0.3.50\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"05100821de9e028f12ae3d189176b41ee198341eb8f369956407fea2f5cc666c\"\n+checksum = \"46254cf2fdcdf1badb5934448c1bcbe046a56537b3987d96c51a7afc5d03f293\"\n dependencies = [\n  \"addr2line\",\n  \"cfg-if\",\n@@ -83,15 +94,6 @@ version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n-[[package]]\n-name = \"bstr\"\n-version = \"0.2.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"31accafdb70df7871592c058eca3985b71104e15ac32f64706022c58867da931\"\n-dependencies = [\n- \"memchr\",\n-]\n-\n [[package]]\n name = \"byteorder\"\n version = \"1.3.4\"\n@@ -100,21 +102,20 @@ checksum = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.10.0\"\n+version = \"0.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b8de60b887edf6d74370fc8eb177040da4847d971d6234c7b13a6da324ef0caf\"\n+checksum = \"89fec17b16f1ac67908af82e47d0a90a7afd0e1827b181cd77504323d3263d35\"\n dependencies = [\n  \"semver\",\n  \"serde\",\n- \"serde_derive\",\n  \"serde_json\",\n ]\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.56\"\n+version = \"1.0.58\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77c1f1d60091c1b73e2b1f4560ab419204b178e625fa945ded7b660becd2bd46\"\n+checksum = \"f9a06fb2e53271d7c279ec1efea6ab691c35a2ae67ec0d91d7acec0caf13b518\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -124,9 +125,9 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.15.0\"\n+version = \"0.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c7379caa72d04103fcfd9bde5642b816f58e3ffd6a0d39347e9e35a066648226\"\n+checksum = \"654c611946ba2629c5028cb7708687af975faf2c29d731824cb294c873df4697\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -135,49 +136,50 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"chalk-engine\"\n-version = \"0.15.0\"\n+name = \"chalk-ir\"\n+version = \"0.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e8afe48b5663504b485791ab4fae69cf4864869a71ceec9c758fd4d03423722\"\n+checksum = \"0a5341fbc654ca886b73b804a36aebf0e621057ccc1a68e9815b5b39b3ac9ae8\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-ir\",\n- \"rustc-hash\",\n- \"tracing\",\n+ \"lazy_static\",\n ]\n \n [[package]]\n-name = \"chalk-ir\"\n-version = \"0.15.0\"\n+name = \"chalk-recursive\"\n+version = \"0.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"231e391a03c1fc45874171d92be9542efedc939bac59d9501ee28b9521feb406\"\n+checksum = \"4484807b155b5a411e6135d330295f9ba5042e2920b8712c6574ca6ea91e9ee5\"\n dependencies = [\n  \"chalk-derive\",\n- \"lazy_static\",\n+ \"chalk-ir\",\n+ \"chalk-solve\",\n+ \"rustc-hash\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.15.0\"\n+version = \"0.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72c969c0fd06ad50538253327ca3445ff02cc9d0209f94c3cbf198ad9d365b48\"\n+checksum = \"281f82facd2538997fbe52132b1941ed213d266748215c31d15f62a8664429ad\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-engine\",\n  \"chalk-ir\",\n  \"ena\",\n  \"itertools\",\n  \"petgraph\",\n  \"rustc-hash\",\n  \"tracing\",\n  \"tracing-subscriber\",\n+ \"tracing-tree\",\n ]\n \n [[package]]\n name = \"chrono\"\n-version = \"0.4.11\"\n+version = \"0.4.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"80094f509cf8b5ae86a4966a39b3ff66cd7e2a3e594accec3743ff3fabeab5b2\"\n+checksum = \"c74d84029116787153e02106bf53e66828452a4b325cc8652b788b5967c0a0b6\"\n dependencies = [\n  \"num-integer\",\n  \"num-traits\",\n@@ -194,41 +196,31 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"console\"\n-version = \"0.11.3\"\n+name = \"cmake\"\n+version = \"0.1.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8c0994e656bba7b922d8dd1245db90672ffb701e684e45be58f20719d69abc5a\"\n+checksum = \"0e56268c17a6248366d66d4a47a3381369d068cce8409bb1716ed77ea32163bb\"\n dependencies = [\n- \"encode_unicode\",\n- \"lazy_static\",\n- \"libc\",\n- \"terminal_size\",\n- \"termios\",\n- \"winapi 0.3.9\",\n+ \"cc\",\n ]\n \n [[package]]\n-name = \"crossbeam\"\n-version = \"0.7.3\"\n+name = \"crc32fast\"\n+version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"69323bff1fb41c635347b8ead484a5ca6c3f11914d784170b158d8449ab07f8e\"\n+checksum = \"ba125de2af0df55319f41944744ad91c71113bf74a4646efff39afe1f6842db1\"\n dependencies = [\n  \"cfg-if\",\n- \"crossbeam-channel\",\n- \"crossbeam-deque\",\n- \"crossbeam-epoch\",\n- \"crossbeam-queue\",\n- \"crossbeam-utils\",\n ]\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.4.2\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cced8691919c02aac3cb0a1bc2e9b73d89e832bf9a06fc579d4e71b68a2da061\"\n+checksum = \"09ee0cc8804d5393478d743b035099520087a5186f3b93fa58cec08fa62407b6\"\n dependencies = [\n+ \"cfg-if\",\n  \"crossbeam-utils\",\n- \"maybe-uninit\",\n ]\n \n [[package]]\n@@ -291,12 +283,6 @@ version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"69b26e475fd29098530e709294e94e661974c851aed42512793f120fed4e199f\"\n \n-[[package]]\n-name = \"dtoa\"\n-version = \"0.4.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"134951f4028bdadb9b84baf4232681efbf277da25144b9b0ad65df75946c422b\"\n-\n [[package]]\n name = \"either\"\n version = \"1.5.3\"\n@@ -312,12 +298,6 @@ dependencies = [\n  \"log\",\n ]\n \n-[[package]]\n-name = \"encode_unicode\"\n-version = \"0.3.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f\"\n-\n [[package]]\n name = \"env_logger\"\n version = \"0.7.1\"\n@@ -327,11 +307,20 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"expect\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"difference\",\n+ \"once_cell\",\n+ \"stdx\",\n+]\n+\n [[package]]\n name = \"filetime\"\n-version = \"0.2.10\"\n+version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"affc17579b132fc2461adf7c575cc6e8b134ebca52c51f5411388965227dc695\"\n+checksum = \"e500da2fab70bdc43f8f0e0b350a227f31c72311c56aba48f01d5cd62bb0345b\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -345,6 +334,18 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n \n+[[package]]\n+name = \"flate2\"\n+version = \"1.0.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"68c90b0fc46cf89d227cc78b40e494ff81287a92dd07631e5af0d06fe3cf885e\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crc32fast\",\n+ \"libc\",\n+ \"miniz_oxide\",\n+]\n+\n [[package]]\n name = \"flycheck\"\n version = \"0.1.0\"\n@@ -357,18 +358,6 @@ dependencies = [\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"fnv\"\n-version = \"1.0.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n-\n-[[package]]\n-name = \"fs_extra\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n-\n [[package]]\n name = \"fsevent\"\n version = \"2.0.2\"\n@@ -432,22 +421,9 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.21.0\"\n+version = \"0.22.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bcc8e0c9bce37868955864dbecd2b1ab2bdf967e6f28066d65aaac620444b65c\"\n-\n-[[package]]\n-name = \"globset\"\n-version = \"0.4.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7ad1da430bd7281dde2576f44c84cc3f0f7b475e7202cd503042dff01a8c8120\"\n-dependencies = [\n- \"aho-corasick\",\n- \"bstr\",\n- \"fnv\",\n- \"log\",\n- \"regex\",\n-]\n+checksum = \"aaf91faf136cb47367fa430cd46e37a788775e7fa104f8b4bcb3861dc389b724\"\n \n [[package]]\n name = \"goblin\"\n@@ -460,6 +436,15 @@ dependencies = [\n  \"scroll\",\n ]\n \n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"34f595585f103464d8d2f6e9864682d74c1601fed5e07d62b1c9058dba8246fb\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n [[package]]\n name = \"heck\"\n version = \"0.3.1\"\n@@ -471,9 +456,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.14\"\n+version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9586eedd4ce6b3c498bc3b4dd92fc9f11166aa908a914071953768066c67909\"\n+checksum = \"3deed196b6e7f9e44a2ae8d94225d80302d81208b1bb673fd21fe634645c85a9\"\n dependencies = [\n  \"libc\",\n ]\n@@ -500,11 +485,12 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.4.0\"\n+version = \"1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c398b2b113b55809ceb9ee3e753fcbac793f1956663f3c36549c1346015c2afe\"\n+checksum = \"5b88cd59ee5f71fea89a62248fc8f387d44400cefe05ef548466d61ced9029a7\"\n dependencies = [\n  \"autocfg\",\n+ \"hashbrown\",\n ]\n \n [[package]]\n@@ -527,25 +513,11 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"insta\"\n-version = \"0.16.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"617e921abc813f96a3b00958c079e7bf1e2db998f8a04f1546dd967373a418ee\"\n-dependencies = [\n- \"console\",\n- \"difference\",\n- \"lazy_static\",\n- \"serde\",\n- \"serde_json\",\n- \"serde_yaml\",\n-]\n-\n [[package]]\n name = \"instant\"\n-version = \"0.1.5\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"69da7ce1490173c2bf4d26bc8be429aaeeaf4cce6c4b970b7949651fa17655fe\"\n+checksum = \"5b141fdc7836c525d4d594027d318c84161ca17aaf8113ab1f81ab93ae897485\"\n \n [[package]]\n name = \"iovec\"\n@@ -571,38 +543,6 @@ version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dc6f3ad7b9d11a0c00842ff8de1b60ee58661048eb8049ed33c73594f359d7e6\"\n \n-[[package]]\n-name = \"jemalloc-ctl\"\n-version = \"0.3.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c502a5ff9dd2924f1ed32ba96e3b65735d837b4bfd978d3161b1702e66aca4b7\"\n-dependencies = [\n- \"jemalloc-sys\",\n- \"libc\",\n- \"paste\",\n-]\n-\n-[[package]]\n-name = \"jemalloc-sys\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d3b9f3f5c9b31aa0f5ed3260385ac205db665baa41d49bb8338008ae94ede45\"\n-dependencies = [\n- \"cc\",\n- \"fs_extra\",\n- \"libc\",\n-]\n-\n-[[package]]\n-name = \"jemallocator\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43ae63fcfc45e99ab3d1b29a46782ad679e98436c3169d15a167a1108a724b69\"\n-dependencies = [\n- \"jemalloc-sys\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"jod-thread\"\n version = \"0.1.2\"\n@@ -633,9 +573,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.71\"\n+version = \"0.2.74\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9457b06509d27052635f90d6466700c65095fdf75409b3fbdd903e988b886f49\"\n+checksum = \"a2f02823cf78b754822df5f7f268fb59822e7296276d3e069d8e8cb26a14bd10\"\n \n [[package]]\n name = \"libloading\"\n@@ -647,25 +587,28 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"linked-hash-map\"\n-version = \"0.5.3\"\n+name = \"libmimalloc-sys\"\n+version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8dd5a6d5999d9907cda8ed67bbd137d3af8085216c2ac62de5be860bd41f304a\"\n+checksum = \"a27252ec1d0c4e0dd6142cbc572da50b363ab56fc334f7aa8fadf295b2e24e74\"\n+dependencies = [\n+ \"cmake\",\n+]\n \n [[package]]\n name = \"lock_api\"\n-version = \"0.4.0\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"de302ce1fe7482db13738fbaf2e21cfb06a986b89c0bf38d88abf16681aada4e\"\n+checksum = \"28247cc5a5be2f05fbcd76dd0cf2c7d3b5400cb978a28042abcd4fa0b3f8261c\"\n dependencies = [\n  \"scopeguard\",\n ]\n \n [[package]]\n name = \"log\"\n-version = \"0.4.8\"\n+version = \"0.4.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n+checksum = \"4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -684,9 +627,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.74.2\"\n+version = \"0.79.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b360754e89e0e13c114245131382ba921d4ff1efabb918e549422938aaa8d392\"\n+checksum = \"7f1f86677fdbe8df5f88b99131b1424e50aad27bbe3e5900d221bc414bd72e9b\"\n dependencies = [\n  \"base64\",\n  \"bitflags\",\n@@ -741,20 +684,29 @@ dependencies = [\n \n [[package]]\n name = \"memoffset\"\n-version = \"0.5.4\"\n+version = \"0.5.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b4fc2c02a7e374099d4ee95a193111f72d2110197fe200272371758f6c3643d8\"\n+checksum = \"c198b026e1bbf08a937e94c6c60f9ec4a2267f5b0d2eec9c1b21b061ce2be55f\"\n dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"mimalloc\"\n+version = \"0.1.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6c52de2069999f01bd26436564dbe7de3a87898feeb7a0d0ff9eb20a05bb7ca0\"\n+dependencies = [\n+ \"libmimalloc-sys\",\n+]\n+\n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.3.7\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"791daaae1ed6889560f8c4359194f56648355540573244a5448a83ba1ecc7435\"\n+checksum = \"be0f75932c1f6cfae3c04000e40114adf955636e19040f9c0a2c380702aa1c7f\"\n dependencies = [\n- \"adler32\",\n+ \"adler\",\n ]\n \n [[package]]\n@@ -872,6 +824,12 @@ version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0b631f7e854af39a1739f401cf34a8a013dfe09eac4fa4dba91e9768bd28168d\"\n \n+[[package]]\n+name = \"oorandom\"\n+version = \"11.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a170cebd8021a008ea92e4db85a72f80b35df514ec664b296fdcbb654eac0b2c\"\n+\n [[package]]\n name = \"parking_lot\"\n version = \"0.11.0\"\n@@ -899,33 +857,33 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"paste\"\n-version = \"0.1.18\"\n+name = \"paths\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"percent-encoding\"\n+version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45ca20c77d80be666aef2b45486da86238fabe33e38306bd3118fe4af33fa880\"\n-dependencies = [\n- \"paste-impl\",\n- \"proc-macro-hack\",\n-]\n+checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n \n [[package]]\n-name = \"paste-impl\"\n-version = \"0.1.18\"\n+name = \"perf-event\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d95a7db200b97ef370c8e6de0088252f7e0dfff7d047a28528e47456c0fc98b6\"\n+checksum = \"76c42ba5d85a2f4472b99f475fb60cf336d9b4c85b1ea8bb300fef2e3c7c8f89\"\n dependencies = [\n- \"proc-macro-hack\",\n+ \"libc\",\n+ \"perf-event-open-sys\",\n ]\n \n [[package]]\n-name = \"paths\"\n-version = \"0.1.0\"\n-\n-[[package]]\n-name = \"percent-encoding\"\n-version = \"2.1.0\"\n+name = \"perf-event-open-sys\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n+checksum = \"95db63e37862bc1b842135d2234ef9418f222cc660c6752f45e7cf9ddfb97f96\"\n+dependencies = [\n+ \"libc\",\n+]\n \n [[package]]\n name = \"petgraph\"\n@@ -955,26 +913,20 @@ version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"237a5ed80e274dbc66f86bd59c1e25edc039660be53194b5fe0a482e0f2612ea\"\n \n-[[package]]\n-name = \"proc-macro-hack\"\n-version = \"0.5.16\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e0456befd48169b9f13ef0f0ad46d492cf9d2dbb918bcf38e01eed4ce3ec5e4\"\n-\n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.18\"\n+version = \"1.0.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"beae6331a816b1f65d04c45b078fd8e6c93e8071771f41b8163255bbd8d7c8fa\"\n+checksum = \"04f5f085b5d71e2188cb8271e5da0161ad52c3f227a661a3c135fdf28e258b12\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.7.1\"\n+version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3e142c3b8f49d2200605ee6ba0b1d757310e9e7a72afe78c36ee2ef67300ee00\"\n+checksum = \"ca36dea94d187597e104a5c8e4b07576a8a45aa5db48a65e12940d3eb7461f55\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n@@ -1040,7 +992,6 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"ra_tt\",\n- \"relative-path\",\n  \"rustc-hash\",\n  \"salsa\",\n  \"stdx\",\n@@ -1071,6 +1022,7 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"rustc-hash\",\n+ \"stdx\",\n ]\n \n [[package]]\n@@ -1080,9 +1032,9 @@ dependencies = [\n  \"anymap\",\n  \"drop_bomb\",\n  \"either\",\n+ \"expect\",\n  \"fst\",\n  \"indexmap\",\n- \"insta\",\n  \"itertools\",\n  \"log\",\n  \"once_cell\",\n@@ -1123,9 +1075,10 @@ version = \"0.1.0\"\n dependencies = [\n  \"arrayvec\",\n  \"chalk-ir\",\n+ \"chalk-recursive\",\n  \"chalk-solve\",\n  \"ena\",\n- \"insta\",\n+ \"expect\",\n  \"itertools\",\n  \"log\",\n  \"ra_arena\",\n@@ -1139,19 +1092,23 @@ dependencies = [\n  \"smallvec\",\n  \"stdx\",\n  \"test_utils\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n ]\n \n [[package]]\n name = \"ra_ide\"\n version = \"0.1.0\"\n dependencies = [\n  \"either\",\n+ \"expect\",\n  \"indexmap\",\n- \"insta\",\n  \"itertools\",\n  \"lazy_static\",\n  \"log\",\n  \"maplit\",\n+ \"oorandom\",\n  \"pulldown-cmark\",\n  \"pulldown-cmark-to-cmark\",\n  \"ra_assists\",\n@@ -1190,7 +1147,7 @@ dependencies = [\n  \"ra_text_edit\",\n  \"rayon\",\n  \"rustc-hash\",\n- \"superslice\",\n+ \"stdx\",\n  \"test_utils\",\n ]\n \n@@ -1248,9 +1205,10 @@ name = \"ra_prof\"\n version = \"0.1.0\"\n dependencies = [\n  \"backtrace\",\n- \"jemalloc-ctl\",\n- \"jemallocator\",\n+ \"cfg-if\",\n+ \"libc\",\n  \"once_cell\",\n+ \"perf-event\",\n  \"ra_arena\",\n ]\n \n@@ -1277,23 +1235,27 @@ dependencies = [\n name = \"ra_ssr\"\n version = \"0.1.0\"\n dependencies = [\n+ \"expect\",\n  \"ra_db\",\n  \"ra_hir\",\n  \"ra_ide_db\",\n  \"ra_syntax\",\n  \"ra_text_edit\",\n  \"rustc-hash\",\n+ \"test_utils\",\n ]\n \n [[package]]\n name = \"ra_syntax\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec\",\n+ \"expect\",\n  \"itertools\",\n  \"once_cell\",\n  \"ra_parser\",\n  \"ra_text_edit\",\n+ \"rayon\",\n  \"rowan\",\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-hash\",\n@@ -1323,6 +1285,7 @@ name = \"ra_tt\"\n version = \"0.1.0\"\n dependencies = [\n  \"smol_str\",\n+ \"stdx\",\n ]\n \n [[package]]\n@@ -1403,9 +1366,9 @@ dependencies = [\n \n [[package]]\n name = \"redox_syscall\"\n-version = \"0.1.56\"\n+version = \"0.1.57\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84\"\n+checksum = \"41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce\"\n \n [[package]]\n name = \"regex\"\n@@ -1435,21 +1398,6 @@ version = \"0.6.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"26412eb97c6b088a6997e05f69403a802a92d520de2f8e63c2b65f9e0f47c4e8\"\n \n-[[package]]\n-name = \"relative-path\"\n-version = \"1.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c602122c47b382cd045b10866a084b184035d45d8c2609cdd3762852ddfae2a1\"\n-\n-[[package]]\n-name = \"remove_dir_all\"\n-version = \"0.5.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7\"\n-dependencies = [\n- \"winapi 0.3.9\",\n-]\n-\n [[package]]\n name = \"rowan\"\n version = \"0.10.0\"\n@@ -1469,14 +1417,15 @@ dependencies = [\n  \"anyhow\",\n  \"crossbeam-channel\",\n  \"env_logger\",\n+ \"expect\",\n  \"flycheck\",\n- \"globset\",\n- \"insta\",\n  \"itertools\",\n  \"jod-thread\",\n  \"log\",\n  \"lsp-server\",\n  \"lsp-types\",\n+ \"mimalloc\",\n+ \"oorandom\",\n  \"parking_lot\",\n  \"pico-args\",\n  \"ra_cfg\",\n@@ -1495,12 +1444,11 @@ dependencies = [\n  \"ra_text_edit\",\n  \"ra_toolchain\",\n  \"ra_tt\",\n- \"rand\",\n+ \"rayon\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n  \"stdx\",\n- \"tempfile\",\n  \"test_utils\",\n  \"threadpool\",\n  \"vfs\",\n@@ -1510,9 +1458,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"666.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4e00c526f9f8430ea4cd2178d25b02bfc7debe6677350c57292f92f50e65d2fe\"\n+checksum = \"22e1221f3bfa2943c942cf8da319ab2346887f8757778c29c7f1822cd27b521f\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1537,25 +1485,26 @@ checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n [[package]]\n name = \"salsa\"\n-version = \"0.14.2\"\n+version = \"0.15.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6a976dce155e392af3f1aa540ca23a6fc7303a7fef425cb431c464deb263eb54\"\n+checksum = \"d4cdc109fcc9e9450c7ef47fb7474e99bffd51799da03ed0a6c7f0e2cb3848a6\"\n dependencies = [\n- \"crossbeam\",\n+ \"crossbeam-utils\",\n  \"indexmap\",\n+ \"lock_api\",\n  \"log\",\n+ \"oorandom\",\n  \"parking_lot\",\n- \"rand\",\n  \"rustc-hash\",\n  \"salsa-macros\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"salsa-macros\"\n-version = \"0.14.1\"\n+version = \"0.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"038a09b6271446f1123f142fe7e5bef6d4687c4cf82e6986be574c2af3745530\"\n+checksum = \"2c280ac85b15ac214b86ac4b407626a48e6a1c4f90769a582fec74aa57942b9f\"\n dependencies = [\n  \"heck\",\n  \"proc-macro2\",\n@@ -1606,9 +1555,9 @@ dependencies = [\n \n [[package]]\n name = \"semver\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n+checksum = \"394cec28fa623e00903caf7ba4fa6fb9a0e260280bb8cdbbba029611108a0190\"\n dependencies = [\n  \"semver-parser\",\n  \"serde\",\n@@ -1642,9 +1591,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.56\"\n+version = \"1.0.57\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3433e879a558dde8b5e8feb2a04899cf34fdde1fafb894687e52105fc1162ac3\"\n+checksum = \"164eacbdb13512ec2745fb09d51fd5b22b0d65ed294a1dcf7285a360c80a675c\"\n dependencies = [\n  \"itoa\",\n  \"ryu\",\n@@ -1662,18 +1611,6 @@ dependencies = [\n  \"syn\",\n ]\n \n-[[package]]\n-name = \"serde_yaml\"\n-version = \"0.8.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ae3e2dd40a7cdc18ca80db804b7f461a39bb721160a85c9a1fa30134bf3c02a5\"\n-dependencies = [\n- \"dtoa\",\n- \"linked-hash-map\",\n- \"serde\",\n- \"yaml-rust\",\n-]\n-\n [[package]]\n name = \"sharded-slab\"\n version = \"0.0.9\"\n@@ -1691,15 +1628,15 @@ checksum = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.4.0\"\n+version = \"1.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c7cb5678e1615754284ec264d9bb5b4c27d2018577fd90ac0ceb578591ed5ee4\"\n+checksum = \"3757cb9d89161a2f24e1cf78efa0c1fcff485d18e3f55e0aa3480824ddaa0f3f\"\n \n [[package]]\n name = \"smol_str\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34836c9a295c62c2ce3514471117c5cb269891e8421b2aafdd910050576c4d8b\"\n+checksum = \"2f7909a1d8bc166a862124d84fdc11bda0ea4ed3157ccca662296919c2972db1\"\n dependencies = [\n  \"serde\",\n ]\n@@ -1708,17 +1645,11 @@ dependencies = [\n name = \"stdx\"\n version = \"0.1.0\"\n \n-[[package]]\n-name = \"superslice\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n-\n [[package]]\n name = \"syn\"\n-version = \"1.0.33\"\n+version = \"1.0.36\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e8d5d96e8cbb005d6959f119f773bfaebb5684296108fb32600c00cde305b2cd\"\n+checksum = \"4cdb98bcb1f9d81d07b536179c269ea15999b5d14ea958196413869445bb5250\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1738,36 +1669,12 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"tempfile\"\n-version = \"3.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n-dependencies = [\n- \"cfg-if\",\n- \"libc\",\n- \"rand\",\n- \"redox_syscall\",\n- \"remove_dir_all\",\n- \"winapi 0.3.9\",\n-]\n-\n-[[package]]\n-name = \"terminal_size\"\n-version = \"0.1.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8038f95fc7a6f351163f4b964af631bd26c9e828f7db085f2a84aca56f70d13b\"\n-dependencies = [\n- \"libc\",\n- \"winapi 0.3.9\",\n-]\n-\n-[[package]]\n-name = \"termios\"\n-version = \"0.3.2\"\n+name = \"termcolor\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f0fcee7b24a25675de40d5bb4de6e41b0df07bc9856295e7e2b3a3600c400c2\"\n+checksum = \"bb6bfa289a4d7c5766392812c0a1f4c1ba45afa1ad47803c11e1f407d846d75f\"\n dependencies = [\n- \"libc\",\n+ \"winapi-util\",\n ]\n \n [[package]]\n@@ -1829,9 +1736,9 @@ checksum = \"53953d2d3a5ad81d9f844a32f14ebb121f50b650cd59d0ee2a07cf13c617efed\"\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.15\"\n+version = \"0.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a41f40ed0e162c911ac6fcb53ecdc8134c46905fdbbae8c50add462a538b495f\"\n+checksum = \"dbdf4ccd1652592b01286a5dbe1e2a77d78afaa34beadd9872a5f7396f92aaa9\"\n dependencies = [\n  \"cfg-if\",\n  \"tracing-attributes\",\n@@ -1840,9 +1747,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99bbad0de3fd923c9c3232ead88510b783e5a4d16a6154adffa3d53308de984c\"\n+checksum = \"f0693bf8d6f2bf22c690fc61a9d21ac69efdbb894a17ed596b9af0f01e64b84b\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1851,9 +1758,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.10\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0aa83a9a47081cd522c09c81b31aec2c9273424976f922ad61c053b58350b715\"\n+checksum = \"94ae75f0d28ae10786f3b1895c55fe72e79928fd5ccdebb5438c75e93fec178f\"\n dependencies = [\n  \"lazy_static\",\n ]\n@@ -1881,9 +1788,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-subscriber\"\n-version = \"0.2.6\"\n+version = \"0.2.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04a11b459109e38ff6e1b580bafef4142a11d44889f5d07424cbce2fd2a2a119\"\n+checksum = \"e4f5dd7095c2481b7b3cbed71c8de53085fb3542bc3c2b4c73cba43e8f11c7ba\"\n dependencies = [\n  \"ansi_term\",\n  \"chrono\",\n@@ -1899,6 +1806,26 @@ dependencies = [\n  \"tracing-serde\",\n ]\n \n+[[package]]\n+name = \"tracing-tree\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"37ee7f0f53ed2093971a698db799ef56a2dfd89b32e3aeb5165f0e637a02be04\"\n+dependencies = [\n+ \"ansi_term\",\n+ \"atty\",\n+ \"chrono\",\n+ \"termcolor\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+]\n+\n+[[package]]\n+name = \"ungrammar\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0ee12e4891ab3acc2d95d5023022ace22020247bb8a8d1ece875a443f7dab37d\"\n+\n [[package]]\n name = \"unicase\"\n version = \"2.6.0\"\n@@ -1966,6 +1893,7 @@ checksum = \"b5a972e5669d67ba988ce3dc826706fb0a8b01471c088cb0b6110b805cc36aed\"\n name = \"vfs\"\n version = \"0.1.0\"\n dependencies = [\n+ \"fst\",\n  \"paths\",\n  \"rustc-hash\",\n ]\n@@ -1975,7 +1903,6 @@ name = \"vfs-notify\"\n version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel\",\n- \"globset\",\n  \"jod-thread\",\n  \"log\",\n  \"notify\",\n@@ -2060,17 +1987,10 @@ name = \"xtask\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n+ \"flate2\",\n  \"pico-args\",\n  \"proc-macro2\",\n  \"quote\",\n+ \"ungrammar\",\n  \"walkdir\",\n ]\n-\n-[[package]]\n-name = \"yaml-rust\"\n-version = \"0.4.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39f0c922f1a334134dc2f7a8b67dc5d25f0735263feec974345ff706bcf20b0d\"\n-dependencies = [\n- \"linked-hash-map\",\n-]"}, {"sha": "612e6809f62a3c0949fcf4d00125905b5d895444", "filename": "Cargo.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -24,9 +24,16 @@ opt-level = 0\n opt-level = 0\n [profile.release.package.salsa-macros]\n opt-level = 0\n+[profile.release.package.tracing-attributes]\n+opt-level = 0\n [profile.release.package.xtask]\n opt-level = 0\n \n+# Gzipping the artifacts is up to 10 times faster with optimizations (`cargo xtask dist`).\n+# `miniz_oxide` is the direct dependency of `flate2` which does all the heavy lifting\n+[profile.dev.package.miniz_oxide]\n+opt-level = 3\n+\n [patch.'crates-io']\n # rowan = { path = \"../rowan\" }\n "}, {"sha": "16c980400cf69d0327b54b2e4e8c9f339cfe822a", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,11 +2,8 @@\n   <img src=\"https://user-images.githubusercontent.com/1711539/72443316-5a79f280-37ae-11ea-858f-035209ece2dd.png\" alt=\"rust-analyzer logo\">\n </p>\n \n-rust-analyzer is an **experimental** modular compiler frontend for the Rust\n-language. It is a part of a larger rls-2.0 effort to create excellent IDE\n-support for Rust. If you want to get involved, check the rls-2.0 working group:\n-\n-https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0\n+rust-analyzer is an **experimental** modular compiler frontend for the Rust language.\n+It is a part of a larger rls-2.0 effort to create excellent IDE support for Rust.\n \n Work on rust-analyzer is sponsored by\n \n@@ -25,8 +22,8 @@ If you want to **contribute** to rust-analyzer or are just curious about how\n things work under the hood, check the [./docs/dev](./docs/dev) folder.\n \n If you want to **use** rust-analyzer's language server with your editor of\n-choice, check [the manual](https://rust-analyzer.github.io/manual.html) folder. It also contains some tips & tricks to help\n-you be more productive when using rust-analyzer.\n+choice, check [the manual](https://rust-analyzer.github.io/manual.html) folder.\n+It also contains some tips & tricks to help you be more productive when using rust-analyzer.\n \n ## Communication\n \n@@ -40,8 +37,9 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n \n ## Quick Links\n \n-* API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide/\n * Website: https://rust-analyzer.github.io/\n+* Metrics: https://rust-analyzer.github.io/metrics/\n+* API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide/\n \n ## License\n "}, {"sha": "77775630dc7aefc4a52487883cffb824c2abc0e1", "filename": "crates/expect/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fexpect%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fexpect%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"expect\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+license = \"MIT OR Apache-2.0\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+once_cell = \"1\"\n+difference = \"2\"\n+stdx = { path = \"../stdx\" }"}, {"sha": "21a458d477c56414408fa7b8d4306e64c0ba6c77", "filename": "crates/expect/src/lib.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fexpect%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fexpect%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -0,0 +1,356 @@\n+//! Snapshot testing library, see\n+//! https://github.com/rust-analyzer/rust-analyzer/pull/5101\n+use std::{\n+    collections::HashMap,\n+    env, fmt, fs, mem,\n+    ops::Range,\n+    panic,\n+    path::{Path, PathBuf},\n+    sync::Mutex,\n+};\n+\n+use difference::Changeset;\n+use once_cell::sync::Lazy;\n+use stdx::{lines_with_ends, trim_indent};\n+\n+const HELP: &str = \"\n+You can update all `expect![[]]` tests by running:\n+\n+    env UPDATE_EXPECT=1 cargo test\n+\n+To update a single test, place the cursor on `expect` token and use `run` feature of rust-analyzer.\n+\";\n+\n+fn update_expect() -> bool {\n+    env::var(\"UPDATE_EXPECT\").is_ok()\n+}\n+\n+/// expect![[r#\"inline snapshot\"#]]\n+#[macro_export]\n+macro_rules! expect {\n+    [[$data:literal]] => {$crate::Expect {\n+        position: $crate::Position {\n+            file: file!(),\n+            line: line!(),\n+            column: column!(),\n+        },\n+        data: $data,\n+    }};\n+    [[]] => { $crate::expect![[\"\"]] };\n+}\n+\n+/// expect_file![\"/crates/foo/test_data/bar.html\"]\n+#[macro_export]\n+macro_rules! expect_file {\n+    [$path:expr] => {$crate::ExpectFile {\n+        path: std::path::PathBuf::from($path)\n+    }};\n+}\n+\n+#[derive(Debug)]\n+pub struct Expect {\n+    pub position: Position,\n+    pub data: &'static str,\n+}\n+\n+#[derive(Debug)]\n+pub struct ExpectFile {\n+    pub path: PathBuf,\n+}\n+\n+#[derive(Debug)]\n+pub struct Position {\n+    pub file: &'static str,\n+    pub line: u32,\n+    pub column: u32,\n+}\n+\n+impl fmt::Display for Position {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}:{}:{}\", self.file, self.line, self.column)\n+    }\n+}\n+\n+impl Expect {\n+    pub fn assert_eq(&self, actual: &str) {\n+        let trimmed = self.trimmed();\n+        if &trimmed == actual {\n+            return;\n+        }\n+        Runtime::fail_expect(self, &trimmed, actual);\n+    }\n+    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n+        let actual = format!(\"{:#?}\\n\", actual);\n+        self.assert_eq(&actual)\n+    }\n+\n+    fn trimmed(&self) -> String {\n+        if !self.data.contains('\\n') {\n+            return self.data.to_string();\n+        }\n+        trim_indent(self.data)\n+    }\n+\n+    fn locate(&self, file: &str) -> Location {\n+        let mut target_line = None;\n+        let mut line_start = 0;\n+        for (i, line) in lines_with_ends(file).enumerate() {\n+            if i == self.position.line as usize - 1 {\n+                let pat = \"expect![[\";\n+                let offset = line.find(pat).unwrap();\n+                let literal_start = line_start + offset + pat.len();\n+                let indent = line.chars().take_while(|&it| it == ' ').count();\n+                target_line = Some((literal_start, indent));\n+                break;\n+            }\n+            line_start += line.len();\n+        }\n+        let (literal_start, line_indent) = target_line.unwrap();\n+        let literal_length =\n+            file[literal_start..].find(\"]]\").expect(\"Couldn't find matching `]]` for `expect![[`.\");\n+        let literal_range = literal_start..literal_start + literal_length;\n+        Location { line_indent, literal_range }\n+    }\n+}\n+\n+impl ExpectFile {\n+    pub fn assert_eq(&self, actual: &str) {\n+        let expected = self.read();\n+        if actual == expected {\n+            return;\n+        }\n+        Runtime::fail_file(self, &expected, actual);\n+    }\n+    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n+        let actual = format!(\"{:#?}\\n\", actual);\n+        self.assert_eq(&actual)\n+    }\n+    fn read(&self) -> String {\n+        fs::read_to_string(self.abs_path()).unwrap_or_default().replace(\"\\r\\n\", \"\\n\")\n+    }\n+    fn write(&self, contents: &str) {\n+        fs::write(self.abs_path(), contents).unwrap()\n+    }\n+    fn abs_path(&self) -> PathBuf {\n+        WORKSPACE_ROOT.join(&self.path)\n+    }\n+}\n+\n+#[derive(Default)]\n+struct Runtime {\n+    help_printed: bool,\n+    per_file: HashMap<&'static str, FileRuntime>,\n+}\n+static RT: Lazy<Mutex<Runtime>> = Lazy::new(Default::default);\n+\n+impl Runtime {\n+    fn fail_expect(expect: &Expect, expected: &str, actual: &str) {\n+        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n+        if update_expect() {\n+            println!(\"\\x1b[1m\\x1b[92mupdating\\x1b[0m: {}\", expect.position);\n+            rt.per_file\n+                .entry(expect.position.file)\n+                .or_insert_with(|| FileRuntime::new(expect))\n+                .update(expect, actual);\n+            return;\n+        }\n+        rt.panic(expect.position.to_string(), expected, actual);\n+    }\n+\n+    fn fail_file(expect: &ExpectFile, expected: &str, actual: &str) {\n+        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n+        if update_expect() {\n+            println!(\"\\x1b[1m\\x1b[92mupdating\\x1b[0m: {}\", expect.path.display());\n+            expect.write(actual);\n+            return;\n+        }\n+        rt.panic(expect.path.display().to_string(), expected, actual);\n+    }\n+\n+    fn panic(&mut self, position: String, expected: &str, actual: &str) {\n+        let print_help = !mem::replace(&mut self.help_printed, true);\n+        let help = if print_help { HELP } else { \"\" };\n+\n+        let diff = Changeset::new(actual, expected, \"\\n\");\n+\n+        println!(\n+            \"\\n\n+\\x1b[1m\\x1b[91merror\\x1b[97m: expect test failed\\x1b[0m\n+   \\x1b[1m\\x1b[34m-->\\x1b[0m {}\n+{}\n+\\x1b[1mExpect\\x1b[0m:\n+----\n+{}\n+----\n+\n+\\x1b[1mActual\\x1b[0m:\n+----\n+{}\n+----\n+\n+\\x1b[1mDiff\\x1b[0m:\n+----\n+{}\n+----\n+\",\n+            position, help, expected, actual, diff\n+        );\n+        // Use resume_unwind instead of panic!() to prevent a backtrace, which is unnecessary noise.\n+        panic::resume_unwind(Box::new(()));\n+    }\n+}\n+\n+struct FileRuntime {\n+    path: PathBuf,\n+    original_text: String,\n+    patchwork: Patchwork,\n+}\n+\n+impl FileRuntime {\n+    fn new(expect: &Expect) -> FileRuntime {\n+        let path = WORKSPACE_ROOT.join(expect.position.file);\n+        let original_text = fs::read_to_string(&path).unwrap();\n+        let patchwork = Patchwork::new(original_text.clone());\n+        FileRuntime { path, original_text, patchwork }\n+    }\n+    fn update(&mut self, expect: &Expect, actual: &str) {\n+        let loc = expect.locate(&self.original_text);\n+        let patch = format_patch(loc.line_indent.clone(), actual);\n+        self.patchwork.patch(loc.literal_range, &patch);\n+        fs::write(&self.path, &self.patchwork.text).unwrap()\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Location {\n+    line_indent: usize,\n+    literal_range: Range<usize>,\n+}\n+\n+#[derive(Debug)]\n+struct Patchwork {\n+    text: String,\n+    indels: Vec<(Range<usize>, usize)>,\n+}\n+\n+impl Patchwork {\n+    fn new(text: String) -> Patchwork {\n+        Patchwork { text, indels: Vec::new() }\n+    }\n+    fn patch(&mut self, mut range: Range<usize>, patch: &str) {\n+        self.indels.push((range.clone(), patch.len()));\n+        self.indels.sort_by_key(|(delete, _insert)| delete.start);\n+\n+        let (delete, insert) = self\n+            .indels\n+            .iter()\n+            .take_while(|(delete, _)| delete.start < range.start)\n+            .map(|(delete, insert)| (delete.end - delete.start, insert))\n+            .fold((0usize, 0usize), |(x1, y1), (x2, y2)| (x1 + x2, y1 + y2));\n+\n+        for pos in &mut [&mut range.start, &mut range.end] {\n+            **pos -= delete;\n+            **pos += insert;\n+        }\n+\n+        self.text.replace_range(range, &patch);\n+    }\n+}\n+\n+fn format_patch(line_indent: usize, patch: &str) -> String {\n+    let mut max_hashes = 0;\n+    let mut cur_hashes = 0;\n+    for byte in patch.bytes() {\n+        if byte != b'#' {\n+            cur_hashes = 0;\n+            continue;\n+        }\n+        cur_hashes += 1;\n+        max_hashes = max_hashes.max(cur_hashes);\n+    }\n+    let hashes = &\"#\".repeat(max_hashes + 1);\n+    let indent = &\" \".repeat(line_indent);\n+    let is_multiline = patch.contains('\\n');\n+\n+    let mut buf = String::new();\n+    buf.push('r');\n+    buf.push_str(hashes);\n+    buf.push('\"');\n+    if is_multiline {\n+        buf.push('\\n');\n+    }\n+    let mut final_newline = false;\n+    for line in lines_with_ends(patch) {\n+        if is_multiline && !line.trim().is_empty() {\n+            buf.push_str(indent);\n+            buf.push_str(\"    \");\n+        }\n+        buf.push_str(line);\n+        final_newline = line.ends_with('\\n');\n+    }\n+    if final_newline {\n+        buf.push_str(indent);\n+    }\n+    buf.push('\"');\n+    buf.push_str(hashes);\n+    buf\n+}\n+\n+static WORKSPACE_ROOT: Lazy<PathBuf> = Lazy::new(|| {\n+    let my_manifest =\n+        env::var(\"CARGO_MANIFEST_DIR\").unwrap_or_else(|_| env!(\"CARGO_MANIFEST_DIR\").to_owned());\n+    // Heuristic, see https://github.com/rust-lang/cargo/issues/3946\n+    Path::new(&my_manifest)\n+        .ancestors()\n+        .filter(|it| it.join(\"Cargo.toml\").exists())\n+        .last()\n+        .unwrap()\n+        .to_path_buf()\n+});\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_format_patch() {\n+        let patch = format_patch(0, \"hello\\nworld\\n\");\n+        expect![[r##\"\n+            r#\"\n+                hello\n+                world\n+            \"#\"##]]\n+        .assert_eq(&patch);\n+\n+        let patch = format_patch(4, \"single line\");\n+        expect![[r##\"r#\"single line\"#\"##]].assert_eq(&patch);\n+    }\n+\n+    #[test]\n+    fn test_patchwork() {\n+        let mut patchwork = Patchwork::new(\"one two three\".to_string());\n+        patchwork.patch(4..7, \"zwei\");\n+        patchwork.patch(0..3, \"\u043e\u0434\u0438\u043d\");\n+        patchwork.patch(8..13, \"3\");\n+        expect![[r#\"\n+            Patchwork {\n+                text: \"\u043e\u0434\u0438\u043d zwei 3\",\n+                indels: [\n+                    (\n+                        0..3,\n+                        8,\n+                    ),\n+                    (\n+                        4..7,\n+                        4,\n+                    ),\n+                    (\n+                        8..13,\n+                        1,\n+                    ),\n+                ],\n+            }\n+        \"#]]\n+        .assert_debug_eq(&patchwork);\n+    }\n+}"}, {"sha": "ff8a1e5689d595e5ba27c1efcb06ae8a4fc88f7f", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,14 +3,15 @@ edition = \"2018\"\n name = \"flycheck\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false\n \n [dependencies]\n crossbeam-channel = \"0.4.0\"\n log = \"0.4.8\"\n-cargo_metadata = \"0.10.0\"\n+cargo_metadata = \"0.11.1\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n ra_toolchain = { path = \"../ra_toolchain\" }"}, {"sha": "7c38f5ef9d5381ece6f62fea0fc796a0b1d6859e", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -14,14 +14,17 @@ use std::{\n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n \n pub use cargo_metadata::diagnostic::{\n-    Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n+    Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n+    DiagnosticSpanMacroExpansion,\n };\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand {\n         command: String,\n+        target_triple: Option<String>,\n         all_targets: bool,\n+        no_default_features: bool,\n         all_features: bool,\n         features: Vec<String>,\n         extra_args: Vec<String>,\n@@ -132,6 +135,7 @@ impl FlycheckActor {\n                     self.cancel_check_process();\n \n                     let mut command = self.check_command();\n+                    log::info!(\"restart flycheck {:?}\", command);\n                     command.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n                     if let Ok(child) = command.spawn().map(JodChild) {\n                         self.cargo_handle = Some(CargoHandle::spawn(child));\n@@ -176,6 +180,8 @@ impl FlycheckActor {\n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n+                target_triple,\n+                no_default_features,\n                 all_targets,\n                 all_features,\n                 extra_args,\n@@ -185,14 +191,23 @@ impl FlycheckActor {\n                 cmd.arg(command);\n                 cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n                     .arg(self.workspace_root.join(\"Cargo.toml\"));\n+\n+                if let Some(target) = target_triple {\n+                    cmd.args(&[\"--target\", target.as_str()]);\n+                }\n                 if *all_targets {\n                     cmd.arg(\"--all-targets\");\n                 }\n                 if *all_features {\n                     cmd.arg(\"--all-features\");\n-                } else if !features.is_empty() {\n-                    cmd.arg(\"--features\");\n-                    cmd.arg(features.join(\" \"));\n+                } else {\n+                    if *no_default_features {\n+                        cmd.arg(\"--no-default-features\");\n+                    }\n+                    if !features.is_empty() {\n+                        cmd.arg(\"--features\");\n+                        cmd.arg(features.join(\" \"));\n+                    }\n                 }\n                 cmd.args(extra_args);\n                 cmd"}, {"sha": "cbe2c26e20f62d2b92fa2de4150386a40593dd0a", "filename": "crates/paths/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fpaths%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fpaths%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ name = \"paths\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n edition = \"2018\"\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false"}, {"sha": "66c3738f4d2e641bdaa77670a1b6349faa7f78c3", "filename": "crates/ra_arena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ edition = \"2018\"\n name = \"ra_arena\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false"}, {"sha": "bd2905f080af30b0e6c1a2ca1302bd2b2b1fbb28", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ edition = \"2018\"\n name = \"ra_assists\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false"}, {"sha": "cda2abfb9c2fdf49ff322a248c8bf30729150cf0", "filename": "crates/ra_assists/src/assist_config.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_config.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -4,9 +4,12 @@\n //! module, and we use to statically check that we only produce snippet\n //! assists if we are allowed to.\n \n+use crate::AssistKind;\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct AssistConfig {\n     pub snippet_cap: Option<SnippetCap>,\n+    pub allowed: Option<Vec<AssistKind>>,\n }\n \n impl AssistConfig {\n@@ -22,6 +25,6 @@ pub struct SnippetCap {\n \n impl Default for AssistConfig {\n     fn default() -> Self {\n-        AssistConfig { snippet_cap: Some(SnippetCap { _private: () }) }\n+        AssistConfig { snippet_cap: Some(SnippetCap { _private: () }), allowed: None }\n     }\n }"}, {"sha": "3407df8562d2580635777f6f85ebb15dd0c70439", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -19,7 +19,7 @@ use ra_text_edit::TextEditBuilder;\n \n use crate::{\n     assist_config::{AssistConfig, SnippetCap},\n-    Assist, AssistId, GroupLabel, ResolvedAssist,\n+    Assist, AssistId, AssistKind, GroupLabel, ResolvedAssist,\n };\n \n /// `AssistContext` allows to apply an assist or check if it could be applied.\n@@ -55,7 +55,6 @@ use crate::{\n pub(crate) struct AssistContext<'a> {\n     pub(crate) config: &'a AssistConfig,\n     pub(crate) sema: Semantics<'a, RootDatabase>,\n-    pub(crate) db: &'a RootDatabase,\n     pub(crate) frange: FileRange,\n     source_file: SourceFile,\n }\n@@ -67,8 +66,11 @@ impl<'a> AssistContext<'a> {\n         frange: FileRange,\n     ) -> AssistContext<'a> {\n         let source_file = sema.parse(frange.file_id);\n-        let db = sema.db;\n-        AssistContext { config, sema, db, frange, source_file }\n+        AssistContext { config, sema, frange, source_file }\n+    }\n+\n+    pub(crate) fn db(&self) -> &RootDatabase {\n+        self.sema.db\n     }\n \n     // NB, this ignores active selection.\n@@ -101,14 +103,26 @@ pub(crate) struct Assists {\n     resolve: bool,\n     file: FileId,\n     buf: Vec<(Assist, Option<SourceChange>)>,\n+    allowed: Option<Vec<AssistKind>>,\n }\n \n impl Assists {\n     pub(crate) fn new_resolved(ctx: &AssistContext) -> Assists {\n-        Assists { resolve: true, file: ctx.frange.file_id, buf: Vec::new() }\n+        Assists {\n+            resolve: true,\n+            file: ctx.frange.file_id,\n+            buf: Vec::new(),\n+            allowed: ctx.config.allowed.clone(),\n+        }\n     }\n+\n     pub(crate) fn new_unresolved(ctx: &AssistContext) -> Assists {\n-        Assists { resolve: false, file: ctx.frange.file_id, buf: Vec::new() }\n+        Assists {\n+            resolve: false,\n+            file: ctx.frange.file_id,\n+            buf: Vec::new(),\n+            allowed: ctx.config.allowed.clone(),\n+        }\n     }\n \n     pub(crate) fn finish_unresolved(self) -> Vec<Assist> {\n@@ -137,9 +151,13 @@ impl Assists {\n         target: TextRange,\n         f: impl FnOnce(&mut AssistBuilder),\n     ) -> Option<()> {\n+        if !self.is_allowed(&id) {\n+            return None;\n+        }\n         let label = Assist::new(id, label.into(), None, target);\n         self.add_impl(label, f)\n     }\n+\n     pub(crate) fn add_group(\n         &mut self,\n         group: &GroupLabel,\n@@ -148,9 +166,14 @@ impl Assists {\n         target: TextRange,\n         f: impl FnOnce(&mut AssistBuilder),\n     ) -> Option<()> {\n+        if !self.is_allowed(&id) {\n+            return None;\n+        }\n+\n         let label = Assist::new(id, label.into(), Some(group.clone()), target);\n         self.add_impl(label, f)\n     }\n+\n     fn add_impl(&mut self, label: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n         let source_change = if self.resolve {\n             let mut builder = AssistBuilder::new(self.file);\n@@ -168,13 +191,20 @@ impl Assists {\n         self.buf.sort_by_key(|(label, _edit)| label.target.len());\n         self.buf\n     }\n+\n+    fn is_allowed(&self, id: &AssistId) -> bool {\n+        match &self.allowed {\n+            Some(allowed) => allowed.iter().any(|kind| kind.contains(id.1)),\n+            None => true,\n+        }\n+    }\n }\n \n pub(crate) struct AssistBuilder {\n     edit: TextEditBuilder,\n     file_id: FileId,\n     is_snippet: bool,\n-    edits: Vec<SourceFileEdit>,\n+    change: SourceChange,\n }\n \n impl AssistBuilder {\n@@ -183,7 +213,7 @@ impl AssistBuilder {\n             edit: TextEditBuilder::default(),\n             file_id,\n             is_snippet: false,\n-            edits: Vec::new(),\n+            change: SourceChange::default(),\n         }\n     }\n \n@@ -195,8 +225,8 @@ impl AssistBuilder {\n         let edit = mem::take(&mut self.edit).finish();\n         if !edit.is_empty() {\n             let new_edit = SourceFileEdit { file_id: self.file_id, edit };\n-            assert!(!self.edits.iter().any(|it| it.file_id == new_edit.file_id));\n-            self.edits.push(new_edit);\n+            assert!(!self.change.source_file_edits.iter().any(|it| it.file_id == new_edit.file_id));\n+            self.change.source_file_edits.push(new_edit);\n         }\n     }\n \n@@ -263,10 +293,10 @@ impl AssistBuilder {\n \n     fn finish(mut self) -> SourceChange {\n         self.commit();\n-        let mut res: SourceChange = mem::take(&mut self.edits).into();\n+        let mut change = mem::take(&mut self.change);\n         if self.is_snippet {\n-            res.is_snippet = true;\n+            change.is_snippet = true;\n         }\n-        res\n+        change\n     }\n }"}, {"sha": "5ea4f9f5ba0a3defb7501e954195d36745361449", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,7 +2,6 @@\n use rustc_hash::FxHashMap;\n \n use hir::{HirDisplay, PathResolution, SemanticsScope};\n-use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::SyntaxRewriter,\n     ast::{self, AstNode},\n@@ -32,17 +31,17 @@ impl<'a> AstTransform<'a> for NullTransformer {\n }\n \n pub struct SubstituteTypeParams<'a> {\n-    source_scope: &'a SemanticsScope<'a, RootDatabase>,\n+    source_scope: &'a SemanticsScope<'a>,\n     substs: FxHashMap<hir::TypeParam, ast::TypeRef>,\n     previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n impl<'a> SubstituteTypeParams<'a> {\n     pub fn for_trait_impl(\n-        source_scope: &'a SemanticsScope<'a, RootDatabase>,\n+        source_scope: &'a SemanticsScope<'a>,\n         // FIXME: there's implicit invariant that `trait_` and  `source_scope` match...\n         trait_: hir::Trait,\n-        impl_def: ast::ImplDef,\n+        impl_def: ast::Impl,\n     ) -> SubstituteTypeParams<'a> {\n         let substs = get_syntactic_substs(impl_def).unwrap_or_default();\n         let generic_def: hir::GenericDef = trait_.into();\n@@ -81,7 +80,7 @@ impl<'a> SubstituteTypeParams<'a> {\n \n         // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n         // trait ref, and then go from the types in the substs back to the syntax)\n-        fn get_syntactic_substs(impl_def: ast::ImplDef) -> Option<Vec<ast::TypeRef>> {\n+        fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::TypeRef>> {\n             let target_trait = impl_def.target_trait()?;\n             let path_type = match target_trait {\n                 ast::TypeRef::PathType(path) => path,\n@@ -126,16 +125,13 @@ impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n }\n \n pub struct QualifyPaths<'a> {\n-    target_scope: &'a SemanticsScope<'a, RootDatabase>,\n-    source_scope: &'a SemanticsScope<'a, RootDatabase>,\n+    target_scope: &'a SemanticsScope<'a>,\n+    source_scope: &'a SemanticsScope<'a>,\n     previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n impl<'a> QualifyPaths<'a> {\n-    pub fn new(\n-        target_scope: &'a SemanticsScope<'a, RootDatabase>,\n-        source_scope: &'a SemanticsScope<'a, RootDatabase>,\n-    ) -> Self {\n+    pub fn new(target_scope: &'a SemanticsScope<'a>, source_scope: &'a SemanticsScope<'a>) -> Self {\n         Self { target_scope, source_scope, previous: Box::new(NullTransformer) }\n     }\n \n@@ -156,7 +152,7 @@ impl<'a> QualifyPaths<'a> {\n         let resolution = self.source_scope.resolve_hir_path(&hir_path?)?;\n         match resolution {\n             PathResolution::Def(def) => {\n-                let found_path = from.find_use_path(self.source_scope.db, def)?;\n+                let found_path = from.find_use_path(self.source_scope.db.upcast(), def)?;\n                 let mut path = path_to_ast(found_path);\n \n                 let type_args = p"}, {"sha": "b67438b6ba26689dac22012ed73c58eae14fb259", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -8,7 +8,7 @@ use stdx::SepBy;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n-    AssistId,\n+    AssistId, AssistKind,\n };\n \n // Assist: add_custom_impl\n@@ -29,8 +29,8 @@ use crate::{\n // }\n // ```\n pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let input = ctx.find_node_at_offset::<ast::AttrInput>()?;\n-    let attr = input.syntax().parent().and_then(ast::Attr::cast)?;\n+    let attr = ctx.find_node_at_offset::<ast::Attr>()?;\n+    let input = attr.token_tree()?;\n \n     let attr_name = attr\n         .syntax()\n@@ -52,7 +52,7 @@ pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         format!(\"Add custom impl `{}` for `{}`\", trait_token.text().as_str(), annotated_name);\n \n     let target = attr.syntax().text_range();\n-    acc.add(AssistId(\"add_custom_impl\"), label, target, |builder| {\n+    acc.add(AssistId(\"add_custom_impl\", AssistKind::Refactor), label, target, |builder| {\n         let new_attr_input = input\n             .syntax()\n             .descendants_with_tokens()"}, {"sha": "e69f0a89b20b58a6903d7cedd709f19fc521bc54", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,10 +1,10 @@\n use hir::HirDisplay;\n use ra_syntax::{\n-    ast::{self, AstNode, LetStmt, NameOwner, TypeAscriptionOwner},\n+    ast::{self, AstNode, LetStmt, NameOwner},\n     TextRange,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: add_explicit_type\n //\n@@ -22,20 +22,20 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n // ```\n pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n-    let module = ctx.sema.scope(stmt.syntax()).module()?;\n-    let expr = stmt.initializer()?;\n+    let let_stmt = ctx.find_node_at_offset::<LetStmt>()?;\n+    let module = ctx.sema.scope(let_stmt.syntax()).module()?;\n+    let expr = let_stmt.initializer()?;\n     // Must be a binding\n-    let pat = match stmt.pat()? {\n+    let pat = match let_stmt.pat()? {\n         ast::Pat::BindPat(bind_pat) => bind_pat,\n         _ => return None,\n     };\n     let pat_range = pat.syntax().text_range();\n     // The binding must have a name\n     let name = pat.name()?;\n     let name_range = name.syntax().text_range();\n-    let stmt_range = stmt.syntax().text_range();\n-    let eq_range = stmt.eq_token()?.text_range();\n+    let stmt_range = let_stmt.syntax().text_range();\n+    let eq_range = let_stmt.eq_token()?.text_range();\n     // Assist should only be applicable if cursor is between 'let' and '='\n     let let_range = TextRange::new(stmt_range.start(), eq_range.start());\n     let cursor_in_range = let_range.contains_range(ctx.frange.range);\n@@ -44,7 +44,7 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     }\n     // Assist not applicable if the type has already been specified\n     // and it has no placeholders\n-    let ascribed_ty = stmt.ascribed_type();\n+    let ascribed_ty = let_stmt.ty();\n     if let Some(ty) = &ascribed_ty {\n         if ty.syntax().descendants().find_map(ast::PlaceholderType::cast).is_none() {\n             return None;\n@@ -57,9 +57,9 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n         return None;\n     }\n \n-    let inferred_type = ty.display_source_code(ctx.db, module.into()).ok()?;\n+    let inferred_type = ty.display_source_code(ctx.db(), module.into()).ok()?;\n     acc.add(\n-        AssistId(\"add_explicit_type\"),\n+        AssistId(\"add_explicit_type\", AssistKind::RefactorRewrite),\n         format!(\"Insert explicit type `{}`\", inferred_type),\n         pat_range,\n         |builder| match ascribed_ty {"}, {"sha": "eceba7d0ae671c11d8de5cb7aa29892762a2e4f7", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=73ff610e41959e3e7c78a2b4b25b086883132956", "patch": "@@ -1,98 +0,0 @@\n-use ra_syntax::ast::{self, AstNode, NameOwner, TypeParamsOwner};\n-use stdx::{format_to, SepBy};\n-\n-use crate::{AssistContext, AssistId, Assists};\n-\n-// Assist: add_impl\n-//\n-// Adds a new inherent impl for a type.\n-//\n-// ```\n-// struct Ctx<T: Clone> {\n-//     data: T,<|>\n-// }\n-// ```\n-// ->\n-// ```\n-// struct Ctx<T: Clone> {\n-//     data: T,\n-// }\n-//\n-// impl<T: Clone> Ctx<T> {\n-//     $0\n-// }\n-// ```\n-pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n-    let name = nominal.name()?;\n-    let target = nominal.syntax().text_range();\n-    acc.add(AssistId(\"add_impl\"), format!(\"Implement {}\", name.text().as_str()), target, |edit| {\n-        let type_params = nominal.type_param_list();\n-        let start_offset = nominal.syntax().text_range().end();\n-        let mut buf = String::new();\n-        buf.push_str(\"\\n\\nimpl\");\n-        if let Some(type_params) = &type_params {\n-            format_to!(buf, \"{}\", type_params.syntax());\n-        }\n-        buf.push_str(\" \");\n-        buf.push_str(name.text().as_str());\n-        if let Some(type_params) = type_params {\n-            let lifetime_params = type_params\n-                .lifetime_params()\n-                .filter_map(|it| it.lifetime_token())\n-                .map(|it| it.text().clone());\n-            let type_params =\n-                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n-\n-            let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n-            format_to!(buf, \"<{}>\", generic_params)\n-        }\n-        match ctx.config.snippet_cap {\n-            Some(cap) => {\n-                buf.push_str(\" {\\n    $0\\n}\");\n-                edit.insert_snippet(cap, start_offset, buf);\n-            }\n-            None => {\n-                buf.push_str(\" {\\n}\");\n-                edit.insert(start_offset, buf);\n-            }\n-        }\n-    })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_assist, check_assist_target};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn test_add_impl() {\n-        check_assist(add_impl, \"struct Foo {<|>}\\n\", \"struct Foo {}\\n\\nimpl Foo {\\n    $0\\n}\\n\");\n-        check_assist(\n-            add_impl,\n-            \"struct Foo<T: Clone> {<|>}\",\n-            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n    $0\\n}\",\n-        );\n-        check_assist(\n-            add_impl,\n-            \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n-            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n    $0\\n}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn add_impl_target() {\n-        check_assist_target(\n-            add_impl,\n-            \"\n-struct SomeThingIrrelevant;\n-/// Has a lifetime parameter\n-struct Foo<'a, T: Foo<'a>> {<|>}\n-struct EvenMoreIrrelevant;\n-\",\n-            \"/// Has a lifetime parameter\n-struct Foo<'a, T: Foo<'a>> {}\",\n-        );\n-    }\n-}"}, {"sha": "95a750aeec2fbf3feeb5c3eb6b6c4250baed19a6", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     assist_context::{AssistContext, Assists},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n     utils::{get_missing_assoc_items, render_snippet, resolve_target_trait, Cursor},\n-    AssistId,\n+    AssistId, AssistKind,\n };\n \n #[derive(PartialEq)]\n@@ -111,30 +111,31 @@ fn add_missing_impl_members_inner(\n     label: &'static str,\n ) -> Option<()> {\n     let _p = ra_prof::profile(\"add_missing_impl_members_inner\");\n-    let impl_def = ctx.find_node_at_offset::<ast::ImplDef>()?;\n-    let impl_item_list = impl_def.item_list()?;\n+    let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n+    let impl_item_list = impl_def.assoc_item_list()?;\n \n     let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n \n     let def_name = |item: &ast::AssocItem| -> Option<SmolStr> {\n         match item {\n-            ast::AssocItem::FnDef(def) => def.name(),\n-            ast::AssocItem::TypeAliasDef(def) => def.name(),\n-            ast::AssocItem::ConstDef(def) => def.name(),\n+            ast::AssocItem::Fn(def) => def.name(),\n+            ast::AssocItem::TypeAlias(def) => def.name(),\n+            ast::AssocItem::Const(def) => def.name(),\n+            ast::AssocItem::MacroCall(_) => None,\n         }\n         .map(|it| it.text().clone())\n     };\n \n     let missing_items = get_missing_assoc_items(&ctx.sema, &impl_def)\n         .iter()\n         .map(|i| match i {\n-            hir::AssocItem::Function(i) => ast::AssocItem::FnDef(i.source(ctx.db).value),\n-            hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAliasDef(i.source(ctx.db).value),\n-            hir::AssocItem::Const(i) => ast::AssocItem::ConstDef(i.source(ctx.db).value),\n+            hir::AssocItem::Function(i) => ast::AssocItem::Fn(i.source(ctx.db()).value),\n+            hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAlias(i.source(ctx.db()).value),\n+            hir::AssocItem::Const(i) => ast::AssocItem::Const(i.source(ctx.db()).value),\n         })\n         .filter(|t| def_name(&t).is_some())\n         .filter(|t| match t {\n-            ast::AssocItem::FnDef(def) => match mode {\n+            ast::AssocItem::Fn(def) => match mode {\n                 AddMissingImplMembersMode::DefaultMethodsOnly => def.body().is_some(),\n                 AddMissingImplMembersMode::NoDefaultMethods => def.body().is_none(),\n             },\n@@ -147,7 +148,7 @@ fn add_missing_impl_members_inner(\n     }\n \n     let target = impl_def.syntax().text_range();\n-    acc.add(AssistId(assist_id), label, target, |builder| {\n+    acc.add(AssistId(assist_id, AssistKind::QuickFix), label, target, |builder| {\n         let n_existing_items = impl_item_list.assoc_items().count();\n         let source_scope = ctx.sema.scope_for_def(trait_);\n         let target_scope = ctx.sema.scope(impl_item_list.syntax());\n@@ -157,7 +158,8 @@ fn add_missing_impl_members_inner(\n             .into_iter()\n             .map(|it| ast_transform::apply(&*ast_transform, it))\n             .map(|it| match it {\n-                ast::AssocItem::FnDef(def) => ast::AssocItem::FnDef(add_body(def)),\n+                ast::AssocItem::Fn(def) => ast::AssocItem::Fn(add_body(def)),\n+                ast::AssocItem::TypeAlias(def) => ast::AssocItem::TypeAlias(def.remove_bounds()),\n                 _ => it,\n             })\n             .map(|it| edit::remove_attrs_and_docs(&it));\n@@ -170,7 +172,7 @@ fn add_missing_impl_members_inner(\n             Some(cap) => {\n                 let mut cursor = Cursor::Before(first_new_item.syntax());\n                 let placeholder;\n-                if let ast::AssocItem::FnDef(func) = &first_new_item {\n+                if let ast::AssocItem::Fn(func) = &first_new_item {\n                     if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast) {\n                         if m.syntax().text() == \"todo!()\" {\n                             placeholder = m;\n@@ -188,7 +190,7 @@ fn add_missing_impl_members_inner(\n     })\n }\n \n-fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n+fn add_body(fn_def: ast::Fn) -> ast::Fn {\n     if fn_def.body().is_some() {\n         return fn_def;\n     }\n@@ -681,6 +683,28 @@ impl Foo<T> for S<T> {\n     fn bar(&self, this: &T, that: &Self) {\n         ${0:todo!()}\n     }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_bounds_are_removed() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Tr {\n+    type Ty: Copy + 'static;\n+}\n+\n+impl Tr for ()<|> {\n+}\"#,\n+            r#\"\n+trait Tr {\n+    type Ty: Copy + 'static;\n+}\n+\n+impl Tr for () {\n+    $0type Ty;\n }\"#,\n         )\n     }"}, {"sha": "0c565e89af86cad7cd7d8dd2f6ae8726c65cb2a0", "filename": "crates/ra_assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -4,7 +4,7 @@ use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n-    AssistId,\n+    AssistId, AssistKind,\n };\n \n // Assist: add_turbo_fish\n@@ -25,7 +25,14 @@ use crate::{\n // }\n // ```\n pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let ident = ctx.find_token_at_offset(SyntaxKind::IDENT)?;\n+    let ident = ctx.find_token_at_offset(SyntaxKind::IDENT).or_else(|| {\n+        let arg_list = ctx.find_node_at_offset::<ast::ArgList>()?;\n+        if arg_list.args().count() > 0 {\n+            return None;\n+        }\n+        mark::hit!(add_turbo_fish_after_call);\n+        arg_list.l_paren_token()?.prev_token().filter(|it| it.kind() == SyntaxKind::IDENT)\n+    })?;\n     let next_token = ident.next_token()?;\n     if next_token.kind() == T![::] {\n         mark::hit!(add_turbo_fish_one_fish_is_enough);\n@@ -45,12 +52,15 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         mark::hit!(add_turbo_fish_non_generic);\n         return None;\n     }\n-    acc.add(AssistId(\"add_turbo_fish\"), \"Add `::<>`\", ident.text_range(), |builder| {\n-        match ctx.config.snippet_cap {\n+    acc.add(\n+        AssistId(\"add_turbo_fish\", AssistKind::RefactorRewrite),\n+        \"Add `::<>`\",\n+        ident.text_range(),\n+        |builder| match ctx.config.snippet_cap {\n             Some(cap) => builder.insert_snippet(cap, ident.text_range().end(), \"::<${0:_}>\"),\n             None => builder.insert(ident.text_range().end(), \"::<_>\"),\n-        }\n-    })\n+        },\n+    )\n }\n \n #[cfg(test)]\n@@ -79,6 +89,26 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn add_turbo_fish_after_call() {\n+        mark::check!(add_turbo_fish_after_call);\n+        check_assist(\n+            add_turbo_fish,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make()<|>;\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make::<${0:_}>();\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn add_turbo_fish_method() {\n         check_assist("}, {"sha": "de701f8b8313cdc9e8c5ea9229bff1cf90b76fec", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{utils::invert_boolean_expression, AssistContext, AssistId, Assists};\n+use crate::{utils::invert_boolean_expression, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: apply_demorgan\n //\n@@ -39,11 +39,16 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     let rhs_range = rhs.syntax().text_range();\n     let not_rhs = invert_boolean_expression(rhs);\n \n-    acc.add(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n-        edit.replace(op_range, opposite_op);\n-        edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n-        edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));\n-    })\n+    acc.add(\n+        AssistId(\"apply_demorgan\", AssistKind::RefactorRewrite),\n+        \"Apply De Morgan's law\",\n+        op_range,\n+        |edit| {\n+            edit.replace(op_range, opposite_op);\n+            edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n+            edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));\n+        },\n+    )\n }\n \n // Return the opposite text for a given logical operator, if it makes sense"}, {"sha": "01e7b7a44cba776197fbf55e7d7b5eed69cb5c6c", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 151, "deletions": 9, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,15 +5,17 @@ use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n };\n-use ra_ide_db::{imports_locator::ImportsLocator, RootDatabase};\n+use ra_ide_db::{imports_locator, RootDatabase};\n use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxNode,\n };\n use rustc_hash::FxHashSet;\n \n-use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists, GroupLabel};\n+use crate::{\n+    utils::insert_use_statement, AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n+};\n \n // Assist: auto_import\n //\n@@ -35,8 +37,8 @@ use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists, Group\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let auto_import_assets = AutoImportAssets::new(&ctx)?;\n-    let proposed_imports = auto_import_assets.search_for_imports(ctx.db);\n+    let auto_import_assets = AutoImportAssets::new(ctx)?;\n+    let proposed_imports = auto_import_assets.search_for_imports(ctx);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n@@ -46,7 +48,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     for import in proposed_imports {\n         acc.add_group(\n             &group,\n-            AssistId(\"auto_import\"),\n+            AssistId(\"auto_import\", AssistKind::QuickFix),\n             format!(\"Import `{}`\", &import),\n             range,\n             |builder| {\n@@ -90,7 +92,7 @@ impl AutoImportAssets {\n \n     fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = path_under_caret.syntax().to_owned();\n-        if syntax_under_caret.ancestors().find_map(ast::UseItem::cast).is_some() {\n+        if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n             return None;\n         }\n \n@@ -127,11 +129,11 @@ impl AutoImportAssets {\n         GroupLabel(name)\n     }\n \n-    fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n+    fn search_for_imports(&self, ctx: &AssistContext) -> BTreeSet<ModPath> {\n         let _p = profile(\"auto_import::search_for_imports\");\n+        let db = ctx.db();\n         let current_crate = self.module_with_name_to_import.krate();\n-        ImportsLocator::new(db, current_crate)\n-            .find_imports(&self.get_search_query())\n+        imports_locator::find_imports(&ctx.sema, current_crate, &self.get_search_query())\n             .into_iter()\n             .filter_map(|candidate| match &self.import_candidate {\n                 ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n@@ -810,6 +812,146 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn trait_method_cross_crate() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+            r\"\n+            use dep::test_mod::TestTrait;\n+\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_method()\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_cross_crate() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::test_func<|>tion\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+            r\"\n+            use dep::test_mod::TestTrait;\n+\n+            fn main() {\n+                dep::test_mod::TestStruct::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_const_cross_crate() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::CONST<|>\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    const CONST: bool;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const CONST: bool = true;\n+                }\n+            }\n+            \",\n+            r\"\n+            use dep::test_mod::TestTrait;\n+\n+            fn main() {\n+                dep::test_mod::TestStruct::CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_as_method_cross_crate() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_func<|>tion()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn private_trait_cross_crate() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn not_applicable_for_imported_trait_for_method() {\n         check_assist_not_applicable("}, {"sha": "167e162d804ea5decceb2848d78db8974a1ad1cd", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     AstNode, SyntaxNode,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n use test_utils::mark;\n \n // Assist: change_return_type_to_result\n@@ -20,9 +20,9 @@ use test_utils::mark;\n pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n     // FIXME: extend to lambdas as well\n-    let fn_def = ret_type.syntax().parent().and_then(ast::FnDef::cast)?;\n+    let fn_def = ret_type.syntax().parent().and_then(ast::Fn::cast)?;\n \n-    let type_ref = &ret_type.type_ref()?;\n+    let type_ref = &ret_type.ty()?;\n     let ret_type_str = type_ref.syntax().text().to_string();\n     let first_part_ret_type = ret_type_str.splitn(2, '<').next();\n     if let Some(ret_type_first_part) = first_part_ret_type {\n@@ -35,8 +35,8 @@ pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContex\n     let block_expr = &fn_def.body()?;\n \n     acc.add(\n-        AssistId(\"change_return_type_to_result\"),\n-        \"Change return type to Result\",\n+        AssistId(\"change_return_type_to_result\", AssistKind::RefactorRewrite),\n+        \"Wrap return type in Result\",\n         type_ref.syntax().text_range(),\n         |builder| {\n             let mut tail_return_expr_collector = TailReturnCollector::new();\n@@ -240,7 +240,7 @@ fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n         Expr::ParenExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n         Expr::PathExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n         Expr::Label(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::RecordLit(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RecordExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n         Expr::IndexExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n         Expr::MethodCallExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n         Expr::AwaitExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),"}, {"sha": "724daa93f41b75b5d12330f123336b02d3b14c37", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,12 +1,12 @@\n use ra_syntax::{\n     ast::{self, NameOwner, VisibilityOwner},\n     AstNode,\n-    SyntaxKind::{CONST_DEF, ENUM_DEF, FN_DEF, MODULE, STRUCT_DEF, TRAIT_DEF, VISIBILITY},\n+    SyntaxKind::{CONST, ENUM, FN, MODULE, STATIC, STRUCT, TRAIT, VISIBILITY},\n     T,\n };\n use test_utils::mark;\n \n-use crate::{utils::vis_offset, AssistContext, AssistId, Assists};\n+use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: change_visibility\n //\n@@ -28,12 +28,15 @@ pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Optio\n \n fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| {\n-        matches!(leaf.kind(), T![const] | T![fn] | T![mod] | T![struct] | T![enum] | T![trait])\n+        matches!(\n+            leaf.kind(),\n+            T![const] | T![static] | T![fn] | T![mod] | T![struct] | T![enum] | T![trait]\n+        )\n     });\n \n     let (offset, target) = if let Some(keyword) = item_keyword {\n         let parent = keyword.parent();\n-        let def_kws = vec![CONST_DEF, FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF];\n+        let def_kws = vec![CONST, STATIC, FN, MODULE, STRUCT, ENUM, TRAIT];\n         // Parent is not a definition, can't add visibility\n         if !def_kws.iter().any(|&def_kw| def_kw == parent.kind()) {\n             return None;\n@@ -44,7 +47,7 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         }\n         (vis_offset(&parent), keyword.text_range())\n     } else if let Some(field_name) = ctx.find_node_at_offset::<ast::Name>() {\n-        let field = field_name.syntax().ancestors().find_map(ast::RecordFieldDef::cast)?;\n+        let field = field_name.syntax().ancestors().find_map(ast::RecordField::cast)?;\n         if field.name()? != field_name {\n             mark::hit!(change_visibility_field_false_positive);\n             return None;\n@@ -53,7 +56,7 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n             return None;\n         }\n         (vis_offset(field.syntax()), field_name.syntax().text_range())\n-    } else if let Some(field) = ctx.find_node_at_offset::<ast::TupleFieldDef>() {\n+    } else if let Some(field) = ctx.find_node_at_offset::<ast::TupleField>() {\n         if field.visibility().is_some() {\n             return None;\n         }\n@@ -62,16 +65,21 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         return None;\n     };\n \n-    acc.add(AssistId(\"change_visibility\"), \"Change visibility to pub(crate)\", target, |edit| {\n-        edit.insert(offset, \"pub(crate) \");\n-    })\n+    acc.add(\n+        AssistId(\"change_visibility\", AssistKind::RefactorRewrite),\n+        \"Change visibility to pub(crate)\",\n+        target,\n+        |edit| {\n+            edit.insert(offset, \"pub(crate) \");\n+        },\n+    )\n }\n \n fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n     if vis.syntax().text() == \"pub\" {\n         let target = vis.syntax().text_range();\n         return acc.add(\n-            AssistId(\"change_visibility\"),\n+            AssistId(\"change_visibility\", AssistKind::RefactorRewrite),\n             \"Change Visibility to pub(crate)\",\n             target,\n             |edit| {\n@@ -82,7 +90,7 @@ fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n     if vis.syntax().text() == \"pub(crate)\" {\n         let target = vis.syntax().text_range();\n         return acc.add(\n-            AssistId(\"change_visibility\"),\n+            AssistId(\"change_visibility\", AssistKind::RefactorRewrite),\n             \"Change visibility to pub\",\n             target,\n             |edit| {\n@@ -146,6 +154,11 @@ mod tests {\n         check_assist(change_visibility, \"<|>const FOO = 3u8;\", \"pub(crate) const FOO = 3u8;\");\n     }\n \n+    #[test]\n+    fn change_visibility_static() {\n+        check_assist(change_visibility, \"<|>static FOO = 3u8;\", \"pub(crate) static FOO = 3u8;\");\n+    }\n+\n     #[test]\n     fn change_visibility_handles_comment_attrs() {\n         check_assist("}, {"sha": "3650289fd64989654680db7a0fbf38fbe5858ff1", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "modified", "additions": 83, "deletions": 77, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -8,14 +8,14 @@ use ra_syntax::{\n         make,\n     },\n     AstNode,\n-    SyntaxKind::{FN_DEF, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n+    SyntaxKind::{FN, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n     SyntaxNode,\n };\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n     utils::invert_boolean_expression,\n-    AssistId,\n+    AssistId, AssistKind,\n };\n \n // Assist: convert_to_guarded_return\n@@ -88,7 +88,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n \n     let early_expression: ast::Expr = match parent_container.kind() {\n         WHILE_EXPR | LOOP_EXPR => make::expr_continue(),\n-        FN_DEF => make::expr_return(),\n+        FN => make::expr_return(),\n         _ => return None,\n     };\n \n@@ -99,86 +99,92 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n     then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n \n     let target = if_expr.syntax().text_range();\n-    acc.add(AssistId(\"convert_to_guarded_return\"), \"Convert to guarded return\", target, |edit| {\n-        let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-        let new_block = match if_let_pat {\n-            None => {\n-                // If.\n-                let new_expr = {\n-                    let then_branch =\n-                        make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n-                    let cond = invert_boolean_expression(cond_expr);\n-                    make::expr_if(make::condition(cond, None), then_branch).indent(if_indent_level)\n-                };\n-                replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n-            }\n-            Some((path, bound_ident)) => {\n-                // If-let.\n-                let match_expr = {\n-                    let happy_arm = {\n-                        let pat = make::tuple_struct_pat(\n-                            path,\n-                            once(make::bind_pat(make::name(\"it\")).into()),\n-                        );\n-                        let expr = {\n-                            let name_ref = make::name_ref(\"it\");\n-                            let segment = make::path_segment(name_ref);\n-                            let path = make::path_unqualified(segment);\n-                            make::expr_path(path)\n-                        };\n-                        make::match_arm(once(pat.into()), expr)\n+    acc.add(\n+        AssistId(\"convert_to_guarded_return\", AssistKind::RefactorRewrite),\n+        \"Convert to guarded return\",\n+        target,\n+        |edit| {\n+            let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n+            let new_block = match if_let_pat {\n+                None => {\n+                    // If.\n+                    let new_expr = {\n+                        let then_branch =\n+                            make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n+                        let cond = invert_boolean_expression(cond_expr);\n+                        make::expr_if(make::condition(cond, None), then_branch)\n+                            .indent(if_indent_level)\n                     };\n+                    replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n+                }\n+                Some((path, bound_ident)) => {\n+                    // If-let.\n+                    let match_expr = {\n+                        let happy_arm = {\n+                            let pat = make::tuple_struct_pat(\n+                                path,\n+                                once(make::bind_pat(make::name(\"it\")).into()),\n+                            );\n+                            let expr = {\n+                                let name_ref = make::name_ref(\"it\");\n+                                let segment = make::path_segment(name_ref);\n+                                let path = make::path_unqualified(segment);\n+                                make::expr_path(path)\n+                            };\n+                            make::match_arm(once(pat.into()), expr)\n+                        };\n \n-                    let sad_arm = make::match_arm(\n-                        // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n-                        once(make::placeholder_pat().into()),\n-                        early_expression,\n-                    );\n+                        let sad_arm = make::match_arm(\n+                            // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n+                            once(make::placeholder_pat().into()),\n+                            early_expression,\n+                        );\n \n-                    make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n-                };\n+                        make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                    };\n \n-                let let_stmt = make::let_stmt(\n-                    make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n-                    Some(match_expr),\n+                    let let_stmt = make::let_stmt(\n+                        make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                        Some(match_expr),\n+                    );\n+                    let let_stmt = let_stmt.indent(if_indent_level);\n+                    replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n+                }\n+            };\n+            edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n+\n+            fn replace(\n+                new_expr: &SyntaxNode,\n+                then_block: &ast::BlockExpr,\n+                parent_block: &ast::BlockExpr,\n+                if_expr: &ast::IfExpr,\n+            ) -> SyntaxNode {\n+                let then_block_items = then_block.dedent(IndentLevel(1));\n+                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+                let end_of_then =\n+                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                        end_of_then.prev_sibling_or_token().unwrap()\n+                    } else {\n+                        end_of_then\n+                    };\n+                let mut then_statements = new_expr.children_with_tokens().chain(\n+                    then_block_items\n+                        .syntax()\n+                        .children_with_tokens()\n+                        .skip(1)\n+                        .take_while(|i| *i != end_of_then),\n                 );\n-                let let_stmt = let_stmt.indent(if_indent_level);\n-                replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n+                replace_children(\n+                    &parent_block.syntax(),\n+                    RangeInclusive::new(\n+                        if_expr.clone().syntax().clone().into(),\n+                        if_expr.syntax().clone().into(),\n+                    ),\n+                    &mut then_statements,\n+                )\n             }\n-        };\n-        edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n-\n-        fn replace(\n-            new_expr: &SyntaxNode,\n-            then_block: &ast::BlockExpr,\n-            parent_block: &ast::BlockExpr,\n-            if_expr: &ast::IfExpr,\n-        ) -> SyntaxNode {\n-            let then_block_items = then_block.dedent(IndentLevel(1));\n-            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-            let end_of_then =\n-                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                    end_of_then.prev_sibling_or_token().unwrap()\n-                } else {\n-                    end_of_then\n-                };\n-            let mut then_statements = new_expr.children_with_tokens().chain(\n-                then_block_items\n-                    .syntax()\n-                    .children_with_tokens()\n-                    .skip(1)\n-                    .take_while(|i| *i != end_of_then),\n-            );\n-            replace_children(\n-                &parent_block.syntax(),\n-                RangeInclusive::new(\n-                    if_expr.clone().syntax().clone().into(),\n-                    if_expr.syntax().clone().into(),\n-                ),\n-                &mut then_statements,\n-            )\n-        }\n-    })\n+        },\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "ccec688caee1a4858b809b27234ac98ecc79d77f", "filename": "crates/ra_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -10,7 +10,8 @@ use ra_syntax::{\n use rustc_hash::FxHashSet;\n \n use crate::{\n-    assist_context::AssistBuilder, utils::insert_use_statement, AssistContext, AssistId, Assists,\n+    assist_context::AssistBuilder, utils::insert_use_statement, AssistContext, AssistId,\n+    AssistKind, Assists,\n };\n \n // Assist: extract_struct_from_enum_variant\n@@ -30,30 +31,30 @@ pub(crate) fn extract_struct_from_enum_variant(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n ) -> Option<()> {\n-    let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let field_list = match variant.kind() {\n         ast::StructKind::Tuple(field_list) => field_list,\n         _ => return None,\n     };\n     let variant_name = variant.name()?.to_string();\n     let variant_hir = ctx.sema.to_def(&variant)?;\n-    if existing_struct_def(ctx.db, &variant_name, &variant_hir) {\n+    if existing_struct_def(ctx.db(), &variant_name, &variant_hir) {\n         return None;\n     }\n     let enum_ast = variant.parent_enum();\n     let visibility = enum_ast.visibility();\n     let enum_hir = ctx.sema.to_def(&enum_ast)?;\n-    let variant_hir_name = variant_hir.name(ctx.db);\n+    let variant_hir_name = variant_hir.name(ctx.db());\n     let enum_module_def = ModuleDef::from(enum_hir);\n-    let current_module = enum_hir.module(ctx.db);\n+    let current_module = enum_hir.module(ctx.db());\n     let target = variant.syntax().text_range();\n     acc.add(\n-        AssistId(\"extract_struct_from_enum_variant\"),\n+        AssistId(\"extract_struct_from_enum_variant\", AssistKind::RefactorRewrite),\n         \"Extract struct from enum variant\",\n         target,\n         |builder| {\n             let definition = Definition::ModuleDef(ModuleDef::EnumVariant(variant_hir));\n-            let res = definition.find_usages(&ctx.db, None);\n+            let res = definition.find_usages(&ctx.sema, None);\n             let start_offset = variant.parent_enum().syntax().text_range().start();\n             let mut visited_modules_set = FxHashSet::default();\n             visited_modules_set.insert(current_module);\n@@ -101,7 +102,7 @@ fn insert_import(\n     enum_module_def: &ModuleDef,\n     variant_hir_name: &Name,\n ) -> Option<()> {\n-    let db = ctx.db;\n+    let db = ctx.db();\n     let mod_path = module.find_use_path(db, enum_module_def.clone());\n     if let Some(mut mod_path) = mod_path {\n         mod_path.segments.pop();"}, {"sha": "b925a2884cc7c3ab6a6db8c8cc0fd6a64df825ac", "filename": "crates/ra_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 107, "deletions": 95, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,14 +2,13 @@ use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::{\n         BLOCK_EXPR, BREAK_EXPR, COMMENT, LAMBDA_EXPR, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n-        WHITESPACE,\n     },\n     SyntaxNode,\n };\n use stdx::format_to;\n use test_utils::mark;\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: extract_variable\n //\n@@ -36,87 +35,84 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n         mark::hit!(extract_var_in_comment_is_not_applicable);\n         return None;\n     }\n-    let expr = node.ancestors().find_map(valid_target_expr)?;\n-    let (anchor_stmt, wrap_in_block) = anchor_stmt(expr.clone())?;\n-    let indent = anchor_stmt.prev_sibling_or_token()?.as_token()?.clone();\n-    if indent.kind() != WHITESPACE {\n-        return None;\n-    }\n-    let target = expr.syntax().text_range();\n-    acc.add(AssistId(\"extract_variable\"), \"Extract into variable\", target, move |edit| {\n-        let field_shorthand = match expr.syntax().parent().and_then(ast::RecordField::cast) {\n-            Some(field) => field.name_ref(),\n-            None => None,\n-        };\n-\n-        let mut buf = String::new();\n-\n-        let var_name = match &field_shorthand {\n-            Some(it) => it.to_string(),\n-            None => \"var_name\".to_string(),\n-        };\n-        let expr_range = match &field_shorthand {\n-            Some(it) => it.syntax().text_range().cover(expr.syntax().text_range()),\n-            None => expr.syntax().text_range(),\n-        };\n-\n-        if wrap_in_block {\n-            format_to!(buf, \"{{ let {} = \", var_name);\n-        } else {\n-            format_to!(buf, \"let {} = \", var_name);\n-        };\n-        format_to!(buf, \"{}\", expr.syntax());\n-\n-        let full_stmt = ast::ExprStmt::cast(anchor_stmt.clone());\n-        let is_full_stmt = if let Some(expr_stmt) = &full_stmt {\n-            Some(expr.syntax().clone()) == expr_stmt.expr().map(|e| e.syntax().clone())\n-        } else {\n-            false\n-        };\n-        if is_full_stmt {\n-            mark::hit!(test_extract_var_expr_stmt);\n-            if full_stmt.unwrap().semicolon_token().is_none() {\n-                buf.push_str(\";\");\n+    let to_extract = node.ancestors().find_map(valid_target_expr)?;\n+    let anchor = Anchor::from(&to_extract)?;\n+    let indent = anchor.syntax().prev_sibling_or_token()?.as_token()?.clone();\n+    let target = to_extract.syntax().text_range();\n+    acc.add(\n+        AssistId(\"extract_variable\", AssistKind::RefactorExtract),\n+        \"Extract into variable\",\n+        target,\n+        move |edit| {\n+            let field_shorthand =\n+                match to_extract.syntax().parent().and_then(ast::RecordExprField::cast) {\n+                    Some(field) => field.name_ref(),\n+                    None => None,\n+                };\n+\n+            let mut buf = String::new();\n+\n+            let var_name = match &field_shorthand {\n+                Some(it) => it.to_string(),\n+                None => \"var_name\".to_string(),\n+            };\n+            let expr_range = match &field_shorthand {\n+                Some(it) => it.syntax().text_range().cover(to_extract.syntax().text_range()),\n+                None => to_extract.syntax().text_range(),\n+            };\n+\n+            if let Anchor::WrapInBlock(_) = anchor {\n+                format_to!(buf, \"{{ let {} = \", var_name);\n+            } else {\n+                format_to!(buf, \"let {} = \", var_name);\n+            };\n+            format_to!(buf, \"{}\", to_extract.syntax());\n+\n+            if let Anchor::Replace(stmt) = anchor {\n+                mark::hit!(test_extract_var_expr_stmt);\n+                if stmt.semicolon_token().is_none() {\n+                    buf.push_str(\";\");\n+                }\n+                match ctx.config.snippet_cap {\n+                    Some(cap) => {\n+                        let snip = buf\n+                            .replace(&format!(\"let {}\", var_name), &format!(\"let $0{}\", var_name));\n+                        edit.replace_snippet(cap, expr_range, snip)\n+                    }\n+                    None => edit.replace(expr_range, buf),\n+                }\n+                return;\n             }\n+\n+            buf.push_str(\";\");\n+\n+            // We want to maintain the indent level,\n+            // but we do not want to duplicate possible\n+            // extra newlines in the indent block\n+            let text = indent.text();\n+            if text.starts_with('\\n') {\n+                buf.push_str(\"\\n\");\n+                buf.push_str(text.trim_start_matches('\\n'));\n+            } else {\n+                buf.push_str(text);\n+            }\n+\n+            edit.replace(expr_range, var_name.clone());\n+            let offset = anchor.syntax().text_range().start();\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     let snip =\n                         buf.replace(&format!(\"let {}\", var_name), &format!(\"let $0{}\", var_name));\n-                    edit.replace_snippet(cap, expr_range, snip)\n+                    edit.insert_snippet(cap, offset, snip)\n                 }\n-                None => edit.replace(expr_range, buf),\n+                None => edit.insert(offset, buf),\n             }\n-            return;\n-        }\n-\n-        buf.push_str(\";\");\n-\n-        // We want to maintain the indent level,\n-        // but we do not want to duplicate possible\n-        // extra newlines in the indent block\n-        let text = indent.text();\n-        if text.starts_with('\\n') {\n-            buf.push_str(\"\\n\");\n-            buf.push_str(text.trim_start_matches('\\n'));\n-        } else {\n-            buf.push_str(text);\n-        }\n \n-        edit.replace(expr_range, var_name.clone());\n-        let offset = anchor_stmt.text_range().start();\n-        match ctx.config.snippet_cap {\n-            Some(cap) => {\n-                let snip =\n-                    buf.replace(&format!(\"let {}\", var_name), &format!(\"let $0{}\", var_name));\n-                edit.insert_snippet(cap, offset, snip)\n+            if let Anchor::WrapInBlock(_) = anchor {\n+                edit.insert(anchor.syntax().text_range().end(), \" }\");\n             }\n-            None => edit.insert(offset, buf),\n-        }\n-\n-        if wrap_in_block {\n-            edit.insert(anchor_stmt.text_range().end(), \" }\");\n-        }\n-    })\n+        },\n+    )\n }\n \n /// Check whether the node is a valid expression which can be extracted to a variable.\n@@ -133,32 +129,48 @@ fn valid_target_expr(node: SyntaxNode) -> Option<ast::Expr> {\n     }\n }\n \n-/// Returns the syntax node which will follow the freshly extractd var\n-/// and a boolean indicating whether we have to wrap it within a { } block\n-/// to produce correct code.\n-/// It can be a statement, the last in a block expression or a wanna be block\n-/// expression like a lambda or match arm.\n-fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n-    expr.syntax().ancestors().find_map(|node| {\n-        if let Some(expr) = node.parent().and_then(ast::BlockExpr::cast).and_then(|it| it.expr()) {\n-            if expr.syntax() == &node {\n-                mark::hit!(test_extract_var_last_expr);\n-                return Some((node, false));\n+enum Anchor {\n+    Before(SyntaxNode),\n+    Replace(ast::ExprStmt),\n+    WrapInBlock(SyntaxNode),\n+}\n+\n+impl Anchor {\n+    fn from(to_extract: &ast::Expr) -> Option<Anchor> {\n+        to_extract.syntax().ancestors().find_map(|node| {\n+            if let Some(expr) =\n+                node.parent().and_then(ast::BlockExpr::cast).and_then(|it| it.expr())\n+            {\n+                if expr.syntax() == &node {\n+                    mark::hit!(test_extract_var_last_expr);\n+                    return Some(Anchor::Before(node));\n+                }\n             }\n-        }\n \n-        if let Some(parent) = node.parent() {\n-            if parent.kind() == MATCH_ARM || parent.kind() == LAMBDA_EXPR {\n-                return Some((node, true));\n+            if let Some(parent) = node.parent() {\n+                if parent.kind() == MATCH_ARM || parent.kind() == LAMBDA_EXPR {\n+                    return Some(Anchor::WrapInBlock(node));\n+                }\n             }\n-        }\n \n-        if ast::Stmt::cast(node.clone()).is_some() {\n-            return Some((node, false));\n-        }\n+            if let Some(stmt) = ast::Stmt::cast(node.clone()) {\n+                if let ast::Stmt::ExprStmt(stmt) = stmt {\n+                    if stmt.expr().as_ref() == Some(to_extract) {\n+                        return Some(Anchor::Replace(stmt));\n+                    }\n+                }\n+                return Some(Anchor::Before(node));\n+            }\n+            None\n+        })\n+    }\n \n-        None\n-    })\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Anchor::Before(it) | Anchor::WrapInBlock(it) => it,\n+            Anchor::Replace(stmt) => stmt.syntax(),\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "708e1bc6ca971f8e07e2d35930e3e12c0f0358bb", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 109, "deletions": 142, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -8,7 +8,7 @@ use test_utils::mark;\n \n use crate::{\n     utils::{render_snippet, Cursor, FamousDefs},\n-    AssistContext, AssistId, Assists,\n+    AssistContext, AssistId, AssistKind, Assists,\n };\n \n // Assist: fill_match_arms\n@@ -51,11 +51,11 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     let module = ctx.sema.scope(expr.syntax()).module()?;\n \n     let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n-        let variants = enum_def.variants(ctx.db);\n+        let variants = enum_def.variants(ctx.db());\n \n         let mut variants = variants\n             .into_iter()\n-            .filter_map(|variant| build_pat(ctx.db, module, variant))\n+            .filter_map(|variant| build_pat(ctx.db(), module, variant))\n             .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n             .collect::<Vec<_>>();\n@@ -84,11 +84,11 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         // where each tuple represents a proposed match arm.\n         enum_defs\n             .into_iter()\n-            .map(|enum_def| enum_def.variants(ctx.db))\n+            .map(|enum_def| enum_def.variants(ctx.db()))\n             .multi_cartesian_product()\n             .map(|variants| {\n                 let patterns =\n-                    variants.into_iter().filter_map(|variant| build_pat(ctx.db, module, variant));\n+                    variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n                 ast::Pat::from(make::tuple_pat(patterns))\n             })\n             .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n@@ -103,24 +103,37 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     }\n \n     let target = match_expr.syntax().text_range();\n-    acc.add(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |builder| {\n-        let new_arm_list = match_arm_list.remove_placeholder();\n-        let n_old_arms = new_arm_list.arms().count();\n-        let new_arm_list = new_arm_list.append_arms(missing_arms);\n-        let first_new_arm = new_arm_list.arms().nth(n_old_arms);\n-        let old_range = match_arm_list.syntax().text_range();\n-        match (first_new_arm, ctx.config.snippet_cap) {\n-            (Some(first_new_arm), Some(cap)) => {\n-                let snippet = render_snippet(\n-                    cap,\n-                    new_arm_list.syntax(),\n-                    Cursor::Before(first_new_arm.syntax()),\n-                );\n-                builder.replace_snippet(cap, old_range, snippet);\n-            }\n-            _ => builder.replace(old_range, new_arm_list.to_string()),\n-        }\n-    })\n+    acc.add(\n+        AssistId(\"fill_match_arms\", AssistKind::QuickFix),\n+        \"Fill match arms\",\n+        target,\n+        |builder| {\n+            let new_arm_list = match_arm_list.remove_placeholder();\n+            let n_old_arms = new_arm_list.arms().count();\n+            let new_arm_list = new_arm_list.append_arms(missing_arms);\n+            let first_new_arm = new_arm_list.arms().nth(n_old_arms);\n+            let old_range = match_arm_list.syntax().text_range();\n+            match (first_new_arm, ctx.config.snippet_cap) {\n+                (Some(first_new_arm), Some(cap)) => {\n+                    let extend_lifetime;\n+                    let cursor = match first_new_arm\n+                        .syntax()\n+                        .descendants()\n+                        .find_map(ast::PlaceholderPat::cast)\n+                    {\n+                        Some(it) => {\n+                            extend_lifetime = it.syntax().clone();\n+                            Cursor::Replace(&extend_lifetime)\n+                        }\n+                        None => Cursor::Before(first_new_arm.syntax()),\n+                    };\n+                    let snippet = render_snippet(cap, new_arm_list.syntax(), cursor);\n+                    builder.replace_snippet(cap, old_range, snippet);\n+                }\n+                _ => builder.replace(old_range, new_arm_list.to_string()),\n+            }\n+        },\n+    )\n }\n \n fn is_variant_missing(existing_arms: &mut Vec<MatchArm>, var: &Pat) -> bool {\n@@ -286,30 +299,22 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(Option<i32>),\n-            }\n-            fn main() {\n-                match A::As<|> {\n-                    A::Cs(_) | A::Bs => {}\n-                }\n-            }\n-            \"#,\n+enum A { As, Bs, Cs(Option<i32>) }\n+fn main() {\n+    match A::As<|> {\n+        A::Cs(_) | A::Bs => {}\n+    }\n+}\n+\"#,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(Option<i32>),\n-            }\n-            fn main() {\n-                match A::As {\n-                    A::Cs(_) | A::Bs => {}\n-                    $0A::As => {}\n-                }\n-            }\n-            \"#,\n+enum A { As, Bs, Cs(Option<i32>) }\n+fn main() {\n+    match A::As {\n+        A::Cs(_) | A::Bs => {}\n+        $0A::As => {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -318,47 +323,29 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs,\n-                Ds(String),\n-                Es(B),\n-            }\n-            enum B {\n-                Xs,\n-                Ys,\n-            }\n-            fn main() {\n-                match A::As<|> {\n-                    A::Bs if 0 < 1 => {}\n-                    A::Ds(_value) => { let x = 1; }\n-                    A::Es(B::Xs) => (),\n-                }\n-            }\n-            \"#,\n+enum A { As, Bs, Cs, Ds(String), Es(B) }\n+enum B { Xs, Ys }\n+fn main() {\n+    match A::As<|> {\n+        A::Bs if 0 < 1 => {}\n+        A::Ds(_value) => { let x = 1; }\n+        A::Es(B::Xs) => (),\n+    }\n+}\n+\"#,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs,\n-                Ds(String),\n-                Es(B),\n-            }\n-            enum B {\n-                Xs,\n-                Ys,\n-            }\n-            fn main() {\n-                match A::As {\n-                    A::Bs if 0 < 1 => {}\n-                    A::Ds(_value) => { let x = 1; }\n-                    A::Es(B::Xs) => (),\n-                    $0A::As => {}\n-                    A::Cs => {}\n-                }\n-            }\n-            \"#,\n+enum A { As, Bs, Cs, Ds(String), Es(B) }\n+enum B { Xs, Ys }\n+fn main() {\n+    match A::As {\n+        A::Bs if 0 < 1 => {}\n+        A::Ds(_value) => { let x = 1; }\n+        A::Es(B::Xs) => (),\n+        $0A::As => {}\n+        A::Cs => {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -367,32 +354,24 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(Option<i32>),\n-            }\n-            fn main() {\n-                match A::As<|> {\n-                    A::As(_) => {}\n-                    a @ A::Bs(_) => {}\n-                }\n-            }\n-            \"#,\n+enum A { As, Bs, Cs(Option<i32>) }\n+fn main() {\n+    match A::As<|> {\n+        A::As(_) => {}\n+        a @ A::Bs(_) => {}\n+    }\n+}\n+\"#,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(Option<i32>),\n-            }\n-            fn main() {\n-                match A::As {\n-                    A::As(_) => {}\n-                    a @ A::Bs(_) => {}\n-                    $0A::Cs(_) => {}\n-                }\n-            }\n-            \"#,\n+enum A { As, Bs, Cs(Option<i32>) }\n+fn main() {\n+    match A::As {\n+        A::As(_) => {}\n+        a @ A::Bs(_) => {}\n+        A::Cs(${0:_}) => {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -401,39 +380,27 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(String),\n-                Ds(String, String),\n-                Es { x: usize, y: usize }\n-            }\n+enum A { As, Bs, Cs(String), Ds(String, String), Es { x: usize, y: usize } }\n \n-            fn main() {\n-                let a = A::As;\n-                match a<|> {}\n-            }\n-            \"#,\n+fn main() {\n+    let a = A::As;\n+    match a<|> {}\n+}\n+\"#,\n             r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(String),\n-                Ds(String, String),\n-                Es { x: usize, y: usize }\n-            }\n+enum A { As, Bs, Cs(String), Ds(String, String), Es { x: usize, y: usize } }\n \n-            fn main() {\n-                let a = A::As;\n-                match a {\n-                    $0A::As => {}\n-                    A::Bs => {}\n-                    A::Cs(_) => {}\n-                    A::Ds(_, _) => {}\n-                    A::Es { x, y } => {}\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    let a = A::As;\n+    match a {\n+        $0A::As => {}\n+        A::Bs => {}\n+        A::Cs(_) => {}\n+        A::Ds(_, _) => {}\n+        A::Es { x, y } => {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -773,7 +740,7 @@ fn foo(opt: Option<i32>) {\n             r#\"\n fn foo(opt: Option<i32>) {\n     match opt {\n-        $0Some(_) => {}\n+        Some(${0:_}) => {}\n         None => {}\n     }\n }"}, {"sha": "1aefa79cc3052b9f4a617b1717ff125769b5bdf9", "filename": "crates/ra_assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 90, "deletions": 30, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,7 +2,8 @@ use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n use ra_db::FileId;\n use ra_syntax::{ast, AstNode, TextRange, TextSize};\n \n-use crate::{utils::vis_offset, AssistContext, AssistId, Assists};\n+use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n+use ast::VisibilityOwner;\n \n // FIXME: this really should be a fix for diagnostic, rather than an assist.\n \n@@ -41,14 +42,15 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> O\n     };\n \n     let current_module = ctx.sema.scope(&path.syntax()).module()?;\n-    let target_module = def.module(ctx.db)?;\n+    let target_module = def.module(ctx.db())?;\n \n-    let vis = target_module.visibility_of(ctx.db, &def)?;\n-    if vis.is_visible_from(ctx.db, current_module.into()) {\n+    let vis = target_module.visibility_of(ctx.db(), &def)?;\n+    if vis.is_visible_from(ctx.db(), current_module.into()) {\n         return None;\n     };\n \n-    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n+    let (offset, current_visibility, target, target_file, target_name) =\n+        target_data_for_def(ctx.db(), def)?;\n \n     let missing_visibility =\n         if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n@@ -58,79 +60,109 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> O\n         Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n     };\n \n-    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n+    acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n         builder.edit_file(target_file);\n         match ctx.config.snippet_cap {\n-            Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n-            None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+            Some(cap) => match current_visibility {\n+                Some(current_visibility) => builder.replace_snippet(\n+                    cap,\n+                    current_visibility.syntax().text_range(),\n+                    format!(\"$0{}\", missing_visibility),\n+                ),\n+                None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+            },\n+            None => match current_visibility {\n+                Some(current_visibility) => {\n+                    builder.replace(current_visibility.syntax().text_range(), missing_visibility)\n+                }\n+                None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+            },\n         }\n     })\n }\n \n fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n+    let record_field: ast::RecordExprField = ctx.find_node_at_offset()?;\n     let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n \n     let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n-    let visibility = record_field_def.visibility(ctx.db);\n-    if visibility.is_visible_from(ctx.db, current_module.into()) {\n+    let visibility = record_field_def.visibility(ctx.db());\n+    if visibility.is_visible_from(ctx.db(), current_module.into()) {\n         return None;\n     }\n \n-    let parent = record_field_def.parent_def(ctx.db);\n-    let parent_name = parent.name(ctx.db);\n-    let target_module = parent.module(ctx.db);\n+    let parent = record_field_def.parent_def(ctx.db());\n+    let parent_name = parent.name(ctx.db());\n+    let target_module = parent.module(ctx.db());\n \n-    let in_file_source = record_field_def.source(ctx.db);\n-    let (offset, target) = match in_file_source.value {\n+    let in_file_source = record_field_def.source(ctx.db());\n+    let (offset, current_visibility, target) = match in_file_source.value {\n         hir::FieldSource::Named(it) => {\n             let s = it.syntax();\n-            (vis_offset(s), s.text_range())\n+            (vis_offset(s), it.visibility(), s.text_range())\n         }\n         hir::FieldSource::Pos(it) => {\n             let s = it.syntax();\n-            (vis_offset(s), s.text_range())\n+            (vis_offset(s), it.visibility(), s.text_range())\n         }\n     };\n \n     let missing_visibility =\n         if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n-    let target_file = in_file_source.file_id.original_file(ctx.db);\n+    let target_file = in_file_source.file_id.original_file(ctx.db());\n \n-    let target_name = record_field_def.name(ctx.db);\n+    let target_name = record_field_def.name(ctx.db());\n     let assist_label =\n         format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n \n-    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n+    acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n         builder.edit_file(target_file);\n         match ctx.config.snippet_cap {\n-            Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n-            None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+            Some(cap) => match current_visibility {\n+                Some(current_visibility) => builder.replace_snippet(\n+                    cap,\n+                    dbg!(current_visibility.syntax()).text_range(),\n+                    format!(\"$0{}\", missing_visibility),\n+                ),\n+                None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+            },\n+            None => match current_visibility {\n+                Some(current_visibility) => {\n+                    builder.replace(current_visibility.syntax().text_range(), missing_visibility)\n+                }\n+                None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+            },\n         }\n     })\n }\n \n fn target_data_for_def(\n     db: &dyn HirDatabase,\n     def: hir::ModuleDef,\n-) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n+) -> Option<(TextSize, Option<ast::Visibility>, TextRange, FileId, Option<hir::Name>)> {\n     fn offset_target_and_file_id<S, Ast>(\n         db: &dyn HirDatabase,\n         x: S,\n-    ) -> (TextSize, TextRange, FileId)\n+    ) -> (TextSize, Option<ast::Visibility>, TextRange, FileId)\n     where\n         S: HasSource<Ast = Ast>,\n-        Ast: AstNode,\n+        Ast: AstNode + ast::VisibilityOwner,\n     {\n         let source = x.source(db);\n         let in_file_syntax = source.syntax();\n         let file_id = in_file_syntax.file_id;\n         let syntax = in_file_syntax.value;\n-        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n+        let current_visibility = source.value.visibility();\n+        (\n+            vis_offset(syntax),\n+            current_visibility,\n+            syntax.text_range(),\n+            file_id.original_file(db.upcast()),\n+        )\n     }\n \n     let target_name;\n-    let (offset, target, target_file) = match def {\n+    let (offset, current_visibility, target, target_file) = match def {\n         hir::ModuleDef::Function(f) => {\n             target_name = Some(f.name(db));\n             offset_target_and_file_id(db, f)\n@@ -164,13 +196,13 @@ fn target_data_for_def(\n             let in_file_source = m.declaration_source(db)?;\n             let file_id = in_file_source.file_id.original_file(db.upcast());\n             let syntax = in_file_source.value.syntax();\n-            (vis_offset(syntax), syntax.text_range(), file_id)\n+            (vis_offset(syntax), in_file_source.value.visibility(), syntax.text_range(), file_id)\n         }\n         // Enum variants can't be private, we can't modify builtin types\n         hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n     };\n \n-    Some((offset, target, target_file, target_name))\n+    Some((offset, current_visibility, target, target_file, target_name))\n }\n \n #[cfg(test)]\n@@ -522,6 +554,34 @@ struct Bar;\n         )\n     }\n \n+    #[test]\n+    fn replaces_pub_crate_with_pub() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+//- /main.rs crate:a deps:foo\n+foo::Bar<|>\n+//- /lib.rs crate:foo\n+pub(crate) struct Bar;\n+\",\n+            r\"$0pub struct Bar;\n+\",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+//- /main.rs crate:a deps:foo\n+fn main() {\n+    foo::Foo { <|>bar: () };\n+}\n+//- /lib.rs crate:foo\n+pub struct Foo { pub(crate) bar: () }\n+\",\n+            r\"pub struct Foo { $0pub bar: () }\n+\",\n+        );\n+    }\n+\n     #[test]\n     #[ignore]\n     // FIXME handle reexports properly"}, {"sha": "3cd5326505e2ed5a9457fc98fbbaa376bf687dd8", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: flip_binexpr\n //\n@@ -33,13 +33,18 @@ pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         return None;\n     }\n \n-    acc.add(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n-        if let FlipAction::FlipAndReplaceOp(new_op) = action {\n-            edit.replace(op_range, new_op);\n-        }\n-        edit.replace(lhs.text_range(), rhs.text());\n-        edit.replace(rhs.text_range(), lhs.text());\n-    })\n+    acc.add(\n+        AssistId(\"flip_binexpr\", AssistKind::RefactorRewrite),\n+        \"Flip binary expression\",\n+        op_range,\n+        |edit| {\n+            if let FlipAction::FlipAndReplaceOp(new_op) = action {\n+                edit.replace(op_range, new_op);\n+            }\n+            edit.replace(lhs.text_range(), rhs.text());\n+            edit.replace(rhs.text_range(), lhs.text());\n+        },\n+    )\n }\n \n enum FlipAction {"}, {"sha": "55a971dc77e0fa06491a4f465d8a3d0899f76195", "filename": "crates/ra_assists/src/handlers/flip_comma.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: flip_comma\n //\n@@ -28,10 +28,15 @@ pub(crate) fn flip_comma(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         return None;\n     }\n \n-    acc.add(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n-        edit.replace(prev.text_range(), next.to_string());\n-        edit.replace(next.text_range(), prev.to_string());\n-    })\n+    acc.add(\n+        AssistId(\"flip_comma\", AssistKind::RefactorRewrite),\n+        \"Flip comma\",\n+        comma.text_range(),\n+        |edit| {\n+            edit.replace(prev.text_range(), next.to_string());\n+            edit.replace(next.text_range(), prev.to_string());\n+        },\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "1234f4d2966e65416d2d0839c6b8080ce4747ecc", "filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     Direction, T,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: flip_trait_bound\n //\n@@ -33,10 +33,15 @@ pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext) -> Option\n     );\n \n     let target = plus.text_range();\n-    acc.add(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n-        edit.replace(before.text_range(), after.to_string());\n-        edit.replace(after.text_range(), before.to_string());\n-    })\n+    acc.add(\n+        AssistId(\"flip_trait_bound\", AssistKind::RefactorRewrite),\n+        \"Flip trait bounds\",\n+        target,\n+        |edit| {\n+            edit.replace(before.text_range(), after.to_string());\n+            edit.replace(after.text_range(), before.to_string());\n+        },\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "90ece9fab050eb5386ca5b9b6ab57aa0f915c3f2", "filename": "crates/ra_assists/src/handlers/generate_derive.rs", "status": "renamed", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -4,9 +4,9 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: add_derive\n+// Assist: generate_derive\n //\n // Adds a new `#[derive()]` clause to a struct or enum.\n //\n@@ -24,36 +24,41 @@ use crate::{AssistContext, AssistId, Assists};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let cap = ctx.config.snippet_cap?;\n-    let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n+    let nominal = ctx.find_node_at_offset::<ast::AdtDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n     let target = nominal.syntax().text_range();\n-    acc.add(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |builder| {\n-        let derive_attr = nominal\n-            .attrs()\n-            .filter_map(|x| x.as_simple_call())\n-            .filter(|(name, _arg)| name == \"derive\")\n-            .map(|(_name, arg)| arg)\n-            .next();\n-        match derive_attr {\n-            None => {\n-                builder.insert_snippet(cap, node_start, \"#[derive($0)]\\n\");\n-            }\n-            Some(tt) => {\n-                // Just move the cursor.\n-                builder.insert_snippet(\n-                    cap,\n-                    tt.syntax().text_range().end() - TextSize::of(')'),\n-                    \"$0\",\n-                )\n-            }\n-        };\n-    })\n+    acc.add(\n+        AssistId(\"generate_derive\", AssistKind::Generate),\n+        \"Add `#[derive]`\",\n+        target,\n+        |builder| {\n+            let derive_attr = nominal\n+                .attrs()\n+                .filter_map(|x| x.as_simple_call())\n+                .filter(|(name, _arg)| name == \"derive\")\n+                .map(|(_name, arg)| arg)\n+                .next();\n+            match derive_attr {\n+                None => {\n+                    builder.insert_snippet(cap, node_start, \"#[derive($0)]\\n\");\n+                }\n+                Some(tt) => {\n+                    // Just move the cursor.\n+                    builder.insert_snippet(\n+                        cap,\n+                        tt.syntax().text_range().end() - TextSize::of(')'),\n+                        \"$0\",\n+                    )\n+                }\n+            };\n+        },\n+    )\n }\n \n // Insert `derive` after doc comments.\n-fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextSize> {\n+fn derive_insertion_offset(nominal: &ast::AdtDef) -> Option<TextSize> {\n     let non_ws_child = nominal\n         .syntax()\n         .children_with_tokens()\n@@ -70,12 +75,12 @@ mod tests {\n     #[test]\n     fn add_derive_new() {\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"struct Foo { a: i32, <|>}\",\n             \"#[derive($0)]\\nstruct Foo { a: i32, }\",\n         );\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"struct Foo { <|> a: i32, }\",\n             \"#[derive($0)]\\nstruct Foo {  a: i32, }\",\n         );\n@@ -84,7 +89,7 @@ mod tests {\n     #[test]\n     fn add_derive_existing() {\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n             \"#[derive(Clone$0)]\\nstruct Foo { a: i32, }\",\n         );\n@@ -93,7 +98,7 @@ mod tests {\n     #[test]\n     fn add_derive_new_with_doc_comment() {\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"\n /// `Foo` is a pretty important struct.\n /// It does stuff.\n@@ -111,7 +116,7 @@ struct Foo { a: i32, }\n     #[test]\n     fn add_derive_target() {\n         check_assist_target(\n-            add_derive,\n+            generate_derive,\n             \"\n struct SomeThingIrrelevant;\n /// `Foo` is a pretty important struct.", "previous_filename": "crates/ra_assists/src/handlers/add_derive.rs"}, {"sha": "9da23640a68d2ccecb2d97be5e7d64e3e28072d6", "filename": "crates/ra_assists/src/handlers/generate_from_impl_for_enum.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,9 +2,9 @@ use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, AstNode, NameOwner};\n use test_utils::mark;\n \n-use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n+use crate::{utils::FamousDefs, AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: add_from_impl_for_enum\n+// Assist: generate_from_impl_for_enum\n //\n // Adds a From impl for an enum variant with one tuple field.\n //\n@@ -21,8 +21,8 @@ use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n //     }\n // }\n // ```\n-pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n+pub(crate) fn generate_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n     let enum_name = variant.parent_enum().name()?;\n     let field_list = match variant.kind() {\n@@ -32,7 +32,7 @@ pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) ->\n     if field_list.fields().count() != 1 {\n         return None;\n     }\n-    let field_type = field_list.fields().next()?.type_ref()?;\n+    let field_type = field_list.fields().next()?.ty()?;\n     let path = match field_type {\n         ast::TypeRef::PathType(it) => it,\n         _ => return None,\n@@ -45,8 +45,8 @@ pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) ->\n \n     let target = variant.syntax().text_range();\n     acc.add(\n-        AssistId(\"add_from_impl_for_enum\"),\n-        \"Add From impl for this enum variant\",\n+        AssistId(\"generate_from_impl_for_enum\", AssistKind::Generate),\n+        \"Generate `From` impl for this enum variant\",\n         target,\n         |edit| {\n             let start_offset = variant.parent_enum().syntax().text_range().end();\n@@ -69,7 +69,7 @@ impl From<{0}> for {1} {{\n \n fn existing_from_impl(\n     sema: &'_ hir::Semantics<'_, RootDatabase>,\n-    variant: &ast::EnumVariant,\n+    variant: &ast::Variant,\n ) -> Option<()> {\n     let variant = sema.to_def(variant)?;\n     let enum_ = variant.parent_enum(sema.db);\n@@ -97,9 +97,9 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_add_from_impl_for_enum() {\n+    fn test_generate_from_impl_for_enum() {\n         check_assist(\n-            add_from_impl_for_enum,\n+            generate_from_impl_for_enum,\n             \"enum A { <|>One(u32) }\",\n             r#\"enum A { One(u32) }\n \n@@ -112,9 +112,9 @@ impl From<u32> for A {\n     }\n \n     #[test]\n-    fn test_add_from_impl_for_enum_complicated_path() {\n+    fn test_generate_from_impl_for_enum_complicated_path() {\n         check_assist(\n-            add_from_impl_for_enum,\n+            generate_from_impl_for_enum,\n             r#\"enum A { <|>One(foo::bar::baz::Boo) }\"#,\n             r#\"enum A { One(foo::bar::baz::Boo) }\n \n@@ -129,7 +129,7 @@ impl From<foo::bar::baz::Boo> for A {\n     fn check_not_applicable(ra_fixture: &str) {\n         let fixture =\n             format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n-        check_assist_not_applicable(add_from_impl_for_enum, &fixture)\n+        check_assist_not_applicable(generate_from_impl_for_enum, &fixture)\n     }\n \n     #[test]\n@@ -166,7 +166,7 @@ impl From<u32> for A {\n     #[test]\n     fn test_add_from_impl_different_variant_impl_exists() {\n         check_assist(\n-            add_from_impl_for_enum,\n+            generate_from_impl_for_enum,\n             r#\"enum A { <|>One(u32), Two(String), }\n \n impl From<String> for A {", "previous_filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs"}, {"sha": "56510861dfb2aac1878e9075dfffa8e9588f3b10", "filename": "crates/ra_assists/src/handlers/generate_function.rs", "status": "renamed", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -13,10 +13,10 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use crate::{\n     assist_config::SnippetCap,\n     utils::{render_snippet, Cursor},\n-    AssistContext, AssistId, Assists,\n+    AssistContext, AssistId, AssistKind, Assists,\n };\n \n-// Assist: add_function\n+// Assist: generate_function\n //\n // Adds a stub function with a signature matching the function under the cursor.\n //\n@@ -41,7 +41,7 @@ use crate::{\n // }\n //\n // ```\n-pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n@@ -62,22 +62,27 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     let target = call.syntax().text_range();\n-    acc.add(AssistId(\"add_function\"), \"Add function\", target, |builder| {\n-        let function_template = function_builder.render();\n-        builder.edit_file(function_template.file);\n-        let new_fn = function_template.to_string(ctx.config.snippet_cap);\n-        match ctx.config.snippet_cap {\n-            Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n-            None => builder.insert(function_template.insert_offset, new_fn),\n-        }\n-    })\n+    acc.add(\n+        AssistId(\"generate_function\", AssistKind::Generate),\n+        format!(\"Generate `{}` function\", function_builder.fn_name),\n+        target,\n+        |builder| {\n+            let function_template = function_builder.render();\n+            builder.edit_file(function_template.file);\n+            let new_fn = function_template.to_string(ctx.config.snippet_cap);\n+            match ctx.config.snippet_cap {\n+                Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+                None => builder.insert(function_template.insert_offset, new_fn),\n+            }\n+        },\n+    )\n }\n \n struct FunctionTemplate {\n     insert_offset: TextSize,\n     placeholder_expr: ast::MacroCall,\n     leading_ws: String,\n-    fn_def: ast::FnDef,\n+    fn_def: ast::Fn,\n     trailing_ws: String,\n     file: FileId,\n }\n@@ -99,7 +104,7 @@ impl FunctionTemplate {\n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n-    type_params: Option<ast::TypeParamList>,\n+    type_params: Option<ast::GenericParamList>,\n     params: ast::ParamList,\n     file: FileId,\n     needs_pub: bool,\n@@ -117,7 +122,7 @@ impl FunctionBuilder {\n         let mut file = ctx.frange.file_id;\n         let target = match &target_module {\n             Some(target_module) => {\n-                let module_source = target_module.definition_source(ctx.db);\n+                let module_source = target_module.definition_source(ctx.db());\n                 let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n                 file = in_file;\n                 target\n@@ -195,7 +200,7 @@ fn fn_args(\n     ctx: &AssistContext,\n     target_module: hir::Module,\n     call: &ast::CallExpr,\n-) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n+) -> Option<(Option<ast::GenericParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n@@ -269,7 +274,7 @@ fn fn_arg_type(\n         return None;\n     }\n \n-    if let Ok(rendered) = ty.display_source_code(ctx.db, target_module.into()) {\n+    if let Ok(rendered) = ty.display_source_code(ctx.db(), target_module.into()) {\n         Some(rendered)\n     } else {\n         None\n@@ -333,7 +338,7 @@ mod tests {\n     #[test]\n     fn add_function_with_no_args() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     bar<|>();\n@@ -356,7 +361,7 @@ fn bar() {\n         // This ensures that the function is correctly generated\n         // in the next outer mod or file\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n impl Foo {\n     fn foo() {\n@@ -382,7 +387,7 @@ fn bar() {\n     fn add_function_directly_after_current_block() {\n         // The new fn should not be created at the end of the file or module\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo1() {\n     bar<|>();\n@@ -407,7 +412,7 @@ fn foo2() {}\n     #[test]\n     fn add_function_with_no_args_in_same_module() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod baz {\n     fn foo() {\n@@ -432,7 +437,7 @@ mod baz {\n     #[test]\n     fn add_function_with_function_call_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n fn baz() -> Baz { todo!() }\n@@ -457,7 +462,7 @@ fn bar(baz: Baz) {\n     #[test]\n     fn add_function_with_method_call_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n impl Baz {\n@@ -490,7 +495,7 @@ fn bar(baz: Baz) {\n     #[test]\n     fn add_function_with_string_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r#\"\n fn foo() {\n     <|>bar(\"bar\")\n@@ -511,7 +516,7 @@ fn bar(arg: &str) {\n     #[test]\n     fn add_function_with_char_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r#\"\n fn foo() {\n     <|>bar('x')\n@@ -532,7 +537,7 @@ fn bar(arg: char) {\n     #[test]\n     fn add_function_with_int_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     <|>bar(42)\n@@ -553,7 +558,7 @@ fn bar(arg: i32) {\n     #[test]\n     fn add_function_with_cast_int_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     <|>bar(42 as u8)\n@@ -576,7 +581,7 @@ fn bar(arg: u8) {\n         // Ensures that the name of the cast type isn't used\n         // in the generated function signature.\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     let x = 42;\n@@ -599,7 +604,7 @@ fn bar(x: u8) {\n     #[test]\n     fn add_function_with_variable_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     let worble = ();\n@@ -622,7 +627,7 @@ fn bar(worble: ()) {\n     #[test]\n     fn add_function_with_impl_trait_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n trait Foo {}\n fn foo() -> impl Foo {\n@@ -651,7 +656,7 @@ fn bar(foo: impl Foo) {\n     #[test]\n     fn borrowed_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n fn baz() -> Baz { todo!() }\n@@ -678,7 +683,7 @@ fn bar(baz: &Baz) {\n     #[test]\n     fn add_function_with_qualified_path_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod Baz {\n     pub struct Bof;\n@@ -709,7 +714,7 @@ fn bar(baz: Baz::Bof) {\n     // FIXME fix printing the generics of a `Ty` to make this test pass\n     fn add_function_with_generic_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo<T>(t: T) {\n     <|>bar(t)\n@@ -732,7 +737,7 @@ fn bar<T>(t: T) {\n     // FIXME Fix function type printing to make this test pass\n     fn add_function_with_fn_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n impl Baz {\n@@ -763,7 +768,7 @@ fn bar(arg: fn() -> Baz) {\n     // FIXME Fix closure type printing to make this test pass\n     fn add_function_with_closure_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     let closure = |x: i64| x - 1;\n@@ -786,7 +791,7 @@ fn bar(closure: impl Fn(i64) -> i64) {\n     #[test]\n     fn unresolveable_types_default_to_unit() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     <|>bar(baz)\n@@ -807,7 +812,7 @@ fn bar(baz: ()) {\n     #[test]\n     fn arg_names_dont_overlap() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n fn baz() -> Baz { Baz }\n@@ -832,7 +837,7 @@ fn bar(baz_1: Baz, baz_2: Baz) {\n     #[test]\n     fn arg_name_counters_start_at_1_per_name() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r#\"\n struct Baz;\n fn baz() -> Baz { Baz }\n@@ -857,7 +862,7 @@ fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n     #[test]\n     fn add_function_in_module() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod bar {}\n \n@@ -885,7 +890,7 @@ fn foo() {\n     // See https://github.com/rust-analyzer/rust-analyzer/issues/1165\n     fn qualified_path_uses_correct_scope() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             \"\n mod foo {\n     pub struct Foo;\n@@ -916,7 +921,7 @@ fn baz(foo: foo::Foo) {\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod bar {\n     fn something_else() {}\n@@ -945,7 +950,7 @@ fn foo() {\n     #[test]\n     fn add_function_in_nested_module() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod bar {\n     mod baz {}\n@@ -974,7 +979,7 @@ fn foo() {\n     #[test]\n     fn add_function_in_another_file() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n //- /main.rs\n mod foo;\n@@ -996,7 +1001,7 @@ pub(crate) fn bar() {\n     #[test]\n     fn add_function_not_applicable_if_function_already_exists() {\n         check_assist_not_applicable(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     bar<|>();\n@@ -1013,7 +1018,7 @@ fn bar() {}\n             // bar is resolved, but baz isn't.\n             // The assist is only active if the cursor is on an unresolved path,\n             // but the assist should only be offered if the path is a function call.\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     bar(b<|>az);\n@@ -1028,7 +1033,7 @@ fn bar(baz: ()) {}\n     #[ignore]\n     fn create_method_with_no_args() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Foo;\n impl Foo {", "previous_filename": "crates/ra_assists/src/handlers/add_function.rs"}, {"sha": "d9b87c9c0dd79795e1a4ef6b78a60fe143b70044", "filename": "crates/ra_assists/src/handlers/generate_impl.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -0,0 +1,109 @@\n+use ra_syntax::ast::{self, AstNode, GenericParamsOwner, NameOwner};\n+use stdx::{format_to, SepBy};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: generate_impl\n+//\n+// Adds a new inherent impl for a type.\n+//\n+// ```\n+// struct Ctx<T: Clone> {\n+//     data: T,<|>\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Ctx<T: Clone> {\n+//     data: T,\n+// }\n+//\n+// impl<T: Clone> Ctx<T> {\n+//     $0\n+// }\n+// ```\n+pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let nominal = ctx.find_node_at_offset::<ast::AdtDef>()?;\n+    let name = nominal.name()?;\n+    let target = nominal.syntax().text_range();\n+    acc.add(\n+        AssistId(\"generate_impl\", AssistKind::Generate),\n+        format!(\"Generate impl for `{}`\", name),\n+        target,\n+        |edit| {\n+            let type_params = nominal.generic_param_list();\n+            let start_offset = nominal.syntax().text_range().end();\n+            let mut buf = String::new();\n+            buf.push_str(\"\\n\\nimpl\");\n+            if let Some(type_params) = &type_params {\n+                format_to!(buf, \"{}\", type_params.syntax());\n+            }\n+            buf.push_str(\" \");\n+            buf.push_str(name.text().as_str());\n+            if let Some(type_params) = type_params {\n+                let lifetime_params = type_params\n+                    .lifetime_params()\n+                    .filter_map(|it| it.lifetime_token())\n+                    .map(|it| it.text().clone());\n+                let type_params = type_params\n+                    .type_params()\n+                    .filter_map(|it| it.name())\n+                    .map(|it| it.text().clone());\n+\n+                let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n+                format_to!(buf, \"<{}>\", generic_params)\n+            }\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    buf.push_str(\" {\\n    $0\\n}\");\n+                    edit.insert_snippet(cap, start_offset, buf);\n+                }\n+                None => {\n+                    buf.push_str(\" {\\n}\");\n+                    edit.insert(start_offset, buf);\n+                }\n+            }\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_target};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_add_impl() {\n+        check_assist(\n+            generate_impl,\n+            \"struct Foo {<|>}\\n\",\n+            \"struct Foo {}\\n\\nimpl Foo {\\n    $0\\n}\\n\",\n+        );\n+        check_assist(\n+            generate_impl,\n+            \"struct Foo<T: Clone> {<|>}\",\n+            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n    $0\\n}\",\n+        );\n+        check_assist(\n+            generate_impl,\n+            \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n+            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n    $0\\n}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn add_impl_target() {\n+        check_assist_target(\n+            generate_impl,\n+            \"\n+struct SomeThingIrrelevant;\n+/// Has a lifetime parameter\n+struct Foo<'a, T: Foo<'a>> {<|>}\n+struct EvenMoreIrrelevant;\n+\",\n+            \"/// Has a lifetime parameter\n+struct Foo<'a, T: Foo<'a>> {}\",\n+        );\n+    }\n+}"}, {"sha": "b84aa24b6c760b5e8a27a37dfa03627b9d5b1865", "filename": "crates/ra_assists/src/handlers/generate_new.rs", "status": "renamed", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,15 +1,13 @@\n use hir::Adt;\n use ra_syntax::{\n-    ast::{\n-        self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n-    },\n+    ast::{self, AstNode, GenericParamsOwner, NameOwner, StructKind, VisibilityOwner},\n     T,\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: add_new\n+// Assist: generate_new\n //\n // Adds a new inherent impl for a type.\n //\n@@ -29,8 +27,8 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n //\n // ```\n-pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n+pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n \n     // We want to only apply this to non-union structs with named fields\n     let field_list = match strukt.kind() {\n@@ -42,7 +40,7 @@ pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let impl_def = find_struct_impl(&ctx, &strukt)?;\n \n     let target = strukt.syntax().text_range();\n-    acc.add(AssistId(\"add_new\"), \"Add default constructor\", target, |builder| {\n+    acc.add(AssistId(\"generate_new\", AssistKind::Generate), \"Generate `new`\", target, |builder| {\n         let mut buf = String::with_capacity(512);\n \n         if impl_def.is_some() {\n@@ -53,9 +51,7 @@ pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n \n         let params = field_list\n             .fields()\n-            .filter_map(|f| {\n-                Some(format!(\"{}: {}\", f.name()?.syntax(), f.ascribed_type()?.syntax()))\n-            })\n+            .filter_map(|f| Some(format!(\"{}: {}\", f.name()?.syntax(), f.ty()?.syntax())))\n             .sep_by(\", \");\n         let fields = field_list.fields().filter_map(|f| f.name()).sep_by(\", \");\n \n@@ -90,8 +86,8 @@ pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n \n // Generates the surrounding `impl Type { <code> }` including type and lifetime\n // parameters\n-fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n-    let type_params = strukt.type_param_list();\n+fn generate_impl_text(strukt: &ast::Struct, code: &str) -> String {\n+    let type_params = strukt.generic_param_list();\n     let mut buf = String::with_capacity(code.len());\n     buf.push_str(\"\\n\\nimpl\");\n     if let Some(type_params) = &type_params {\n@@ -121,15 +117,15 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n //\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(ctx: &AssistContext, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n-    let db = ctx.db;\n+fn find_struct_impl(ctx: &AssistContext, strukt: &ast::Struct) -> Option<Option<ast::Impl>> {\n+    let db = ctx.db();\n     let module = strukt.syntax().ancestors().find(|node| {\n         ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n     })?;\n \n     let struct_def = ctx.sema.to_def(strukt)?;\n \n-    let block = module.descendants().filter_map(ast::ImplDef::cast).find_map(|impl_blk| {\n+    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {\n         let blk = ctx.sema.to_def(&impl_blk)?;\n \n         // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n@@ -157,10 +153,10 @@ fn find_struct_impl(ctx: &AssistContext, strukt: &ast::StructDef) -> Option<Opti\n     Some(block)\n }\n \n-fn has_new_fn(imp: &ast::ImplDef) -> bool {\n-    if let Some(il) = imp.item_list() {\n+fn has_new_fn(imp: &ast::Impl) -> bool {\n+    if let Some(il) = imp.assoc_item_list() {\n         for item in il.assoc_items() {\n-            if let ast::AssocItem::FnDef(f) = item {\n+            if let ast::AssocItem::Fn(f) = item {\n                 if let Some(name) = f.name() {\n                     if name.text().eq_ignore_ascii_case(\"new\") {\n                         return true;\n@@ -181,10 +177,10 @@ mod tests {\n \n     #[test]\n     #[rustfmt::skip]\n-    fn test_add_new() {\n+    fn test_generate_new() {\n         // Check output of generation\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\",\n \"struct Foo {}\n \n@@ -194,7 +190,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo<T: Clone> {<|>}\",\n \"struct Foo<T: Clone> {}\n \n@@ -204,7 +200,7 @@ impl<T: Clone> Foo<T> {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n \"struct Foo<'a, T: Foo<'a>> {}\n \n@@ -214,7 +210,7 @@ impl<'a, T: Foo<'a>> Foo<'a, T> {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo { baz: String <|>}\",\n \"struct Foo { baz: String }\n \n@@ -224,7 +220,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo { baz: String, qux: Vec<i32> <|>}\",\n \"struct Foo { baz: String, qux: Vec<i32> }\n \n@@ -236,7 +232,7 @@ impl Foo {\n \n         // Check that visibility modifiers don't get brought in for fields\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo { pub baz: String, pub qux: Vec<i32> <|>}\",\n \"struct Foo { pub baz: String, pub qux: Vec<i32> }\n \n@@ -248,7 +244,7 @@ impl Foo {\n \n         // Check that it reuses existing impls\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\n \n impl Foo {}\n@@ -261,7 +257,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\n \n impl Foo {\n@@ -279,7 +275,7 @@ impl Foo {\n         );\n \n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\n \n impl Foo {\n@@ -304,7 +300,7 @@ impl Foo {\n \n         // Check visibility of new fn based on struct\n         check_assist(\n-            add_new,\n+            generate_new,\n \"pub struct Foo {<|>}\",\n \"pub struct Foo {}\n \n@@ -314,7 +310,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"pub(crate) struct Foo {<|>}\",\n \"pub(crate) struct Foo {}\n \n@@ -326,9 +322,9 @@ impl Foo {\n     }\n \n     #[test]\n-    fn add_new_not_applicable_if_fn_exists() {\n+    fn generate_new_not_applicable_if_fn_exists() {\n         check_assist_not_applicable(\n-            add_new,\n+            generate_new,\n             \"\n struct Foo {<|>}\n \n@@ -340,7 +336,7 @@ impl Foo {\n         );\n \n         check_assist_not_applicable(\n-            add_new,\n+            generate_new,\n             \"\n struct Foo {<|>}\n \n@@ -353,9 +349,9 @@ impl Foo {\n     }\n \n     #[test]\n-    fn add_new_target() {\n+    fn generate_new_target() {\n         check_assist_target(\n-            add_new,\n+            generate_new,\n             \"\n struct SomeThingIrrelevant;\n /// Has a lifetime parameter\n@@ -370,7 +366,7 @@ struct Foo<'a, T: Foo<'a>> {}\",\n     #[test]\n     fn test_unrelated_new() {\n         check_assist(\n-            add_new,\n+            generate_new,\n             r##\"\n pub struct AstId<N: AstNode> {\n     file_id: HirFileId,", "previous_filename": "crates/ra_assists/src/handlers/add_new.rs"}, {"sha": "2fdfabaf53fe674edb76a9c5bc2906fa02e7cc98", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -7,7 +7,7 @@ use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n-    AssistId,\n+    AssistId, AssistKind,\n };\n \n // Assist: inline_local_variable\n@@ -44,7 +44,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n \n     let def = ctx.sema.to_def(&bind_pat)?;\n     let def = Definition::Local(def);\n-    let refs = def.find_usages(ctx.db, None);\n+    let refs = def.find_usages(&ctx.sema, None);\n     if refs.is_empty() {\n         mark::hit!(test_not_applicable_if_variable_unused);\n         return None;\n@@ -110,13 +110,19 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n     let init_in_paren = format!(\"({})\", &init_str);\n \n     let target = bind_pat.syntax().text_range();\n-    acc.add(AssistId(\"inline_local_variable\"), \"Inline variable\", target, move |builder| {\n-        builder.delete(delete_range);\n-        for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n-            let replacement = if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-            builder.replace(desc.file_range.range, replacement)\n-        }\n-    })\n+    acc.add(\n+        AssistId(\"inline_local_variable\", AssistKind::RefactorInline),\n+        \"Inline variable\",\n+        target,\n+        move |builder| {\n+            builder.delete(delete_range);\n+            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+                let replacement =\n+                    if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n+                builder.replace(desc.file_range.range, replacement)\n+            }\n+        },\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "c3134f64d0592574511ac8b397916aa794de366d", "filename": "crates/ra_assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,10 +1,10 @@\n use ra_syntax::{\n-    ast::{self, NameOwner, TypeAscriptionOwner, TypeParamsOwner},\n+    ast::{self, GenericParamsOwner, NameOwner},\n     AstNode, SyntaxKind, TextRange, TextSize,\n };\n use rustc_hash::FxHashSet;\n \n-use crate::{assist_context::AssistBuilder, AssistContext, AssistId, Assists};\n+use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n \n static ASSIST_NAME: &str = \"introduce_named_lifetime\";\n static ASSIST_LABEL: &str = \"Introduce named lifetime\";\n@@ -38,9 +38,9 @@ pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -\n     let lifetime_token = ctx\n         .find_token_at_offset(SyntaxKind::LIFETIME)\n         .filter(|lifetime| lifetime.text() == \"'_\")?;\n-    if let Some(fn_def) = lifetime_token.ancestors().find_map(ast::FnDef::cast) {\n+    if let Some(fn_def) = lifetime_token.ancestors().find_map(ast::Fn::cast) {\n         generate_fn_def_assist(acc, &fn_def, lifetime_token.text_range())\n-    } else if let Some(impl_def) = lifetime_token.ancestors().find_map(ast::ImplDef::cast) {\n+    } else if let Some(impl_def) = lifetime_token.ancestors().find_map(ast::Impl::cast) {\n         generate_impl_def_assist(acc, &impl_def, lifetime_token.text_range())\n     } else {\n         None\n@@ -50,11 +50,11 @@ pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -\n /// Generate the assist for the fn def case\n fn generate_fn_def_assist(\n     acc: &mut Assists,\n-    fn_def: &ast::FnDef,\n+    fn_def: &ast::Fn,\n     lifetime_loc: TextRange,\n ) -> Option<()> {\n     let param_list: ast::ParamList = fn_def.param_list()?;\n-    let new_lifetime_param = generate_unique_lifetime_param_name(&fn_def.type_param_list())?;\n+    let new_lifetime_param = generate_unique_lifetime_param_name(&fn_def.generic_param_list())?;\n     let end_of_fn_ident = fn_def.name()?.ident_token()?.text_range().end();\n     let self_param =\n         // use the self if it's a reference and has no explicit lifetime\n@@ -67,7 +67,7 @@ fn generate_fn_def_assist(\n         // otherwise, if there's a single reference parameter without a named liftime, use that\n         let fn_params_without_lifetime: Vec<_> = param_list\n             .params()\n-            .filter_map(|param| match param.ascribed_type() {\n+            .filter_map(|param| match param.ty() {\n                 Some(ast::TypeRef::ReferenceType(ascribed_type))\n                     if ascribed_type.lifetime_token() == None =>\n                 {\n@@ -83,7 +83,7 @@ fn generate_fn_def_assist(\n             _ => return None,\n         }\n     };\n-    acc.add(AssistId(ASSIST_NAME), ASSIST_LABEL, lifetime_loc, |builder| {\n+    acc.add(AssistId(ASSIST_NAME, AssistKind::Refactor), ASSIST_LABEL, lifetime_loc, |builder| {\n         add_lifetime_param(fn_def, builder, end_of_fn_ident, new_lifetime_param);\n         builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n         loc_needing_lifetime.map(|loc| builder.insert(loc, format!(\"'{} \", new_lifetime_param)));\n@@ -93,12 +93,12 @@ fn generate_fn_def_assist(\n /// Generate the assist for the impl def case\n fn generate_impl_def_assist(\n     acc: &mut Assists,\n-    impl_def: &ast::ImplDef,\n+    impl_def: &ast::Impl,\n     lifetime_loc: TextRange,\n ) -> Option<()> {\n-    let new_lifetime_param = generate_unique_lifetime_param_name(&impl_def.type_param_list())?;\n+    let new_lifetime_param = generate_unique_lifetime_param_name(&impl_def.generic_param_list())?;\n     let end_of_impl_kw = impl_def.impl_token()?.text_range().end();\n-    acc.add(AssistId(ASSIST_NAME), ASSIST_LABEL, lifetime_loc, |builder| {\n+    acc.add(AssistId(ASSIST_NAME, AssistKind::Refactor), ASSIST_LABEL, lifetime_loc, |builder| {\n         add_lifetime_param(impl_def, builder, end_of_impl_kw, new_lifetime_param);\n         builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n     })\n@@ -107,7 +107,7 @@ fn generate_impl_def_assist(\n /// Given a type parameter list, generate a unique lifetime parameter name\n /// which is not in the list\n fn generate_unique_lifetime_param_name(\n-    existing_type_param_list: &Option<ast::TypeParamList>,\n+    existing_type_param_list: &Option<ast::GenericParamList>,\n ) -> Option<char> {\n     match existing_type_param_list {\n         Some(type_params) => {\n@@ -123,13 +123,13 @@ fn generate_unique_lifetime_param_name(\n \n /// Add the lifetime param to `builder`. If there are type parameters in `type_params_owner`, add it to the end. Otherwise\n /// add new type params brackets with the lifetime parameter at `new_type_params_loc`.\n-fn add_lifetime_param<TypeParamsOwner: ast::TypeParamsOwner>(\n+fn add_lifetime_param<TypeParamsOwner: ast::GenericParamsOwner>(\n     type_params_owner: &TypeParamsOwner,\n     builder: &mut AssistBuilder,\n     new_type_params_loc: TextSize,\n     new_lifetime_param: char,\n ) {\n-    match type_params_owner.type_param_list() {\n+    match type_params_owner.generic_param_list() {\n         // add the new lifetime parameter to an existing type param list\n         Some(type_params) => {\n             builder.insert("}, {"sha": "bbe3f364360515b31cd601192950cdb356a3358b", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n use crate::{\n     assist_context::{AssistContext, Assists},\n     utils::invert_boolean_expression,\n-    AssistId,\n+    AssistId, AssistKind,\n };\n \n // Assist: invert_if\n@@ -54,7 +54,7 @@ pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let else_node = else_block.syntax();\n     let else_range = else_node.text_range();\n     let then_range = then_node.text_range();\n-    acc.add(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n+    acc.add(AssistId(\"invert_if\", AssistKind::RefactorRewrite), \"Invert if\", if_range, |edit| {\n         edit.replace(cond_range, flip_cond.syntax().text());\n         edit.replace(else_range, then_node.text());\n         edit.replace(then_range, else_node.text());"}, {"sha": "c775fe25c52fdfcf8f79dc01facf93d42e6273ab", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::{\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n-    AssistId,\n+    AssistId, AssistKind,\n };\n \n // Assist: merge_imports\n@@ -28,7 +28,7 @@ pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n     let mut rewriter = SyntaxRewriter::default();\n     let mut offset = ctx.offset();\n \n-    if let Some(use_item) = tree.syntax().parent().and_then(ast::UseItem::cast) {\n+    if let Some(use_item) = tree.syntax().parent().and_then(ast::Use::cast) {\n         let (merged, to_delete) = next_prev()\n             .filter_map(|dir| neighbor(&use_item, dir))\n             .filter_map(|it| Some((it.clone(), it.use_tree()?)))\n@@ -56,9 +56,14 @@ pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n     };\n \n     let target = tree.syntax().text_range();\n-    acc.add(AssistId(\"merge_imports\"), \"Merge imports\", target, |builder| {\n-        builder.rewrite(rewriter);\n-    })\n+    acc.add(\n+        AssistId(\"merge_imports\", AssistKind::RefactorRewrite),\n+        \"Merge imports\",\n+        target,\n+        |builder| {\n+            builder.rewrite(rewriter);\n+        },\n+    )\n }\n \n fn next_prev() -> impl Iterator<Item = Direction> {"}, {"sha": "186a1f61839b8d9bbf95167ea26a7c411c621edb", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n     Direction,\n };\n \n-use crate::{AssistContext, AssistId, Assists, TextRange};\n+use crate::{AssistContext, AssistId, AssistKind, Assists, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -59,25 +59,30 @@ pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option\n         return None;\n     }\n \n-    acc.add(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n-        let pats = if arms_to_merge.iter().any(contains_placeholder) {\n-            \"_\".into()\n-        } else {\n-            arms_to_merge\n-                .iter()\n-                .filter_map(ast::MatchArm::pat)\n-                .map(|x| x.syntax().to_string())\n-                .collect::<Vec<String>>()\n-                .join(\" | \")\n-        };\n-\n-        let arm = format!(\"{} => {}\", pats, current_expr.syntax().text());\n-\n-        let start = arms_to_merge.first().unwrap().syntax().text_range().start();\n-        let end = arms_to_merge.last().unwrap().syntax().text_range().end();\n-\n-        edit.replace(TextRange::new(start, end), arm);\n-    })\n+    acc.add(\n+        AssistId(\"merge_match_arms\", AssistKind::RefactorRewrite),\n+        \"Merge match arms\",\n+        current_text_range,\n+        |edit| {\n+            let pats = if arms_to_merge.iter().any(contains_placeholder) {\n+                \"_\".into()\n+            } else {\n+                arms_to_merge\n+                    .iter()\n+                    .filter_map(ast::MatchArm::pat)\n+                    .map(|x| x.syntax().to_string())\n+                    .collect::<Vec<String>>()\n+                    .join(\" | \")\n+            };\n+\n+            let arm = format!(\"{} => {}\", pats, current_expr.syntax().text());\n+\n+            let start = arms_to_merge.first().unwrap().syntax().text_range().start();\n+            let end = arms_to_merge.last().unwrap().syntax().text_range().end();\n+\n+            edit.replace(TextRange::new(start, end), arm);\n+        },\n+    )\n }\n \n fn contains_placeholder(a: &ast::MatchArm) -> bool {"}, {"sha": "6d394443ebf4d51d0319feb55f8135fddcc18731", "filename": "crates/ra_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: move_bounds_to_where_clause\n //\n@@ -23,7 +23,7 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n // ```\n pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let type_param_list = ctx.find_node_at_offset::<ast::TypeParamList>()?;\n+    let type_param_list = ctx.find_node_at_offset::<ast::GenericParamList>()?;\n \n     let mut type_params = type_param_list.type_params();\n     if type_params.all(|p| p.type_bound_list().is_none()) {\n@@ -37,42 +37,49 @@ pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext\n \n     let anchor = match_ast! {\n         match parent {\n-            ast::FnDef(it) => it.body()?.syntax().clone().into(),\n-            ast::TraitDef(it) => it.item_list()?.syntax().clone().into(),\n-            ast::ImplDef(it) => it.item_list()?.syntax().clone().into(),\n-            ast::EnumDef(it) => it.variant_list()?.syntax().clone().into(),\n-            ast::StructDef(it) => {\n+            ast::Fn(it) => it.body()?.syntax().clone().into(),\n+            ast::Trait(it) => it.assoc_item_list()?.syntax().clone().into(),\n+            ast::Impl(it) => it.assoc_item_list()?.syntax().clone().into(),\n+            ast::Enum(it) => it.variant_list()?.syntax().clone().into(),\n+            ast::Struct(it) => {\n                 it.syntax().children_with_tokens()\n-                    .find(|it| it.kind() == RECORD_FIELD_DEF_LIST || it.kind() == T![;])?\n+                    .find(|it| it.kind() == RECORD_FIELD_LIST || it.kind() == T![;])?\n             },\n             _ => return None\n         }\n     };\n \n     let target = type_param_list.syntax().text_range();\n-    acc.add(AssistId(\"move_bounds_to_where_clause\"), \"Move to where clause\", target, |edit| {\n-        let new_params = type_param_list\n-            .type_params()\n-            .filter(|it| it.type_bound_list().is_some())\n-            .map(|type_param| {\n-                let without_bounds = type_param.remove_bounds();\n-                (type_param, without_bounds)\n-            });\n-\n-        let new_type_param_list = type_param_list.replace_descendants(new_params);\n-        edit.replace_ast(type_param_list.clone(), new_type_param_list);\n-\n-        let where_clause = {\n-            let predicates = type_param_list.type_params().filter_map(build_predicate);\n-            make::where_clause(predicates)\n-        };\n-\n-        let to_insert = match anchor.prev_sibling_or_token() {\n-            Some(ref elem) if elem.kind() == WHITESPACE => format!(\"{} \", where_clause.syntax()),\n-            _ => format!(\" {}\", where_clause.syntax()),\n-        };\n-        edit.insert(anchor.text_range().start(), to_insert);\n-    })\n+    acc.add(\n+        AssistId(\"move_bounds_to_where_clause\", AssistKind::RefactorRewrite),\n+        \"Move to where clause\",\n+        target,\n+        |edit| {\n+            let new_params = type_param_list\n+                .type_params()\n+                .filter(|it| it.type_bound_list().is_some())\n+                .map(|type_param| {\n+                    let without_bounds = type_param.remove_bounds();\n+                    (type_param, without_bounds)\n+                });\n+\n+            let new_type_param_list = type_param_list.replace_descendants(new_params);\n+            edit.replace_ast(type_param_list.clone(), new_type_param_list);\n+\n+            let where_clause = {\n+                let predicates = type_param_list.type_params().filter_map(build_predicate);\n+                make::where_clause(predicates)\n+            };\n+\n+            let to_insert = match anchor.prev_sibling_or_token() {\n+                Some(ref elem) if elem.kind() == WHITESPACE => {\n+                    format!(\"{} \", where_clause.syntax())\n+                }\n+                _ => format!(\" {}\", where_clause.syntax()),\n+            };\n+            edit.insert(anchor.text_range().start(), to_insert);\n+        },\n+    )\n }\n \n fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {"}, {"sha": "4060d34c641455993534c84d2a6cde8d169e33cd", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     SyntaxKind::WHITESPACE,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: move_guard_to_arm_body\n //\n@@ -40,17 +40,22 @@ pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) ->\n     let buf = format!(\"if {} {{ {} }}\", guard_conditions.syntax().text(), arm_expr.syntax().text());\n \n     let target = guard.syntax().text_range();\n-    acc.add(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n-        match space_before_guard {\n-            Some(element) if element.kind() == WHITESPACE => {\n-                edit.delete(element.text_range());\n-            }\n-            _ => (),\n-        };\n+    acc.add(\n+        AssistId(\"move_guard_to_arm_body\", AssistKind::RefactorRewrite),\n+        \"Move guard to arm body\",\n+        target,\n+        |edit| {\n+            match space_before_guard {\n+                Some(element) if element.kind() == WHITESPACE => {\n+                    edit.delete(element.text_range());\n+                }\n+                _ => (),\n+            };\n \n-        edit.delete(guard.syntax().text_range());\n-        edit.replace_node_and_indent(arm_expr.syntax(), buf);\n-    })\n+            edit.delete(guard.syntax().text_range());\n+            edit.replace_node_and_indent(arm_expr.syntax(), buf);\n+        },\n+    )\n }\n \n // Assist: move_arm_cond_to_match_guard\n@@ -100,7 +105,7 @@ pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContex\n \n     let target = if_expr.syntax().text_range();\n     acc.add(\n-        AssistId(\"move_arm_cond_to_match_guard\"),\n+        AssistId(\"move_arm_cond_to_match_guard\", AssistKind::RefactorRewrite),\n         \"Move condition to match guard\",\n         target,\n         |edit| {"}, {"sha": "4e8a0c2db6552b45b859f051b5cc48a065b8133d", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 90, "deletions": 86, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,11 +1,14 @@\n+use std::borrow::Cow;\n+\n use ra_syntax::{\n-    ast::{self, HasStringValue},\n+    ast::{self, HasQuotes, HasStringValue},\n     AstToken,\n     SyntaxKind::{RAW_STRING, STRING},\n-    TextSize,\n+    TextRange, TextSize,\n };\n+use test_utils::mark;\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: make_raw_string\n //\n@@ -26,14 +29,24 @@ pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    acc.add(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n-        let max_hash_streak = count_hashes(&value);\n-        let mut hashes = String::with_capacity(max_hash_streak + 1);\n-        for _ in 0..hashes.capacity() {\n-            hashes.push('#');\n-        }\n-        edit.replace(token.syntax().text_range(), format!(\"r{}\\\"{}\\\"{}\", hashes, value, hashes));\n-    })\n+    acc.add(\n+        AssistId(\"make_raw_string\", AssistKind::RefactorRewrite),\n+        \"Rewrite as raw string\",\n+        target,\n+        |edit| {\n+            let hashes = \"#\".repeat(required_hashes(&value).max(1));\n+            if matches!(value, Cow::Borrowed(_)) {\n+                // Avoid replacing the whole string to better position the cursor.\n+                edit.insert(token.syntax().text_range().start(), format!(\"r{}\", hashes));\n+                edit.insert(token.syntax().text_range().end(), format!(\"{}\", hashes));\n+            } else {\n+                edit.replace(\n+                    token.syntax().text_range(),\n+                    format!(\"r{}\\\"{}\\\"{}\", hashes, value, hashes),\n+                );\n+            }\n+        },\n+    )\n }\n \n // Assist: make_usual_string\n@@ -55,11 +68,24 @@ pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    acc.add(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n-        // parse inside string to escape `\"`\n-        let escaped = value.escape_default().to_string();\n-        edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n-    })\n+    acc.add(\n+        AssistId(\"make_usual_string\", AssistKind::RefactorRewrite),\n+        \"Rewrite as regular string\",\n+        target,\n+        |edit| {\n+            // parse inside string to escape `\"`\n+            let escaped = value.escape_default().to_string();\n+            if let Some(offsets) = token.quote_offsets() {\n+                if token.text()[offsets.contents - token.syntax().text_range().start()] == escaped {\n+                    edit.replace(offsets.quotes.0, \"\\\"\");\n+                    edit.replace(offsets.quotes.1, \"\\\"\");\n+                    return;\n+                }\n+            }\n+\n+            edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n+        },\n+    )\n }\n \n // Assist: add_hash\n@@ -80,7 +106,7 @@ pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Optio\n pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let target = token.text_range();\n-    acc.add(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n+    acc.add(AssistId(\"add_hash\", AssistKind::Refactor), \"Add #\", target, |edit| {\n         edit.insert(token.text_range().start() + TextSize::of('r'), \"#\");\n         edit.insert(token.text_range().end(), \"#\");\n     })\n@@ -102,44 +128,58 @@ pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n // }\n // ```\n pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let token = ctx.find_token_at_offset(RAW_STRING)?;\n+    let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n+\n     let text = token.text().as_str();\n-    if text.starts_with(\"r\\\"\") {\n-        // no hash to remove\n+    if !text.starts_with(\"r#\") && text.ends_with('#') {\n         return None;\n     }\n-    let target = token.text_range();\n-    acc.add(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n-        let result = &text[2..text.len() - 1];\n-        let result = if result.starts_with('\\\"') {\n-            // FIXME: this logic is wrong, not only the last has has to handled specially\n-            // no more hash, escape\n-            let internal_str = &result[1..result.len() - 1];\n-            format!(\"\\\"{}\\\"\", internal_str.escape_default().to_string())\n-        } else {\n-            result.to_owned()\n-        };\n-        edit.replace(token.text_range(), format!(\"r{}\", result));\n+\n+    let existing_hashes = text.chars().skip(1).take_while(|&it| it == '#').count();\n+\n+    let text_range = token.syntax().text_range();\n+    let internal_text = &text[token.text_range_between_quotes()? - text_range.start()];\n+\n+    if existing_hashes == required_hashes(internal_text) {\n+        mark::hit!(cant_remove_required_hash);\n+        return None;\n+    }\n+\n+    acc.add(AssistId(\"remove_hash\", AssistKind::RefactorRewrite), \"Remove #\", text_range, |edit| {\n+        edit.delete(TextRange::at(text_range.start() + TextSize::of('r'), TextSize::of('#')));\n+        edit.delete(TextRange::new(text_range.end() - TextSize::of('#'), text_range.end()));\n     })\n }\n \n-fn count_hashes(s: &str) -> usize {\n-    let mut max_hash_streak = 0usize;\n-    for idx in s.match_indices(\"\\\"#\").map(|(i, _)| i) {\n+fn required_hashes(s: &str) -> usize {\n+    let mut res = 0usize;\n+    for idx in s.match_indices('\"').map(|(i, _)| i) {\n         let (_, sub) = s.split_at(idx + 1);\n-        let nb_hash = sub.chars().take_while(|c| *c == '#').count();\n-        if nb_hash > max_hash_streak {\n-            max_hash_streak = nb_hash;\n-        }\n+        let n_hashes = sub.chars().take_while(|c| *c == '#').count();\n+        res = res.max(n_hashes + 1)\n     }\n-    max_hash_streak\n+    res\n+}\n+\n+#[test]\n+fn test_required_hashes() {\n+    assert_eq!(0, required_hashes(\"abc\"));\n+    assert_eq!(0, required_hashes(\"###\"));\n+    assert_eq!(1, required_hashes(\"\\\"\"));\n+    assert_eq!(2, required_hashes(\"\\\"#abc\"));\n+    assert_eq!(0, required_hashes(\"#abc\"));\n+    assert_eq!(3, required_hashes(\"#ab\\\"##c\"));\n+    assert_eq!(5, required_hashes(\"#ab\\\"##\\\"####c\"));\n }\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n+    use test_utils::mark;\n+\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     fn make_raw_string_target() {\n         check_assist_target(\n@@ -341,33 +381,21 @@ string\"###;\n     fn remove_hash_works() {\n         check_assist(\n             remove_hash,\n-            r##\"\n-            fn f() {\n-                let s = <|>r#\"random string\"#;\n-            }\n-            \"##,\n-            r#\"\n-            fn f() {\n-                let s = r\"random string\";\n-            }\n-            \"#,\n+            r##\"fn f() { let s = <|>r#\"random string\"#; }\"##,\n+            r#\"fn f() { let s = r\"random string\"; }\"#,\n         )\n     }\n \n     #[test]\n-    fn remove_hash_with_quote_works() {\n-        check_assist(\n+    fn cant_remove_required_hash() {\n+        mark::check!(cant_remove_required_hash);\n+        check_assist_not_applicable(\n             remove_hash,\n             r##\"\n             fn f() {\n                 let s = <|>r#\"random\"str\"ing\"#;\n             }\n             \"##,\n-            r#\"\n-            fn f() {\n-                let s = r\"random\\\"str\\\"ing\";\n-            }\n-            \"#,\n         )\n     }\n \n@@ -389,27 +417,13 @@ string\"###;\n     }\n \n     #[test]\n-    fn remove_hash_not_works() {\n-        check_assist_not_applicable(\n-            remove_hash,\n-            r#\"\n-            fn f() {\n-                let s = <|>\"random string\";\n-            }\n-            \"#,\n-        );\n+    fn remove_hash_doesnt_work() {\n+        check_assist_not_applicable(remove_hash, r#\"fn f() { let s = <|>\"random string\"; }\"#);\n     }\n \n     #[test]\n-    fn remove_hash_no_hash_not_works() {\n-        check_assist_not_applicable(\n-            remove_hash,\n-            r#\"\n-            fn f() {\n-                let s = <|>r\"random string\";\n-            }\n-            \"#,\n-        );\n+    fn remove_hash_no_hash_doesnt_work() {\n+        check_assist_not_applicable(remove_hash, r#\"fn f() { let s = <|>r\"random string\"; }\"#);\n     }\n \n     #[test]\n@@ -487,14 +501,4 @@ string\"###;\n             \"#,\n         );\n     }\n-\n-    #[test]\n-    fn count_hashes_test() {\n-        assert_eq!(0, count_hashes(\"abc\"));\n-        assert_eq!(0, count_hashes(\"###\"));\n-        assert_eq!(1, count_hashes(\"\\\"#abc\"));\n-        assert_eq!(0, count_hashes(\"#abc\"));\n-        assert_eq!(2, count_hashes(\"#ab\\\"##c\"));\n-        assert_eq!(4, count_hashes(\"#ab\\\"##\\\"####c\"));\n-    }\n }"}, {"sha": "9430ce1b5b85a3d6ef1b2027e811f7abc11cd2ce", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 87, "deletions": 11, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,9 +1,9 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n-    TextSize, T,\n+    TextRange, TextSize, T,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: remove_dbg\n //\n@@ -27,19 +27,33 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         return None;\n     }\n \n-    let macro_range = macro_call.syntax().text_range();\n+    let is_leaf = macro_call.syntax().next_sibling().is_none();\n \n-    let macro_content = {\n-        let macro_args = macro_call.token_tree()?.syntax().clone();\n+    let macro_end = if macro_call.semicolon_token().is_some() {\n+        macro_call.syntax().text_range().end() - TextSize::of(';')\n+    } else {\n+        macro_call.syntax().text_range().end()\n+    };\n \n-        let text = macro_args.text();\n-        let without_parens = TextSize::of('(')..text.len() - TextSize::of(')');\n-        text.slice(without_parens).to_string()\n+    // macro_range determines what will be deleted and replaced with macro_content\n+    let macro_range = TextRange::new(macro_call.syntax().text_range().start(), macro_end);\n+    let paste_instead_of_dbg = {\n+        let text = macro_call.token_tree()?.syntax().text();\n+\n+        // leafiness determines if we should include the parenthesis or not\n+        let slice_index: TextRange = if is_leaf {\n+            // leaf means - we can extract the contents of the dbg! in text\n+            TextRange::new(TextSize::of('('), text.len() - TextSize::of(')'))\n+        } else {\n+            // not leaf - means we should keep the parens\n+            TextRange::up_to(text.len())\n+        };\n+        text.slice(slice_index).to_string()\n     };\n \n     let target = macro_call.syntax().text_range();\n-    acc.add(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |builder| {\n-        builder.replace(macro_range, macro_content);\n+    acc.add(AssistId(\"remove_dbg\", AssistKind::Refactor), \"Remove dbg!()\", target, |builder| {\n+        builder.replace(macro_range, paste_instead_of_dbg);\n     })\n }\n \n@@ -99,6 +113,7 @@ fn foo(n: usize) {\n \",\n         );\n     }\n+\n     #[test]\n     fn test_remove_dbg_with_brackets_and_braces() {\n         check_assist(remove_dbg, \"dbg![<|>1 + 1]\", \"1 + 1\");\n@@ -113,7 +128,7 @@ fn foo(n: usize) {\n     }\n \n     #[test]\n-    fn remove_dbg_target() {\n+    fn test_remove_dbg_target() {\n         check_assist_target(\n             remove_dbg,\n             \"\n@@ -126,4 +141,65 @@ fn foo(n: usize) {\n             \"dbg!(n.checked_sub(4))\",\n         );\n     }\n+\n+    #[test]\n+    fn test_remove_dbg_keep_semicolon() {\n+        // https://github.com/rust-analyzer/rust-analyzer/issues/5129#issuecomment-651399779\n+        // not quite though\n+        // adding a comment at the end of the line makes\n+        // the ast::MacroCall to include the semicolon at the end\n+        check_assist(\n+            remove_dbg,\n+            r#\"let res = <|>dbg!(1 * 20); // needless comment\"#,\n+            r#\"let res = 1 * 20; // needless comment\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_remove_dbg_keep_expression() {\n+        check_assist(\n+            remove_dbg,\n+            r#\"let res = <|>dbg!(a + b).foo();\"#,\n+            r#\"let res = (a + b).foo();\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_remove_dbg_from_inside_fn() {\n+        check_assist_target(\n+            remove_dbg,\n+            r#\"\n+fn square(x: u32) -> u32 {\n+    x * x\n+}\n+\n+fn main() {\n+    let x = square(dbg<|>!(5 + 10));\n+    println!(\"{}\", x);\n+}\"#,\n+            \"dbg!(5 + 10)\",\n+        );\n+\n+        check_assist(\n+            remove_dbg,\n+            r#\"\n+fn square(x: u32) -> u32 {\n+    x * x\n+}\n+\n+fn main() {\n+    let x = square(dbg<|>!(5 + 10));\n+    println!(\"{}\", x);\n+}\"#,\n+            r#\"\n+fn square(x: u32) -> u32 {\n+    x * x\n+}\n+\n+fn main() {\n+    let x = square(5 + 10);\n+    println!(\"{}\", x);\n+}\"#,\n+        );\n+    }\n }"}, {"sha": "ef55c354ee5c9aaea805fc7c016a0028db12f23f", "filename": "crates/ra_assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{SyntaxKind, TextRange, T};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: remove_mut\n //\n@@ -26,7 +26,12 @@ pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     };\n \n     let target = mut_token.text_range();\n-    acc.add(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |builder| {\n-        builder.delete(TextRange::new(delete_from, delete_to));\n-    })\n+    acc.add(\n+        AssistId(\"remove_mut\", AssistKind::Refactor),\n+        \"Remove `mut` keyword\",\n+        target,\n+        |builder| {\n+            builder.delete(TextRange::new(delete_from, delete_to));\n+        },\n+    )\n }"}, {"sha": "120250e7900b2e6565c83f084007607810f01026", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,7 +5,7 @@ use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: reorder_fields\n //\n@@ -23,7 +23,7 @@ use crate::{AssistContext, AssistId, Assists};\n // ```\n //\n pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    reorder::<ast::RecordLit>(acc, ctx).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n+    reorder::<ast::RecordExpr>(acc, ctx).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n }\n \n fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -42,16 +42,21 @@ fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     }\n \n     let target = record.syntax().text_range();\n-    acc.add(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n-        for (old, new) in fields.iter().zip(&sorted_fields) {\n-            algo::diff(old, new).into_text_edit(edit.text_edit_builder());\n-        }\n-    })\n+    acc.add(\n+        AssistId(\"reorder_fields\", AssistKind::RefactorRewrite),\n+        \"Reorder record fields\",\n+        target,\n+        |edit| {\n+            for (old, new) in fields.iter().zip(&sorted_fields) {\n+                algo::diff(old, new).into_text_edit(edit.text_edit_builder());\n+            }\n+        },\n+    )\n }\n \n fn get_fields_kind(node: &SyntaxNode) -> Vec<SyntaxKind> {\n     match node.kind() {\n-        RECORD_LIT => vec![RECORD_FIELD],\n+        RECORD_EXPR => vec![RECORD_EXPR_FIELD],\n         RECORD_PAT => vec![RECORD_FIELD_PAT, BIND_PAT],\n         _ => vec![],\n     }\n@@ -60,7 +65,7 @@ fn get_fields_kind(node: &SyntaxNode) -> Vec<SyntaxKind> {\n fn get_field_name(node: &SyntaxNode) -> String {\n     let res = match_ast! {\n         match node {\n-            ast::RecordField(field) => field.field_name().map(|it| it.to_string()),\n+            ast::RecordExprField(field) => field.field_name().map(|it| it.to_string()),\n             ast::RecordFieldPat(field) => field.field_name().map(|it| it.to_string()),\n             _ => None,\n         }\n@@ -90,10 +95,10 @@ fn struct_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option\n fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {\n     Some(\n         struct_definition(path, &ctx.sema)?\n-            .fields(ctx.db)\n+            .fields(ctx.db())\n             .iter()\n             .enumerate()\n-            .map(|(idx, field)| (field.name(ctx.db).to_string(), idx))\n+            .map(|(idx, field)| (field.name(ctx.db()).to_string(), idx))\n             .collect(),\n     )\n }"}, {"sha": "b7e30a7f27e204df43e3821665463c246e5d1241", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n+use crate::{utils::TryEnum, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: replace_if_let_with_match\n //\n@@ -48,29 +48,35 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n     };\n \n     let target = if_expr.syntax().text_range();\n-    acc.add(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", target, move |edit| {\n-        let match_expr = {\n-            let then_arm = {\n-                let then_block = then_block.reset_indent().indent(IndentLevel(1));\n-                let then_expr = unwrap_trivial_block(then_block);\n-                make::match_arm(vec![pat.clone()], then_expr)\n+    acc.add(\n+        AssistId(\"replace_if_let_with_match\", AssistKind::RefactorRewrite),\n+        \"Replace with match\",\n+        target,\n+        move |edit| {\n+            let match_expr = {\n+                let then_arm = {\n+                    let then_block = then_block.reset_indent().indent(IndentLevel(1));\n+                    let then_expr = unwrap_trivial_block(then_block);\n+                    make::match_arm(vec![pat.clone()], then_expr)\n+                };\n+                let else_arm = {\n+                    let pattern = ctx\n+                        .sema\n+                        .type_of_pat(&pat)\n+                        .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                        .map(|it| it.sad_pattern())\n+                        .unwrap_or_else(|| make::placeholder_pat().into());\n+                    let else_expr = unwrap_trivial_block(else_block);\n+                    make::match_arm(vec![pattern], else_expr)\n+                };\n+                let match_expr =\n+                    make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]));\n+                match_expr.indent(IndentLevel::from_node(if_expr.syntax()))\n             };\n-            let else_arm = {\n-                let pattern = ctx\n-                    .sema\n-                    .type_of_pat(&pat)\n-                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n-                    .map(|it| it.sad_pattern())\n-                    .unwrap_or_else(|| make::placeholder_pat().into());\n-                let else_expr = unwrap_trivial_block(else_block);\n-                make::match_arm(vec![pattern], else_expr)\n-            };\n-            let match_expr = make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]));\n-            match_expr.indent(IndentLevel::from_node(if_expr.syntax()))\n-        };\n \n-        edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n-    })\n+            edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n+        },\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "a49292c970a5a44d6bca1b1dbeb2dee28f676a81", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n     AstNode, T,\n };\n \n-use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n+use crate::{utils::TryEnum, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: replace_let_with_if_let\n //\n@@ -44,24 +44,31 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n     let happy_variant = TryEnum::from_ty(&ctx.sema, &ty).map(|it| it.happy_case());\n \n     let target = let_kw.text_range();\n-    acc.add(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n-        let with_placeholder: ast::Pat = match happy_variant {\n-            None => make::placeholder_pat().into(),\n-            Some(var_name) => make::tuple_struct_pat(\n-                make::path_unqualified(make::path_segment(make::name_ref(var_name))),\n-                once(make::placeholder_pat().into()),\n-            )\n-            .into(),\n-        };\n-        let block = make::block_expr(None, None).indent(IndentLevel::from_node(let_stmt.syntax()));\n-        let if_ = make::expr_if(make::condition(init, Some(with_placeholder)), block);\n-        let stmt = make::expr_stmt(if_);\n+    acc.add(\n+        AssistId(\"replace_let_with_if_let\", AssistKind::RefactorRewrite),\n+        \"Replace with if-let\",\n+        target,\n+        |edit| {\n+            let with_placeholder: ast::Pat = match happy_variant {\n+                None => make::placeholder_pat().into(),\n+                Some(var_name) => make::tuple_struct_pat(\n+                    make::path_unqualified(make::path_segment(make::name_ref(var_name))),\n+                    once(make::placeholder_pat().into()),\n+                )\n+                .into(),\n+            };\n+            let block =\n+                make::block_expr(None, None).indent(IndentLevel::from_node(let_stmt.syntax()));\n+            let if_ = make::expr_if(make::condition(init, Some(with_placeholder)), block);\n+            let stmt = make::expr_stmt(if_);\n \n-        let placeholder = stmt.syntax().descendants().find_map(ast::PlaceholderPat::cast).unwrap();\n-        let stmt = stmt.replace_descendant(placeholder.into(), original_pat);\n+            let placeholder =\n+                stmt.syntax().descendants().find_map(ast::PlaceholderPat::cast).unwrap();\n+            let stmt = stmt.replace_descendant(placeholder.into(), original_pat);\n \n-        edit.replace_ast(ast::Stmt::from(let_stmt), ast::Stmt::from(stmt));\n-    })\n+            edit.replace_ast(ast::Stmt::from(let_stmt), ast::Stmt::from(stmt));\n+        },\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "53496ede1508bd00ac4a54051de2018a16b30865", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SmolStr, SyntaxNo\n \n use crate::{\n     utils::{find_insert_use_container, insert_use_statement},\n-    AssistContext, AssistId, Assists,\n+    AssistContext, AssistId, AssistKind, Assists,\n };\n \n // Assist: replace_qualified_name_with_use\n@@ -25,7 +25,7 @@ pub(crate) fn replace_qualified_name_with_use(\n ) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     // We don't want to mess with use statements\n-    if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n+    if path.syntax().ancestors().find_map(ast::Use::cast).is_some() {\n         return None;\n     }\n \n@@ -37,7 +37,7 @@ pub(crate) fn replace_qualified_name_with_use(\n \n     let target = path.syntax().text_range();\n     acc.add(\n-        AssistId(\"replace_qualified_name_with_use\"),\n+        AssistId(\"replace_qualified_name_with_use\", AssistKind::RefactorRewrite),\n         \"Replace qualified path with use\",\n         target,\n         |builder| {\n@@ -85,7 +85,7 @@ fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path:\n             match child {\n                 // Don't modify `use` items, as this can break the `use` item when injecting a new\n                 // import into the use tree.\n-                ast::UseItem(_it) => continue,\n+                ast::Use(_it) => continue,\n                 // Don't descend into submodules, they don't have the same `use` items in scope.\n                 ast::Module(_it) => continue,\n \n@@ -106,7 +106,7 @@ fn maybe_replace_path(\n     path: ast::Path,\n     target: ast::Path,\n ) -> Option<()> {\n-    if !path_eq(path.clone(), target.clone()) {\n+    if !path_eq(path.clone(), target) {\n         return None;\n     }\n "}, {"sha": "e5a4bb23c3d3a222078fa06f34f2dcc83ec0019b", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n \n use crate::{\n     utils::{render_snippet, Cursor, TryEnum},\n-    AssistContext, AssistId, Assists,\n+    AssistContext, AssistId, AssistKind, Assists,\n };\n \n // Assist: replace_unwrap_with_match\n@@ -46,37 +46,43 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n     let ty = ctx.sema.type_of_expr(&caller)?;\n     let happy_variant = TryEnum::from_ty(&ctx.sema, &ty)?.happy_case();\n     let target = method_call.syntax().text_range();\n-    acc.add(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", target, |builder| {\n-        let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n-        let it = make::bind_pat(make::name(\"a\")).into();\n-        let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n+    acc.add(\n+        AssistId(\"replace_unwrap_with_match\", AssistKind::RefactorRewrite),\n+        \"Replace unwrap with match\",\n+        target,\n+        |builder| {\n+            let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n+            let it = make::bind_pat(make::name(\"a\")).into();\n+            let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n-        let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n-        let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n+            let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n+            let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-        let unreachable_call = make::expr_unreachable();\n-        let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n+            let unreachable_call = make::expr_unreachable();\n+            let err_arm =\n+                make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n-        let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n-        let match_expr = make::expr_match(caller.clone(), match_arm_list)\n-            .indent(IndentLevel::from_node(method_call.syntax()));\n+            let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n+            let match_expr = make::expr_match(caller.clone(), match_arm_list)\n+                .indent(IndentLevel::from_node(method_call.syntax()));\n \n-        let range = method_call.syntax().text_range();\n-        match ctx.config.snippet_cap {\n-            Some(cap) => {\n-                let err_arm = match_expr\n-                    .syntax()\n-                    .descendants()\n-                    .filter_map(ast::MatchArm::cast)\n-                    .last()\n-                    .unwrap();\n-                let snippet =\n-                    render_snippet(cap, match_expr.syntax(), Cursor::Before(err_arm.syntax()));\n-                builder.replace_snippet(cap, range, snippet)\n+            let range = method_call.syntax().text_range();\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let err_arm = match_expr\n+                        .syntax()\n+                        .descendants()\n+                        .filter_map(ast::MatchArm::cast)\n+                        .last()\n+                        .unwrap();\n+                    let snippet =\n+                        render_snippet(cap, match_expr.syntax(), Cursor::Before(err_arm.syntax()));\n+                    builder.replace_snippet(cap, range, snippet)\n+                }\n+                None => builder.replace(range, match_expr.to_string()),\n             }\n-            None => builder.replace(range, match_expr.to_string()),\n-        }\n-    })\n+        },\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "4ca5c3ca14cd6b276a3dea9b640cf088706cd6f4", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,7 +2,7 @@ use std::iter::successors;\n \n use ra_syntax::{ast, AstNode, T};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: split_import\n //\n@@ -28,7 +28,7 @@ pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     }\n \n     let target = colon_colon.text_range();\n-    acc.add(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n+    acc.add(AssistId(\"split_import\", AssistKind::RefactorRewrite), \"Split import\", target, |edit| {\n         edit.replace_ast(use_tree, new_tree);\n     })\n }"}, {"sha": "8b38695a94852cdb48cc58121d88e6d5ba4fcaf0", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n     AstNode, TextRange, T,\n };\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: unwrap_block\n //\n@@ -27,7 +27,7 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n // ```\n pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let assist_id = AssistId(\"unwrap_block\");\n+    let assist_id = AssistId(\"unwrap_block\", AssistKind::RefactorRewrite);\n     let assist_label = \"Unwrap block\";\n \n     let l_curly_token = ctx.find_token_at_offset(T!['{'])?;"}, {"sha": "465b90415171093f0b83f78affe9b26cb28d1122", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -26,10 +26,40 @@ pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n pub use assist_config::AssistConfig;\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum AssistKind {\n+    None,\n+    QuickFix,\n+    Generate,\n+    Refactor,\n+    RefactorExtract,\n+    RefactorInline,\n+    RefactorRewrite,\n+}\n+\n+impl AssistKind {\n+    pub fn contains(self, other: AssistKind) -> bool {\n+        if self == other {\n+            return true;\n+        }\n+\n+        match self {\n+            AssistKind::None | AssistKind::Generate => return true,\n+            AssistKind::Refactor => match other {\n+                AssistKind::RefactorExtract\n+                | AssistKind::RefactorInline\n+                | AssistKind::RefactorRewrite => return true,\n+                _ => return false,\n+            },\n+            _ => return false,\n+        }\n+    }\n+}\n+\n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub struct AssistId(pub &'static str);\n+pub struct AssistId(pub &'static str, pub AssistKind);\n \n #[derive(Clone, Debug)]\n pub struct GroupLabel(pub String);\n@@ -102,13 +132,8 @@ mod handlers {\n     pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n     mod add_custom_impl;\n-    mod add_derive;\n     mod add_explicit_type;\n-    mod add_from_impl_for_enum;\n-    mod add_function;\n-    mod add_impl;\n     mod add_missing_impl_members;\n-    mod add_new;\n     mod add_turbo_fish;\n     mod apply_demorgan;\n     mod auto_import;\n@@ -122,6 +147,11 @@ mod handlers {\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n+    mod generate_derive;\n+    mod generate_from_impl_for_enum;\n+    mod generate_function;\n+    mod generate_impl;\n+    mod generate_new;\n     mod inline_local_variable;\n     mod introduce_named_lifetime;\n     mod invert_if;\n@@ -144,12 +174,7 @@ mod handlers {\n         &[\n             // These are alphabetic for the foolish consistency\n             add_custom_impl::add_custom_impl,\n-            add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n-            add_from_impl_for_enum::add_from_impl_for_enum,\n-            add_function::add_function,\n-            add_impl::add_impl,\n-            add_new::add_new,\n             add_turbo_fish::add_turbo_fish,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n@@ -163,6 +188,11 @@ mod handlers {\n             flip_binexpr::flip_binexpr,\n             flip_comma::flip_comma,\n             flip_trait_bound::flip_trait_bound,\n+            generate_derive::generate_derive,\n+            generate_from_impl_for_enum::generate_from_impl_for_enum,\n+            generate_function::generate_function,\n+            generate_impl::generate_impl,\n+            generate_new::generate_new,\n             inline_local_variable::inline_local_variable,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "18fcb90498742189306e7ce809c4cc400ec34154", "filename": "crates/ra_assists/src/tests.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,7 +6,7 @@ use ra_ide_db::RootDatabase;\n use ra_syntax::TextRange;\n use test_utils::{assert_eq_text, extract_offset, extract_range};\n \n-use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, Assists};\n+use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists};\n use stdx::trim_indent;\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n@@ -134,3 +134,46 @@ fn assist_order_if_expr() {\n     assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n     assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Replace with match\");\n }\n+\n+#[test]\n+fn assist_filter_works() {\n+    let before = \"\n+    pub fn test_some_range(a: int) -> bool {\n+        if let 2..6 = <|>5<|> {\n+            true\n+        } else {\n+            false\n+        }\n+    }\";\n+    let (range, before) = extract_range(before);\n+    let (db, file_id) = with_single_file(&before);\n+    let frange = FileRange { file_id, range };\n+\n+    {\n+        let mut cfg = AssistConfig::default();\n+        cfg.allowed = Some(vec![AssistKind::Refactor]);\n+\n+        let assists = Assist::resolved(&db, &cfg, frange);\n+        let mut assists = assists.iter();\n+\n+        assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n+        assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Replace with match\");\n+    }\n+\n+    {\n+        let mut cfg = AssistConfig::default();\n+        cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n+        let assists = Assist::resolved(&db, &cfg, frange);\n+        assert_eq!(assists.len(), 1);\n+\n+        let mut assists = assists.iter();\n+        assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n+    }\n+\n+    {\n+        let mut cfg = AssistConfig::default();\n+        cfg.allowed = Some(vec![AssistKind::QuickFix]);\n+        let assists = Assist::resolved(&db, &cfg, frange);\n+        assert!(assists.is_empty(), \"All asserts but quickfixes should be filtered out\");\n+    }\n+}"}, {"sha": "eff7feded6221504b8741f1b4c5fc0ece0c435e7", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 109, "deletions": 109, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -21,26 +21,6 @@ impl Debug for S {\n     )\n }\n \n-#[test]\n-fn doctest_add_derive() {\n-    check_doc_test(\n-        \"add_derive\",\n-        r#####\"\n-struct Point {\n-    x: u32,\n-    y: u32,<|>\n-}\n-\"#####,\n-        r#####\"\n-#[derive($0)]\n-struct Point {\n-    x: u32,\n-    y: u32,\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_explicit_type() {\n     check_doc_test(\n@@ -58,52 +38,6 @@ fn main() {\n     )\n }\n \n-#[test]\n-fn doctest_add_from_impl_for_enum() {\n-    check_doc_test(\n-        \"add_from_impl_for_enum\",\n-        r#####\"\n-enum A { <|>One(u32) }\n-\"#####,\n-        r#####\"\n-enum A { One(u32) }\n-\n-impl From<u32> for A {\n-    fn from(v: u32) -> Self {\n-        A::One(v)\n-    }\n-}\n-\"#####,\n-    )\n-}\n-\n-#[test]\n-fn doctest_add_function() {\n-    check_doc_test(\n-        \"add_function\",\n-        r#####\"\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar<|>(\"\", baz());\n-}\n-\n-\"#####,\n-        r#####\"\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar(\"\", baz());\n-}\n-\n-fn bar(arg: &str, baz: Baz) {\n-    ${0:todo!()}\n-}\n-\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_hash() {\n     check_doc_test(\n@@ -121,27 +55,6 @@ fn main() {\n     )\n }\n \n-#[test]\n-fn doctest_add_impl() {\n-    check_doc_test(\n-        \"add_impl\",\n-        r#####\"\n-struct Ctx<T: Clone> {\n-    data: T,<|>\n-}\n-\"#####,\n-        r#####\"\n-struct Ctx<T: Clone> {\n-    data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    $0\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_impl_default_members() {\n     check_doc_test(\n@@ -208,28 +121,6 @@ impl Trait<u32> for () {\n     )\n }\n \n-#[test]\n-fn doctest_add_new() {\n-    check_doc_test(\n-        \"add_new\",\n-        r#####\"\n-struct Ctx<T: Clone> {\n-     data: T,<|>\n-}\n-\"#####,\n-        r#####\"\n-struct Ctx<T: Clone> {\n-     data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    fn $0new(data: T) -> Self { Self { data } }\n-}\n-\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_turbo_fish() {\n     check_doc_test(\n@@ -466,6 +357,115 @@ fn foo<T: Copy + Clone>() { }\n     )\n }\n \n+#[test]\n+fn doctest_generate_derive() {\n+    check_doc_test(\n+        \"generate_derive\",\n+        r#####\"\n+struct Point {\n+    x: u32,\n+    y: u32,<|>\n+}\n+\"#####,\n+        r#####\"\n+#[derive($0)]\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_from_impl_for_enum() {\n+    check_doc_test(\n+        \"generate_from_impl_for_enum\",\n+        r#####\"\n+enum A { <|>One(u32) }\n+\"#####,\n+        r#####\"\n+enum A { One(u32) }\n+\n+impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_function() {\n+    check_doc_test(\n+        \"generate_function\",\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar<|>(\"\", baz());\n+}\n+\n+\"#####,\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar(\"\", baz());\n+}\n+\n+fn bar(arg: &str, baz: Baz) {\n+    ${0:todo!()}\n+}\n+\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_impl() {\n+    check_doc_test(\n+        \"generate_impl\",\n+        r#####\"\n+struct Ctx<T: Clone> {\n+    data: T,<|>\n+}\n+\"#####,\n+        r#####\"\n+struct Ctx<T: Clone> {\n+    data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+    $0\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_new() {\n+    check_doc_test(\n+        \"generate_new\",\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,<|>\n+}\n+\"#####,\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+    fn $0new(data: T) -> Self { Self { data } }\n+}\n+\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_inline_local_variable() {\n     check_doc_test("}, {"sha": "bb16ebd4e8fbe14c3baea454aad97935801bcdbc", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -56,33 +56,34 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n \n pub fn get_missing_assoc_items(\n     sema: &Semantics<RootDatabase>,\n-    impl_def: &ast::ImplDef,\n+    impl_def: &ast::Impl,\n ) -> Vec<hir::AssocItem> {\n     // Names must be unique between constants and functions. However, type aliases\n     // may share the same name as a function or constant.\n     let mut impl_fns_consts = FxHashSet::default();\n     let mut impl_type = FxHashSet::default();\n \n-    if let Some(item_list) = impl_def.item_list() {\n+    if let Some(item_list) = impl_def.assoc_item_list() {\n         for item in item_list.assoc_items() {\n             match item {\n-                ast::AssocItem::FnDef(f) => {\n+                ast::AssocItem::Fn(f) => {\n                     if let Some(n) = f.name() {\n                         impl_fns_consts.insert(n.syntax().to_string());\n                     }\n                 }\n \n-                ast::AssocItem::TypeAliasDef(t) => {\n+                ast::AssocItem::TypeAlias(t) => {\n                     if let Some(n) = t.name() {\n                         impl_type.insert(n.syntax().to_string());\n                     }\n                 }\n \n-                ast::AssocItem::ConstDef(c) => {\n+                ast::AssocItem::Const(c) => {\n                     if let Some(n) = c.name() {\n                         impl_fns_consts.insert(n.syntax().to_string());\n                     }\n                 }\n+                ast::AssocItem::MacroCall(_) => (),\n             }\n         }\n     }\n@@ -108,7 +109,7 @@ pub fn get_missing_assoc_items(\n \n pub(crate) fn resolve_target_trait(\n     sema: &Semantics<RootDatabase>,\n-    impl_def: &ast::ImplDef,\n+    impl_def: &ast::Impl,\n ) -> Option<hir::Trait> {\n     let ast_path = impl_def\n         .target_trait()"}, {"sha": "617afe2e945f6b40cdb96e72e737cf810de8e273", "filename": "crates/ra_assists/src/utils/insert_use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -215,7 +215,7 @@ fn walk_use_tree_for_best_action(\n     let prev_len = current_path_segments.len();\n \n     let tree_list = current_use_tree.use_tree_list();\n-    let alias = current_use_tree.alias();\n+    let alias = current_use_tree.rename();\n \n     let path = match current_use_tree.path() {\n         Some(path) => path,\n@@ -225,7 +225,7 @@ fn walk_use_tree_for_best_action(\n                 current_use_tree\n                     .syntax()\n                     .ancestors()\n-                    .find_map(ast::UseItem::cast)\n+                    .find_map(ast::Use::cast)\n                     .map(|it| it.syntax().clone()),\n                 true,\n             );\n@@ -254,7 +254,7 @@ fn walk_use_tree_for_best_action(\n             current_use_tree\n                 .syntax()\n                 .ancestors()\n-                .find_map(ast::UseItem::cast)\n+                .find_map(ast::Use::cast)\n                 .map(|it| it.syntax().clone()),\n             true,\n         ),\n@@ -304,7 +304,7 @@ fn walk_use_tree_for_best_action(\n                 current_use_tree\n                     .syntax()\n                     .ancestors()\n-                    .find_map(ast::UseItem::cast)\n+                    .find_map(ast::Use::cast)\n                     .map(|it| it.syntax().clone()),\n                 true,\n             );\n@@ -377,7 +377,7 @@ fn best_action_for_target(\n     let mut storage = Vec::with_capacity(16); // this should be the only allocation\n     let best_action = container\n         .children()\n-        .filter_map(ast::UseItem::cast)\n+        .filter_map(ast::Use::cast)\n         .filter_map(|it| it.use_tree())\n         .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n         .fold(None, |best, a| match best {"}, {"sha": "6425cd6d6fa543792dc6b81531f55dd26d8f6660", "filename": "crates/ra_cfg/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_cfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_cfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ edition = \"2018\"\n name = \"ra_cfg\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false"}, {"sha": "f48928aee874e5946de7b29b6eca45e312a6670c", "filename": "crates/ra_cfg/src/cfg_expr.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,7 +5,6 @@\n use std::slice::Iter as SliceIter;\n \n use ra_syntax::SmolStr;\n-use tt::{Leaf, Subtree, TokenTree};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum CfgExpr {\n@@ -18,6 +17,9 @@ pub enum CfgExpr {\n }\n \n impl CfgExpr {\n+    pub fn parse(tt: &tt::Subtree) -> CfgExpr {\n+        next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n+    }\n     /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n     pub fn fold(&self, query: &dyn Fn(&SmolStr, Option<&SmolStr>) -> bool) -> Option<bool> {\n         match self {\n@@ -35,22 +37,18 @@ impl CfgExpr {\n     }\n }\n \n-pub fn parse_cfg(tt: &Subtree) -> CfgExpr {\n-    next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n-}\n-\n fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n     let name = match it.next() {\n         None => return None,\n-        Some(TokenTree::Leaf(Leaf::Ident(ident))) => ident.text.clone(),\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),\n         Some(_) => return Some(CfgExpr::Invalid),\n     };\n \n     // Peek\n     let ret = match it.as_slice().first() {\n-        Some(TokenTree::Leaf(Leaf::Punct(punct))) if punct.char == '=' => {\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '=' => {\n             match it.as_slice().get(1) {\n-                Some(TokenTree::Leaf(Leaf::Literal(literal))) => {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(literal))) => {\n                     it.next();\n                     it.next();\n                     // FIXME: escape? raw string?\n@@ -61,7 +59,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n                 _ => return Some(CfgExpr::Invalid),\n             }\n         }\n-        Some(TokenTree::Subtree(subtree)) => {\n+        Some(tt::TokenTree::Subtree(subtree)) => {\n             it.next();\n             let mut sub_it = subtree.token_trees.iter();\n             let mut subs = std::iter::from_fn(|| next_cfg_expr(&mut sub_it)).collect();\n@@ -76,7 +74,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n     };\n \n     // Eat comma separator\n-    if let Some(TokenTree::Leaf(Leaf::Punct(punct))) = it.as_slice().first() {\n+    if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = it.as_slice().first() {\n         if punct.char == ',' {\n             it.next();\n         }\n@@ -99,7 +97,8 @@ mod tests {\n \n     fn assert_parse_result(input: &str, expected: CfgExpr) {\n         let (tt, _) = get_token_tree_generated(input);\n-        assert_eq!(parse_cfg(&tt), expected);\n+        let cfg = CfgExpr::parse(&tt);\n+        assert_eq!(cfg, expected);\n     }\n \n     #[test]"}, {"sha": "cd5a0a7b64032653406adcfba3e77fa939d4c610", "filename": "crates/ra_cfg/src/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,7 +5,7 @@ mod cfg_expr;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n-pub use cfg_expr::{parse_cfg, CfgExpr};\n+pub use cfg_expr::CfgExpr;\n \n /// Configuration options used for conditional compilition on items with `cfg` attributes.\n /// We have two kind of options in different namespaces: atomic options like `unix`, and\n@@ -31,19 +31,21 @@ impl CfgOptions {\n         })\n     }\n \n-    pub fn is_cfg_enabled(&self, attr: &tt::Subtree) -> Option<bool> {\n-        self.check(&parse_cfg(attr))\n-    }\n-\n     pub fn insert_atom(&mut self, key: SmolStr) {\n         self.atoms.insert(key);\n     }\n \n-    pub fn remove_atom(&mut self, name: &str) {\n-        self.atoms.remove(name);\n-    }\n-\n     pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n         self.key_values.insert((key, value));\n     }\n+\n+    pub fn append(&mut self, other: &CfgOptions) {\n+        for atom in &other.atoms {\n+            self.atoms.insert(atom.clone());\n+        }\n+\n+        for (key, value) in &other.key_values {\n+            self.key_values.insert((key.clone(), value.clone()));\n+        }\n+    }\n }"}, {"sha": "5f334d04f147a361b35c438e92b7ec1ee0588b68", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,13 +3,13 @@ edition = \"2018\"\n name = \"ra_db\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false\n \n [dependencies]\n-salsa = \"0.14.1\"\n-relative-path = \"1.0.0\"\n+salsa = \"0.15.0\"\n rustc-hash = \"1.1.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }"}, {"sha": "2aafb99654917096833e0d5e85044c651bc036c3", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -149,15 +149,17 @@ fn with_files(\n             let crate_id = crate_graph.add_crate_root(\n                 file_id,\n                 meta.edition,\n-                Some(CrateName::new(&krate).unwrap()),\n+                Some(krate.clone()),\n                 meta.cfg,\n                 meta.env,\n                 Default::default(),\n             );\n-            let prev = crates.insert(krate.clone(), crate_id);\n+            let crate_name = CrateName::new(&krate).unwrap();\n+            let prev = crates.insert(crate_name.clone(), crate_id);\n             assert!(prev.is_none());\n             for dep in meta.deps {\n-                crate_deps.push((krate.clone(), dep))\n+                let dep = CrateName::new(&dep).unwrap();\n+                crate_deps.push((crate_name.clone(), dep))\n             }\n         } else if meta.path == \"/main.rs\" || meta.path == \"/lib.rs\" {\n             assert!(default_crate_root.is_none());\n@@ -220,7 +222,7 @@ impl From<Fixture> for FileMeta {\n                 .edition\n                 .as_ref()\n                 .map_or(Edition::Edition2018, |v| Edition::from_str(&v).unwrap()),\n-            env: Env::from(f.env.iter()),\n+            env: f.env.into_iter().collect(),\n         }\n     }\n }"}, {"sha": "6f2e5cfc76e72dde42ebfea049fb6c1387ffbc0c", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,7 +6,7 @@\n //! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n //! actual IO is done and lowered to input.\n \n-use std::{fmt, ops, str::FromStr, sync::Arc};\n+use std::{fmt, iter::FromIterator, ops, str::FromStr, sync::Arc};\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n@@ -67,7 +67,7 @@ pub struct CrateGraph {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct CrateId(pub u32);\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CrateName(SmolStr);\n \n impl CrateName {\n@@ -94,6 +94,13 @@ impl fmt::Display for CrateName {\n     }\n }\n \n+impl ops::Deref for CrateName {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        &*self.0\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct ProcMacroId(pub u32);\n \n@@ -117,7 +124,7 @@ pub struct CrateData {\n     /// The name to display to the end user.\n     /// This actual crate name can be different in a particular dependent crate\n     /// or may even be missing for some cases, such as a dummy crate for the code snippet.\n-    pub display_name: Option<CrateName>,\n+    pub display_name: Option<String>,\n     pub cfg_options: CfgOptions,\n     pub env: Env,\n     pub dependencies: Vec<Dependency>,\n@@ -138,15 +145,15 @@ pub struct Env {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Dependency {\n     pub crate_id: CrateId,\n-    pub name: SmolStr,\n+    pub name: CrateName,\n }\n \n impl CrateGraph {\n     pub fn add_crate_root(\n         &mut self,\n         file_id: FileId,\n         edition: Edition,\n-        display_name: Option<CrateName>,\n+        display_name: Option<String>,\n         cfg_options: CfgOptions,\n         env: Env,\n         proc_macro: Vec<(SmolStr, Arc<dyn ra_tt::TokenExpander>)>,\n@@ -178,7 +185,7 @@ impl CrateGraph {\n         if self.dfs_find(from, to, &mut FxHashSet::default()) {\n             return Err(CyclicDependenciesError);\n         }\n-        self.arena.get_mut(&from).unwrap().add_dep(name.0, to);\n+        self.arena.get_mut(&from).unwrap().add_dep(name, to);\n         Ok(())\n     }\n \n@@ -190,6 +197,23 @@ impl CrateGraph {\n         self.arena.keys().copied()\n     }\n \n+    /// Returns an iterator over all transitive dependencies of the given crate.\n+    pub fn transitive_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> + '_ {\n+        let mut worklist = vec![of];\n+        let mut deps = FxHashSet::default();\n+\n+        while let Some(krate) = worklist.pop() {\n+            if !deps.insert(krate) {\n+                continue;\n+            }\n+\n+            worklist.extend(self[krate].dependencies.iter().map(|dep| dep.crate_id));\n+        }\n+\n+        deps.remove(&of);\n+        deps.into_iter()\n+    }\n+\n     // FIXME: this only finds one crate with the given root; we could have multiple\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n         let (&crate_id, _) =\n@@ -247,7 +271,7 @@ impl CrateId {\n }\n \n impl CrateData {\n-    fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n+    fn add_dep(&mut self, name: CrateName, crate_id: CrateId) {\n         self.dependencies.push(Dependency { name, crate_id })\n     }\n }\n@@ -274,18 +298,9 @@ impl fmt::Display for Edition {\n     }\n }\n \n-impl<'a, T> From<T> for Env\n-where\n-    T: Iterator<Item = (&'a String, &'a String)>,\n-{\n-    fn from(iter: T) -> Self {\n-        let mut result = Self::default();\n-\n-        for (k, v) in iter {\n-            result.entries.insert(k.to_owned(), v.to_owned());\n-        }\n-\n-        result\n+impl FromIterator<(String, String)> for Env {\n+    fn from_iter<T: IntoIterator<Item = (String, String)>>(iter: T) -> Self {\n+        Env { entries: FromIterator::from_iter(iter) }\n     }\n }\n \n@@ -429,7 +444,10 @@ mod tests {\n             .is_ok());\n         assert_eq!(\n             graph[crate1].dependencies,\n-            vec![Dependency { crate_id: crate2, name: \"crate_name_with_dashes\".into() }]\n+            vec![Dependency {\n+                crate_id: crate2,\n+                name: CrateName::new(\"crate_name_with_dashes\").unwrap()\n+            }]\n         );\n     }\n }"}, {"sha": "f25be24fe2371e0f4448a91e37b9cc06691ecc51", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -16,9 +16,8 @@ pub use crate::{\n         SourceRoot, SourceRootId,\n     },\n };\n-pub use relative_path::{RelativePath, RelativePathBuf};\n pub use salsa;\n-pub use vfs::{file_set::FileSet, AbsPathBuf, VfsPath};\n+pub use vfs::{file_set::FileSet, VfsPath};\n \n #[macro_export]\n macro_rules! impl_intern_key {\n@@ -80,7 +79,7 @@ pub struct FilePosition {\n     pub offset: TextSize,\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n pub struct FileRange {\n     pub file_id: FileId,\n     pub range: TextRange,\n@@ -93,9 +92,9 @@ pub trait FileLoader {\n     fn file_text(&self, file_id: FileId) -> Arc<String>;\n     /// Note that we intentionally accept a `&str` and not a `&Path` here. This\n     /// method exists to handle `#[path = \"/some/path.rs\"] mod foo;` and such,\n-    /// so the input is guaranteed to be utf-8 string. We might introduce\n-    /// `struct StrPath(str)` for clarity some day, but it's a bit messy, so we\n-    /// get by with a `&str` for the time being.\n+    /// so the input is guaranteed to be utf-8 string. One might be tempted to\n+    /// introduce some kind of \"utf-8 path with / separators\", but that's a bad idea. Behold\n+    /// `#[path = \"C://no/way\"]`\n     fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId>;\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n }\n@@ -113,7 +112,7 @@ pub trait SourceDatabase: CheckCanceled + FileLoader + std::fmt::Debug {\n     fn crate_graph(&self) -> Arc<CrateGraph>;\n }\n \n-fn parse_query(db: &impl SourceDatabase, file_id: FileId) -> Parse<ast::SourceFile> {\n+fn parse_query(db: &dyn SourceDatabase, file_id: FileId) -> Parse<ast::SourceFile> {\n     let _p = profile(\"parse_query\").detail(|| format!(\"{:?}\", file_id));\n     let text = db.file_text(file_id);\n     SourceFile::parse(&*text)\n@@ -136,10 +135,7 @@ pub trait SourceDatabaseExt: SourceDatabase {\n     fn source_root_crates(&self, id: SourceRootId) -> Arc<FxHashSet<CrateId>>;\n }\n \n-fn source_root_crates(\n-    db: &(impl SourceDatabaseExt + SourceDatabase),\n-    id: SourceRootId,\n-) -> Arc<FxHashSet<CrateId>> {\n+fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<FxHashSet<CrateId>> {\n     let graph = db.crate_graph();\n     let res = graph\n         .iter()"}, {"sha": "b4ef93f2b27934076833653585a719239466ffc6", "filename": "crates/ra_fmt/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_fmt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_fmt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -4,6 +4,7 @@ name = \"ra_fmt\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n publish = false\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false"}, {"sha": "c260bb193cd8f0ddd53514d19317e27179453367", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ edition = \"2018\"\n name = \"ra_hir\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false\n@@ -15,6 +16,7 @@ arrayvec = \"0.5.1\"\n \n itertools = \"0.9.0\"\n \n+stdx = { path = \"../stdx\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n ra_prof = { path = \"../ra_prof\" }"}, {"sha": "5d88c5c64fec59fc71dcb898bdf85d413e682955", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 134, "deletions": 45, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,5 +1,5 @@\n //! FIXME: write short doc here\n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use either::Either;\n@@ -12,6 +12,7 @@ use hir_def::{\n     import_map,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n+    src::HasSource as _,\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocContainerId, ConstId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule,\n     ImplId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StaticId, StructId,\n@@ -25,21 +26,22 @@ use hir_expand::{\n use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n-    expr::ExprValidator,\n-    method_resolution,\n-    unsafe_validation::UnsafeValidator,\n-    ApplicationTy, Canonical, GenericPredicate, InEnvironment, Substs, TraitEnvironment, Ty,\n-    TyDefId, TypeCtor,\n+    method_resolution, ApplicationTy, CallableDefId, Canonical, FnSig, GenericPredicate,\n+    InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n-use ra_db::{CrateId, CrateName, Edition, FileId};\n+use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n-use ra_syntax::ast::{self, AttrsOwner, NameOwner};\n+use ra_syntax::{\n+    ast::{self, AttrsOwner, NameOwner},\n+    AstNode,\n+};\n use rustc_hash::FxHashSet;\n+use stdx::impl_from;\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n     has_source::HasSource,\n-    CallableDef, HirDisplay, InFile, Name,\n+    HirDisplay, InFile, Name,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -94,8 +96,8 @@ impl Crate {\n         db.crate_graph()[self.id].edition\n     }\n \n-    pub fn display_name(self, db: &dyn HirDatabase) -> Option<CrateName> {\n-        db.crate_graph()[self.id].display_name.as_ref().cloned()\n+    pub fn display_name(self, db: &dyn HirDatabase) -> Option<String> {\n+        db.crate_graph()[self.id].display_name.clone()\n     }\n \n     pub fn query_external_importables(\n@@ -139,8 +141,8 @@ pub enum ModuleDef {\n     TypeAlias(TypeAlias),\n     BuiltinType(BuiltinType),\n }\n-impl_froms!(\n-    ModuleDef: Module,\n+impl_from!(\n+    Module,\n     Function,\n     Adt(Struct, Enum, Union),\n     EnumVariant,\n@@ -149,6 +151,7 @@ impl_froms!(\n     Trait,\n     TypeAlias,\n     BuiltinType\n+    for ModuleDef\n );\n \n impl ModuleDef {\n@@ -376,8 +379,8 @@ pub struct Field {\n \n #[derive(Debug, PartialEq, Eq)]\n pub enum FieldSource {\n-    Named(ast::RecordFieldDef),\n-    Pos(ast::TupleFieldDef),\n+    Named(ast::RecordField),\n+    Pos(ast::TupleField),\n }\n \n impl Field {\n@@ -556,7 +559,7 @@ pub enum Adt {\n     Union(Union),\n     Enum(Enum),\n }\n-impl_froms!(Adt: Struct, Union, Enum);\n+impl_from!(Struct, Union, Enum for Adt);\n \n impl Adt {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n@@ -599,7 +602,7 @@ pub enum VariantDef {\n     Union(Union),\n     EnumVariant(EnumVariant),\n }\n-impl_froms!(VariantDef: Struct, Union, EnumVariant);\n+impl_from!(Struct, Union, EnumVariant for VariantDef);\n \n impl VariantDef {\n     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n@@ -642,8 +645,7 @@ pub enum DefWithBody {\n     Static(Static),\n     Const(Const),\n }\n-\n-impl_froms!(DefWithBody: Function, Const, Static);\n+impl_from!(Function, Const, Static for DefWithBody);\n \n impl DefWithBody {\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n@@ -694,13 +696,7 @@ impl Function {\n     }\n \n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n-        let _p = profile(\"Function::diagnostics\");\n-        let infer = db.infer(self.id.into());\n-        infer.add_diagnostics(db, self.id, sink);\n-        let mut validator = ExprValidator::new(self.id, infer.clone(), sink);\n-        validator.validate_body(db);\n-        let mut validator = UnsafeValidator::new(self.id, infer, sink);\n-        validator.validate_body(db);\n+        hir_ty::diagnostics::validate_body(db, self.id.into(), sink)\n     }\n }\n \n@@ -945,14 +941,15 @@ pub enum GenericDef {\n     // consts can have type parameters from their parents (i.e. associated consts of traits)\n     Const(Const),\n }\n-impl_froms!(\n-    GenericDef: Function,\n+impl_from!(\n+    Function,\n     Adt(Struct, Enum, Union),\n     Trait,\n     TypeAlias,\n     ImplDef,\n     EnumVariant,\n     Const\n+    for GenericDef\n );\n \n impl GenericDef {\n@@ -973,6 +970,16 @@ pub struct Local {\n }\n \n impl Local {\n+    pub fn is_param(self, db: &dyn HirDatabase) -> bool {\n+        let src = self.source(db);\n+        match src.value {\n+            Either::Left(bind_pat) => {\n+                bind_pat.syntax().ancestors().any(|it| ast::Param::can_cast(it.kind()))\n+            }\n+            Either::Right(_self_param) => true,\n+        }\n+    }\n+\n     // FIXME: why is this an option? It shouldn't be?\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         let body = db.body(self.parent.into());\n@@ -1071,12 +1078,14 @@ pub struct ImplDef {\n \n impl ImplDef {\n     pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<ImplDef> {\n-        let impls = db.impls_in_crate(krate.id);\n-        impls.all_impls().map(Self::from).collect()\n+        let inherent = db.inherent_impls_in_crate(krate.id);\n+        let trait_ = db.trait_impls_in_crate(krate.id);\n+\n+        inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n     }\n     pub fn for_trait(db: &dyn HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplDef> {\n-        let impls = db.impls_in_crate(krate.id);\n-        impls.lookup_impl_defs_for_trait(trait_.id).map(Self::from).collect()\n+        let impls = db.trait_impls_in_crate(krate.id);\n+        impls.for_trait(trait_.id).map(Self::from).collect()\n     }\n \n     pub fn target_trait(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n@@ -1178,6 +1187,12 @@ impl Type {\n         Type::new(db, krate, def, ty)\n     }\n \n+    pub fn is_unit(&self) -> bool {\n+        matches!(\n+            self.ty.value,\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { cardinality: 0 }, .. })\n+        )\n+    }\n     pub fn is_bool(&self) -> bool {\n         matches!(self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. }))\n     }\n@@ -1205,7 +1220,7 @@ impl Type {\n             None => return false,\n         };\n \n-        let canonical_ty = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n         method_resolution::implements_trait(\n             &canonical_ty,\n             db,\n@@ -1229,15 +1244,20 @@ impl Type {\n                 self.ty.environment.clone(),\n                 hir_ty::Obligation::Trait(trait_ref),\n             ),\n-            num_vars: 0,\n+            kinds: Arc::new([]),\n         };\n \n         db.trait_solve(self.krate, goal).is_some()\n     }\n \n-    // FIXME: this method is broken, as it doesn't take closures into account.\n-    pub fn as_callable(&self) -> Option<CallableDef> {\n-        Some(self.ty.value.as_callable()?.0)\n+    pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n+        let def = match self.ty.value {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(def), parameters: _ }) => Some(def),\n+            _ => None,\n+        };\n+\n+        let sig = self.ty.value.callable_sig(db)?;\n+        Some(Callable { ty: self.clone(), sig, def, is_bound_method: false })\n     }\n \n     pub fn is_closure(&self) -> bool {\n@@ -1304,7 +1324,7 @@ impl Type {\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n-        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n         let environment = self.ty.environment.clone();\n         let ty = InEnvironment { value: canonical, environment };\n         autoderef(db, Some(self.krate), ty)\n@@ -1321,10 +1341,10 @@ impl Type {\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         for krate in self.ty.value.def_crates(db, krate.id)? {\n-            let impls = db.impls_in_crate(krate);\n+            let impls = db.inherent_impls_in_crate(krate);\n \n-            for impl_def in impls.lookup_impl_defs(&self.ty.value) {\n-                for &item in db.impl_data(impl_def).items.iter() {\n+            for impl_def in impls.for_self_ty(&self.ty.value) {\n+                for &item in db.impl_data(*impl_def).items.iter() {\n                     if let Some(result) = callback(item.into()) {\n                         return Some(result);\n                     }\n@@ -1345,7 +1365,7 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n \n         let env = self.ty.environment.clone();\n         let krate = krate.id;\n@@ -1376,7 +1396,7 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n \n         let env = self.ty.environment.clone();\n         let krate = krate.id;\n@@ -1522,6 +1542,74 @@ impl HirDisplay for Type {\n     }\n }\n \n+// FIXME: closures\n+#[derive(Debug)]\n+pub struct Callable {\n+    ty: Type,\n+    sig: FnSig,\n+    def: Option<CallableDefId>,\n+    pub(crate) is_bound_method: bool,\n+}\n+\n+pub enum CallableKind {\n+    Function(Function),\n+    TupleStruct(Struct),\n+    TupleEnumVariant(EnumVariant),\n+    Closure,\n+}\n+\n+impl Callable {\n+    pub fn kind(&self) -> CallableKind {\n+        match self.def {\n+            Some(CallableDefId::FunctionId(it)) => CallableKind::Function(it.into()),\n+            Some(CallableDefId::StructId(it)) => CallableKind::TupleStruct(it.into()),\n+            Some(CallableDefId::EnumVariantId(it)) => CallableKind::TupleEnumVariant(it.into()),\n+            None => CallableKind::Closure,\n+        }\n+    }\n+    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {\n+        let func = match self.def {\n+            Some(CallableDefId::FunctionId(it)) if self.is_bound_method => it,\n+            _ => return None,\n+        };\n+        let src = func.lookup(db.upcast()).source(db.upcast());\n+        let param_list = src.value.param_list()?;\n+        param_list.self_param()\n+    }\n+    pub fn n_params(&self) -> usize {\n+        self.sig.params().len() - if self.is_bound_method { 1 } else { 0 }\n+    }\n+    pub fn params(\n+        &self,\n+        db: &dyn HirDatabase,\n+    ) -> Vec<(Option<Either<ast::SelfParam, ast::Pat>>, Type)> {\n+        let types = self\n+            .sig\n+            .params()\n+            .iter()\n+            .skip(if self.is_bound_method { 1 } else { 0 })\n+            .map(|ty| self.ty.derived(ty.clone()));\n+        let patterns = match self.def {\n+            Some(CallableDefId::FunctionId(func)) => {\n+                let src = func.lookup(db.upcast()).source(db.upcast());\n+                src.value.param_list().map(|param_list| {\n+                    param_list\n+                        .self_param()\n+                        .map(|it| Some(Either::Left(it)))\n+                        .filter(|_| !self.is_bound_method)\n+                        .into_iter()\n+                        .chain(param_list.params().map(|it| it.pat().map(Either::Right)))\n+                })\n+            }\n+            _ => None,\n+        };\n+        patterns.into_iter().flatten().chain(iter::repeat(None)).zip(types).collect()\n+    }\n+    pub fn return_type(&self) -> Type {\n+        self.ty.derived(self.sig.ret().clone())\n+    }\n+}\n+\n /// For IDE only\n #[derive(Debug)]\n pub enum ScopeDef {\n@@ -1581,8 +1669,8 @@ pub enum AttrDef {\n     MacroDef(MacroDef),\n }\n \n-impl_froms!(\n-    AttrDef: Module,\n+impl_from!(\n+    Module,\n     Field,\n     Adt(Struct, Enum, Union),\n     EnumVariant,\n@@ -1592,6 +1680,7 @@ impl_froms!(\n     Trait,\n     TypeAlias,\n     MacroDef\n+    for AttrDef\n );\n \n pub trait HasAttrs {"}, {"sha": "a2b9f3e35c035db49bf0210f8cd8ea253478ea2a", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -11,15 +11,15 @@ pub use hir_def::db::{\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternEagerExpansionQuery, InternMacroQuery,\n-    MacroArgQuery, MacroDefQuery, MacroExpandQuery, ParseMacroQuery,\n+    MacroArgTextQuery, MacroDefQuery, MacroExpandQuery, ParseMacroQuery,\n };\n pub use hir_ty::db::{\n     AssociatedTyDataQuery, AssociatedTyValueQuery, CallableItemSignatureQuery, FieldTypesQuery,\n     GenericDefaultsQuery, GenericPredicatesForParamQuery, GenericPredicatesQuery, HirDatabase,\n-    HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery, ImplsFromDepsQuery,\n-    ImplsInCrateQuery, InferQueryQuery, InternAssocTyValueQuery, InternChalkImplQuery,\n-    InternTypeCtorQuery, InternTypeParamIdQuery, ReturnTypeImplTraitsQuery, StructDatumQuery,\n-    TraitDatumQuery, TraitSolveQuery, TyQuery, ValueTyQuery,\n+    HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery, InferQueryQuery,\n+    InherentImplsInCrateQuery, InternTypeParamIdQuery, ReturnTypeImplTraitsQuery, StructDatumQuery,\n+    TraitDatumQuery, TraitImplsInCrateQuery, TraitImplsInDepsQuery, TraitSolveQuery, TyQuery,\n+    ValueTyQuery,\n };\n \n #[test]"}, {"sha": "266b513dcf50c307943ce688af4c8d700a92b25c", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,4 +1,8 @@\n //! FIXME: write short doc here\n pub use hir_def::diagnostics::UnresolvedModule;\n-pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-pub use hir_ty::diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField};\n+pub use hir_expand::diagnostics::{\n+    AstDiagnostic, Diagnostic, DiagnosticSink, DiagnosticSinkBuilder,\n+};\n+pub use hir_ty::diagnostics::{\n+    MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField,\n+};"}, {"sha": "1c691d961967a08b0bc9012d3f46dff22ecc66b5", "filename": "crates/ra_hir/src/has_source.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fhas_source.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -57,56 +57,56 @@ impl HasSource for Field {\n     }\n }\n impl HasSource for Struct {\n-    type Ast = ast::StructDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::StructDef> {\n+    type Ast = ast::Struct;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Struct> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Union {\n-    type Ast = ast::UnionDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::UnionDef> {\n+    type Ast = ast::Union;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Union> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Enum {\n-    type Ast = ast::EnumDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::EnumDef> {\n+    type Ast = ast::Enum;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Enum> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for EnumVariant {\n-    type Ast = ast::EnumVariant;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::EnumVariant> {\n+    type Ast = ast::Variant;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Variant> {\n         self.parent.id.child_source(db.upcast()).map(|map| map[self.id].clone())\n     }\n }\n impl HasSource for Function {\n-    type Ast = ast::FnDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::FnDef> {\n+    type Ast = ast::Fn;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Fn> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Const {\n-    type Ast = ast::ConstDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::ConstDef> {\n+    type Ast = ast::Const;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Const> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Static {\n-    type Ast = ast::StaticDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::StaticDef> {\n+    type Ast = ast::Static;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Static> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for Trait {\n-    type Ast = ast::TraitDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::TraitDef> {\n+    type Ast = ast::Trait;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Trait> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n impl HasSource for TypeAlias {\n-    type Ast = ast::TypeAliasDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::TypeAliasDef> {\n+    type Ast = ast::TypeAlias;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::TypeAlias> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n@@ -120,14 +120,14 @@ impl HasSource for MacroDef {\n     }\n }\n impl HasSource for ImplDef {\n-    type Ast = ast::ImplDef;\n-    fn source(self, db: &dyn HirDatabase) -> InFile<ast::ImplDef> {\n+    type Ast = ast::Impl;\n+    fn source(self, db: &dyn HirDatabase) -> InFile<ast::Impl> {\n         self.id.lookup(db.upcast()).source(db.upcast())\n     }\n }\n \n impl HasSource for TypeParam {\n-    type Ast = Either<ast::TraitDef, ast::TypeParam>;\n+    type Ast = Either<ast::Trait, ast::TypeParam>;\n     fn source(self, db: &dyn HirDatabase) -> InFile<Self::Ast> {\n         let child_source = self.id.parent.child_source(db.upcast());\n         child_source.map(|it| it[self.id.local_id].clone())"}, {"sha": "e2d13dbfdc803a2ed8fd829c59cd766568495b85", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -19,25 +19,6 @@\n \n #![recursion_limit = \"512\"]\n \n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident $(($($sv:ident),*))?),*$(,)?) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-            $($(\n-                impl From<$sv> for $e {\n-                    fn from(it: $sv) -> $e {\n-                        $e::$v($v::$sv(it))\n-                    }\n-                }\n-            )*)?\n-        )*\n-    }\n-}\n-\n mod semantics;\n pub mod db;\n mod source_analyzer;\n@@ -51,10 +32,10 @@ mod has_source;\n \n pub use crate::{\n     code_model::{\n-        Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Const, Crate, CrateDependency,\n-        DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource, Function, GenericDef, HasAttrs,\n-        HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef, Static, Struct,\n-        Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n+        Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Callable, CallableKind, Const,\n+        Crate, CrateDependency, DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource, Function,\n+        GenericDef, HasAttrs, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef,\n+        Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     has_source::HasSource,\n     semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n@@ -74,6 +55,7 @@ pub use hir_def::{\n pub use hir_expand::{\n     hygiene::Hygiene,\n     name::{AsName, Name},\n-    HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,\n+    HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, /* FIXME */\n+    MacroFile, Origin,\n };\n-pub use hir_ty::{display::HirDisplay, CallableDef};\n+pub use hir_ty::display::HirDisplay;"}, {"sha": "6f3b3dc9ad7c6b45147ce6c16eca5949a9471235", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 282, "deletions": 99, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,7 +6,7 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    AsMacroCall, TraitId, VariantId,\n+    AsMacroCall, FunctionId, TraitId, VariantId,\n };\n use hir_expand::{diagnostics::AstDiagnostic, hygiene::Hygiene, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n@@ -24,8 +24,8 @@ use crate::{\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n-    AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n-    Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam,\n+    AssocItem, Callable, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module,\n+    ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n use resolver::TypeNs;\n \n@@ -83,7 +83,13 @@ impl PathResolution {\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,\n+    imp: SemanticsImpl<'db>,\n+}\n+\n+pub struct SemanticsImpl<'db> {\n+    pub db: &'db dyn HirDatabase,\n     s2d_cache: RefCell<SourceToDefCache>,\n+    expansion_info_cache: RefCell<FxHashMap<HirFileId, Option<ExpansionInfo>>>,\n     cache: RefCell<FxHashMap<SyntaxNode, HirFileId>>,\n }\n \n@@ -95,23 +101,199 @@ impl<DB> fmt::Debug for Semantics<'_, DB> {\n \n impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn new(db: &DB) -> Semantics<DB> {\n-        Semantics { db, s2d_cache: Default::default(), cache: Default::default() }\n+        let impl_ = SemanticsImpl::new(db);\n+        Semantics { db, imp: impl_ }\n     }\n \n     pub fn parse(&self, file_id: FileId) -> ast::SourceFile {\n-        let tree = self.db.parse(file_id).tree();\n-        self.cache(tree.syntax().clone(), file_id.into());\n-        tree\n+        self.imp.parse(file_id)\n     }\n \n     pub fn ast<T: AstDiagnostic + Diagnostic>(&self, d: &T) -> <T as AstDiagnostic>::AST {\n         let file_id = d.source().file_id;\n         let root = self.db.parse_or_expand(file_id).unwrap();\n-        self.cache(root, file_id);\n-        d.ast(self.db)\n+        self.imp.cache(root, file_id);\n+        d.ast(self.db.upcast())\n     }\n \n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n+        self.imp.expand(macro_call)\n+    }\n+\n+    pub fn expand_hypothetical(\n+        &self,\n+        actual_macro_call: &ast::MacroCall,\n+        hypothetical_args: &ast::TokenTree,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        self.imp.expand_hypothetical(actual_macro_call, hypothetical_args, token_to_map)\n+    }\n+\n+    pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n+        self.imp.descend_into_macros(token)\n+    }\n+\n+    pub fn descend_node_at_offset<N: ast::AstNode>(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextSize,\n+    ) -> Option<N> {\n+        self.imp.descend_node_at_offset(node, offset).find_map(N::cast)\n+    }\n+\n+    pub fn original_range(&self, node: &SyntaxNode) -> FileRange {\n+        self.imp.original_range(node)\n+    }\n+\n+    pub fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        self.imp.diagnostics_range(diagnostics)\n+    }\n+\n+    pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        self.imp.ancestors_with_macros(node)\n+    }\n+\n+    pub fn ancestors_at_offset_with_macros(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextSize,\n+    ) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        self.imp.ancestors_at_offset_with_macros(node, offset)\n+    }\n+\n+    /// Find a AstNode by offset inside SyntaxNode, if it is inside *Macrofile*,\n+    /// search up until it is of the target AstNode type\n+    pub fn find_node_at_offset_with_macros<N: AstNode>(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextSize,\n+    ) -> Option<N> {\n+        self.imp.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n+    }\n+\n+    /// Find a AstNode by offset inside SyntaxNode, if it is inside *MacroCall*,\n+    /// descend it and find again\n+    pub fn find_node_at_offset_with_descend<N: AstNode>(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextSize,\n+    ) -> Option<N> {\n+        if let Some(it) = find_node_at_offset(&node, offset) {\n+            return Some(it);\n+        }\n+\n+        self.imp.descend_node_at_offset(node, offset).find_map(N::cast)\n+    }\n+\n+    pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n+        self.imp.type_of_expr(expr)\n+    }\n+\n+    pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n+        self.imp.type_of_pat(pat)\n+    }\n+\n+    pub fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n+        self.imp.type_of_self(param)\n+    }\n+\n+    pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n+        self.imp.resolve_method_call(call).map(Function::from)\n+    }\n+\n+    pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n+        self.imp.resolve_method_call_as_callable(call)\n+    }\n+\n+    pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n+        self.imp.resolve_field(field)\n+    }\n+\n+    pub fn resolve_record_field(\n+        &self,\n+        field: &ast::RecordExprField,\n+    ) -> Option<(Field, Option<Local>)> {\n+        self.imp.resolve_record_field(field)\n+    }\n+\n+    pub fn resolve_record_field_pat(&self, field: &ast::RecordFieldPat) -> Option<Field> {\n+        self.imp.resolve_record_field_pat(field)\n+    }\n+\n+    pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n+        self.imp.resolve_macro_call(macro_call)\n+    }\n+\n+    pub fn resolve_path(&self, path: &ast::Path) -> Option<PathResolution> {\n+        self.imp.resolve_path(path)\n+    }\n+\n+    pub fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantDef> {\n+        self.imp.resolve_variant(record_lit).map(VariantDef::from)\n+    }\n+\n+    pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n+        self.imp.lower_path(path)\n+    }\n+\n+    pub fn resolve_bind_pat_to_const(&self, pat: &ast::BindPat) -> Option<ModuleDef> {\n+        self.imp.resolve_bind_pat_to_const(pat)\n+    }\n+\n+    // FIXME: use this instead?\n+    // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n+\n+    pub fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n+        self.imp.record_literal_missing_fields(literal)\n+    }\n+\n+    pub fn record_pattern_missing_fields(&self, pattern: &ast::RecordPat) -> Vec<(Field, Type)> {\n+        self.imp.record_pattern_missing_fields(pattern)\n+    }\n+\n+    pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n+        let src = self.imp.find_file(src.syntax().clone()).with_value(src).cloned();\n+        T::to_def(&self.imp, src)\n+    }\n+\n+    pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n+        self.imp.to_module_def(file)\n+    }\n+\n+    pub fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n+        self.imp.scope(node)\n+    }\n+\n+    pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n+        self.imp.scope_at_offset(node, offset)\n+    }\n+\n+    pub fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n+        self.imp.scope_for_def(def)\n+    }\n+\n+    pub fn assert_contains_node(&self, node: &SyntaxNode) {\n+        self.imp.assert_contains_node(node)\n+    }\n+}\n+\n+impl<'db> SemanticsImpl<'db> {\n+    fn new(db: &'db dyn HirDatabase) -> Self {\n+        SemanticsImpl {\n+            db,\n+            s2d_cache: Default::default(),\n+            cache: Default::default(),\n+            expansion_info_cache: Default::default(),\n+        }\n+    }\n+\n+    fn parse(&self, file_id: FileId) -> ast::SourceFile {\n+        let tree = self.db.parse(file_id).tree();\n+        self.cache(tree.syntax().clone(), file_id.into());\n+        tree\n+    }\n+\n+    fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         let macro_call = self.find_file(macro_call.syntax().clone()).with_value(macro_call);\n         let sa = self.analyze2(macro_call.map(|it| it.syntax()), None);\n         let file_id = sa.expand(self.db, macro_call)?;\n@@ -120,7 +302,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         Some(node)\n     }\n \n-    pub fn expand_hypothetical(\n+    fn expand_hypothetical(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n         hypothetical_args: &ast::TokenTree,\n@@ -130,24 +312,38 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n             self.find_file(actual_macro_call.syntax().clone()).with_value(actual_macro_call);\n         let sa = self.analyze2(macro_call.map(|it| it.syntax()), None);\n         let krate = sa.resolver.krate()?;\n-        let macro_call_id = macro_call\n-            .as_call_id(self.db, krate, |path| sa.resolver.resolve_path_as_macro(self.db, &path))?;\n-        hir_expand::db::expand_hypothetical(self.db, macro_call_id, hypothetical_args, token_to_map)\n-    }\n-\n-    pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n+        let macro_call_id = macro_call.as_call_id(self.db.upcast(), krate, |path| {\n+            sa.resolver.resolve_path_as_macro(self.db.upcast(), &path)\n+        })?;\n+        hir_expand::db::expand_hypothetical(\n+            self.db.upcast(),\n+            macro_call_id,\n+            hypothetical_args,\n+            token_to_map,\n+        )\n+    }\n+\n+    fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n+        let _p = profile(\"descend_into_macros\");\n         let parent = token.parent();\n         let parent = self.find_file(parent);\n         let sa = self.analyze2(parent.as_ref(), None);\n \n         let token = successors(Some(parent.with_value(token)), |token| {\n+            self.db.check_canceled();\n             let macro_call = token.value.ancestors().find_map(ast::MacroCall::cast)?;\n             let tt = macro_call.token_tree()?;\n             if !tt.syntax().text_range().contains_range(token.value.text_range()) {\n                 return None;\n             }\n             let file_id = sa.expand(self.db, token.with_value(&macro_call))?;\n-            let token = file_id.expansion_info(self.db)?.map_token_down(token.as_ref())?;\n+            let token = self\n+                .expansion_info_cache\n+                .borrow_mut()\n+                .entry(file_id)\n+                .or_insert_with(|| file_id.expansion_info(self.db.upcast()))\n+                .as_ref()?\n+                .map_token_down(token.as_ref())?;\n \n             self.cache(find_root(&token.value.parent()), token.file_id);\n \n@@ -159,35 +355,36 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         token.value\n     }\n \n-    pub fn descend_node_at_offset<N: ast::AstNode>(\n+    fn descend_node_at_offset(\n         &self,\n         node: &SyntaxNode,\n         offset: TextSize,\n-    ) -> Option<N> {\n+    ) -> impl Iterator<Item = SyntaxNode> + '_ {\n         // Handle macro token cases\n         node.token_at_offset(offset)\n             .map(|token| self.descend_into_macros(token))\n-            .find_map(|it| self.ancestors_with_macros(it.parent()).find_map(N::cast))\n+            .map(|it| self.ancestors_with_macros(it.parent()))\n+            .flatten()\n     }\n \n-    pub fn original_range(&self, node: &SyntaxNode) -> FileRange {\n+    fn original_range(&self, node: &SyntaxNode) -> FileRange {\n         let node = self.find_file(node.clone());\n         original_range(self.db, node.as_ref())\n     }\n \n-    pub fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+    fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n         let src = diagnostics.source();\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);\n         original_range(self.db, src.with_value(&node))\n     }\n \n-    pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n+    fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n         let node = self.find_file(node);\n-        node.ancestors_with_macros(self.db).map(|it| it.value)\n+        node.ancestors_with_macros(self.db.upcast()).map(|it| it.value)\n     }\n \n-    pub fn ancestors_at_offset_with_macros(\n+    fn ancestors_at_offset_with_macros(\n         &self,\n         node: &SyntaxNode,\n         offset: TextSize,\n@@ -197,120 +394,104 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n             .kmerge_by(|node1, node2| node1.text_range().len() < node2.text_range().len())\n     }\n \n-    /// Find a AstNode by offset inside SyntaxNode, if it is inside *Macrofile*,\n-    /// search up until it is of the target AstNode type\n-    pub fn find_node_at_offset_with_macros<N: AstNode>(\n-        &self,\n-        node: &SyntaxNode,\n-        offset: TextSize,\n-    ) -> Option<N> {\n-        self.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n+    fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n+        self.analyze(expr.syntax()).type_of_expr(self.db, &expr)\n     }\n \n-    /// Find a AstNode by offset inside SyntaxNode, if it is inside *MacroCall*,\n-    /// descend it and find again\n-    pub fn find_node_at_offset_with_descend<N: AstNode>(\n-        &self,\n-        node: &SyntaxNode,\n-        offset: TextSize,\n-    ) -> Option<N> {\n-        if let Some(it) = find_node_at_offset(&node, offset) {\n-            return Some(it);\n-        }\n-        self.descend_node_at_offset(&node, offset)\n+    fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n+        self.analyze(pat.syntax()).type_of_pat(self.db, &pat)\n     }\n \n-    pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n-        self.analyze(expr.syntax()).type_of(self.db, &expr)\n+    fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n+        self.analyze(param.syntax()).type_of_self(self.db, &param)\n     }\n \n-    pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n-        self.analyze(pat.syntax()).type_of_pat(self.db, &pat)\n+    fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<FunctionId> {\n+        self.analyze(call.syntax()).resolve_method_call(self.db, call)\n     }\n \n-    pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        self.analyze(call.syntax()).resolve_method_call(self.db, call)\n+    fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n+        // FIXME: this erases Substs\n+        let func = self.resolve_method_call(call)?;\n+        let ty = self.db.value_ty(func.into());\n+        let resolver = self.analyze(call.syntax()).resolver;\n+        let ty = Type::new_with_resolver(self.db, &resolver, ty.value)?;\n+        let mut res = ty.as_callable(self.db)?;\n+        res.is_bound_method = true;\n+        Some(res)\n     }\n \n-    pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n+    fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n         self.analyze(field.syntax()).resolve_field(self.db, field)\n     }\n \n-    pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<(Field, Option<Local>)> {\n+    fn resolve_record_field(&self, field: &ast::RecordExprField) -> Option<(Field, Option<Local>)> {\n         self.analyze(field.syntax()).resolve_record_field(self.db, field)\n     }\n \n-    pub fn resolve_record_field_pat(&self, field: &ast::RecordFieldPat) -> Option<Field> {\n+    fn resolve_record_field_pat(&self, field: &ast::RecordFieldPat) -> Option<Field> {\n         self.analyze(field.syntax()).resolve_record_field_pat(self.db, field)\n     }\n \n-    pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n+    fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n         let sa = self.analyze(macro_call.syntax());\n         let macro_call = self.find_file(macro_call.syntax().clone()).with_value(macro_call);\n         sa.resolve_macro_call(self.db, macro_call)\n     }\n \n-    pub fn resolve_path(&self, path: &ast::Path) -> Option<PathResolution> {\n+    fn resolve_path(&self, path: &ast::Path) -> Option<PathResolution> {\n         self.analyze(path.syntax()).resolve_path(self.db, path)\n     }\n \n-    pub fn resolve_variant(&self, record_lit: ast::RecordLit) -> Option<VariantId> {\n+    fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantId> {\n         self.analyze(record_lit.syntax()).resolve_variant(self.db, record_lit)\n     }\n \n-    pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n+    fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n         let src = self.find_file(path.syntax().clone());\n         Path::from_src(path.clone(), &Hygiene::new(self.db.upcast(), src.file_id.into()))\n     }\n \n-    pub fn resolve_bind_pat_to_const(&self, pat: &ast::BindPat) -> Option<ModuleDef> {\n+    fn resolve_bind_pat_to_const(&self, pat: &ast::BindPat) -> Option<ModuleDef> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n \n-    // FIXME: use this instead?\n-    // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n-\n-    pub fn record_literal_missing_fields(&self, literal: &ast::RecordLit) -> Vec<(Field, Type)> {\n+    fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.analyze(literal.syntax())\n             .record_literal_missing_fields(self.db, literal)\n             .unwrap_or_default()\n     }\n \n-    pub fn record_pattern_missing_fields(&self, pattern: &ast::RecordPat) -> Vec<(Field, Type)> {\n+    fn record_pattern_missing_fields(&self, pattern: &ast::RecordPat) -> Vec<(Field, Type)> {\n         self.analyze(pattern.syntax())\n             .record_pattern_missing_fields(self.db, pattern)\n             .unwrap_or_default()\n     }\n \n-    pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n-        let src = self.find_file(src.syntax().clone()).with_value(src).cloned();\n-        T::to_def(self, src)\n-    }\n-\n     fn with_ctx<F: FnOnce(&mut SourceToDefCtx) -> T, T>(&self, f: F) -> T {\n         let mut cache = self.s2d_cache.borrow_mut();\n         let mut ctx = SourceToDefCtx { db: self.db, cache: &mut *cache };\n         f(&mut ctx)\n     }\n \n-    pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n+    fn to_module_def(&self, file: FileId) -> Option<Module> {\n         self.with_ctx(|ctx| ctx.file_to_def(file)).map(Module::from)\n     }\n \n-    pub fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db, DB> {\n+    fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n         let node = self.find_file(node.clone());\n         let resolver = self.analyze2(node.as_ref(), None).resolver;\n         SemanticsScope { db: self.db, resolver }\n     }\n \n-    pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db, DB> {\n+    fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n         let node = self.find_file(node.clone());\n         let resolver = self.analyze2(node.as_ref(), Some(offset)).resolver;\n         SemanticsScope { db: self.db, resolver }\n     }\n \n-    pub fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db, DB> {\n-        let resolver = def.id.resolver(self.db);\n+    fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n+        let resolver = def.id.resolver(self.db.upcast());\n         SemanticsScope { db: self.db, resolver }\n     }\n \n@@ -331,12 +512,13 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n             ChildContainer::DefWithBodyId(def) => {\n                 return SourceAnalyzer::new_for_body(self.db, def, src, offset)\n             }\n-            ChildContainer::TraitId(it) => it.resolver(self.db),\n-            ChildContainer::ImplId(it) => it.resolver(self.db),\n-            ChildContainer::ModuleId(it) => it.resolver(self.db),\n-            ChildContainer::EnumId(it) => it.resolver(self.db),\n-            ChildContainer::VariantId(it) => it.resolver(self.db),\n-            ChildContainer::GenericDefId(it) => it.resolver(self.db),\n+            ChildContainer::TraitId(it) => it.resolver(self.db.upcast()),\n+            ChildContainer::ImplId(it) => it.resolver(self.db.upcast()),\n+            ChildContainer::ModuleId(it) => it.resolver(self.db.upcast()),\n+            ChildContainer::EnumId(it) => it.resolver(self.db.upcast()),\n+            ChildContainer::VariantId(it) => it.resolver(self.db.upcast()),\n+            ChildContainer::TypeAliasId(it) => it.resolver(self.db.upcast()),\n+            ChildContainer::GenericDefId(it) => it.resolver(self.db.upcast()),\n         };\n         SourceAnalyzer::new_for_resolver(resolver, src)\n     }\n@@ -348,7 +530,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         assert!(prev == None || prev == Some(file_id))\n     }\n \n-    pub fn assert_contains_node(&self, node: &SyntaxNode) {\n+    fn assert_contains_node(&self, node: &SyntaxNode) {\n         self.find_file(node.clone());\n     }\n \n@@ -382,14 +564,14 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n pub trait ToDef: AstNode + Clone {\n     type Def;\n \n-    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: InFile<Self>) -> Option<Self::Def>;\n+    fn to_def(sema: &SemanticsImpl, src: InFile<Self>) -> Option<Self::Def>;\n }\n \n macro_rules! to_def_impls {\n     ($(($def:path, $ast:path, $meth:ident)),* ,) => {$(\n         impl ToDef for $ast {\n             type Def = $def;\n-            fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: InFile<Self>) -> Option<Self::Def> {\n+            fn to_def(sema: &SemanticsImpl, src: InFile<Self>) -> Option<Self::Def> {\n                 sema.with_ctx(|ctx| ctx.$meth(src)).map(<$def>::from)\n             }\n         }\n@@ -398,18 +580,18 @@ macro_rules! to_def_impls {\n \n to_def_impls![\n     (crate::Module, ast::Module, module_to_def),\n-    (crate::Struct, ast::StructDef, struct_to_def),\n-    (crate::Enum, ast::EnumDef, enum_to_def),\n-    (crate::Union, ast::UnionDef, union_to_def),\n-    (crate::Trait, ast::TraitDef, trait_to_def),\n-    (crate::ImplDef, ast::ImplDef, impl_to_def),\n-    (crate::TypeAlias, ast::TypeAliasDef, type_alias_to_def),\n-    (crate::Const, ast::ConstDef, const_to_def),\n-    (crate::Static, ast::StaticDef, static_to_def),\n-    (crate::Function, ast::FnDef, fn_to_def),\n-    (crate::Field, ast::RecordFieldDef, record_field_to_def),\n-    (crate::Field, ast::TupleFieldDef, tuple_field_to_def),\n-    (crate::EnumVariant, ast::EnumVariant, enum_variant_to_def),\n+    (crate::Struct, ast::Struct, struct_to_def),\n+    (crate::Enum, ast::Enum, enum_to_def),\n+    (crate::Union, ast::Union, union_to_def),\n+    (crate::Trait, ast::Trait, trait_to_def),\n+    (crate::ImplDef, ast::Impl, impl_to_def),\n+    (crate::TypeAlias, ast::TypeAlias, type_alias_to_def),\n+    (crate::Const, ast::Const, const_to_def),\n+    (crate::Static, ast::Static, static_to_def),\n+    (crate::Function, ast::Fn, fn_to_def),\n+    (crate::Field, ast::RecordField, record_field_to_def),\n+    (crate::Field, ast::TupleField, tuple_field_to_def),\n+    (crate::EnumVariant, ast::Variant, enum_variant_to_def),\n     (crate::TypeParam, ast::TypeParam, type_param_to_def),\n     (crate::MacroDef, ast::MacroCall, macro_call_to_def), // this one is dubious, not all calls are macros\n     (crate::Local, ast::BindPat, bind_pat_to_def),\n@@ -419,12 +601,13 @@ fn find_root(node: &SyntaxNode) -> SyntaxNode {\n     node.ancestors().last().unwrap()\n }\n \n-pub struct SemanticsScope<'a, DB> {\n-    pub db: &'a DB,\n+#[derive(Debug)]\n+pub struct SemanticsScope<'a> {\n+    pub db: &'a dyn HirDatabase,\n     resolver: Resolver,\n }\n \n-impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n+impl<'a> SemanticsScope<'a> {\n     pub fn module(&self) -> Option<Module> {\n         Some(Module { id: self.resolver.module()? })\n     }\n@@ -433,13 +616,13 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n     // FIXME: rename to visible_traits to not repeat scope?\n     pub fn traits_in_scope(&self) -> FxHashSet<TraitId> {\n         let resolver = &self.resolver;\n-        resolver.traits_in_scope(self.db)\n+        resolver.traits_in_scope(self.db.upcast())\n     }\n \n     pub fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n         let resolver = &self.resolver;\n \n-        resolver.process_all_names(self.db, &mut |name, def| {\n+        resolver.process_all_names(self.db.upcast(), &mut |name, def| {\n             let def = match def {\n                 resolver::ScopeDef::PerNs(it) => {\n                     let items = ScopeDef::all_items(it);"}, {"sha": "d1994e2e7804ec0d987f3ea7a806c01760fdd563", "filename": "crates/ra_hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -16,6 +16,7 @@ use ra_syntax::{\n     match_ast, AstNode, SyntaxNode,\n };\n use rustc_hash::FxHashMap;\n+use stdx::impl_from;\n \n use crate::{db::HirDatabase, InFile, MacroDefId};\n \n@@ -64,53 +65,44 @@ impl SourceToDefCtx<'_, '_> {\n         Some(ModuleId { krate: parent_module.krate, local_id: child_id })\n     }\n \n-    pub(super) fn trait_to_def(&mut self, src: InFile<ast::TraitDef>) -> Option<TraitId> {\n+    pub(super) fn trait_to_def(&mut self, src: InFile<ast::Trait>) -> Option<TraitId> {\n         self.to_def(src, keys::TRAIT)\n     }\n-    pub(super) fn impl_to_def(&mut self, src: InFile<ast::ImplDef>) -> Option<ImplId> {\n+    pub(super) fn impl_to_def(&mut self, src: InFile<ast::Impl>) -> Option<ImplId> {\n         self.to_def(src, keys::IMPL)\n     }\n-    pub(super) fn fn_to_def(&mut self, src: InFile<ast::FnDef>) -> Option<FunctionId> {\n+    pub(super) fn fn_to_def(&mut self, src: InFile<ast::Fn>) -> Option<FunctionId> {\n         self.to_def(src, keys::FUNCTION)\n     }\n-    pub(super) fn struct_to_def(&mut self, src: InFile<ast::StructDef>) -> Option<StructId> {\n+    pub(super) fn struct_to_def(&mut self, src: InFile<ast::Struct>) -> Option<StructId> {\n         self.to_def(src, keys::STRUCT)\n     }\n-    pub(super) fn enum_to_def(&mut self, src: InFile<ast::EnumDef>) -> Option<EnumId> {\n+    pub(super) fn enum_to_def(&mut self, src: InFile<ast::Enum>) -> Option<EnumId> {\n         self.to_def(src, keys::ENUM)\n     }\n-    pub(super) fn union_to_def(&mut self, src: InFile<ast::UnionDef>) -> Option<UnionId> {\n+    pub(super) fn union_to_def(&mut self, src: InFile<ast::Union>) -> Option<UnionId> {\n         self.to_def(src, keys::UNION)\n     }\n-    pub(super) fn static_to_def(&mut self, src: InFile<ast::StaticDef>) -> Option<StaticId> {\n+    pub(super) fn static_to_def(&mut self, src: InFile<ast::Static>) -> Option<StaticId> {\n         self.to_def(src, keys::STATIC)\n     }\n-    pub(super) fn const_to_def(&mut self, src: InFile<ast::ConstDef>) -> Option<ConstId> {\n+    pub(super) fn const_to_def(&mut self, src: InFile<ast::Const>) -> Option<ConstId> {\n         self.to_def(src, keys::CONST)\n     }\n-    pub(super) fn type_alias_to_def(\n-        &mut self,\n-        src: InFile<ast::TypeAliasDef>,\n-    ) -> Option<TypeAliasId> {\n+    pub(super) fn type_alias_to_def(&mut self, src: InFile<ast::TypeAlias>) -> Option<TypeAliasId> {\n         self.to_def(src, keys::TYPE_ALIAS)\n     }\n-    pub(super) fn record_field_to_def(\n-        &mut self,\n-        src: InFile<ast::RecordFieldDef>,\n-    ) -> Option<FieldId> {\n+    pub(super) fn record_field_to_def(&mut self, src: InFile<ast::RecordField>) -> Option<FieldId> {\n         self.to_def(src, keys::RECORD_FIELD)\n     }\n-    pub(super) fn tuple_field_to_def(\n-        &mut self,\n-        src: InFile<ast::TupleFieldDef>,\n-    ) -> Option<FieldId> {\n+    pub(super) fn tuple_field_to_def(&mut self, src: InFile<ast::TupleField>) -> Option<FieldId> {\n         self.to_def(src, keys::TUPLE_FIELD)\n     }\n     pub(super) fn enum_variant_to_def(\n         &mut self,\n-        src: InFile<ast::EnumVariant>,\n+        src: InFile<ast::Variant>,\n     ) -> Option<EnumVariantId> {\n-        self.to_def(src, keys::ENUM_VARIANT)\n+        self.to_def(src, keys::VARIANT)\n     }\n     pub(super) fn bind_pat_to_def(\n         &mut self,\n@@ -162,38 +154,42 @@ impl SourceToDefCtx<'_, '_> {\n                         let def = self.module_to_def(container.with_value(it))?;\n                         def.into()\n                     },\n-                    ast::TraitDef(it) => {\n+                    ast::Trait(it) => {\n                         let def = self.trait_to_def(container.with_value(it))?;\n                         def.into()\n                     },\n-                    ast::ImplDef(it) => {\n+                    ast::Impl(it) => {\n                         let def = self.impl_to_def(container.with_value(it))?;\n                         def.into()\n                     },\n-                    ast::FnDef(it) => {\n+                    ast::Fn(it) => {\n                         let def = self.fn_to_def(container.with_value(it))?;\n                         DefWithBodyId::from(def).into()\n                     },\n-                    ast::StructDef(it) => {\n+                    ast::Struct(it) => {\n                         let def = self.struct_to_def(container.with_value(it))?;\n                         VariantId::from(def).into()\n                     },\n-                    ast::EnumDef(it) => {\n+                    ast::Enum(it) => {\n                         let def = self.enum_to_def(container.with_value(it))?;\n                         def.into()\n                     },\n-                    ast::UnionDef(it) => {\n+                    ast::Union(it) => {\n                         let def = self.union_to_def(container.with_value(it))?;\n                         VariantId::from(def).into()\n                     },\n-                    ast::StaticDef(it) => {\n+                    ast::Static(it) => {\n                         let def = self.static_to_def(container.with_value(it))?;\n                         DefWithBodyId::from(def).into()\n                     },\n-                    ast::ConstDef(it) => {\n+                    ast::Const(it) => {\n                         let def = self.const_to_def(container.with_value(it))?;\n                         DefWithBodyId::from(def).into()\n                     },\n+                    ast::TypeAlias(it) => {\n+                        let def = self.type_alias_to_def(container.with_value(it))?;\n+                        def.into()\n+                    },\n                     _ => continue,\n                 }\n             };\n@@ -208,12 +204,12 @@ impl SourceToDefCtx<'_, '_> {\n         for container in src.cloned().ancestors_with_macros(self.db.upcast()).skip(1) {\n             let res: GenericDefId = match_ast! {\n                 match (container.value) {\n-                    ast::FnDef(it) => self.fn_to_def(container.with_value(it))?.into(),\n-                    ast::StructDef(it) => self.struct_to_def(container.with_value(it))?.into(),\n-                    ast::EnumDef(it) => self.enum_to_def(container.with_value(it))?.into(),\n-                    ast::TraitDef(it) => self.trait_to_def(container.with_value(it))?.into(),\n-                    ast::TypeAliasDef(it) => self.type_alias_to_def(container.with_value(it))?.into(),\n-                    ast::ImplDef(it) => self.impl_to_def(container.with_value(it))?.into(),\n+                    ast::Fn(it) => self.fn_to_def(container.with_value(it))?.into(),\n+                    ast::Struct(it) => self.struct_to_def(container.with_value(it))?.into(),\n+                    ast::Enum(it) => self.enum_to_def(container.with_value(it))?.into(),\n+                    ast::Trait(it) => self.trait_to_def(container.with_value(it))?.into(),\n+                    ast::TypeAlias(it) => self.type_alias_to_def(container.with_value(it))?.into(),\n+                    ast::Impl(it) => self.impl_to_def(container.with_value(it))?.into(),\n                     _ => continue,\n                 }\n             };\n@@ -226,9 +222,9 @@ impl SourceToDefCtx<'_, '_> {\n         for container in src.cloned().ancestors_with_macros(self.db.upcast()).skip(1) {\n             let res: DefWithBodyId = match_ast! {\n                 match (container.value) {\n-                    ast::ConstDef(it) => self.const_to_def(container.with_value(it))?.into(),\n-                    ast::StaticDef(it) => self.static_to_def(container.with_value(it))?.into(),\n-                    ast::FnDef(it) => self.fn_to_def(container.with_value(it))?.into(),\n+                    ast::Const(it) => self.const_to_def(container.with_value(it))?.into(),\n+                    ast::Static(it) => self.static_to_def(container.with_value(it))?.into(),\n+                    ast::Fn(it) => self.fn_to_def(container.with_value(it))?.into(),\n                     _ => continue,\n                 }\n             };\n@@ -246,19 +242,21 @@ pub(crate) enum ChildContainer {\n     ImplId(ImplId),\n     EnumId(EnumId),\n     VariantId(VariantId),\n+    TypeAliasId(TypeAliasId),\n     /// XXX: this might be the same def as, for example an `EnumId`. However,\n     /// here the children generic parameters, and not, eg enum variants.\n     GenericDefId(GenericDefId),\n }\n-impl_froms! {\n-    ChildContainer:\n+impl_from! {\n     DefWithBodyId,\n     ModuleId,\n     TraitId,\n     ImplId,\n     EnumId,\n     VariantId,\n+    TypeAliasId,\n     GenericDefId\n+    for ChildContainer\n }\n \n impl ChildContainer {\n@@ -271,6 +269,7 @@ impl ChildContainer {\n             ChildContainer::ImplId(it) => it.child_by_source(db),\n             ChildContainer::EnumId(it) => it.child_by_source(db),\n             ChildContainer::VariantId(it) => it.child_by_source(db),\n+            ChildContainer::TypeAliasId(_) => DynMap::default(),\n             ChildContainer::GenericDefId(it) => it.child_by_source(db),\n         }\n     }"}, {"sha": "f2e630ef1ab43ed405bd81a123d6106f72519ff9", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -14,11 +14,11 @@ use hir_def::{\n     },\n     expr::{ExprId, Pat, PatId},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n-    AsMacroCall, DefWithBodyId, FieldId, LocalFieldId, VariantId,\n+    AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n use hir_ty::{\n-    expr::{record_literal_missing_fields, record_pattern_missing_fields},\n+    diagnostics::{record_literal_missing_fields, record_pattern_missing_fields},\n     InferenceResult, Substs, Ty,\n };\n use ra_syntax::{\n@@ -115,7 +115,7 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    pub(crate) fn type_of(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n+    pub(crate) fn type_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = self.expr_id(db, expr)?;\n         let ty = self.infer.as_ref()?[expr_id].clone();\n         Type::new_with_resolver(db, &self.resolver, ty)\n@@ -127,13 +127,24 @@ impl SourceAnalyzer {\n         Type::new_with_resolver(db, &self.resolver, ty)\n     }\n \n+    pub(crate) fn type_of_self(\n+        &self,\n+        db: &dyn HirDatabase,\n+        param: &ast::SelfParam,\n+    ) -> Option<Type> {\n+        let src = InFile { file_id: self.file_id, value: param };\n+        let pat_id = self.body_source_map.as_ref()?.node_self_param(src)?;\n+        let ty = self.infer.as_ref()?[pat_id].clone();\n+        Type::new_with_resolver(db, &self.resolver, ty)\n+    }\n+\n     pub(crate) fn resolve_method_call(\n         &self,\n         db: &dyn HirDatabase,\n         call: &ast::MethodCallExpr,\n-    ) -> Option<Function> {\n+    ) -> Option<FunctionId> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id).map(Function::from)\n+        self.infer.as_ref()?.method_resolution(expr_id)\n     }\n \n     pub(crate) fn resolve_field(\n@@ -148,7 +159,7 @@ impl SourceAnalyzer {\n     pub(crate) fn resolve_record_field(\n         &self,\n         db: &dyn HirDatabase,\n-        field: &ast::RecordField,\n+        field: &ast::RecordExprField,\n     ) -> Option<(Field, Option<Local>)> {\n         let expr = field.expr()?;\n         let expr_id = self.expr_id(db, &expr)?;\n@@ -235,7 +246,7 @@ impl SourceAnalyzer {\n             }\n         }\n \n-        if let Some(rec_lit) = path.syntax().parent().and_then(ast::RecordLit::cast) {\n+        if let Some(rec_lit) = path.syntax().parent().and_then(ast::RecordExpr::cast) {\n             let expr_id = self.expr_id(db, &rec_lit.into())?;\n             if let Some(VariantId::EnumVariantId(variant)) =\n                 self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n@@ -273,7 +284,7 @@ impl SourceAnalyzer {\n     pub(crate) fn record_literal_missing_fields(\n         &self,\n         db: &dyn HirDatabase,\n-        literal: &ast::RecordLit,\n+        literal: &ast::RecordExpr,\n     ) -> Option<Vec<(Field, Type)>> {\n         let krate = self.resolver.krate()?;\n         let body = self.body.as_ref()?;\n@@ -341,13 +352,13 @@ impl SourceAnalyzer {\n         let macro_call_id = macro_call.as_call_id(db.upcast(), krate, |path| {\n             self.resolver.resolve_path_as_macro(db.upcast(), &path)\n         })?;\n-        Some(macro_call_id.as_file())\n+        Some(macro_call_id.as_file()).filter(|it| it.expansion_level(db.upcast()) < 64)\n     }\n \n     pub(crate) fn resolve_variant(\n         &self,\n         db: &dyn HirDatabase,\n-        record_lit: ast::RecordLit,\n+        record_lit: ast::RecordExpr,\n     ) -> Option<VariantId> {\n         let infer = self.infer.as_ref()?;\n         let expr_id = self.expr_id(db, &record_lit.into())?;\n@@ -394,8 +405,7 @@ fn scope_for_offset(\n             )\n         })\n         .map(|(expr_range, scope)| {\n-            adjust(db, scopes, source_map, expr_range, offset.file_id, offset.value)\n-                .unwrap_or(*scope)\n+            adjust(db, scopes, source_map, expr_range, offset).unwrap_or(*scope)\n         })\n }\n \n@@ -406,24 +416,23 @@ fn adjust(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n     expr_range: TextRange,\n-    file_id: HirFileId,\n-    offset: TextSize,\n+    offset: InFile<TextSize>,\n ) -> Option<ScopeId> {\n     let child_scopes = scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n             let source = source_map.expr_syntax(*id).ok()?;\n             // FIXME: correctly handle macro expansion\n-            if source.file_id != file_id {\n+            if source.file_id != offset.file_id {\n                 return None;\n             }\n             let root = source.file_syntax(db.upcast());\n             let node = source.value.to_node(&root);\n             Some((node.syntax().text_range(), scope))\n         })\n         .filter(|&(range, _)| {\n-            range.start() <= offset && expr_range.contains_range(range) && range != expr_range\n+            range.start() <= offset.value && expr_range.contains_range(range) && range != expr_range\n         });\n \n     child_scopes"}, {"sha": "d96a86b80f0ced2a01eb73a05ba2e8efb32a2d4a", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ edition = \"2018\"\n name = \"ra_hir_def\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false\n@@ -32,4 +33,4 @@ ra_cfg = { path = \"../ra_cfg\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n \n [dev-dependencies]\n-insta = \"0.16.0\"\n+expect = { path = \"../expect\" }"}, {"sha": "6cb56a1cd00e6e8dc4d4036801f7cf3b21ba2d6b", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -8,7 +8,7 @@ use hir_expand::{\n     InFile,\n };\n use ra_arena::{map::ArenaMap, Arena};\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n+use ra_syntax::ast::{self, NameOwner, VisibilityOwner};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n@@ -112,7 +112,7 @@ impl EnumData {\n \n impl HasChildSource for EnumId {\n     type ChildId = LocalEnumVariantId;\n-    type Value = ast::EnumVariant;\n+    type Value = ast::Variant;\n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let src = self.lookup(db).source(db);\n         let mut trace = Trace::new_for_map();\n@@ -123,8 +123,8 @@ impl HasChildSource for EnumId {\n \n fn lower_enum(\n     db: &dyn DefDatabase,\n-    trace: &mut Trace<EnumVariantData, ast::EnumVariant>,\n-    ast: &InFile<ast::EnumDef>,\n+    trace: &mut Trace<EnumVariantData, ast::Variant>,\n+    ast: &InFile<ast::Enum>,\n     module_id: ModuleId,\n ) {\n     let expander = CfgExpander::new(db, ast.file_id, module_id.krate);\n@@ -179,7 +179,7 @@ impl VariantData {\n \n impl HasChildSource for VariantId {\n     type ChildId = LocalFieldId;\n-    type Value = Either<ast::TupleFieldDef, ast::RecordFieldDef>;\n+    type Value = Either<ast::TupleField, ast::RecordField>;\n \n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let (src, module_id) = match self {\n@@ -194,7 +194,7 @@ impl HasChildSource for VariantId {\n             }\n             VariantId::UnionId(it) => (\n                 it.lookup(db).source(db).map(|it| {\n-                    it.record_field_def_list()\n+                    it.record_field_list()\n                         .map(ast::StructKind::Record)\n                         .unwrap_or(ast::StructKind::Unit)\n                 }),\n@@ -218,7 +218,7 @@ pub enum StructKind {\n fn lower_struct(\n     db: &dyn DefDatabase,\n     expander: &mut CfgExpander,\n-    trace: &mut Trace<FieldData, Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n+    trace: &mut Trace<FieldData, Either<ast::TupleField, ast::RecordField>>,\n     ast: &InFile<ast::StructKind>,\n ) -> StructKind {\n     let ctx = LowerCtx::new(db, ast.file_id);\n@@ -234,7 +234,7 @@ fn lower_struct(\n                     || Either::Left(fd.clone()),\n                     || FieldData {\n                         name: Name::new_tuple_field(i),\n-                        type_ref: TypeRef::from_ast_opt(&ctx, fd.type_ref()),\n+                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ty()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n@@ -251,7 +251,7 @@ fn lower_struct(\n                     || Either::Right(fd.clone()),\n                     || FieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n-                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ascribed_type()),\n+                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ty()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );"}, {"sha": "050832ce01be0cd51d2dccc00c23882624bcb7b1", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,7 +5,7 @@ use std::{ops, sync::Arc};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, AstId, InFile};\n use mbe::ast_to_token_tree;\n-use ra_cfg::CfgOptions;\n+use ra_cfg::{CfgExpr, CfgOptions};\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SmolStr,\n@@ -125,9 +125,12 @@ impl Attrs {\n         AttrQuery { attrs: self, key }\n     }\n \n-    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+    pub fn cfg(&self) -> impl Iterator<Item = CfgExpr> + '_ {\n         // FIXME: handle cfg_attr :-)\n-        self.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n+        self.by_key(\"cfg\").tt_values().map(CfgExpr::parse)\n+    }\n+    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+        self.cfg().all(|cfg| cfg_options.check(&cfg) != Some(false))\n     }\n }\n \n@@ -148,18 +151,15 @@ pub enum AttrInput {\n impl Attr {\n     fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n         let path = ModPath::from_src(ast.path()?, hygiene)?;\n-        let input = match ast.input() {\n-            None => None,\n-            Some(ast::AttrInput::Literal(lit)) => {\n-                // FIXME: escape? raw string?\n-                let value = lit.syntax().first_token()?.text().trim_matches('\"').into();\n-                Some(AttrInput::Literal(value))\n-            }\n-            Some(ast::AttrInput::TokenTree(tt)) => {\n-                Some(AttrInput::TokenTree(ast_to_token_tree(&tt)?.0))\n-            }\n+        let input = if let Some(lit) = ast.literal() {\n+            // FIXME: escape? raw string?\n+            let value = lit.syntax().first_token()?.text().trim_matches('\"').into();\n+            Some(AttrInput::Literal(value))\n+        } else if let Some(tt) = ast.token_tree() {\n+            Some(AttrInput::TokenTree(ast_to_token_tree(&tt)?.0))\n+        } else {\n+            None\n         };\n-\n         Some(Attr { path, input })\n     }\n }"}, {"sha": "d5f18b9201c401a07773e6960a380a2bedf34071", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -14,6 +14,7 @@ use ra_db::CrateId;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n+use test_utils::mark;\n \n pub(crate) use lower::LowerCtx;\n \n@@ -42,9 +43,15 @@ pub(crate) struct Expander {\n     current_file_id: HirFileId,\n     ast_id_map: Arc<AstIdMap>,\n     module: ModuleId,\n-    recursive_limit: usize,\n+    recursion_limit: usize,\n }\n \n+#[cfg(test)]\n+const EXPANSION_RECURSION_LIMIT: usize = 32;\n+\n+#[cfg(not(test))]\n+const EXPANSION_RECURSION_LIMIT: usize = 128;\n+\n impl CfgExpander {\n     pub(crate) fn new(\n         db: &dyn DefDatabase,\n@@ -81,7 +88,7 @@ impl Expander {\n             current_file_id,\n             ast_id_map,\n             module,\n-            recursive_limit: 0,\n+            recursion_limit: 0,\n         }\n     }\n \n@@ -91,7 +98,9 @@ impl Expander {\n         local_scope: Option<&ItemScope>,\n         macro_call: ast::MacroCall,\n     ) -> Option<(Mark, T)> {\n-        if self.recursive_limit > 1024 {\n+        self.recursion_limit += 1;\n+        if self.recursion_limit > EXPANSION_RECURSION_LIMIT {\n+            mark::hit!(your_stack_belongs_to_me);\n             return None;\n         }\n \n@@ -118,8 +127,6 @@ impl Expander {\n                     self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n                     self.current_file_id = file_id;\n                     self.ast_id_map = db.ast_id_map(file_id);\n-                    self.recursive_limit += 1;\n-\n                     return Some((mark, expr));\n                 }\n             }\n@@ -134,7 +141,7 @@ impl Expander {\n         self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n         self.ast_id_map = mem::take(&mut mark.ast_id_map);\n-        self.recursive_limit -= 1;\n+        self.recursion_limit -= 1;\n         mark.bomb.defuse();\n     }\n \n@@ -209,7 +216,7 @@ pub struct BodySourceMap {\n     expr_map_back: ArenaMap<ExprId, Result<ExprSource, SyntheticSyntax>>,\n     pat_map: FxHashMap<PatSource, PatId>,\n     pat_map_back: ArenaMap<PatId, Result<PatSource, SyntheticSyntax>>,\n-    field_map: FxHashMap<(ExprId, usize), InFile<AstPtr<ast::RecordField>>>,\n+    field_map: FxHashMap<(ExprId, usize), InFile<AstPtr<ast::RecordExprField>>>,\n     expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n }\n \n@@ -302,7 +309,53 @@ impl BodySourceMap {\n         self.pat_map.get(&src).cloned()\n     }\n \n-    pub fn field_syntax(&self, expr: ExprId, field: usize) -> InFile<AstPtr<ast::RecordField>> {\n+    pub fn node_self_param(&self, node: InFile<&ast::SelfParam>) -> Option<PatId> {\n+        let src = node.map(|it| Either::Right(AstPtr::new(it)));\n+        self.pat_map.get(&src).cloned()\n+    }\n+\n+    pub fn field_syntax(&self, expr: ExprId, field: usize) -> InFile<AstPtr<ast::RecordExprField>> {\n         self.field_map[&(expr, field)].clone()\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n+    use test_utils::mark;\n+\n+    use crate::ModuleDefId;\n+\n+    use super::*;\n+\n+    fn lower(ra_fixture: &str) -> Arc<Body> {\n+        let (db, file_id) = crate::test_db::TestDB::with_single_file(ra_fixture);\n+\n+        let krate = db.crate_graph().iter().next().unwrap();\n+        let def_map = db.crate_def_map(krate);\n+        let module = def_map.modules_for_file(file_id).next().unwrap();\n+        let module = &def_map[module];\n+        let fn_def = match module.scope.declarations().next().unwrap() {\n+            ModuleDefId::FunctionId(it) => it,\n+            _ => panic!(),\n+        };\n+\n+        db.body(fn_def.into())\n+    }\n+\n+    #[test]\n+    fn your_stack_belongs_to_me() {\n+        mark::check!(your_stack_belongs_to_me);\n+        lower(\n+            \"\n+macro_rules! n_nuple {\n+    ($e:tt) => ();\n+    ($($rest:tt)*) => {{\n+        (n_nuple!($($rest)*)None,)\n+    }};\n+}\n+fn main() { n_nuple!(1,2,3); }\n+\",\n+        );\n+    }\n+}"}, {"sha": "827ced4ad211fe2a54d46081eace5fcfc51f6508", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -11,7 +11,7 @@ use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n         self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, ModuleItemOwner, NameOwner,\n-        SlicePatComponents, TypeAscriptionOwner,\n+        SlicePatComponents,\n     },\n     AstNode, AstPtr,\n };\n@@ -379,10 +379,10 @@ impl ExprCollector<'_> {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n-            ast::Expr::RecordLit(e) => {\n+            ast::Expr::RecordExpr(e) => {\n                 let path = e.path().and_then(|path| self.expander.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n-                let record_lit = if let Some(nfl) = e.record_field_list() {\n+                let record_lit = if let Some(nfl) = e.record_expr_field_list() {\n                     let fields = nfl\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n@@ -432,7 +432,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.type_ref());\n+                let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.ty());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::Expr::RefExpr(e) => {\n@@ -466,16 +466,13 @@ impl ExprCollector<'_> {\n                 if let Some(pl) = e.param_list() {\n                     for param in pl.params() {\n                         let pat = self.collect_pat_opt(param.pat());\n-                        let type_ref =\n-                            param.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                        let type_ref = param.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n-                let ret_type = e\n-                    .ret_type()\n-                    .and_then(|r| r.type_ref())\n-                    .map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                let ret_type =\n+                    e.ret_type().and_then(|r| r.ty()).map(|it| TypeRef::from_ast(&self.ctx(), it));\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n@@ -607,8 +604,7 @@ impl ExprCollector<'_> {\n             .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref =\n-                        stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                    let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }\n@@ -627,53 +623,53 @@ impl ExprCollector<'_> {\n             .items()\n             .filter_map(|item| {\n                 let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n-                    ast::ModuleItem::FnDef(def) => {\n+                    ast::Item::Fn(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (\n                             FunctionLoc { container: container.into(), id }.intern(self.db).into(),\n                             def.name(),\n                         )\n                     }\n-                    ast::ModuleItem::TypeAliasDef(def) => {\n+                    ast::Item::TypeAlias(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (\n                             TypeAliasLoc { container: container.into(), id }.intern(self.db).into(),\n                             def.name(),\n                         )\n                     }\n-                    ast::ModuleItem::ConstDef(def) => {\n+                    ast::Item::Const(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (\n                             ConstLoc { container: container.into(), id }.intern(self.db).into(),\n                             def.name(),\n                         )\n                     }\n-                    ast::ModuleItem::StaticDef(def) => {\n+                    ast::Item::Static(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (StaticLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::StructDef(def) => {\n+                    ast::Item::Struct(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (StructLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::EnumDef(def) => {\n+                    ast::Item::Enum(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (EnumLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::UnionDef(def) => {\n+                    ast::Item::Union(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (UnionLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::TraitDef(def) => {\n+                    ast::Item::Trait(def) => {\n                         let id = self.find_inner_item(&def)?;\n                         (TraitLoc { container, id }.intern(self.db).into(), def.name())\n                     }\n-                    ast::ModuleItem::ExternBlock(_) => return None, // FIXME: collect from extern blocks\n-                    ast::ModuleItem::ImplDef(_)\n-                    | ast::ModuleItem::UseItem(_)\n-                    | ast::ModuleItem::ExternCrateItem(_)\n-                    | ast::ModuleItem::Module(_)\n-                    | ast::ModuleItem::MacroCall(_) => return None,\n+                    ast::Item::ExternBlock(_) => return None, // FIXME: collect from extern blocks\n+                    ast::Item::Impl(_)\n+                    | ast::Item::Use(_)\n+                    | ast::Item::ExternCrate(_)\n+                    | ast::Item::Module(_)\n+                    | ast::Item::MacroCall(_) => return None,\n                 };\n \n                 Some((def, name))"}, {"sha": "dcb00a1d9a0ba916cc83b3bcc0015f7a9c79aab7", "filename": "crates/ra_hir_def/src/child_by_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -162,7 +162,7 @@ impl ChildBySource for EnumId {\n         let arena_map = arena_map.as_ref();\n         for (local_id, source) in arena_map.value.iter() {\n             let id = EnumVariantId { parent: *self, local_id };\n-            res[keys::ENUM_VARIANT].insert(arena_map.with_value(source.clone()), id)\n+            res[keys::VARIANT].insert(arena_map.with_value(source.clone()), id)\n         }\n \n         res"}, {"sha": "88a8ef9bffebedec08f3181688aed1bd15c2c518", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -27,11 +27,12 @@ pub struct FunctionData {\n     /// can be called as a method.\n     pub has_self_param: bool,\n     pub is_unsafe: bool,\n+    pub is_varargs: bool,\n     pub visibility: RawVisibility,\n }\n \n impl FunctionData {\n-    pub(crate) fn fn_data_query(db: &impl DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n+    pub(crate) fn fn_data_query(db: &dyn DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n         let item_tree = db.item_tree(loc.id.file_id);\n         let func = &item_tree[loc.id.value];\n@@ -43,6 +44,7 @@ impl FunctionData {\n             attrs: item_tree.attrs(ModItem::from(loc.id.value).into()).clone(),\n             has_self_param: func.has_self_param,\n             is_unsafe: func.is_unsafe,\n+            is_varargs: func.is_varargs,\n             visibility: item_tree[func.visibility].clone(),\n         })\n     }"}, {"sha": "8ea61fcf237d4539e991ddddc81ffbe9d7474cfa", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -12,7 +12,7 @@ use hir_expand::{\n use ra_arena::{map::ArenaMap, Arena};\n use ra_db::FileId;\n use ra_prof::profile;\n-use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n+use ra_syntax::ast::{self, GenericParamsOwner, NameOwner, TypeBoundsOwner};\n \n use crate::{\n     body::LowerCtx,\n@@ -66,7 +66,7 @@ pub enum WherePredicateTarget {\n     TypeParam(LocalTypeParamId),\n }\n \n-type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::TraitDef, ast::TypeParam>>;\n+type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::Trait, ast::TypeParam>>;\n \n impl GenericParams {\n     pub(crate) fn generic_params_query(\n@@ -205,9 +205,9 @@ impl GenericParams {\n         &mut self,\n         lower_ctx: &LowerCtx,\n         sm: &mut SourceMap,\n-        node: &dyn TypeParamsOwner,\n+        node: &dyn GenericParamsOwner,\n     ) {\n-        if let Some(params) = node.type_param_list() {\n+        if let Some(params) = node.generic_param_list() {\n             self.fill_params(lower_ctx, sm, params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n@@ -232,7 +232,7 @@ impl GenericParams {\n         &mut self,\n         lower_ctx: &LowerCtx,\n         sm: &mut SourceMap,\n-        params: ast::TypeParamList,\n+        params: ast::GenericParamList,\n     ) {\n         for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n@@ -317,7 +317,7 @@ impl GenericParams {\n \n impl HasChildSource for GenericDefId {\n     type ChildId = LocalTypeParamId;\n-    type Value = Either<ast::TraitDef, ast::TypeParam>;\n+    type Value = Either<ast::Trait, ast::TypeParam>;\n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<SourceMap> {\n         let (_, sm) = GenericParams::new(db, *self);\n         sm"}, {"sha": "9e4c30b1abf1c169d43a1e2f352f67b185fab3ce", "filename": "crates/ra_hir_def/src/import_map.rs", "status": "modified", "additions": 218, "deletions": 152, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,14 +5,16 @@ use std::{cmp::Ordering, fmt, hash::BuildHasherDefault, sync::Arc};\n use fst::{self, Streamer};\n use indexmap::{map::Entry, IndexMap};\n use ra_db::CrateId;\n-use rustc_hash::FxHasher;\n+use ra_syntax::SmolStr;\n+use rustc_hash::{FxHashMap, FxHasher};\n+use smallvec::SmallVec;\n \n use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n     visibility::Visibility,\n-    ModuleDefId, ModuleId,\n+    AssocItemId, ModuleDefId, ModuleId, TraitId,\n };\n \n type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n@@ -34,6 +36,7 @@ pub struct ImportInfo {\n ///\n /// Note that all paths are relative to the containing crate's root, so the crate name still needs\n /// to be prepended to the `ModPath` before the path is valid.\n+#[derive(Default)]\n pub struct ImportMap {\n     map: FxIndexMap<ItemInNs, ImportInfo>,\n \n@@ -45,13 +48,17 @@ pub struct ImportMap {\n     /// the index of the first one.\n     importables: Vec<ItemInNs>,\n     fst: fst::Map<Vec<u8>>,\n+\n+    /// Maps names of associated items to the item's ID. Only includes items whose defining trait is\n+    /// exported.\n+    assoc_map: FxHashMap<SmolStr, SmallVec<[AssocItemId; 1]>>,\n }\n \n impl ImportMap {\n     pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n         let _p = ra_prof::profile(\"import_map_query\");\n         let def_map = db.crate_def_map(krate);\n-        let mut import_map = FxIndexMap::with_capacity_and_hasher(64, Default::default());\n+        let mut import_map = Self::default();\n \n         // We look only into modules that are public(ly reexported), starting with the crate root.\n         let empty = ModPath { kind: PathKind::Plain, segments: vec![] };\n@@ -85,7 +92,7 @@ impl ImportMap {\n \n                 for item in per_ns.iter_items() {\n                     let path = mk_path();\n-                    match import_map.entry(item) {\n+                    match import_map.map.entry(item) {\n                         Entry::Vacant(entry) => {\n                             entry.insert(ImportInfo { path, container: module });\n                         }\n@@ -105,11 +112,16 @@ impl ImportMap {\n                     if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n                         worklist.push((mod_id, mk_path()));\n                     }\n+\n+                    // If we've added a path to a trait, add the trait's methods to the method map.\n+                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n+                        import_map.collect_trait_methods(db, tr);\n+                    }\n                 }\n             }\n         }\n \n-        let mut importables = import_map.iter().collect::<Vec<_>>();\n+        let mut importables = import_map.map.iter().collect::<Vec<_>>();\n \n         importables.sort_by(cmp);\n \n@@ -133,10 +145,10 @@ impl ImportMap {\n             builder.insert(key, start as u64).unwrap();\n         }\n \n-        let fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n-        let importables = importables.iter().map(|(item, _)| **item).collect();\n+        import_map.fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n+        import_map.importables = importables.iter().map(|(item, _)| **item).collect();\n \n-        Arc::new(Self { map: import_map, fst, importables })\n+        Arc::new(import_map)\n     }\n \n     /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n@@ -147,6 +159,13 @@ impl ImportMap {\n     pub fn import_info_for(&self, item: ItemInNs) -> Option<&ImportInfo> {\n         self.map.get(&item)\n     }\n+\n+    fn collect_trait_methods(&mut self, db: &dyn DefDatabase, tr: TraitId) {\n+        let data = db.trait_data(tr);\n+        for (name, item) in data.items.iter() {\n+            self.assoc_map.entry(name.to_string().into()).or_default().push(*item);\n+        }\n+    }\n }\n \n impl PartialEq for ImportMap {\n@@ -290,37 +309,32 @@ pub fn search_dependencies<'a>(\n         }\n     }\n \n+    // Add all exported associated items whose names match the query (exactly).\n+    for map in &import_maps {\n+        if let Some(v) = map.assoc_map.get(&*query.query) {\n+            res.extend(v.iter().map(|&assoc| {\n+                ItemInNs::Types(match assoc {\n+                    AssocItemId::FunctionId(it) => it.into(),\n+                    AssocItemId::ConstId(it) => it.into(),\n+                    AssocItemId::TypeAliasId(it) => it.into(),\n+                })\n+            }));\n+        }\n+    }\n+\n     res\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use crate::test_db::TestDB;\n-    use insta::assert_snapshot;\n-    use itertools::Itertools;\n-    use ra_db::fixture::WithFixture;\n-    use ra_db::{SourceDatabase, Upcast};\n+    use expect::{expect, Expect};\n+    use ra_db::{fixture::WithFixture, SourceDatabase, Upcast};\n \n-    fn import_map(ra_fixture: &str) -> String {\n-        let db = TestDB::with_files(ra_fixture);\n-        let crate_graph = db.crate_graph();\n+    use crate::{test_db::TestDB, AssocContainerId, Lookup};\n \n-        let s = crate_graph\n-            .iter()\n-            .filter_map(|krate| {\n-                let cdata = &crate_graph[krate];\n-                let name = cdata.display_name.as_ref()?;\n-\n-                let map = db.import_map(krate);\n-\n-                Some(format!(\"{}:\\n{:?}\", name, map))\n-            })\n-            .join(\"\\n\");\n-        s\n-    }\n+    use super::*;\n \n-    fn search_dependencies_of(ra_fixture: &str, krate_name: &str, query: Query) -> String {\n+    fn check_search(ra_fixture: &str, krate_name: &str, query: Query, expect: Expect) {\n         let db = TestDB::with_files(ra_fixture);\n         let crate_graph = db.crate_graph();\n         let krate = crate_graph\n@@ -331,31 +345,75 @@ mod tests {\n             })\n             .unwrap();\n \n-        search_dependencies(db.upcast(), krate, query)\n+        let actual = search_dependencies(db.upcast(), krate, query)\n             .into_iter()\n             .filter_map(|item| {\n                 let mark = match item {\n                     ItemInNs::Types(_) => \"t\",\n                     ItemInNs::Values(_) => \"v\",\n                     ItemInNs::Macros(_) => \"m\",\n                 };\n+                let item = assoc_to_trait(&db, item);\n                 item.krate(db.upcast()).map(|krate| {\n                     let map = db.import_map(krate);\n                     let path = map.path_of(item).unwrap();\n                     format!(\n-                        \"{}::{} ({})\",\n+                        \"{}::{} ({})\\n\",\n                         crate_graph[krate].display_name.as_ref().unwrap(),\n                         path,\n                         mark\n                     )\n                 })\n             })\n-            .join(\"\\n\")\n+            .collect::<String>();\n+        expect.assert_eq(&actual)\n+    }\n+\n+    fn assoc_to_trait(db: &dyn DefDatabase, item: ItemInNs) -> ItemInNs {\n+        let assoc: AssocItemId = match item {\n+            ItemInNs::Types(it) | ItemInNs::Values(it) => match it {\n+                ModuleDefId::TypeAliasId(it) => it.into(),\n+                ModuleDefId::FunctionId(it) => it.into(),\n+                ModuleDefId::ConstId(it) => it.into(),\n+                _ => return item,\n+            },\n+            _ => return item,\n+        };\n+\n+        let container = match assoc {\n+            AssocItemId::FunctionId(it) => it.lookup(db).container,\n+            AssocItemId::ConstId(it) => it.lookup(db).container,\n+            AssocItemId::TypeAliasId(it) => it.lookup(db).container,\n+        };\n+\n+        match container {\n+            AssocContainerId::TraitId(it) => ItemInNs::Types(it.into()),\n+            _ => item,\n+        }\n+    }\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+\n+        let actual = crate_graph\n+            .iter()\n+            .filter_map(|krate| {\n+                let cdata = &crate_graph[krate];\n+                let name = cdata.display_name.as_ref()?;\n+\n+                let map = db.import_map(krate);\n+\n+                Some(format!(\"{}:\\n{:?}\\n\", name, map))\n+            })\n+            .collect::<String>();\n+\n+        expect.assert_eq(&actual)\n     }\n \n     #[test]\n     fn smoke() {\n-        let map = import_map(\n+        check(\n             r\"\n             //- /main.rs crate:main deps:lib\n \n@@ -380,24 +438,23 @@ mod tests {\n             pub struct Pub2; // t + v\n             struct Priv;\n         \",\n+            expect![[r#\"\n+                main:\n+                - publ1 (t)\n+                - real_pu2 (t)\n+                - real_pub (t)\n+                - real_pub::Pub (t)\n+                lib:\n+                - Pub (t)\n+                - Pub2 (t)\n+                - Pub2 (v)\n+            \"#]],\n         );\n-\n-        assert_snapshot!(map, @r###\"\n-        main:\n-        - publ1 (t)\n-        - real_pu2 (t)\n-        - real_pub (t)\n-        - real_pub::Pub (t)\n-        lib:\n-        - Pub (t)\n-        - Pub2 (t)\n-        - Pub2 (v)\n-        \"###);\n     }\n \n     #[test]\n     fn prefers_shortest_path() {\n-        let map = import_map(\n+        check(\n             r\"\n             //- /main.rs crate:main\n \n@@ -409,21 +466,20 @@ mod tests {\n                 pub use super::sub::subsub::Def;\n             }\n         \",\n+            expect![[r#\"\n+                main:\n+                - sub (t)\n+                - sub::Def (t)\n+                - sub::subsub (t)\n+            \"#]],\n         );\n-\n-        assert_snapshot!(map, @r###\"\n-        main:\n-        - sub (t)\n-        - sub::Def (t)\n-        - sub::subsub (t)\n-        \"###);\n     }\n \n     #[test]\n     fn type_reexport_cross_crate() {\n         // Reexports need to be visible from a crate, even if the original crate exports the item\n         // at a shorter path.\n-        let map = import_map(\n+        check(\n             r\"\n             //- /main.rs crate:main deps:lib\n             pub mod m {\n@@ -432,22 +488,21 @@ mod tests {\n             //- /lib.rs crate:lib\n             pub struct S;\n         \",\n+            expect![[r#\"\n+                main:\n+                - m (t)\n+                - m::S (t)\n+                - m::S (v)\n+                lib:\n+                - S (t)\n+                - S (v)\n+            \"#]],\n         );\n-\n-        assert_snapshot!(map, @r###\"\n-        main:\n-        - m (t)\n-        - m::S (t)\n-        - m::S (v)\n-        lib:\n-        - S (t)\n-        - S (v)\n-        \"###);\n     }\n \n     #[test]\n     fn macro_reexport() {\n-        let map = import_map(\n+        check(\n             r\"\n             //- /main.rs crate:main deps:lib\n             pub mod m {\n@@ -459,21 +514,20 @@ mod tests {\n                 () => {};\n             }\n         \",\n+            expect![[r#\"\n+                main:\n+                - m (t)\n+                - m::pub_macro (m)\n+                lib:\n+                - pub_macro (m)\n+            \"#]],\n         );\n-\n-        assert_snapshot!(map, @r###\"\n-        main:\n-        - m (t)\n-        - m::pub_macro (m)\n-        lib:\n-        - pub_macro (m)\n-        \"###);\n     }\n \n     #[test]\n     fn module_reexport() {\n         // Reexporting modules from a dependency adds all contents to the import map.\n-        let map = import_map(\n+        check(\n             r\"\n             //- /main.rs crate:main deps:lib\n             pub use lib::module as reexported_module;\n@@ -482,24 +536,23 @@ mod tests {\n                 pub struct S;\n             }\n         \",\n+            expect![[r#\"\n+                main:\n+                - reexported_module (t)\n+                - reexported_module::S (t)\n+                - reexported_module::S (v)\n+                lib:\n+                - module (t)\n+                - module::S (t)\n+                - module::S (v)\n+            \"#]],\n         );\n-\n-        assert_snapshot!(map, @r###\"\n-        main:\n-        - reexported_module (t)\n-        - reexported_module::S (t)\n-        - reexported_module::S (v)\n-        lib:\n-        - module (t)\n-        - module::S (t)\n-        - module::S (v)\n-        \"###);\n     }\n \n     #[test]\n     fn cyclic_module_reexport() {\n         // A cyclic reexport does not hang.\n-        let map = import_map(\n+        check(\n             r\"\n             //- /lib.rs crate:lib\n             pub mod module {\n@@ -511,36 +564,35 @@ mod tests {\n                 pub use super::module;\n             }\n         \",\n+            expect![[r#\"\n+                lib:\n+                - module (t)\n+                - module::S (t)\n+                - module::S (v)\n+                - sub (t)\n+            \"#]],\n         );\n-\n-        assert_snapshot!(map, @r###\"\n-        lib:\n-        - module (t)\n-        - module::S (t)\n-        - module::S (v)\n-        - sub (t)\n-        \"###);\n     }\n \n     #[test]\n     fn private_macro() {\n-        let map = import_map(\n+        check(\n             r\"\n             //- /lib.rs crate:lib\n             macro_rules! private_macro {\n                 () => {};\n             }\n         \",\n-        );\n+            expect![[r#\"\n+                lib:\n \n-        assert_snapshot!(map, @r###\"\n-        lib:\n-        \"###);\n+            \"#]],\n+        );\n     }\n \n     #[test]\n     fn namespacing() {\n-        let map = import_map(\n+        check(\n             r\"\n             //- /lib.rs crate:lib\n             pub struct Thing;     // t + v\n@@ -549,16 +601,15 @@ mod tests {\n                 () => {};\n             }\n         \",\n+            expect![[r#\"\n+                lib:\n+                - Thing (m)\n+                - Thing (t)\n+                - Thing (v)\n+            \"#]],\n         );\n \n-        assert_snapshot!(map, @r###\"\n-        lib:\n-        - Thing (m)\n-        - Thing (t)\n-        - Thing (v)\n-        \"###);\n-\n-        let map = import_map(\n+        check(\n             r\"\n             //- /lib.rs crate:lib\n             pub mod Thing {}      // t\n@@ -567,13 +618,12 @@ mod tests {\n                 () => {};\n             }\n         \",\n+            expect![[r#\"\n+                lib:\n+                - Thing (m)\n+                - Thing (t)\n+            \"#]],\n         );\n-\n-        assert_snapshot!(map, @r###\"\n-        lib:\n-        - Thing (m)\n-        - Thing (t)\n-        \"###);\n     }\n \n     #[test]\n@@ -602,23 +652,33 @@ mod tests {\n             }\n         \"#;\n \n-        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\"));\n-        assert_snapshot!(res, @r###\"\n-        dep::fmt (t)\n-        dep::Fmt (t)\n-        dep::Fmt (v)\n-        dep::Fmt (m)\n-        dep::fmt::Display (t)\n-        dep::format (v)\n-        \"###);\n-\n-        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\").anchor_end());\n-        assert_snapshot!(res, @r###\"\n-        dep::fmt (t)\n-        dep::Fmt (t)\n-        dep::Fmt (v)\n-        dep::Fmt (m)\n-        \"###);\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\"),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::fmt::Display (t)\n+                dep::format (v)\n+                dep::fmt::Display (t)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\").anchor_end(),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::fmt::Display (t)\n+            \"#]],\n+        );\n     }\n \n     #[test]\n@@ -631,26 +691,32 @@ mod tests {\n             pub struct FMT;\n         \"#;\n \n-        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"FMT\"));\n-\n-        assert_snapshot!(res, @r###\"\n-        dep::fmt (t)\n-        dep::fmt (v)\n-        dep::FMT (t)\n-        dep::FMT (v)\n-        \"###);\n-\n-        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"FMT\").case_sensitive());\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"FMT\"),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::fmt (v)\n+                dep::FMT (t)\n+                dep::FMT (v)\n+            \"#]],\n+        );\n \n-        assert_snapshot!(res, @r###\"\n-        dep::FMT (t)\n-        dep::FMT (v)\n-        \"###);\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"FMT\").case_sensitive(),\n+            expect![[r#\"\n+                dep::FMT (t)\n+                dep::FMT (v)\n+            \"#]],\n+        );\n     }\n \n     #[test]\n     fn search_limit() {\n-        let res = search_dependencies_of(\n+        check_search(\n             r#\"\n         //- /main.rs crate:main deps:dep\n         //- /dep.rs crate:dep\n@@ -670,10 +736,10 @@ mod tests {\n     \"#,\n             \"main\",\n             Query::new(\"\").limit(2),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (t)\n+            \"#]],\n         );\n-        assert_snapshot!(res, @r###\"\n-        dep::fmt (t)\n-        dep::Fmt (t)\n-        \"###);\n     }\n }"}, {"sha": "8fee4b15e54ef56bf7a0ec16ef24995415594962", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 90, "deletions": 42, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,6 +1,8 @@\n //! Describes items defined or visible (ie, imported) in a certain scope.\n //! This is shared between modules and blocks.\n \n+use std::collections::hash_map::Entry;\n+\n use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use ra_db::CrateId;\n@@ -27,9 +29,15 @@ pub struct PerNsGlobImports {\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n-    visible: FxHashMap<Name, PerNs>,\n+    types: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    values: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    macros: FxHashMap<Name, (MacroDefId, Visibility)>,\n+    unresolved: FxHashSet<Name>,\n+\n     defs: Vec<ModuleDefId>,\n     impls: Vec<ImplId>,\n+    /// Traits imported via `use Trait as _;`.\n+    unnamed_trait_imports: FxHashMap<TraitId, Visibility>,\n     /// Macros visible in current module in legacy textual scope\n     ///\n     /// For macros invoked by an unqualified identifier like `bar!()`, `legacy_macros` will be searched in first.\n@@ -65,14 +73,16 @@ pub(crate) enum BuiltinShadowMode {\n /// Other methods will only resolve values, types and module scoped macros only.\n impl ItemScope {\n     pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n-        //FIXME: shadowing\n-        self.visible.iter().map(|(n, def)| (n, *def))\n-    }\n-\n-    pub fn entries_without_primitives<'a>(\n-        &'a self,\n-    ) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n-        self.visible.iter().map(|(n, def)| (n, *def))\n+        // FIXME: shadowing\n+        let keys: FxHashSet<_> = self\n+            .types\n+            .keys()\n+            .chain(self.values.keys())\n+            .chain(self.macros.keys())\n+            .chain(self.unresolved.iter())\n+            .collect();\n+\n+        keys.into_iter().map(move |name| (name, self.get(name)))\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n@@ -91,7 +101,7 @@ impl ItemScope {\n \n     /// Iterate over all module scoped macros\n     pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.visible.iter().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n+        self.entries().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n@@ -101,23 +111,30 @@ impl ItemScope {\n \n     /// Get a name from current module scope, legacy macros are not included\n     pub(crate) fn get(&self, name: &Name) -> PerNs {\n-        self.visible.get(name).copied().unwrap_or_else(PerNs::none)\n+        PerNs {\n+            types: self.types.get(name).copied(),\n+            values: self.values.get(name).copied(),\n+            macros: self.macros.get(name).copied(),\n+        }\n     }\n \n     pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n-        for (name, per_ns) in &self.visible {\n-            if let Some(vis) = item.match_with(*per_ns) {\n+        for (name, per_ns) in self.entries() {\n+            if let Some(vis) = item.match_with(per_ns) {\n                 return Some((name, vis));\n             }\n         }\n         None\n     }\n \n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.visible.values().filter_map(|def| match def.take_types() {\n-            Some(ModuleDefId::TraitId(t)) => Some(t),\n-            _ => None,\n-        })\n+        self.types\n+            .values()\n+            .filter_map(|(def, _)| match def {\n+                ModuleDefId::TraitId(t) => Some(*t),\n+                _ => None,\n+            })\n+            .chain(self.unnamed_trait_imports.keys().copied())\n     }\n \n     pub(crate) fn define_def(&mut self, def: ModuleDefId) {\n@@ -136,23 +153,40 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n+    pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {\n+        self.unnamed_trait_imports.get(&tr).copied()\n+    }\n+\n+    pub(crate) fn push_unnamed_trait(&mut self, tr: TraitId, vis: Visibility) {\n+        self.unnamed_trait_imports.insert(tr, vis);\n+    }\n+\n     pub(crate) fn push_res(&mut self, name: Name, def: PerNs) -> bool {\n         let mut changed = false;\n-        let existing = self.visible.entry(name).or_default();\n \n-        if existing.types.is_none() && def.types.is_some() {\n-            existing.types = def.types;\n-            changed = true;\n+        if let Some(types) = def.types {\n+            self.types.entry(name.clone()).or_insert_with(|| {\n+                changed = true;\n+                types\n+            });\n         }\n-\n-        if existing.values.is_none() && def.values.is_some() {\n-            existing.values = def.values;\n-            changed = true;\n+        if let Some(values) = def.values {\n+            self.values.entry(name.clone()).or_insert_with(|| {\n+                changed = true;\n+                values\n+            });\n+        }\n+        if let Some(macros) = def.macros {\n+            self.macros.entry(name.clone()).or_insert_with(|| {\n+                changed = true;\n+                macros\n+            });\n         }\n \n-        if existing.macros.is_none() && def.macros.is_some() {\n-            existing.macros = def.macros;\n-            changed = true;\n+        if def.is_none() {\n+            if self.unresolved.insert(name) {\n+                changed = true;\n+            }\n         }\n \n         changed\n@@ -166,17 +200,17 @@ impl ItemScope {\n         def_import_type: ImportType,\n     ) -> bool {\n         let mut changed = false;\n-        let existing = self.visible.entry(lookup.1.clone()).or_default();\n \n         macro_rules! check_changed {\n             (\n                 $changed:ident,\n-                ( $existing:ident / $def:ident ) . $field:ident,\n+                ( $this:ident / $def:ident ) . $field:ident,\n                 $glob_imports:ident [ $lookup:ident ],\n                 $def_import_type:ident\n-            ) => {\n-                match ($existing.$field, $def.$field) {\n-                    (None, Some(_)) => {\n+            ) => {{\n+                let existing = $this.$field.entry($lookup.1.clone());\n+                match (existing, $def.$field) {\n+                    (Entry::Vacant(entry), Some(_)) => {\n                         match $def_import_type {\n                             ImportType::Glob => {\n                                 $glob_imports.$field.insert($lookup.clone());\n@@ -186,32 +220,46 @@ impl ItemScope {\n                             }\n                         }\n \n-                        $existing.$field = $def.$field;\n+                        if let Some(fld) = $def.$field {\n+                            entry.insert(fld);\n+                        }\n                         $changed = true;\n                     }\n-                    (Some(_), Some(_))\n+                    (Entry::Occupied(mut entry), Some(_))\n                         if $glob_imports.$field.contains(&$lookup)\n                             && matches!($def_import_type, ImportType::Named) =>\n                     {\n                         mark::hit!(import_shadowed);\n                         $glob_imports.$field.remove(&$lookup);\n-                        $existing.$field = $def.$field;\n+                        if let Some(fld) = $def.$field {\n+                            entry.insert(fld);\n+                        }\n                         $changed = true;\n                     }\n                     _ => {}\n                 }\n-            };\n+            }};\n         }\n \n-        check_changed!(changed, (existing / def).types, glob_imports[lookup], def_import_type);\n-        check_changed!(changed, (existing / def).values, glob_imports[lookup], def_import_type);\n-        check_changed!(changed, (existing / def).macros, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).types, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).values, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).macros, glob_imports[lookup], def_import_type);\n+\n+        if def.is_none() {\n+            if self.unresolved.insert(lookup.1) {\n+                changed = true;\n+            }\n+        }\n \n         changed\n     }\n \n-    pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Name, PerNs)> + 'a {\n-        self.visible.iter().map(|(name, res)| (name.clone(), *res))\n+    pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Option<Name>, PerNs)> + 'a {\n+        self.entries().map(|(name, res)| (Some(name.clone()), res)).chain(\n+            self.unnamed_trait_imports\n+                .iter()\n+                .map(|(tr, vis)| (None, PerNs::types(ModuleDefId::TraitId(*tr), *vis))),\n+        )\n     }\n \n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {"}, {"sha": "a67e75dac069000341344ae64240b792e2ab202f", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -13,7 +13,7 @@ use std::{\n     sync::Arc,\n };\n \n-use ast::{AstNode, AttrsOwner, NameOwner, StructKind, TypeAscriptionOwner};\n+use ast::{AstNode, AttrsOwner, NameOwner, StructKind};\n use either::Either;\n use hir_expand::{\n     ast_id_map::FileAstId,\n@@ -70,7 +70,7 @@ impl GenericParamsId {\n pub struct ItemTree {\n     top_level: SmallVec<[ModItem; 1]>,\n     attrs: FxHashMap<AttrOwner, Attrs>,\n-    inner_items: FxHashMap<FileAstId<ast::ModuleItem>, SmallVec<[ModItem; 1]>>,\n+    inner_items: FxHashMap<FileAstId<ast::Item>, SmallVec<[ModItem; 1]>>,\n \n     data: Option<Box<ItemTreeData>>,\n }\n@@ -187,7 +187,7 @@ impl ItemTree {\n     ///\n     /// Most AST items are lowered to a single `ModItem`, but some (eg. `use` items) may be lowered\n     /// to multiple items in the `ItemTree`.\n-    pub fn inner_items(&self, ast: FileAstId<ast::ModuleItem>) -> &[ModItem] {\n+    pub fn inner_items(&self, ast: FileAstId<ast::Item>) -> &[ModItem] {\n         &self.inner_items[&ast]\n     }\n \n@@ -310,7 +310,7 @@ from_attrs!(ModItem(ModItem), Variant(Idx<Variant>), Field(Idx<Field>));\n \n /// Trait implemented by all item nodes in the item tree.\n pub trait ItemTreeNode: Clone {\n-    type Source: AstNode + Into<ast::ModuleItem>;\n+    type Source: AstNode + Into<ast::Item>;\n \n     fn ast_id(&self) -> FileAstId<Self::Source>;\n \n@@ -411,17 +411,17 @@ macro_rules! mod_items {\n }\n \n mod_items! {\n-    Import in imports -> ast::UseItem,\n-    ExternCrate in extern_crates -> ast::ExternCrateItem,\n-    Function in functions -> ast::FnDef,\n-    Struct in structs -> ast::StructDef,\n-    Union in unions -> ast::UnionDef,\n-    Enum in enums -> ast::EnumDef,\n-    Const in consts -> ast::ConstDef,\n-    Static in statics -> ast::StaticDef,\n-    Trait in traits -> ast::TraitDef,\n-    Impl in impls -> ast::ImplDef,\n-    TypeAlias in type_aliases -> ast::TypeAliasDef,\n+    Import in imports -> ast::Use,\n+    ExternCrate in extern_crates -> ast::ExternCrate,\n+    Function in functions -> ast::Fn,\n+    Struct in structs -> ast::Struct,\n+    Union in unions -> ast::Union,\n+    Enum in enums -> ast::Enum,\n+    Const in consts -> ast::Const,\n+    Static in statics -> ast::Static,\n+    Trait in traits -> ast::Trait,\n+    Impl in impls -> ast::Impl,\n+    TypeAlias in type_aliases -> ast::TypeAlias,\n     Mod in mods -> ast::Module,\n     MacroCall in macro_calls -> ast::MacroCall,\n }\n@@ -482,7 +482,7 @@ pub struct Import {\n     pub is_prelude: bool,\n     /// AST ID of the `use` or `extern crate` item this import was derived from. Note that many\n     /// `Import`s can map to the same `use` item.\n-    pub ast_id: FileAstId<ast::UseItem>,\n+    pub ast_id: FileAstId<ast::Use>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -492,7 +492,7 @@ pub struct ExternCrate {\n     pub visibility: RawVisibilityId,\n     /// Whether this is a `#[macro_use] extern crate ...`.\n     pub is_macro_use: bool,\n-    pub ast_id: FileAstId<ast::ExternCrateItem>,\n+    pub ast_id: FileAstId<ast::ExternCrate>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -503,8 +503,9 @@ pub struct Function {\n     pub has_self_param: bool,\n     pub is_unsafe: bool,\n     pub params: Box<[TypeRef]>,\n+    pub is_varargs: bool,\n     pub ret_type: TypeRef,\n-    pub ast_id: FileAstId<ast::FnDef>,\n+    pub ast_id: FileAstId<ast::Fn>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -513,7 +514,7 @@ pub struct Struct {\n     pub visibility: RawVisibilityId,\n     pub generic_params: GenericParamsId,\n     pub fields: Fields,\n-    pub ast_id: FileAstId<ast::StructDef>,\n+    pub ast_id: FileAstId<ast::Struct>,\n     pub kind: StructDefKind,\n }\n \n@@ -533,7 +534,7 @@ pub struct Union {\n     pub visibility: RawVisibilityId,\n     pub generic_params: GenericParamsId,\n     pub fields: Fields,\n-    pub ast_id: FileAstId<ast::UnionDef>,\n+    pub ast_id: FileAstId<ast::Union>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -542,7 +543,7 @@ pub struct Enum {\n     pub visibility: RawVisibilityId,\n     pub generic_params: GenericParamsId,\n     pub variants: IdRange<Variant>,\n-    pub ast_id: FileAstId<ast::EnumDef>,\n+    pub ast_id: FileAstId<ast::Enum>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -551,7 +552,7 @@ pub struct Const {\n     pub name: Option<Name>,\n     pub visibility: RawVisibilityId,\n     pub type_ref: TypeRef,\n-    pub ast_id: FileAstId<ast::ConstDef>,\n+    pub ast_id: FileAstId<ast::Const>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -560,7 +561,7 @@ pub struct Static {\n     pub visibility: RawVisibilityId,\n     pub mutable: bool,\n     pub type_ref: TypeRef,\n-    pub ast_id: FileAstId<ast::StaticDef>,\n+    pub ast_id: FileAstId<ast::Static>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -570,7 +571,7 @@ pub struct Trait {\n     pub generic_params: GenericParamsId,\n     pub auto: bool,\n     pub items: Box<[AssocItem]>,\n-    pub ast_id: FileAstId<ast::TraitDef>,\n+    pub ast_id: FileAstId<ast::Trait>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -580,7 +581,7 @@ pub struct Impl {\n     pub target_type: TypeRef,\n     pub is_negative: bool,\n     pub items: Box<[AssocItem]>,\n-    pub ast_id: FileAstId<ast::ImplDef>,\n+    pub ast_id: FileAstId<ast::Impl>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -591,7 +592,7 @@ pub struct TypeAlias {\n     pub bounds: Box<[TypeBound]>,\n     pub generic_params: GenericParamsId,\n     pub type_ref: Option<TypeRef>,\n-    pub ast_id: FileAstId<ast::TypeAliasDef>,\n+    pub ast_id: FileAstId<ast::TypeAlias>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]"}, {"sha": "feb31579e5e8cabd206c392d41c25af7f85a1f67", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 97, "deletions": 90, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,18 +1,21 @@\n //! AST -> `ItemTree` lowering code.\n \n-use super::*;\n-use crate::{\n-    attr::Attrs,\n-    generics::{GenericParams, TypeParamData, TypeParamProvenance},\n-};\n+use std::{collections::hash_map::Entry, mem, sync::Arc};\n+\n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n use ra_arena::map::ArenaMap;\n use ra_syntax::{\n     ast::{self, ModuleItemOwner},\n     SyntaxNode,\n };\n use smallvec::SmallVec;\n-use std::{collections::hash_map::Entry, mem, sync::Arc};\n+\n+use crate::{\n+    attr::Attrs,\n+    generics::{GenericParams, TypeParamData, TypeParamProvenance},\n+};\n+\n+use super::*;\n \n fn id<N: ItemTreeNode>(index: Idx<N>) -> FileItemTreeId<N> {\n     FileItemTreeId { index, _p: PhantomData }\n@@ -70,19 +73,19 @@ impl Ctx {\n         self.tree.data_mut()\n     }\n \n-    fn lower_mod_item(&mut self, item: &ast::ModuleItem, inner: bool) -> Option<ModItems> {\n+    fn lower_mod_item(&mut self, item: &ast::Item, inner: bool) -> Option<ModItems> {\n         assert!(inner || self.inner_items.is_empty());\n \n         // Collect inner items for 1-to-1-lowered items.\n         match item {\n-            ast::ModuleItem::StructDef(_)\n-            | ast::ModuleItem::UnionDef(_)\n-            | ast::ModuleItem::EnumDef(_)\n-            | ast::ModuleItem::FnDef(_)\n-            | ast::ModuleItem::TypeAliasDef(_)\n-            | ast::ModuleItem::ConstDef(_)\n-            | ast::ModuleItem::StaticDef(_)\n-            | ast::ModuleItem::MacroCall(_) => {\n+            ast::Item::Struct(_)\n+            | ast::Item::Union(_)\n+            | ast::Item::Enum(_)\n+            | ast::Item::Fn(_)\n+            | ast::Item::TypeAlias(_)\n+            | ast::Item::Const(_)\n+            | ast::Item::Static(_)\n+            | ast::Item::MacroCall(_) => {\n                 // Skip this if we're already collecting inner items. We'll descend into all nodes\n                 // already.\n                 if !inner {\n@@ -92,34 +95,30 @@ impl Ctx {\n \n             // These are handled in their respective `lower_X` method (since we can't just blindly\n             // walk them).\n-            ast::ModuleItem::TraitDef(_)\n-            | ast::ModuleItem::ImplDef(_)\n-            | ast::ModuleItem::ExternBlock(_) => {}\n+            ast::Item::Trait(_) | ast::Item::Impl(_) | ast::Item::ExternBlock(_) => {}\n \n             // These don't have inner items.\n-            ast::ModuleItem::Module(_)\n-            | ast::ModuleItem::ExternCrateItem(_)\n-            | ast::ModuleItem::UseItem(_) => {}\n+            ast::Item::Module(_) | ast::Item::ExternCrate(_) | ast::Item::Use(_) => {}\n         };\n \n         let attrs = Attrs::new(item, &self.hygiene);\n         let items = match item {\n-            ast::ModuleItem::StructDef(ast) => self.lower_struct(ast).map(Into::into),\n-            ast::ModuleItem::UnionDef(ast) => self.lower_union(ast).map(Into::into),\n-            ast::ModuleItem::EnumDef(ast) => self.lower_enum(ast).map(Into::into),\n-            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n-            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n-            ast::ModuleItem::StaticDef(ast) => self.lower_static(ast).map(Into::into),\n-            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n-            ast::ModuleItem::Module(ast) => self.lower_module(ast).map(Into::into),\n-            ast::ModuleItem::TraitDef(ast) => self.lower_trait(ast).map(Into::into),\n-            ast::ModuleItem::ImplDef(ast) => self.lower_impl(ast).map(Into::into),\n-            ast::ModuleItem::UseItem(ast) => Some(ModItems(\n+            ast::Item::Struct(ast) => self.lower_struct(ast).map(Into::into),\n+            ast::Item::Union(ast) => self.lower_union(ast).map(Into::into),\n+            ast::Item::Enum(ast) => self.lower_enum(ast).map(Into::into),\n+            ast::Item::Fn(ast) => self.lower_function(ast).map(Into::into),\n+            ast::Item::TypeAlias(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::Item::Static(ast) => self.lower_static(ast).map(Into::into),\n+            ast::Item::Const(ast) => Some(self.lower_const(ast).into()),\n+            ast::Item::Module(ast) => self.lower_module(ast).map(Into::into),\n+            ast::Item::Trait(ast) => self.lower_trait(ast).map(Into::into),\n+            ast::Item::Impl(ast) => self.lower_impl(ast).map(Into::into),\n+            ast::Item::Use(ast) => Some(ModItems(\n                 self.lower_use(ast).into_iter().map(Into::into).collect::<SmallVec<_>>(),\n             )),\n-            ast::ModuleItem::ExternCrateItem(ast) => self.lower_extern_crate(ast).map(Into::into),\n-            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n-            ast::ModuleItem::ExternBlock(ast) => {\n+            ast::Item::ExternCrate(ast) => self.lower_extern_crate(ast).map(Into::into),\n+            ast::Item::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+            ast::Item::ExternBlock(ast) => {\n                 Some(ModItems(self.lower_extern_block(ast).into_iter().collect::<SmallVec<_>>()))\n             }\n         };\n@@ -147,27 +146,26 @@ impl Ctx {\n     fn collect_inner_items(&mut self, container: &SyntaxNode) {\n         let forced_vis = self.forced_visibility.take();\n         let mut inner_items = mem::take(&mut self.tree.inner_items);\n-        inner_items.extend(\n-            container.descendants().skip(1).filter_map(ast::ModuleItem::cast).filter_map(|item| {\n+        inner_items.extend(container.descendants().skip(1).filter_map(ast::Item::cast).filter_map(\n+            |item| {\n                 let ast_id = self.source_ast_id_map.ast_id(&item);\n                 Some((ast_id, self.lower_mod_item(&item, true)?.0))\n-            }),\n-        );\n+            },\n+        ));\n         self.tree.inner_items = inner_items;\n         self.forced_visibility = forced_vis;\n     }\n \n-    fn lower_assoc_item(&mut self, item: &ast::ModuleItem) -> Option<AssocItem> {\n+    fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n         match item {\n-            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n-            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n-            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n-            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n-            _ => None,\n+            ast::AssocItem::Fn(ast) => self.lower_function(ast).map(Into::into),\n+            ast::AssocItem::TypeAlias(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::AssocItem::Const(ast) => Some(self.lower_const(ast).into()),\n+            ast::AssocItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n         }\n     }\n \n-    fn lower_struct(&mut self, strukt: &ast::StructDef) -> Option<FileItemTreeId<Struct>> {\n+    fn lower_struct(&mut self, strukt: &ast::Struct) -> Option<FileItemTreeId<Struct>> {\n         let visibility = self.lower_visibility(strukt);\n         let name = strukt.name()?.as_name();\n         let generic_params = self.lower_generic_params(GenericsOwner::Struct, strukt);\n@@ -196,7 +194,7 @@ impl Ctx {\n         }\n     }\n \n-    fn lower_record_fields(&mut self, fields: &ast::RecordFieldDefList) -> IdRange<Field> {\n+    fn lower_record_fields(&mut self, fields: &ast::RecordFieldList) -> IdRange<Field> {\n         let start = self.next_field_idx();\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n@@ -208,50 +206,47 @@ impl Ctx {\n         IdRange::new(start..end)\n     }\n \n-    fn lower_record_field(&mut self, field: &ast::RecordFieldDef) -> Option<Field> {\n+    fn lower_record_field(&mut self, field: &ast::RecordField) -> Option<Field> {\n         let name = field.name()?.as_name();\n         let visibility = self.lower_visibility(field);\n-        let type_ref = self.lower_type_ref(&field.ascribed_type()?);\n+        let type_ref = self.lower_type_ref_opt(field.ty());\n         let res = Field { name, type_ref, visibility };\n         Some(res)\n     }\n \n-    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldDefList) -> IdRange<Field> {\n+    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldList) -> IdRange<Field> {\n         let start = self.next_field_idx();\n         for (i, field) in fields.fields().enumerate() {\n-            if let Some(data) = self.lower_tuple_field(i, &field) {\n-                let idx = self.data().fields.alloc(data);\n-                self.add_attrs(idx.into(), Attrs::new(&field, &self.hygiene));\n-            }\n+            let data = self.lower_tuple_field(i, &field);\n+            let idx = self.data().fields.alloc(data);\n+            self.add_attrs(idx.into(), Attrs::new(&field, &self.hygiene));\n         }\n         let end = self.next_field_idx();\n         IdRange::new(start..end)\n     }\n \n-    fn lower_tuple_field(&mut self, idx: usize, field: &ast::TupleFieldDef) -> Option<Field> {\n+    fn lower_tuple_field(&mut self, idx: usize, field: &ast::TupleField) -> Field {\n         let name = Name::new_tuple_field(idx);\n         let visibility = self.lower_visibility(field);\n-        let type_ref = self.lower_type_ref(&field.type_ref()?);\n+        let type_ref = self.lower_type_ref_opt(field.ty());\n         let res = Field { name, type_ref, visibility };\n-        Some(res)\n+        res\n     }\n \n-    fn lower_union(&mut self, union: &ast::UnionDef) -> Option<FileItemTreeId<Union>> {\n+    fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n         let visibility = self.lower_visibility(union);\n         let name = union.name()?.as_name();\n         let generic_params = self.lower_generic_params(GenericsOwner::Union, union);\n-        let fields = match union.record_field_def_list() {\n-            Some(record_field_def_list) => {\n-                self.lower_fields(&StructKind::Record(record_field_def_list))\n-            }\n+        let fields = match union.record_field_list() {\n+            Some(record_field_list) => self.lower_fields(&StructKind::Record(record_field_list)),\n             None => Fields::Record(IdRange::new(self.next_field_idx()..self.next_field_idx())),\n         };\n         let ast_id = self.source_ast_id_map.ast_id(union);\n         let res = Union { name, visibility, generic_params, fields, ast_id };\n         Some(id(self.data().unions.alloc(res)))\n     }\n \n-    fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<FileItemTreeId<Enum>> {\n+    fn lower_enum(&mut self, enum_: &ast::Enum) -> Option<FileItemTreeId<Enum>> {\n         let visibility = self.lower_visibility(enum_);\n         let name = enum_.name()?.as_name();\n         let generic_params = self.lower_generic_params(GenericsOwner::Enum, enum_);\n@@ -264,7 +259,7 @@ impl Ctx {\n         Some(id(self.data().enums.alloc(res)))\n     }\n \n-    fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> IdRange<Variant> {\n+    fn lower_variants(&mut self, variants: &ast::VariantList) -> IdRange<Variant> {\n         let start = self.next_variant_idx();\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n@@ -276,22 +271,22 @@ impl Ctx {\n         IdRange::new(start..end)\n     }\n \n-    fn lower_variant(&mut self, variant: &ast::EnumVariant) -> Option<Variant> {\n+    fn lower_variant(&mut self, variant: &ast::Variant) -> Option<Variant> {\n         let name = variant.name()?.as_name();\n         let fields = self.lower_fields(&variant.kind());\n         let res = Variant { name, fields };\n         Some(res)\n     }\n \n-    fn lower_function(&mut self, func: &ast::FnDef) -> Option<FileItemTreeId<Function>> {\n+    fn lower_function(&mut self, func: &ast::Fn) -> Option<FileItemTreeId<Function>> {\n         let visibility = self.lower_visibility(func);\n         let name = func.name()?.as_name();\n \n         let mut params = Vec::new();\n         let mut has_self_param = false;\n         if let Some(param_list) = func.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n-                let self_type = match self_param.ascribed_type() {\n+                let self_type = match self_param.ty() {\n                     Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n                     None => {\n                         let self_type = TypeRef::Path(name![Self].into());\n@@ -310,11 +305,19 @@ impl Ctx {\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ascribed_type());\n+                let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n                 params.push(type_ref);\n             }\n         }\n-        let ret_type = match func.ret_type().and_then(|rt| rt.type_ref()) {\n+\n+        let mut is_varargs = false;\n+        if let Some(params) = func.param_list() {\n+            if let Some(last) = params.params().last() {\n+                is_varargs = last.dotdotdot_token().is_some();\n+            }\n+        }\n+\n+        let ret_type = match func.ret_type().and_then(|rt| rt.ty()) {\n             Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n             _ => TypeRef::unit(),\n         };\n@@ -335,6 +338,7 @@ impl Ctx {\n             has_self_param,\n             is_unsafe: func.unsafe_token().is_some(),\n             params: params.into_boxed_slice(),\n+            is_varargs,\n             ret_type,\n             ast_id,\n         };\n@@ -345,10 +349,10 @@ impl Ctx {\n \n     fn lower_type_alias(\n         &mut self,\n-        type_alias: &ast::TypeAliasDef,\n+        type_alias: &ast::TypeAlias,\n     ) -> Option<FileItemTreeId<TypeAlias>> {\n         let name = type_alias.name()?.as_name();\n-        let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n+        let type_ref = type_alias.ty().map(|it| self.lower_type_ref(&it));\n         let visibility = self.lower_visibility(type_alias);\n         let bounds = self.lower_type_bounds(type_alias);\n         let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n@@ -364,19 +368,19 @@ impl Ctx {\n         Some(id(self.data().type_aliases.alloc(res)))\n     }\n \n-    fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<FileItemTreeId<Static>> {\n+    fn lower_static(&mut self, static_: &ast::Static) -> Option<FileItemTreeId<Static>> {\n         let name = static_.name()?.as_name();\n-        let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n+        let type_ref = self.lower_type_ref_opt(static_.ty());\n         let visibility = self.lower_visibility(static_);\n         let mutable = static_.mut_token().is_some();\n         let ast_id = self.source_ast_id_map.ast_id(static_);\n         let res = Static { name, visibility, mutable, type_ref, ast_id };\n         Some(id(self.data().statics.alloc(res)))\n     }\n \n-    fn lower_const(&mut self, konst: &ast::ConstDef) -> FileItemTreeId<Const> {\n+    fn lower_const(&mut self, konst: &ast::Const) -> FileItemTreeId<Const> {\n         let name = konst.name().map(|it| it.as_name());\n-        let type_ref = self.lower_type_ref_opt(konst.ascribed_type());\n+        let type_ref = self.lower_type_ref_opt(konst.ty());\n         let visibility = self.lower_visibility(konst);\n         let ast_id = self.source_ast_id_map.ast_id(konst);\n         let res = Const { name, visibility, type_ref, ast_id };\n@@ -409,15 +413,15 @@ impl Ctx {\n         Some(id(self.data().mods.alloc(res)))\n     }\n \n-    fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<FileItemTreeId<Trait>> {\n+    fn lower_trait(&mut self, trait_def: &ast::Trait) -> Option<FileItemTreeId<Trait>> {\n         let name = trait_def.name()?.as_name();\n         let visibility = self.lower_visibility(trait_def);\n         let generic_params =\n             self.lower_generic_params_and_inner_items(GenericsOwner::Trait(trait_def), trait_def);\n         let auto = trait_def.auto_token().is_some();\n-        let items = trait_def.item_list().map(|list| {\n+        let items = trait_def.assoc_item_list().map(|list| {\n             self.with_inherited_visibility(visibility, |this| {\n-                list.items()\n+                list.assoc_items()\n                     .filter_map(|item| {\n                         let attrs = Attrs::new(&item, &this.hygiene);\n                         this.collect_inner_items(item.syntax());\n@@ -441,7 +445,7 @@ impl Ctx {\n         Some(id(self.data().traits.alloc(res)))\n     }\n \n-    fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<FileItemTreeId<Impl>> {\n+    fn lower_impl(&mut self, impl_def: &ast::Impl) -> Option<FileItemTreeId<Impl>> {\n         let generic_params =\n             self.lower_generic_params_and_inner_items(GenericsOwner::Impl, impl_def);\n         let target_trait = impl_def.target_trait().map(|tr| self.lower_type_ref(&tr));\n@@ -450,8 +454,9 @@ impl Ctx {\n \n         // We cannot use `assoc_items()` here as that does not include macro calls.\n         let items = impl_def\n-            .item_list()?\n-            .items()\n+            .assoc_item_list()\n+            .into_iter()\n+            .flat_map(|it| it.assoc_items())\n             .filter_map(|item| {\n                 self.collect_inner_items(item.syntax());\n                 let assoc = self.lower_assoc_item(&item)?;\n@@ -465,7 +470,7 @@ impl Ctx {\n         Some(id(self.data().impls.alloc(res)))\n     }\n \n-    fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<FileItemTreeId<Import>> {\n+    fn lower_use(&mut self, use_item: &ast::Use) -> Vec<FileItemTreeId<Import>> {\n         // FIXME: cfg_attr\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n         let visibility = self.lower_visibility(use_item);\n@@ -494,10 +499,10 @@ impl Ctx {\n \n     fn lower_extern_crate(\n         &mut self,\n-        extern_crate: &ast::ExternCrateItem,\n+        extern_crate: &ast::ExternCrate,\n     ) -> Option<FileItemTreeId<ExternCrate>> {\n         let path = ModPath::from_name_ref(&extern_crate.name_ref()?);\n-        let alias = extern_crate.alias().map(|a| {\n+        let alias = extern_crate.rename().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n         let visibility = self.lower_visibility(extern_crate);\n@@ -543,14 +548,16 @@ impl Ctx {\n                     self.collect_inner_items(item.syntax());\n                     let attrs = Attrs::new(&item, &self.hygiene);\n                     let id: ModItem = match item {\n-                        ast::ExternItem::FnDef(ast) => {\n+                        ast::ExternItem::Fn(ast) => {\n                             let func = self.lower_function(&ast)?;\n+                            self.data().functions[func.index].is_unsafe = true;\n                             func.into()\n                         }\n-                        ast::ExternItem::StaticDef(ast) => {\n+                        ast::ExternItem::Static(ast) => {\n                             let statik = self.lower_static(&ast)?;\n                             statik.into()\n                         }\n+                        ast::ExternItem::MacroCall(_) => return None,\n                     };\n                     self.add_attrs(id.into(), attrs);\n                     Some(id)\n@@ -563,10 +570,10 @@ impl Ctx {\n     fn lower_generic_params_and_inner_items(\n         &mut self,\n         owner: GenericsOwner<'_>,\n-        node: &impl ast::TypeParamsOwner,\n+        node: &impl ast::GenericParamsOwner,\n     ) -> GenericParamsId {\n         // Generics are part of item headers and may contain inner items we need to collect.\n-        if let Some(params) = node.type_param_list() {\n+        if let Some(params) = node.generic_param_list() {\n             self.collect_inner_items(params.syntax());\n         }\n         if let Some(clause) = node.where_clause() {\n@@ -579,7 +586,7 @@ impl Ctx {\n     fn lower_generic_params(\n         &mut self,\n         owner: GenericsOwner<'_>,\n-        node: &impl ast::TypeParamsOwner,\n+        node: &impl ast::GenericParamsOwner,\n     ) -> GenericParamsId {\n         let mut sm = &mut ArenaMap::default();\n         let mut generics = GenericParams::default();\n@@ -692,7 +699,7 @@ enum GenericsOwner<'a> {\n     Enum,\n     Union,\n     /// The `TraitDef` is needed to fill the source map for the implicit `Self` parameter.\n-    Trait(&'a ast::TraitDef),\n+    Trait(&'a ast::Trait),\n     TypeAlias,\n     Impl,\n }"}, {"sha": "a81497fa8a9e56f9c760a7a0e6b07d43856bdf3b", "filename": "crates/ra_hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 111, "deletions": 107, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,13 +1,15 @@\n-use super::{ItemTree, ModItem, ModKind};\n-use crate::{db::DefDatabase, test_db::TestDB};\n+use expect::{expect, Expect};\n use hir_expand::{db::AstDatabase, HirFileId, InFile};\n-use insta::assert_snapshot;\n use ra_db::fixture::WithFixture;\n use ra_syntax::{ast, AstNode};\n use rustc_hash::FxHashSet;\n use std::sync::Arc;\n use stdx::format_to;\n \n+use crate::{db::DefDatabase, test_db::TestDB};\n+\n+use super::{ItemTree, ModItem, ModKind};\n+\n fn test_inner_items(ra_fixture: &str) {\n     let (db, file_id) = TestDB::with_single_file(ra_fixture);\n     let file_id = HirFileId::from(file_id);\n@@ -19,7 +21,7 @@ fn test_inner_items(ra_fixture: &str) {\n     let mut outer_items = FxHashSet::default();\n     let mut worklist = tree.top_level_items().to_vec();\n     while let Some(item) = worklist.pop() {\n-        let node: ast::ModuleItem = match item {\n+        let node: ast::Item = match item {\n             ModItem::Import(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n             ModItem::ExternCrate(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n             ModItem::Function(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n@@ -51,7 +53,7 @@ fn test_inner_items(ra_fixture: &str) {\n \n     // Now descend the root node and check that all `ast::ModuleItem`s are either recorded above, or\n     // registered as inner items.\n-    for item in root.descendants().skip(1).filter_map(ast::ModuleItem::cast) {\n+    for item in root.descendants().skip(1).filter_map(ast::Item::cast) {\n         if outer_items.contains(&item) {\n             continue;\n         }\n@@ -162,9 +164,15 @@ fn fmt_mod_item(out: &mut String, tree: &ItemTree, item: ModItem) {\n     }\n }\n \n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = print_item_tree(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n #[test]\n fn smoke() {\n-    assert_snapshot!(print_item_tree(r\"\n+    check(\n+        r\"\n         #![attr]\n \n         #[attr_on_use]\n@@ -214,42 +222,44 @@ fn smoke() {\n             #[union_fld]\n             fld: u16,\n         }\n-    \"), @r###\"\n-inner attrs: Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr\"))] }, input: None }]) }\n-\n-top-level items:\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UseItem>(0) }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UseItem>(0) }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"ext_crate\"))] }, input: None }]) }]\n-ExternCrate { path: ModPath { kind: Plain, segments: [Name(Text(\"krate\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ExternCrateItem>(1) }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_trait\"))] }, input: None }]) }]\n-Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TraitDef>(2) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_ty\"))] }, input: None }]) }]\n-> TypeAlias { name: Name(Text(\"AssocTy\")), visibility: RawVisibilityId(\"pub(self)\"), bounds: [Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Tr\"))] }, generic_args: [Some(GenericArgs { args: [Type(Tuple([]))], has_self_type: false, bindings: [] })] })], generic_params: GenericParamsId(4294967295), type_ref: None, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TypeAliasDef>(8) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_const\"))] }, input: None }]) }]\n-> Const { name: Some(Name(Text(\"CONST\"))), visibility: RawVisibilityId(\"pub(self)\"), type_ref: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"u8\"))] }, generic_args: [None] }), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ConstDef>(9) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_method\"))] }, input: None }]) }]\n-> Function { name: Name(Text(\"method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Shared)], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(10) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_dfl_method\"))] }, input: None }]) }]\n-> Function { name: Name(Text(\"dfl_method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Mut)], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(11) }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct0\"))] }, input: None }]) }]\n-Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(3), kind: Unit }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct1\"))] }, input: None }]) }]\n-Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(IdRange::<ra_hir_def::item_tree::Field>(0..1)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(4), kind: Tuple }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct2\"))] }, input: None }]) }]\n-Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(1..2)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(5), kind: Record }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"en\"))] }, input: None }]) }]\n-Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: IdRange::<ra_hir_def::item_tree::Variant>(0..1), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::EnumDef>(6) }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"un\"))] }, input: None }]) }]\n-Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(3..4)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UnionDef>(7) }\n-    \"###);\n+    \",\n+        expect![[r##\"\n+            inner attrs: Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr\"))] }, input: None }]) }\n+\n+            top-level items:\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n+            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Use>(0) }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n+            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Use>(0) }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"ext_crate\"))] }, input: None }]) }]\n+            ExternCrate { path: ModPath { kind: Plain, segments: [Name(Text(\"krate\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ExternCrate>(1) }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_trait\"))] }, input: None }]) }]\n+            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Trait>(2) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_ty\"))] }, input: None }]) }]\n+            > TypeAlias { name: Name(Text(\"AssocTy\")), visibility: RawVisibilityId(\"pub(self)\"), bounds: [Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Tr\"))] }, generic_args: [Some(GenericArgs { args: [Type(Tuple([]))], has_self_type: false, bindings: [] })] })], generic_params: GenericParamsId(4294967295), type_ref: None, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TypeAlias>(8) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_const\"))] }, input: None }]) }]\n+            > Const { name: Some(Name(Text(\"CONST\"))), visibility: RawVisibilityId(\"pub(self)\"), type_ref: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"u8\"))] }, generic_args: [None] }), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Const>(9) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_method\"))] }, input: None }]) }]\n+            > Function { name: Name(Text(\"method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Shared)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(10) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_dfl_method\"))] }, input: None }]) }]\n+            > Function { name: Name(Text(\"dfl_method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Mut)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(11) }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct0\"))] }, input: None }]) }]\n+            Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Struct>(3), kind: Unit }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct1\"))] }, input: None }]) }]\n+            Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(IdRange::<ra_hir_def::item_tree::Field>(0..1)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Struct>(4), kind: Tuple }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct2\"))] }, input: None }]) }]\n+            Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(1..2)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Struct>(5), kind: Record }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"en\"))] }, input: None }]) }]\n+            Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: IdRange::<ra_hir_def::item_tree::Variant>(0..1), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Enum>(6) }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"un\"))] }, input: None }]) }]\n+            Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(3..4)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Union>(7) }\n+        \"##]],\n+    );\n }\n \n #[test]\n fn simple_inner_items() {\n-    let tree = print_item_tree(\n+    check(\n         r\"\n         impl<T:A> D for Response<T> {\n             fn foo() {\n@@ -260,26 +270,25 @@ fn simple_inner_items() {\n             }\n         }\n     \",\n-    );\n+        expect![[r#\"\n+            inner attrs: Attrs { entries: None }\n \n-    assert_snapshot!(tree, @r###\"\n-inner attrs: Attrs { entries: None }\n+            top-level items:\n+            Impl { generic_params: GenericParamsId(0), target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Impl>(0) }\n+            > Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n \n-top-level items:\n-Impl { generic_params: GenericParamsId(0), target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n-> Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n+            inner items:\n \n-inner items:\n+            for AST FileAstId::<ra_syntax::ast::generated::nodes::Item>(2):\n+            Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n \n-for AST FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(2):\n-Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n-\n-    \"###);\n+        \"#]],\n+    );\n }\n \n #[test]\n fn extern_attrs() {\n-    let tree = print_item_tree(\n+    check(\n         r#\"\n         #[block_attr]\n         extern \"C\" {\n@@ -289,22 +298,21 @@ fn extern_attrs() {\n             fn b() {}\n         }\n     \"#,\n+        expect![[r##\"\n+            inner attrs: Attrs { entries: None }\n+\n+            top-level items:\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n+            Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n+            Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n+        \"##]],\n     );\n-\n-    assert_snapshot!(tree, @r###\"\n-inner attrs: Attrs { entries: None }\n-\n-top-level items:\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n-    \"###);\n }\n \n #[test]\n fn trait_attrs() {\n-    let tree = print_item_tree(\n+    check(\n         r#\"\n         #[trait_attr]\n         trait Tr {\n@@ -314,24 +322,23 @@ fn trait_attrs() {\n             fn b() {}\n         }\n     \"#,\n+        expect![[r##\"\n+            inner attrs: Attrs { entries: None }\n+\n+            top-level items:\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"trait_attr\"))] }, input: None }]) }]\n+            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Trait>(0) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n+            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n+            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n+        \"##]],\n     );\n-\n-    assert_snapshot!(tree, @r###\"\n-inner attrs: Attrs { entries: None }\n-\n-top-level items:\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"trait_attr\"))] }, input: None }]) }]\n-Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TraitDef>(0) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-> Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-> Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n-    \"###);\n }\n \n #[test]\n fn impl_attrs() {\n-    let tree = print_item_tree(\n+    check(\n         r#\"\n         #[impl_attr]\n         impl Ty {\n@@ -341,19 +348,18 @@ fn impl_attrs() {\n             fn b() {}\n         }\n     \"#,\n+        expect![[r##\"\n+            inner attrs: Attrs { entries: None }\n+\n+            top-level items:\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"impl_attr\"))] }, input: None }]) }]\n+            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Ty\"))] }, generic_args: [None] }), is_negative: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Impl>(0) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n+            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n+            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n+        \"##]],\n     );\n-\n-    assert_snapshot!(tree, @r###\"\n-inner attrs: Attrs { entries: None }\n-\n-top-level items:\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"impl_attr\"))] }, input: None }]) }]\n-Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Ty\"))] }, generic_args: [None] }), is_negative: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-> Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n-> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-> Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n-    \"###);\n }\n \n #[test]\n@@ -391,45 +397,43 @@ fn cursed_inner_items() {\n \n #[test]\n fn inner_item_attrs() {\n-    let tree = print_item_tree(\n+    check(\n         r\"\n         fn foo() {\n             #[on_inner]\n             fn inner() {}\n         }\n     \",\n-    );\n-\n-    assert_snapshot!(tree, @r###\"\n-inner attrs: Attrs { entries: None }\n+        expect![[r##\"\n+            inner attrs: Attrs { entries: None }\n \n-top-level items:\n-Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(0) }\n+            top-level items:\n+            Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(0) }\n \n-inner items:\n+            inner items:\n \n-for AST FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(1):\n-#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_inner\"))] }, input: None }]) }]\n-Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n+            for AST FileAstId::<ra_syntax::ast::generated::nodes::Item>(1):\n+            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_inner\"))] }, input: None }]) }]\n+            Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n \n-    \"###);\n+        \"##]],\n+    );\n }\n \n #[test]\n fn assoc_item_macros() {\n-    let tree = print_item_tree(\n+    check(\n         r\"\n         impl S {\n             items!();\n         }\n     \",\n-    );\n-\n-    assert_snapshot!(tree, @r###\"\n-inner attrs: Attrs { entries: None }\n+        expect![[r#\"\n+            inner attrs: Attrs { entries: None }\n \n-top-level items:\n-Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n-> MacroCall { name: None, path: ModPath { kind: Plain, segments: [Name(Text(\"items\"))] }, is_export: false, is_local_inner: false, is_builtin: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::MacroCall>(1) }\n-    \"###);\n+            top-level items:\n+            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Impl>(0) }\n+            > MacroCall { name: None, path: ModPath { kind: Plain, segments: [Name(Text(\"items\"))] }, is_export: false, is_local_inner: false, is_builtin: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::MacroCall>(1) }\n+        \"#]],\n+    );\n }"}, {"sha": "441bdbead88542a2a424b31e9e5a2df6039d4604", "filename": "crates/ra_hir_def/src/keys.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -14,19 +14,19 @@ use crate::{\n \n pub type Key<K, V> = crate::dyn_map::Key<InFile<K>, V, AstPtrPolicy<K, V>>;\n \n-pub const FUNCTION: Key<ast::FnDef, FunctionId> = Key::new();\n-pub const CONST: Key<ast::ConstDef, ConstId> = Key::new();\n-pub const STATIC: Key<ast::StaticDef, StaticId> = Key::new();\n-pub const TYPE_ALIAS: Key<ast::TypeAliasDef, TypeAliasId> = Key::new();\n-pub const IMPL: Key<ast::ImplDef, ImplId> = Key::new();\n-pub const TRAIT: Key<ast::TraitDef, TraitId> = Key::new();\n-pub const STRUCT: Key<ast::StructDef, StructId> = Key::new();\n-pub const UNION: Key<ast::UnionDef, UnionId> = Key::new();\n-pub const ENUM: Key<ast::EnumDef, EnumId> = Key::new();\n-\n-pub const ENUM_VARIANT: Key<ast::EnumVariant, EnumVariantId> = Key::new();\n-pub const TUPLE_FIELD: Key<ast::TupleFieldDef, FieldId> = Key::new();\n-pub const RECORD_FIELD: Key<ast::RecordFieldDef, FieldId> = Key::new();\n+pub const FUNCTION: Key<ast::Fn, FunctionId> = Key::new();\n+pub const CONST: Key<ast::Const, ConstId> = Key::new();\n+pub const STATIC: Key<ast::Static, StaticId> = Key::new();\n+pub const TYPE_ALIAS: Key<ast::TypeAlias, TypeAliasId> = Key::new();\n+pub const IMPL: Key<ast::Impl, ImplId> = Key::new();\n+pub const TRAIT: Key<ast::Trait, TraitId> = Key::new();\n+pub const STRUCT: Key<ast::Struct, StructId> = Key::new();\n+pub const UNION: Key<ast::Union, UnionId> = Key::new();\n+pub const ENUM: Key<ast::Enum, EnumId> = Key::new();\n+\n+pub const VARIANT: Key<ast::Variant, EnumVariantId> = Key::new();\n+pub const TUPLE_FIELD: Key<ast::TupleField, FieldId> = Key::new();\n+pub const RECORD_FIELD: Key<ast::RecordField, FieldId> = Key::new();\n pub const TYPE_PARAM: Key<ast::TypeParam, TypeParamId> = Key::new();\n \n pub const MACRO: Key<ast::MacroCall, MacroDefId> = Key::new();"}, {"sha": "237b1038afcfe52447b1cc347330f24c3c085916", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -65,6 +65,7 @@ use item_tree::{\n     Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, ModItem, Static, Struct, Trait,\n     TypeAlias, Union,\n };\n+use stdx::impl_from;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n@@ -158,17 +159,17 @@ pub struct FunctionId(salsa::InternId);\n type FunctionLoc = AssocItemLoc<Function>;\n impl_intern!(FunctionId, FunctionLoc, intern_function, lookup_intern_function);\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct StructId(salsa::InternId);\n type StructLoc = ItemLoc<Struct>;\n impl_intern!(StructId, StructLoc, intern_struct, lookup_intern_struct);\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct UnionId(salsa::InternId);\n pub type UnionLoc = ItemLoc<Union>;\n impl_intern!(UnionId, UnionLoc, intern_union, lookup_intern_union);\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct EnumId(salsa::InternId);\n pub type EnumLoc = ItemLoc<Enum>;\n impl_intern!(EnumId, EnumLoc, intern_enum, lookup_intern_enum);\n@@ -223,25 +224,6 @@ pub struct TypeParamId {\n \n pub type LocalTypeParamId = Idx<generics::TypeParamData>;\n \n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-            $($(\n-                impl From<$sv> for $e {\n-                    fn from(it: $sv) -> $e {\n-                        $e::$v($v::$sv(it))\n-                    }\n-                }\n-            )*)?\n-        )*\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum ContainerId {\n     ModuleId(ModuleId),\n@@ -254,16 +236,16 @@ pub enum AssocContainerId {\n     ImplId(ImplId),\n     TraitId(TraitId),\n }\n-impl_froms!(AssocContainerId: ContainerId);\n+impl_from!(ContainerId for AssocContainerId);\n \n /// A Data Type\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub enum AdtId {\n     StructId(StructId),\n     UnionId(UnionId),\n     EnumId(EnumId),\n }\n-impl_froms!(AdtId: StructId, UnionId, EnumId);\n+impl_from!(StructId, UnionId, EnumId for AdtId);\n \n /// The defs which can be visible in the module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -279,8 +261,8 @@ pub enum ModuleDefId {\n     TypeAliasId(TypeAliasId),\n     BuiltinType(BuiltinType),\n }\n-impl_froms!(\n-    ModuleDefId: ModuleId,\n+impl_from!(\n+    ModuleId,\n     FunctionId,\n     AdtId(StructId, EnumId, UnionId),\n     EnumVariantId,\n@@ -289,6 +271,7 @@ impl_froms!(\n     TraitId,\n     TypeAliasId,\n     BuiltinType\n+    for ModuleDefId\n );\n \n /// The defs which have a body.\n@@ -299,7 +282,7 @@ pub enum DefWithBodyId {\n     ConstId(ConstId),\n }\n \n-impl_froms!(DefWithBodyId: FunctionId, ConstId, StaticId);\n+impl_from!(FunctionId, ConstId, StaticId for DefWithBodyId);\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItemId {\n@@ -311,7 +294,7 @@ pub enum AssocItemId {\n // sure that you can only turn actual assoc items into AssocItemIds. This would\n // require not implementing From, and instead having some checked way of\n // casting them, and somehow making the constructors private, which would be annoying.\n-impl_froms!(AssocItemId: FunctionId, ConstId, TypeAliasId);\n+impl_from!(FunctionId, ConstId, TypeAliasId for AssocItemId);\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum GenericDefId {\n@@ -326,14 +309,15 @@ pub enum GenericDefId {\n     // consts can have type parameters from their parents (i.e. associated consts of traits)\n     ConstId(ConstId),\n }\n-impl_froms!(\n-    GenericDefId: FunctionId,\n+impl_from!(\n+    FunctionId,\n     AdtId(StructId, EnumId, UnionId),\n     TraitId,\n     TypeAliasId,\n     ImplId,\n     EnumVariantId,\n     ConstId\n+    for GenericDefId\n );\n \n impl From<AssocItemId> for GenericDefId {\n@@ -361,8 +345,8 @@ pub enum AttrDefId {\n     ImplId(ImplId),\n }\n \n-impl_froms!(\n-    AttrDefId: ModuleId,\n+impl_from!(\n+    ModuleId,\n     FieldId,\n     AdtId(StructId, EnumId, UnionId),\n     EnumVariantId,\n@@ -373,6 +357,7 @@ impl_froms!(\n     TypeAliasId,\n     MacroDefId,\n     ImplId\n+    for AttrDefId\n );\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -381,7 +366,7 @@ pub enum VariantId {\n     StructId(StructId),\n     UnionId(UnionId),\n }\n-impl_froms!(VariantId: EnumVariantId, StructId, UnionId);\n+impl_from!(EnumVariantId, StructId, UnionId for VariantId);\n \n trait Intern {\n     type ID;\n@@ -536,7 +521,7 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n     }\n }\n \n-impl AsMacroCall for AstIdWithPath<ast::ModuleItem> {\n+impl AsMacroCall for AstIdWithPath<ast::Item> {\n     fn as_call_id(\n         &self,\n         db: &dyn db::DefDatabase,"}, {"sha": "3d9b55a73c4dfabf1de8e528bda90596c567c2ab", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -229,37 +229,37 @@ impl CrateDefMap {\n     // even), as this should be a great debugging aid.\n     pub fn dump(&self) -> String {\n         let mut buf = String::new();\n-        go(&mut buf, self, \"\\ncrate\", self.root);\n-        return buf.trim().to_string();\n+        go(&mut buf, self, \"crate\", self.root);\n+        return buf;\n \n         fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: LocalModuleId) {\n-            *buf += path;\n-            *buf += \"\\n\";\n+            format_to!(buf, \"{}\\n\", path);\n \n             let mut entries: Vec<_> = map.modules[module].scope.resolutions().collect();\n             entries.sort_by_key(|(name, _)| name.clone());\n \n             for (name, def) in entries {\n-                format_to!(buf, \"{}:\", name);\n+                format_to!(buf, \"{}:\", name.map_or(\"_\".to_string(), |name| name.to_string()));\n \n                 if def.types.is_some() {\n-                    *buf += \" t\";\n+                    buf.push_str(\" t\");\n                 }\n                 if def.values.is_some() {\n-                    *buf += \" v\";\n+                    buf.push_str(\" v\");\n                 }\n                 if def.macros.is_some() {\n-                    *buf += \" m\";\n+                    buf.push_str(\" m\");\n                 }\n                 if def.is_none() {\n-                    *buf += \" _\";\n+                    buf.push_str(\" _\");\n                 }\n \n-                *buf += \"\\n\";\n+                buf.push_str(\"\\n\");\n             }\n \n             for (name, child) in map.modules[module].children.iter() {\n-                let path = &format!(\"{}::{}\", path, name);\n+                let path = format!(\"{}::{}\", path, name);\n+                buf.push('\\n');\n                 go(buf, map, &path, *child);\n             }\n         }"}, {"sha": "28b7a20c552910b7f35e5217b5a09a4742861606", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 74, "deletions": 31, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -36,6 +36,10 @@ use crate::{\n     TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n+const GLOB_RECURSION_LIMIT: usize = 100;\n+const EXPANSION_DEPTH_LIMIT: usize = 128;\n+const FIXED_POINT_LIMIT: usize = 8192;\n+\n pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n     let crate_graph = db.crate_graph();\n \n@@ -166,7 +170,7 @@ struct MacroDirective {\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct DeriveDirective {\n     module_id: LocalModuleId,\n-    ast_id: AstIdWithPath<ast::ModuleItem>,\n+    ast_id: AstIdWithPath<ast::Item>,\n }\n \n struct DefData<'a> {\n@@ -217,7 +221,7 @@ impl DefCollector<'_> {\n                 ReachedFixedPoint::Yes => break,\n                 ReachedFixedPoint::No => i += 1,\n             }\n-            if i == 10000 {\n+            if i == FIXED_POINT_LIMIT {\n                 log::error!(\"name resolution is stuck\");\n                 break;\n             }\n@@ -306,7 +310,7 @@ impl DefCollector<'_> {\n         if export {\n             self.update(\n                 self.def_map.root,\n-                &[(name, PerNs::macros(macro_, Visibility::Public))],\n+                &[(Some(name), PerNs::macros(macro_, Visibility::Public))],\n                 Visibility::Public,\n                 ImportType::Named,\n             );\n@@ -332,7 +336,7 @@ impl DefCollector<'_> {\n     fn define_proc_macro(&mut self, name: Name, macro_: MacroDefId) {\n         self.update(\n             self.def_map.root,\n-            &[(name, PerNs::macros(macro_, Visibility::Public))],\n+            &[(Some(name), PerNs::macros(macro_, Visibility::Public))],\n             Visibility::Public,\n             ImportType::Named,\n         );\n@@ -530,7 +534,7 @@ impl DefCollector<'_> {\n                             let name = variant_data.name.clone();\n                             let variant = EnumVariantId { parent: e, local_id };\n                             let res = PerNs::both(variant.into(), variant.into(), vis);\n-                            (name, res)\n+                            (Some(name), res)\n                         })\n                         .collect::<Vec<_>>();\n                     self.update(module_id, &resolutions, vis, ImportType::Glob);\n@@ -546,15 +550,15 @@ impl DefCollector<'_> {\n             match import.path.segments.last() {\n                 Some(last_segment) => {\n                     let name = match &import.alias {\n-                        Some(ImportAlias::Alias(name)) => name.clone(),\n-                        Some(ImportAlias::Underscore) => last_segment.clone(), // FIXME rust-analyzer#2736\n-                        None => last_segment.clone(),\n+                        Some(ImportAlias::Alias(name)) => Some(name.clone()),\n+                        Some(ImportAlias::Underscore) => None,\n+                        None => Some(last_segment.clone()),\n                     };\n                     log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n                     // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                     if import.is_extern_crate && module_id == self.def_map.root {\n-                        if let Some(def) = def.take_types() {\n+                        if let (Some(def), Some(name)) = (def.take_types(), name.as_ref()) {\n                             self.def_map.extern_prelude.insert(name.clone(), def);\n                         }\n                     }\n@@ -569,36 +573,73 @@ impl DefCollector<'_> {\n     fn update(\n         &mut self,\n         module_id: LocalModuleId,\n-        resolutions: &[(Name, PerNs)],\n+        resolutions: &[(Option<Name>, PerNs)],\n         vis: Visibility,\n         import_type: ImportType,\n     ) {\n+        self.db.check_canceled();\n         self.update_recursive(module_id, resolutions, vis, import_type, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n-        resolutions: &[(Name, PerNs)],\n+        resolutions: &[(Option<Name>, PerNs)],\n         // All resolutions are imported with this visibility; the visibilies in\n         // the `PerNs` values are ignored and overwritten\n         vis: Visibility,\n         import_type: ImportType,\n         depth: usize,\n     ) {\n-        if depth > 100 {\n+        if depth > GLOB_RECURSION_LIMIT {\n             // prevent stack overflows (but this shouldn't be possible)\n             panic!(\"infinite recursion in glob imports!\");\n         }\n-        let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n+\n         for (name, res) in resolutions {\n-            changed |= scope.push_res_with_import(\n-                &mut self.from_glob_import,\n-                (module_id, name.clone()),\n-                res.with_visibility(vis),\n-                import_type,\n-            );\n+            match name {\n+                Some(name) => {\n+                    let scope = &mut self.def_map.modules[module_id].scope;\n+                    changed |= scope.push_res_with_import(\n+                        &mut self.from_glob_import,\n+                        (module_id, name.clone()),\n+                        res.with_visibility(vis),\n+                        import_type,\n+                    );\n+                }\n+                None => {\n+                    let tr = match res.take_types() {\n+                        Some(ModuleDefId::TraitId(tr)) => tr,\n+                        Some(other) => {\n+                            log::debug!(\"non-trait `_` import of {:?}\", other);\n+                            continue;\n+                        }\n+                        None => continue,\n+                    };\n+                    let old_vis = self.def_map.modules[module_id].scope.unnamed_trait_vis(tr);\n+                    let should_update = match old_vis {\n+                        None => true,\n+                        Some(old_vis) => {\n+                            let max_vis = old_vis.max(vis, &self.def_map).unwrap_or_else(|| {\n+                                panic!(\"`Tr as _` imports with unrelated visibilities {:?} and {:?} (trait {:?})\", old_vis, vis, tr);\n+                            });\n+\n+                            if max_vis == old_vis {\n+                                false\n+                            } else {\n+                                mark::hit!(upgrade_underscore_visibility);\n+                                true\n+                            }\n+                        }\n+                    };\n+\n+                    if should_update {\n+                        changed = true;\n+                        self.def_map.modules[module_id].scope.push_unnamed_trait(tr, vis);\n+                    }\n+                }\n+            }\n         }\n \n         if !changed {\n@@ -609,14 +650,15 @@ impl DefCollector<'_> {\n             .get(&module_id)\n             .into_iter()\n             .flat_map(|v| v.iter())\n+            .filter(|(glob_importing_module, _)| {\n+                // we know all resolutions have the same visibility (`vis`), so we\n+                // just need to check that once\n+                vis.is_visible_from_def_map(&self.def_map, *glob_importing_module)\n+            })\n             .cloned()\n             .collect::<Vec<_>>();\n+\n         for (glob_importing_module, glob_import_vis) in glob_imports {\n-            // we know all resolutions have the same visibility (`vis`), so we\n-            // just need to check that once\n-            if !vis.is_visible_from_def_map(&self.def_map, glob_importing_module) {\n-                continue;\n-            }\n             self.update_recursive(\n                 glob_importing_module,\n                 resolutions,\n@@ -677,10 +719,6 @@ impl DefCollector<'_> {\n         self.unexpanded_attribute_macros = attribute_macros;\n \n         for (module_id, macro_call_id, depth) in resolved {\n-            if depth > 1024 {\n-                log::debug!(\"Max macro expansion depth reached\");\n-                continue;\n-            }\n             self.collect_macro_expansion(module_id, macro_call_id, depth);\n         }\n \n@@ -717,6 +755,11 @@ impl DefCollector<'_> {\n         macro_call_id: MacroCallId,\n         depth: usize,\n     ) {\n+        if depth > EXPANSION_DEPTH_LIMIT {\n+            mark::hit!(macro_expansion_overflow);\n+            log::warn!(\"macro expansion is too deep\");\n+            return;\n+        }\n         let file_id: HirFileId = macro_call_id.as_file();\n         let item_tree = self.db.item_tree(file_id);\n         let mod_dir = self.mod_dirs[&module_id].clone();\n@@ -943,7 +986,7 @@ impl ModCollector<'_, '_> {\n                         .unwrap_or(Visibility::Public);\n                     self.def_collector.update(\n                         self.module_id,\n-                        &[(name.clone(), PerNs::from_def(id, vis, has_constructor))],\n+                        &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n                         vis,\n                         ImportType::Named,\n                     )\n@@ -1050,14 +1093,14 @@ impl ModCollector<'_, '_> {\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n         self.def_collector.update(\n             self.module_id,\n-            &[(name, PerNs::from_def(def, vis, false))],\n+            &[(Some(name), PerNs::from_def(def, vis, false))],\n             vis,\n             ImportType::Named,\n         );\n         res\n     }\n \n-    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::ModuleItem>) {\n+    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::Item>) {\n         for derive_subtree in attrs.by_key(\"derive\").tt_values() {\n             // for #[derive(Copy, Clone)], `derive_subtree` is the `(Copy, Clone)` subtree\n             for tt in &derive_subtree.token_trees {"}, {"sha": "9539616325a46d9ba7508a76bb14bb3351b653d7", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 87, "deletions": 29, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,41 +1,46 @@\n //! This module resolves `mod foo;` declaration to file.\n use hir_expand::name::Name;\n-use ra_db::{FileId, RelativePathBuf};\n+use ra_db::FileId;\n use ra_syntax::SmolStr;\n \n use crate::{db::DefDatabase, HirFileId};\n \n #[derive(Clone, Debug)]\n pub(super) struct ModDir {\n-    /// `.` for `mod.rs`, `lib.rs`\n-    /// `./foo` for `foo.rs`\n-    /// `./foo/bar` for `mod bar { mod x; }` nested in `foo.rs`\n-    path: RelativePathBuf,\n+    /// `` for `mod.rs`, `lib.rs`\n+    /// `foo/` for `foo.rs`\n+    /// `foo/bar/` for `mod bar { mod x; }` nested in `foo.rs`\n+    /// Invariant: path.is_empty() || path.ends_with('/')\n+    dir_path: DirPath,\n     /// inside `./foo.rs`, mods with `#[path]` should *not* be relative to `./foo/`\n     root_non_dir_owner: bool,\n }\n \n impl ModDir {\n     pub(super) fn root() -> ModDir {\n-        ModDir { path: RelativePathBuf::default(), root_non_dir_owner: false }\n+        ModDir { dir_path: DirPath::empty(), root_non_dir_owner: false }\n     }\n \n     pub(super) fn descend_into_definition(\n         &self,\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n     ) -> ModDir {\n-        let mut path = self.path.clone();\n-        match attr_to_path(attr_path) {\n-            None => path.push(&name.to_string()),\n+        let path = match attr_path.map(|it| it.as_str()) {\n+            None => {\n+                let mut path = self.dir_path.clone();\n+                path.push(&name.to_string());\n+                path\n+            }\n             Some(attr_path) => {\n-                if self.root_non_dir_owner {\n-                    assert!(path.pop());\n+                let mut path = self.dir_path.join_attr(attr_path, self.root_non_dir_owner);\n+                if !(path.is_empty() || path.ends_with('/')) {\n+                    path.push('/')\n                 }\n-                path.push(attr_path);\n+                DirPath::new(path)\n             }\n-        }\n-        ModDir { path, root_non_dir_owner: false }\n+        };\n+        ModDir { dir_path: path, root_non_dir_owner: false }\n     }\n \n     pub(super) fn resolve_declaration(\n@@ -48,34 +53,87 @@ impl ModDir {\n         let file_id = file_id.original_file(db.upcast());\n \n         let mut candidate_files = Vec::new();\n-        match attr_to_path(attr_path) {\n+        match attr_path {\n             Some(attr_path) => {\n-                let base =\n-                    if self.root_non_dir_owner { self.path.parent().unwrap() } else { &self.path };\n-                candidate_files.push(base.join(attr_path).to_string())\n+                candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None => {\n-                candidate_files.push(self.path.join(&format!(\"{}.rs\", name)).to_string());\n-                candidate_files.push(self.path.join(&format!(\"{}/mod.rs\", name)).to_string());\n+                candidate_files.push(format!(\"{}{}.rs\", self.dir_path.0, name));\n+                candidate_files.push(format!(\"{}{}/mod.rs\", self.dir_path.0, name));\n             }\n         };\n \n         for candidate in candidate_files.iter() {\n             if let Some(file_id) = db.resolve_path(file_id, candidate.as_str()) {\n-                let mut root_non_dir_owner = false;\n-                let mut mod_path = RelativePathBuf::new();\n                 let is_mod_rs = candidate.ends_with(\"mod.rs\");\n-                if !(is_mod_rs || attr_path.is_some()) {\n-                    root_non_dir_owner = true;\n-                    mod_path.push(&name.to_string());\n-                }\n-                return Ok((file_id, is_mod_rs, ModDir { path: mod_path, root_non_dir_owner }));\n+\n+                let (dir_path, root_non_dir_owner) = if is_mod_rs || attr_path.is_some() {\n+                    (DirPath::empty(), false)\n+                } else {\n+                    (DirPath::new(format!(\"{}/\", name)), true)\n+                };\n+                return Ok((file_id, is_mod_rs, ModDir { dir_path, root_non_dir_owner }));\n             }\n         }\n         Err(candidate_files.remove(0))\n     }\n }\n \n-fn attr_to_path(attr: Option<&SmolStr>) -> Option<RelativePathBuf> {\n-    attr.and_then(|it| RelativePathBuf::from_path(&it.replace(\"\\\\\", \"/\")).ok())\n+#[derive(Clone, Debug)]\n+struct DirPath(String);\n+\n+impl DirPath {\n+    fn assert_invariant(&self) {\n+        assert!(self.0.is_empty() || self.0.ends_with('/'));\n+    }\n+    fn new(repr: String) -> DirPath {\n+        let res = DirPath(repr);\n+        res.assert_invariant();\n+        res\n+    }\n+    fn empty() -> DirPath {\n+        DirPath::new(String::new())\n+    }\n+    fn push(&mut self, name: &str) {\n+        self.0.push_str(name);\n+        self.0.push('/');\n+        self.assert_invariant();\n+    }\n+    fn parent(&self) -> Option<&str> {\n+        if self.0.is_empty() {\n+            return None;\n+        };\n+        let idx =\n+            self.0[..self.0.len() - '/'.len_utf8()].rfind('/').map_or(0, |it| it + '/'.len_utf8());\n+        Some(&self.0[..idx])\n+    }\n+    /// So this is the case which doesn't really work I think if we try to be\n+    /// 100% platform agnostic:\n+    ///\n+    /// ```\n+    /// mod a {\n+    ///     #[path=\"C://sad/face\"]\n+    ///     mod b { mod c; }\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, we need to join logical dir path to a string path from an\n+    /// attribute. Ideally, we should somehow losslessly communicate the whole\n+    /// construction to `FileLoader`.\n+    fn join_attr(&self, mut attr: &str, relative_to_parent: bool) -> String {\n+        let base = if relative_to_parent { self.parent().unwrap() } else { &self.0 };\n+\n+        if attr.starts_with(\"./\") {\n+            attr = &attr[\"./\".len()..];\n+        }\n+        let tmp;\n+        let attr = if attr.contains('\\\\') {\n+            tmp = attr.replace('\\\\', \"/\");\n+            &tmp\n+        } else {\n+            attr\n+        };\n+        let res = format!(\"{}{}\", base, attr);\n+        res\n+    }\n }"}, {"sha": "dbfa7fccb4777b58e0d9c259c162839f09a39974", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -226,7 +226,15 @@ impl CrateDefMap {\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into(), Visibility::Public)\n+                            match &*enum_data.variants[local_id].variant_data {\n+                                crate::adt::VariantData::Record(_) => {\n+                                    PerNs::types(variant.into(), Visibility::Public)\n+                                }\n+                                crate::adt::VariantData::Tuple(_)\n+                                | crate::adt::VariantData::Unit => {\n+                                    PerNs::both(variant.into(), variant.into(), Visibility::Public)\n+                                }\n+                            }\n                         }\n                         None => {\n                             return ResolvePathResult::with("}, {"sha": "839b1de5787dcc59ff946c160af6be64b13384e3", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 537, "deletions": 435, "changes": 972, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,558 +6,531 @@ mod primitives;\n \n use std::sync::Arc;\n \n-use insta::assert_snapshot;\n+use expect::{expect, Expect};\n use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::mark;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n \n-fn def_map(ra_fixture: &str) -> String {\n-    compute_crate_def_map(ra_fixture).dump()\n-}\n-\n fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n     let db = TestDB::with_files(fixture);\n     let krate = db.crate_graph().iter().next().unwrap();\n     db.crate_def_map(krate)\n }\n \n+fn check(ra_fixture: &str, expect: Expect) {\n+    let db = TestDB::with_files(ra_fixture);\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let actual = db.crate_def_map(krate).dump();\n+    expect.assert_eq(&actual);\n+}\n+\n #[test]\n fn crate_def_map_smoke_test() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod foo;\n-        struct S;\n-        use crate::foo::bar::E;\n-        use self::E::V;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        fn f() {}\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-\n-        union U {\n-            to_be: bool,\n-            not_to_be: u8,\n-        }\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+struct S;\n+use crate::foo::bar::E;\n+use self::E::V;\n \n-        enum E { V }\n+//- /foo/mod.rs\n+pub mod bar;\n+fn f() {}\n \n-        extern {\n-            static EXT: u8;\n-            fn ext();\n-        }\n-        \",\n+//- /foo/bar.rs\n+pub struct Baz;\n+\n+union U { to_be: bool, not_to_be: u8 }\n+enum E { V }\n+\n+extern {\n+    static EXT: u8;\n+    fn ext();\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            E: t\n+            S: t v\n+            V: t v\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+            f: v\n+\n+            crate::foo::bar\n+            Baz: t v\n+            E: t\n+            EXT: v\n+            U: t\n+            ext: v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeE: t\n-        \u22eeS: t v\n-        \u22eeV: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22eef: v\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-        \u22eeE: t\n-        \u22eeEXT: v\n-        \u22eeU: t\n-        \u22eeext: v\n-    \"###)\n }\n \n #[test]\n fn crate_def_map_super_super() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod a {\n-            const A: usize = 0;\n-\n-            mod b {\n-                const B: usize = 0;\n-\n-                mod c {\n-                    use super::super::*;\n-                }\n-            }\n+    check(\n+        r#\"\n+mod a {\n+    const A: usize = 0;\n+    mod b {\n+        const B: usize = 0;\n+        mod c {\n+            use super::super::*;\n         }\n-        \",\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n+\n+            crate::a\n+            A: v\n+            b: t\n+\n+            crate::a::b\n+            B: v\n+            c: t\n+\n+            crate::a::b::c\n+            A: v\n+            b: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eeA: v\n-        \u22eeb: t\n-        \u22ee\n-        \u22eecrate::a::b\n-        \u22eeB: v\n-        \u22eec: t\n-        \u22ee\n-        \u22eecrate::a::b::c\n-        \u22eeA: v\n-        \u22eeb: t\n-    \"###)\n }\n \n #[test]\n fn crate_def_map_fn_mod_same_name() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod m {\n-            pub mod z {}\n-            pub fn z() {}\n-        }\n-        \",\n+    check(\n+        r#\"\n+mod m {\n+    pub mod z {}\n+    pub fn z() {}\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            m: t\n+\n+            crate::m\n+            z: t v\n+\n+            crate::m::z\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eem: t\n-        \u22ee\n-        \u22eecrate::m\n-        \u22eez: t v\n-        \u22ee\n-        \u22eecrate::m::z\n-    \"###)\n }\n \n #[test]\n fn bogus_paths() {\n     mark::check!(bogus_paths);\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        struct S;\n-        use self;\n-\n-        //- /foo/mod.rs\n-        use super;\n-        use crate;\n-\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+struct S;\n+use self;\n+\n+//- /foo/mod.rs\n+use super;\n+use crate;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            S: t v\n+            foo: t\n+\n+            crate::foo\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeS: t v\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-    \"###\n-    )\n }\n \n #[test]\n fn use_as() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::Baz as Foo;\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use crate::foo::Baz as Foo;\n \n-        //- /foo/mod.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    assert_snapshot!(map,\n-        @r###\"\n-   \u22eecrate\n-   \u22eeFoo: t v\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeBaz: t v\n-    \"###\n+//- /foo/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Foo: t v\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn use_trees() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::bar::{Baz, Quux};\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use crate::foo::bar::{Baz, Quux};\n \n-        //- /foo/mod.rs\n-        pub mod bar;\n+//- /foo/mod.rs\n+pub mod bar;\n \n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        pub enum Quux {};\n-        \",\n+//- /foo/bar.rs\n+pub struct Baz;\n+pub enum Quux {};\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            Quux: t\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+            Quux: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eeQuux: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-        \u22eeQuux: t\n-    \"###);\n }\n \n #[test]\n fn re_exports() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use self::foo::Baz;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use self::foo::Baz;\n \n-        pub use self::bar::Baz;\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::Baz;\n \n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn std_prelude() {\n     mark::check!(std_prelude);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:test_crate\n-        use Foo::*;\n-\n-        //- /lib.rs crate:test_crate\n-        mod prelude;\n-        #[prelude_import]\n-        use prelude::*;\n-\n-        //- /prelude.rs\n-        pub enum Foo { Bar, Baz };\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use Foo::*;\n+\n+//- /lib.rs crate:test_crate\n+mod prelude;\n+#[prelude_import]\n+use prelude::*;\n+\n+//- /prelude.rs\n+pub enum Foo { Bar, Baz };\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn can_import_enum_variant() {\n     mark::check!(can_import_enum_variant);\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        enum E { V }\n-        use self::E::V;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeE: t\n-        \u22eeV: t v\n-    \"###\n+    check(\n+        r#\"\n+enum E { V }\n+use self::E::V;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            E: t\n+            V: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn edition_2015_imports() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:other_crate edition:2015\n-        mod foo;\n-        mod bar;\n-\n-        //- /bar.rs\n-        struct Bar;\n-\n-        //- /foo.rs\n-        use bar::Bar;\n-        use other_crate::FromLib;\n-\n-        //- /lib.rs crate:other_crate edition:2018\n-        struct FromLib;\n-        \",\n-    );\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:other_crate edition:2015\n+mod foo;\n+mod bar;\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eebar: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::bar\n-        \u22eeBar: t v\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBar: t v\n-        \u22eeFromLib: t v\n-    \"###);\n+//- /bar.rs\n+struct Bar;\n+\n+//- /foo.rs\n+use bar::Bar;\n+use other_crate::FromLib;\n+\n+//- /lib.rs crate:other_crate edition:2018\n+struct FromLib;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            bar: t\n+            foo: t\n+\n+            crate::bar\n+            Bar: t v\n+\n+            crate::foo\n+            Bar: t v\n+            FromLib: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn item_map_using_self() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use crate::foo::bar::Baz::{self};\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use crate::foo::bar::Baz::{self};\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn item_map_across_crates() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::Baz;\n-\n-        //- /lib.rs crate:test_crate\n-        pub struct Baz;\n-        \",\n-    );\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::Baz;\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###);\n+//- /lib.rs crate:test_crate\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn extern_crate_rename() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:alloc\n-        extern crate alloc as alloc_crate;\n-\n-        mod alloc;\n-        mod sync;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:alloc\n+extern crate alloc as alloc_crate;\n+mod alloc;\n+mod sync;\n \n-        //- /sync.rs\n-        use alloc_crate::Arc;\n+//- /sync.rs\n+use alloc_crate::Arc;\n \n-        //- /lib.rs crate:alloc\n-        struct Arc;\n-        \",\n+//- /lib.rs crate:alloc\n+struct Arc;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            alloc_crate: t\n+            sync: t\n+\n+            crate::sync\n+            Arc: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eealloc_crate: t\n-   \u22eesync: t\n-   \u22ee\n-   \u22eecrate::sync\n-   \u22eeArc: t v\n-    \"###);\n }\n \n #[test]\n fn extern_crate_rename_2015_edition() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:alloc edition:2015\n-        extern crate alloc as alloc_crate;\n-\n-        mod alloc;\n-        mod sync;\n-\n-        //- /sync.rs\n-        use alloc_crate::Arc;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:alloc edition:2015\n+extern crate alloc as alloc_crate;\n+mod alloc;\n+mod sync;\n \n-        //- /lib.rs crate:alloc\n-        struct Arc;\n-        \",\n-    );\n+//- /sync.rs\n+use alloc_crate::Arc;\n \n-    assert_snapshot!(map,\n-        @r###\"\n-   \u22eecrate\n-   \u22eealloc_crate: t\n-   \u22eesync: t\n-   \u22ee\n-   \u22eecrate::sync\n-   \u22eeArc: t v\n-    \"###\n+//- /lib.rs crate:alloc\n+struct Arc;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            alloc_crate: t\n+            sync: t\n+\n+            crate::sync\n+            Arc: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn reexport_across_crates() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::Baz;\n-\n-        //- /lib.rs crate:test_crate\n-        pub use foo::Baz;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::Baz;\n \n-        mod foo;\n+//- /lib.rs crate:test_crate\n+pub use foo::Baz;\n+mod foo;\n \n-        //- /foo.rs\n-        pub struct Baz;\n-        \",\n+//- /foo.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn values_dont_shadow_extern_crates() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        fn foo() {}\n-        use foo::Bar;\n-\n-        //- /foo/lib.rs crate:foo\n-        pub struct Bar;\n-        \",\n-    );\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+fn foo() {}\n+use foo::Bar;\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eefoo: v\n-    \"###);\n+//- /foo/lib.rs crate:foo\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            foo: v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn std_prelude_takes_precedence_above_core_prelude() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:core,std\n-        use {Foo, Bar};\n-\n-        //- /std.rs crate:std deps:core\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            pub struct Foo;\n-            pub use core::prelude::Bar;\n-        }\n+//- /main.rs crate:main deps:core,std\n+use {Foo, Bar};\n+\n+//- /std.rs crate:std deps:core\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    pub struct Foo;\n+    pub use core::prelude::Bar;\n+}\n \n-        //- /core.rs crate:core\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            pub struct Bar;\n-        }\n-        \"#,\n+//- /core.rs crate:core\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    pub struct Bar;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Foo: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeFoo: t v\n-    \"###);\n }\n \n #[test]\n fn cfg_not_test() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:std\n-        use {Foo, Bar, Baz};\n-\n-        //- /lib.rs crate:std\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            #[cfg(test)]\n-            pub struct Foo;\n-            #[cfg(not(test))]\n-            pub struct Bar;\n-            #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n-            pub struct Baz;\n-        }\n-        \"#,\n+//- /main.rs crate:main deps:std\n+use {Foo, Bar, Baz};\n+\n+//- /lib.rs crate:std\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    #[cfg(test)]\n+    pub struct Foo;\n+    #[cfg(not(test))]\n+    pub struct Bar;\n+    #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n+    pub struct Baz;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: _\n+            Foo: _\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: _\n-        \u22eeFoo: _\n-    \"###);\n }\n \n #[test]\n fn cfg_test() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:std\n-        use {Foo, Bar, Baz};\n-\n-        //- /lib.rs crate:std cfg:test,feature=foo,feature=bar,opt=42\n-        #[prelude_import]\n-        pub use self::prelude::*;\n-        mod prelude {\n-            #[cfg(test)]\n-            pub struct Foo;\n-            #[cfg(not(test))]\n-            pub struct Bar;\n-            #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n-            pub struct Baz;\n-        }\n-        \"#,\n+//- /main.rs crate:main deps:std\n+use {Foo, Bar, Baz};\n+\n+//- /lib.rs crate:std cfg:test,feature=foo,feature=bar,opt=42\n+#[prelude_import]\n+pub use self::prelude::*;\n+mod prelude {\n+    #[cfg(test)]\n+    pub struct Foo;\n+    #[cfg(not(test))]\n+    pub struct Bar;\n+    #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n+    pub struct Baz;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: _\n+            Baz: t v\n+            Foo: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: _\n-        \u22eeBaz: t v\n-        \u22eeFoo: t v\n-    \"###);\n }\n \n #[test]\n fn infer_multiple_namespace() {\n-    let map = def_map(\n+    check(\n         r#\"\n //- /main.rs\n mod a {\n@@ -571,18 +544,147 @@ mod b {\n     pub const T: () = ();\n }\n \"#,\n+        expect![[r#\"\n+            crate\n+            T: t v\n+            a: t\n+            b: t\n+\n+            crate::b\n+            T: v\n+\n+            crate::a\n+            T: t v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn underscore_import() {\n+    check(\n+        r#\"\n+//- /main.rs\n+use tr::Tr as _;\n+use tr::Tr2 as _;\n+\n+mod tr {\n+    pub trait Tr {}\n+    pub trait Tr2 {}\n+}\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            _: t\n+            _: t\n+            tr: t\n+\n+            crate::tr\n+            Tr: t\n+            Tr2: t\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn underscore_reexport() {\n+    check(\n+        r#\"\n+//- /main.rs\n+mod tr {\n+    pub trait PubTr {}\n+    pub trait PrivTr {}\n+}\n+mod reex {\n+    use crate::tr::PrivTr as _;\n+    pub use crate::tr::PubTr as _;\n+}\n+use crate::reex::*;\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            _: t\n+            reex: t\n+            tr: t\n+\n+            crate::tr\n+            PrivTr: t\n+            PubTr: t\n+\n+            crate::reex\n+            _: t\n+            _: t\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn underscore_pub_crate_reexport() {\n+    mark::check!(upgrade_underscore_visibility);\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:lib\n+use lib::*;\n+\n+//- /lib.rs crate:lib\n+use tr::Tr as _;\n+pub use tr::Tr as _;\n+\n+mod tr {\n+    pub trait Tr {}\n+}\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            _: t\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn underscore_nontrait() {\n+    check(\n+        r#\"\n+//- /main.rs\n+mod m {\n+    pub struct Struct;\n+    pub enum Enum {}\n+    pub const CONST: () = ();\n+}\n+use crate::m::{Struct as _, Enum as _, CONST as _};\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            m: t\n+\n+            crate::m\n+            CONST: v\n+            Enum: t\n+            Struct: t v\n+        \"#]],\n     );\n+}\n+\n+#[test]\n+fn underscore_name_conflict() {\n+    check(\n+        r#\"\n+//- /main.rs\n+struct Tr;\n+\n+use tr::Tr as _;\n \n-    assert_snapshot!(map, @r###\"\n-    \u22eecrate\n-    \u22eeT: t v\n-    \u22eea: t\n-    \u22eeb: t\n-    \u22ee\n-    \u22eecrate::b\n-    \u22eeT: v\n-    \u22ee\n-    \u22eecrate::a\n-    \u22eeT: t v\n-\"###);\n+mod tr {\n+    pub trait Tr {}\n+}\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            _: t\n+            Tr: t v\n+            tr: t\n+\n+            crate::tr\n+            Tr: t\n+        \"#]],\n+    );\n }"}, {"sha": "2ae836e3c2892085080b9d53758e430933425fb7", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 274, "deletions": 304, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,367 +2,337 @@ use super::*;\n \n #[test]\n fn glob_1() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::Baz;\n-        pub struct Foo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::foo::bar\n-   \u22eeBaz: t v\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::Baz;\n+pub struct Foo;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_2() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::*;\n-        pub struct Foo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        pub use super::*;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::foo::bar\n-   \u22eeBaz: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::*;\n+pub struct Foo;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+pub use super::*;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_privacy_1() {\n-    let map = def_map(\n+    check(\n         r\"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::*;\n-        struct PrivateStructFoo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        struct PrivateStructBar;\n-        pub use super::*;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eePrivateStructFoo: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-        \u22eePrivateStructBar: t v\n-        \u22eePrivateStructFoo: t v\n-        \u22eebar: t\n-    \"###\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::*;\n+struct PrivateStructFoo;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+struct PrivateStructBar;\n+pub use super::*;\n+\",\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            bar: t\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            PrivateStructFoo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+            PrivateStructBar: t v\n+            PrivateStructFoo: t v\n+            bar: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_privacy_2() {\n-    let map = def_map(\n+    check(\n         r\"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-        use foo::bar::*;\n-\n-        //- /foo/mod.rs\n-        mod bar;\n-        fn Foo() {};\n-        pub struct Foo {};\n-\n-        //- /foo/bar.rs\n-        pub(super) struct PrivateBaz;\n-        struct PrivateBar;\n-        pub(crate) struct PubCrateStruct;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeFoo: t\n-        \u22eePubCrateStruct: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeFoo: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eePrivateBar: t v\n-        \u22eePrivateBaz: t v\n-        \u22eePubCrateStruct: t v\n-    \"###\n+//- /lib.rs\n+mod foo;\n+use foo::*;\n+use foo::bar::*;\n+\n+//- /foo/mod.rs\n+mod bar;\n+fn Foo() {};\n+pub struct Foo {};\n+\n+//- /foo/bar.rs\n+pub(super) struct PrivateBaz;\n+struct PrivateBar;\n+pub(crate) struct PubCrateStruct;\n+\",\n+        expect![[r#\"\n+            crate\n+            Foo: t\n+            PubCrateStruct: t v\n+            foo: t\n+\n+            crate::foo\n+            Foo: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            PrivateBar: t v\n+            PrivateBaz: t v\n+            PubCrateStruct: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_across_crates() {\n     mark::check!(glob_across_crates);\n-    let map = def_map(\n-        r\"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::*;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::*;\n \n-        //- /lib.rs crate:test_crate\n-        pub struct Baz;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###\n+//- /lib.rs crate:test_crate\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_privacy_across_crates() {\n-    let map = def_map(\n-        r\"\n-        //- /main.rs crate:main deps:test_crate\n-        use test_crate::*;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:test_crate\n+use test_crate::*;\n \n-        //- /lib.rs crate:test_crate\n-        pub struct Baz;\n-        struct Foo;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-    \"###\n+//- /lib.rs crate:test_crate\n+pub struct Baz;\n+struct Foo;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_enum() {\n     mark::check!(glob_enum);\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        enum Foo {\n-            Bar, Baz\n-        }\n-        use self::Foo::*;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-        \u22eeFoo: t\n-    \"###\n+    check(\n+        r#\"\n+enum Foo { Bar, Baz }\n+use self::Foo::*;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+            Foo: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_enum_group() {\n     mark::check!(glob_enum_group);\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        enum Foo {\n-            Bar, Baz\n-        }\n-        use self::Foo::{*};\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-        \u22eeFoo: t\n-    \"###\n+    check(\n+        r#\"\n+enum Foo { Bar, Baz }\n+use self::Foo::{*};\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+            Foo: t\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_shadowed_def() {\n     mark::check!(import_shadowed);\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod foo;\n-        mod bar;\n-\n-        use foo::*;\n-        use bar::baz;\n-\n-        use baz::Bar;\n-\n-        //- /foo.rs\n-        pub mod baz {\n-            pub struct Foo;\n-        }\n-\n-        //- /bar.rs\n-        pub mod baz {\n-            pub struct Bar;\n-        }\n-        \"###,\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eebar: t\n-        \u22eebaz: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::bar::baz\n-        \u22eeBar: t v\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::baz\n-        \u22eeFoo: t v\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+mod bar;\n+use foo::*;\n+use bar::baz;\n+use baz::Bar;\n+\n+//- /foo.rs\n+pub mod baz { pub struct Foo; }\n+\n+//- /bar.rs\n+pub mod baz { pub struct Bar; }\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            bar: t\n+            baz: t\n+            foo: t\n+\n+            crate::bar\n+            baz: t\n+\n+            crate::bar::baz\n+            Bar: t v\n+\n+            crate::foo\n+            baz: t\n+\n+            crate::foo::baz\n+            Foo: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_shadowed_def_reversed() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod foo;\n-        mod bar;\n-\n-        use bar::baz;\n-        use foo::*;\n-\n-        use baz::Bar;\n-\n-        //- /foo.rs\n-        pub mod baz {\n-            pub struct Foo;\n-        }\n-\n-        //- /bar.rs\n-        pub mod baz {\n-            pub struct Bar;\n-        }\n-        \"###,\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eebar: t\n-        \u22eebaz: t\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::bar::baz\n-        \u22eeBar: t v\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::baz\n-        \u22eeFoo: t v\n-    \"###\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+mod bar;\n+use bar::baz;\n+use foo::*;\n+use baz::Bar;\n+\n+//- /foo.rs\n+pub mod baz { pub struct Foo; }\n+\n+//- /bar.rs\n+pub mod baz { pub struct Bar; }\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            bar: t\n+            baz: t\n+            foo: t\n+\n+            crate::bar\n+            baz: t\n+\n+            crate::bar::baz\n+            Bar: t v\n+\n+            crate::foo\n+            baz: t\n+\n+            crate::foo::baz\n+            Foo: t v\n+        \"#]],\n     );\n }\n \n #[test]\n fn glob_shadowed_def_dependencies() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod a { pub mod foo { pub struct X; } }\n-        mod b { pub use super::a::foo; }\n-        mod c { pub mod foo { pub struct Y; } }\n-        mod d {\n-            use super::c::foo;\n-            use super::b::*;\n-            use foo::Y;\n-        }\n-        \"###,\n-    );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22eeb: t\n-        \u22eec: t\n-        \u22eed: t\n-        \u22ee\n-        \u22eecrate::d\n-        \u22eeY: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::c\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::c::foo\n-        \u22eeY: t v\n-        \u22ee\n-        \u22eecrate::b\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::a::foo\n-        \u22eeX: t v\n-    \"###\n+    check(\n+        r#\"\n+mod a { pub mod foo { pub struct X; } }\n+mod b { pub use super::a::foo; }\n+mod c { pub mod foo { pub struct Y; } }\n+mod d {\n+    use super::c::foo;\n+    use super::b::*;\n+    use foo::Y;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n+            b: t\n+            c: t\n+            d: t\n+\n+            crate::d\n+            Y: t v\n+            foo: t\n+\n+            crate::c\n+            foo: t\n+\n+            crate::c::foo\n+            Y: t v\n+\n+            crate::b\n+            foo: t\n+\n+            crate::a\n+            foo: t\n+\n+            crate::a::foo\n+            X: t v\n+        \"#]],\n     );\n }"}, {"sha": "e0fb8bdef46d74cd29ced45d0b54ff6b15190656", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 534, "deletions": 527, "changes": 1061, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,661 +2,668 @@ use super::*;\n \n #[test]\n fn macro_rules_are_globally_visible() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        structs!(Foo);\n-        mod nested;\n-\n-        //- /nested.rs\n-        structs!(Bar, Baz);\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+structs!(Foo);\n+mod nested;\n+\n+//- /nested.rs\n+structs!(Bar, Baz);\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Foo: t\n+            nested: t\n+\n+            crate::nested\n+            Bar: t\n+            Baz: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeFoo: t\n-   \u22eenested: t\n-   \u22ee\n-   \u22eecrate::nested\n-   \u22eeBar: t\n-   \u22eeBaz: t\n-    \"###);\n }\n \n #[test]\n fn macro_rules_can_define_modules() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        macro_rules! m {\n-            ($name:ident) => { mod $name;  }\n-        }\n-        m!(n1);\n-\n-        mod m {\n-            m!(n3)\n-        }\n-\n-        //- /n1.rs\n-        m!(n2)\n-        //- /n1/n2.rs\n-        struct X;\n-        //- /m/n3.rs\n-        struct Y;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+macro_rules! m {\n+    ($name:ident) => { mod $name;  }\n+}\n+m!(n1);\n+mod m { m!(n3) }\n+\n+//- /n1.rs\n+m!(n2)\n+//- /n1/n2.rs\n+struct X;\n+//- /m/n3.rs\n+struct Y;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            m: t\n+            n1: t\n+\n+            crate::m\n+            n3: t\n+\n+            crate::m::n3\n+            Y: t v\n+\n+            crate::n1\n+            n2: t\n+\n+            crate::n1::n2\n+            X: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eem: t\n-        \u22een1: t\n-        \u22ee\n-        \u22eecrate::m\n-        \u22een3: t\n-        \u22ee\n-        \u22eecrate::m::n3\n-        \u22eeY: t v\n-        \u22ee\n-        \u22eecrate::n1\n-        \u22een2: t\n-        \u22ee\n-        \u22eecrate::n1::n2\n-        \u22eeX: t v\n-    \"###);\n }\n \n #[test]\n fn macro_rules_from_other_crates_are_visible() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        foo::structs!(Foo, Bar)\n-        mod bar;\n-\n-        //- /bar.rs\n-        use crate::*;\n-\n-        //- /lib.rs crate:foo\n-        #[macro_export]\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+foo::structs!(Foo, Bar)\n+mod bar;\n+\n+//- /bar.rs\n+use crate::*;\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t\n+            Foo: t\n+            bar: t\n+\n+            crate::bar\n+            Bar: t\n+            Foo: t\n+            bar: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-    \"###);\n }\n \n #[test]\n fn macro_rules_export_with_local_inner_macros_are_visible() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        foo::structs!(Foo, Bar)\n-        mod bar;\n-\n-        //- /bar.rs\n-        use crate::*;\n-\n-        //- /lib.rs crate:foo\n-        #[macro_export(local_inner_macros)]\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+foo::structs!(Foo, Bar)\n+mod bar;\n+\n+//- /bar.rs\n+use crate::*;\n+\n+//- /lib.rs crate:foo\n+#[macro_export(local_inner_macros)]\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t\n+            Foo: t\n+            bar: t\n+\n+            crate::bar\n+            Bar: t\n+            Foo: t\n+            bar: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-    \"###);\n }\n \n #[test]\n fn local_inner_macros_makes_local_macros_usable() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        foo::structs!(Foo, Bar);\n-        mod bar;\n-        //- /bar.rs\n-        use crate::*;\n-        //- /lib.rs crate:foo\n-        #[macro_export(local_inner_macros)]\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                inner!($($i),*);\n-            }\n-        }\n-        #[macro_export]\n-        macro_rules! inner {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+foo::structs!(Foo, Bar);\n+mod bar;\n+\n+//- /bar.rs\n+use crate::*;\n+\n+//- /lib.rs crate:foo\n+#[macro_export(local_inner_macros)]\n+macro_rules! structs {\n+    ($($i:ident),*) => {\n+        inner!($($i),*);\n+    }\n+}\n+#[macro_export]\n+macro_rules! inner {\n+    ($($i:ident),*) => {\n+        $(struct $i { field: u32 } )*\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t\n+            Foo: t\n+            bar: t\n+\n+            crate::bar\n+            Bar: t\n+            Foo: t\n+            bar: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBar: t\n-   \u22eeFoo: t\n-   \u22eebar: t\n-    \"###);\n }\n \n #[test]\n fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        macro_rules! baz {\n-            () => {\n-                use foo::bar;\n-            }\n-        }\n-\n-        foo!();\n-        bar!();\n-        baz!();\n-\n-        //- /lib.rs crate:foo\n-        #[macro_export]\n-        macro_rules! foo {\n-            () => {\n-                struct Foo { field: u32 }\n-            }\n-        }\n-        #[macro_export]\n-        macro_rules! bar {\n-            () => {\n-                use foo::foo;\n-            }\n-        }\n-        \",\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+macro_rules! baz {\n+    () => {\n+        use foo::bar;\n+    }\n+}\n+foo!();\n+bar!();\n+baz!();\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        struct Foo { field: u32 }\n+    }\n+}\n+#[macro_export]\n+macro_rules! bar {\n+    () => {\n+        use foo::foo;\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Foo: t\n+            bar: m\n+            foo: m\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeFoo: t\n-   \u22eebar: m\n-   \u22eefoo: m\n-    \"###);\n }\n \n #[test]\n fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n     mark::check!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        structs!(Foo);\n-        structs_priv!(Bar);\n-        structs_not_exported!(MacroNotResolved1);\n-        crate::structs!(MacroNotResolved2);\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+structs!(Foo);\n+structs_priv!(Bar);\n+structs_not_exported!(MacroNotResolved1);\n+crate::structs!(MacroNotResolved2);\n \n-        mod bar;\n+mod bar;\n \n-        #[macro_use]\n-        extern crate foo;\n+#[macro_use]\n+extern crate foo;\n \n-        //- /bar.rs\n-        structs!(Baz);\n-        crate::structs!(MacroNotResolved3);\n+//- /bar.rs\n+structs!(Baz);\n+crate::structs!(MacroNotResolved3);\n \n-        //- /lib.rs crate:foo\n-        #[macro_export]\n-        macro_rules! structs {\n-            ($i:ident) => { struct $i; }\n-        }\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! structs {\n+    ($i:ident) => { struct $i; }\n+}\n \n-        macro_rules! structs_not_exported {\n-            ($i:ident) => { struct $i; }\n-        }\n+macro_rules! structs_not_exported {\n+    ($i:ident) => { struct $i; }\n+}\n \n-        mod priv_mod {\n-            #[macro_export]\n-            macro_rules! structs_priv {\n-                ($i:ident) => { struct $i; }\n-            }\n-        }\n-        \",\n+mod priv_mod {\n+    #[macro_export]\n+    macro_rules! structs_priv {\n+        ($i:ident) => { struct $i; }\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+\n+            crate::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n-   \u22eebar: t\n-   \u22eefoo: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn prelude_is_macro_use() {\n     mark::check!(prelude_is_macro_use);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        structs!(Foo);\n-        structs_priv!(Bar);\n-        structs_outside!(Out);\n-        crate::structs!(MacroNotResolved2);\n-\n-        mod bar;\n-\n-        //- /bar.rs\n-        structs!(Baz);\n-        crate::structs!(MacroNotResolved3);\n-\n-        //- /lib.rs crate:foo\n-        #[prelude_import]\n-        use self::prelude::*;\n-\n-        mod prelude {\n-            #[macro_export]\n-            macro_rules! structs {\n-                ($i:ident) => { struct $i; }\n-            }\n-\n-            mod priv_mod {\n-                #[macro_export]\n-                macro_rules! structs_priv {\n-                    ($i:ident) => { struct $i; }\n-                }\n-            }\n-        }\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+structs!(Foo);\n+structs_priv!(Bar);\n+structs_outside!(Out);\n+crate::structs!(MacroNotResolved2);\n+\n+mod bar;\n \n+//- /bar.rs\n+structs!(Baz);\n+crate::structs!(MacroNotResolved3);\n+\n+//- /lib.rs crate:foo\n+#[prelude_import]\n+use self::prelude::*;\n+\n+mod prelude {\n+    #[macro_export]\n+    macro_rules! structs {\n+        ($i:ident) => { struct $i; }\n+    }\n+\n+    mod priv_mod {\n         #[macro_export]\n-        macro_rules! structs_outside {\n+        macro_rules! structs_priv {\n             ($i:ident) => { struct $i; }\n         }\n-        \",\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! structs_outside {\n+    ($i:ident) => { struct $i; }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Foo: t v\n+            Out: t v\n+            bar: t\n+\n+            crate::bar\n+            Baz: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n-   \u22eeOut: t v\n-   \u22eebar: t\n-   \u22ee\n-   \u22eecrate::bar\n-   \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn prelude_cycle() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        #[prelude_import]\n-        use self::prelude::*;\n+    check(\n+        r#\"\n+#[prelude_import]\n+use self::prelude::*;\n \n-        declare_mod!();\n+declare_mod!();\n \n-        mod prelude {\n-            macro_rules! declare_mod {\n-                () => (mod foo {})\n-            }\n-        }\n-        \",\n+mod prelude {\n+    macro_rules! declare_mod {\n+        () => (mod foo {})\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            prelude: t\n+\n+            crate::prelude\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeprelude: t\n-        \u22ee\n-        \u22eecrate::prelude\n-    \"###);\n }\n \n #[test]\n fn plain_macros_are_legacy_textual_scoped() {\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs\n-        mod m1;\n-        bar!(NotFoundNotMacroUse);\n+//- /main.rs\n+mod m1;\n+bar!(NotFoundNotMacroUse);\n \n-        mod m2 {\n-            foo!(NotFoundBeforeInside2);\n-        }\n+mod m2 { foo!(NotFoundBeforeInside2); }\n \n-        macro_rules! foo {\n-            ($x:ident) => { struct $x; }\n-        }\n-        foo!(Ok);\n-\n-        mod m3;\n-        foo!(OkShadowStop);\n-        bar!(NotFoundMacroUseStop);\n-\n-        #[macro_use]\n-        mod m5 {\n-            #[macro_use]\n-            mod m6 {\n-                macro_rules! foo {\n-                    ($x:ident) => { fn $x() {} }\n-                }\n-            }\n-        }\n-        foo!(ok_double_macro_use_shadow);\n-\n-        baz!(NotFoundBefore);\n-        #[macro_use]\n-        mod m7 {\n-            macro_rules! baz {\n-                ($x:ident) => { struct $x; }\n-            }\n-        }\n-        baz!(OkAfter);\n+macro_rules! foo {\n+    ($x:ident) => { struct $x; }\n+}\n+foo!(Ok);\n \n-        //- /m1.rs\n-        foo!(NotFoundBeforeInside1);\n-        macro_rules! bar {\n-            ($x:ident) => { struct $x; }\n-        }\n+mod m3;\n+foo!(OkShadowStop);\n+bar!(NotFoundMacroUseStop);\n \n-        //- /m3/mod.rs\n-        foo!(OkAfterInside);\n+#[macro_use]\n+mod m5 {\n+    #[macro_use]\n+    mod m6 {\n         macro_rules! foo {\n             ($x:ident) => { fn $x() {} }\n         }\n-        foo!(ok_shadow);\n+    }\n+}\n+foo!(ok_double_macro_use_shadow);\n+\n+baz!(NotFoundBefore);\n+#[macro_use]\n+mod m7 {\n+    macro_rules! baz {\n+        ($x:ident) => { struct $x; }\n+    }\n+}\n+baz!(OkAfter);\n \n-        #[macro_use]\n-        mod m4;\n-        bar!(OkMacroUse);\n+//- /m1.rs\n+foo!(NotFoundBeforeInside1);\n+macro_rules! bar {\n+    ($x:ident) => { struct $x; }\n+}\n \n-        //- /m3/m4.rs\n-        foo!(ok_shadow_deep);\n-        macro_rules! bar {\n-            ($x:ident) => { struct $x; }\n-        }\n-        \"#,\n+//- /m3/mod.rs\n+foo!(OkAfterInside);\n+macro_rules! foo {\n+    ($x:ident) => { fn $x() {} }\n+}\n+foo!(ok_shadow);\n+\n+#[macro_use]\n+mod m4;\n+bar!(OkMacroUse);\n+\n+//- /m3/m4.rs\n+foo!(ok_shadow_deep);\n+macro_rules! bar {\n+    ($x:ident) => { struct $x; }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            OkAfter: t v\n+            OkShadowStop: t v\n+            m1: t\n+            m2: t\n+            m3: t\n+            m5: t\n+            m7: t\n+            ok_double_macro_use_shadow: v\n+\n+            crate::m7\n+\n+            crate::m1\n+\n+            crate::m5\n+            m6: t\n+\n+            crate::m5::m6\n+\n+            crate::m2\n+\n+            crate::m3\n+            OkAfterInside: t v\n+            OkMacroUse: t v\n+            m4: t\n+            ok_shadow: v\n+\n+            crate::m3::m4\n+            ok_shadow_deep: v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eeOk: t v\n-   \u22eeOkAfter: t v\n-   \u22eeOkShadowStop: t v\n-   \u22eem1: t\n-   \u22eem2: t\n-   \u22eem3: t\n-   \u22eem5: t\n-   \u22eem7: t\n-   \u22eeok_double_macro_use_shadow: v\n-   \u22ee\n-   \u22eecrate::m7\n-   \u22ee\n-   \u22eecrate::m1\n-   \u22ee\n-   \u22eecrate::m5\n-   \u22eem6: t\n-   \u22ee\n-   \u22eecrate::m5::m6\n-   \u22ee\n-   \u22eecrate::m2\n-   \u22ee\n-   \u22eecrate::m3\n-   \u22eeOkAfterInside: t v\n-   \u22eeOkMacroUse: t v\n-   \u22eem4: t\n-   \u22eeok_shadow: v\n-   \u22ee\n-   \u22eecrate::m3::m4\n-   \u22eeok_shadow_deep: v\n-    \"###);\n }\n \n #[test]\n fn type_value_macro_live_in_different_scopes() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs\n-        #[macro_export]\n-        macro_rules! foo {\n-            ($x:ident) => { type $x = (); }\n-        }\n-\n-        foo!(foo);\n-        use foo as bar;\n+    check(\n+        r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    ($x:ident) => { type $x = (); }\n+}\n \n-        use self::foo as baz;\n-        fn baz() {}\n-        \",\n+foo!(foo);\n+use foo as bar;\n+\n+use self::foo as baz;\n+fn baz() {}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            bar: t m\n+            baz: t v m\n+            foo: t m\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eebar: t m\n-        \u22eebaz: t v m\n-        \u22eefoo: t m\n-    \"###);\n }\n \n #[test]\n fn macro_use_can_be_aliased() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        #[macro_use]\n-        extern crate foo;\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+#[macro_use]\n+extern crate foo;\n \n-        foo!(Direct);\n-        bar!(Alias);\n+foo!(Direct);\n+bar!(Alias);\n \n-        //- /lib.rs crate:foo\n-        use crate::foo as bar;\n+//- /lib.rs crate:foo\n+use crate::foo as bar;\n \n-        mod m {\n-            #[macro_export]\n-            macro_rules! foo {\n-                ($x:ident) => { struct $x; }\n-            }\n-        }\n-        \",\n+mod m {\n+    #[macro_export]\n+    macro_rules! foo {\n+        ($x:ident) => { struct $x; }\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Alias: t v\n+            Direct: t v\n+            foo: t\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeAlias: t v\n-        \u22eeDirect: t v\n-        \u22eefoo: t\n-    \"###);\n }\n \n #[test]\n fn path_qualified_macros() {\n-    let map = def_map(\n-        \"\n-        //- /main.rs\n-        macro_rules! foo {\n-            ($x:ident) => { struct $x; }\n-        }\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($x:ident) => { struct $x; }\n+}\n \n-        crate::foo!(NotResolved);\n-\n-        crate::bar!(OkCrate);\n-        bar!(OkPlain);\n-        alias1!(NotHere);\n-        m::alias1!(OkAliasPlain);\n-        m::alias2!(OkAliasSuper);\n-        m::alias3!(OkAliasCrate);\n-        not_found!(NotFound);\n-\n-        mod m {\n-            #[macro_export]\n-            macro_rules! bar {\n-                ($x:ident) => { struct $x; }\n-            }\n-\n-            pub use bar as alias1;\n-            pub use super::bar as alias2;\n-            pub use crate::bar as alias3;\n-            pub use self::bar as not_found;\n-        }\n-        \",\n+crate::foo!(NotResolved);\n+\n+crate::bar!(OkCrate);\n+bar!(OkPlain);\n+alias1!(NotHere);\n+m::alias1!(OkAliasPlain);\n+m::alias2!(OkAliasSuper);\n+m::alias3!(OkAliasCrate);\n+not_found!(NotFound);\n+\n+mod m {\n+    #[macro_export]\n+    macro_rules! bar {\n+        ($x:ident) => { struct $x; }\n+    }\n+    pub use bar as alias1;\n+    pub use super::bar as alias2;\n+    pub use crate::bar as alias3;\n+    pub use self::bar as not_found;\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            OkAliasCrate: t v\n+            OkAliasPlain: t v\n+            OkAliasSuper: t v\n+            OkCrate: t v\n+            OkPlain: t v\n+            bar: m\n+            m: t\n+\n+            crate::m\n+            alias1: m\n+            alias2: m\n+            alias3: m\n+            not_found: _\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeOkAliasCrate: t v\n-        \u22eeOkAliasPlain: t v\n-        \u22eeOkAliasSuper: t v\n-        \u22eeOkCrate: t v\n-        \u22eeOkPlain: t v\n-        \u22eebar: m\n-        \u22eem: t\n-        \u22ee\n-        \u22eecrate::m\n-        \u22eealias1: m\n-        \u22eealias2: m\n-        \u22eealias3: m\n-        \u22eenot_found: _\n-    \"###);\n }\n \n #[test]\n fn macro_dollar_crate_is_correct_in_item() {\n     mark::check!(macro_dollar_crate_self);\n-    let map = def_map(\n-        \"\n-        //- /main.rs crate:main deps:foo\n-        #[macro_use]\n-        extern crate foo;\n-\n-        #[macro_use]\n-        mod m {\n-            macro_rules! current {\n-                () => {\n-                    use $crate::Foo as FooSelf;\n-                }\n-            }\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+#[macro_use]\n+extern crate foo;\n+\n+#[macro_use]\n+mod m {\n+    macro_rules! current {\n+        () => {\n+            use $crate::Foo as FooSelf;\n         }\n+    }\n+}\n \n-        struct Foo;\n+struct Foo;\n \n-        current!();\n-        not_current1!();\n-        foo::not_current2!();\n-\n-        //- /lib.rs crate:foo\n-        mod m {\n-            #[macro_export]\n-            macro_rules! not_current1 {\n-                () => {\n-                    use $crate::Bar;\n-                }\n-            }\n-        }\n+current!();\n+not_current1!();\n+foo::not_current2!();\n \n-        #[macro_export]\n-        macro_rules! not_current2 {\n-            () => {\n-                use $crate::Baz;\n-            }\n+//- /lib.rs crate:foo\n+mod m {\n+    #[macro_export]\n+    macro_rules! not_current1 {\n+        () => {\n+            use $crate::Bar;\n         }\n+    }\n+}\n \n-        struct Bar;\n-        struct Baz;\n-        \",\n+#[macro_export]\n+macro_rules! not_current2 {\n+    () => {\n+        use $crate::Baz;\n+    }\n+}\n+\n+struct Bar;\n+struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Baz: t v\n+            Foo: t v\n+            FooSelf: t v\n+            foo: t\n+            m: t\n+\n+            crate::m\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeBaz: t v\n-        \u22eeFoo: t v\n-        \u22eeFooSelf: t v\n-        \u22eefoo: t\n-        \u22eem: t\n-        \u22ee\n-        \u22eecrate::m\n-    \"###);\n }\n \n #[test]\n fn macro_dollar_crate_is_correct_in_indirect_deps() {\n     mark::check!(macro_dollar_crate_other);\n     // From std\n-    let map = def_map(\n+    check(\n         r#\"\n-        //- /main.rs crate:main deps:std\n-        foo!();\n+//- /main.rs crate:main deps:std\n+foo!();\n \n-        //- /std.rs crate:std deps:core\n-        #[prelude_import]\n-        use self::prelude::*;\n+//- /std.rs crate:std deps:core\n+#[prelude_import]\n+use self::prelude::*;\n \n-        pub use core::foo;\n+pub use core::foo;\n \n-        mod prelude {}\n+mod prelude {}\n \n-        #[macro_use]\n-        mod std_macros;\n+#[macro_use]\n+mod std_macros;\n \n-        //- /core.rs crate:core\n-        #[macro_export]\n-        macro_rules! foo {\n-            () => {\n-                use $crate::bar;\n-            }\n-        }\n+//- /core.rs crate:core\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        use $crate::bar;\n+    }\n+}\n \n-        pub struct bar;\n-        \"#,\n+pub struct bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            bar: t v\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eebar: t v\n-    \"###);\n }\n \n #[test]\n fn expand_derive() {\n     let map = compute_crate_def_map(\n         \"\n         //- /main.rs\n-        #[derive(Clone)]\n+        #[derive(Copy, Clone)]\n         struct Foo;\n         \",\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n }\n \n #[test]\n-fn expand_multiple_derive() {\n-    let map = compute_crate_def_map(\n-        \"\n-        //- /main.rs\n-        #[derive(Copy, Clone)]\n-        struct Foo;\n-        \",\n+fn macro_expansion_overflow() {\n+    mark::check!(macro_expansion_overflow);\n+    check(\n+        r#\"\n+macro_rules! a {\n+    ($e:expr; $($t:tt)*) => {\n+        b!($($t)*);\n+    };\n+    () => {};\n+}\n+\n+macro_rules! b {\n+    (static = $e:expr; $($t:tt)*) => {\n+        a!($e; $($t)*);\n+    };\n+    () => {};\n+}\n+\n+b! { static = #[] (); }\n+\"#,\n+        expect![[r#\"\n+            crate\n+        \"#]],\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n }"}, {"sha": "ae58948c4261e73faf42fcae063d2e290fafc4fc", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 623, "deletions": 666, "changes": 1289, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,710 +3,672 @@ use super::*;\n #[test]\n fn name_res_works_for_broken_modules() {\n     mark::check!(name_res_works_for_broken_modules);\n-    let map = def_map(\n+    check(\n         r\"\n-        //- /lib.rs\n-        mod foo // no `;`, no body\n-\n-        use self::foo::Baz;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        pub use self::bar::Baz;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n+//- /lib.rs\n+mod foo // no `;`, no body\n+use self::foo::Baz;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+pub use self::bar::Baz;\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\",\n+        expect![[r#\"\n+            crate\n+            Baz: _\n+            foo: t\n+\n+            crate::foo\n+        \"#]],\n     );\n-    assert_snapshot!(map, @r###\"\n-crate\n-Baz: _\n-foo: t\n-\n-crate::foo\n-    \"###);\n }\n \n #[test]\n fn nested_module_resolution() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod n1;\n-\n-        //- /n1.rs\n-        mod n2;\n-\n-        //- /n1/n2.rs\n-        struct X;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod n1;\n+\n+//- /n1.rs\n+mod n2;\n+\n+//- /n1/n2.rs\n+struct X;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            n1: t\n+\n+            crate::n1\n+            n2: t\n+\n+            crate::n1::n2\n+            X: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22een1: t\n-        \u22ee\n-        \u22eecrate::n1\n-        \u22een2: t\n-        \u22ee\n-        \u22eecrate::n1::n2\n-        \u22eeX: t v\n-    \"###);\n }\n \n #[test]\n fn nested_module_resolution_2() {\n-    let map = def_map(\n-        r\"\n-        //- /lib.rs\n-        mod prelude;\n-        mod iter;\n-\n-        //- /prelude.rs\n-        pub use crate::iter::Iterator;\n-\n-        //- /iter.rs\n-        pub use self::traits::Iterator;\n-        mod traits;\n-\n-        //- /iter/traits.rs\n-        pub use self::iterator::Iterator;\n-        mod iterator;\n-\n-        //- /iter/traits/iterator.rs\n-        pub trait Iterator;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod prelude;\n+mod iter;\n+\n+//- /prelude.rs\n+pub use crate::iter::Iterator;\n+\n+//- /iter.rs\n+pub use self::traits::Iterator;\n+mod traits;\n+\n+//- /iter/traits.rs\n+pub use self::iterator::Iterator;\n+mod iterator;\n+\n+//- /iter/traits/iterator.rs\n+pub trait Iterator;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            iter: t\n+            prelude: t\n+\n+            crate::iter\n+            Iterator: t\n+            traits: t\n+\n+            crate::iter::traits\n+            Iterator: t\n+            iterator: t\n+\n+            crate::iter::traits::iterator\n+            Iterator: t\n+\n+            crate::prelude\n+            Iterator: t\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeiter: t\n-        \u22eeprelude: t\n-        \u22ee\n-        \u22eecrate::iter\n-        \u22eeIterator: t\n-        \u22eetraits: t\n-        \u22ee\n-        \u22eecrate::iter::traits\n-        \u22eeIterator: t\n-        \u22eeiterator: t\n-        \u22ee\n-        \u22eecrate::iter::traits::iterator\n-        \u22eeIterator: t\n-        \u22ee\n-        \u22eecrate::prelude\n-        \u22eeIterator: t\n-    \"###);\n }\n \n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n-    let map = def_map(\n-        \"\n-        //- /my_library.rs crate:my_library\n-        mod foo;\n-        use self::foo::Bar;\n-\n-        //- /foo/mod.rs\n-        pub struct Bar;\n-        \",\n+    check(\n+        r#\"\n+//- /my_library.rs crate:my_library\n+mod foo;\n+use self::foo::Bar;\n+\n+//- /foo/mod.rs\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            foo: t\n+\n+            crate::foo\n+            Bar: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBar: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_works_for_raw_modules() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod r#async;\n-        use self::r#async::Bar;\n-\n-        //- /async.rs\n-        pub struct Bar;\n-        \",\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod r#async;\n+use self::r#async::Bar;\n+\n+//- /async.rs\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            async: t\n+\n+            crate::async\n+            Bar: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeasync: t\n-        \u22ee\n-        \u22eecrate::async\n-        \u22eeBar: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        #[path = \"bar/baz/foo.rs\"]\n-        mod foo;\n-        use self::foo::Bar;\n-\n-        //- /bar/baz/foo.rs\n-        pub struct Bar;\n-        \"###,\n+    check(\n+        r#\"\n+//- /lib.rs\n+#[path = \"bar/baz/foo.rs\"]\n+mod foo;\n+use self::foo::Bar;\n+\n+//- /bar/baz/foo.rs\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            foo: t\n+\n+            crate::foo\n+            Bar: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBar: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_module_with_path_in_mod_rs() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo/mod.rs\n-        #[path = \"baz.rs\"]\n-        pub mod bar;\n-\n-        use self::bar::Baz;\n-\n-        //- /foo/baz.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo/mod.rs\n+#[path = \"baz.rs\"]\n+pub mod bar;\n+use self::bar::Baz;\n+\n+//- /foo/baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_module_with_path_non_crate_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo.rs\n-        #[path = \"baz.rs\"]\n-        pub mod bar;\n-\n-        use self::bar::Baz;\n-\n-        //- /baz.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+#[path = \"baz.rs\"]\n+pub mod bar;\n+use self::bar::Baz;\n+\n+//- /baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_module_decl_path_super() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"bar/baz/module.rs\"]\n-        mod foo;\n-        pub struct Baz;\n-\n-        //- /bar/baz/module.rs\n-        use super::Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"bar/baz/module.rs\"]\n+mod foo;\n+pub struct Baz;\n+\n+//- /bar/baz/module.rs\n+use super::Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_explicit_path_mod_rs() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"module/mod.rs\"]\n-        mod foo;\n-\n-        //- /module/mod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"module/mod.rs\"]\n+mod foo;\n+\n+//- /module/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_relative_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo.rs\n-        #[path = \"./sub.rs\"]\n-        pub mod foo_bar;\n-\n-        //- /sub.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+#[path = \"./sub.rs\"]\n+pub mod foo_bar;\n+\n+//- /sub.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            foo_bar: t\n+\n+            crate::foo::foo_bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eefoo_bar: t\n-        \u22ee\n-        \u22eecrate::foo::foo_bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_relative_path_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n-\n-        //- /foo/mod.rs\n-        #[path=\"../sub.rs\"]\n-        pub mod foo_bar;\n-\n-        //- /sub.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo/mod.rs\n+#[path=\"../sub.rs\"]\n+pub mod foo_bar;\n+\n+//- /sub.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            foo_bar: t\n+\n+            crate::foo::foo_bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eefoo_bar: t\n-        \u22ee\n-        \u22eecrate::foo::foo_bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_relative_path_outside_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-\n-        #[path=\"../../../../../outside.rs\"]\n-        mod foo;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path=\"../../../../../outside.rs\"]\n+mod foo;\n+\"#,\n+        expect![[r#\"\n+            crate\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-    \"###);\n }\n \n #[test]\n fn module_resolution_explicit_path_mod_rs_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"module/bar/mod.rs\"]\n-        mod foo;\n-\n-        //- /module/bar/mod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"module/bar/mod.rs\"]\n+mod foo;\n+\n+//- /module/bar/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_explicit_path_mod_rs_with_win_separator() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"module\\bar\\mod.rs\"]\n-        mod foo;\n-\n-        //- /module/bar/mod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"module\\bar\\mod.rs\"]\n+mod foo;\n+\n+//- /module/bar/mod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_with_path_attribute() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"models\"]\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /models/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"models\"]\n+mod foo { mod bar; }\n+\n+//- /models/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo { mod bar; }\n+\n+//- /foo/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_2_with_path_attribute() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"models/db\"]\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /models/db/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"models/db\"]\n+mod foo { mod bar; }\n+\n+//- /models/db/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_3() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"models/db\"]\n-        mod foo {\n-            #[path = \"users.rs\"]\n-            mod bar;\n-        }\n-\n-        //- /models/db/users.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"models/db\"]\n+mod foo {\n+    #[path = \"users.rs\"]\n+    mod bar;\n+}\n+\n+//- /models/db/users.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_empty_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"\"]\n-        mod foo {\n-            #[path = \"users.rs\"]\n-            mod bar;\n-        }\n-\n-        //- /users.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"\"]\n+mod foo {\n+    #[path = \"users.rs\"]\n+    mod bar;\n+}\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n+//- /users.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_empty_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"\"] // Should try to read `/` (a directory)\n-        mod foo;\n-\n-        //- /foo.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"\"] // Should try to read `/` (a directory)\n+mod foo;\n+\n+//- /foo.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_relative_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path = \"./models\"]\n-        mod foo {\n-            mod bar;\n-        }\n-\n-        //- /models/bar.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path = \"./models\"]\n+mod foo { mod bar; }\n+\n+//- /models/bar.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_crate_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo {\n-            #[path = \"baz.rs\"]\n-            mod bar;\n-        }\n-        use self::foo::bar::Baz;\n-\n-        //- /foo/baz.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo {\n+    #[path = \"baz.rs\"]\n+    mod bar;\n+}\n+use self::foo::bar::Baz;\n+\n+//- /foo/baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Baz: t v\n+            foo: t\n+\n+            crate::foo\n+            bar: t\n+\n+            crate::foo::bar\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_mod_rs() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo/mod.rs\n+mod bar {\n+    #[path = \"qwe.rs\"]\n+    pub mod baz;\n+}\n+use self::bar::baz::Baz;\n \n-        //- /foo/mod.rs\n-        mod bar {\n-            #[path = \"qwe.rs\"]\n-            pub mod baz;\n-        }\n-        use self::bar::baz::Baz;\n+//- /foo/bar/qwe.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n \n-        //- /foo/bar/qwe.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            baz: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::bar::baz\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo::bar::baz\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+mod bar {\n+    #[path = \"qwe.rs\"]\n+    pub mod baz;\n+}\n+use self::bar::baz::Baz;\n \n-        //- /foo.rs\n-        mod bar {\n-            #[path = \"qwe.rs\"]\n-            pub mod baz;\n-        }\n-        use self::bar::baz::Baz;\n-\n-        //- /foo/bar/qwe.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+//- /foo/bar/qwe.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::bar::baz\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo\n+            Baz: t v\n+            bar: t\n+\n+            crate::foo::bar\n+            baz: t\n+\n+            crate::foo::bar::baz\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        mod foo;\n+    check(\n+        r#\"\n+//- /main.rs\n+mod foo;\n+\n+//- /foo.rs\n+#[path = \"bar\"]\n+mod bar {\n+    pub mod baz;\n+}\n+use self::bar::baz::Baz;\n \n-        //- /foo.rs\n-        #[path = \"bar\"]\n-        mod bar {\n-            pub mod baz;\n-        }\n-        use self::bar::baz::Baz;\n-\n-        //- /bar/baz.rs\n-        pub struct Baz;\n-        \"###,\n-    );\n+//- /bar/baz.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+\n+            crate::foo\n+            Baz: t v\n+            bar: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBaz: t v\n-        \u22eebar: t\n-        \u22ee\n-        \u22eecrate::foo::bar\n-        \u22eebaz: t\n-        \u22ee\n-        \u22eecrate::foo::bar::baz\n-        \u22eeBaz: t v\n-    \"###);\n+            crate::foo::bar\n+            baz: t\n+\n+            crate::foo::bar::baz\n+            Baz: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n@@ -724,116 +686,111 @@ fn unresolved_module_diagnostics() {\n \n     let crate_def_map = db.crate_def_map(krate);\n \n-    insta::assert_debug_snapshot!(\n-        crate_def_map.diagnostics,\n-        @r###\"\n-    [\n-        UnresolvedModule {\n-            module: Idx::<ModuleData>(0),\n-            declaration: InFile {\n-                file_id: HirFileId(\n-                    FileId(\n+    expect![[r#\"\n+        [\n+            UnresolvedModule {\n+                module: Idx::<ModuleData>(0),\n+                declaration: InFile {\n+                    file_id: HirFileId(\n                         FileId(\n-                            0,\n+                            FileId(\n+                                0,\n+                            ),\n                         ),\n                     ),\n-                ),\n-                value: FileAstId::<ra_syntax::ast::generated::nodes::Module>(1),\n+                    value: FileAstId::<ra_syntax::ast::generated::nodes::Module>(1),\n+                },\n+                candidate: \"bar.rs\",\n             },\n-            candidate: \"bar.rs\",\n-        },\n-    ]\n-    \"###\n-    );\n+        ]\n+    \"#]]\n+    .assert_debug_eq(&crate_def_map.diagnostics);\n }\n \n #[test]\n fn module_resolution_decl_inside_module_in_non_crate_root_2() {\n-    let map = def_map(\n-        r###\"\n-        //- /main.rs\n-        #[path=\"module/m2.rs\"]\n-        mod module;\n-\n-        //- /module/m2.rs\n-        pub mod submod;\n-\n-        //- /module/submod.rs\n-        pub struct Baz;\n-        \"###,\n+    check(\n+        r#\"\n+//- /main.rs\n+#[path=\"module/m2.rs\"]\n+mod module;\n+\n+//- /module/m2.rs\n+pub mod submod;\n+\n+//- /module/submod.rs\n+pub struct Baz;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            module: t\n+\n+            crate::module\n+            submod: t\n+\n+            crate::module::submod\n+            Baz: t v\n+        \"#]],\n     );\n-\n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eemodule: t\n-        \u22ee\n-        \u22eecrate::module\n-        \u22eesubmod: t\n-        \u22ee\n-        \u22eecrate::module::submod\n-        \u22eeBaz: t v\n-    \"###);\n }\n \n #[test]\n fn nested_out_of_line_module() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod a {\n-            mod b {\n-                mod c;\n-            }\n-        }\n-\n-        //- /a/b/c.rs\n-        struct X;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod a {\n+    mod b {\n+        mod c;\n+    }\n+}\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eeb: t\n-        \u22ee\n-        \u22eecrate::a::b\n-        \u22eec: t\n-        \u22ee\n-        \u22eecrate::a::b::c\n-        \u22eeX: t v\n-    \"###);\n+//- /a/b/c.rs\n+struct X;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n+\n+            crate::a\n+            b: t\n+\n+            crate::a::b\n+            c: t\n+\n+            crate::a::b::c\n+            X: t v\n+        \"#]],\n+    );\n }\n \n #[test]\n fn nested_out_of_line_module_with_path() {\n-    let map = def_map(\n-        r###\"\n-        //- /lib.rs\n-        mod a {\n-            #[path = \"d/e\"]\n-            mod b {\n-                mod c;\n-            }\n-        }\n-\n-        //- /a/d/e/c.rs\n-        struct X;\n-        \"###,\n-    );\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod a {\n+    #[path = \"d/e\"]\n+    mod b {\n+        mod c;\n+    }\n+}\n+\n+//- /a/d/e/c.rs\n+struct X;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            a: t\n \n-    assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eea: t\n-        \u22ee\n-        \u22eecrate::a\n-        \u22eeb: t\n-        \u22ee\n-        \u22eecrate::a::b\n-        \u22eec: t\n-        \u22ee\n-        \u22eecrate::a::b::c\n-        \u22eeX: t v\n-    \"###);\n+            crate::a\n+            b: t\n+\n+            crate::a::b\n+            c: t\n+\n+            crate::a::b::c\n+            X: t v\n+        \"#]],\n+    );\n }"}, {"sha": "215e8952d90299e3c977ef96a51d6e8b96143ec7", "filename": "crates/ra_hir_def/src/nameres/tests/primitives.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,23 +2,22 @@ use super::*;\n \n #[test]\n fn primitive_reexport() {\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::int;\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod foo;\n+use foo::int;\n \n-        //- /foo.rs\n-        pub use i32 as int;\n-        \",\n-    );\n-    assert_snapshot!(map, @r###\"\n-   \u22eecrate\n-   \u22eefoo: t\n-   \u22eeint: t\n-   \u22ee\n-   \u22eecrate::foo\n-   \u22eeint: t\n-    \"###\n+//- /foo.rs\n+pub use i32 as int;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            foo: t\n+            int: t\n+\n+            crate::foo\n+            int: t\n+        \"#]],\n     );\n }"}, {"sha": "68b9f89c375ebdfd69157271ab5f733893aa6e25", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -67,7 +67,7 @@ impl ModPath {\n \n     /// Calls `cb` with all paths, represented by this use item.\n     pub(crate) fn expand_use_item(\n-        item_src: InFile<ast::UseItem>,\n+        item_src: InFile<ast::Use>,\n         hygiene: &Hygiene,\n         mut cb: impl FnMut(ModPath, &ast::UseTree, /* is_glob */ bool, Option<ImportAlias>),\n     ) {"}, {"sha": "07d17916ae66f665702784026e91530fe890a9bf", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -9,7 +9,7 @@ use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName},\n };\n-use ra_syntax::ast::{self, AstNode, TypeAscriptionOwner, TypeBoundsOwner};\n+use ra_syntax::ast::{self, AstNode, TypeBoundsOwner};\n \n use super::AssociatedTypeBinding;\n use crate::{\n@@ -189,14 +189,14 @@ fn lower_generic_args_from_fn_path(\n     if let Some(params) = params {\n         let mut param_types = Vec::new();\n         for param in params.params() {\n-            let type_ref = TypeRef::from_ast_opt(&ctx, param.ascribed_type());\n+            let type_ref = TypeRef::from_ast_opt(&ctx, param.ty());\n             param_types.push(type_ref);\n         }\n         let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n         args.push(arg);\n     }\n     if let Some(ret_type) = ret_type {\n-        let type_ref = TypeRef::from_ast_opt(&ctx, ret_type.type_ref());\n+        let type_ref = TypeRef::from_ast_opt(&ctx, ret_type.ty());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n             type_ref: Some(type_ref),"}, {"sha": "794be45e894c88bf08fbc70eeaee6dfe359d521b", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -31,7 +31,7 @@ pub(crate) fn lower_use_tree(\n             lower_use_tree(prefix.clone(), child_tree, hygiene, cb);\n         }\n     } else {\n-        let alias = tree.alias().map(|a| {\n+        let alias = tree.rename().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n         let is_glob = tree.star_token().is_some();"}, {"sha": "0bf51eb7b839b6f9929c71b7e595d96cb2dfbc8a", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -511,11 +511,9 @@ impl Scope {\n                     });\n                 }\n             }\n-            Scope::LocalItemsScope(body) => {\n-                body.item_scope.entries_without_primitives().for_each(|(name, def)| {\n-                    f(name.clone(), ScopeDef::PerNs(def));\n-                })\n-            }\n+            Scope::LocalItemsScope(body) => body.item_scope.entries().for_each(|(name, def)| {\n+                f(name.clone(), ScopeDef::PerNs(def));\n+            }),\n             Scope::GenericParams { params, def } => {\n                 for (local_id, param) in params.types.iter() {\n                     if let Some(name) = &param.name {"}, {"sha": "339f819b8b5bc42c7bd4ae99a8d14aa99f48625e", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,7 +1,7 @@\n //! Database used for testing `hir_def`.\n \n use std::{\n-    panic,\n+    fmt, panic,\n     sync::{Arc, Mutex},\n };\n \n@@ -18,10 +18,10 @@ use crate::db::DefDatabase;\n     crate::db::InternDatabaseStorage,\n     crate::db::DefDatabaseStorage\n )]\n-#[derive(Debug, Default)]\n+#[derive(Default)]\n pub struct TestDB {\n-    runtime: salsa::Runtime<TestDB>,\n-    events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n+    storage: salsa::Storage<TestDB>,\n+    events: Mutex<Option<Vec<salsa::Event>>>,\n }\n \n impl Upcast<dyn AstDatabase> for TestDB {\n@@ -37,20 +37,20 @@ impl Upcast<dyn DefDatabase> for TestDB {\n }\n \n impl salsa::Database for TestDB {\n-    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n-        &self.runtime\n-    }\n-    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n-        &mut self.runtime\n-    }\n-    fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n+    fn salsa_event(&self, event: salsa::Event) {\n         let mut events = self.events.lock().unwrap();\n         if let Some(events) = &mut *events {\n-            events.push(event());\n+            events.push(event);\n         }\n     }\n }\n \n+impl fmt::Debug for TestDB {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"TestDB\").finish()\n+    }\n+}\n+\n impl panic::RefUnwindSafe for TestDB {}\n \n impl FileLoader for TestDB {\n@@ -78,7 +78,7 @@ impl TestDB {\n         panic!(\"Can't find module for file\")\n     }\n \n-    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<TestDB>> {\n+    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event> {\n         *self.events.lock().unwrap() = Some(Vec::new());\n         f();\n         self.events.lock().unwrap().take().unwrap()\n@@ -92,7 +92,7 @@ impl TestDB {\n                 // This pretty horrible, but `Debug` is the only way to inspect\n                 // QueryDescriptor at the moment.\n                 salsa::EventKind::WillExecute { database_key } => {\n-                    Some(format!(\"{:?}\", database_key))\n+                    Some(format!(\"{:?}\", database_key.debug(self)))\n                 }\n                 _ => None,\n             })"}, {"sha": "a5dc10eac50292a17036f1f83807eed4b980c0e7", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,7 +1,7 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n \n-use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n+use ra_syntax::ast::{self};\n \n use crate::{body::LowerCtx, path::Path};\n \n@@ -63,7 +63,7 @@ pub enum TypeRef {\n     Array(Box<TypeRef> /*, Expr*/),\n     Slice(Box<TypeRef>),\n     /// A fn pointer. Last element of the vector is the return type.\n-    Fn(Vec<TypeRef>),\n+    Fn(Vec<TypeRef>, bool /*varargs*/),\n     // For\n     ImplTrait(Vec<TypeBound>),\n     DynTrait(Vec<TypeBound>),\n@@ -82,7 +82,7 @@ impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n     pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeRef) -> Self {\n         match node {\n-            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.type_ref()),\n+            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n             ast::TypeRef::TupleType(inner) => {\n                 TypeRef::Tuple(inner.fields().map(|it| TypeRef::from_ast(ctx, it)).collect())\n             }\n@@ -96,41 +96,43 @@ impl TypeRef {\n                     .unwrap_or(TypeRef::Error)\n             }\n             ast::TypeRef::PointerType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.type_ref());\n+                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.ty());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n             ast::TypeRef::ArrayType(inner) => {\n-                TypeRef::Array(Box::new(TypeRef::from_ast_opt(&ctx, inner.type_ref())))\n+                TypeRef::Array(Box::new(TypeRef::from_ast_opt(&ctx, inner.ty())))\n             }\n             ast::TypeRef::SliceType(inner) => {\n-                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(&ctx, inner.type_ref())))\n+                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(&ctx, inner.ty())))\n             }\n             ast::TypeRef::ReferenceType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.type_ref());\n+                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.ty());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n             ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,\n             ast::TypeRef::FnPointerType(inner) => {\n                 let ret_ty = inner\n                     .ret_type()\n-                    .and_then(|rt| rt.type_ref())\n+                    .and_then(|rt| rt.ty())\n                     .map(|it| TypeRef::from_ast(ctx, it))\n                     .unwrap_or_else(|| TypeRef::Tuple(Vec::new()));\n+                let mut is_varargs = false;\n                 let mut params = if let Some(pl) = inner.param_list() {\n-                    pl.params()\n-                        .map(|p| p.ascribed_type())\n-                        .map(|it| TypeRef::from_ast_opt(&ctx, it))\n-                        .collect()\n+                    if let Some(param) = pl.params().last() {\n+                        is_varargs = param.dotdotdot_token().is_some();\n+                    }\n+\n+                    pl.params().map(|p| p.ty()).map(|it| TypeRef::from_ast_opt(&ctx, it)).collect()\n                 } else {\n                     Vec::new()\n                 };\n                 params.push(ret_ty);\n-                TypeRef::Fn(params)\n+                TypeRef::Fn(params, is_varargs)\n             }\n             // for types are close enough for our purposes to the inner type for now...\n-            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.type_ref()),\n+            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n             ast::TypeRef::ImplTraitType(inner) => {\n                 TypeRef::ImplTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n@@ -158,7 +160,9 @@ impl TypeRef {\n         fn go(type_ref: &TypeRef, f: &mut impl FnMut(&TypeRef)) {\n             f(type_ref);\n             match type_ref {\n-                TypeRef::Fn(types) | TypeRef::Tuple(types) => types.iter().for_each(|t| go(t, f)),\n+                TypeRef::Fn(types, _) | TypeRef::Tuple(types) => {\n+                    types.iter().for_each(|t| go(t, f))\n+                }\n                 TypeRef::RawPtr(type_ref, _)\n                 | TypeRef::Reference(type_ref, _)\n                 | TypeRef::Array(type_ref)"}, {"sha": "1abffb4c3cac1d7517173ac8f1f94caa0d76dc29", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -5,6 +5,7 @@ use ra_syntax::ast;\n \n use crate::{\n     db::DefDatabase,\n+    nameres::CrateDefMap,\n     path::{ModPath, PathKind},\n     ModuleId,\n };\n@@ -115,7 +116,7 @@ impl Visibility {\n \n     pub(crate) fn is_visible_from_def_map(\n         self,\n-        def_map: &crate::nameres::CrateDefMap,\n+        def_map: &CrateDefMap,\n         from_module: crate::LocalModuleId,\n     ) -> bool {\n         let to_module = match self {\n@@ -129,4 +130,42 @@ impl Visibility {\n         });\n         ancestors.any(|m| m == to_module.local_id)\n     }\n+\n+    /// Returns the most permissive visibility of `self` and `other`.\n+    ///\n+    /// If there is no subset relation between `self` and `other`, returns `None` (ie. they're only\n+    /// visible in unrelated modules).\n+    pub(crate) fn max(self, other: Visibility, def_map: &CrateDefMap) -> Option<Visibility> {\n+        match (self, other) {\n+            (Visibility::Module(_), Visibility::Public)\n+            | (Visibility::Public, Visibility::Module(_))\n+            | (Visibility::Public, Visibility::Public) => Some(Visibility::Public),\n+            (Visibility::Module(mod_a), Visibility::Module(mod_b)) => {\n+                if mod_a.krate != mod_b.krate {\n+                    return None;\n+                }\n+\n+                let mut a_ancestors = std::iter::successors(Some(mod_a.local_id), |m| {\n+                    let parent_id = def_map[*m].parent?;\n+                    Some(parent_id)\n+                });\n+                let mut b_ancestors = std::iter::successors(Some(mod_b.local_id), |m| {\n+                    let parent_id = def_map[*m].parent?;\n+                    Some(parent_id)\n+                });\n+\n+                if a_ancestors.any(|m| m == mod_b.local_id) {\n+                    // B is above A\n+                    return Some(Visibility::Module(mod_b));\n+                }\n+\n+                if b_ancestors.any(|m| m == mod_a.local_id) {\n+                    // A is above B\n+                    return Some(Visibility::Module(mod_a));\n+                }\n+\n+                None\n+            }\n+        }\n+    }\n }"}, {"sha": "6da0e2a165fec47a71b4ef4e47b7057f73941e1f", "filename": "crates/ra_hir_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ edition = \"2018\"\n name = \"ra_hir_expand\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false"}, {"sha": "8bfe1b4ba7d3357f36682c56e76cf2515d8cbc30", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -73,7 +73,7 @@ impl AstIdMap {\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bfs(node, |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+            if let Some(module_item) = ast::Item::cast(it) {\n                 res.alloc(module_item.syntax());\n             }\n         });"}, {"sha": "69fa907cb89b90aa8f1ae15aa6a9504830162a5c", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -4,7 +4,7 @@ use log::debug;\n \n use ra_parser::FragmentKind;\n use ra_syntax::{\n-    ast::{self, AstNode, ModuleItemOwner, NameOwner, TypeParamsOwner},\n+    ast::{self, AstNode, GenericParamsOwner, ModuleItemOwner, NameOwner},\n     match_ast,\n };\n \n@@ -72,9 +72,9 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n     let node = item.syntax();\n     let (name, params) = match_ast! {\n         match node {\n-            ast::StructDef(it) => (it.name(), it.type_param_list()),\n-            ast::EnumDef(it) => (it.name(), it.type_param_list()),\n-            ast::UnionDef(it) => (it.name(), it.type_param_list()),\n+            ast::Struct(it) => (it.name(), it.generic_param_list()),\n+            ast::Enum(it) => (it.name(), it.generic_param_list()),\n+            ast::Union(it) => (it.name(), it.generic_param_list()),\n             _ => {\n                 debug!(\"unexpected node is {:?}\", node);\n                 return Err(mbe::ExpandError::ConversionError)\n@@ -161,7 +161,7 @@ fn find_builtin_crate(db: &dyn AstDatabase, id: LazyMacroId) -> tt::TokenTree {\n     // XXX\n     //  All crates except core itself should have a dependency on core,\n     //  We detect `core` by seeing whether it doesn't have such a dependency.\n-    let tt = if cg[krate].dependencies.iter().any(|dep| dep.name == \"core\") {\n+    let tt = if cg[krate].dependencies.iter().any(|dep| &*dep.name == \"core\") {\n         quote! { core }\n     } else {\n         quote! { crate }\n@@ -276,7 +276,7 @@ mod tests {\n         let file_id = file_pos.file_id;\n         let parsed = db.parse(file_id);\n         let items: Vec<_> =\n-            parsed.syntax_node().descendants().filter_map(ast::ModuleItem::cast).collect();\n+            parsed.syntax_node().descendants().filter_map(ast::Item::cast).collect();\n \n         let ast_id_map = db.ast_id_map(file_id.into());\n "}, {"sha": "9f50569dc41c77585a3e9b75a3b7919d9f81ac32", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -272,7 +272,7 @@ fn format_args_expand(\n fn unquote_str(lit: &tt::Literal) -> Option<String> {\n     let lit = ast::make::tokens::literal(&lit.to_string());\n     let token = ast::String::cast(lit)?;\n-    token.value()\n+    token.value().map(|it| it.into_owned())\n }\n \n fn concat_expand("}, {"sha": "41df666965c34996b6efe3c23a426cd37e3e83da", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,7 +6,7 @@ use mbe::{ExpandResult, MacroRules};\n use ra_db::{salsa, SourceDatabase};\n use ra_parser::FragmentKind;\n use ra_prof::profile;\n-use ra_syntax::{algo::diff, AstNode, Parse, SyntaxKind::*, SyntaxNode};\n+use ra_syntax::{algo::diff, AstNode, GreenNode, Parse, SyntaxKind::*, SyntaxNode};\n \n use crate::{\n     ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId,\n@@ -72,6 +72,8 @@ pub trait AstDatabase: SourceDatabase {\n \n     #[salsa::interned]\n     fn intern_macro(&self, macro_call: MacroCallLoc) -> LazyMacroId;\n+    fn macro_arg_text(&self, id: MacroCallId) -> Option<GreenNode>;\n+    #[salsa::transparent]\n     fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n     fn macro_def(&self, id: MacroDefId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>>;\n     fn parse_macro(&self, macro_file: MacroFile)\n@@ -148,10 +150,7 @@ pub(crate) fn macro_def(\n     }\n }\n \n-pub(crate) fn macro_arg(\n-    db: &dyn AstDatabase,\n-    id: MacroCallId,\n-) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n+pub(crate) fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     let id = match id {\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(_id) => {\n@@ -161,7 +160,15 @@ pub(crate) fn macro_arg(\n     };\n     let loc = db.lookup_intern_macro(id);\n     let arg = loc.kind.arg(db)?;\n-    let (tt, tmap) = mbe::syntax_node_to_token_tree(&arg)?;\n+    Some(arg.green().clone())\n+}\n+\n+pub(crate) fn macro_arg(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n+    let arg = db.macro_arg_text(id)?;\n+    let (tt, tmap) = mbe::syntax_node_to_token_tree(&SyntaxNode::new_root(arg))?;\n     Some(Arc::new((tt, tmap)))\n }\n \n@@ -379,7 +386,7 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n         MATCH_EXPR => FragmentKind::Expr,\n         MATCH_ARM => FragmentKind::Expr,\n         MATCH_GUARD => FragmentKind::Expr,\n-        RECORD_FIELD => FragmentKind::Expr,\n+        RECORD_EXPR_FIELD => FragmentKind::Expr,\n         CALL_EXPR => FragmentKind::Expr,\n         INDEX_EXPR => FragmentKind::Expr,\n         METHOD_CALL_EXPR => FragmentKind::Expr,"}, {"sha": "84ba97b14a1fedd42f4ee77268f068336731e9ab", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -24,11 +24,14 @@ pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n     fn message(&self) -> String;\n     fn source(&self) -> InFile<SyntaxNodePtr>;\n     fn as_any(&self) -> &(dyn Any + Send + 'static);\n+    fn is_experimental(&self) -> bool {\n+        false\n+    }\n }\n \n pub trait AstDiagnostic {\n     type AST;\n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST;\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST;\n }\n \n impl dyn Diagnostic {\n@@ -44,16 +47,48 @@ impl dyn Diagnostic {\n \n pub struct DiagnosticSink<'a> {\n     callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n+    filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n     default_callback: Box<dyn FnMut(&dyn Diagnostic) + 'a>,\n }\n \n impl<'a> DiagnosticSink<'a> {\n-    /// FIXME: split `new` and `on` into a separate builder type\n-    pub fn new(cb: impl FnMut(&dyn Diagnostic) + 'a) -> DiagnosticSink<'a> {\n-        DiagnosticSink { callbacks: Vec::new(), default_callback: Box::new(cb) }\n+    pub fn push(&mut self, d: impl Diagnostic) {\n+        let d: &dyn Diagnostic = &d;\n+        self._push(d);\n+    }\n+\n+    fn _push(&mut self, d: &dyn Diagnostic) {\n+        for filter in &mut self.filters {\n+            if !filter(d) {\n+                return;\n+            }\n+        }\n+        for cb in &mut self.callbacks {\n+            match cb(d) {\n+                Ok(()) => return,\n+                Err(()) => (),\n+            }\n+        }\n+        (self.default_callback)(d)\n     }\n+}\n \n-    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> DiagnosticSink<'a> {\n+pub struct DiagnosticSinkBuilder<'a> {\n+    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n+    filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n+}\n+\n+impl<'a> DiagnosticSinkBuilder<'a> {\n+    pub fn new() -> Self {\n+        Self { callbacks: Vec::new(), filters: Vec::new() }\n+    }\n+\n+    pub fn filter<F: FnMut(&dyn Diagnostic) -> bool + 'a>(mut self, cb: F) -> Self {\n+        self.filters.push(Box::new(cb));\n+        self\n+    }\n+\n+    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> Self {\n         let cb = move |diag: &dyn Diagnostic| match diag.downcast_ref::<D>() {\n             Some(d) => {\n                 cb(d);\n@@ -65,18 +100,11 @@ impl<'a> DiagnosticSink<'a> {\n         self\n     }\n \n-    pub fn push(&mut self, d: impl Diagnostic) {\n-        let d: &dyn Diagnostic = &d;\n-        self._push(d);\n-    }\n-\n-    fn _push(&mut self, d: &dyn Diagnostic) {\n-        for cb in self.callbacks.iter_mut() {\n-            match cb(d) {\n-                Ok(()) => return,\n-                Err(()) => (),\n-            }\n+    pub fn build<F: FnMut(&dyn Diagnostic) + 'a>(self, default_callback: F) -> DiagnosticSink<'a> {\n+        DiagnosticSink {\n+            callbacks: self.callbacks,\n+            filters: self.filters,\n+            default_callback: Box::new(default_callback),\n         }\n-        (self.default_callback)(d)\n     }\n }"}, {"sha": "2e8d63691716b9f1190a5b5604bc65711464da18", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -88,6 +88,25 @@ impl HirFileId {\n         }\n     }\n \n+    pub fn expansion_level(self, db: &dyn db::AstDatabase) -> u32 {\n+        let mut level = 0;\n+        let mut curr = self;\n+        while let HirFileIdRepr::MacroFile(macro_file) = curr.0 {\n+            level += 1;\n+            curr = match macro_file.macro_call_id {\n+                MacroCallId::LazyMacro(id) => {\n+                    let loc = db.lookup_intern_macro(id);\n+                    loc.kind.file_id()\n+                }\n+                MacroCallId::EagerMacro(id) => {\n+                    let loc = db.lookup_intern_eager_expansion(id);\n+                    loc.file_id\n+                }\n+            };\n+        }\n+        level\n+    }\n+\n     /// If this is a macro call, returns the syntax node of the call.\n     pub fn call_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n         match self.0 {\n@@ -140,7 +159,7 @@ impl HirFileId {\n     }\n \n     /// Indicate it is macro file generated for builtin derive\n-    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::ModuleItem>> {\n+    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::Item>> {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n@@ -155,7 +174,7 @@ impl HirFileId {\n                     MacroDefKind::BuiltInDerive(_) => loc.kind.node(db),\n                     _ => return None,\n                 };\n-                Some(item.with_value(ast::ModuleItem::cast(item.value.clone())?))\n+                Some(item.with_value(ast::Item::cast(item.value.clone())?))\n             }\n         }\n     }\n@@ -239,18 +258,18 @@ pub struct MacroCallLoc {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum MacroCallKind {\n     FnLike(AstId<ast::MacroCall>),\n-    Attr(AstId<ast::ModuleItem>, String),\n+    Attr(AstId<ast::Item>, String),\n }\n \n impl MacroCallKind {\n-    pub fn file_id(&self) -> HirFileId {\n+    fn file_id(&self) -> HirFileId {\n         match self {\n             MacroCallKind::FnLike(ast_id) => ast_id.file_id,\n             MacroCallKind::Attr(ast_id, _) => ast_id.file_id,\n         }\n     }\n \n-    pub fn node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n+    fn node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike(ast_id) => ast_id.with_value(ast_id.to_node(db).syntax().clone()),\n             MacroCallKind::Attr(ast_id, _) => {\n@@ -259,7 +278,7 @@ impl MacroCallKind {\n         }\n     }\n \n-    pub fn arg(&self, db: &dyn db::AstDatabase) -> Option<SyntaxNode> {\n+    fn arg(&self, db: &dyn db::AstDatabase) -> Option<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike(ast_id) => {\n                 Some(ast_id.to_node(db).token_tree()?.syntax().clone())"}, {"sha": "969a2e5b834eea7e3ebc450d6142bc104f9a4f61", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -117,7 +117,7 @@ impl AsName for ast::FieldKind {\n \n impl AsName for ra_db::Dependency {\n     fn as_name(&self) -> Name {\n-        Name::new_text(self.name.clone())\n+        Name::new_text(SmolStr::new(&*self.name))\n     }\n }\n "}, {"sha": "332fa556fad5236bbde4cae641568cb604256b52", "filename": "crates/ra_hir_expand/src/test_db.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,7 +1,7 @@\n //! Database used for testing `hir_expand`.\n \n use std::{\n-    panic,\n+    fmt, panic,\n     sync::{Arc, Mutex},\n };\n \n@@ -13,25 +13,23 @@ use rustc_hash::FxHashSet;\n     ra_db::SourceDatabaseStorage,\n     crate::db::AstDatabaseStorage\n )]\n-#[derive(Debug, Default)]\n+#[derive(Default)]\n pub struct TestDB {\n-    runtime: salsa::Runtime<TestDB>,\n-    events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n+    storage: salsa::Storage<TestDB>,\n+    events: Mutex<Option<Vec<salsa::Event>>>,\n }\n \n-impl salsa::Database for TestDB {\n-    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n-        &self.runtime\n-    }\n-\n-    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n-        &mut self.runtime\n+impl fmt::Debug for TestDB {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"TestDB\").finish()\n     }\n+}\n \n-    fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n+impl salsa::Database for TestDB {\n+    fn salsa_event(&self, event: salsa::Event) {\n         let mut events = self.events.lock().unwrap();\n         if let Some(events) = &mut *events {\n-            events.push(event());\n+            events.push(event);\n         }\n     }\n }"}, {"sha": "623ce261a0598591e25232b4d13ee456daaec4b1", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,6 +3,7 @@ edition = \"2018\"\n name = \"ra_hir_ty\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false\n@@ -27,8 +28,13 @@ test_utils = { path = \"../test_utils\" }\n \n scoped-tls = \"1\"\n \n-chalk-solve = { version = \"0.15.0\" }\n-chalk-ir = { version = \"0.15.0\" }\n+chalk-solve = { version = \"0.19.0\" }\n+chalk-ir = { version = \"0.19.0\" }\n+chalk-recursive = { version = \"0.19.0\" }\n \n [dev-dependencies]\n-insta = \"0.16.0\"\n+expect = { path = \"../expect\" }\n+\n+tracing = \"0.1\"\n+tracing-subscriber = { version = \"0.2\", default-features = false, features = [\"env-filter\", \"registry\"] }\n+tracing-tree = { version = \"0.1.4\" }"}, {"sha": "c727012c69de33681a52f05bcbbd2bf03507bae2", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -37,7 +37,7 @@ pub(crate) fn deref(\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n     if let Some(derefed) = ty.value.value.builtin_deref() {\n-        Some(Canonical { value: derefed, num_vars: ty.value.num_vars })\n+        Some(Canonical { value: derefed, kinds: ty.value.kinds.clone() })\n     } else {\n         deref_by_trait(db, krate, ty)\n     }\n@@ -68,8 +68,8 @@ fn deref_by_trait(\n \n     // Check that the type implements Deref at all\n     let trait_ref = TraitRef { trait_: deref_trait, substs: parameters.clone() };\n-    let implements_goal = super::Canonical {\n-        num_vars: ty.value.num_vars,\n+    let implements_goal = Canonical {\n+        kinds: ty.value.kinds.clone(),\n         value: InEnvironment {\n             value: Obligation::Trait(trait_ref),\n             environment: ty.environment.clone(),\n@@ -81,15 +81,16 @@ fn deref_by_trait(\n \n     // Now do the assoc type projection\n     let projection = super::traits::ProjectionPredicate {\n-        ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.num_vars)),\n+        ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len())),\n         projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n     };\n \n     let obligation = super::Obligation::Projection(projection);\n \n     let in_env = InEnvironment { value: obligation, environment: ty.environment };\n \n-    let canonical = super::Canonical { num_vars: 1 + ty.value.num_vars, value: in_env };\n+    let canonical =\n+        Canonical::new(in_env, ty.value.kinds.iter().copied().chain(Some(super::TyKind::General)));\n \n     let solution = db.trait_solve(krate, canonical)?;\n \n@@ -110,7 +111,7 @@ fn deref_by_trait(\n             // assumptions will be broken. We would need to properly introduce\n             // new variables in that case\n \n-            for i in 1..vars.0.num_vars {\n+            for i in 1..vars.0.kinds.len() {\n                 if vars.0.value[i - 1] != Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.value, solution);\n@@ -119,7 +120,7 @@ fn deref_by_trait(\n             }\n             Some(Canonical {\n                 value: vars.0.value[vars.0.value.len() - 1].clone(),\n-                num_vars: vars.0.num_vars,\n+                kinds: vars.0.kinds.clone(),\n             })\n         }\n         Solution::Ambig(_) => {"}, {"sha": "c773adc6744292190bd816d4a98ee566f3de0c3e", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,23 +3,22 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    db::DefDatabase, DefWithBodyId, FunctionId, GenericDefId, ImplId, LocalFieldId, TypeParamId,\n-    VariantId,\n+    db::DefDatabase, expr::ExprId, DefWithBodyId, FunctionId, GenericDefId, ImplId, LocalFieldId,\n+    TypeParamId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n use ra_prof::profile;\n \n use crate::{\n-    method_resolution::CrateImplDefs,\n-    traits::{chalk, AssocTyValue, Impl},\n-    Binders, CallableDef, GenericPredicate, InferenceResult, OpaqueTyId, PolyFnSig,\n-    ReturnTypeImplTraits, TraitRef, Ty, TyDefId, TypeCtor, ValueTyDefId,\n+    method_resolution::{InherentImpls, TraitImpls},\n+    traits::chalk,\n+    Binders, CallableDefId, GenericPredicate, InferenceResult, OpaqueTyId, PolyFnSig,\n+    ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n #[salsa::query_group(HirDatabaseStorage)]\n-#[salsa::requires(salsa::Database)]\n pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(infer_wait)]\n     #[salsa::transparent]\n@@ -46,7 +45,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Binders<Ty>>>;\n \n     #[salsa::invoke(crate::callable_item_sig)]\n-    fn callable_item_signature(&self, def: CallableDef) -> PolyFnSig;\n+    fn callable_item_signature(&self, def: CallableDefId) -> PolyFnSig;\n \n     #[salsa::invoke(crate::lower::return_type_impl_traits)]\n     fn return_type_impl_traits(\n@@ -67,25 +66,24 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDefId) -> Arc<[Binders<Ty>]>;\n \n-    #[salsa::invoke(crate::method_resolution::CrateImplDefs::impls_in_crate_query)]\n-    fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplDefs>;\n+    #[salsa::invoke(InherentImpls::inherent_impls_in_crate_query)]\n+    fn inherent_impls_in_crate(&self, krate: CrateId) -> Arc<InherentImpls>;\n \n-    #[salsa::invoke(crate::method_resolution::CrateImplDefs::impls_from_deps_query)]\n-    fn impls_from_deps(&self, krate: CrateId) -> Arc<CrateImplDefs>;\n+    #[salsa::invoke(TraitImpls::trait_impls_in_crate_query)]\n+    fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;\n+\n+    #[salsa::invoke(TraitImpls::trait_impls_in_deps_query)]\n+    fn trait_impls_in_deps(&self, krate: CrateId) -> Arc<TraitImpls>;\n \n     // Interned IDs for Chalk integration\n     #[salsa::interned]\n-    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::TypeCtorId;\n-    #[salsa::interned]\n-    fn intern_callable_def(&self, callable_def: CallableDef) -> crate::CallableDefId;\n+    fn intern_callable_def(&self, callable_def: CallableDefId) -> InternedCallableDefId;\n     #[salsa::interned]\n     fn intern_type_param_id(&self, param_id: TypeParamId) -> GlobalTypeParamId;\n     #[salsa::interned]\n     fn intern_impl_trait_id(&self, id: OpaqueTyId) -> InternedOpaqueTyId;\n     #[salsa::interned]\n-    fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n-    #[salsa::interned]\n-    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n+    fn intern_closure(&self, id: (DefWithBodyId, ExprId)) -> ClosureId;\n \n     #[salsa::invoke(chalk::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk::AssocTypeId) -> Arc<chalk::AssociatedTyDatum>;\n@@ -149,3 +147,13 @@ impl_intern_key!(GlobalTypeParamId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct InternedOpaqueTyId(salsa::InternId);\n impl_intern_key!(InternedOpaqueTyId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ClosureId(salsa::InternId);\n+impl_intern_key!(ClosureId);\n+\n+/// This exists just for Chalk, because Chalk just has a single `FnDefId` where\n+/// we have different IDs for struct and enum variant constructors.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub struct InternedCallableDefId(salsa::InternId);\n+impl_intern_key!(InternedCallableDefId);"}, {"sha": "f210c305a3fb8539b4fe87c31d7127a1edb1a55f", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 295, "deletions": 13, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -1,18 +1,35 @@\n //! FIXME: write short doc here\n+mod expr;\n+mod match_check;\n+mod unsafe_check;\n \n use std::any::Any;\n \n+use hir_def::DefWithBodyId;\n+use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n use hir_expand::{db::AstDatabase, name::Name, HirFileId, InFile};\n+use ra_prof::profile;\n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n use stdx::format_to;\n \n-pub use hir_def::{diagnostics::UnresolvedModule, expr::MatchArm, path::Path};\n-pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n+use crate::db::HirDatabase;\n+\n+pub use crate::diagnostics::expr::{record_literal_missing_fields, record_pattern_missing_fields};\n+\n+pub fn validate_body(db: &dyn HirDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n+    let _p = profile(\"validate_body\");\n+    let infer = db.infer(owner);\n+    infer.add_diagnostics(db, owner, sink);\n+    let mut validator = expr::ExprValidator::new(owner, infer.clone(), sink);\n+    validator.validate_body(db);\n+    let mut validator = unsafe_check::UnsafeValidator::new(owner, infer, sink);\n+    validator.validate_body(db);\n+}\n \n #[derive(Debug)]\n pub struct NoSuchField {\n     pub file: HirFileId,\n-    pub field: AstPtr<ast::RecordField>,\n+    pub field: AstPtr<ast::RecordExprField>,\n }\n \n impl Diagnostic for NoSuchField {\n@@ -30,19 +47,19 @@ impl Diagnostic for NoSuchField {\n }\n \n impl AstDiagnostic for NoSuchField {\n-    type AST = ast::RecordField;\n+    type AST = ast::RecordExprField;\n \n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.source().file_id).unwrap();\n         let node = self.source().value.to_node(&root);\n-        ast::RecordField::cast(node).unwrap()\n+        ast::RecordExprField::cast(node).unwrap()\n     }\n }\n \n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordFieldList>,\n+    pub field_list: AstPtr<ast::RecordExprFieldList>,\n     pub missed_fields: Vec<Name>,\n }\n \n@@ -63,12 +80,12 @@ impl Diagnostic for MissingFields {\n }\n \n impl AstDiagnostic for MissingFields {\n-    type AST = ast::RecordFieldList;\n+    type AST = ast::RecordExprFieldList;\n \n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.source().file_id).unwrap();\n         let node = self.source().value.to_node(&root);\n-        ast::RecordFieldList::cast(node).unwrap()\n+        ast::RecordExprFieldList::cast(node).unwrap()\n     }\n }\n \n@@ -135,7 +152,7 @@ impl Diagnostic for MissingOkInTailExpr {\n impl AstDiagnostic for MissingOkInTailExpr {\n     type AST = ast::Expr;\n \n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file).unwrap();\n         let node = self.source().value.to_node(&root);\n         ast::Expr::cast(node).unwrap()\n@@ -163,7 +180,7 @@ impl Diagnostic for BreakOutsideOfLoop {\n impl AstDiagnostic for BreakOutsideOfLoop {\n     type AST = ast::Expr;\n \n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file).unwrap();\n         let node = self.source().value.to_node(&root);\n         ast::Expr::cast(node).unwrap()\n@@ -191,9 +208,274 @@ impl Diagnostic for MissingUnsafe {\n impl AstDiagnostic for MissingUnsafe {\n     type AST = ast::Expr;\n \n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.source().file_id).unwrap();\n         let node = self.source().value.to_node(&root);\n         ast::Expr::cast(node).unwrap()\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct MismatchedArgCount {\n+    pub file: HirFileId,\n+    pub call_expr: AstPtr<ast::Expr>,\n+    pub expected: usize,\n+    pub found: usize,\n+}\n+\n+impl Diagnostic for MismatchedArgCount {\n+    fn message(&self) -> String {\n+        let s = if self.expected == 1 { \"\" } else { \"s\" };\n+        format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.call_expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+    fn is_experimental(&self) -> bool {\n+        true\n+    }\n+}\n+\n+impl AstDiagnostic for MismatchedArgCount {\n+    type AST = ast::CallExpr;\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.source().file_id).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::CallExpr::cast(node).unwrap()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n+    use hir_expand::diagnostics::{Diagnostic, DiagnosticSinkBuilder};\n+    use ra_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n+    use ra_syntax::{TextRange, TextSize};\n+    use rustc_hash::FxHashMap;\n+\n+    use crate::{diagnostics::validate_body, test_db::TestDB};\n+\n+    impl TestDB {\n+        fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n+            let crate_graph = self.crate_graph();\n+            for krate in crate_graph.iter() {\n+                let crate_def_map = self.crate_def_map(krate);\n+\n+                let mut fns = Vec::new();\n+                for (module_id, _) in crate_def_map.modules.iter() {\n+                    for decl in crate_def_map[module_id].scope.declarations() {\n+                        if let ModuleDefId::FunctionId(f) = decl {\n+                            fns.push(f)\n+                        }\n+                    }\n+\n+                    for impl_id in crate_def_map[module_id].scope.impls() {\n+                        let impl_data = self.impl_data(impl_id);\n+                        for item in impl_data.items.iter() {\n+                            if let AssocItemId::FunctionId(f) = item {\n+                                fns.push(*f)\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                for f in fns {\n+                    let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n+                    validate_body(self, f.into(), &mut sink);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        let db = TestDB::with_files(ra_fixture);\n+        let annotations = db.extract_annotations();\n+\n+        let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n+        db.diagnostics(|d| {\n+            // FXIME: macros...\n+            let file_id = d.source().file_id.original_file(&db);\n+            let range = d.syntax_node(&db).text_range();\n+            let message = d.message().to_owned();\n+            actual.entry(file_id).or_default().push((range, message));\n+        });\n+\n+        for (file_id, diags) in actual.iter_mut() {\n+            diags.sort_by_key(|it| it.0.start());\n+            let text = db.file_text(*file_id);\n+            // For multiline spans, place them on line start\n+            for (range, content) in diags {\n+                if text[*range].contains('\\n') {\n+                    *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n+                    *content = format!(\"... {}\", content);\n+                }\n+            }\n+        }\n+\n+        assert_eq!(annotations, actual);\n+    }\n+\n+    #[test]\n+    fn no_such_field_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+impl S {\n+    fn new() -> S {\n+        S {\n+        //^... Missing structure fields:\n+        //|    - bar\n+            foo: 92,\n+            baz: 62,\n+          //^^^^^^^ no such field\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct MyStruct {\n+    my_val: usize,\n+    #[cfg(feature = \"foo\")]\n+    bar: bool,\n+}\n+\n+impl MyStruct {\n+    #[cfg(feature = \"foo\")]\n+    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+        Self { my_val, bar }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+        Self { my_val }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_enum_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+enum Foo {\n+    #[cfg(not(feature = \"foo\"))]\n+    Buz,\n+    #[cfg(feature = \"foo\")]\n+    Bar,\n+    Baz\n+}\n+\n+fn test_fn(f: Foo) {\n+    match f {\n+        Foo::Bar => {},\n+        Foo::Baz => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct S {\n+    #[cfg(feature = \"foo\")]\n+    foo: u32,\n+    #[cfg(not(feature = \"foo\"))]\n+    bar: u32,\n+}\n+\n+impl S {\n+    #[cfg(feature = \"foo\")]\n+    fn new(foo: u32) -> Self {\n+        Self { foo }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    fn new(bar: u32) -> Self {\n+        Self { bar }\n+    }\n+    fn new2(bar: u32) -> Self {\n+        #[cfg(feature = \"foo\")]\n+        { Self { foo: bar } }\n+        #[cfg(not(feature = \"foo\"))]\n+        { Self { bar } }\n+    }\n+    fn new2(val: u32) -> Self {\n+        Self {\n+            #[cfg(feature = \"foo\")]\n+            foo: val,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: val,\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type { () => { u32 }; }\n+struct Foo { bar: Type![] }\n+\n+impl Foo {\n+    fn new() -> Self {\n+        Foo { bar: 0 }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) {\n+    let S { foo: _ } = s;\n+        //^^^^^^^^^^ Missing structure fields:\n+        //         | - bar\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n+        check_diagnostics(\n+            r\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) -> i32 {\n+    match s {\n+        S { foo, .. } => foo,\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn break_outside_of_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() { break; }\n+         //^^^^^ break outside of loop\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "f0e0f2988d5bd4e4758a53cbd047b6c56b8edde4", "filename": "crates/ra_hir_ty/src/diagnostics/expr.rs", "status": "renamed", "additions": 271, "deletions": 20, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -2,17 +2,19 @@\n \n use std::sync::Arc;\n \n-use hir_def::{path::path, resolver::HasResolver, AdtId, FunctionId};\n+use hir_def::{path::path, resolver::HasResolver, AdtId, DefWithBodyId};\n use hir_expand::diagnostics::DiagnosticSink;\n use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, MissingPatFields},\n+    diagnostics::{\n+        match_check::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n+        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr, MissingPatFields,\n+    },\n     utils::variant_data,\n     ApplicationTy, InferenceResult, Ty, TypeCtor,\n-    _match::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n };\n \n pub use hir_def::{\n@@ -24,26 +26,27 @@ pub use hir_def::{\n         ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n         MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n     },\n-    LocalFieldId, VariantId,\n+    src::HasSource,\n+    LocalFieldId, Lookup, VariantId,\n };\n \n-pub struct ExprValidator<'a, 'b: 'a> {\n-    func: FunctionId,\n+pub(super) struct ExprValidator<'a, 'b: 'a> {\n+    owner: DefWithBodyId,\n     infer: Arc<InferenceResult>,\n     sink: &'a mut DiagnosticSink<'b>,\n }\n \n impl<'a, 'b> ExprValidator<'a, 'b> {\n-    pub fn new(\n-        func: FunctionId,\n+    pub(super) fn new(\n+        owner: DefWithBodyId,\n         infer: Arc<InferenceResult>,\n         sink: &'a mut DiagnosticSink<'b>,\n     ) -> ExprValidator<'a, 'b> {\n-        ExprValidator { func, infer, sink }\n+        ExprValidator { owner, infer, sink }\n     }\n \n-    pub fn validate_body(&mut self, db: &dyn HirDatabase) {\n-        let body = db.body(self.func.into());\n+    pub(super) fn validate_body(&mut self, db: &dyn HirDatabase) {\n+        let body = db.body(self.owner.into());\n \n         for (id, expr) in body.exprs.iter() {\n             if let Some((variant_def, missed_fields, true)) =\n@@ -56,8 +59,15 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     missed_fields,\n                 );\n             }\n-            if let Expr::Match { expr, arms } = expr {\n-                self.validate_match(id, *expr, arms, db, self.infer.clone());\n+\n+            match expr {\n+                Expr::Match { expr, arms } => {\n+                    self.validate_match(id, *expr, arms, db, self.infer.clone());\n+                }\n+                Expr::Call { .. } | Expr::MethodCall { .. } => {\n+                    self.validate_call(db, id, expr);\n+                }\n+                _ => {}\n             }\n         }\n         for (id, pat) in body.pats.iter() {\n@@ -86,12 +96,12 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         missed_fields: Vec<LocalFieldId>,\n     ) {\n         // XXX: only look at source_map if we do have missing fields\n-        let (_, source_map) = db.body_with_source_map(self.func.into());\n+        let (_, source_map) = db.body_with_source_map(self.owner.into());\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {\n             let root = source_ptr.file_syntax(db.upcast());\n-            if let ast::Expr::RecordLit(record_lit) = &source_ptr.value.to_node(&root) {\n-                if let Some(field_list) = record_lit.record_field_list() {\n+            if let ast::Expr::RecordExpr(record_lit) = &source_ptr.value.to_node(&root) {\n+                if let Some(field_list) = record_lit.record_expr_field_list() {\n                     let variant_data = variant_data(db.upcast(), variant_def);\n                     let missed_fields = missed_fields\n                         .into_iter()\n@@ -115,7 +125,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         missed_fields: Vec<LocalFieldId>,\n     ) {\n         // XXX: only look at source_map if we do have missing fields\n-        let (_, source_map) = db.body_with_source_map(self.func.into());\n+        let (_, source_map) = db.body_with_source_map(self.owner.into());\n \n         if let Ok(source_ptr) = source_map.pat_syntax(id) {\n             if let Some(expr) = source_ptr.value.as_ref().left() {\n@@ -138,6 +148,65 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n+    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) -> Option<()> {\n+        // Check that the number of arguments matches the number of parameters.\n+\n+        // FIXME: Due to shortcomings in the current type system implementation, only emit this\n+        // diagnostic if there are no type mismatches in the containing function.\n+        if self.infer.type_mismatches.iter().next().is_some() {\n+            return Some(());\n+        }\n+\n+        let is_method_call = matches!(expr, Expr::MethodCall { .. });\n+        let (sig, args) = match expr {\n+            Expr::Call { callee, args } => {\n+                let callee = &self.infer.type_of_expr[*callee];\n+                let sig = callee.callable_sig(db)?;\n+                (sig, args.clone())\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                let mut args = args.clone();\n+                args.insert(0, *receiver);\n+\n+                // FIXME: note that we erase information about substs here. This\n+                // is not right, but, luckily, doesn't matter as we care only\n+                // about the number of params\n+                let callee = self.infer.method_resolution(call_id)?;\n+                let sig = db.callable_item_signature(callee.into()).value;\n+\n+                (sig, args)\n+            }\n+            _ => return None,\n+        };\n+\n+        if sig.is_varargs {\n+            return None;\n+        }\n+\n+        let params = sig.params();\n+\n+        let mut param_count = params.len();\n+        let mut arg_count = args.len();\n+\n+        if arg_count != param_count {\n+            let (_, source_map) = db.body_with_source_map(self.owner.into());\n+            if let Ok(source_ptr) = source_map.expr_syntax(call_id) {\n+                if is_method_call {\n+                    param_count -= 1;\n+                    arg_count -= 1;\n+                }\n+                self.sink.push(MismatchedArgCount {\n+                    file: source_ptr.file_id,\n+                    call_expr: source_ptr.value,\n+                    expected: param_count,\n+                    found: arg_count,\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn validate_match(\n         &mut self,\n         id: ExprId,\n@@ -147,7 +216,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         infer: Arc<InferenceResult>,\n     ) {\n         let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n-            db.body_with_source_map(self.func.into());\n+            db.body_with_source_map(self.owner.into());\n \n         let match_expr_ty = match infer.type_of_expr.get(match_expr) {\n             Some(ty) => ty,\n@@ -228,7 +297,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let core_result_path = path![core::result::Result];\n \n-        let resolver = self.func.resolver(db.upcast());\n+        let resolver = self.owner.resolver(db.upcast());\n         let core_result_enum = match resolver.resolve_known_enum(db.upcast(), &core_result_path) {\n             Some(it) => it,\n             _ => return,\n@@ -243,7 +312,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         };\n \n         if params.len() == 2 && params[0] == mismatch.actual {\n-            let (_, source_map) = db.body_with_source_map(self.func.into());\n+            let (_, source_map) = db.body_with_source_map(self.owner.into());\n \n             if let Ok(source_ptr) = source_map.expr_syntax(id) {\n                 self.sink\n@@ -312,3 +381,185 @@ pub fn record_pattern_missing_fields(\n     }\n     Some((variant_def, missed_fields, exhaustive))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn simple_free_fn_zero() {\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(1); }\n+       //^^^^^^^ Expected 0 arguments, found 1\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_free_fn_one() {\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(); }\n+       //^^^^^ Expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(1); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_as_fn() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method();\n+} //^^^^^^^^^^^ Expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method(&S);\n+    S.method();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_arg() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+            fn f() {\n+                S.method();\n+            } //^^^^^^^^^^ Expected 1 argument, found 0\n+            \"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+fn f() {\n+    S::method(&S, 0);\n+    S.method(1);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct Tup(u8, u16);\n+fn f() {\n+    Tup(0);\n+} //^^^^^^ Expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant() {\n+        check_diagnostics(\n+            r#\"\n+enum En { Variant(u8, u16), }\n+fn f() {\n+    En::Variant(0);\n+} //^^^^^^^^^^^^^^ Expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type {\n+    () => { u32 };\n+}\n+enum Foo {\n+    Bar(Type![])\n+}\n+impl Foo {\n+    fn new() {\n+        Foo::Bar(0);\n+        Foo::Bar(0, 1);\n+      //^^^^^^^^^^^^^^ Expected 1 argument, found 2\n+        Foo::Bar();\n+      //^^^^^^^^^^ Expected 1 argument, found 0\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn varargs() {\n+        check_diagnostics(\n+            r#\"\n+extern \"C\" {\n+    fn fixed(fixed: u8);\n+    fn varargs(fixed: u8, ...);\n+    fn varargs2(...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        fixed(0);\n+        fixed(0, 1);\n+      //^^^^^^^^^^^ Expected 1 argument, found 2\n+        varargs(0);\n+        varargs(0, 1);\n+        varargs2();\n+        varargs2(0);\n+        varargs2(0, 1);\n+    }\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_count_lambda() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let f = |()| ();\n+    f();\n+  //^^^ Expected 1 argument, found 0\n+    f(());\n+    f((), ());\n+  //^^^^^^^^^ Expected 1 argument, found 2\n+}\n+\"#,\n+        )\n+    }\n+}", "previous_filename": "crates/ra_hir_ty/src/expr.rs"}, {"sha": "507edcb7def8ca3cb8fcc629fb0ba0b260bbb895", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "renamed", "additions": 471, "deletions": 1207, "changes": 1678, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -41,9 +41,9 @@\n //! ```ignore\n //! // x: (Option<bool>, Result<()>)\n //! match x {\n-//!     (Some(true), _) => {}\n-//!     (None, Err(())) => {}\n-//!     (None, Err(_)) => {}\n+//!     (Some(true), _) => (),\n+//!     (None, Err(())) => (),\n+//!     (None, Err(_)) => (),\n //! }\n //! ```\n //!\n@@ -218,15 +218,16 @@\n //!   ```\n use std::sync::Arc;\n \n-use smallvec::{smallvec, SmallVec};\n-\n-use crate::{\n-    db::HirDatabase,\n-    expr::{Body, Expr, Literal, Pat, PatId},\n-    ApplicationTy, InferenceResult, Ty, TypeCtor,\n+use hir_def::{\n+    adt::VariantData,\n+    body::Body,\n+    expr::{Expr, Literal, Pat, PatId},\n+    AdtId, EnumVariantId, VariantId,\n };\n-use hir_def::{adt::VariantData, AdtId, EnumVariantId, VariantId};\n use ra_arena::Idx;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{db::HirDatabase, ApplicationTy, InferenceResult, Ty, TypeCtor};\n \n #[derive(Debug, Clone, Copy)]\n /// Either a pattern from the source code being analyzed, represented as\n@@ -271,7 +272,7 @@ impl From<&PatId> for PatIdOrWild {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n-pub enum MatchCheckErr {\n+pub(super) enum MatchCheckErr {\n     NotImplemented,\n     MalformedMatchArm,\n     /// Used when type inference cannot resolve the type of\n@@ -286,21 +287,21 @@ pub enum MatchCheckErr {\n ///\n /// The `std::result::Result` type is used here rather than a custom enum\n /// to allow the use of `?`.\n-pub type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n+pub(super) type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n \n #[derive(Debug)]\n /// A row in a Matrix.\n ///\n /// This type is modeled from the struct of the same name in `rustc`.\n-pub(crate) struct PatStack(PatStackInner);\n+pub(super) struct PatStack(PatStackInner);\n type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n \n impl PatStack {\n-    pub(crate) fn from_pattern(pat_id: PatId) -> PatStack {\n+    pub(super) fn from_pattern(pat_id: PatId) -> PatStack {\n         Self(smallvec!(pat_id.into()))\n     }\n \n-    pub(crate) fn from_wild() -> PatStack {\n+    pub(super) fn from_wild() -> PatStack {\n         Self(smallvec!(PatIdOrWild::Wild))\n     }\n \n@@ -509,14 +510,14 @@ impl PatStack {\n /// A collection of PatStack.\n ///\n /// This type is modeled from the struct of the same name in `rustc`.\n-pub(crate) struct Matrix(Vec<PatStack>);\n+pub(super) struct Matrix(Vec<PatStack>);\n \n impl Matrix {\n-    pub(crate) fn empty() -> Self {\n+    pub(super) fn empty() -> Self {\n         Self(vec![])\n     }\n \n-    pub(crate) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n+    pub(super) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n         if let Some(Pat::Or(pat_ids)) = row.get_head().map(|pat_id| pat_id.as_pat(cx)) {\n             // Or patterns are expanded here\n             for pat_id in pat_ids {\n@@ -578,16 +579,16 @@ impl Matrix {\n /// not matched by an prior match arms.\n ///\n /// We may eventually need an `Unknown` variant here.\n-pub enum Usefulness {\n+pub(super) enum Usefulness {\n     Useful,\n     NotUseful,\n }\n \n-pub struct MatchCheckCtx<'a> {\n-    pub match_expr: Idx<Expr>,\n-    pub body: Arc<Body>,\n-    pub infer: Arc<InferenceResult>,\n-    pub db: &'a dyn HirDatabase,\n+pub(super) struct MatchCheckCtx<'a> {\n+    pub(super) match_expr: Idx<Expr>,\n+    pub(super) body: Arc<Body>,\n+    pub(super) infer: Arc<InferenceResult>,\n+    pub(super) db: &'a dyn HirDatabase,\n }\n \n /// Given a set of patterns `matrix`, and pattern to consider `v`, determines\n@@ -598,7 +599,7 @@ pub struct MatchCheckCtx<'a> {\n /// expected that you have already type checked the match arms. All patterns in\n /// matrix should be the same type as v, as well as they should all be the same\n /// type as the match expression.\n-pub(crate) fn is_useful(\n+pub(super) fn is_useful(\n     cx: &MatchCheckCtx,\n     matrix: &Matrix,\n     v: &PatStack,\n@@ -836,1322 +837,585 @@ fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: Enum\n \n #[cfg(test)]\n mod tests {\n-    pub(super) use insta::assert_snapshot;\n-    pub(super) use ra_db::fixture::WithFixture;\n-\n-    pub(super) use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n-\n-    pub(super) fn check_diagnostic_message(ra_fixture: &str) -> String {\n-        TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().0\n-    }\n-\n-    pub(super) fn check_diagnostic(ra_fixture: &str) {\n-        let diagnostic_count =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n-\n-        assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n-    }\n-\n-    pub(super) fn check_no_diagnostic(ra_fixture: &str) {\n-        let (s, diagnostic_count) =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>();\n-\n-        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one: {}\", s);\n-    }\n-\n-    #[test]\n-    fn empty_tuple_no_arms_diagnostic_message() {\n-        assert_snapshot!(\n-            check_diagnostic_message(r\"\n-                fn test_fn() {\n-                    match () {\n-                    }\n-                }\n-            \"),\n-            @\"\\\"()\\\": Missing match arm\\n\"\n-        );\n-    }\n-\n-    #[test]\n-    fn empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn empty_tuple_wild() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                    _ => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                    () => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (()) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (()) {\n-                    (()) => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n-    fn tuple_of_two_empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match ((), ()) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match () { }\n+        //^^ Missing match arm\n+   match (()) { }\n+       //^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_two_empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match ((), ()) {\n-                    ((), ()) => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                    true => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                    true => {}\n-                    false => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, true) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                    (true, false) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_wilds() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (false, _) => {},\n-                    (true, false) => {},\n-                    (_, true) => {},\n-                }\n-            }\n-        \",\n+    match () { _ => (), }\n+    match () { () => (), }\n+    match (()) { (()) => (), }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_bools_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, true) => {},\n-                    (true, false) => {},\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn tuple_of_two_empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match ((), ()) { }\n+        //^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_bools_binding_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, _x) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_binding_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, _x) => {},\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                }\n-            }\n-        \",\n+    match ((), ()) { ((), ()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn boolean() {\n+        check_diagnostics(\n+            r#\"\n+fn test_main() {\n+    match false { }\n+        //^^^^^ Missing match arm\n+    match false { true => (), }\n+        //^^^^^ Missing match arm\n+    match (false, true) {}\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) { (true, true) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) {\n+        //^^^^^^^^^^^^^ Missing match arm\n+        (false, true) => (),\n+        (false, false) => (),\n+        (true, false) => (),\n+    }\n+    match (false, true) { (true, _x) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+\n+    match false { true => (), false => (), }\n+    match (false, true) {\n+        (false, _) => (),\n+        (true, false) => (),\n+        (_, true) => (),\n+    }\n+    match (false, true) {\n+        (true, true) => (),\n+        (true, false) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true) {\n+        (true, _x) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true, false) {\n+        (false, ..) => (),\n+        (true, ..) => (),\n+    }\n+    match (false, true, false) {\n+        (.., false) => (),\n+        (.., true) => (),\n+    }\n+    match (false, true, false) { (..) => (), }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (false, ..) => {},\n-                    (true, ..) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn tuple_of_tuple_and_bools() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, ((), false)) {}\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, ((), true)) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, _) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (.., false) => {},\n-                    (.., true) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, ((), true)) => (),\n+        (false, ((), false)) => (),\n     }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (..) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, _) => (),\n     }\n-\n-    #[test]\n-    fn tuple_of_tuple_and_bools_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_tuple_and_bools_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enums() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B, }\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                    (true, ((), false)) => {},\n-                    (false, ((), true)) => {},\n-                    (false, ((), false)) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+fn main() {\n+    match Either::A { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B { Either::A => (), }\n+        //^^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_wildcard_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, _) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match &Either::B {\n+        //^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n     }\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_wildcard_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                    (true, ((), false)) => {},\n-                    (false, _) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A => (), Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                }\n-            }\n-        \",\n-        );\n+    match &Either::B {\n+        Either::A => (), Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A => {},\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_containing_bool() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B }\n \n-    #[test]\n-    fn enum_ref_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match &Either::B {\n-                    Either::A => {},\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::B { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true) => (), Either::B => ()\n     }\n \n-    #[test]\n-    fn enum_ref_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match &Either::B {\n-                    Either::A => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A(true) => (),\n+        Either::A(false) => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_containing_bool_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::B => (),\n+        _ => (),\n     }\n-\n-    #[test]\n-    fn enum_containing_bool_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A(_) => (),\n+        Either::B => (),\n     }\n \n-    #[test]\n-    fn enum_containing_bool_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true) => (),\n-                    Either::A(false) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n+}\n+        \"#,\n         );\n     }\n \n     #[test]\n-    fn enum_containing_bool_with_wild_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::B => (),\n-                    _ => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_different_sizes() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n \n-    #[test]\n-    fn enum_containing_bool_with_wild_2_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(_) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::A(false) {\n+        //^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A(_) => (),\n+        Either::B(false, _) => (),\n     }\n \n-    #[test]\n-    fn enum_different_sizes_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(_) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::A(false) {\n+        Either::A(_) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n     }\n-\n-    #[test]\n-    fn enum_different_sizes_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(_) => (),\n-                    Either::B(true, _) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::A(false) {\n+        Either::A(true) | Either::A(false) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n     }\n-\n-    #[test]\n-    fn or_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(true) | Either::A(false) => (),\n-                    Either::B(true, _) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn tuple_of_enum_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            enum Either2 {\n-                C,\n-                D,\n-            }\n-            fn test_fn() {\n-                match (Either::A(false), Either2::C) {\n-                    (Either::A(true), _) | (Either::A(false), _) => (),\n-                    (Either::B(true, _), Either2::C) => (),\n-                    (Either::B(false, _), Either2::C) => (),\n-                    (Either::B(_, _), Either2::D) => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn mismatched_types() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            enum Either2 {\n-                C,\n-                D,\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                    Either2::C => (),\n-                    Either2::D => (),\n-                }\n-            }\n-        \",\n-        );\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match (Either::A(false), Either2::C) {\n+        (Either::A(true), _) | (Either::A(false), _) => (),\n+        (Either::B(true, _), Either2::C) => (),\n+        (Either::B(false, _), Either2::C) => (),\n+        (Either::B(_, _), Either2::D) => (),\n     }\n-\n-    #[test]\n-    fn mismatched_types_with_different_arity() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (true, false) {\n-                    (true, false, true) => (),\n-                    (true) => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn malformed_match_arm_tuple_missing_pattern() {\n+    fn mismatched_types() {\n         // Match statements with arms that don't match the\n         // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (0) {\n-                    () => (),\n-                }\n-            }\n-        \",\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match Either::A {\n+        Either2::C => (),\n+        Either2::D => (),\n+    }\n+    match (true, false) {\n+        (true, false, true) => (),\n+        (true) => (),\n+    }\n+    match (0) { () => () }\n+    match Unresolved::Bar { Unresolved::Baz => () }\n+}\n+        \"#,\n         );\n     }\n \n     #[test]\n     fn malformed_match_arm_tuple_enum_missing_pattern() {\n         // We are testing to be sure we don't panic here when the match\n         // arm `Either::B` is missing its pattern.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B(u32),\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                    Either::A => (),\n-                    Either::B() => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B(u32) }\n \n-    #[test]\n-    fn enum_not_in_scope() {\n-        // The enum is not in scope so we don't perform exhaustiveness\n-        // checking, but we want to be sure we don't panic here (and\n-        // we don't create a diagnostic).\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match Foo::Bar {\n-                    Foo::Baz => (),\n-                }\n-            }\n-        \",\n+fn main() {\n+    match Either::A {\n+        Either::A => (),\n+        Either::B() => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn expr_diverges() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n \n-    #[test]\n-    fn expr_loop_with_break() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop { break Foo::A } {\n-                    Either::A => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n+fn main() {\n+    match loop {} {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+    match loop {} {\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn expr_partially_diverges() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either<T> {\n-                A(T),\n-                B,\n-            }\n-            fn foo() -> Either<!> {\n-                Either::B\n-            }\n-            fn test_fn() -> u32 {\n-                match foo() {\n-                    Either::A(val) => val,\n-                    Either::B => 0,\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either<T> { A(T), B }\n \n-    #[test]\n-    fn enum_record_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                }\n-            }\n-        \",\n-        );\n+fn foo() -> Either<!> { Either::B }\n+fn main() -> u32 {\n+    match foo() {\n+        Either::A(val) => val,\n+        Either::B => 0,\n     }\n-\n-    #[test]\n-    fn enum_record_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true } => (),\n-                    Either::A { foo: false } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A { foo: bool }, B }\n \n-    #[test]\n-    fn enum_record_missing_field_no_diagnostic() {\n-        // When `Either::A` is missing a struct member, we don't want\n-        // to fire the missing match arm diagnostic. This should fire\n-        // some other diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::A { foo: true };\n+    match a { }\n+        //^ Missing match arm\n+    match a { Either::A { foo: true } => () }\n+        //^ Missing match arm\n+    match a {\n+        Either::A { } => (),\n+                //^^^ Missing structure fields:\n+                //  | - foo\n+        Either::B => (),\n     }\n+    match a {\n+        //^ Missing match arm\n+        Either::A { } => (),\n+    }           //^^^ Missing structure fields:\n+                //  | - foo\n \n-    #[test]\n-    fn enum_record_missing_field_missing_match_arm() {\n-        // Even though `Either::A` is missing fields, we still want to fire\n-        // the missing arm diagnostic here, since we know `Either::B` is missing.\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { } => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: true } => (),\n+        Either::A { foo: false } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_no_diagnostic_wild() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: _ } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: _ } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_fields_out_of_order_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: () },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { bar: (), foo: false } => (),\n-                    Either::A { foo: true, bar: () } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_fields_out_of_order_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: () },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { bar: (), foo: false } => (),\n-                    Either::A { foo: true, bar: () } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record_fields_out_of_order() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: () },\n+    B,\n+}\n \n-    #[test]\n-    fn enum_record_ellipsis_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A { foo: true, .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::A { foo: true, bar: () };\n+    match a {\n+        //^ Missing match arm\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n     }\n \n-    #[test]\n-    fn enum_record_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true, .. } => (),\n-                    Either::A { foo: false, .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_ellipsis_all_fields_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { .. } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_ellipsis_all_fields_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: bool },\n+    B,\n+}\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., true) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::B;\n+    match a {\n+        //^ Missing match arm\n+        Either::A { foo: true, .. } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(.., true) => {},\n-                    Either::A(.., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        //^ Missing match arm\n+        Either::A { .. } => (),\n     }\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: true, .. } => (),\n+        Either::A { foo: false, .. } => (),\n+        Either::B => (),\n     }\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_2_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(.., true) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { .. } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_tuple_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(..) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_never() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Never {}\n+    fn enum_tuple_partial_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A(bool, bool, bool, bool),\n+    B,\n+}\n \n-            fn test_fn(never: Never) {\n-                match never {}\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::B => (),\n+    }\n+\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., true) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::A(.., false) => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn type_never() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn(never: !) {\n-                match never {}\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_never_ref() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Never {}\n+    fn never() {\n+        check_diagnostics(\n+            r#\"\n+enum Never {}\n \n-            fn test_fn(never: &Never) {\n-                match never {}\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_diverges_missing_arm() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                }\n-            }\n-        \",\n+fn enum_(never: Never) {\n+    match never {}\n+}\n+fn enum_ref(never: &Never) {\n+    match never {}\n+}\n+fn bang(never: !) {\n+    match never {}\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn or_pattern_panic() {\n-        check_no_diagnostic(\n-            r\"\n-            pub enum Category {\n-                Infinity,\n-                Zero,\n-            }\n+        check_diagnostics(\n+            r#\"\n+pub enum Category { Infinity, Zero }\n \n-            fn panic(a: Category, b: Category) {\n-                match (a, b) {\n-                    (Category::Zero | Category::Infinity, _) => {}\n-                    (_, Category::Zero | Category::Infinity) => {}\n-                }\n-            }\n-        \",\n-        );\n+fn panic(a: Category, b: Category) {\n+    match (a, b) {\n+        (Category::Zero | Category::Infinity, _) => (),\n+        (_, Category::Zero | Category::Infinity) => (),\n     }\n \n-    #[test]\n-    fn or_pattern_panic_2() {\n-        // FIXME: This is a false positive, but the code used to cause a panic in the match checker,\n-        // so this acts as a regression test for that.\n-        check_diagnostic(\n-            r\"\n-            pub enum Category {\n-                Infinity,\n-                Zero,\n-            }\n-\n-            fn panic(a: Category, b: Category) {\n-                match (a, b) {\n-                    (Category::Infinity, Category::Infinity) | (Category::Zero, Category::Zero) => {}\n-\n-                    (Category::Infinity | Category::Zero, _) => {}\n-                }\n-            }\n-        \",\n-        );\n+    // FIXME: This is a false positive, but the code used to cause a panic in the match checker,\n+    // so this acts as a regression test for that.\n+    match (a, b) {\n+        //^^^^^^ Missing match arm\n+        (Category::Infinity, Category::Infinity) | (Category::Zero, Category::Zero) => (),\n+        (Category::Infinity | Category::Zero, _) => (),\n     }\n }\n-\n-#[cfg(test)]\n-mod false_negatives {\n-    //! The implementation of match checking here is a work in progress. As we roll this out, we\n-    //! prefer false negatives to false positives (ideally there would be no false positives). This\n-    //! test module should document known false negatives. Eventually we will have a complete\n-    //! implementation of match checking and this module will be empty.\n-    //!\n-    //! The reasons for documenting known false negatives:\n-    //!\n-    //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n-    //!   2. It ensures the code doesn't panic when handling these cases.\n-\n-    use super::tests::*;\n-\n-    #[test]\n-    fn integers() {\n-        // This is a false negative.\n-        // We don't currently check integer exhaustiveness.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match 5 {\n-                    10 => (),\n-                    11..20 => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn internal_or() {\n-        // This is a false negative.\n-        // We do not currently handle patterns with internal `or`s.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                enum Either {\n-                    A(bool),\n-                    B,\n-                }\n-                match Either::B {\n-                    Either::A(true | false) => (),\n-                }\n-            }\n-        \",\n-        );\n+\"#,\n+        );\n+    }\n+\n+    mod false_negatives {\n+        //! The implementation of match checking here is a work in progress. As we roll this out, we\n+        //! prefer false negatives to false positives (ideally there would be no false positives). This\n+        //! test module should document known false negatives. Eventually we will have a complete\n+        //! implementation of match checking and this module will be empty.\n+        //!\n+        //! The reasons for documenting known false negatives:\n+        //!\n+        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+        //!   2. It ensures the code doesn't panic when handling these cases.\n+        use super::*;\n+\n+        #[test]\n+        fn integers() {\n+            // We don't currently check integer exhaustiveness.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match 5 {\n+        10 => (),\n+        11..20 => (),\n     }\n+}\n+\"#,\n+            );\n+        }\n \n-    #[test]\n-    fn expr_loop_missing_arm() {\n-        // This is a false negative.\n-        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n-        // causes us to skip the diagnostic since `Either::A` doesn't type check\n-        // with `!`.\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop { break Foo::A } {\n-                    Either::A => (),\n-                }\n-            }\n-        \",\n-        );\n+        #[test]\n+        fn internal_or() {\n+            // We do not currently handle patterns with internal `or`s.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    enum Either { A(bool), B }\n+    match Either::B {\n+        Either::A(true | false) => (),\n     }\n+}\n+\"#,\n+            );\n+        }\n \n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (false, ..) => {},\n-                }\n-            }\n-        \",\n-        );\n+        #[test]\n+        fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+            // We don't currently handle tuple patterns with ellipsis.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (false, true, false) {\n+        (false, ..) => (),\n     }\n+}\n+\"#,\n+            );\n+        }\n \n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (.., false) => {},\n-                }\n-            }\n-        \",\n-        );\n+        #[test]\n+        fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+            // We don't currently handle tuple patterns with ellipsis.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (false, true, false) {\n+        (.., false) => (),\n     }\n+}\n+\"#,\n+            );\n+        }\n \n-    #[test]\n-    fn struct_missing_arm() {\n-        // This is a false negative.\n-        // We don't currently handle structs.\n-        check_no_diagnostic(\n-            r\"\n-            struct Foo {\n-                a: bool,\n-            }\n-            fn test_fn(f: Foo) {\n-                match f {\n-                    Foo { a: true } => {},\n-                }\n-            }\n-        \",\n-        );\n+        #[test]\n+        fn struct_missing_arm() {\n+            // We don't currently handle structs.\n+            check_diagnostics(\n+                r#\"\n+struct Foo { a: bool }\n+fn main(f: Foo) {\n+    match f { Foo { a: true } => () }\n+}\n+\"#,\n+            );\n+        }\n     }\n }", "previous_filename": "crates/ra_hir_ty/src/_match.rs"}, {"sha": "5cc76bdce411bc1c6102ca174233ba0bf919c9cd", "filename": "crates/ra_hir_ty/src/diagnostics/unsafe_check.rs", "status": "renamed", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,35 +6,38 @@ use std::sync::Arc;\n use hir_def::{\n     body::Body,\n     expr::{Expr, ExprId, UnaryOp},\n-    DefWithBodyId, FunctionId,\n+    DefWithBodyId,\n };\n use hir_expand::diagnostics::DiagnosticSink;\n \n use crate::{\n-    db::HirDatabase, diagnostics::MissingUnsafe, lower::CallableDef, ApplicationTy,\n+    db::HirDatabase, diagnostics::MissingUnsafe, lower::CallableDefId, ApplicationTy,\n     InferenceResult, Ty, TypeCtor,\n };\n \n-pub struct UnsafeValidator<'a, 'b: 'a> {\n-    func: FunctionId,\n+pub(super) struct UnsafeValidator<'a, 'b: 'a> {\n+    owner: DefWithBodyId,\n     infer: Arc<InferenceResult>,\n     sink: &'a mut DiagnosticSink<'b>,\n }\n \n impl<'a, 'b> UnsafeValidator<'a, 'b> {\n-    pub fn new(\n-        func: FunctionId,\n+    pub(super) fn new(\n+        owner: DefWithBodyId,\n         infer: Arc<InferenceResult>,\n         sink: &'a mut DiagnosticSink<'b>,\n     ) -> UnsafeValidator<'a, 'b> {\n-        UnsafeValidator { func, infer, sink }\n+        UnsafeValidator { owner, infer, sink }\n     }\n \n-    pub fn validate_body(&mut self, db: &dyn HirDatabase) {\n-        let def = self.func.into();\n+    pub(super) fn validate_body(&mut self, db: &dyn HirDatabase) {\n+        let def = self.owner.into();\n         let unsafe_expressions = unsafe_expressions(db, self.infer.as_ref(), def);\n-        let func_data = db.function_data(self.func);\n-        if func_data.is_unsafe\n+        let is_unsafe = match self.owner {\n+            DefWithBodyId::FunctionId(it) => db.function_data(it).is_unsafe,\n+            DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) => false,\n+        };\n+        if is_unsafe\n             || unsafe_expressions\n                 .iter()\n                 .filter(|unsafe_expr| !unsafe_expr.inside_unsafe_block)\n@@ -85,7 +88,7 @@ fn walk_unsafe(\n         Expr::Call { callee, .. } => {\n             let ty = &infer[*callee];\n             if let &Ty::Apply(ApplicationTy {\n-                ctor: TypeCtor::FnDef(CallableDef::FunctionId(func)),\n+                ctor: TypeCtor::FnDef(CallableDefId::FunctionId(func)),\n                 ..\n             }) = ty\n             {\n@@ -118,3 +121,53 @@ fn walk_unsafe(\n         walk_unsafe(unsafe_exprs, db, infer, body, child, inside_unsafe_block);\n     });\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_raw_ptr() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe { let y = *x; }\n+    let z = *x;\n+}         //^^ This operation is unsafe and requires an unsafe function or block\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_unsafe_call() {\n+        check_diagnostics(\n+            r#\"\n+struct HasUnsafe;\n+\n+impl HasUnsafe {\n+    unsafe fn unsafe_fn(&self) {\n+        let x = &5 as *const usize;\n+        let y = *x;\n+    }\n+}\n+\n+unsafe fn unsafe_fn() {\n+    let x = &5 as *const usize;\n+    let y = *x;\n+}\n+\n+fn main() {\n+    unsafe_fn();\n+  //^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    HasUnsafe.unsafe_fn();\n+  //^^^^^^^^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafe.unsafe_fn();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}", "previous_filename": "crates/ra_hir_ty/src/unsafe_validation.rs"}, {"sha": "19770e609afd3115bcd31bbb23aaddbb70d4aa8d", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -3,7 +3,7 @@\n use std::fmt;\n \n use crate::{\n-    db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n+    db::HirDatabase, utils::generics, ApplicationTy, CallableDefId, FnSig, GenericPredicate,\n     Obligation, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n use hir_def::{\n@@ -243,22 +243,36 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \")\")?;\n                 }\n             }\n-            TypeCtor::FnPtr { .. } => {\n-                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n+            TypeCtor::FnPtr { is_varargs, .. } => {\n+                let sig = FnSig::from_fn_ptr_substs(&self.parameters, is_varargs);\n                 write!(f, \"fn(\")?;\n                 f.write_joined(sig.params(), \", \")?;\n+                if is_varargs {\n+                    if sig.params().is_empty() {\n+                        write!(f, \"...\")?;\n+                    } else {\n+                        write!(f, \", ...\")?;\n+                    }\n+                }\n                 write!(f, \")\")?;\n                 let ret = sig.ret();\n                 if *ret != Ty::unit() {\n-                    write!(f, \" -> {}\", ret.display(f.db))?;\n+                    let ret_display = if f.omit_verbose_types() {\n+                        ret.display_truncated(f.db, f.max_size)\n+                    } else {\n+                        ret.display(f.db)\n+                    };\n+                    write!(f, \" -> {}\", ret_display)?;\n                 }\n             }\n             TypeCtor::FnDef(def) => {\n                 let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n                 match def {\n-                    CallableDef::FunctionId(ff) => write!(f, \"fn {}\", f.db.function_data(ff).name)?,\n-                    CallableDef::StructId(s) => write!(f, \"{}\", f.db.struct_data(s).name)?,\n-                    CallableDef::EnumVariantId(e) => {\n+                    CallableDefId::FunctionId(ff) => {\n+                        write!(f, \"fn {}\", f.db.function_data(ff).name)?\n+                    }\n+                    CallableDefId::StructId(s) => write!(f, \"{}\", f.db.struct_data(s).name)?,\n+                    CallableDefId::EnumVariantId(e) => {\n                         write!(f, \"{}\", f.db.enum_data(e.parent).variants[e.local_id].name)?\n                     }\n                 };\n@@ -279,7 +293,12 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \")\")?;\n                 let ret = sig.ret();\n                 if *ret != Ty::unit() {\n-                    write!(f, \" -> {}\", ret.display(f.db))?;\n+                    let ret_display = if f.omit_verbose_types() {\n+                        ret.display_truncated(f.db, f.max_size)\n+                    } else {\n+                        ret.display(f.db)\n+                    };\n+                    write!(f, \" -> {}\", ret_display)?;\n                 }\n             }\n             TypeCtor::Adt(def_id) => {\n@@ -369,7 +388,7 @@ impl HirDisplay for ApplicationTy {\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        data.clone().subst(&self.parameters)\n+                        data.subst(&self.parameters)\n                     }\n                 };\n                 write!(f, \"impl \")?;\n@@ -388,7 +407,13 @@ impl HirDisplay for ApplicationTy {\n                         f.write_joined(sig.params(), \", \")?;\n                         write!(f, \"|\")?;\n                     };\n-                    write!(f, \" -> {}\", sig.ret().display(f.db))?;\n+\n+                    let ret_display = if f.omit_verbose_types() {\n+                        sig.ret().display_truncated(f.db, f.max_size)\n+                    } else {\n+                        sig.ret().display(f.db)\n+                    };\n+                    write!(f, \" -> {}\", ret_display)?;\n                 } else {\n                     write!(f, \"{{closure}}\")?;\n                 }\n@@ -456,7 +481,7 @@ impl HirDisplay for Ty {\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        data.clone().subst(&opaque_ty.parameters)\n+                        data.subst(&opaque_ty.parameters)\n                     }\n                 };\n                 write!(f, \"impl \")?;"}, {"sha": "28f32a0a4de302310819b22748999fe0baaed6be", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -18,8 +18,6 @@ use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n-use rustc_hash::FxHashMap;\n-\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -28,13 +26,15 @@ use hir_def::{\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, TraitId, TypeAliasId,\n-    VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, Lookup, TraitId,\n+    TypeAliasId, VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n+use rustc_hash::FxHashMap;\n+use stdx::impl_from;\n \n use super::{\n     primitive::{FloatTy, IntTy},\n@@ -84,8 +84,7 @@ enum ExprOrPatId {\n     ExprId(ExprId),\n     PatId(PatId),\n }\n-\n-impl_froms!(ExprOrPatId: ExprId, PatId);\n+impl_from!(ExprId, PatId for ExprOrPatId);\n \n /// Binding modes inferred for patterns.\n /// https://doc.rust-lang.org/reference/patterns.html#binding-modes\n@@ -169,7 +168,7 @@ impl InferenceResult {\n     pub fn add_diagnostics(\n         &self,\n         db: &dyn HirDatabase,\n-        owner: FunctionId,\n+        owner: DefWithBodyId,\n         sink: &mut DiagnosticSink,\n     ) {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n@@ -376,17 +375,21 @@ impl<'a> InferenceContext<'a> {\n     ) -> Ty {\n         match assoc_ty {\n             Some(res_assoc_ty) => {\n+                let trait_ = match res_assoc_ty.lookup(self.db.upcast()).container {\n+                    hir_def::AssocContainerId::TraitId(trait_) => trait_,\n+                    _ => panic!(\"resolve_associated_type called with non-associated type\"),\n+                };\n                 let ty = self.table.new_type_var();\n-                let builder = Substs::build_for_def(self.db, res_assoc_ty)\n+                let substs = Substs::build_for_def(self.db, res_assoc_ty)\n                     .push(inner_ty)\n-                    .fill(params.iter().cloned());\n+                    .fill(params.iter().cloned())\n+                    .build();\n+                let trait_ref = TraitRef { trait_, substs: substs.clone() };\n                 let projection = ProjectionPredicate {\n                     ty: ty.clone(),\n-                    projection_ty: ProjectionTy {\n-                        associated_ty: res_assoc_ty,\n-                        parameters: builder.build(),\n-                    },\n+                    projection_ty: ProjectionTy { associated_ty: res_assoc_ty, parameters: substs },\n                 };\n+                self.obligations.push(Obligation::Trait(trait_ref));\n                 self.obligations.push(Obligation::Projection(projection));\n                 self.resolve_ty_as_possible(ty)\n             }\n@@ -757,7 +760,7 @@ impl std::ops::BitOrAssign for Diverges {\n }\n \n mod diagnostics {\n-    use hir_def::{expr::ExprId, FunctionId};\n+    use hir_def::{expr::ExprId, DefWithBodyId};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n     use crate::{\n@@ -775,17 +778,17 @@ mod diagnostics {\n         pub(super) fn add_to(\n             &self,\n             db: &dyn HirDatabase,\n-            owner: FunctionId,\n+            owner: DefWithBodyId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let (_, source_map) = db.body_with_source_map(owner);\n                     let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file: field.file_id, field: field.value })\n                 }\n                 InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n-                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let (_, source_map) = db.body_with_source_map(owner);\n                     let ptr = source_map\n                         .expr_syntax(*expr)\n                         .expect(\"break outside of loop in synthetic syntax\");"}, {"sha": "731b062c2da46c8349d9cef1b7b7609913af45d3", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     autoderef, method_resolution, op,\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n+    ApplicationTy, Binders, CallableDefId, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n     TraitRef, Ty, TypeCtor,\n };\n \n@@ -85,10 +85,8 @@ impl<'a> InferenceContext<'a> {\n             ctor: TypeCtor::Tuple { cardinality: num_args as u16 },\n             parameters,\n         });\n-        let substs = Substs::build_for_generics(&generic_params)\n-            .push(ty.clone())\n-            .push(arg_ty.clone())\n-            .build();\n+        let substs =\n+            Substs::build_for_generics(&generic_params).push(ty.clone()).push(arg_ty).build();\n \n         let trait_env = Arc::clone(&self.trait_env);\n         let implements_fn_trait =\n@@ -222,7 +220,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 sig_tys.push(ret_ty.clone());\n                 let sig_ty = Ty::apply(\n-                    TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n+                    TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1, is_varargs: false },\n                     Substs(sig_tys.clone().into()),\n                 );\n                 let closure_ty =\n@@ -407,8 +405,15 @@ impl<'a> InferenceContext<'a> {\n                                     .subst(&a_ty.parameters)\n                             })\n                         }\n-                        // FIXME:\n-                        TypeCtor::Adt(AdtId::UnionId(_)) => None,\n+                        TypeCtor::Adt(AdtId::UnionId(u)) => {\n+                            self.db.union_data(u).variant_data.field(name).map(|local_id| {\n+                                let field = FieldId { parent: u.into(), local_id };\n+                                self.write_field_resolution(tgt_expr, field);\n+                                self.db.field_types(u.into())[field.local_id]\n+                                    .clone()\n+                                    .subst(&a_ty.parameters)\n+                            })\n+                        }\n                         _ => None,\n                     },\n                     _ => None,\n@@ -849,7 +854,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 // add obligation for trait implementation, if this is a trait method\n                 match def {\n-                    CallableDef::FunctionId(f) => {\n+                    CallableDefId::FunctionId(f) => {\n                         if let AssocContainerId::TraitId(trait_) =\n                             f.lookup(self.db.upcast()).container\n                         {\n@@ -860,7 +865,7 @@ impl<'a> InferenceContext<'a> {\n                             self.obligations.push(Obligation::Trait(TraitRef { trait_, substs }));\n                         }\n                     }\n-                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {}\n+                    CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_) => {}\n                 }\n             }\n         }"}, {"sha": "2e895d911683c7f18b2cdace38d9b3a19a998cfb", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -9,7 +9,7 @@ use test_utils::mark;\n use super::{InferenceContext, Obligation};\n use crate::{\n     BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Substs, Ty,\n-    TypeCtor, TypeWalk,\n+    TyKind, TypeCtor, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -86,10 +86,20 @@ where\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n-        Canonicalized {\n-            value: Canonical { value: result, num_vars: self.free_vars.len() },\n-            free_vars: self.free_vars,\n-        }\n+        let kinds = self\n+            .free_vars\n+            .iter()\n+            .map(|v| match v {\n+                // mapping MaybeNeverTypeVar to the same kind as general ones\n+                // should be fine, because as opposed to int or float type vars,\n+                // they don't restrict what kind of type can go into them, they\n+                // just affect fallback.\n+                InferTy::TypeVar(_) | InferTy::MaybeNeverTypeVar(_) => TyKind::General,\n+                InferTy::IntVar(_) => TyKind::Integer,\n+                InferTy::FloatVar(_) => TyKind::Float,\n+            })\n+            .collect();\n+        Canonicalized { value: Canonical { value: result, kinds }, free_vars: self.free_vars }\n     }\n \n     pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n@@ -131,26 +141,41 @@ impl<T> Canonicalized<T> {\n         ty\n     }\n \n-    pub fn apply_solution(&self, ctx: &mut InferenceContext<'_>, solution: Canonical<Vec<Ty>>) {\n+    pub fn apply_solution(&self, ctx: &mut InferenceContext<'_>, solution: Canonical<Substs>) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.table.new_type_var()).collect());\n+        let new_vars = Substs(\n+            solution\n+                .kinds\n+                .iter()\n+                .map(|k| match k {\n+                    TyKind::General => ctx.table.new_type_var(),\n+                    TyKind::Integer => ctx.table.new_integer_var(),\n+                    TyKind::Float => ctx.table.new_float_var(),\n+                })\n+                .collect(),\n+        );\n         for (i, ty) in solution.value.into_iter().enumerate() {\n             let var = self.free_vars[i];\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n-            let ty = ctx.normalize_associated_types_in(ty.subst_bound_vars(&new_vars));\n+            let ty = ctx.normalize_associated_types_in(ty.clone().subst_bound_vars(&new_vars));\n             ctx.table.unify(&Ty::Infer(var), &ty);\n         }\n     }\n }\n \n-pub fn unify(ty1: &Canonical<Ty>, ty2: &Canonical<Ty>) -> Option<Substs> {\n+pub fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substs> {\n     let mut table = InferenceTable::new();\n-    let num_vars = ty1.num_vars.max(ty2.num_vars);\n-    let vars =\n-        Substs::builder(num_vars).fill(std::iter::repeat_with(|| table.new_type_var())).build();\n-    let ty1_with_vars = ty1.value.clone().subst_bound_vars(&vars);\n-    let ty2_with_vars = ty2.value.clone().subst_bound_vars(&vars);\n+    let vars = Substs(\n+        tys.kinds\n+            .iter()\n+            // we always use type vars here because we want everything to\n+            // fallback to Unknown in the end (kind of hacky, as below)\n+            .map(|_| table.new_type_var())\n+            .collect(),\n+    );\n+    let ty1_with_vars = tys.value.0.clone().subst_bound_vars(&vars);\n+    let ty2_with_vars = tys.value.1.clone().subst_bound_vars(&vars);\n     if !table.unify(&ty1_with_vars, &ty2_with_vars) {\n         return None;\n     }\n@@ -162,7 +187,7 @@ pub fn unify(ty1: &Canonical<Ty>, ty2: &Canonical<Ty>) -> Option<Substs> {\n         }\n     }\n     Some(\n-        Substs::builder(ty1.num_vars)\n+        Substs::builder(tys.kinds.len())\n             .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n             .build(),\n     )"}, {"sha": "7698cb0d4bb1b0ee3b505caa9809ac8194caa49b", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 40, "deletions": 67, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "patch": "@@ -6,75 +6,52 @@ macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n }\n \n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-            $($(\n-                impl From<$sv> for $e {\n-                    fn from(it: $sv) -> $e {\n-                        $e::$v($v::$sv(it))\n-                    }\n-                }\n-            )*)?\n-        )*\n-    }\n-}\n-\n mod autoderef;\n pub mod primitive;\n pub mod traits;\n pub mod method_resolution;\n mod op;\n mod lower;\n pub(crate) mod infer;\n-pub mod display;\n pub(crate) mod utils;\n+\n+pub mod display;\n pub mod db;\n pub mod diagnostics;\n-pub mod expr;\n-pub mod unsafe_validation;\n \n #[cfg(test)]\n mod tests;\n #[cfg(test)]\n mod test_db;\n-mod _match;\n \n-use std::ops::Deref;\n-use std::sync::Arc;\n-use std::{iter, mem};\n+use std::{iter, mem, ops::Deref, sync::Arc};\n \n use hir_def::{\n     expr::ExprId,\n     type_ref::{Mutability, Rawness},\n     AdtId, AssocContainerId, DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n     TypeParamId,\n };\n-use ra_db::{impl_intern_key, salsa, CrateId};\n+use itertools::Itertools;\n+use ra_db::{salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,\n+    display::HirDisplay,\n     primitive::{FloatTy, IntTy},\n     utils::{generics, make_mut_slice, Generics},\n };\n-use display::HirDisplay;\n \n pub use autoderef::autoderef;\n pub use infer::{InferTy, InferenceResult};\n-pub use lower::CallableDef;\n+pub use lower::CallableDefId;\n pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, ImplTraitLoweringMode, TyDefId,\n     TyLoweringContext, ValueTyDefId,\n };\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n pub use chalk_ir::{BoundVar, DebruijnIndex};\n-use itertools::Itertools;\n \n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or\n@@ -125,7 +102,7 @@ pub enum TypeCtor {\n     /// fn foo() -> i32 { 1 }\n     /// let bar = foo; // bar: fn() -> i32 {foo}\n     /// ```\n-    FnDef(CallableDef),\n+    FnDef(CallableDefId),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n@@ -135,7 +112,8 @@ pub enum TypeCtor {\n     /// fn foo() -> i32 { 1 }\n     /// let bar: fn() -> i32 = foo;\n     /// ```\n-    FnPtr { num_args: u16 },\n+    // FIXME make this a Ty variant like in Chalk\n+    FnPtr { num_args: u16, is_varargs: bool },\n \n     /// The never type `!`.\n     Never,\n@@ -162,19 +140,6 @@ pub enum TypeCtor {\n     Closure { def: DefWithBodyId, expr: ExprId },\n }\n \n-/// This exists just for Chalk, because Chalk just has a single `StructId` where\n-/// we have different kinds of ADTs, primitive types and special type\n-/// constructors like tuples and function pointers.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n-pub struct TypeCtorId(salsa::InternId);\n-impl_intern_key!(TypeCtorId);\n-\n-/// This exists just for Chalk, because Chalk just has a single `FnDefId` where\n-/// we have different IDs for struct and enum variant constructors.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n-pub struct CallableDefId(salsa::InternId);\n-impl_intern_key!(CallableDefId);\n-\n impl TypeCtor {\n     pub fn num_ty_params(self, db: &dyn HirDatabase) -> usize {\n         match self {\n@@ -210,7 +175,7 @@ impl TypeCtor {\n                     }\n                 }\n             }\n-            TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n+            TypeCtor::FnPtr { num_args, is_varargs: _ } => num_args as usize + 1,\n             TypeCtor::Tuple { cardinality } => cardinality as usize,\n         }\n     }\n@@ -662,33 +627,48 @@ impl TypeWalk for GenericPredicate {\n \n /// Basically a claim (currently not validated / checked) that the contained\n /// type / trait ref contains no inference variables; any inference variables it\n-/// contained have been replaced by bound variables, and `num_vars` tells us how\n-/// many there are. This is used to erase irrelevant differences between types\n-/// before using them in queries.\n+/// contained have been replaced by bound variables, and `kinds` tells us how\n+/// many there are and whether they were normal or float/int variables. This is\n+/// used to erase irrelevant differences between types before using them in\n+/// queries.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Canonical<T> {\n     pub value: T,\n-    pub num_vars: usize,\n+    pub kinds: Arc<[TyKind]>,\n+}\n+\n+impl<T> Canonical<T> {\n+    pub fn new(value: T, kinds: impl IntoIterator<Item = TyKind>) -> Self {\n+        Self { value, kinds: kinds.into_iter().collect() }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum TyKind {\n+    General,\n+    Integer,\n+    Float,\n }\n \n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FnSig {\n     params_and_return: Arc<[Ty]>,\n+    is_varargs: bool,\n }\n \n /// A polymorphic function signature.\n pub type PolyFnSig = Binders<FnSig>;\n \n impl FnSig {\n-    pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty) -> FnSig {\n+    pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty, is_varargs: bool) -> FnSig {\n         params.push(ret);\n-        FnSig { params_and_return: params.into() }\n+        FnSig { params_and_return: params.into(), is_varargs }\n     }\n \n-    pub fn from_fn_ptr_substs(substs: &Substs) -> FnSig {\n-        FnSig { params_and_return: Arc::clone(&substs.0) }\n+    pub fn from_fn_ptr_substs(substs: &Substs, is_varargs: bool) -> FnSig {\n+        FnSig { params_and_return: Arc::clone(&substs.0), is_varargs }\n     }\n \n     pub fn params(&self) -> &[Ty] {\n@@ -733,7 +713,7 @@ impl Ty {\n     }\n     pub fn fn_ptr(sig: FnSig) -> Self {\n         Ty::apply(\n-            TypeCtor::FnPtr { num_args: sig.params().len() as u16 },\n+            TypeCtor::FnPtr { num_args: sig.params().len() as u16, is_varargs: sig.is_varargs },\n             Substs(sig.params_and_return),\n         )\n     }\n@@ -787,15 +767,6 @@ impl Ty {\n         }\n     }\n \n-    pub fn as_callable(&self) -> Option<(CallableDef, &Substs)> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(callable_def), parameters }) => {\n-                Some((*callable_def, parameters))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     pub fn is_never(&self) -> bool {\n         matches!(self, Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }))\n     }\n@@ -827,10 +798,12 @@ impl Ty {\n         }\n     }\n \n-    fn callable_sig(&self, db: &dyn HirDatabase) -> Option<FnSig> {\n+    pub fn callable_sig(&self, db: &dyn HirDatabase) -> Option<FnSig> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n+                TypeCtor::FnPtr { is_varargs, .. } => {\n+                    Some(FnSig::from_fn_ptr_substs(&a_ty.parameters, is_varargs))\n+                }\n                 TypeCtor::FnDef(def) => {\n                     let sig = db.callable_item_signature(def);\n                     Some(sig.subst(&a_ty.parameters))\n@@ -877,7 +850,7 @@ impl Ty {\n                             let data = (*it)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            data.clone().subst(&opaque_ty.parameters)\n+                            data.subst(&opaque_ty.parameters)\n                         })\n                     }\n                 };"}, {"sha": "1eacc6f95ed8fe30ab1203387f9ac8b3bca75139", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "fb4b30a131fc1ddf2ad599c4bbccff0376e4b7ad", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 180, "deletions": 122, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a1714ff0fcd7da04b0dc852d47a5cb39f85c7b70", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 34, "deletions": 91, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "016e689fff22524e3d380e64b61bf98818b066b0", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 30, "deletions": 389, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "17efd75cb6b699538c7a97f49b8e6f7013e91185", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 735, "deletions": 651, "changes": 1386, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "24c53eb022251b16891a871c8684045be62e2d78", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 310, "deletions": 310, "changes": 620, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "fa68355aa84734d9b95dfaf72866c0bf6bc6f6cc", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 575, "deletions": 575, "changes": 1150, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "49538b572db3089cd3c33cb302deb6c65221ffac", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "modified", "additions": 156, "deletions": 159, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "39fabf7eb553da78447cfd7ea5af7aed6543e5d7", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 552, "deletions": 550, "changes": 1102, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "b9ab0f3576a9d3803e66b6bb0445c2ff33b039b9", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 599, "deletions": 538, "changes": 1137, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "3fd7d5cd4ffe62e17be68757cde70e48014d46ef", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 1711, "deletions": 1687, "changes": 3398, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "526e61cafb460df57245dfc5566f740cee682bf4", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 1771, "deletions": 1689, "changes": 3460, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "3f6d2cf35213052b34608b385a0a3f7ba6b414da", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 11, "deletions": 69, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "6d5f2d46a72cc56ba4382fe10b07c170586bd419", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "removed", "additions": 0, "deletions": 371, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=73ff610e41959e3e7c78a2b4b25b086883132956"}, {"sha": "1c7065364450c26d2da0e2ed2e50d9d888c9eed4", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 109, "deletions": 96, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "8d4c51a8ffda80b8f525ccfc69bcd31ed8e67f7d", "filename": "crates/ra_hir_ty/src/traits/chalk/interner.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "b3e92993d2dd3f5d4f28a18d3bcb3f0c6f6b0af6", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 137, "deletions": 96, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "db915625c2b3e1ebb5670672682f72b671eeea36", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "e3e2442680e8ec7946c19501c70e480fe40c482b", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "4e2ba6d619b43efe011c00fa8fc999dd6b1aa30f", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "1fcaf4a32b75d07ed5663e0d2ccb5e17e92b053f", "filename": "crates/ra_ide/src/call_hierarchy.rs", "status": "modified", "additions": 66, "deletions": 31, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "ff602202f2d9343aed849461c31dafc39b0d5a76", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 422, "deletions": 367, "changes": 789, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "68ac05e4ca94535e1fbe8b36993308c6ad6788eb", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "2faaae974607c875568bd91cebd48427b0d29d4f", "filename": "crates/ra_ide/src/completion/complete_attribute.rs", "status": "modified", "additions": 459, "deletions": 804, "changes": 1263, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "5326652852f0ba7cd055c421ab54b0e8f5a394a0", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 269, "deletions": 725, "changes": 994, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "4063342572bfcb8b31289184f7592d3019f4c0e8", "filename": "crates/ra_ide/src/completion/complete_fn_param.rs", "status": "modified", "additions": 79, "deletions": 82, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "b62064797b0b79e471006cceb04a725937b1332a", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 320, "deletions": 242, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "0447f0511515401aaf605dbaa727677ed9d0b2b6", "filename": "crates/ra_ide/src/completion/complete_macro_in_item_position.rs", "status": "modified", "additions": 17, "deletions": 120, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "aceb77cb5ccc2ddbbda05ec2f8ec9287b23e7414", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "modified", "additions": 38, "deletions": 88, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "8735b9010370b30a1fa35625d320b081c42f482e", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 123, "deletions": 512, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "b08f5b9b45e0bdfe07f21991e59cdc48302d687e", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 432, "deletions": 1074, "changes": 1506, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "74b94594dca697598f845c4de3f9b49743dfbd70", "filename": "crates/ra_ide/src/completion/complete_record.rs", "status": "modified", "additions": 183, "deletions": 363, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "28d8f787681314b8f9e831d702a669f70adb62e0", "filename": "crates/ra_ide/src/completion/complete_snippet.rs", "status": "modified", "additions": 29, "deletions": 77, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "d9a0ef167dbdc7cb2cc3e9ba614e6afa896fd08e", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 215, "deletions": 283, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bd9551f358a26f1cbce5ba638c1c1e01ea7c6097", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 424, "deletions": 1191, "changes": 1615, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "2113abbb224934a1e1c9eb10050185bf9b853ac2", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "7bdda316c458dbc76091fbeb144bc12d6a39709e", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a68861e1c9c4155df7811a7efb45a5fbeda4eae8", "filename": "crates/ra_ide/src/completion/patterns.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "9a94ff476710cb2560977adb7fa878a7a751af2e", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 693, "deletions": 982, "changes": 1675, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "9191777455be079f7942b1a010c1c5cf81bae96f", "filename": "crates/ra_ide/src/completion/test_utils.rs", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "dd8a7ffd9b6b4a42001aedb6a16c5ca34454d70b", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 417, "deletions": 496, "changes": 913, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "fd42aa4352e6280a23a64b2c5a6c85dc7cfe3d33", "filename": "crates/ra_ide/src/display.rs", "status": "modified", "additions": 41, "deletions": 55, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a98264fb33d655aae9fd74a49d9b9e440c182530", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "removed", "additions": 0, "deletions": 334, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=73ff610e41959e3e7c78a2b4b25b086883132956"}, {"sha": "45fbc86ef1baf88745034dcdf48c525a6bf18ead", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 125, "deletions": 82, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bddf1bd47474def5b96dc4a51638182b6b6bf221", "filename": "crates/ra_ide/src/display/short_label.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "aad5a8e4db69b5d4b57a7b4c0ca8567abaa6b9cb", "filename": "crates/ra_ide/src/display/structure.rs", "status": "removed", "additions": 0, "deletions": 438, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs?ref=73ff610e41959e3e7c78a2b4b25b086883132956"}, {"sha": "043515f541f76dad4e6b68ede29b4a9a5daa3a37", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 115, "deletions": 126, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "fc81b48ccef19acaa34a762e98164e06b752a3b1", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "91765140a45671450a30c31abc6a44f11a9d70d9", "filename": "crates/ra_ide/src/file_structure.rs", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "5a6e17936f94b068f28eeb9977e846702f97d34f", "filename": "crates/ra_ide/src/folding_ranges.rs", "status": "modified", "additions": 110, "deletions": 84, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "4e3f428fae78d8f0384b2879543f24c49e8ea4e2", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 572, "deletions": 596, "changes": 1168, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "9912b714214e8b4e338b664c86c7faa665c1a86a", "filename": "crates/ra_ide/src/goto_implementation.rs", "status": "modified", "additions": 116, "deletions": 95, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "8f52feea6e9cbe23b34c1e8a2fdc6551ee515d9c", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "ad68bc43c681e998350390f935c4c4f992b128d7", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 1714, "deletions": 1750, "changes": 3464, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "4bbbcd258f36025d98e2632c94c36e4ad23a346f", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 316, "deletions": 746, "changes": 1062, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "0fede0d87952db10d6094b88d39cbfcb27d172d8", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 37, "deletions": 105, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "60c193c40aba27b81111fcab406a69584de34f6d", "filename": "crates/ra_ide/src/markup.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fmarkup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fmarkup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarkup.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "cf2ee1bfadc564d17cd22da5c23519656f37cfa5", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "519e4bf1a255a88ee9aa545228121f657f62eeb0", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "31654bf791778954f480e0338ef207b343f71c78", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 519, "deletions": 582, "changes": 1101, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "3b7162b8416ba462fee1f7b9cd82d5e331bc283d", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 588, "deletions": 549, "changes": 1137, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "e8155def75eb6ccf9e52bf627b6a86bb5830372d", "filename": "crates/ra_ide/src/snapshots/highlight_doctest.html", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html?ref=73ff610e41959e3e7c78a2b4b25b086883132956"}, {"sha": "d184b569102401c8831c1f806d3634ad2b26e6a2", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=73ff610e41959e3e7c78a2b4b25b086883132956"}, {"sha": "8d0b38f958dcea4887e97477cfc5d756c8348a28", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/73ff610e41959e3e7c78a2b4b25b086883132956/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=73ff610e41959e3e7c78a2b4b25b086883132956"}, {"sha": "4348b43beb53bc39d0ac77ac225569cd7e939c2c", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "08e6f69cb302a1d88a3e0abcc24fd44aead9be08", "filename": "crates/ra_ide/src/status.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fstatus.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "e3a96f9d5c603851644b70aaa25e560fa520d9e7", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 84, "deletions": 30, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a5e7d28676dd7f46dbbe722f7c570368dd39c088", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "8665b480fdbee7d4ba079f83892400d5c4deed79", "filename": "crates/ra_ide/src/syntax_highlighting/injection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "49ec94bdcdb98d6b67fe02bd116a3776968f8408", "filename": "crates/ra_ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "87a6e2523b885bfb6456e287e6557d7cc19b758d", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "07217e8087a205fc683f0858b7da74bb92c6e7cb", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "d3ce744b44cb731d1732439bb0cf490032b4cfc7", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "143b1ae413ed1ce380fd5fc0d968e1dfd01018d2", "filename": "crates/ra_ide/src/typing/on_enter.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "6322d404fba5c6c7cab62278eecce9b22af4b45c", "filename": "crates/ra_ide/test_data/highlight_doctest.html", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_doctest.html?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "18addd00d283c68b13aa8dbd99b5b964c3e1d0c1", "filename": "crates/ra_ide/test_data/highlight_injection.html", "status": "renamed", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_injection.html?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "previous_filename": "crates/ra_ide/src/snapshots/highlight_injection.html"}, {"sha": "1b681b2c6b53b5e88c49766605429f4c832ff1c7", "filename": "crates/ra_ide/test_data/highlight_strings.html", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_strings.html?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "b81b6f1c3b9fe586ff276386818adbf8e1b4d647", "filename": "crates/ra_ide/test_data/highlight_unsafe.html", "status": "renamed", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "previous_filename": "crates/ra_ide/src/snapshots/highlight_unsafe.html"}, {"sha": "345a2f0231f26b5c034e20dff87e1cac43f2a343", "filename": "crates/ra_ide/test_data/highlighting.html", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlighting.html?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "401e87a73d3bc12d0e464d1f30b5caff9d03f59c", "filename": "crates/ra_ide/test_data/rainbow_highlighting.html", "status": "renamed", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide%2Ftest_data%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Frainbow_highlighting.html?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "previous_filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html"}, {"sha": "f345f1de8a0699d126687e0f54d57d1ef84cbd9d", "filename": "crates/ra_ide_db/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "32d9a8d1ffc5bb0f53dc6403aea55c55e64b0f67", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 53, "deletions": 34, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "80c99935d796af8820e2d8137e6f0716d0f6ccd1", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "1fba71ff85cb2305d348a4d0a4c3da24d02026c0", "filename": "crates/ra_ide_db/src/imports_locator.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "6900cac73e18ca9a11da5b162bde11ea2db77bf1", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "2ab662098a6425548a888188780932c10b01334e", "filename": "crates/ra_ide_db/src/line_index.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "0b862b449f7548cdedad228b938ee0a2f4eb52d5", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "abb83f421343d0fc6c71ff579da0e0d374bae260", "filename": "crates/ra_ide_db/src/source_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "35a2c5be3b2769eb4ee3463c5fd98b04e4b9dea5", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a26746a194371aa5a62e264ccff247275e5942c8", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "dec7ba22ea0bec832ada0def55d439ec18ae5021", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "f9e515b81189eab85772469a03810d21c658f5d9", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "5fc48507ff589d91d71b1ee6eafb6f8c60cb2b95", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "707e84f42ddfa3dad86e8300809f69cd7a1b7314", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "72ec3e4d9a36a19f6e935c0eef599e40ced3923f", "filename": "crates/ra_parser/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "c2e1d701e2247e2ccee1422e9a5de6f574951619", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "e1c25a838fb70eb32782137d6b23564d32b35713", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "cca524ceaa036be80ed1f4f2fa8634f79241e1a2", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "addfb59d4b1a98377f243d4bbb7c300a053aa10a", "filename": "crates/ra_parser/src/grammar/items/adt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "35ad766dcee8882f6bec5aa007182bb8a5590400", "filename": "crates/ra_parser/src/grammar/items/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "ef9c8ff5b03f2d00d2a2ad95d17f77d2b9d26a2e", "filename": "crates/ra_parser/src/grammar/items/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "8e836a77e1d4c27b11d39794dff9925b74b83a66", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "90dabb4c0f109c703d25e2356c58e5d27442e9be", "filename": "crates/ra_parser/src/grammar/type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "be4da67bcb03e5fe5498594ef6505f5d183583cc", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "c4b6e9e7bae1ba2bd8095acf7de65f9dc600d1b7", "filename": "crates/ra_proc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bc119a6c710227f23ece9cd3ae7c6709eebc83dd", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "1addbbd54fddd462d9c05b6938c058ff1f9604df", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "cb4b3bdb0d3eb8f99f2118cde2eb177fd3697e3c", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/client.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "273a977158862ba5632c236f21ca8fd4e5086314", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/closure.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "aeb05aad44810aed89ef19d1a64a31c3b2340d5b", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "cc32d5a6ddd59ba6be15dbd35357ff699907ec1b", "filename": "crates/ra_proc_macro_srv/src/rustc_server.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "8e6f28abdf50c7f3cbf9489272fcd65e729d56f4", "filename": "crates/ra_proc_macro_srv/src/tests/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "dcb00671ffb80c0a7c1deada655ed638627773bf", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "c82b9f76d4817873319ec5098738802e405d2c69", "filename": "crates/ra_prof/Cargo.toml", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "eb50965ae6f07e7ad032ed4696699f8f02697d6a", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "c2ecbd33cf4103b8acc8909b99ddc8b6ecdbdc76", "filename": "crates/ra_prof/src/memory_usage.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2Fsrc%2Fmemory_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2Fsrc%2Fmemory_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fmemory_usage.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "5e276190e5c0ace0b6a087977f917fdcc0657d67", "filename": "crates/ra_prof/src/stop_watch.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2Fsrc%2Fstop_watch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_prof%2Fsrc%2Fstop_watch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fstop_watch.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "99adea8e44b25c7dbc6e5f79607257bd2c5457f4", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "10513542e262d3b4c0d549463fa9c07fcdcddcf2", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bd50056c689f8fd95dcf2a8a37d7c7bd0a1bd048", "filename": "crates/ra_project_model/src/cfg_flag.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fcfg_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fcfg_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcfg_flag.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "300e751355b90fd15acb0ccfce99e6267065cf15", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 77, "deletions": 105, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "e3f3163f6af1042abec8b85142a8fc466056e70b", "filename": "crates/ra_project_model/src/project_json.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fproject_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fproject_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fproject_json.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a10ade3757aff5b4f6095b64d5bc4982ba513734", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 56, "deletions": 46, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "84e4b171e1beb4bc4b729334c10695719ba1cf47", "filename": "crates/ra_ssr/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "c02bacae6bfe68f2ed94a114011ecb805006844e", "filename": "crates/ra_ssr/src/errors.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ferrors.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "73abfecb2e1e2e8227a11a608e4d7cd6e5b3803f", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 230, "deletions": 78, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "74e15c631785d210a26a2c59c5872d75c5bd6c7c", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 260, "deletions": 121, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "b3e20579bda0d25492eb53febb239c9dc973683f", "filename": "crates/ra_ssr/src/nester.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fnester.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fnester.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fnester.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "78e03f394be5b6a42b1791e58262c745415c744a", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 188, "deletions": 71, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "0943244ff9f2a909c2fc37c0cfd396f03fcc80ca", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 167, "deletions": 37, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "78d45654674b2dc2fb61d50de73cf26aae4002e3", "filename": "crates/ra_ssr/src/resolving.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "213dc494fffcc5e88060cdb55b7a96b4cf61c146", "filename": "crates/ra_ssr/src/search.rs", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a4fa2cb4470855d50fc8ad55475bd84d3df849ae", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 692, "deletions": 271, "changes": 963, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "fc4d7aa048b80551460d2c2df9639cf4d3e7b58d", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "fd426ece9d0306f6c3d8a6f51508326201a4f0e0", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "8d3e42f256879ca09a3dde5e348bade560b41ae3", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "f5ba872233f9e7f6fbf60e1b22258d4e9e3546a5", "filename": "crates/ra_syntax/src/ast/expr_ext.rs", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "previous_filename": "crates/ra_syntax/src/ast/expr_extensions.rs"}, {"sha": "4306efe13624cb942fd8ab656f839f0289ce81b3", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1192, "deletions": 2658, "changes": 3850, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "509e8ae7a09823b7f2e69e412a3c00b673ebeace", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bba7310adeee914eec2672ebaf64785bbe24d52c", "filename": "crates/ra_syntax/src/ast/node_ext.rs", "status": "renamed", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "previous_filename": "crates/ra_syntax/src/ast/extensions.rs"}, {"sha": "c5ef92733d8462e03458b7c36cef1feaffafaf11", "filename": "crates/ra_syntax/src/ast/token_ext.rs", "status": "renamed", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6", "previous_filename": "crates/ra_syntax/src/ast/tokens.rs"}, {"sha": "3a56b1674c8d5d7be400ef76b5f5fd5f1ff75eb0", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "6203b62064d0f1a55af089fac65d5de75a215bed", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "6d1828d203946b0d7fe9b69731ee71c593be5301", "filename": "crates/ra_syntax/src/parsing/text_tree_sink.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "ca79577471321414ba7da95bfdde01e8f0cb7177", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a7dbdba7b115cae079246635aaa6c5483142734d", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "68cee8914930677d4bffe5a5df47a0f5d182f901", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 98, "deletions": 20, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "0325ab0b4209a7d1b5ddc2ee0e25df4f0ea40795", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "ad99014688586d447f12154a5c4730bb21d3b47c", "filename": "crates/ra_syntax/src/validation/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bbbf496c82de40fe356d88ccb045355f1173f6e2", "filename": "crates/ra_syntax/test_data/parser/err/0000_struct_field_missing_comma.rast", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0000_struct_field_missing_comma.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0000_struct_field_missing_comma.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0000_struct_field_missing_comma.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "6dc73bfdbae629b87f2079460814489f8fcc7cd1", "filename": "crates/ra_syntax/test_data/parser/err/0001_item_recovery_in_file.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0001_item_recovery_in_file.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0001_item_recovery_in_file.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0001_item_recovery_in_file.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "4cfd1bce4b1739768ff4b50796e921e9b1b42a30", "filename": "crates/ra_syntax/test_data/parser/err/0002_duplicate_shebang.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0002_duplicate_shebang.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0002_duplicate_shebang.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0002_duplicate_shebang.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "7763fad840b69062e8f7af2d4409086a4879e90b", "filename": "crates/ra_syntax/test_data/parser/err/0003_C++_semicolon.rast", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0003_C%2B%2B_semicolon.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0003_C%2B%2B_semicolon.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0003_C%2B%2B_semicolon.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "9a0f4665efc9981009ae559a266789794427a600", "filename": "crates/ra_syntax/test_data/parser/err/0004_use_path_bad_segment.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0004_use_path_bad_segment.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0004_use_path_bad_segment.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0004_use_path_bad_segment.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "4845a6563cb83c9bd4cfe1ff20faebba78091d0a", "filename": "crates/ra_syntax/test_data/parser/err/0005_attribute_recover.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0005_attribute_recover.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0005_attribute_recover.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0005_attribute_recover.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "5f85c3943ab9c95cdf531001ec28745eaa480a8a", "filename": "crates/ra_syntax/test_data/parser/err/0006_named_field_recovery.rast", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0006_named_field_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0006_named_field_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0006_named_field_recovery.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "560bfd7518602b02ddf027b2e91521a5d4afd317", "filename": "crates/ra_syntax/test_data/parser/err/0007_stray_curly_in_file.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0007_stray_curly_in_file.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0007_stray_curly_in_file.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0007_stray_curly_in_file.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "1e9637c26d57f21d906a689a0bf0b286dec4ac38", "filename": "crates/ra_syntax/test_data/parser/err/0008_item_block_recovery.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0008_item_block_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0008_item_block_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0008_item_block_recovery.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "dacf71aa16514eda790ddad05628b4a39b86c91c", "filename": "crates/ra_syntax/test_data/parser/err/0009_broken_struct_type_parameter.rast", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "1c3e0f65bfad367686f397585016f26e65ec6407", "filename": "crates/ra_syntax/test_data/parser/err/0010_unsafe_lambda_block.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "b02d390af9b6adcdbead6beb231437be87e9298d", "filename": "crates/ra_syntax/test_data/parser/err/0011_extern_struct.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0011_extern_struct.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0011_extern_struct.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0011_extern_struct.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "d62906b99b94f5b15e517cdfbc2e9d57e174916f", "filename": "crates/ra_syntax/test_data/parser/err/0012_broken_lambda.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0012_broken_lambda.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0012_broken_lambda.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0012_broken_lambda.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "3eef848fc8eedfc96630bcdd98bb0e8dd96db126", "filename": "crates/ra_syntax/test_data/parser/err/0013_invalid_type.rast", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a1f39b22a52b3c1528ae088ae7523d78368037f9", "filename": "crates/ra_syntax/test_data/parser/err/0014_where_no_bounds.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0014_where_no_bounds.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0014_where_no_bounds.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0014_where_no_bounds.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "a3c25b450a9870d7b157119c1023206bde4a8203", "filename": "crates/ra_syntax/test_data/parser/err/0015_curly_in_params.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0015_curly_in_params.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0015_curly_in_params.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0015_curly_in_params.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "66157c3dce9d78ce702a3aa5f33ce55ab08b6656", "filename": "crates/ra_syntax/test_data/parser/err/0016_missing_semi.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0016_missing_semi.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0016_missing_semi.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0016_missing_semi.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bb4a28f4e8b87d2c4e9f23b091aa334cbb42fc83", "filename": "crates/ra_syntax/test_data/parser/err/0017_incomplete_binexpr.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0017_incomplete_binexpr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0017_incomplete_binexpr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0017_incomplete_binexpr.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "bc95b851288d97df4d989e273ce002b533b306c4", "filename": "crates/ra_syntax/test_data/parser/err/0018_incomplete_fn.rast", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0018_incomplete_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0018_incomplete_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0018_incomplete_fn.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "f6fa964b7b91f847eecf3233919b5d671c9ec9e8", "filename": "crates/ra_syntax/test_data/parser/err/0019_let_recover.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0019_let_recover.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0019_let_recover.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0019_let_recover.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "6f6feba5a833e02c96a34bb7d3ba52d5013696fe", "filename": "crates/ra_syntax/test_data/parser/err/0020_fn_recover.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0020_fn_recover.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0020_fn_recover.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0020_fn_recover.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}, {"sha": "ba4ce47955d16aa61be304af9291acfd964deb42", "filename": "crates/ra_syntax/test_data/parser/err/0021_incomplete_param.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0021_incomplete_param.rast", "raw_url": "https://github.com/rust-lang/rust/raw/f05d7b41a719d848844b054a16477b29d0f063c6/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0021_incomplete_param.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0021_incomplete_param.rast?ref=f05d7b41a719d848844b054a16477b29d0f063c6"}]}