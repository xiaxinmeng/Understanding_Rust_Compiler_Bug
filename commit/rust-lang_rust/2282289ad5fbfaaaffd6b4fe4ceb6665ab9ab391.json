{"sha": "2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyODIyODlhZDVmYmZhYWFmZmQ2YjRmZTRjZWI2NjY1YWI5YWIzOTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-23T08:27:14Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-23T08:27:14Z"}, "message": "refactor away intermediate allocations, stage1", "tree": {"sha": "57f912e0998879ea452dd38d2787df6c7082baef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57f912e0998879ea452dd38d2787df6c7082baef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX5OdiAAoJEFbW7qD8Z6xGca4QAInnshFWMYgmKZ/5Z9xKgCir\nk4bIPwx043t+mrMRu3+/DqsshT85oS447WHOSLpbzX2CMh/J2xqHFo71uxIGwtVd\nrs8bFYtcYo/d4A1uRJrBUvohrVLAzrsqDTd4nyGIQN25LUnlsPWInmQB6KqtO1UO\nl7hBa3jFJudSlVFNo6+WMtqjVlb5+csGizlwlUNRUDzcWGqrcdpMA+YlLknX/GSQ\nHqmr2OdprVGnaZ5piugDOmGCaQ7oqfe8WQtVY4J8ej+1SU7ke86rXBoOgv+r1mFl\ngvlSls91dujETf9+E0DPENIk1PMoGb5n+bLoACaPAn0ylqlBLQzQwmfgF05puMQH\nsmLpSH/IAQsX0UJA+LTm4ijF3zF/YBk4wmKKwGFmN59C5krF7V0Dn1HU6e3fit2a\nEJUhtOrAqIRObXXGO6/KWwLzOEKHm3YuThrTBA3ZyR+wY7V+P2+Z+7iBcgFXVYEj\nII4br3t2CnsHfW7526xxoIy9iVQ0zzOFGHHDTW9TsIiYSS9gYwxNvwvvABiDf+iq\nLx8DDDhBHVEAZHHIyLsVdzQyzhbL0H6MbS+M/MTiEnzCNIqJ5NaSTsJ677NVYm7H\nYvDCZxxZhJocGTGeqX1I3USLnsFOYX17Ai5klXpE1UyhzwOGMWzBo5o4Mx5LjhbH\nbMUR6NSOpOxUh0cPQTuy\n=gYu9\n-----END PGP SIGNATURE-----", "payload": "tree 57f912e0998879ea452dd38d2787df6c7082baef\nparent 38748fa6150a99aaa16902ecd081a38bcfb92630\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474619234 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474619234 +0200\n\nrefactor away intermediate allocations, stage1"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "html_url": "https://github.com/rust-lang/rust/commit/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38748fa6150a99aaa16902ecd081a38bcfb92630", "url": "https://api.github.com/repos/rust-lang/rust/commits/38748fa6150a99aaa16902ecd081a38bcfb92630", "html_url": "https://github.com/rust-lang/rust/commit/38748fa6150a99aaa16902ecd081a38bcfb92630"}], "stats": {"total": 363, "additions": 233, "deletions": 130}, "files": [{"sha": "4f31cc210339c32efa79a4e975e137805d0a952c", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -28,6 +28,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             U64(u) => self.cast_const_int(u, ty, false),\n             FnPtr(ptr) |\n             Ptr(ptr) => self.cast_ptr(ptr, ty),\n+            VtablePtr(..) | SlicePtr(..) => unimplemented!(),\n         }\n     }\n "}, {"sha": "c30c47961daecb3019a5e3167324876eec6ceb6b", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 47, "deletions": 72, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -17,13 +17,15 @@ use syntax::codemap::{self, DUMMY_SP};\n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer, AllocId};\n use primval::{self, PrimVal};\n+use self::value::Value;\n \n use std::collections::HashMap;\n \n mod step;\n mod terminator;\n mod cast;\n mod vtable;\n+mod value;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -99,21 +101,6 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub stmt: usize,\n }\n \n-/// A `Value` represents a single self-contained Rust value.\n-///\n-/// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitve\n-/// value held directly, outside of any allocation (`ByVal`).\n-///\n-/// For optimization of a few very common cases, there is also a representation for a pair of\n-/// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n-/// operations and fat pointers. This idea was taken from rustc's trans.\n-#[derive(Clone, Copy, Debug)]\n-enum Value {\n-    ByRef(Pointer),\n-    ByVal(PrimVal),\n-    ByValPair(PrimVal, PrimVal),\n-}\n-\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n struct Lvalue {\n     ptr: Pointer,\n@@ -245,10 +232,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.memory.allocate(s.len(), 1)?;\n                 self.memory.write_bytes(ptr, s.as_bytes())?;\n                 self.memory.freeze(ptr.alloc_id)?;\n-                Value::ByValPair(\n-                    PrimVal::Ptr(ptr),\n-                    self.target_usize_primval(s.len() as u64)\n-                )\n+                Value::ByVal(PrimVal::SlicePtr(ptr, s.len() as u64))\n             }\n \n             ByteStr(ref bs) => {\n@@ -618,13 +602,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n-                        let src = self.eval_operand_to_ptr(operand)?;\n+                        let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         let dest_ty = self.monomorphize(dest_ty, self.substs());\n                         // FIXME: cases where dest_ty is not a fat pointer. e.g. Arc<Struct> -> Arc<Trait>\n                         assert!(self.type_is_fat_ptr(dest_ty));\n                         let (ptr, extra) = self.get_fat_ptr(dest);\n-                        self.move_(src, ptr, src_ty)?;\n+                        self.move_value(src, ptr, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n \n@@ -639,9 +623,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 // For now, upcasts are limited to changes in marker\n                                 // traits, and hence never actually require an actual\n                                 // change to the vtable.\n-                                let (_, src_extra) = self.get_fat_ptr(src);\n-                                let src_extra = self.memory.read_ptr(src_extra)?;\n-                                self.memory.write_ptr(extra, src_extra)?;\n+                                let src_extra = src.expect_fat_ptr_extra(&self.memory)?;\n+                                self.memory.write_primval(extra, src_extra)?;\n                             },\n                             (_, &ty::TyTrait(ref data)) => {\n                                 let trait_ref = data.principal.with_self_ty(self.tcx, src_pointee_ty);\n@@ -655,25 +638,36 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     Misc => {\n-                        let src = self.eval_operand_to_ptr(operand)?;\n+                        let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n+                        // FIXME: dest_ty should already be monomorphized\n+                        let dest_ty = self.monomorphize(dest_ty, self.substs());\n                         if self.type_is_fat_ptr(src_ty) {\n-                            let (data_ptr, _meta_ptr) = self.get_fat_ptr(src);\n+                            trace!(\"misc cast: {:?}\", src);\n                             let ptr_size = self.memory.pointer_size();\n-                            let dest_ty = self.monomorphize(dest_ty, self.substs());\n-                            if self.type_is_fat_ptr(dest_ty) {\n-                                // FIXME: add assertion that the extra part of the src_ty and\n-                                // dest_ty is of the same type\n-                                self.memory.copy(data_ptr, dest, ptr_size * 2, ptr_size)?;\n-                            } else { // cast to thin-ptr\n-                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n-                                // pointer-cast of that pointer to desired pointer type.\n-                                self.memory.copy(data_ptr, dest, ptr_size, ptr_size)?;\n+                            match (src, self.type_is_fat_ptr(dest_ty)) {\n+                                (Value::ByVal(PrimVal::VtablePtr(data, meta)), true) => {\n+                                    self.memory.write_ptr(dest, data)?;\n+                                    self.memory.write_ptr(dest.offset(ptr_size as isize), meta)?;\n+                                },\n+                                (Value::ByVal(PrimVal::SlicePtr(data, meta)), true) => {\n+                                    self.memory.write_ptr(dest, data)?;\n+                                    self.memory.write_usize(dest.offset(ptr_size as isize), meta)?;\n+                                },\n+                                (Value::ByVal(PrimVal::SlicePtr(data, _)), false) |\n+                                (Value::ByVal(PrimVal::VtablePtr(data, _)), false) => {\n+                                    self.memory.write_ptr(dest, data)?;\n+                                },\n+                                (Value::ByRef(ptr), true) => {\n+                                    self.memory.copy(ptr, dest, ptr_size * 2, ptr_size)?;\n+                                },\n+                                (Value::ByRef(ptr), false) => {\n+                                    self.memory.copy(ptr, dest, ptr_size, ptr_size)?;\n+                                },\n+                                (Value::ByVal(_), _) => bug!(\"expected fat ptr\"),\n                             }\n                         } else {\n-                            // FIXME: dest_ty should already be monomorphized\n-                            let dest_ty = self.monomorphize(dest_ty, self.substs());\n-                            let src_val = self.read_primval(src, src_ty)?;\n+                            let src_val = self.value_to_primval(src, src_ty)?;\n                             let dest_val = self.cast_primval(src_val, dest_ty)?;\n                             self.memory.write_primval(dest, dest_val)?;\n                         }\n@@ -689,8 +683,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     UnsafeFnPointer => match dest_ty.sty {\n                         ty::TyFnPtr(unsafe_fn_ty) => {\n-                            let src = self.eval_operand_to_ptr(operand)?;\n-                            let ptr = self.memory.read_ptr(src)?;\n+                            let src = self.eval_operand(operand)?;\n+                            let ptr = src.read_ptr(&self.memory)?;\n                             let (def_id, substs, _) = self.memory.get_fn(ptr.alloc_id)?;\n                             let fn_ptr = self.memory.create_fn_ptr(def_id, substs, unsafe_fn_ty);\n                             self.memory.write_ptr(dest, fn_ptr)?;\n@@ -779,14 +773,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n-    // remove it as soon as PrimVal can represent fat pointers.\n-    fn eval_operand_to_ptr(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        let value = self.eval_operand(op)?;\n-        let ty = self.operand_ty(op);\n-        self.value_to_ptr(value, ty)\n-    }\n-\n     fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);\n@@ -857,6 +843,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n+                trace!(\"projection base: {:?}\", base);\n+                trace!(\"projection: {:?}\", proj.elem);\n                 let base_ty = self.lvalue_ty(&proj.base);\n                 let base_layout = self.type_layout(base_ty);\n \n@@ -937,8 +925,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             ty::TySlice(elem_ty) => self.type_size(elem_ty),\n                             _ => bug!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n-                        let n_ptr = self.eval_operand_to_ptr(operand)?;\n-                        let n = self.memory.read_usize(n_ptr)?;\n+                        let n_ptr = self.eval_operand(operand)?;\n+                        let usize = self.tcx.types.usize;\n+                        let n = self.value_to_primval(n_ptr, usize)?.expect_uint(\"Projection::Index expected usize\");\n                         base.ptr.offset(n as isize * elem_size as isize)\n                     }\n \n@@ -965,6 +954,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(operand.ty(&self.mir(), self.tcx), self.substs())\n     }\n \n+    fn move_value(&mut self, src: Value, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n+        match src {\n+            Value::ByRef(ptr) => self.move_(ptr, dest, ty),\n+            Value::ByVal(val) => self.memory.write_primval(dest, val),\n+        }\n+    }\n+\n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         let size = self.type_size(ty);\n         let align = self.type_align(ty);\n@@ -974,7 +970,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n     // remove it as soon as PrimVal can represent fat pointers.\n-    fn value_to_ptr(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    fn value_to_ptr_dont_use(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n         match value {\n             Value::ByRef(ptr) => Ok(ptr),\n \n@@ -985,18 +981,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_primval(ptr, primval)?;\n                 Ok(ptr)\n             }\n-\n-            Value::ByValPair(primval1, primval2) => {\n-                let size = self.type_size(ty);\n-                let align = self.type_align(ty);\n-                let ptr = self.memory.allocate(size, align)?;\n-\n-                // FIXME(solson): Major dangerous assumptions here. Ideally obliterate this\n-                // function.\n-                self.memory.write_primval(ptr, primval1)?;\n-                self.memory.write_primval(ptr.offset((size / 2) as isize), primval2)?;\n-                Ok(ptr)\n-            }\n         }\n     }\n \n@@ -1006,7 +990,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // TODO(solson): Sanity-check the primval type against the input type.\n             Value::ByVal(primval) => Ok(primval),\n-            Value::ByValPair(..) => bug!(\"can't turn a ByValPair into a single PrimVal\"),\n         }\n     }\n \n@@ -1019,14 +1002,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match value {\n             Value::ByRef(ptr) => self.move_(ptr, dest, dest_ty),\n             Value::ByVal(primval) => self.memory.write_primval(dest, primval),\n-            Value::ByValPair(primval1, primval2) => {\n-                let size = self.type_size(dest_ty);\n-\n-                // FIXME(solson): Major dangerous assumptions here.\n-                self.memory.write_primval(dest, primval1)?;\n-                self.memory.write_primval(dest.offset((size / 2) as isize), primval2)?;\n-                Ok(())\n-            }\n         }\n     }\n "}, {"sha": "94ab3014ffd3f359c3e68c41c4388dc7b29ba8bb", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 55, "deletions": 40, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -7,7 +7,8 @@ use rustc::ty;\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n use interpreter::EvalContext;\n-use primval;\n+use primval::{self, PrimVal};\n+use interpreter::value::Value;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n@@ -18,27 +19,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Pointer,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n-        // TODO(solson): We can probably remove this _to_ptr easily.\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand_to_ptr(arg))\n+        let args_ptrs: EvalResult<Vec<Value>> = args.iter()\n+            .map(|arg| self.eval_operand(arg))\n             .collect();\n-        let args_ptrs = args_res?;\n+        let args_ptrs = args_ptrs?;\n         let pointer_size = self.memory.pointer_size();\n+        let i32 = self.tcx.types.i32;\n+        let isize = self.tcx.types.isize;\n+        let usize = self.tcx.types.usize;\n+        let f32 = self.tcx.types.f32;\n+        let f64 = self.tcx.types.f64;\n \n         match &self.tcx.item_name(def_id).as_str()[..] {\n             \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n             \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n             \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n \n             \"arith_offset\" => {\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                let offset = self.memory.read_int(args_ptrs[1], pointer_size)?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n+                let offset = self.value_to_primval(args_ptrs[1], isize)?.expect_int(\"arith_offset second arg not isize\");\n                 let new_ptr = ptr.offset(offset as isize);\n                 self.memory.write_ptr(dest, new_ptr)?;\n             }\n \n             \"assume\" => {\n-                if !self.memory.read_bool(args_ptrs[0])? {\n+                let bool = self.tcx.types.bool;\n+                if !self.value_to_primval(args_ptrs[0], bool)?.expect_bool(\"assume arg not bool\") {\n                     return Err(EvalError::AssumptionNotHeld);\n                 }\n             }\n@@ -51,47 +57,59 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty);\n                 let elem_align = self.type_align(elem_ty);\n-                let src = self.memory.read_ptr(args_ptrs[0])?;\n-                let dest = self.memory.read_ptr(args_ptrs[1])?;\n-                let count = self.memory.read_isize(args_ptrs[2])?;\n+                let src = args_ptrs[0].read_ptr(&self.memory)?;\n+                let dest = args_ptrs[1].read_ptr(&self.memory)?;\n+                let count = self.value_to_primval(args_ptrs[2], usize)?.expect_uint(\"arith_offset second arg not isize\");\n                 self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n             }\n \n             \"ctpop\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.count_ones();\n+                let num = self.value_to_primval(args_ptrs[2], elem_ty)?.expect_int(\"ctpop second arg not integral\");\n+                let num = num.count_ones();\n                 self.memory.write_uint(dest, num.into(), elem_size)?;\n             }\n \n             \"ctlz\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.leading_zeros();\n+                let num = self.value_to_primval(args_ptrs[2], elem_ty)?;\n+                let num = match num {\n+                    PrimVal::I8(i) => i.leading_zeros(),\n+                    PrimVal::U8(i) => i.leading_zeros(),\n+                    PrimVal::I16(i) => i.leading_zeros(),\n+                    PrimVal::U16(i) => i.leading_zeros(),\n+                    PrimVal::I32(i) => i.leading_zeros(),\n+                    PrimVal::U32(i) => i.leading_zeros(),\n+                    PrimVal::I64(i) => i.leading_zeros(),\n+                    PrimVal::U64(i) => i.leading_zeros(),\n+                    _ => bug!(\"ctlz called with non-integer type\"),\n+                };\n                 self.memory.write_uint(dest, num.into(), elem_size)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let adt_ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.memory.write_uint(dest, discr_val, 8)?;\n             }\n \n             \"fabsf32\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[2], f32)?.expect_f32(\"fabsf32 read non f32\");\n                 self.memory.write_f32(dest, f.abs())?;\n             }\n \n             \"fabsf64\" => {\n-                let f = self.memory.read_f64(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[2], f64)?.expect_f64(\"fabsf64 read non f64\");\n                 self.memory.write_f64(dest, f.abs())?;\n             }\n \n             \"fadd_fast\" => {\n                 let ty = substs.type_at(0);\n-                let a = self.read_primval(args_ptrs[0], ty)?;\n-                let b = self.read_primval(args_ptrs[0], ty)?;\n+                let a = self.value_to_primval(args_ptrs[0], ty)?;\n+                let b = self.value_to_primval(args_ptrs[0], ty)?;\n                 let result = primval::binary_op(mir::BinOp::Add, a, b)?;\n                 self.memory.write_primval(dest, result.0)?;\n             }\n@@ -117,8 +135,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                self.move_(args_ptrs[1], ptr, ty)?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n+                self.move_value(args_ptrs[1], ptr, ty)?;\n             }\n \n             \"needs_drop\" => {\n@@ -129,10 +147,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n                 let pointee_size = self.type_size(pointee_ty) as isize;\n-                let ptr_arg = args_ptrs[0];\n-                let offset = self.memory.read_isize(args_ptrs[1])?;\n+                let offset = self.value_to_primval(args_ptrs[1], isize)?.expect_int(\"offset second arg not isize\");\n \n-                let ptr = self.memory.read_ptr(ptr_arg)?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.offset(offset as isize * pointee_size);\n                 self.memory.write_ptr(dest, result_ptr)?;\n             }\n@@ -150,24 +167,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"powif32\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n-                let i = self.memory.read_int(args_ptrs[1], 4)?;\n+                let f = self.value_to_primval(args_ptrs[0], f32)?.expect_f32(\"powif32 first arg not f32\");\n+                let i = self.value_to_primval(args_ptrs[1], i32)?.expect_int(\"powif32 second arg not i32\");\n                 self.memory.write_f32(dest, f.powi(i as i32))?;\n             }\n \n             \"powif64\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n-                let i = self.memory.read_int(args_ptrs[1], 4)?;\n-                self.memory.write_f32(dest, f.powi(i as i32))?;\n+                let f = self.value_to_primval(args_ptrs[0], f64)?.expect_f64(\"powif64 first arg not f64\");\n+                let i = self.value_to_primval(args_ptrs[1], i32)?.expect_int(\"powif64 second arg not i32\");\n+                self.memory.write_f64(dest, f.powi(i as i32))?;\n             }\n \n             \"sqrtf32\" => {\n-                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[0], f32)?.expect_f32(\"sqrtf32 first arg not f32\");\n                 self.memory.write_f32(dest, f.sqrt())?;\n             }\n \n             \"sqrtf64\" => {\n-                let f = self.memory.read_f64(args_ptrs[0])?;\n+                let f = self.value_to_primval(args_ptrs[0], f64)?.expect_f64(\"sqrtf64 first arg not f64\");\n                 self.memory.write_f64(dest, f.sqrt())?;\n             }\n \n@@ -198,7 +215,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"transmute\" => {\n                 let ty = substs.type_at(0);\n-                self.move_(args_ptrs[0], dest, ty)?;\n+                self.move_value(args_ptrs[0], dest, ty)?;\n             }\n \n             \"try\" => unimplemented!(),\n@@ -207,14 +224,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 self.move_(ptr, dest, ty)?;\n             }\n \n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = self.memory.read_ptr(args_ptrs[0])?;\n-                self.move_(args_ptrs[1], dest, ty)?;\n+                let dest = args_ptrs[0].read_ptr(&self.memory)?;\n+                self.move_value(args_ptrs[1], dest, ty)?;\n             }\n \n             name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n@@ -229,7 +246,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn size_and_align_of_dst(\n         &self,\n         ty: ty::Ty<'tcx>,\n-        value: Pointer,\n+        value: Value,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n         if self.type_is_sized(ty) {\n@@ -306,8 +323,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n                 ty::TyTrait(..) => {\n-                    let (_, vtable) = self.get_fat_ptr(value);\n-                    let vtable = self.memory.read_ptr(vtable)?;\n+                    let vtable = value.expect_vtable(&self.memory)?;\n                     // the second entry in the vtable is the dynamic size of the object.\n                     let size = self.memory.read_usize(vtable.offset(pointer_size as isize))?;\n                     let align = self.memory.read_usize(vtable.offset(pointer_size as isize * 2))?;\n@@ -317,10 +333,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n                     let elem_size = self.type_size(elem_ty) as u64;\n-                    let (_, len_ptr) = self.get_fat_ptr(value);\n-                    let n = self.memory.read_usize(len_ptr)?;\n+                    let len = value.expect_slice_len(&self.memory)?;\n                     let align = self.type_align(elem_ty);\n-                    Ok((n * elem_size, align as u64))\n+                    Ok((len * elem_size, align as u64))\n                 }\n \n                 _ => bug!(\"size_of_val::<{:?}>\", ty),"}, {"sha": "3a4e2f5ff842483f1cc1469389f5797c89bbf5ed", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -14,7 +14,8 @@ use syntax::{ast, attr};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n use primval::PrimVal;\n-use super::{EvalContext, IntegerExt, StackPopCleanup, Value};\n+use super::{EvalContext, IntegerExt, StackPopCleanup};\n+use super::value::Value;\n \n mod intrinsics;\n \n@@ -265,9 +266,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             None => name.as_str(),\n         };\n \n-        // TODO(solson): We can probably remove this _to_ptr easily.\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand_to_ptr(arg))\n+        let args_res: EvalResult<Vec<Value>> = args.iter()\n+            .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args = args_res?;\n \n@@ -276,26 +276,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             return Ok(());\n         }\n \n+        let usize = self.tcx.types.usize;\n+\n         match &link_name[..] {\n             \"__rust_allocate\" => {\n-                let size = self.memory.read_usize(args[0])?;\n-                let align = self.memory.read_usize(args[1])?;\n+                let size = self.value_to_primval(args[0], usize)?.expect_uint(\"__rust_allocate first arg not usize\");\n+                let align = self.value_to_primval(args[1], usize)?.expect_uint(\"__rust_allocate second arg not usize\");\n                 let ptr = self.memory.allocate(size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n             \"__rust_reallocate\" => {\n-                let ptr = self.memory.read_ptr(args[0])?;\n-                let size = self.memory.read_usize(args[2])?;\n-                let align = self.memory.read_usize(args[3])?;\n+                let ptr = args[0].read_ptr(&self.memory)?;\n+                let size = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate third arg not usize\");\n+                let align = self.value_to_primval(args[3], usize)?.expect_uint(\"__rust_reallocate fourth arg not usize\");\n                 let new_ptr = self.memory.reallocate(ptr, size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, new_ptr)?;\n             }\n \n             \"memcmp\" => {\n-                let left = self.memory.read_ptr(args[0])?;\n-                let right = self.memory.read_ptr(args[1])?;\n-                let n = self.memory.read_usize(args[2])? as usize;\n+                let left = args[0].read_ptr(&self.memory)?;\n+                let right = args[1].read_ptr(&self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate first arg not usize\") as usize;\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -419,7 +421,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         // intermediate function call.\n                         // FIXME: this is a memory leak, should probably add the pointer to the\n                         // current stack.\n-                        let first = self.value_to_ptr(args[0].0, args[0].1)?;\n+                        let first = self.value_to_ptr_dont_use(args[0].0, args[0].1)?;\n                         args[0].0 = Value::ByVal(PrimVal::Ptr(first));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n@@ -442,11 +444,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             traits::VtableObject(ref data) => {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n                 if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n-                    // FIXME(solson): Remove this allocating hack.\n-                    let ptr = self.value_to_ptr(*first_arg, *first_ty)?;\n-                    *first_arg = Value::ByRef(ptr);\n-                    let (_, vtable) = self.get_fat_ptr(ptr);\n-                    let vtable = self.memory.read_ptr(vtable)?;\n+                    let vtable = first_arg.expect_vtable(&self.memory)?;\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset as isize))?;"}, {"sha": "0237afd06a34c575a466e3f9a6d17fb53700a3dd", "filename": "src/interpreter/value.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -0,0 +1,60 @@\n+use memory::{Memory, Pointer};\n+use error::EvalResult;\n+use primval::PrimVal;\n+\n+/// A `Value` represents a single self-contained Rust value.\n+///\n+/// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitve\n+/// value held directly, outside of any allocation (`ByVal`).\n+///\n+/// For optimization of a few very common cases, there is also a representation for a pair of\n+/// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n+/// operations and fat pointers. This idea was taken from rustc's trans.\n+#[derive(Clone, Copy, Debug)]\n+pub(super) enum Value {\n+    ByRef(Pointer),\n+    ByVal(PrimVal),\n+}\n+\n+impl Value {\n+    pub(super) fn read_ptr<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => mem.read_ptr(ptr),\n+            ByVal(PrimVal::Ptr(ptr)) |\n+            ByVal(PrimVal::FnPtr(ptr)) => Ok(ptr),\n+            ByVal(_other) => unimplemented!(),\n+        }\n+    }\n+\n+    pub(super) fn expect_vtable<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => mem.read_ptr(ptr.offset(mem.pointer_size() as isize)),\n+            ByVal(PrimVal::VtablePtr(_, vtable)) => Ok(vtable),\n+            _ => unimplemented!(),\n+        }\n+    }\n+\n+    pub(super) fn expect_slice_len<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, u64> {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => mem.read_usize(ptr.offset(mem.pointer_size() as isize)),\n+            ByVal(PrimVal::SlicePtr(_, len)) => Ok(len),\n+            _ => unimplemented!(),\n+        }\n+    }\n+\n+    pub(super) fn expect_fat_ptr_extra<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        use self::Value::*;\n+        match (*self, mem.pointer_size()) {\n+            (ByRef(ptr), size) => mem.read_ptr(ptr.offset(size as isize)).map(PrimVal::Ptr),\n+            (ByVal(PrimVal::SlicePtr(_, len)), 8) => Ok(PrimVal::U64(len)),\n+            (ByVal(PrimVal::SlicePtr(_, len)), 4) => Ok(PrimVal::U32(len as u32)),\n+            (ByVal(PrimVal::SlicePtr(_, len)), 2) => Ok(PrimVal::U16(len as u16)),\n+            (ByVal(PrimVal::SlicePtr(_, len)), 1) => Ok(PrimVal::U8(len as u8)),\n+            (ByVal(PrimVal::VtablePtr(_, ptr)), _) => Ok(PrimVal::Ptr(ptr)),\n+            _ => unimplemented!(),\n+        }\n+    }\n+}"}, {"sha": "d1c0c7408433ff966ad9d7eb47a622f029923750", "filename": "src/memory.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -55,6 +55,9 @@ impl Pointer {\n     pub fn points_to_zst(&self) -> bool {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n+    pub fn to_int(&self) -> usize {\n+        self.offset\n+    }\n     pub fn from_int(i: usize) -> Self {\n         Pointer {\n             alloc_id: ZST_ALLOC_ID,\n@@ -543,6 +546,20 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             PrimVal::F64(f) => self.write_f64(ptr, f),\n             PrimVal::FnPtr(p) |\n             PrimVal::Ptr(p) => self.write_ptr(ptr, p),\n+            PrimVal::VtablePtr(p, v) => {\n+                assert_eq!(layout::FAT_PTR_ADDR, 0);\n+                assert_eq!(layout::FAT_PTR_EXTRA, 1);\n+                self.write_ptr(ptr, p)?;\n+                let vptr = ptr.offset(self.pointer_size() as isize);\n+                self.write_ptr(vptr, v)\n+            }\n+            PrimVal::SlicePtr(p, n) => {\n+                assert_eq!(layout::FAT_PTR_ADDR, 0);\n+                assert_eq!(layout::FAT_PTR_EXTRA, 1);\n+                self.write_ptr(ptr, p)?;\n+                let nptr = ptr.offset(self.pointer_size() as isize);\n+                self.write_usize(nptr, n)\n+            }\n         }\n     }\n "}, {"sha": "82e2616252490992f0d39615d25bbca3b9c43b40", "filename": "src/primval.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -14,6 +14,8 @@ pub enum PrimVal {\n \n     Ptr(Pointer),\n     FnPtr(Pointer),\n+    VtablePtr(Pointer, Pointer),\n+    SlicePtr(Pointer, u64),\n     Char(char),\n \n     F32(f32), F64(f64),\n@@ -32,7 +34,10 @@ macro_rules! declare_expect_fn {\n \n impl PrimVal {\n     declare_expect_fn!(expect_bool, Bool, bool);\n+    declare_expect_fn!(expect_f32, F32, f32);\n+    declare_expect_fn!(expect_f64, F64, f64);\n     declare_expect_fn!(expect_fn_ptr, FnPtr, Pointer);\n+    declare_expect_fn!(expect_ptr, Ptr, Pointer);\n \n     pub fn expect_uint(self, error_msg: &str) -> u64 {\n         use self::PrimVal::*;\n@@ -41,6 +46,19 @@ impl PrimVal {\n             U16(u) => u as u64,\n             U32(u) => u as u64,\n             U64(u) => u,\n+            Ptr(ptr) => ptr.to_int() as u64,\n+            _ => bug!(\"{}\", error_msg),\n+        }\n+    }\n+\n+    pub fn expect_int(self, error_msg: &str) -> i64 {\n+        use self::PrimVal::*;\n+        match self {\n+            I8(i)  => i as i64,\n+            I16(i) => i as i64,\n+            I32(i) => i as i64,\n+            I64(i) => i,\n+            Ptr(ptr) => ptr.to_int() as i64,\n             _ => bug!(\"{}\", error_msg),\n         }\n     }"}, {"sha": "edbf2b81ce941e2ae140848723c64f36ae8b9462", "filename": "tests/run-pass/issue-33387.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/tests%2Frun-pass%2Fissue-33387.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391/tests%2Frun-pass%2Fissue-33387.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-33387.rs?ref=2282289ad5fbfaaaffd6b4fe4ceb6665ab9ab391", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::Arc;\n+\n+trait Foo {}\n+\n+impl Foo for [u8; 2] {}\n+\n+fn main() {\n+    let _: Arc<Foo + Send> = Arc::new([3, 4]);\n+}"}]}