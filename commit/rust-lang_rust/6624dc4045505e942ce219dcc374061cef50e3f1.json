{"sha": "6624dc4045505e942ce219dcc374061cef50e3f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MjRkYzQwNDU1MDVlOTQyY2UyMTlkY2MzNzQwNjFjZWY1MGUzZjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-18T09:25:22Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-23T22:07:19Z"}, "message": "Make librustc_query_system compile.", "tree": {"sha": "70e6d664e29bf49132f2f10031f8a792caef8337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70e6d664e29bf49132f2f10031f8a792caef8337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6624dc4045505e942ce219dcc374061cef50e3f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6624dc4045505e942ce219dcc374061cef50e3f1", "html_url": "https://github.com/rust-lang/rust/commit/6624dc4045505e942ce219dcc374061cef50e3f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6624dc4045505e942ce219dcc374061cef50e3f1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "html_url": "https://github.com/rust-lang/rust/commit/a7e2641b9aba10d6eabf6978d3b5506d99ae633c"}], "stats": {"total": 962, "additions": 358, "deletions": 604}, "files": [{"sha": "22a06151353bada202aa083bf39d34c2cab1d293", "filename": "Cargo.lock", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -3116,6 +3116,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4021,6 +4022,22 @@ dependencies = [\n  \"rustc_typeck\",\n ]\n \n+[[package]]\n+name = \"rustc_query_system\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"parking_lot 0.9.0\",\n+ \"rustc_ast\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"serialize\",\n+ \"smallvec 1.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_resolve\"\n version = \"0.0.0\""}, {"sha": "47b94a2f1a4b49947eef67613ecdd6a3de4cb3a1", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -25,6 +25,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_query_system = { path = \"../librustc_query_system\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "a01bb5e5ea30dbc2a341b5120a26de8bc3326a49", "filename": "src/librustc_query_system/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_query_system\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_query_system\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+rustc_ast = { path = \"../librustc_ast\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n+rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+parking_lot = \"0.9\"\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "718a2f1039a4df8576fb3ac2cc842c322fbd573f", "filename": "src/librustc_query_system/dep_graph/debug.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -1,6 +1,6 @@\n //! Code for debugging the dep-graph.\n \n-use super::dep_node::DepNode;\n+use super::{DepKind, DepNode};\n use std::error::Error;\n \n /// A dep-node filter goes from a user-defined string to a query over\n@@ -26,7 +26,7 @@ impl DepNodeFilter {\n     }\n \n     /// Tests whether `node` meets the filter, returning true if so.\n-    pub fn test(&self, node: &DepNode) -> bool {\n+    pub fn test<K: DepKind>(&self, node: &DepNode<K>) -> bool {\n         let debug_str = format!(\"{:?}\", node);\n         self.text.split('&').map(|s| s.trim()).all(|f| debug_str.contains(f))\n     }\n@@ -52,7 +52,7 @@ impl EdgeFilter {\n         }\n     }\n \n-    pub fn test(&self, source: &DepNode, target: &DepNode) -> bool {\n+    pub fn test<K: DepKind>(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }"}, {"sha": "9dcba30300f06cd8ba48b1aac562e08124c9c4fa", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 32, "deletions": 395, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -26,10 +26,10 @@\n //!   could not be instantiated because the current compilation session\n //!   contained no `DefId` for thing that had been removed.\n //!\n-//! `DepNode` definition happens in the `define_dep_nodes!()` macro. This macro\n-//! defines the `DepKind` enum and a corresponding `DepConstructor` enum. The\n-//! `DepConstructor` enum links a `DepKind` to the parameters that are needed at\n-//! runtime in order to construct a valid `DepNode` fingerprint.\n+//! `DepNode` definition happens in `librustc` with the `define_dep_nodes!()` macro.\n+//! This macro defines the `DepKind` enum and a corresponding `DepConstructor` enum. The\n+//! `DepConstructor` enum links a `DepKind` to the parameters that are needed at runtime in order\n+//! to construct a valid `DepNode` fingerprint.\n //!\n //! Because the macro sees what parameters a given `DepKind` requires, it can\n //! \"infer\" some properties for each kind of `DepNode`:\n@@ -41,326 +41,50 @@\n //!   in which case it is possible to map the node's fingerprint back to the\n //!   `DefId` it was computed from. In other cases, too much information gets\n //!   lost during fingerprint computation.\n-//!\n-//! The `DepConstructor` enum, together with `DepNode::new()` ensures that only\n-//! valid `DepNode` instances can be constructed. For example, the API does not\n-//! allow for constructing parameterless `DepNode`s with anything other\n-//! than a zeroed out fingerprint. More generally speaking, it relieves the\n-//! user of the `DepNode` API of having to know how to compute the expected\n-//! fingerprint for a given set of node parameters.\n \n-use crate::hir::map::DefPathHash;\n-use crate::ich::{Fingerprint, StableHashingContext};\n-use crate::mir;\n-use crate::mir::interpret::{GlobalId, LitToConstInput};\n-use crate::traits;\n-use crate::traits::query::{\n-    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n-    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n-    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n-};\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use super::{DepContext, DepKind};\n \n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n-use rustc_hir::HirId;\n-use rustc_span::symbol::Symbol;\n+use rustc_macros::HashStable_Generic;\n+\n use std::fmt;\n use std::hash::Hash;\n \n-// erase!() just makes tokens go away. It's used to specify which macro argument\n-// is repeated (i.e., which sub-expression of the macro we are in) but don't need\n-// to actually use any of the arguments.\n-macro_rules! erase {\n-    ($x:tt) => {{}};\n-}\n-\n-macro_rules! is_anon_attr {\n-    (anon) => {\n-        true\n-    };\n-    ($attr:ident) => {\n-        false\n-    };\n-}\n-\n-macro_rules! is_eval_always_attr {\n-    (eval_always) => {\n-        true\n-    };\n-    ($attr:ident) => {\n-        false\n-    };\n-}\n-\n-macro_rules! contains_anon_attr {\n-    ($($attr:ident $(($($attr_args:tt)*))* ),*) => ({$(is_anon_attr!($attr) | )* false});\n-}\n-\n-macro_rules! contains_eval_always_attr {\n-    ($($attr:ident $(($($attr_args:tt)*))* ),*) => ({$(is_eval_always_attr!($attr) | )* false});\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DepNode<K> {\n+    pub kind: K,\n+    pub hash: Fingerprint,\n }\n \n-macro_rules! define_dep_nodes {\n-    (<$tcx:tt>\n-    $(\n-        [$($attrs:tt)*]\n-        $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n-      ,)*\n-    ) => (\n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n-        #[allow(non_camel_case_types)]\n-        pub enum DepKind {\n-            $($variant),*\n-        }\n-\n-        impl DepKind {\n-            #[allow(unreachable_code)]\n-            pub fn can_reconstruct_query_key<$tcx>(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => {\n-                            if contains_anon_attr!($($attrs)*) {\n-                                return false;\n-                            }\n-\n-                            // tuple args\n-                            $({\n-                                return <$tuple_arg_ty as DepNodeParams>\n-                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n-                            })*\n-\n-                            true\n-                        }\n-                    )*\n-                }\n-            }\n-\n-            pub fn is_anon(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => { contains_anon_attr!($($attrs)*) }\n-                    )*\n-                }\n-            }\n-\n-            pub fn is_eval_always(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => { contains_eval_always_attr!($($attrs)*) }\n-                    )*\n-                }\n-            }\n-\n-            #[allow(unreachable_code)]\n-            pub fn has_params(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => {\n-                            // tuple args\n-                            $({\n-                                erase!($tuple_arg_ty);\n-                                return true;\n-                            })*\n-\n-                            false\n-                        }\n-                    )*\n-                }\n-            }\n-        }\n-\n-        pub struct DepConstructor;\n-\n-        #[allow(non_camel_case_types)]\n-        impl DepConstructor {\n-            $(\n-                #[inline(always)]\n-                #[allow(unreachable_code, non_snake_case)]\n-                pub fn $variant(_tcx: TyCtxt<'_>, $(arg: $tuple_arg_ty)*) -> DepNode {\n-                    // tuple args\n-                    $({\n-                        erase!($tuple_arg_ty);\n-                        let hash = DepNodeParams::to_fingerprint(&arg, _tcx);\n-                        let dep_node = DepNode {\n-                            kind: DepKind::$variant,\n-                            hash\n-                        };\n-\n-                        #[cfg(debug_assertions)]\n-                        {\n-                            if !dep_node.kind.can_reconstruct_query_key() &&\n-                            (_tcx.sess.opts.debugging_opts.incremental_info ||\n-                                _tcx.sess.opts.debugging_opts.query_dep_graph)\n-                            {\n-                                _tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                    arg.to_debug_str(_tcx)\n-                                });\n-                            }\n-                        }\n-\n-                        return dep_node;\n-                    })*\n-\n-                    DepNode {\n-                        kind: DepKind::$variant,\n-                        hash: Fingerprint::ZERO,\n-                    }\n-                }\n-            )*\n-        }\n-\n-        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n-        pub struct DepNode {\n-            pub kind: DepKind,\n-            pub hash: Fingerprint,\n-        }\n-\n-        impl DepNode {\n-            /// Construct a DepNode from the given DepKind and DefPathHash. This\n-            /// method will assert that the given DepKind actually requires a\n-            /// single DefId/DefPathHash parameter.\n-            pub fn from_def_path_hash(def_path_hash: DefPathHash,\n-                                      kind: DepKind)\n-                                      -> DepNode {\n-                debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n-                DepNode {\n-                    kind,\n-                    hash: def_path_hash.0,\n-                }\n-            }\n-\n-            /// Creates a new, parameterless DepNode. This method will assert\n-            /// that the DepNode corresponding to the given DepKind actually\n-            /// does not require any parameters.\n-            pub fn new_no_params(kind: DepKind) -> DepNode {\n-                debug_assert!(!kind.has_params());\n-                DepNode {\n-                    kind,\n-                    hash: Fingerprint::ZERO,\n-                }\n-            }\n-\n-            /// Extracts the DefId corresponding to this DepNode. This will work\n-            /// if two conditions are met:\n-            ///\n-            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n-            /// 2. the item that the DefPath refers to exists in the current tcx.\n-            ///\n-            /// Condition (1) is determined by the DepKind variant of the\n-            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n-            /// refers to something from the previous compilation session that\n-            /// has been removed.\n-            pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n-                if self.kind.can_reconstruct_query_key() {\n-                    let def_path_hash = DefPathHash(self.hash);\n-                    tcx.def_path_hash_to_def_id.as_ref()?\n-                        .get(&def_path_hash).cloned()\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            /// Used in testing\n-            pub fn from_label_string(label: &str,\n-                                     def_path_hash: DefPathHash)\n-                                     -> Result<DepNode, ()> {\n-                let kind = match label {\n-                    $(\n-                        stringify!($variant) => DepKind::$variant,\n-                    )*\n-                    _ => return Err(()),\n-                };\n-\n-                if !kind.can_reconstruct_query_key() {\n-                    return Err(());\n-                }\n-\n-                if kind.has_params() {\n-                    Ok(DepNode::from_def_path_hash(def_path_hash, kind))\n-                } else {\n-                    Ok(DepNode::new_no_params(kind))\n-                }\n-            }\n-\n-            /// Used in testing\n-            pub fn has_label_string(label: &str) -> bool {\n-                match label {\n-                    $(\n-                        stringify!($variant) => true,\n-                    )*\n-                    _ => false,\n-                }\n-            }\n-        }\n-\n-        /// Contains variant => str representations for constructing\n-        /// DepNode groups for tests.\n-        #[allow(dead_code, non_upper_case_globals)]\n-        pub mod label_strs {\n-           $(\n-                pub const $variant: &str = stringify!($variant);\n-            )*\n-        }\n-    );\n+impl<K: DepKind> DepNode<K> {\n+    /// Creates a new, parameterless DepNode. This method will assert\n+    /// that the DepNode corresponding to the given DepKind actually\n+    /// does not require any parameters.\n+    pub fn new_no_params(kind: K) -> DepNode<K> {\n+        debug_assert!(!kind.has_params());\n+        DepNode { kind, hash: Fingerprint::ZERO }\n+    }\n }\n \n-impl fmt::Debug for DepNode {\n+impl<K: DepKind> fmt::Debug for DepNode<K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.kind)?;\n-\n-        if !self.kind.has_params() && !self.kind.is_anon() {\n-            return Ok(());\n-        }\n-\n-        write!(f, \"(\")?;\n-\n-        crate::ty::tls::with_opt(|opt_tcx| {\n-            if let Some(tcx) = opt_tcx {\n-                if let Some(def_id) = self.extract_def_id(tcx) {\n-                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n-                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n-                    write!(f, \"{}\", s)?;\n-                } else {\n-                    write!(f, \"{}\", self.hash)?;\n-                }\n-            } else {\n-                write!(f, \"{}\", self.hash)?;\n-            }\n-            Ok(())\n-        })?;\n-\n-        write!(f, \")\")\n+        K::debug_node(self, f)\n     }\n }\n \n-rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n-    // We use this for most things when incr. comp. is turned off.\n-    [] Null,\n-\n-    // Represents metadata from an extern crate.\n-    [eval_always] CrateMetadata(CrateNum),\n-\n-    [anon] TraitSelect,\n-\n-    [] CompileCodegenUnit(Symbol),\n-]);\n-\n-pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n+pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n     /// Not all DepNodeParams support being turned into a Fingerprint (they\n     /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n+    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n         panic!(\"Not implemented. Accidentally called on anonymous node?\")\n     }\n \n-    fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n+    fn to_debug_str(&self, _: Ctxt) -> String {\n         format!(\"{:?}\", self)\n     }\n \n@@ -370,16 +94,16 @@ pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n     /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n     /// It is always valid to return `None` here, in which case incremental\n     /// compilation will treat the query as having changed instead of forcing it.\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n+    fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n }\n \n-impl<'tcx, T> DepNodeParams<'tcx> for T\n+impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n where\n-    T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n+    T: HashStable<Ctxt::StableHashingContext> + fmt::Debug,\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n-    default fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n+    default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n         let mut hcx = tcx.create_stable_hashing_context();\n         let mut hasher = StableHasher::new();\n \n@@ -388,102 +112,15 @@ where\n         hasher.finish()\n     }\n \n-    default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n+    default fn to_debug_str(&self, _: Ctxt) -> String {\n         format!(\"{:?}\", *self)\n     }\n \n-    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n+    default fn recover(_: Ctxt, _: &DepNode<Ctxt::DepKind>) -> Option<Self> {\n         None\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for DefId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n-\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n-        tcx.def_path_hash(*self).0\n-    }\n-\n-    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n-        tcx.def_path_str(*self)\n-    }\n-\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx)\n-    }\n-}\n-\n-impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n-\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n-        tcx.hir().definitions().def_path_hash(*self).0\n-    }\n-\n-    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n-        tcx.def_path_str(DefId::local(*self))\n-    }\n-\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.index)\n-    }\n-}\n-\n-impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n-\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n-        let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n-        tcx.def_path_hash(def_id).0\n-    }\n-\n-    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n-        tcx.crate_name(*self).to_string()\n-    }\n-\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.krate)\n-    }\n-}\n-\n-impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n-\n-    // We actually would not need to specialize the implementation of this\n-    // method but it's faster to combine the hashes than to instantiate a full\n-    // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n-        let (def_id_0, def_id_1) = *self;\n-\n-        let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n-        let def_path_hash_1 = tcx.def_path_hash(def_id_1);\n-\n-        def_path_hash_0.0.combine(def_path_hash_1.0)\n-    }\n-\n-    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n-        let (def_id_0, def_id_1) = *self;\n-\n-        format!(\"({}, {})\", tcx.def_path_debug_str(def_id_0), tcx.def_path_debug_str(def_id_1))\n-    }\n-}\n-\n-impl<'tcx> DepNodeParams<'tcx> for HirId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n-\n-    // We actually would not need to specialize the implementation of this\n-    // method but it's faster to combine the hashes than to instantiate a full\n-    // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n-        let HirId { owner, local_id } = *self;\n-\n-        let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n-        let local_id = Fingerprint::from_smaller_hash(local_id.as_u32().into());\n-\n-        def_path_hash.0.combine(local_id)\n-    }\n-}\n-\n /// A \"work product\" corresponds to a `.o` (or other) file that we\n /// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without\n@@ -500,7 +137,7 @@ impl<'tcx> DepNodeParams<'tcx> for HirId {\n     Hash,\n     RustcEncodable,\n     RustcDecodable,\n-    HashStable\n+    HashStable_Generic\n )]\n pub struct WorkProductId {\n     hash: Fingerprint,"}, {"sha": "5e004c5428ad23057ebd1a701a8e340f45589714", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "modified", "additions": 112, "deletions": 160, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -1,32 +1,33 @@\n-use crate::ty::{self, TyCtxt};\n-use parking_lot::{Condvar, Mutex};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n+use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n-use smallvec::SmallVec;\n+\n+use parking_lot::{Condvar, Mutex};\n+use smallvec::{smallvec, SmallVec};\n use std::collections::hash_map::Entry;\n use std::env;\n use std::hash::Hash;\n use std::mem;\n+use std::panic as bug;\n use std::sync::atomic::Ordering::Relaxed;\n \n-use crate::ich::{Fingerprint, StableHashingContext, StableHashingContextProvider};\n-\n use super::debug::EdgeFilter;\n-use super::dep_node::{DepKind, DepNode, WorkProductId};\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n use super::safe::DepGraphSafe;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+use super::{DepContext, DepKind, DepNode, WorkProductId};\n+use crate::{HashStableContext, HashStableContextProvider};\n \n #[derive(Clone)]\n-pub struct DepGraph {\n-    data: Option<Lrc<DepGraphData>>,\n+pub struct DepGraph<K: DepKind> {\n+    data: Option<Lrc<DepGraphData<K>>>,\n \n     /// This field is used for assigning DepNodeIndices when running in\n     /// non-incremental mode. Even in non-incremental mode we make sure that\n@@ -65,16 +66,16 @@ impl DepNodeColor {\n     }\n }\n \n-struct DepGraphData {\n+struct DepGraphData<K: DepKind> {\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n     /// current one anymore.\n-    current: CurrentDepGraph,\n+    current: CurrentDepGraph<K>,\n \n     /// The dep-graph from the previous compilation session. It contains all\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n-    previous: PreviousDepGraph,\n+    previous: PreviousDepGraph<K>,\n \n     colors: DepNodeColorMap,\n \n@@ -90,24 +91,24 @@ struct DepGraphData {\n     /// this map. We can later look for and extract that data.\n     previous_work_products: FxHashMap<WorkProductId, WorkProduct>,\n \n-    dep_node_debug: Lock<FxHashMap<DepNode, String>>,\n+    dep_node_debug: Lock<FxHashMap<DepNode<K>, String>>,\n }\n \n-pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n+pub fn hash_result<HashCtxt, R>(hcx: &mut HashCtxt, result: &R) -> Option<Fingerprint>\n where\n-    R: for<'a> HashStable<StableHashingContext<'a>>,\n+    R: HashStable<HashCtxt>,\n {\n     let mut stable_hasher = StableHasher::new();\n     result.hash_stable(hcx, &mut stable_hasher);\n \n     Some(stable_hasher.finish())\n }\n \n-impl DepGraph {\n+impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n-        prev_graph: PreviousDepGraph,\n+        prev_graph: PreviousDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n-    ) -> DepGraph {\n+    ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n         DepGraph {\n@@ -124,7 +125,7 @@ impl DepGraph {\n         }\n     }\n \n-    pub fn new_disabled() -> DepGraph {\n+    pub fn new_disabled() -> DepGraph<K> {\n         DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n@@ -134,7 +135,7 @@ impl DepGraph {\n         self.data.is_some()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery {\n+    pub fn query(&self) -> DepGraphQuery<K> {\n         let data = self.data.as_ref().unwrap().current.data.lock();\n         let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n         let mut edges = Vec::new();\n@@ -150,22 +151,15 @@ impl DepGraph {\n \n     pub fn assert_ignored(&self) {\n         if let Some(..) = self.data {\n-            ty::tls::with_context_opt(|icx| {\n-                let icx = if let Some(icx) = icx { icx } else { return };\n-                assert!(icx.task_deps.is_none(), \"expected no task dependency tracking\");\n-            })\n+            K::assert_ignored();\n         }\n     }\n \n     pub fn with_ignore<OP, R>(&self, op: OP) -> R\n     where\n         OP: FnOnce() -> R,\n     {\n-        ty::tls::with_context(|icx| {\n-            let icx = ty::tls::ImplicitCtxt { task_deps: None, ..icx.clone() };\n-\n-            ty::tls::enter_context(&icx, |_| op())\n-        })\n+        K::with_ignore_deps(op)\n     }\n \n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n@@ -195,16 +189,17 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/incremental-compilation.html\n-    pub fn with_task<'a, C, A, R>(\n+    pub fn with_task<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         self.with_task_impl(\n             key,\n@@ -218,31 +213,33 @@ impl DepGraph {\n                     node: Some(_key),\n                     reads: SmallVec::new(),\n                     read_set: Default::default(),\n+                    phantom_data: std::marker::PhantomData,\n                 })\n             },\n             |data, key, fingerprint, task| data.complete_task(key, task.unwrap(), fingerprint),\n             hash_result,\n         )\n     }\n \n-    fn with_task_impl<'a, C, A, R>(\n+    fn with_task_impl<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         no_tcx: bool,\n         task: fn(C, A) -> R,\n-        create_task: fn(DepNode) -> Option<TaskDeps>,\n+        create_task: fn(DepNode<K>) -> Option<TaskDeps<K>>,\n         finish_task_and_alloc_depnode: fn(\n-            &CurrentDepGraph,\n-            DepNode,\n+            &CurrentDepGraph<K>,\n+            DepNode<K>,\n             Fingerprint,\n-            Option<TaskDeps>,\n+            Option<TaskDeps<K>>,\n         ) -> DepNodeIndex,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(Lock::new);\n@@ -257,12 +254,7 @@ impl DepGraph {\n             let result = if no_tcx {\n                 task(cx, arg)\n             } else {\n-                ty::tls::with_context(|icx| {\n-                    let icx =\n-                        ty::tls::ImplicitCtxt { task_deps: task_deps.as_ref(), ..icx.clone() };\n-\n-                    ty::tls::enter_context(&icx, |_| task(cx, arg))\n-                })\n+                K::with_deps(task_deps.as_ref(), || task(cx, arg))\n             };\n \n             let current_fingerprint = hash_result(&mut hcx, &result);\n@@ -274,7 +266,7 @@ impl DepGraph {\n                 task_deps.map(|lock| lock.into_inner()),\n             );\n \n-            let print_status = cfg!(debug_assertions) && hcx.sess().opts.debugging_opts.dep_tasks;\n+            let print_status = cfg!(debug_assertions) && hcx.debug_dep_tasks();\n \n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n@@ -322,22 +314,16 @@ impl DepGraph {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<OP, R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNodeIndex)\n+    pub fn with_anon_task<OP, R>(&self, dep_kind: K, op: OP) -> (R, DepNodeIndex)\n     where\n         OP: FnOnce() -> R,\n     {\n         if let Some(ref data) = self.data {\n-            let (result, task_deps) = ty::tls::with_context(|icx| {\n-                let task_deps = Lock::new(TaskDeps::default());\n-\n-                let r = {\n-                    let icx = ty::tls::ImplicitCtxt { task_deps: Some(&task_deps), ..icx.clone() };\n+            let task_deps = Lock::new(TaskDeps::default());\n \n-                    ty::tls::enter_context(&icx, |_| op())\n-                };\n+            let result = K::with_deps(Some(&task_deps), op);\n+            let task_deps = task_deps.into_inner();\n \n-                (r, task_deps.into_inner())\n-            });\n             let dep_node_index = data.current.complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n@@ -347,16 +333,17 @@ impl DepGraph {\n \n     /// Executes something within an \"eval-always\" task which is a task\n     /// that runs whenever anything changes.\n-    pub fn with_eval_always_task<'a, C, A, R>(\n+    pub fn with_eval_always_task<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         self.with_task_impl(\n             key,\n@@ -371,7 +358,7 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn read(&self, v: DepNode) {\n+    pub fn read(&self, v: DepNode<K>) {\n         if let Some(ref data) = self.data {\n             let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n             if let Some(dep_node_index) = map.get(&v).copied() {\n@@ -391,7 +378,7 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn dep_node_index_of(&self, dep_node: &DepNode) -> DepNodeIndex {\n+    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n         self.data\n             .as_ref()\n             .unwrap()\n@@ -405,7 +392,7 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n+    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n         if let Some(ref data) = self.data {\n             data.current\n                 .node_to_node_index\n@@ -423,12 +410,12 @@ impl DepGraph {\n         data[dep_node_index].fingerprint\n     }\n \n-    pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+    pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n     #[inline]\n-    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n         self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n     }\n \n@@ -445,7 +432,7 @@ impl DepGraph {\n     }\n \n     #[inline(always)]\n-    pub fn register_dep_node_debug_str<F>(&self, dep_node: DepNode, debug_str_gen: F)\n+    pub fn register_dep_node_debug_str<F>(&self, dep_node: DepNode<K>, debug_str_gen: F)\n     where\n         F: FnOnce() -> String,\n     {\n@@ -458,7 +445,7 @@ impl DepGraph {\n         dep_node_debug.borrow_mut().insert(dep_node, debug_str);\n     }\n \n-    pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n+    pub fn dep_node_debug_str(&self, dep_node: DepNode<K>) -> Option<String> {\n         self.data.as_ref()?.dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n \n@@ -475,7 +462,7 @@ impl DepGraph {\n         }\n     }\n \n-    pub fn serialize(&self) -> SerializedDepGraph {\n+    pub fn serialize(&self) -> SerializedDepGraph<K> {\n         let data = self.data.as_ref().unwrap().current.data.lock();\n \n         let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n@@ -503,7 +490,7 @@ impl DepGraph {\n         SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data }\n     }\n \n-    pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n+    pub fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n                 return data.colors.get(prev_index);\n@@ -521,10 +508,10 @@ impl DepGraph {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green_and_read(\n+    pub fn try_mark_green_and_read<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'_>,\n-        dep_node: &DepNode,\n+        tcx: Ctxt,\n+        dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         self.try_mark_green(tcx, dep_node).map(|(prev_index, dep_node_index)| {\n             debug_assert!(self.is_green(&dep_node));\n@@ -533,10 +520,10 @@ impl DepGraph {\n         })\n     }\n \n-    pub fn try_mark_green(\n+    pub fn try_mark_green<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'_>,\n-        dep_node: &DepNode,\n+        tcx: Ctxt,\n+        dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n@@ -561,12 +548,12 @@ impl DepGraph {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    fn try_mark_previous_green<'tcx>(\n+    fn try_mark_previous_green<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        data: &DepGraphData,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n-        dep_node: &DepNode,\n+        dep_node: &DepNode<K>,\n     ) -> Option<DepNodeIndex> {\n         debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n \n@@ -649,49 +636,7 @@ impl DepGraph {\n                             continue;\n                         }\n                     } else {\n-                        // FIXME: This match is just a workaround for incremental bugs and should\n-                        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n-                        // bug that must be fixed before removing this.\n-                        match dep_dep_node.kind {\n-                            DepKind::hir_owner\n-                            | DepKind::hir_owner_nodes\n-                            | DepKind::CrateMetadata => {\n-                                if let Some(def_id) = dep_dep_node.extract_def_id(tcx) {\n-                                    if def_id_corresponds_to_hir_dep_node(tcx, def_id) {\n-                                        if dep_dep_node.kind == DepKind::CrateMetadata {\n-                                            // The `DefPath` has corresponding node,\n-                                            // and that node should have been marked\n-                                            // either red or green in `data.colors`.\n-                                            bug!(\n-                                                \"DepNode {:?} should have been \\\n-                                             pre-marked as red or green but wasn't.\",\n-                                                dep_dep_node\n-                                            );\n-                                        }\n-                                    } else {\n-                                        // This `DefPath` does not have a\n-                                        // corresponding `DepNode` (e.g. a\n-                                        // struct field), and the ` DefPath`\n-                                        // collided with the `DefPath` of a\n-                                        // proper item that existed in the\n-                                        // previous compilation session.\n-                                        //\n-                                        // Since the given `DefPath` does not\n-                                        // denote the item that previously\n-                                        // existed, we just fail to mark green.\n-                                        return None;\n-                                    }\n-                                } else {\n-                                    // If the node does not exist anymore, we\n-                                    // just fail to mark green.\n-                                    return None;\n-                                }\n-                            }\n-                            _ => {\n-                                // For other kinds of nodes it's OK to be\n-                                // forced.\n-                            }\n-                        }\n+                        tcx.ensure_node_can_be_forced(dep_dep_node)?;\n                     }\n \n                     // We failed to mark it green, so we try to force the query.\n@@ -700,7 +645,7 @@ impl DepGraph {\n                             dependency {:?}\",\n                         dep_node, dep_dep_node\n                     );\n-                    if crate::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n+                    if tcx.force_from_dep_node(dep_dep_node) {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n@@ -721,7 +666,7 @@ impl DepGraph {\n                                 return None;\n                             }\n                             None => {\n-                                if !tcx.sess.has_errors_or_delayed_span_bugs() {\n+                                if !tcx.has_errors_or_delayed_span_bugs() {\n                                     bug!(\n                                         \"try_mark_previous_green() - Forcing the DepNode \\\n                                           should have set its color\"\n@@ -779,7 +724,7 @@ impl DepGraph {\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n         // Maybe store a list on disk and encode this fact in the DepNodeState\n-        let diagnostics = tcx.queries.on_disk_cache.load_diagnostics(tcx, prev_dep_node_index);\n+        let diagnostics = tcx.load_diagnostics(prev_dep_node_index);\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n@@ -805,10 +750,10 @@ impl DepGraph {\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_diagnostics<'tcx>(\n+    fn emit_diagnostics<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        data: &DepGraphData,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         diagnostics: Vec<Diagnostic>,\n@@ -827,9 +772,9 @@ impl DepGraph {\n             mem::drop(emitting);\n \n             // Promote the previous diagnostics to the current session.\n-            tcx.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics.clone().into());\n+            tcx.store_diagnostics(dep_node_index, diagnostics.clone().into());\n \n-            let handle = tcx.sess.diagnostic();\n+            let handle = tcx.diagnostic();\n \n             for diagnostic in diagnostics {\n                 handle.emit_diagnostic(&diagnostic);\n@@ -858,7 +803,7 @@ impl DepGraph {\n \n     // Returns true if the given node has been marked as green during the\n     // current compilation session. Used in various assertions\n-    pub fn is_green(&self, dep_node: &DepNode) -> bool {\n+    pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node).map(|c| c.is_green()).unwrap_or(false)\n     }\n \n@@ -870,15 +815,15 @@ impl DepGraph {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions(&self, tcx: TyCtxt<'_>) {\n-        let _prof_timer = tcx.prof.generic_activity(\"incr_comp_query_cache_promotion\");\n+    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+        let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n                     let dep_node = data.previous.index_to_node(prev_index);\n-                    dep_node.try_load_from_on_disk_cache(tcx);\n+                    tcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n                     // We can skip red nodes because a node can only be marked\n@@ -895,11 +840,6 @@ impl DepGraph {\n     }\n }\n \n-fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    def_id.index == hir_id.owner.local_def_index\n-}\n-\n /// A \"work product\" is an intermediate result that we save into the\n /// incremental directory for later re-use. The primary example are\n /// the object files that we save for each partition at code\n@@ -946,8 +886,8 @@ pub enum WorkProductFileKind {\n }\n \n #[derive(Clone)]\n-struct DepNodeData {\n-    node: DepNode,\n+struct DepNodeData<K> {\n+    node: DepNode<K>,\n     edges: EdgesVec,\n     fingerprint: Fingerprint,\n }\n@@ -967,9 +907,9 @@ struct DepNodeData {\n /// The only operation that must manipulate both locks is adding new nodes, in which case\n /// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n /// acquire the lock on `data.`\n-pub(super) struct CurrentDepGraph {\n-    data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n-    node_to_node_index: Sharded<FxHashMap<DepNode, DepNodeIndex>>,\n+pub(super) struct CurrentDepGraph<K> {\n+    data: Lock<IndexVec<DepNodeIndex, DepNodeData<K>>>,\n+    node_to_node_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -995,8 +935,8 @@ pub(super) struct CurrentDepGraph {\n     total_duplicate_read_count: AtomicU64,\n }\n \n-impl CurrentDepGraph {\n-    fn new(prev_graph_node_count: usize) -> CurrentDepGraph {\n+impl<K: DepKind> CurrentDepGraph<K> {\n+    fn new(prev_graph_node_count: usize) -> CurrentDepGraph<K> {\n         use std::time::{SystemTime, UNIX_EPOCH};\n \n         let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n@@ -1039,14 +979,14 @@ impl CurrentDepGraph {\n \n     fn complete_task(\n         &self,\n-        node: DepNode,\n-        task_deps: TaskDeps,\n+        node: DepNode<K>,\n+        task_deps: TaskDeps<K>,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n         self.alloc_node(node, task_deps.reads, fingerprint)\n     }\n \n-    fn complete_anon_task(&self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n+    fn complete_anon_task(&self, kind: K, task_deps: TaskDeps<K>) -> DepNodeIndex {\n         debug_assert!(!kind.is_eval_always());\n \n         let mut hasher = StableHasher::new();\n@@ -1072,7 +1012,7 @@ impl CurrentDepGraph {\n \n     fn alloc_node(\n         &self,\n-        dep_node: DepNode,\n+        dep_node: DepNode<K>,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n@@ -1084,7 +1024,7 @@ impl CurrentDepGraph {\n \n     fn intern_node(\n         &self,\n-        dep_node: DepNode,\n+        dep_node: DepNode<K>,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n@@ -1101,12 +1041,11 @@ impl CurrentDepGraph {\n     }\n }\n \n-impl DepGraphData {\n+impl<K: DepKind> DepGraphData<K> {\n     #[inline(never)]\n     fn read_index(&self, source: DepNodeIndex) {\n-        ty::tls::with_context_opt(|icx| {\n-            let icx = if let Some(icx) = icx { icx } else { return };\n-            if let Some(task_deps) = icx.task_deps {\n+        K::read_deps(|task_deps| {\n+            if let Some(task_deps) = task_deps {\n                 let mut task_deps = task_deps.lock();\n                 let task_deps = &mut *task_deps;\n                 if cfg!(debug_assertions) {\n@@ -1151,12 +1090,25 @@ impl DepGraphData {\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;\n-#[derive(Default)]\n-pub struct TaskDeps {\n+\n+pub struct TaskDeps<K> {\n     #[cfg(debug_assertions)]\n-    node: Option<DepNode>,\n+    node: Option<DepNode<K>>,\n     reads: EdgesVec,\n     read_set: FxHashSet<DepNodeIndex>,\n+    phantom_data: std::marker::PhantomData<DepNode<K>>,\n+}\n+\n+impl<K> Default for TaskDeps<K> {\n+    fn default() -> Self {\n+        Self {\n+            #[cfg(debug_assertions)]\n+            node: None,\n+            reads: EdgesVec::new(),\n+            read_set: FxHashSet::default(),\n+            phantom_data: std::marker::PhantomData,\n+        }\n+    }\n }\n \n // A data structure that stores Option<DepNodeColor> values as a contiguous"}, {"sha": "77bc8f612932f36baf795ab090ed91ef9f49d4ad", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -6,12 +6,94 @@ mod query;\n mod safe;\n mod serialized;\n \n-pub(crate) use self::dep_node::DepNodeParams;\n-pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, WorkProductId};\n-pub use self::graph::WorkProductFileKind;\n-pub use self::graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n-pub use self::prev::PreviousDepGraph;\n-pub use self::query::DepGraphQuery;\n-pub use self::safe::AssertDepGraphSafe;\n-pub use self::safe::DepGraphSafe;\n-pub use self::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+pub use dep_node::{DepNode, DepNodeParams, WorkProductId};\n+pub use graph::WorkProductFileKind;\n+pub use graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n+pub use prev::PreviousDepGraph;\n+pub use query::DepGraphQuery;\n+pub use safe::AssertDepGraphSafe;\n+pub use safe::DepGraphSafe;\n+pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::Diagnostic;\n+use rustc_hir::def_id::DefId;\n+\n+use std::fmt;\n+use std::hash::Hash;\n+\n+pub trait DepContext: Copy {\n+    type DepKind: self::DepKind;\n+    type StableHashingContext: crate::HashStableContext;\n+\n+    /// Create a hashing context for hashing new results.\n+    fn create_stable_hashing_context(&self) -> Self::StableHashingContext;\n+\n+    /// Force the execution of a query given the associated `DepNode`.\n+    fn force_from_dep_node(&self, node: &DepNode<Self::DepKind>) -> bool;\n+\n+    /// Extracts the DefId corresponding to this DepNode. This will work\n+    /// if two conditions are met:\n+    ///\n+    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+    /// 2. the item that the DefPath refers to exists in the current tcx.\n+    ///\n+    /// Condition (1) is determined by the DepKind variant of the\n+    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+    /// refers to something from the previous compilation session that\n+    /// has been removed.\n+    fn extract_def_id(&self, node: &DepNode<Self::DepKind>) -> Option<DefId>;\n+\n+    /// Check the legality of forcing this node.\n+    fn ensure_node_can_be_forced(&self, dep_dep_node: &DepNode<Self::DepKind>) -> Option<()>;\n+\n+    /// Return whether the current session is tainted by errors.\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool;\n+\n+    /// Return the diagnostic handler.\n+    fn diagnostic(&self) -> &rustc_errors::Handler;\n+\n+    /// Load data from the on-disk cache.\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n+\n+    /// Load diagnostics associated to the node in the previous session.\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n+\n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+\n+    /// Access the profiler.\n+    fn profiler(&self) -> &SelfProfilerRef;\n+}\n+\n+/// Describe the different families of dependency nodes.\n+pub trait DepKind: Copy + fmt::Debug + Eq + Ord + Hash {\n+    /// Return whether this kind always require evaluation.\n+    fn is_eval_always(&self) -> bool;\n+\n+    /// Return whether this kind requires additional parameters to be executed.\n+    fn has_params(&self) -> bool;\n+\n+    /// Implementation of `std::fmt::Debug` for `DepNode`.\n+    fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n+\n+    /// Assert the current implicit context does not track any dependency.\n+    fn assert_ignored();\n+\n+    /// Execute the operation ignoring the dependencies.\n+    fn with_ignore_deps<OP, R>(op: OP) -> R\n+    where\n+        OP: FnOnce() -> R;\n+\n+    /// Execute the operation with provided dependencies.\n+    fn with_deps<OP, R>(deps: Option<&Lock<TaskDeps<Self>>>, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R;\n+\n+    /// Access dependencies from current implicit context.\n+    fn read_deps<OP>(op: OP) -> ()\n+    where\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>) -> ();\n+}"}, {"sha": "5cba64cac4b3449eb26eddc6c053c460444f6aea", "filename": "src/librustc_query_system/dep_graph/prev.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -1,16 +1,22 @@\n-use super::dep_node::DepNode;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n-use crate::ich::Fingerprint;\n+use super::{DepKind, DepNode};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, Default)]\n-pub struct PreviousDepGraph {\n-    data: SerializedDepGraph,\n-    index: FxHashMap<DepNode, SerializedDepNodeIndex>,\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct PreviousDepGraph<K: DepKind> {\n+    data: SerializedDepGraph<K>,\n+    index: FxHashMap<DepNode<K>, SerializedDepNodeIndex>,\n }\n \n-impl PreviousDepGraph {\n-    pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n+impl<K: DepKind> Default for PreviousDepGraph<K> {\n+    fn default() -> Self {\n+        PreviousDepGraph { data: Default::default(), index: Default::default() }\n+    }\n+}\n+\n+impl<K: DepKind> PreviousDepGraph<K> {\n+    pub fn new(data: SerializedDepGraph<K>) -> PreviousDepGraph<K> {\n         let index: FxHashMap<_, _> =\n             data.nodes.iter_enumerated().map(|(idx, &dep_node)| (dep_node, idx)).collect();\n         PreviousDepGraph { data, index }\n@@ -25,22 +31,22 @@ impl PreviousDepGraph {\n     }\n \n     #[inline]\n-    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode {\n+    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode<K> {\n         self.data.nodes[dep_node_index]\n     }\n \n     #[inline]\n-    pub fn node_to_index(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+    pub fn node_to_index(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n         self.index[dep_node]\n     }\n \n     #[inline]\n-    pub fn node_to_index_opt(&self, dep_node: &DepNode) -> Option<SerializedDepNodeIndex> {\n+    pub fn node_to_index_opt(&self, dep_node: &DepNode<K>) -> Option<SerializedDepNodeIndex> {\n         self.index.get(dep_node).cloned()\n     }\n \n     #[inline]\n-    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+    pub fn fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.index.get(dep_node).map(|&node_index| self.data.fingerprints[node_index])\n     }\n "}, {"sha": "4a4283b2a0cbbd05f8083fdb4ba5e038db37019b", "filename": "src/librustc_query_system/dep_graph/query.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -3,15 +3,15 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n \n-use super::DepNode;\n+use super::{DepKind, DepNode};\n \n-pub struct DepGraphQuery {\n-    pub graph: Graph<DepNode, ()>,\n-    pub indices: FxHashMap<DepNode, NodeIndex>,\n+pub struct DepGraphQuery<K> {\n+    pub graph: Graph<DepNode<K>, ()>,\n+    pub indices: FxHashMap<DepNode<K>, NodeIndex>,\n }\n \n-impl DepGraphQuery {\n-    pub fn new(nodes: &[DepNode], edges: &[(DepNode, DepNode)]) -> DepGraphQuery {\n+impl<K: DepKind> DepGraphQuery<K> {\n+    pub fn new(nodes: &[DepNode<K>], edges: &[(DepNode<K>, DepNode<K>)]) -> DepGraphQuery<K> {\n         let mut graph = Graph::with_capacity(nodes.len(), edges.len());\n         let mut indices = FxHashMap::default();\n         for node in nodes {\n@@ -27,15 +27,15 @@ impl DepGraphQuery {\n         DepGraphQuery { graph, indices }\n     }\n \n-    pub fn contains_node(&self, node: &DepNode) -> bool {\n+    pub fn contains_node(&self, node: &DepNode<K>) -> bool {\n         self.indices.contains_key(&node)\n     }\n \n-    pub fn nodes(&self) -> Vec<&DepNode> {\n+    pub fn nodes(&self) -> Vec<&DepNode<K>> {\n         self.graph.all_nodes().iter().map(|n| &n.data).collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(&DepNode, &DepNode)> {\n+    pub fn edges(&self) -> Vec<(&DepNode<K>, &DepNode<K>)> {\n         self.graph\n             .all_edges()\n             .iter()\n@@ -44,7 +44,7 @@ impl DepGraphQuery {\n             .collect()\n     }\n \n-    fn reachable_nodes(&self, node: &DepNode, direction: Direction) -> Vec<&DepNode> {\n+    fn reachable_nodes(&self, node: &DepNode<K>, direction: Direction) -> Vec<&DepNode<K>> {\n         if let Some(&index) = self.indices.get(node) {\n             self.graph.depth_traverse(index, direction).map(|s| self.graph.node_data(s)).collect()\n         } else {\n@@ -54,17 +54,17 @@ impl DepGraphQuery {\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn transitive_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, OUTGOING)\n     }\n \n     /// All nodes that can reach `node`.\n-    pub fn transitive_predecessors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn transitive_predecessors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, INCOMING)\n     }\n \n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn immediate_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index).map(|s| self.graph.node_data(s)).collect()\n         } else {"}, {"sha": "7bba348f8841f70c46019f9aa8ba64612f9c3190", "filename": "src/librustc_query_system/dep_graph/safe.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -1,7 +1,5 @@\n //! The `DepGraphSafe` trait\n \n-use crate::ty::TyCtxt;\n-\n use rustc_ast::ast::NodeId;\n use rustc_hir::def_id::DefId;\n use rustc_hir::BodyId;\n@@ -28,10 +26,6 @@ impl DepGraphSafe for NodeId {}\n /// on-demand queries, all of which create reads.\n impl DepGraphSafe for DefId {}\n \n-/// The type context itself can be used to access all kinds of tracked\n-/// state, but those accesses should always generate read events.\n-impl<'tcx> DepGraphSafe for TyCtxt<'tcx> {}\n-\n /// Tuples make it easy to build up state.\n impl<A, B> DepGraphSafe for (A, B)\n where"}, {"sha": "4a89da23ea6a59239ff9a99834d9bc029e51d2bf", "filename": "src/librustc_query_system/dep_graph/serialized.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -1,18 +1,18 @@\n //! The data that we will serialize and deserialize.\n \n-use crate::dep_graph::DepNode;\n-use crate::ich::Fingerprint;\n+use super::{DepKind, DepNode};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n \n rustc_index::newtype_index! {\n     pub struct SerializedDepNodeIndex { .. }\n }\n \n /// Data for use when recompiling the **current crate**.\n-#[derive(Debug, RustcEncodable, RustcDecodable, Default)]\n-pub struct SerializedDepGraph {\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph<K: DepKind> {\n     /// The set of all DepNodes in the graph\n-    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode>,\n+    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>>,\n     /// The set of all Fingerprints in the graph. Each Fingerprint corresponds to\n     /// the DepNode at the same index in the nodes vector.\n     pub fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint>,\n@@ -25,7 +25,18 @@ pub struct SerializedDepGraph {\n     pub edge_list_data: Vec<SerializedDepNodeIndex>,\n }\n \n-impl SerializedDepGraph {\n+impl<K: DepKind> Default for SerializedDepGraph<K> {\n+    fn default() -> Self {\n+        SerializedDepGraph {\n+            nodes: Default::default(),\n+            fingerprints: Default::default(),\n+            edge_list_indices: Default::default(),\n+            edge_list_data: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<K: DepKind> SerializedDepGraph<K> {\n     #[inline]\n     pub fn edge_targets_from(&self, source: SerializedDepNodeIndex) -> &[SerializedDepNodeIndex] {\n         let targets = self.edge_list_indices[source];"}, {"sha": "ef4886828c41167dc5358c8dafcfe52ed831e750", "filename": "src/librustc_query_system/lib.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6624dc4045505e942ce219dcc374061cef50e3f1/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=6624dc4045505e942ce219dcc374061cef50e3f1", "patch": "@@ -0,0 +1,32 @@\n+#![feature(const_fn)]\n+#![feature(const_if_match)]\n+#![feature(const_panic)]\n+#![feature(core_intrinsics)]\n+#![feature(specialization)]\n+#![feature(stmt_expr_attributes)]\n+\n+#[macro_use]\n+extern crate log;\n+\n+pub mod dep_graph;\n+\n+pub trait HashStableContext {\n+    fn debug_dep_tasks(&self) -> bool;\n+}\n+\n+/// Something that can provide a stable hashing context.\n+pub trait HashStableContextProvider<Ctxt> {\n+    fn get_stable_hashing_context(&self) -> Ctxt;\n+}\n+\n+impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &T {\n+    fn get_stable_hashing_context(&self) -> Ctxt {\n+        (**self).get_stable_hashing_context()\n+    }\n+}\n+\n+impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &mut T {\n+    fn get_stable_hashing_context(&self) -> Ctxt {\n+        (**self).get_stable_hashing_context()\n+    }\n+}"}]}