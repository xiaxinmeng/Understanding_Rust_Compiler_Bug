{"sha": "9564a30c194ab7324bb528b817c08a8f760d4c71", "node_id": "C_kwDOAAsO6NoAKDk1NjRhMzBjMTk0YWI3MzI0YmI1MjhiODE3YzA4YThmNzYwZDRjNzE", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-11-08T21:03:17Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2023-02-01T20:50:34Z"}, "message": "Convert rustc_parse::parser::pat::Expected to enum\n\nThis is required in order to support translatable diagnostics.", "tree": {"sha": "53706cc6d3c461a6bc2f8bf85b048ce2e8d0e52e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53706cc6d3c461a6bc2f8bf85b048ce2e8d0e52e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9564a30c194ab7324bb528b817c08a8f760d4c71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9564a30c194ab7324bb528b817c08a8f760d4c71", "html_url": "https://github.com/rust-lang/rust/commit/9564a30c194ab7324bb528b817c08a8f760d4c71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9564a30c194ab7324bb528b817c08a8f760d4c71/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "url": "https://api.github.com/repos/rust-lang/rust/commits/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "html_url": "https://github.com/rust-lang/rust/commit/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9"}], "stats": {"total": 56, "additions": 36, "deletions": 20}, "files": [{"sha": "26274822ed8a8ffdeef508586b7c91f471764156", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9564a30c194ab7324bb528b817c08a8f760d4c71/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564a30c194ab7324bb528b817c08a8f760d4c71/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9564a30c194ab7324bb528b817c08a8f760d4c71", "patch": "@@ -2030,7 +2030,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn recover_arg_parse(&mut self) -> PResult<'a, (P<ast::Pat>, P<ast::Ty>)> {\n-        let pat = self.parse_pat_no_top_alt(Some(\"argument name\"))?;\n+        let pat = self.parse_pat_no_top_alt(Some(Expected::ArgumentName))?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n@@ -2397,7 +2397,7 @@ impl<'a> Parser<'a> {\n     pub(crate) fn maybe_recover_colon_colon_in_pat_typo_or_anon_enum(\n         &mut self,\n         mut first_pat: P<Pat>,\n-        expected: Expected,\n+        expected: Option<Expected>,\n     ) -> P<Pat> {\n         if token::Colon != self.token.kind {\n             return first_pat;"}, {"sha": "5f5117d6833f88ef7726315b67e118f177ed2115", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9564a30c194ab7324bb528b817c08a8f760d4c71/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564a30c194ab7324bb528b817c08a8f760d4c71/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=9564a30c194ab7324bb528b817c08a8f760d4c71", "patch": "@@ -1,5 +1,5 @@\n use super::diagnostics::SnapshotParser;\n-use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n+use super::pat::{CommaRecoveryMode, Expected, RecoverColon, RecoverComma};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n@@ -2221,7 +2221,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n-            let pat = this.parse_pat_no_top_alt(PARAM_EXPECTED)?;\n+            let pat = this.parse_pat_no_top_alt(Some(Expected::ParameterName))?;\n             let ty = if this.eat(&token::Colon) {\n                 this.parse_ty()?\n             } else {"}, {"sha": "88c75fd81e7582b2a4d72a471fd55ac97df7e486", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9564a30c194ab7324bb528b817c08a8f760d4c71/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564a30c194ab7324bb528b817c08a8f760d4c71/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=9564a30c194ab7324bb528b817c08a8f760d4c71", "patch": "@@ -24,10 +24,26 @@ use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n \n-pub(super) type Expected = Option<&'static str>;\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum Expected {\n+    ParameterName,\n+    ArgumentName,\n+    Identifier,\n+    BindingPattern,\n+}\n \n-/// `Expected` for function and lambda parameter patterns.\n-pub(super) const PARAM_EXPECTED: Expected = Some(\"parameter name\");\n+impl Expected {\n+    // FIXME(#100717): migrate users of this to proper localization\n+    fn to_string_or_fallback(expected: Option<Expected>) -> &'static str {\n+        match expected {\n+            Some(Expected::ParameterName) => \"parameter name\",\n+            Some(Expected::ArgumentName) => \"argument name\",\n+            Some(Expected::Identifier) => \"identifier\",\n+            Some(Expected::BindingPattern) => \"binding pattern\",\n+            None => \"pattern\",\n+        }\n+    }\n+}\n \n const WHILE_PARSING_OR_MSG: &str = \"while parsing this or-pattern starting here\";\n \n@@ -76,7 +92,7 @@ impl<'a> Parser<'a> {\n     /// Corresponds to `pat<no_top_alt>` in RFC 2535 and does not admit or-patterns\n     /// at the top level. Used when parsing the parameters of lambda expressions,\n     /// functions, function pointers, and `pat` macro fragments.\n-    pub fn parse_pat_no_top_alt(&mut self, expected: Expected) -> PResult<'a, P<Pat>> {\n+    pub fn parse_pat_no_top_alt(&mut self, expected: Option<Expected>) -> PResult<'a, P<Pat>> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n@@ -90,7 +106,7 @@ impl<'a> Parser<'a> {\n     /// simplify the grammar somewhat.\n     pub fn parse_pat_allow_top_alt(\n         &mut self,\n-        expected: Expected,\n+        expected: Option<Expected>,\n         rc: RecoverComma,\n         ra: RecoverColon,\n         rt: CommaRecoveryMode,\n@@ -102,7 +118,7 @@ impl<'a> Parser<'a> {\n     /// recovered).\n     fn parse_pat_allow_top_alt_inner(\n         &mut self,\n-        expected: Expected,\n+        expected: Option<Expected>,\n         rc: RecoverComma,\n         ra: RecoverColon,\n         rt: CommaRecoveryMode,\n@@ -182,7 +198,7 @@ impl<'a> Parser<'a> {\n     /// otherwise).\n     pub(super) fn parse_pat_before_ty(\n         &mut self,\n-        expected: Expected,\n+        expected: Option<Expected>,\n         rc: RecoverComma,\n         syntax_loc: PatternLocation,\n     ) -> PResult<'a, (P<Pat>, bool)> {\n@@ -254,7 +270,7 @@ impl<'a> Parser<'a> {\n         }\n \n         self.parse_pat_before_ty(\n-            PARAM_EXPECTED,\n+            Some(Expected::ParameterName),\n             RecoverComma::No,\n             PatternLocation::FunctionParameter,\n         )\n@@ -320,7 +336,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_with_range_pat(\n         &mut self,\n         allow_range_pat: bool,\n-        expected: Expected,\n+        expected: Option<Expected>,\n     ) -> PResult<'a, P<Pat>> {\n         maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole!(self, NtPat, |x| x);\n@@ -416,7 +432,7 @@ impl<'a> Parser<'a> {\n             let lt = self.expect_lifetime();\n             let (lit, _) =\n                 self.recover_unclosed_char(lt.ident, Parser::mk_token_lit_char, |self_| {\n-                    let expected = expected.unwrap_or(\"pattern\");\n+                    let expected = Expected::to_string_or_fallback(expected);\n                     let msg = format!(\n                         \"expected {}, found {}\",\n                         expected,\n@@ -527,7 +543,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `&pat` / `&mut pat`.\n-    fn parse_pat_deref(&mut self, expected: Expected) -> PResult<'a, PatKind> {\n+    fn parse_pat_deref(&mut self, expected: Option<Expected>) -> PResult<'a, PatKind> {\n         self.expect_and()?;\n         if let token::Lifetime(name) = self.token.kind {\n             self.bump(); // `'a`\n@@ -580,7 +596,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // Parse the pattern we hope to be an identifier.\n-        let mut pat = self.parse_pat_no_top_alt(Some(\"identifier\"))?;\n+        let mut pat = self.parse_pat_no_top_alt(Some(Expected::Identifier))?;\n \n         // If we don't have `mut $ident (@ pat)?`, error.\n         if let PatKind::Ident(BindingAnnotation(ByRef::No, m @ Mutability::Not), ..) = &mut pat.kind\n@@ -652,11 +668,11 @@ impl<'a> Parser<'a> {\n     fn fatal_unexpected_non_pat(\n         &mut self,\n         err: DiagnosticBuilder<'a, ErrorGuaranteed>,\n-        expected: Expected,\n+        expected: Option<Expected>,\n     ) -> PResult<'a, P<Pat>> {\n         err.cancel();\n \n-        let expected = expected.unwrap_or(\"pattern\");\n+        let expected = Expected::to_string_or_fallback(expected);\n         let msg = format!(\"expected {}, found {}\", expected, super::token_descr(&self.token));\n \n         let mut err = self.struct_span_err(self.token.span, &msg);\n@@ -809,7 +825,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_ident(&mut self, binding_annotation: BindingAnnotation) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n-            Some(self.parse_pat_no_top_alt(Some(\"binding pattern\"))?)\n+            Some(self.parse_pat_no_top_alt(Some(Expected::BindingPattern))?)\n         } else {\n             None\n         };\n@@ -903,7 +919,7 @@ impl<'a> Parser<'a> {\n             // We cannot use `parse_pat_ident()` since it will complain `box`\n             // is not an identifier.\n             let sub = if self.eat(&token::At) {\n-                Some(self.parse_pat_no_top_alt(Some(\"binding pattern\"))?)\n+                Some(self.parse_pat_no_top_alt(Some(Expected::BindingPattern))?)\n             } else {\n                 None\n             };"}]}