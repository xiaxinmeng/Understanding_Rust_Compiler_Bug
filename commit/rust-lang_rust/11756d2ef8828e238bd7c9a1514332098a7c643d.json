{"sha": "11756d2ef8828e238bd7c9a1514332098a7c643d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNzU2ZDJlZjg4MjhlMjM4YmQ3YzlhMTUxNDMzMjA5OGE3YzY0M2Q=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-18T22:25:38Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-19T19:28:05Z"}, "message": "Refactor enum formatting", "tree": {"sha": "edc3003403b3186ce8f8e4e2c37171182b3a2d0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edc3003403b3186ce8f8e4e2c37171182b3a2d0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11756d2ef8828e238bd7c9a1514332098a7c643d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11756d2ef8828e238bd7c9a1514332098a7c643d", "html_url": "https://github.com/rust-lang/rust/commit/11756d2ef8828e238bd7c9a1514332098a7c643d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11756d2ef8828e238bd7c9a1514332098a7c643d/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "754925e132db97fba0ca84dc41292e4f0e56d392", "url": "https://api.github.com/repos/rust-lang/rust/commits/754925e132db97fba0ca84dc41292e4f0e56d392", "html_url": "https://github.com/rust-lang/rust/commit/754925e132db97fba0ca84dc41292e4f0e56d392"}], "stats": {"total": 304, "additions": 139, "deletions": 165}, "files": [{"sha": "78d354275197c9bf6d49c6e93418960c63c2cac4", "filename": "src/items.rs", "status": "modified", "additions": 108, "deletions": 158, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/11756d2ef8828e238bd7c9a1514332098a7c643d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11756d2ef8828e238bd7c9a1514332098a7c643d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=11756d2ef8828e238bd7c9a1514332098a7c643d", "patch": "@@ -11,17 +11,18 @@\n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n use Indent;\n-use utils::{format_mutability, format_visibility, contains_skip, span_after, end_typaram, wrap_str};\n-use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic,\n-            DefinitiveListTactic, definitive_tactic};\n+use utils::{format_mutability, format_visibility, contains_skip, span_after, end_typaram,\n+            wrap_str, last_line_width};\n+use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic,\n+            DefinitiveListTactic, definitive_tactic, format_item_list};\n use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n use config::{Config, BlockIndentStyle, Density, ReturnIndent, BraceStyle, StructLitStyle};\n \n use syntax::{ast, abi};\n-use syntax::codemap::{self, Span, BytePos};\n+use syntax::codemap::{Span, BytePos, mk_sp};\n use syntax::print::pprust;\n use syntax::parse::token;\n \n@@ -133,7 +134,7 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing_with_indent(item.span.lo);\n         // Drop semicolon or it will be interpreted as comment.\n         // FIXME: this may be a faulty span from libsyntax.\n-        let span = codemap::mk_sp(item.span.lo, item.span.hi - BytePos(1));\n+        let span = mk_sp(item.span.lo, item.span.hi - BytePos(1));\n \n         match item.node {\n             ast::ForeignItem_::ForeignItemFn(ref fn_decl, ref generics) => {\n@@ -247,7 +248,7 @@ impl<'a> FmtVisitor<'a> {\n                                span: Span)\n                                -> Option<String> {\n         // Drop semicolon or it will be interpreted as comment\n-        let span = codemap::mk_sp(span.lo, span.hi - BytePos(1));\n+        let span = mk_sp(span.lo, span.hi - BytePos(1));\n \n         // FIXME: silly formatting of the `.0`.\n         let mut result = try_opt!(self.rewrite_fn_base(indent,\n@@ -313,7 +314,7 @@ impl<'a> FmtVisitor<'a> {\n \n         // Generics.\n         let generics_indent = indent + result.len();\n-        let generics_span = codemap::mk_sp(span.lo, span_for_return(&fd.output).lo);\n+        let generics_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n         let generics_str = try_opt!(self.rewrite_generics(generics,\n                                                           indent,\n                                                           generics_indent,\n@@ -371,10 +372,8 @@ impl<'a> FmtVisitor<'a> {\n                                  .last()\n                                  .map(|tp| end_typaram(tp))\n                                  .unwrap_or(span.lo);\n-        let args_span = codemap::mk_sp(span_after(codemap::mk_sp(args_start, span.hi),\n-                                                  \"(\",\n-                                                  self.codemap),\n-                                       span_for_return(&fd.output).lo);\n+        let args_span = mk_sp(span_after(mk_sp(args_start, span.hi), \"(\", self.codemap),\n+                              span_for_return(&fd.output).lo);\n         let arg_str = try_opt!(self.rewrite_args(&fd.inputs,\n                                                  explicit_self,\n                                                  one_line_budget,\n@@ -437,7 +436,7 @@ impl<'a> FmtVisitor<'a> {\n             let snippet_lo = fd.output.span().hi;\n             if where_clause.predicates.is_empty() {\n                 let snippet_hi = span.hi;\n-                let snippet = self.snippet(codemap::mk_sp(snippet_lo, snippet_hi));\n+                let snippet = self.snippet(mk_sp(snippet_lo, snippet_hi));\n                 let snippet = snippet.trim();\n                 if !snippet.is_empty() {\n                     result.push(' ');\n@@ -527,7 +526,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n \n             let variadic_arg = if variadic {\n-                let variadic_span = codemap::mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n+                let variadic_span = mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n                 let variadic_start = span_after(variadic_span, \"...\", self.codemap) - BytePos(3);\n                 Some(ArgumentKind::Variadic(variadic_start))\n             } else {\n@@ -666,7 +665,7 @@ impl<'a> FmtVisitor<'a> {\n                                                 \" {\",\n                                                 self.block_indent,\n                                                 self.block_indent.block_indent(self.config),\n-                                                codemap::mk_sp(span.lo, body_start))\n+                                                mk_sp(span.lo, body_start))\n                                .unwrap();\n         self.buffer.push_str(&generics_str);\n \n@@ -737,7 +736,7 @@ impl<'a> FmtVisitor<'a> {\n     fn format_variant(&self, field: &ast::Variant) -> Option<String> {\n         if contains_skip(&field.node.attrs) {\n             let lo = field.node.attrs[0].span.lo;\n-            let span = codemap::mk_sp(lo, field.span.hi);\n+            let span = mk_sp(lo, field.span.hi);\n             return Some(self.snippet(span));\n         }\n \n@@ -753,51 +752,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let variant_body = match *field.node.data {\n-            ast::VariantData::Tuple(ref types, _) => {\n-                let mut result = field.node.name.to_string();\n-                let items = itemize_list(self.codemap,\n-                                         types.iter(),\n-                                         \")\",\n-                                         |arg| arg.node.ty.span.lo,\n-                                         |arg| arg.node.ty.span.hi,\n-                                         |arg| {\n-                                             // FIXME silly width, indent\n-                                             arg.node\n-                                                .ty\n-                                                .rewrite(&self.get_context(), 1000, Indent::empty())\n-                                         },\n-                                         span_after(field.span, \"(\", self.codemap),\n-                                         field.span.hi);\n-                let item_vec = items.collect::<Vec<_>>();\n-\n-                result.push('(');\n-\n-                let indent = indent + field.node.name.to_string().len() + \"(\".len();\n-\n-                let comma_cost = if self.config.enum_trailing_comma {\n-                    1\n-                } else {\n-                    0\n-                };\n-                let budget = self.config.max_width - indent.width() - comma_cost - 1; // 1 = )\n-                let tactic = definitive_tactic(&item_vec, ListTactic::HorizontalVertical, budget);\n-\n-                let fmt = ListFormatting {\n-                    tactic: tactic,\n-                    separator: \",\",\n-                    trailing_separator: SeparatorTactic::Never,\n-                    indent: indent,\n-                    width: budget,\n-                    ends_with_newline: true,\n-                    config: self.config,\n-                };\n-                let list_str = try_opt!(write_list(&item_vec, &fmt));\n-\n-                result.push_str(&list_str);\n-                result.push(')');\n-\n-                Some(result)\n-            }\n+            ast::VariantData::Tuple(..) |\n             ast::VariantData::Struct(..) => {\n                 // FIXME: Should limit the width, as we have a trailing comma\n                 self.format_struct(\"\",\n@@ -844,19 +799,17 @@ impl<'a> FmtVisitor<'a> {\n         let header_str = self.format_header(item_name, ident, vis);\n         result.push_str(&header_str);\n \n-        let (is_tuple, fields) = match *struct_def {\n+        let (fields, body_lo, opener, terminator) = match *struct_def {\n             ast::VariantData::Unit(..) => {\n                 result.push(';');\n                 return Some(result);\n             }\n-            ast::VariantData::Tuple(ref vec, _) => (true, vec),\n-            ast::VariantData::Struct(ref vec, _) => (false, vec),\n-        };\n-\n-        let (opener, terminator) = if is_tuple {\n-            (\"(\", \")\")\n-        } else {\n-            (\" {\", \"}\")\n+            ast::VariantData::Tuple(ref vec, _) => {\n+                (vec, vec[0].span.lo, \"(\", \")\")\n+            }\n+            ast::VariantData::Struct(ref vec, _) => {\n+                (vec, span_after(span, \"{\", self.codemap), \" {\", \"}\")\n+            }\n         };\n \n         let generics_str = match generics {\n@@ -865,12 +818,27 @@ impl<'a> FmtVisitor<'a> {\n                                               opener,\n                                               offset,\n                                               offset + header_str.len(),\n-                                              codemap::mk_sp(span.lo, fields[0].span.lo)))\n+                                              mk_sp(span.lo, body_lo)))\n             }\n             None => opener.to_owned(),\n         };\n         result.push_str(&generics_str);\n \n+        // FIXME: properly format empty structs and their comments.\n+        if fields.is_empty() {\n+            result.push_str(&self.snippet(mk_sp(body_lo, span.hi)));\n+            return Some(result);\n+        }\n+\n+        let item_indent = if let ast::VariantData::Tuple(..) = *struct_def {\n+            self.block_indent + result.len()\n+        } else {\n+            offset.block_indent(self.config)\n+        };\n+        // 2 = \");\" or \",\"\n+        let item_budget = try_opt!(self.config.max_width.checked_sub(item_indent.width() + 2));\n+\n+        let context = self.get_context();\n         let items = itemize_list(self.codemap,\n                                  fields.iter(),\n                                  terminator,\n@@ -883,55 +851,38 @@ impl<'a> FmtVisitor<'a> {\n                                      }\n                                  },\n                                  |field| field.node.ty.span.hi,\n-                                 |field| self.format_field(field),\n+                                 |field| field.rewrite(&context, item_budget, item_indent),\n                                  span_after(span, opener.trim(), self.codemap),\n                                  span.hi);\n-\n-        // 2 terminators and a semicolon\n-        let used_budget = offset.width() + header_str.len() + generics_str.len() + 3;\n-\n-        // Conservative approximation\n-        let single_line_cost = (span.hi - fields[0].span.lo).0;\n-        let break_line = !is_tuple || generics_str.contains('\\n') ||\n-                         single_line_cost as usize + used_budget > self.config.max_width;\n-\n-        let tactic = if break_line {\n-            let indentation = offset.block_indent(self.config).to_string(self.config);\n-            result.push('\\n');\n-            result.push_str(&indentation);\n-\n-            DefinitiveListTactic::Vertical\n-        } else {\n-            DefinitiveListTactic::Horizontal\n-        };\n-\n-        // 1 = ,\n-        let budget = self.config.max_width - offset.width() + self.config.tab_spaces - 1;\n-        let fmt = ListFormatting {\n-            tactic: tactic,\n-            separator: \",\",\n-            trailing_separator: self.config.struct_trailing_comma,\n-            indent: offset.block_indent(self.config),\n-            width: budget,\n-            ends_with_newline: true,\n-            config: self.config,\n-        };\n-\n-        let list_str = try_opt!(write_list(items, &fmt));\n-        result.push_str(&list_str);\n-\n-        if break_line {\n-            result.push('\\n');\n-            result.push_str(&offset.to_string(self.config));\n-        }\n-\n-        result.push_str(terminator);\n-\n-        if is_tuple {\n-            result.push(';');\n+        match *struct_def {\n+            ast::VariantData::Tuple(..) => {\n+                // 2 = );\n+                let budget = try_opt!(self.config.max_width.checked_sub(item_indent.width() + 2));\n+                let rewrite = try_opt!(format_item_list(items, budget, item_indent, self.config));\n+                result.push_str(&rewrite);\n+                result.push(')');\n+                Some(result)\n+            }\n+            ast::VariantData::Struct(..) => {\n+                // 1 = ,\n+                let budget = self.config.max_width - offset.width() + self.config.tab_spaces - 1;\n+                let fmt = ListFormatting {\n+                    tactic: DefinitiveListTactic::Vertical,\n+                    separator: \",\",\n+                    trailing_separator: self.config.struct_trailing_comma,\n+                    indent: item_indent,\n+                    width: budget,\n+                    ends_with_newline: true,\n+                    config: self.config,\n+                };\n+                Some(format!(\"{}\\n{}{}\\n{}}}\",\n+                             result,\n+                             offset.block_indent(self.config).to_string(self.config),\n+                             try_opt!(write_list(items, &fmt)),\n+                             offset.to_string(self.config)))\n+            }\n+            _ => unreachable!(),\n         }\n-\n-        Some(result)\n     }\n \n     fn format_header(&self, item_name: &str, ident: ast::Ident, vis: ast::Visibility) -> String {\n@@ -964,45 +915,6 @@ impl<'a> FmtVisitor<'a> {\n         Some(result)\n     }\n \n-    // Field of a struct\n-    fn format_field(&self, field: &ast::StructField) -> Option<String> {\n-        if contains_skip(&field.node.attrs) {\n-            // FIXME: silly width, indent\n-            return wrap_str(self.snippet(codemap::mk_sp(field.node.attrs[0].span.lo,\n-                                                        field.span.hi)),\n-                            self.config.max_width,\n-                            1000,\n-                            Indent::empty());\n-        }\n-\n-        let name = match field.node.kind {\n-            ast::StructFieldKind::NamedField(ident, _) => Some(ident.to_string()),\n-            ast::StructFieldKind::UnnamedField(_) => None,\n-        };\n-        let vis = match field.node.kind {\n-            ast::StructFieldKind::NamedField(_, vis) |\n-            ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n-        };\n-        // FIXME silly width, indent\n-        let typ = try_opt!(field.node.ty.rewrite(&self.get_context(), 1000, Indent::empty()));\n-\n-        let indent = self.block_indent.block_indent(self.config);\n-        let mut attr_str = try_opt!(field.node\n-                                         .attrs\n-                                         .rewrite(&self.get_context(),\n-                                                  self.config.max_width - indent.width(),\n-                                                  indent));\n-        if !attr_str.is_empty() {\n-            attr_str.push('\\n');\n-            attr_str.push_str(&indent.to_string(self.config));\n-        }\n-\n-        Some(match name {\n-            Some(name) => format!(\"{}{}{}: {}\", attr_str, vis, name, typ),\n-            None => format!(\"{}{}{}\", attr_str, vis, typ),\n-        })\n-    }\n-\n     fn rewrite_generics(&self,\n                         generics: &ast::Generics,\n                         offset: Indent,\n@@ -1039,7 +951,7 @@ impl<'a> FmtVisitor<'a> {\n             } else {\n                 l.bounds[l.bounds.len() - 1].span.hi\n             };\n-            codemap::mk_sp(l.lifetime.span.lo, hi)\n+            mk_sp(l.lifetime.span.lo, hi)\n         });\n         let ty_spans = tys.iter().map(span_for_ty_param);\n \n@@ -1122,6 +1034,44 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n+impl Rewrite for ast::StructField {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+        if contains_skip(&self.node.attrs) {\n+            let span = context.snippet(mk_sp(self.node.attrs[0].span.lo, self.span.hi));\n+            return wrap_str(span, context.config.max_width, width, offset);\n+        }\n+\n+        let name = match self.node.kind {\n+            ast::StructFieldKind::NamedField(ident, _) => Some(ident.to_string()),\n+            ast::StructFieldKind::UnnamedField(_) => None,\n+        };\n+        let vis = match self.node.kind {\n+            ast::StructFieldKind::NamedField(_, vis) |\n+            ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n+        };\n+        let indent = context.block_indent.block_indent(context.config);\n+        let mut attr_str = try_opt!(self.node\n+                                        .attrs\n+                                        .rewrite(context,\n+                                                 context.config.max_width - indent.width(),\n+                                                 indent));\n+        if !attr_str.is_empty() {\n+            attr_str.push('\\n');\n+            attr_str.push_str(&indent.to_string(context.config));\n+        }\n+\n+        let result = match name {\n+            Some(name) => format!(\"{}{}{}: \", attr_str, vis, name),\n+            None => format!(\"{}{}\", attr_str, vis),\n+        };\n+\n+        let last_line_width = last_line_width(&result);\n+        let budget = try_opt!(width.checked_sub(last_line_width));\n+        let rewrite = try_opt!(self.node.ty.rewrite(context, budget, offset + last_line_width));\n+        Some(result + &rewrite)\n+    }\n+}\n+\n pub fn rewrite_static(prefix: &str,\n                       vis: ast::Visibility,\n                       ident: ast::Ident,\n@@ -1254,7 +1204,7 @@ fn span_for_ty_param(ty: &ast::TyParam) -> Span {\n     // Note that ty.span is the span for ty.ident, not the whole item.\n     let lo = ty.span.lo;\n     if let Some(ref def) = ty.default {\n-        return codemap::mk_sp(lo, def.span.hi);\n+        return mk_sp(lo, def.span.hi);\n     }\n     if ty.bounds.is_empty() {\n         return ty.span;\n@@ -1263,7 +1213,7 @@ fn span_for_ty_param(ty: &ast::TyParam) -> Span {\n         ast::TyParamBound::TraitTyParamBound(ref ptr, _) => ptr.span.hi,\n         ast::TyParamBound::RegionTyParamBound(ref l) => l.span.hi,\n     };\n-    codemap::mk_sp(lo, hi)\n+    mk_sp(lo, hi)\n }\n \n fn span_for_where_pred(pred: &ast::WherePredicate) -> Span {"}, {"sha": "6ea296a36b7c74401976fa95daade4d18589b1c1", "filename": "src/visitor.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11756d2ef8828e238bd7c9a1514332098a7c643d/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11756d2ef8828e238bd7c9a1514332098a7c643d/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=11756d2ef8828e238bd7c9a1514332098a7c643d", "patch": "@@ -195,7 +195,13 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                                  def,\n                                                  Some(generics),\n                                                  item.span,\n-                                                 indent);\n+                                                 indent)\n+                                  .map(|s| {\n+                                      match **def {\n+                                          ast::VariantData::Tuple(..) => s + \";\",\n+                                          _ => s,\n+                                      }\n+                                  });\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::Item_::ItemEnum(ref def, ref generics) => {"}, {"sha": "eba7587727793b4b0d7e4b2f0c41dd51ae6de8a6", "filename": "tests/source/enum.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Fsource%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Fsource%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fenum.rs?ref=11756d2ef8828e238bd7c9a1514332098a7c643d", "patch": "@@ -92,3 +92,7 @@ fn nested_enum_test() {\n         }\n     }\n }\n+\n+   pub  struct  EmtpyWithComment {\n+    // FIXME: Implement this struct\n+}"}, {"sha": "2bdfe7325bc657fdaca4c82aaea95e8c669a4a70", "filename": "tests/source/structs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Fsource%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Fsource%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstructs.rs?ref=11756d2ef8828e238bd7c9a1514332098a7c643d", "patch": "@@ -115,3 +115,9 @@ struct FieldsWithAttributes {\n     #[attr1]\n     #[attr2] pub id: usize // CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCC CCCCCCCCCCCC\n }\n+\n+struct Deep {\n+    deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeep: node::Handle<IdRef<'id, Node<K, V>>,\n+                                                     Type,\n+                                                     NodeType>,\n+}"}, {"sha": "04391d8f30c6b6ebaeed74bff9241afcd1b8c6b6", "filename": "tests/target/enum.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=11756d2ef8828e238bd7c9a1514332098a7c643d", "patch": "@@ -140,3 +140,7 @@ fn nested_enum_test() {\n         }\n     }\n }\n+\n+pub struct EmtpyWithComment {\n+    // FIXME: Implement this struct\n+}"}, {"sha": "4bc8c6bbe44b3b8dd091ef90d60f6b04612ac3f3", "filename": "tests/target/structs.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Ftarget%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11756d2ef8828e238bd7c9a1514332098a7c643d/tests%2Ftarget%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstructs.rs?ref=11756d2ef8828e238bd7c9a1514332098a7c643d", "patch": "@@ -34,12 +34,10 @@ struct Qux<'a,\n     pub W,\n );\n \n-struct Tuple(\n-    // Comment 1\n-    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n-    // Comment 2\n-    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\n-);\n+struct Tuple(// Comment 1\n+             AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+             // Comment 2\n+             BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB);\n \n // With a where clause and generics.\n pub struct Foo<'a, Y: Baz>\n@@ -113,3 +111,9 @@ struct FieldsWithAttributes {\n     pub id: usize, /* CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCC\n                     * CCCCCCCCCCCCCC CCCCCCCCCCCC */\n }\n+\n+struct Deep {\n+    deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeep: node::Handle<IdRef<'id, Node<K, V>>,\n+                                                                         Type,\n+                                                                         NodeType>,\n+}"}]}