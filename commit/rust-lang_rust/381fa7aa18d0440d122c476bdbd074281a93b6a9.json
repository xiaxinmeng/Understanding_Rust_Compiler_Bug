{"sha": "381fa7aa18d0440d122c476bdbd074281a93b6a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MWZhN2FhMThkMDQ0MGQxMjJjNDc2YmRiZDA3NDI4MWE5M2I2YTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-20T17:46:47Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: move ty::print::PrintConfig's fields to FmtPrinter.", "tree": {"sha": "8ecc8f40eb2beb407bbe7dc5d2a9d275c797812f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ecc8f40eb2beb407bbe7dc5d2a9d275c797812f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/381fa7aa18d0440d122c476bdbd074281a93b6a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/381fa7aa18d0440d122c476bdbd074281a93b6a9", "html_url": "https://github.com/rust-lang/rust/commit/381fa7aa18d0440d122c476bdbd074281a93b6a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/381fa7aa18d0440d122c476bdbd074281a93b6a9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a0f3a285697b6238793ce3c1353f0d2f0c28938", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0f3a285697b6238793ce3c1353f0d2f0c28938", "html_url": "https://github.com/rust-lang/rust/commit/1a0f3a285697b6238793ce3c1353f0d2f0c28938"}], "stats": {"total": 375, "additions": 185, "deletions": 190}, "files": [{"sha": "a7ce53e9876ac3ab4a92b52b780036b5cca6e229", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -526,9 +526,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n                 let abs_path = |def_id| {\n-                    PrintCx::with(self.tcx, AbsolutePathPrinter, |cx| {\n-                        cx.print_def_path(def_id, None, iter::empty())\n-                    })\n+                    PrintCx::new(self.tcx, AbsolutePathPrinter)\n+                        .print_def_path(def_id, None, iter::empty())\n                 };\n \n                 // We compare strings because DefPath can be different"}, {"sha": "f649309004bfcf595c3346e783a777992bf6c6d6", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -84,9 +84,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         if let Some(highlight) = highlight {\n             printer.region_highlight_mode = highlight;\n         }\n-        let _ = ty::print::PrintCx::with(self.tcx, printer, |cx| {\n-            ty.print(cx)\n-        });\n+        let _ = ty.print(ty::print::PrintCx::new(self.tcx, printer));\n         s\n     }\n "}, {"sha": "fd01ed85ef72134bf4ad98935e42233042d2d6d0", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -347,10 +347,8 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 let mut printer = ty::print::FmtPrinter::new(f, Namespace::TypeNS);\n                 printer.region_highlight_mode = self.highlight;\n \n-                ty::print::PrintCx::with(self.tcx, printer, |cx| {\n-                    self.value.print(cx)?;\n-                    Ok(())\n-                })\n+                self.value.print(ty::print::PrintCx::new(self.tcx, printer))?;\n+                Ok(())\n             }\n         }\n "}, {"sha": "aac76025951fb1f88148cd74e168fead767f1722", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -4,52 +4,50 @@ use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::subst::{Subst, SubstsRef};\n \n use rustc_data_structures::fx::FxHashSet;\n-use syntax::symbol::InternedString;\n \n use std::iter;\n-use std::ops::Deref;\n+use std::ops::{Deref, DerefMut};\n \n // `pretty` is a separate module only for organization.\n mod pretty;\n pub use self::pretty::*;\n \n-#[derive(Default)]\n-struct PrintConfig {\n-    used_region_names: Option<FxHashSet<InternedString>>,\n-    region_index: usize,\n-    binder_depth: usize,\n-}\n-\n pub struct PrintCx<'a, 'gcx, 'tcx, P> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    pub printer: P,\n-    config: &'a mut PrintConfig,\n+    inner: P,\n }\n \n-// HACK(eddyb) this is solely for `self: PrintCx<Self>`, e.g. to\n-// implement traits on the printer and call the methods on the context.\n impl<P> Deref for PrintCx<'_, '_, '_, P> {\n     type Target = P;\n     fn deref(&self) -> &P {\n-        &self.printer\n+        &self.inner\n+    }\n+}\n+\n+impl<P> DerefMut for PrintCx<'_, '_, '_, P> {\n+    fn deref_mut(&mut self) -> &mut P {\n+        &mut self.inner\n     }\n }\n \n impl<'a, 'gcx, 'tcx, P> PrintCx<'a, 'gcx, 'tcx, P> {\n-    pub fn with<R>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        printer: P,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, P>) -> R,\n-    ) -> R {\n-        f(PrintCx {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, inner: P) -> Self {\n+        PrintCx {\n             tcx,\n-            printer,\n-            config: &mut PrintConfig::default(),\n-        })\n+            inner,\n+        }\n+    }\n+\n+    pub fn with_tls_tcx<R>(inner: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n+        ty::tls::with(|tcx| f(PrintCx::new(tcx, inner)))\n+    }\n+\n+    pub fn into_inner(self) -> P {\n+        self.inner\n     }\n \n-    pub fn with_tls_tcx<R>(printer: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n-        ty::tls::with(|tcx| PrintCx::with(tcx, printer, f))\n+    pub fn ok<E>(self) -> Result<P, E> {\n+        Ok(self.into_inner())\n     }\n }\n "}, {"sha": "1f609dbc6e56fed7ebbbee7ee28f448e500df843", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 143, "deletions": 136, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -15,6 +15,7 @@ use syntax::symbol::InternedString;\n use std::cell::Cell;\n use std::fmt::{self, Write as _};\n use std::iter;\n+use std::ops::{Deref, DerefMut};\n \n // `pretty` is a separate module only for organization.\n use super::*;\n@@ -26,7 +27,7 @@ macro_rules! nest {\n }\n macro_rules! print_inner {\n     (write ($($data:expr),+)) => {\n-        write!(scoped_cx!().printer, $($data),+)?\n+        write!(scoped_cx!(), $($data),+)?\n     };\n     ($kind:ident ($data:expr)) => {\n         nest!(|cx| $data.$kind(cx))\n@@ -185,16 +186,7 @@ pub trait PrettyPrinter:\n         self: PrintCx<'a, 'gcx, 'tcx, Self>,\n         f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n     ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n-        let printer = f(PrintCx {\n-            tcx: self.tcx,\n-            printer: self.printer,\n-            config: self.config,\n-        })?;\n-        Ok(PrintCx {\n-            tcx: self.tcx,\n-            printer,\n-            config: self.config,\n-        })\n+        Ok(PrintCx::new(self.tcx, f(self)?))\n     }\n \n     /// Like `print_def_path` but for value paths.\n@@ -243,6 +235,12 @@ pub trait PrettyPrinter:\n     ) -> bool;\n }\n \n+impl<P: PrettyPrinter> fmt::Write for PrintCx<'_, '_, '_, P> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        (**self).write_str(s)\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n     // (but also some things just print a `DefId` generally so maybe we need this?)\n@@ -268,31 +266,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let ns = self.guess_def_namespace(def_id);\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         let mut s = String::new();\n-        let _ = PrintCx::with(self, FmtPrinter::new(&mut s, ns), |cx| {\n-            cx.print_def_path(def_id, None, iter::empty())\n-        });\n+        let _ = PrintCx::new(self, FmtPrinter::new(&mut s, ns))\n+            .print_def_path(def_id, None, iter::empty());\n         s\n     }\n }\n \n-pub struct FmtPrinter<F: fmt::Write> {\n-    fmt: F,\n-    empty: bool,\n-    in_value: bool,\n-    pub region_highlight_mode: RegionHighlightMode,\n-}\n-\n-impl<F: fmt::Write> FmtPrinter<F> {\n-    pub fn new(fmt: F, ns: Namespace) -> Self {\n-        FmtPrinter {\n-            fmt,\n-            empty: true,\n-            in_value: ns == Namespace::ValueNS,\n-            region_highlight_mode: RegionHighlightMode::default(),\n-        }\n-    }\n-}\n-\n impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n     /// If possible, this returns a global path resolving to `def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `def_id` is\n@@ -346,7 +325,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         }\n \n         if def_id.is_local() {\n-            return Ok((self.printer, false));\n+            return self.ok().map(|path| (path, false));\n         }\n \n         let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n@@ -366,20 +345,20 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n \n         let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n             Some(parent) => parent,\n-            None => return Ok((self.printer, false)),\n+            None => return self.ok().map(|path| (path, false)),\n         };\n         // HACK(eddyb) this uses `nest` to avoid knowing ahead of time whether\n         // the entire path will succeed or not. To support printers that do not\n         // implement `PrettyPrinter`, a `Vec` or linked list on the stack would\n         // need to be built, before starting to print anything.\n         let mut prefix_success = false;\n         nest!(|cx| {\n-            let (printer, success) = cx.try_print_visible_def_path(visible_parent)?;\n+            let (path, success) = cx.try_print_visible_def_path(visible_parent)?;\n             prefix_success = success;\n-            Ok(printer)\n+            Ok(path)\n         });\n         if !prefix_success {\n-            return Ok((self.printer, false));\n+            return self.ok().map(|path| (path, false));\n         };\n         let actual_parent = self.tcx.parent(def_id);\n         debug!(\n@@ -445,7 +424,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             },\n         };\n         debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n-        Ok((self.path_append(|cx| Ok(cx.printer), &symbol)?, true))\n+        Ok((self.path_append(|cx| cx.ok(), &symbol)?, true))\n     }\n \n     pub fn pretty_path_qualified(\n@@ -475,7 +454,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             if let Some(trait_ref) = trait_ref {\n                 p!(write(\" as \"), print(trait_ref));\n             }\n-            Ok(cx.printer)\n+            cx.ok()\n         })\n     }\n \n@@ -498,7 +477,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n             p!(print(self_ty));\n \n-            Ok(cx.printer)\n+            cx.ok()\n         })\n     }\n \n@@ -556,7 +535,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         let projection0 = projections.next();\n \n         if arg0.is_none() && projection0.is_none() {\n-            return Ok(self.printer);\n+            return self.ok();\n         }\n \n         self.generic_delimiters(|mut cx| {\n@@ -568,7 +547,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                     empty = false;\n                     Ok(())\n                 } else {\n-                    write!(cx.printer, \", \")\n+                    write!(cx, \", \")\n                 }\n             };\n \n@@ -598,11 +577,54 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                    print(projection.ty));\n             }\n \n-            Ok(cx.printer)\n+            cx.ok()\n         })\n     }\n }\n \n+// HACK(eddyb) boxed to avoid moving around a large struct by-value.\n+pub struct FmtPrinter<F>(Box<FmtPrinterData<F>>);\n+\n+pub struct FmtPrinterData<F> {\n+    fmt: F,\n+\n+    empty: bool,\n+    in_value: bool,\n+\n+    used_region_names: FxHashSet<InternedString>,\n+    region_index: usize,\n+    binder_depth: usize,\n+\n+    pub region_highlight_mode: RegionHighlightMode,\n+}\n+\n+impl<F> Deref for FmtPrinter<F> {\n+    type Target = FmtPrinterData<F>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<F> DerefMut for FmtPrinter<F> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+impl<F> FmtPrinter<F> {\n+    pub fn new(fmt: F, ns: Namespace) -> Self {\n+        FmtPrinter(Box::new(FmtPrinterData {\n+            fmt,\n+            empty: true,\n+            in_value: ns == Namespace::ValueNS,\n+            used_region_names: Default::default(),\n+            region_index: 0,\n+            binder_depth: 0,\n+            region_highlight_mode: RegionHighlightMode::default(),\n+        }))\n+    }\n+}\n+\n impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         self.empty &= s.is_empty();\n@@ -629,17 +651,17 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         if generics.as_ref().and_then(|g| g.parent).is_none() {\n             let mut visible_path_success = false;\n             self = self.nest(|cx| {\n-                let (printer, success) = cx.try_print_visible_def_path(def_id)?;\n+                let (path, success) = cx.try_print_visible_def_path(def_id)?;\n                 visible_path_success = success;\n-                Ok(printer)\n+                Ok(path)\n             })?;\n             if visible_path_success {\n                 return if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let has_own_self = generics.has_self && generics.parent_count == 0;\n                     let params = &generics.params[has_own_self as usize..];\n-                    self.path_generic_args(|cx| Ok(cx.printer), params, substs, projections)\n+                    self.path_generic_args(|cx| cx.ok(), params, substs, projections)\n                 } else {\n-                    Ok(self.printer)\n+                    self.ok()\n                 };\n             }\n         }\n@@ -693,14 +715,13 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n             if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired.\n                 if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n-                    write!(self.printer, \"{}\", keywords::Crate.name())?;\n+                    write!(self, \"{}\", keywords::Crate.name())?;\n                 }\n             }\n-            Ok(self.printer)\n         } else {\n-            write!(self.printer, \"{}\", self.tcx.crate_name(cnum))?;\n-            Ok(self.printer)\n+            write!(self, \"{}\", self.tcx.crate_name(cnum))?;\n         }\n+        self.ok()\n     }\n     fn path_qualified(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -719,15 +740,15 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n         self.pretty_path_append_impl(|cx| {\n-            let mut printer = print_prefix(cx)?;\n+            let mut path = print_prefix(cx)?;\n \n             // HACK(eddyb) this accounts for `generic_delimiters`\n             // printing `::<` instead of `<` if `in_value` is set.\n-            if !printer.empty && !printer.in_value {\n-                write!(printer, \"::\")?;\n+            if !path.empty && !path.in_value {\n+                write!(path, \"::\")?;\n             }\n \n-            Ok(printer)\n+            Ok(path)\n         }, self_ty, trait_ref)\n     }\n     fn path_append<'gcx, 'tcx>(\n@@ -737,18 +758,18 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         ) -> Result<Self::Path, Self::Error>,\n         text: &str,\n     ) -> Result<Self::Path, Self::Error> {\n-        let mut printer = print_prefix(self)?;\n+        let mut path = print_prefix(self)?;\n \n         // FIXME(eddyb) `text` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n         if !text.is_empty() {\n-            if !printer.empty {\n-                write!(printer, \"::\")?;\n+            if !path.empty {\n+                write!(path, \"::\")?;\n             }\n-            write!(printer, \"{}\", text)?;\n+            write!(path, \"{}\", text)?;\n         }\n \n-        Ok(printer)\n+        Ok(path)\n     }\n     fn path_generic_args<'gcx, 'tcx>(\n         self: PrintCx<'_, 'gcx, 'tcx, Self>,\n@@ -768,30 +789,23 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         mut self: PrintCx<'a, 'gcx, 'tcx, Self>,\n         f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n     ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n-        let was_empty = std::mem::replace(&mut self.printer.empty, true);\n-        let mut printer = f(PrintCx {\n-            tcx: self.tcx,\n-            printer: self.printer,\n-            config: self.config,\n-        })?;\n-        printer.empty &= was_empty;\n-        Ok(PrintCx {\n-            tcx: self.tcx,\n-            printer,\n-            config: self.config,\n-        })\n+        let tcx = self.tcx;\n+        let was_empty = std::mem::replace(&mut self.empty, true);\n+        let mut inner = f(self)?;\n+        inner.empty &= was_empty;\n+        Ok(PrintCx::new(tcx, inner))\n     }\n \n     fn print_value_path(\n         mut self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        let was_in_value = std::mem::replace(&mut self.printer.in_value, true);\n-        let mut printer = self.print_def_path(def_id, substs, iter::empty())?;\n-        printer.in_value = was_in_value;\n+        let was_in_value = std::mem::replace(&mut self.in_value, true);\n+        let mut path = self.print_def_path(def_id, substs, iter::empty())?;\n+        path.in_value = was_in_value;\n \n-        Ok(printer)\n+        Ok(path)\n     }\n \n     fn in_binder<T>(\n@@ -807,18 +821,18 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n         f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error> {\n-        if !self.printer.empty && self.printer.in_value {\n-            write!(self.printer, \"::<\")?;\n+        if !self.empty && self.in_value {\n+            write!(self, \"::<\")?;\n         } else {\n-            write!(self.printer, \"<\")?;\n+            write!(self, \"<\")?;\n         }\n \n-        let was_in_value = std::mem::replace(&mut self.printer.in_value, false);\n-        let mut printer = f(self)?;\n-        printer.in_value = was_in_value;\n+        let was_in_value = std::mem::replace(&mut self.in_value, false);\n+        let mut inner = f(self)?;\n+        inner.in_value = was_in_value;\n \n-        write!(printer, \">\")?;\n-        Ok(printer)\n+        write!(inner, \">\")?;\n+        Ok(inner)\n     }\n \n     fn always_print_region_in_paths(\n@@ -832,7 +846,7 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         self: &PrintCx<'_, '_, '_, Self>,\n         region: ty::Region<'_>,\n     ) -> bool {\n-        let highlight = self.printer.region_highlight_mode;\n+        let highlight = self.region_highlight_mode;\n         if highlight.region_highlighted(region).is_some() {\n             return true;\n         }\n@@ -889,15 +903,15 @@ impl<F: fmt::Write> FmtPrinter<F> {\n         define_scoped_cx!(self);\n \n         // Watch out for region highlights.\n-        let highlight = self.printer.region_highlight_mode;\n+        let highlight = self.region_highlight_mode;\n         if let Some(n) = highlight.region_highlighted(region) {\n             p!(write(\"'{}\", n));\n-            return Ok(self.printer);\n+            return self.ok();\n         }\n \n         if self.tcx.sess.verbose() {\n             p!(write(\"{:?}\", region));\n-            return Ok(self.printer);\n+            return self.ok();\n         }\n \n         let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n@@ -918,7 +932,7 @@ impl<F: fmt::Write> FmtPrinter<F> {\n                 if let ty::BrNamed(_, name) = br {\n                     if name != \"\" && name != \"'_\" {\n                         p!(write(\"{}\", name));\n-                        return Ok(self.printer);\n+                        return self.ok();\n                     }\n                 }\n \n@@ -958,7 +972,7 @@ impl<F: fmt::Write> FmtPrinter<F> {\n             ty::ReClosureBound(vid) => p!(write(\"{:?}\", vid)),\n         }\n \n-        Ok(self.printer)\n+        self.ok()\n     }\n }\n \n@@ -1056,7 +1070,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 // FIXME(eddyb) print this with `print_def_path`.\n                 if self.tcx.sess.verbose() {\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n-                    return Ok(self.printer);\n+                    return self.ok();\n                 }\n \n                 let def_key = self.tcx.def_key(def_id);\n@@ -1072,7 +1086,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                         }\n                         p!(write(\">\"));\n                     }\n-                    return Ok(self.printer);\n+                    return self.ok();\n                 }\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n@@ -1216,7 +1230,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n         }\n \n-        Ok(self.printer)\n+        self.ok()\n     }\n \n     pub fn pretty_fn_sig(\n@@ -1243,11 +1257,18 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             p!(write(\" -> \"), print(output));\n         }\n \n-        Ok(self.printer)\n+        self.ok()\n     }\n+}\n \n-    pub fn pretty_in_binder<T>(mut self, value: &ty::Binder<T>) -> Result<P, fmt::Error>\n-        where T: Print<'tcx, P, Output = P, Error = fmt::Error> + TypeFoldable<'tcx>\n+// HACK(eddyb) limited to `FmtPrinter` because of `binder_depth`,\n+// `region_index` and `used_region_names`.\n+impl<F: fmt::Write> FmtPrinter<F> {\n+    pub fn pretty_in_binder<T>(\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, fmt::Error>\n+        where T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n             match index {\n@@ -1262,13 +1283,13 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n-        if self.config.binder_depth == 0 {\n+        if self.binder_depth == 0 {\n             self.prepare_late_bound_region_info(value);\n         }\n \n         let mut empty = true;\n         let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n-            write!(cx.printer, \"{}\", if empty {\n+            write!(cx, \"{}\", if empty {\n                 empty = false;\n                 start\n             } else {\n@@ -1278,13 +1299,13 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n \n         define_scoped_cx!(self);\n \n-        let old_region_index = self.config.region_index;\n+        let old_region_index = self.region_index;\n         let mut region_index = old_region_index;\n         let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n             let _ = start_or_continue(&mut self, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n-                    let _ = write!(self.printer, \"{}\", name);\n+                    let _ = write!(self, \"{}\", name);\n                     br\n                 }\n                 ty::BrAnon(_) |\n@@ -1293,37 +1314,32 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                     let name = loop {\n                         let name = name_by_region_index(region_index);\n                         region_index += 1;\n-                        if !self.is_name_used(&name) {\n+                        if !self.used_region_names.contains(&name) {\n                             break name;\n                         }\n                     };\n-                    let _ = write!(self.printer, \"{}\", name);\n+                    let _ = write!(self, \"{}\", name);\n                     ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n                 }\n             };\n             self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n         }).0;\n         start_or_continue(&mut self, \"\", \"> \")?;\n \n-        // Push current state to gcx, and restore after writing new_value.\n-        self.config.binder_depth += 1;\n-        self.config.region_index = region_index;\n-        let result = new_value.print(PrintCx {\n-            tcx: self.tcx,\n-            printer: self.printer,\n-            config: self.config,\n-        });\n-        self.config.region_index = old_region_index;\n-        self.config.binder_depth -= 1;\n-        result\n+        self.binder_depth += 1;\n+        self.region_index = region_index;\n+        let mut inner = new_value.print(self)?;\n+        inner.region_index = old_region_index;\n+        inner.binder_depth -= 1;\n+        Ok(inner)\n     }\n \n     fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n-    where T: TypeFoldable<'tcx>\n+        where T: TypeFoldable<'tcx>\n     {\n \n-        struct LateBoundRegionNameCollector(FxHashSet<InternedString>);\n-        impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n+        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<InternedString>);\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n                 match *r {\n                     ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n@@ -1335,17 +1351,10 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n         }\n \n-        let mut collector = LateBoundRegionNameCollector(Default::default());\n+        self.used_region_names.clear();\n+        let mut collector = LateBoundRegionNameCollector(&mut self.used_region_names);\n         value.visit_with(&mut collector);\n-        self.config.used_region_names = Some(collector.0);\n-        self.config.region_index = 0;\n-    }\n-\n-    fn is_name_used(&self, name: &InternedString) -> bool {\n-        match self.config.used_region_names {\n-            Some(ref names) => names.contains(name),\n-            None => false,\n-        }\n+        self.region_index = 0;\n     }\n }\n \n@@ -1377,10 +1386,10 @@ impl<T> LiftAndPrintToFmt<'tcx> for T\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         f: &mut fmt::Formatter<'_>,\n     ) -> fmt::Result {\n-        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.tcx.lift(self).expect(\"could not lift for printing\").print(cx)?;\n-            Ok(())\n-        })\n+        tcx.lift(self)\n+            .expect(\"could not lift for printing\")\n+            .print(PrintCx::new(tcx, FmtPrinter::new(f, Namespace::TypeNS)))?;\n+        Ok(())\n     }\n }\n \n@@ -1391,10 +1400,8 @@ impl LiftAndPrintToFmt<'tcx> for ty::RegionKind {\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         f: &mut fmt::Formatter<'_>,\n     ) -> fmt::Result {\n-        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            self.print(cx)?;\n-            Ok(())\n-        })\n+        self.print(PrintCx::new(tcx, FmtPrinter::new(f, Namespace::TypeNS)))?;\n+        Ok(())\n     }\n }\n \n@@ -1427,7 +1434,7 @@ macro_rules! define_print_and_forward_display {\n                 define_scoped_cx!($cx);\n                 let _: () = $print;\n                 #[allow(unreachable_code)]\n-                Ok($cx.printer)\n+                $cx.ok()\n             }\n         }\n \n@@ -1555,7 +1562,7 @@ define_print_and_forward_display! {\n     ty::InferTy {\n         if cx.tcx.sess.verbose() {\n             p!(write(\"{:?}\", self));\n-            return Ok(cx.printer);\n+            return cx.ok();\n         }\n         match *self {\n             ty::TyVar(_) => p!(write(\"_\")),"}, {"sha": "b7e69f64f5ae313a5e8f5688081c09034c660a2c", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -224,11 +224,10 @@ fn get_symbol_hash<'a, 'tcx>(\n }\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    PrintCx::with(tcx, SymbolPath::new(tcx), |cx| {\n-        cx.print_def_path(def_id, None, iter::empty())\n-            .unwrap()\n-            .into_interned()\n-    })\n+    PrintCx::new(tcx, SymbolPath::new(tcx))\n+        .print_def_path(def_id, None, iter::empty())\n+        .unwrap()\n+        .into_interned()\n }\n \n fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n@@ -415,7 +414,7 @@ impl Printer for SymbolPath {\n         self: PrintCx<'_, '_, '_, Self>,\n         _region: ty::Region<'_>,\n     ) -> Result<Self::Region, Self::Error> {\n-        Ok(self.printer)\n+        self.ok()\n     }\n \n     fn print_type(\n@@ -440,8 +439,8 @@ impl Printer for SymbolPath {\n         mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.printer.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n-        Ok(self.printer)\n+        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n+        self.ok()\n     }\n     fn path_qualified(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -524,10 +523,10 @@ impl PrettyPrinter for SymbolPath {\n         mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n         f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error> {\n-        write!(self.printer, \"<\")?;\n+        write!(self, \"<\")?;\n \n         let kept_within_component =\n-            mem::replace(&mut self.printer.keep_within_component, true);\n+            mem::replace(&mut self.keep_within_component, true);\n         let mut path = f(self)?;\n         path.keep_within_component = kept_within_component;\n "}, {"sha": "d7dd0313e9487332f4ed86e08615b0cfa778c5e7", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -2341,9 +2341,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let _ = ty::print::PrintCx::with(self.infcx.tcx, printer, |cx| {\n-            ty.print(cx)\n-        });\n+        let _ = ty.print(ty::print::PrintCx::new(self.infcx.tcx, printer));\n         s\n     }\n \n@@ -2368,9 +2366,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n         };\n \n-        let _ = ty::print::PrintCx::with(self.infcx.tcx, printer, |cx| {\n-            region.print(cx)\n-        });\n+        let _ = region.print(ty::print::PrintCx::new(self.infcx.tcx, printer));\n         s\n     }\n }"}, {"sha": "c486628a4f54688d0d2b7a9a300a3a003f2bba57", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381fa7aa18d0440d122c476bdbd074281a93b6a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=381fa7aa18d0440d122c476bdbd074281a93b6a9", "patch": "@@ -4312,9 +4312,9 @@ where F: Fn(DefId) -> Def {\n         }\n     }\n \n-    let names = PrintCx::with(tcx, AbsolutePathPrinter, |cx| {\n-        cx.print_def_path(def_id, None, iter::empty()).unwrap()\n-    });\n+    let names = PrintCx::new(tcx, AbsolutePathPrinter)\n+        .print_def_path(def_id, None, iter::empty())\n+        .unwrap();\n \n     hir::Path {\n         span: DUMMY_SP,"}]}