{"sha": "83da9a89d8316c76dd6262c6aa10b74e549308bd", "node_id": "C_kwDOAAsO6NoAKDgzZGE5YTg5ZDgzMTZjNzZkZDYyNjJjNmFhMTBiNzRlNTQ5MzA4YmQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-09T19:53:59Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-10T19:22:55Z"}, "message": "Directly construct Inherited.", "tree": {"sha": "59389641f709078e61f0dbe9e39ae6ae43220bc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59389641f709078e61f0dbe9e39ae6ae43220bc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83da9a89d8316c76dd6262c6aa10b74e549308bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83da9a89d8316c76dd6262c6aa10b74e549308bd", "html_url": "https://github.com/rust-lang/rust/commit/83da9a89d8316c76dd6262c6aa10b74e549308bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83da9a89d8316c76dd6262c6aa10b74e549308bd/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a0961bbc8fba75bb863c7835b39d431ad9fc5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a0961bbc8fba75bb863c7835b39d431ad9fc5d", "html_url": "https://github.com/rust-lang/rust/commit/35a0961bbc8fba75bb863c7835b39d431ad9fc5d"}], "stats": {"total": 327, "additions": 151, "deletions": 176}, "files": [{"sha": "4110b176b41b1f8f6bc8726abf81f6df98140bc2", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/83da9a89d8316c76dd6262c6aa10b74e549308bd/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83da9a89d8316c76dd6262c6aa10b74e549308bd/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=83da9a89d8316c76dd6262c6aa10b74e549308bd", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n-use rustc_infer::infer;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -73,40 +72,16 @@ impl<'tcx> Deref for Inherited<'tcx> {\n     }\n }\n \n-/// A temporary returned by `Inherited::build(...)`. This is necessary\n-/// for multiple `InferCtxt` to share the same `typeck_results`\n-/// without using `Rc` or something similar.\n-pub struct InheritedBuilder<'tcx> {\n-    infcx: infer::InferCtxtBuilder<'tcx>,\n-    typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n-}\n-\n impl<'tcx> Inherited<'tcx> {\n-    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n-        InheritedBuilder {\n-            infcx: tcx\n-                .infer_ctxt()\n-                .ignoring_regions()\n-                .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)),\n-            typeck_results: RefCell::new(ty::TypeckResults::new(hir_owner)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> InheritedBuilder<'tcx> {\n-    pub fn enter<F, R>(mut self, f: F) -> R\n-    where\n-        F: FnOnce(&Inherited<'tcx>) -> R,\n-    {\n-        f(&Inherited::new(self.infcx.build(), self.typeck_results))\n-    }\n-}\n-\n-impl<'tcx> Inherited<'tcx> {\n-    fn new(infcx: InferCtxt<'tcx>, typeck_results: RefCell<ty::TypeckResults<'tcx>>) -> Self {\n-        let tcx = infcx.tcx;\n+        let infcx = tcx\n+            .infer_ctxt()\n+            .ignoring_regions()\n+            .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n+            .build();\n+        let typeck_results = RefCell::new(ty::TypeckResults::new(hir_owner));\n \n         Inherited {\n             typeck_results,"}, {"sha": "1846ab4baf38de25bf6d8c51f6e08175b5cd05b2", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 112, "deletions": 111, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/83da9a89d8316c76dd6262c6aa10b74e549308bd/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83da9a89d8316c76dd6262c6aa10b74e549308bd/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=83da9a89d8316c76dd6262c6aa10b74e549308bd", "patch": "@@ -45,13 +45,14 @@ mod rvalue_scopes;\n mod upvar;\n mod writeback;\n \n-pub use diverges::Diverges;\n-pub use expectation::Expectation;\n-pub use fn_ctxt::*;\n-pub use inherited::{Inherited, InheritedBuilder};\n+pub use fn_ctxt::FnCtxt;\n+pub use inherited::Inherited;\n \n use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n+use crate::diverges::Diverges;\n+use crate::expectation::Expectation;\n+use crate::fn_ctxt::RawTy;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{\n@@ -206,135 +207,135 @@ fn typeck_with_fallback<'tcx>(\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n-        let param_env = tcx.param_env(def_id);\n-        let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n-            param_env.without_const()\n+    let param_env = tcx.param_env(def_id);\n+    let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+        param_env.without_const()\n+    } else {\n+        param_env\n+    };\n+    let inh = Inherited::new(tcx, def_id);\n+    let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n+\n+    if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n+            fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n         } else {\n-            param_env\n+            tcx.fn_sig(def_id).subst_identity()\n         };\n-        let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n \n-        if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n-            let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n-            } else {\n-                tcx.fn_sig(def_id).subst_identity()\n-            };\n+        check_abi(tcx, id, span, fn_sig.abi());\n \n-            check_abi(tcx, id, span, fn_sig.abi());\n+        // Compute the function signature from point of view of inside the fn.\n+        let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n+        let fn_sig = fcx.normalize(body.value.span, fn_sig);\n \n-            // Compute the function signature from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n-            let fn_sig = fcx.normalize(body.value.span, fn_sig);\n-\n-            check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n-        } else {\n-            let expected_type = body_ty\n-                .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n-                    _ => None,\n-                })\n-                .unwrap_or_else(|| match tcx.hir().get(id) {\n-                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().parent_id(id)) {\n-                        Node::Expr(&hir::Expr {\n-                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n-                            ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Typeof(ref anon_const), ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+        check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n+    } else {\n+        let expected_type = body_ty\n+            .and_then(|ty| match ty.kind {\n+                hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n+                _ => None,\n+            })\n+            .unwrap_or_else(|| match tcx.hir().get(id) {\n+                Node::AnonConst(_) => match tcx.hir().get(tcx.hir().parent_id(id)) {\n+                    Node::Expr(&hir::Expr {\n+                        kind: hir::ExprKind::ConstBlock(ref anon_const),\n+                        ..\n+                    }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span,\n+                    }),\n+                    Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref anon_const), .. })\n+                        if anon_const.hir_id == id =>\n+                    {\n+                        fcx.next_ty_var(TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::TypeInference,\n                             span,\n-                        }),\n-                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty =\n-                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n-                                    hir::InlineAsmOperand::Const { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        // Inline assembly constants must be integers.\n-                                        Some(fcx.next_int_var())\n-                                    }\n-                                    hir::InlineAsmOperand::SymFn { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n-                                            kind: TypeVariableOriginKind::MiscVariable,\n-                                            span,\n-                                        }))\n-                                    }\n-                                    _ => None,\n-                                });\n-                            operand_ty.unwrap_or_else(fallback)\n-                        }\n-                        _ => fallback(),\n-                    },\n+                        })\n+                    }\n+                    Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                    | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                        let operand_ty = asm.operands.iter().find_map(|(op, _op_sp)| match op {\n+                            hir::InlineAsmOperand::Const { anon_const }\n+                                if anon_const.hir_id == id =>\n+                            {\n+                                // Inline assembly constants must be integers.\n+                                Some(fcx.next_int_var())\n+                            }\n+                            hir::InlineAsmOperand::SymFn { anon_const }\n+                                if anon_const.hir_id == id =>\n+                            {\n+                                Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                    span,\n+                                }))\n+                            }\n+                            _ => None,\n+                        });\n+                        operand_ty.unwrap_or_else(fallback)\n+                    }\n                     _ => fallback(),\n-                });\n+                },\n+                _ => fallback(),\n+            });\n \n-            let expected_type = fcx.normalize(body.value.span, expected_type);\n-            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n+        let expected_type = fcx.normalize(body.value.span, expected_type);\n+        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n-            // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor::new(&fcx).visit_body(body);\n+        // Gather locals in statics (because of block expressions).\n+        GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n+        fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n \n-            fcx.write_ty(id, expected_type);\n-        };\n+        fcx.write_ty(id, expected_type);\n+    };\n \n-        fcx.type_inference_fallback();\n-\n-        // Even though coercion casts provide type hints, we check casts after fallback for\n-        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n-        fcx.check_casts();\n-        fcx.select_obligations_where_possible(|_| {});\n-\n-        // Closure and generator analysis may run after fallback\n-        // because they don't constrain other type variables.\n-        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n-        let prev_constness = fcx.param_env.constness();\n-        fcx.param_env = fcx.param_env.without_const();\n-        fcx.closure_analyze(body);\n-        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n-        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n-        // Before the generator analysis, temporary scopes shall be marked to provide more\n-        // precise information on types to be captured.\n-        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-\n-        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize(span, ty);\n-            fcx.require_type_is_sized(ty, span, code);\n-        }\n+    fcx.type_inference_fallback();\n+\n+    // Even though coercion casts provide type hints, we check casts after fallback for\n+    // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n+    fcx.check_casts();\n+    fcx.select_obligations_where_possible(|_| {});\n+\n+    // Closure and generator analysis may run after fallback\n+    // because they don't constrain other type variables.\n+    // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n+    let prev_constness = fcx.param_env.constness();\n+    fcx.param_env = fcx.param_env.without_const();\n+    fcx.closure_analyze(body);\n+    fcx.param_env = fcx.param_env.with_constness(prev_constness);\n+    assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n+    // Before the generator analysis, temporary scopes shall be marked to provide more\n+    // precise information on types to be captured.\n+    fcx.resolve_rvalue_scopes(def_id.to_def_id());\n+\n+    for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n+        let ty = fcx.normalize(span, ty);\n+        fcx.require_type_is_sized(ty, span, code);\n+    }\n \n-        fcx.select_obligations_where_possible(|_| {});\n+    fcx.select_obligations_where_possible(|_| {});\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        // This must be the last thing before `report_ambiguity_errors`.\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n+    // This must be the last thing before `report_ambiguity_errors`.\n+    fcx.resolve_generator_interiors(def_id.to_def_id());\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.report_ambiguity_errors();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.report_ambiguity_errors();\n+    }\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.check_transmutes();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.check_transmutes();\n+    }\n \n-        fcx.check_asms();\n+    fcx.check_asms();\n \n-        fcx.infcx.skip_region_resolution();\n+    fcx.infcx.skip_region_resolution();\n \n-        fcx.resolve_type_vars_in_body(body)\n-    });\n+    let typeck_results = fcx.resolve_type_vars_in_body(body);\n \n     // Consistency check our TypeckResults instance can hold all ItemLocalIds\n     // it will need to hold."}, {"sha": "4c4c003ca469122825ba59a3500beed1a81aac25", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83da9a89d8316c76dd6262c6aa10b74e549308bd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83da9a89d8316c76dd6262c6aa10b74e549308bd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=83da9a89d8316c76dd6262c6aa10b74e549308bd", "patch": "@@ -369,10 +369,10 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n             Node::Item(item) => {\n                 if let ItemKind::Fn(_, _, body_id) = &item.kind\n                 && let output_ty = return_ty(cx, item.owner_id)\n-                && Inherited::build(cx.tcx, item.owner_id.def_id).enter(|inherited| {\n-                    let fn_ctxt = FnCtxt::new(inherited, cx.param_env, item.owner_id.def_id);\n-                    fn_ctxt.can_coerce(ty, output_ty)\n-                }) {\n+                && let inherited = Inherited::new(cx.tcx, item.owner_id.def_id)\n+                && let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, item.owner_id.def_id)\n+                && fn_ctxt.can_coerce(ty, output_ty)\n+                {\n                     if has_lifetime(output_ty) && has_lifetime(ty) {\n                         return false;\n                     }"}, {"sha": "62efd13b8d909a072232c40757ccd6e9b91de0b4", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/83da9a89d8316c76dd6262c6aa10b74e549308bd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83da9a89d8316c76dd6262c6aa10b74e549308bd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=83da9a89d8316c76dd6262c6aa10b74e549308bd", "patch": "@@ -33,38 +33,37 @@ pub(super) fn check_cast<'tcx>(\n     let hir_id = e.hir_id;\n     let local_def_id = hir_id.owner.def_id;\n \n-    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(inherited, cx.param_env, local_def_id);\n+    let inherited = Inherited::new(cx.tcx, local_def_id);\n+    let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, local_def_id);\n \n-        // If we already have errors, we can't be sure we can pointer cast.\n+    // If we already have errors, we can't be sure we can pointer cast.\n+    assert!(\n+        !fn_ctxt.errors_reported_since_creation(),\n+        \"Newly created FnCtxt contained errors\"\n+    );\n+\n+    if let Ok(check) = cast::CastCheck::new(\n+        &fn_ctxt,\n+        e,\n+        from_ty,\n+        to_ty,\n+        // We won't show any error to the user, so we don't care what the span is here.\n+        DUMMY_SP,\n+        DUMMY_SP,\n+        hir::Constness::NotConst,\n+    ) {\n+        let res = check.do_check(&fn_ctxt);\n+\n+        // do_check's documentation says that it might return Ok and create\n+        // errors in the fcx instead of returning Err in some cases. Those cases\n+        // should be filtered out before getting here.\n         assert!(\n             !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n+            \"`fn_ctxt` contained errors after cast check!\"\n         );\n \n-        if let Ok(check) = cast::CastCheck::new(\n-            &fn_ctxt,\n-            e,\n-            from_ty,\n-            to_ty,\n-            // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP,\n-            DUMMY_SP,\n-            hir::Constness::NotConst,\n-        ) {\n-            let res = check.do_check(&fn_ctxt);\n-\n-            // do_check's documentation says that it might return Ok and create\n-            // errors in the fcx instead of returning Err in some cases. Those cases\n-            // should be filtered out before getting here.\n-            assert!(\n-                !fn_ctxt.errors_reported_since_creation(),\n-                \"`fn_ctxt` contained errors after cast check!\"\n-            );\n-\n-            res.ok()\n-        } else {\n-            None\n-        }\n-    })\n+        res.ok()\n+    } else {\n+        None\n+    }\n }"}]}