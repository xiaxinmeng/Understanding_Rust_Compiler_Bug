{"sha": "37a94b80f207e86017e54056ced2dc9674907ae3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YTk0YjgwZjIwN2U4NjAxN2U1NDA1NmNlZDJkYzk2NzQ5MDdhZTM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-04T12:19:02Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-26T00:37:45Z"}, "message": "Use temp vars for implicit coercion to ^[T]", "tree": {"sha": "05fca5f77317c944b5d8da3198e8a0619fb60225", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05fca5f77317c944b5d8da3198e8a0619fb60225"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a94b80f207e86017e54056ced2dc9674907ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a94b80f207e86017e54056ced2dc9674907ae3", "html_url": "https://github.com/rust-lang/rust/commit/37a94b80f207e86017e54056ced2dc9674907ae3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a94b80f207e86017e54056ced2dc9674907ae3/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "html_url": "https://github.com/rust-lang/rust/commit/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6"}], "stats": {"total": 596, "additions": 381, "deletions": 215}, "files": [{"sha": "d13767077c7ac7fbdd90e1a6d464db539340cc7a", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -2557,7 +2557,7 @@ mod tests {\n     }\n \n     fn rng() -> rand::IsaacRng {\n-        let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::SeedableRng::from_seed(seed)\n     }\n "}, {"sha": "418bb147d204a5e2ec15c0ae2bd5d1f750f3155e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -1088,7 +1088,8 @@ mod tests {\n         let n = list_from([1i,2,3]);\n         spawn(proc() {\n             check_links(&n);\n-            assert_eq!(&[&1,&2,&3], n.iter().collect::<Vec<&int>>().as_slice());\n+            let a: &[_] = &[&1,&2,&3];\n+            assert_eq!(a, n.iter().collect::<Vec<&int>>().as_slice());\n         });\n     }\n "}, {"sha": "ef26452a52902e8fd22d0d53edccb4af161c26ac", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -346,7 +346,8 @@ mod tests {\n         assert_eq!(hasher.hash(&'a'), 97);\n \n         assert_eq!(hasher.hash(&(\"a\")), 97 + 0xFF);\n-        assert_eq!(hasher.hash(& &[1u8, 2u8, 3u8]), 9);\n+        let cs: &[u8] = &[1u8, 2u8, 3u8];\n+        assert_eq!(hasher.hash(& cs), 9);\n \n         unsafe {\n             let ptr: *const int = mem::transmute(5i);"}, {"sha": "f3798e5f9e0094ad6dd1df5f29947d3a36706596", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -495,8 +495,8 @@ mod tests {\n         assert!(s != t && t != u);\n         assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n \n-        let v = (&[1u8], &[0u8, 0], &[0u8]);\n-        let w = (&[1u8, 0, 0, 0], &[], &[]);\n+        let v: (&[u8], &[u8], &[u8]) = (&[1u8], &[0u8, 0], &[0u8]);\n+        let w: (&[u8], &[u8], &[u8]) = (&[1u8, 0, 0, 0], &[], &[]);\n \n         assert!(v != w);\n         assert!(hash(&v) != hash(&w));"}, {"sha": "d2cfb510bc058ee0da306fff53f7f50934bfab0f", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -865,12 +865,18 @@ mod tests {\n         for i in range(0i, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&0,&1,&2,&3,&4]);\n+        {\n+            let b: &[_] = &[&0,&1,&2,&3,&4];\n+            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+        }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&8,&7,&6,&0,&1,&2,&3,&4]);\n+        {\n+            let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n+            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+        }\n \n         let mut it = d.iter();\n         let mut len = d.len();\n@@ -890,12 +896,16 @@ mod tests {\n         for i in range(0i, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n+        {\n+            let b: &[_] = &[&4,&3,&2,&1,&0];\n+            assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+        }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n+        let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n     }\n \n     #[test]"}, {"sha": "55723ec10a062abe961a4fac182cd0fbe789939b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 143, "deletions": 76, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -698,11 +698,13 @@ pub trait MutableOrdSlice<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = &mut [0i, 1, 2];\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n     /// v.next_permutation();\n-    /// assert_eq!(v, &mut [0i, 2, 1]);\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n     /// v.next_permutation();\n-    /// assert_eq!(v, &mut [1i, 0, 2]);\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n     /// ```\n     fn next_permutation(self) -> bool;\n \n@@ -714,11 +716,13 @@ pub trait MutableOrdSlice<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = &mut [1i, 0, 2];\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n     /// v.prev_permutation();\n-    /// assert_eq!(v, &mut [0i, 2, 1]);\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n     /// v.prev_permutation();\n-    /// assert_eq!(v, &mut [0i, 1, 2]);\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n     /// ```\n     fn prev_permutation(self) -> bool;\n }\n@@ -905,9 +909,11 @@ mod tests {\n     #[test]\n     fn test_tail() {\n         let mut a = vec![11i];\n-        assert_eq!(a.tail(), &[]);\n+        let b: &[int] = &[];\n+        assert_eq!(a.tail(), b);\n         a = vec![11i, 12];\n-        assert_eq!(a.tail(), &[12]);\n+        let b: &[int] = &[12];\n+        assert_eq!(a.tail(), b);\n     }\n \n     #[test]\n@@ -920,9 +926,11 @@ mod tests {\n     #[test]\n     fn test_tailn() {\n         let mut a = vec![11i, 12, 13];\n-        assert_eq!(a.tailn(0), &[11, 12, 13]);\n+        let b: &[int] = &[11, 12, 13];\n+        assert_eq!(a.tailn(0), b);\n         a = vec![11i, 12, 13];\n-        assert_eq!(a.tailn(2), &[13]);\n+        let b: &[int] = &[13];\n+        assert_eq!(a.tailn(2), b);\n     }\n \n     #[test]\n@@ -935,9 +943,11 @@ mod tests {\n     #[test]\n     fn test_init() {\n         let mut a = vec![11i];\n-        assert_eq!(a.init(), &[]);\n+        let b: &[int] = &[];\n+        assert_eq!(a.init(), b);\n         a = vec![11i, 12];\n-        assert_eq!(a.init(), &[11]);\n+        let b: &[int] = &[11];\n+        assert_eq!(a.init(), b);\n     }\n \n     #[test]\n@@ -950,9 +960,11 @@ mod tests {\n     #[test]\n     fn test_initn() {\n         let mut a = vec![11i, 12, 13];\n-        assert_eq!(a.as_slice().initn(0), &[11, 12, 13]);\n+        let b: &[int] = &[11, 12, 13];\n+        assert_eq!(a.as_slice().initn(0), b);\n         a = vec![11i, 12, 13];\n-        assert_eq!(a.as_slice().initn(2), &[11]);\n+        let b: &[int] = &[11];\n+        assert_eq!(a.as_slice().initn(2), b);\n     }\n \n     #[test]\n@@ -1005,18 +1017,22 @@ mod tests {\n \n     #[test]\n     fn test_slice_from() {\n-        let vec = &[1i, 2, 3, 4];\n+        let vec: &[int] = &[1, 2, 3, 4];\n         assert_eq!(vec.slice_from(0), vec);\n-        assert_eq!(vec.slice_from(2), &[3, 4]);\n-        assert_eq!(vec.slice_from(4), &[]);\n+        let b: &[int] = &[3, 4];\n+        assert_eq!(vec.slice_from(2), b);\n+        let b: &[int] = &[];\n+        assert_eq!(vec.slice_from(4), b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n-        let vec = &[1i, 2, 3, 4];\n+        let vec: &[int] = &[1, 2, 3, 4];\n         assert_eq!(vec.slice_to(4), vec);\n-        assert_eq!(vec.slice_to(2), &[1, 2]);\n-        assert_eq!(vec.slice_to(0), &[]);\n+        let b: &[int] = &[1, 2];\n+        assert_eq!(vec.slice_to(2), b);\n+        let b: &[int] = &[];\n+        assert_eq!(vec.slice_to(0), b);\n     }\n \n \n@@ -1270,51 +1286,62 @@ mod tests {\n         let v : &mut[int] = &mut[1i, 2, 3, 4, 5];\n         assert!(v.prev_permutation() == false);\n         assert!(v.next_permutation());\n-        assert_eq!(v, &mut[1, 2, 3, 5, 4]);\n+        let b: &mut[int] = &mut[1, 2, 3, 5, 4];\n+        assert!(v == b);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[1, 2, 3, 4, 5]);\n+        let b: &mut[int] = &mut[1, 2, 3, 4, 5];\n+        assert!(v == b);\n         assert!(v.next_permutation());\n         assert!(v.next_permutation());\n-        assert_eq!(v, &mut[1, 2, 4, 3, 5]);\n+        let b: &mut[int] = &mut[1, 2, 4, 3, 5];\n+        assert!(v == b);\n         assert!(v.next_permutation());\n-        assert_eq!(v, &mut[1, 2, 4, 5, 3]);\n+        let b: &mut[int] = &mut[1, 2, 4, 5, 3];\n+        assert!(v == b);\n \n         let v : &mut[int] = &mut[1i, 0, 0, 0];\n         assert!(v.next_permutation() == false);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[0, 1, 0, 0]);\n+        let b: &mut[int] = &mut[0, 1, 0, 0];\n+        assert!(v == b);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[0, 0, 1, 0]);\n+        let b: &mut[int] = &mut[0, 0, 1, 0];\n+        assert!(v == b);\n         assert!(v.prev_permutation());\n-        assert_eq!(v, &mut[0, 0, 0, 1]);\n+        let b: &mut[int] = &mut[0, 0, 0, 1];\n+        assert!(v == b);\n         assert!(v.prev_permutation() == false);\n     }\n \n     #[test]\n     fn test_lexicographic_permutations_empty_and_short() {\n         let empty : &mut[int] = &mut[];\n         assert!(empty.next_permutation() == false);\n-        assert_eq!(empty, &mut[]);\n+        let b: &mut[int] = &mut[];\n+        assert!(empty == b);\n         assert!(empty.prev_permutation() == false);\n-        assert_eq!(empty, &mut[]);\n+        assert!(empty == b);\n \n         let one_elem : &mut[int] = &mut[4i];\n         assert!(one_elem.prev_permutation() == false);\n-        assert_eq!(one_elem, &mut[4]);\n+        let b: &mut[int] = &mut[4];\n+        assert!(one_elem == b);\n         assert!(one_elem.next_permutation() == false);\n-        assert_eq!(one_elem, &mut[4]);\n+        assert!(one_elem == b);\n \n         let two_elem : &mut[int] = &mut[1i, 2];\n         assert!(two_elem.prev_permutation() == false);\n-        assert_eq!(two_elem, &mut[1, 2]);\n+        let b : &mut[int] = &mut[1, 2];\n+        let c : &mut[int] = &mut[2, 1];\n+        assert!(two_elem == b);\n         assert!(two_elem.next_permutation());\n-        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem == c);\n         assert!(two_elem.next_permutation() == false);\n-        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem == c);\n         assert!(two_elem.prev_permutation());\n-        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem == b);\n         assert!(two_elem.prev_permutation() == false);\n-        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem == b);\n     }\n \n     #[test]\n@@ -1468,7 +1495,10 @@ mod tests {\n         assert_eq!(v.concat_vec(), vec![]);\n         assert_eq!([vec![1i], vec![2i,3i]].concat_vec(), vec![1, 2, 3]);\n \n-        assert_eq!([&[1i], &[2i,3i]].concat_vec(), vec![1, 2, 3]);\n+        let v: [&[int], ..2] = [&[1], &[2, 3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n+        let v: [&[int], ..3] = [&[1], &[2], &[3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -1478,8 +1508,10 @@ mod tests {\n         assert_eq!([vec![1i], vec![2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n         assert_eq!([vec![1i], vec![2i], vec![3i]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n \n-        assert_eq!([&[1i], &[2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([&[1i], &[2i], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        let v: [&[int], ..2] = [&[1], &[2, 3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n+        let v: [&[int], ..3] = [&[1], &[2], &[3]];\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -1637,11 +1669,16 @@ mod tests {\n \n     #[test]\n     fn test_total_ord() {\n-        [1i, 2, 3, 4].cmp(& &[1, 2, 3]) == Greater;\n-        [1i, 2, 3].cmp(& &[1, 2, 3, 4]) == Less;\n-        [1i, 2, 3, 4].cmp(& &[1, 2, 3, 4]) == Equal;\n-        [1i, 2, 3, 4, 5, 5, 5, 5].cmp(& &[1, 2, 3, 4, 5, 6]) == Less;\n-        [2i, 2].cmp(& &[1, 2, 3, 4]) == Greater;\n+        let c: &[int] = &[1, 2, 3];\n+        [1, 2, 3, 4].cmp(& c) == Greater;\n+        let c: &[int] = &[1, 2, 3, 4];\n+        [1, 2, 3].cmp(& c) == Less;\n+        let c: &[int] = &[1, 2, 3, 6];\n+        [1, 2, 3, 4].cmp(& c) == Equal;\n+        let c: &[int] = &[1, 2, 3, 4, 5, 6];\n+        [1, 2, 3, 4, 5, 5, 5, 5].cmp(& c) == Less;\n+        let c: &[int] = &[1, 2, 3, 4];\n+        [2, 2].cmp(& c) == Greater;\n     }\n \n     #[test]\n@@ -1765,74 +1802,95 @@ mod tests {\n     fn test_splitator() {\n         let xs = &[1i,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[1], &[3], &[5]];\n         assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1], &[3], &[5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[2,3,4,5]];\n         assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1,2,3,4], &[]];\n         assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4], &[]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[], &[], &[], &[], &[]];\n         assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[], &[], &[], &[], &[]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1], &[3,4,5]];\n         assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1], &[3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[], &[], &[4,5]];\n         assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[], &[], &[4,5]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_rsplitator() {\n         let xs = &[1i,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[5], &[3], &[1]];\n         assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[5], &[3], &[1]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[2,3,4,5], &[]];\n         assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[2,3,4,5], &[]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[1,2,3,4]];\n         assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[1,2,3,4]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n+        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n         assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[1,2,3,4,5]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[5], &[1,2,3]];\n         assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[5], &[1,2,3]]);\n+                   splits);\n+        let splits: &[&[int]] = &[&[], &[], &[], &[1,2]];\n         assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n-                   &[&[], &[], &[], &[1,2]]);\n+                   splits);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n+        let splits: &[&[int]] = &[&[]];\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n-        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), &[&[1,2], &[2,3], &[3,4]]);\n-        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3], &[2,3,4]]);\n+        let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n+        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), wins);\n+        let wins: &[&[int]] = &[&[1i,2,3], &[2,3,4]];\n+        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -1847,16 +1905,23 @@ mod tests {\n     fn test_chunksator() {\n         let v = &[1i,2,3,4,5];\n \n-        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2], &[3,4], &[5]]);\n-        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3], &[4,5]]);\n-        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3,4,5]]);\n+        let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n+        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n+        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        let chunks: &[&[int]] = &[&[1i,2,3,4,5]];\n+        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), chunks);\n \n-        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), &[&[5i], &[3,4], &[1,2]]);\n+        let chunks: &[&[int]] = &[&[5i], &[3,4], &[1,2]];\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n-        assert_eq!(it.idx(0).unwrap(), &[1,2]);\n-        assert_eq!(it.idx(1).unwrap(), &[3,4]);\n-        assert_eq!(it.idx(2).unwrap(), &[5]);\n+        let chunk: &[int] = &[1,2];\n+        assert_eq!(it.idx(0).unwrap(), chunk);\n+        let chunk: &[int] = &[3,4];\n+        assert_eq!(it.idx(1).unwrap(), chunk);\n+        let chunk: &[int] = &[5];\n+        assert_eq!(it.idx(2).unwrap(), chunk);\n         assert_eq!(it.idx(3), None);\n     }\n \n@@ -1924,10 +1989,12 @@ mod tests {\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\".to_string());\n-        test_show_vec!(&mut[1i], \"[1]\".to_string());\n-        test_show_vec!(&mut[1i, 2, 3], \"[1, 2, 3]\".to_string());\n-        test_show_vec!(&mut[&mut[], &mut[1u], &mut[1u, 1u]],\n-                       \"[[], [1], [1, 1]]\".to_string());\n+        let v: &mut[int] = &mut[1];\n+        test_show_vec!(v, \"[1]\".to_string());\n+        let v: &mut[int] = &mut[1, 2, 3];\n+        test_show_vec!(v, \"[1, 2, 3]\".to_string());\n+        let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n+        test_show_vec!(v, \"[[], [1], [1, 1]]\".to_string());\n     }\n \n     #[test]"}, {"sha": "1145e1f3573198b3b6232c53a7a2fd1842a48e6d", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -1265,38 +1265,44 @@ mod tests {\n     fn test_trim_left_chars() {\n         let v: &[char] = &[];\n         assert_eq!(\" *** foo *** \".trim_left_chars(v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_chars(&['*', ' ']), \"\");\n-        assert_eq!(\"foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n+        let chars: &[char] = &['*', ' '];\n+        assert_eq!(\" *** foo *** \".trim_left_chars(chars), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_chars(chars), \"\");\n+        assert_eq!(\"foo *** \".trim_left_chars(chars), \"foo *** \");\n \n         assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n-        assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\");\n+        let chars: &[char] = &['1', '2'];\n+        assert_eq!(\"12foo1bar12\".trim_left_chars(chars), \"foo1bar12\");\n         assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n         let v: &[char] = &[];\n         assert_eq!(\" *** foo *** \".trim_right_chars(v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_right_chars(&['*', ' ']), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_chars(&['*', ' ']), \"\");\n-        assert_eq!(\" *** foo\".trim_right_chars(&['*', ' ']), \" *** foo\");\n+        let chars: &[char] = &['*', ' '];\n+        assert_eq!(\" *** foo *** \".trim_right_chars(chars), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_chars(chars), \"\");\n+        assert_eq!(\" *** foo\".trim_right_chars(chars), \" *** foo\");\n \n         assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\");\n+        let chars: &[char] = &['1', '2'];\n+        assert_eq!(\"12foo1bar12\".trim_right_chars(chars), \"12foo1bar\");\n         assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n         let v: &[char] = &[];\n         assert_eq!(\" *** foo *** \".trim_chars(v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_chars(&['*', ' ']), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_chars(&['*', ' ']), \"\");\n-        assert_eq!(\"foo\".trim_chars(&['*', ' ']), \"foo\");\n+        let chars: &[char] = &['*', ' '];\n+        assert_eq!(\" *** foo *** \".trim_chars(chars), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_chars(chars), \"\");\n+        assert_eq!(\"foo\".trim_chars(chars), \"foo\");\n \n         assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\");\n+        let chars: &[char] = &['1', '2'];\n+        assert_eq!(\"12foo1bar12\".trim_chars(chars), \"foo1bar\");\n         assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\");\n     }\n \n@@ -1443,7 +1449,8 @@ mod tests {\n             184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n             109\n         ];\n-        assert_eq!(\"\".as_bytes(), &[]);\n+        let b: &[u8] = &[];\n+        assert_eq!(\"\".as_bytes(), b);\n         assert_eq!(\"abc\".as_bytes(), b\"abc\");\n         assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v.as_slice());\n     }\n@@ -1542,19 +1549,23 @@ mod tests {\n     #[test]\n     fn test_truncate_utf16_at_nul() {\n         let v = [];\n-        assert_eq!(truncate_utf16_at_nul(v), &[]);\n+        let b: &[u16] = &[];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [0, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), &[]);\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [1, 0, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), &[1]);\n+        let b: &[u16] = &[1];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [1, 2, 0];\n-        assert_eq!(truncate_utf16_at_nul(v), &[1, 2]);\n+        let b: &[u16] = &[1, 2];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n \n         let v = [1, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), &[1, 2, 3]);\n+        let b: &[u16] = &[1, 2, 3];\n+        assert_eq!(truncate_utf16_at_nul(v), b);\n     }\n \n     #[test]\n@@ -2494,7 +2505,8 @@ mod bench {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').count();\n \n-        b.iter(|| assert_eq!(s.split(&[' ']).count(), len));\n+        let c: &[char] = &[' '];\n+        b.iter(|| assert_eq!(s.split(c).count(), len));\n     }\n \n     #[bench]"}, {"sha": "8e5ffbd1686605a55612d08d35fec4dcc42b41ab", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -1853,7 +1853,8 @@ mod test_treemap {\n         check_equal(ctrl.as_slice(), &map);\n         assert!(map.find(&5).is_none());\n \n-        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n+        let seed: &[_] = &[42];\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n \n         for _ in range(0u, 3) {\n             for _ in range(0u, 90) {"}, {"sha": "47df8ae68cdd2d2cb8ed472b0787296182b44e45", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -221,8 +221,14 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n-            Some(ref mut x) => slice::mut_ref_slice(x),\n-            None => &mut []\n+            Some(ref mut x) => {\n+                let result: &mut [T] = slice::mut_ref_slice(x);\n+                result\n+            }\n+            None => {\n+                let result: &mut [T] = &mut [];\n+                result\n+            }\n         }\n     }\n "}, {"sha": "5cbeda94d0f8607d95c8c48300c0636ebb99d2d7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -918,8 +918,8 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n ///\n /// // \"ab\\0d\"\n /// v[2] = 0;\n-/// assert_eq!(str::truncate_utf16_at_nul(v),\n-///            &['a' as u16, 'b' as u16]);\n+/// let b: &[_] = &['a' as u16, 'b' as u16];\n+/// assert_eq!(str::truncate_utf16_at_nul(v), b);\n /// ```\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n@@ -1439,7 +1439,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n     /// ```\n     fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n@@ -1454,7 +1455,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n     /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n     /// ```\n     fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n@@ -1469,7 +1471,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n     /// ```\n     fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n@@ -1620,7 +1623,8 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n     ///\n     /// // neither are found\n-    /// assert_eq!(s.find(&['1', '2']), None);\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.find(x), None);\n     /// ```\n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n \n@@ -1644,7 +1648,8 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n     ///\n     /// // searches for an occurrence of either `1` or `2`, but neither are found\n-    /// assert_eq!(s.rfind(&['1', '2']), None);\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.rfind(x), None);\n     /// ```\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n "}, {"sha": "ba45d2b2e73ff2c569dc240c3b97a96ad41b1907", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -1449,8 +1449,8 @@ mod biguint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let data: Vec<BigUint> = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n-            .iter().map(|v| BigUint::from_slice(*v)).collect();\n+        let data: [&[_], ..7] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ];\n+        let data: Vec<BigUint> = data.iter().map(|v| BigUint::from_slice(*v)).collect();\n         for (i, ni) in data.iter().enumerate() {\n             for (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n                 let j = j0 + i;\n@@ -2311,7 +2311,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n+        let vs: [&[BigDigit], ..4] = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n         let mut nums = Vec::new();\n         for s in vs.iter().rev() {\n             nums.push(BigInt::from_slice(Minus, *s));"}, {"sha": "0f7cda42a8a0ccf0237a93831ad825895870ec46", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -13,7 +13,6 @@\n use core::prelude::*;\n use core::iter::{range_step, Repeat};\n use core::slice::raw;\n-use core::mem;\n \n use {Rng, SeedableRng, Rand};\n \n@@ -46,6 +45,7 @@ static EMPTY: IsaacRng = IsaacRng {\n };\n \n impl IsaacRng {\n+\n     /// Create an ISAAC random number generator using the default\n     /// fixed seed.\n     pub fn new_unseeded() -> IsaacRng {\n@@ -225,7 +225,7 @@ impl Rand for IsaacRng {\n             let ptr = ret.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8,\n-                                  mem::size_of_val(&ret.rsl), |slice| {\n+                                  (RAND_SIZE*4) as uint, |slice| {\n                 other.fill_bytes(slice);\n             })\n         }\n@@ -456,7 +456,7 @@ impl Rand for Isaac64Rng {\n             let ptr = ret.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8,\n-                                  mem::size_of_val(&ret.rsl), |slice| {\n+                                  (RAND_SIZE_64*8) as uint, |slice| {\n                 other.fill_bytes(slice);\n             })\n         }\n@@ -497,15 +497,15 @@ mod test {\n \n     #[test]\n     fn test_rng_32_seeded() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_seeded() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n@@ -537,15 +537,15 @@ mod test {\n \n     #[test]\n     fn test_rng_32_true_values() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = Vec::from_fn(10, |_| ra.next_u32());\n         assert_eq!(v,\n                    vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n                         4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n \n-        let seed = &[12345, 67890, 54321, 9876];\n+        let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u32(); }\n@@ -557,7 +557,7 @@ mod test {\n     }\n     #[test]\n     fn test_rng_64_true_values() {\n-        let seed = &[1, 23, 456, 7890, 12345];\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = Vec::from_fn(10, |_| ra.next_u64());\n@@ -567,7 +567,7 @@ mod test {\n                         4469761996653280935, 15552757044682284409, 6860251611068737823,\n                         13722198873481261842));\n \n-        let seed = &[12345, 67890, 54321, 9876];\n+        let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u64(); }"}, {"sha": "5f460225d39a933fe033ab87fe7287c14ad333ed", "filename": "src/librand/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -309,7 +309,8 @@ pub trait SeedableRng<Seed>: Rng {\n     /// ```rust\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n-    /// let mut rng: StdRng = SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    /// let seed: &[_] = &[1, 2, 3, 4];\n+    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n     /// println!(\"{}\", rng.gen::<f64>());\n     /// rng.reseed([5, 6, 7, 8]);\n     /// println!(\"{}\", rng.gen::<f64>());\n@@ -323,7 +324,8 @@ pub trait SeedableRng<Seed>: Rng {\n     /// ```rust\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n-    /// let mut rng: StdRng = SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    /// let seed: &[_] = &[1, 2, 3, 4];\n+    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n     /// println!(\"{}\", rng.gen::<f64>());\n     /// ```\n     fn from_seed(seed: Seed) -> Self;"}, {"sha": "1d2fcc8b77b15f7a02a2fd8b90a9b7d27bca2ef9", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -183,16 +183,17 @@ mod tests {\n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0u, 256) {\n+            let ii: &[u8] = &[i as u8];\n             assert_eq!(format!(\"{:02x}\", i as uint).as_slice()\n                                                    .from_hex()\n                                                    .unwrap()\n                                                    .as_slice(),\n-                       &[i as u8]);\n+                       ii);\n             assert_eq!(format!(\"{:02X}\", i as uint).as_slice()\n                                                    .from_hex()\n                                                    .unwrap()\n                                                    .as_slice(),\n-                       &[i as u8]);\n+                       ii);\n         }\n     }\n "}, {"sha": "f7b23163dfe482130947df206e9895b8cd1097b6", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -609,11 +609,12 @@ mod tests {\n     #[test]\n     fn test_ascii_vec() {\n         let test = &[40u8, 32u8, 59u8];\n-        assert_eq!(test.to_ascii(), v2ascii!([40, 32, 59]));\n-        assert_eq!(\"( ;\".to_ascii(), v2ascii!([40, 32, 59]));\n+        let b: &[_] = v2ascii!([40, 32, 59]);\n+        assert_eq!(test.to_ascii(), b);\n+        assert_eq!(\"( ;\".to_ascii(), b);\n         let v = vec![40u8, 32u8, 59u8];\n-        assert_eq!(v.as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n-        assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n+        assert_eq!(v.as_slice().to_ascii(), b);\n+        assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), b);\n \n         assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_string(), \"abcdef&?#\".to_string());\n         assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_string(), \"ABCDEF&?#\".to_string());\n@@ -688,13 +689,12 @@ mod tests {\n         assert_eq!((test1).to_ascii_opt(), None);\n \n         let v = [40u8, 32u8, 59u8];\n-        let v2 = v2ascii!(&[40, 32, 59]);\n+        let v2: &[_] = v2ascii!(&[40, 32, 59]);\n         assert_eq!(v.to_ascii_opt(), Some(v2));\n         let v = [127u8, 128u8, 255u8];\n         assert_eq!(v.to_ascii_opt(), None);\n \n         let v = \"( ;\";\n-        let v2 = v2ascii!(&[40, 32, 59]);\n         assert_eq!(v.to_ascii_opt(), Some(v2));\n         assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n "}, {"sha": "1d638e498d44928b7d2c18059ba9adb590f12db9", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -415,21 +415,25 @@ mod test {\n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(2), nread);\n-        assert_eq!(buf.as_slice(), &[0, 1, 0]);\n+        let b: &[_] = &[0, 1, 0];\n+        assert_eq!(buf.as_slice(), b);\n \n         let mut buf = [0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!(buf.as_slice(), &[2]);\n+        let b: &[_] = &[2];\n+        assert_eq!(buf.as_slice(), b);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!(buf.as_slice(), &[3, 0, 0]);\n+        let b: &[_] = &[3, 0, 0];\n+        assert_eq!(buf.as_slice(), b);\n \n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!(buf.as_slice(), &[4, 0, 0]);\n+        let b: &[_] = &[4, 0, 0];\n+        assert_eq!(buf.as_slice(), b);\n \n         assert!(reader.read(buf).is_err());\n     }\n@@ -440,45 +444,53 @@ mod test {\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n         writer.write([0, 1]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[]);\n+        let b: &[_] = &[];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n \n         writer.write([2]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n \n         writer.write([3]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n+        assert_eq!(writer.get_ref().get_ref(), b);\n \n         writer.flush().unwrap();\n-        assert_eq!(&[0, 1, 2, 3], writer.get_ref().get_ref());\n+        let a: &[_] = &[0, 1, 2, 3];\n+        assert_eq!(a, writer.get_ref().get_ref());\n \n         writer.write([4]).unwrap();\n         writer.write([5]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3], writer.get_ref().get_ref());\n+        assert_eq!(a, writer.get_ref().get_ref());\n \n         writer.write([6]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5],\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5];\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n         writer.write([7, 8]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5, 6],\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n         writer.write([9, 10, 11]).unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n         writer.flush().unwrap();\n-        assert_eq!(&[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+        assert_eq!(a,\n                    writer.get_ref().get_ref());\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n         w.write([0, 1]).unwrap();\n-        assert_eq!(&[], w.get_ref().get_ref());\n+        let a: &[_] = &[];\n+        assert_eq!(a, w.get_ref().get_ref());\n         let w = w.unwrap();\n-        assert_eq!(&[0, 1], w.get_ref());\n+        let a: &[_] = &[0, 1];\n+        assert_eq!(a, w.get_ref());\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -519,20 +531,22 @@ mod test {\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(MemWriter::new());\n         writer.write([0]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[]);\n+        let b: &[_] = &[];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.write([1]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[]);\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.flush().unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.write([0, b'\\n', 1, b'\\n', 2]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, b'\\n', 1, b'\\n']);\n+        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.flush().unwrap();\n-        assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, b'\\n', 1, b'\\n', 2]);\n+        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n         writer.write([3, b'\\n']).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(),\n-            &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n+        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n+        assert_eq!(writer.get_ref().get_ref(), b);\n     }\n \n     #[test]"}, {"sha": "1c8b047f56f4db71fbf6a820e20f8121012d157c", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -154,26 +154,29 @@ mod test {\n         assert_eq!(Ok(0), reader.read([]));\n \n         assert_eq!(Ok(3), reader.read(buf));\n-        assert_eq!(&[1,2,3], buf.as_slice());\n+        let a: &[u8] = &[1,2,3];\n+        assert_eq!(a, buf.as_slice());\n \n         assert_eq!(Ok(3), reader.read(buf));\n-        assert_eq!(&[4,5,6], buf.as_slice());\n+        let a: &[u8] = &[4,5,6];\n+        assert_eq!(a, buf.as_slice());\n \n         assert_eq!(Ok(2), reader.read(buf));\n-        assert_eq!(&[7,8,6], buf.as_slice());\n+        let a: &[u8] = &[7,8,6];\n+        assert_eq!(a, buf.as_slice());\n \n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(&[7,8,6], buf.as_slice());\n+        assert_eq!(a, buf.as_slice());\n \n         // Ensure it continues to fail in the same way.\n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(&[7,8,6], buf.as_slice());\n+        assert_eq!(a, buf.as_slice());\n     }\n \n     #[test]"}, {"sha": "21ab9c1fdd431fcf5d568798789ffe586b4ffdaf", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -346,7 +346,8 @@ mod test {\n         writer.write([0]).unwrap();\n         writer.write([1, 2, 3]).unwrap();\n         writer.write([4, 5, 6, 7]).unwrap();\n-        assert_eq!(writer.get_ref(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n     }\n \n     #[test]\n@@ -363,7 +364,8 @@ mod test {\n             writer.write([]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n         }\n-        assert_eq!(buf.as_slice(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     #[test]\n@@ -391,7 +393,8 @@ mod test {\n             assert_eq!(writer.tell(), Ok(8));\n \n         }\n-        assert_eq!(buf.as_slice(), &[1, 3, 2, 0, 0, 0, 0, 4]);\n+        let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     #[test]\n@@ -415,13 +418,16 @@ mod test {\n         let mut buf = [0];\n         assert_eq!(reader.read(buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n-        assert_eq!(buf.as_slice(), &[0]);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf.as_slice(), b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n-        assert_eq!(buf.as_slice(), &[1, 2, 3, 4]);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n-        assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -439,13 +445,16 @@ mod test {\n         let mut buf = [0];\n         assert_eq!(reader.read(buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n-        assert_eq!(buf.as_slice(), &[0]);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf.as_slice(), b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n-        assert_eq!(buf.as_slice(), &[1, 2, 3, 4]);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n-        assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -537,13 +546,16 @@ mod test {\n         let mut r = MemReader::new(vec![1, 2, 3, 4, 5, 6, 7, 8]);\n         let mut buf = [0, ..3];\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n-        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        let b: &[_] = &[1, 2, 3];\n+        assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(0, buf.mut_slice_to(0)).is_ok());\n-        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n-        assert_eq!(buf.as_slice(), &[4, 5, 6]);\n+        let b: &[_] = &[4, 5, 6];\n+        assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_err());\n-        assert_eq!(buf.as_slice(), &[7, 8, 6]);\n+        let b: &[_] = &[7, 8, 6];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {"}, {"sha": "03637079241d6cb542d4626f02ee821dd8ca76a7", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -111,7 +111,8 @@ mod test {\n             Ok(MemReader::new(vec!(0, 1, 2, 3)));\n         let mut buf = [0, 0];\n         reader.read(buf).unwrap();\n-        assert_eq!(buf.as_slice(), &[0, 1]);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(buf.as_slice(), b);\n     }\n \n     #[test]"}, {"sha": "f452f8b23e7bac5fa37c4abbb5fd9a08a1a73658", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -295,7 +295,8 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             for p in input.iter() {\n                 let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n                 let key = Vec::from_slice(it.next().unwrap());\n-                let val = Vec::from_slice(it.next().unwrap_or(&[]));\n+                let default: &[u8] = &[];\n+                let val = Vec::from_slice(it.next().unwrap_or(default));\n                 pairs.push((key, val));\n             }\n             pairs"}, {"sha": "50441cb534de12d0c1da3a1b9156e1fdf572107f", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -846,7 +846,10 @@ impl<'a, P: GenericPath> Display<'a, P> {\n     pub fn as_maybe_owned(&self) -> MaybeOwned<'a> {\n         String::from_utf8_lossy(if self.filename {\n             match self.path.filename() {\n-                None => &[],\n+                None => {\n+                    let result: &[u8] = &[];\n+                    result\n+                }\n                 Some(v) => v\n             }\n         } else {"}, {"sha": "b9b7a02b62f1ba09f9c63a08c6ff49e39b14c4c7", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -531,15 +531,17 @@ mod test {\n         r.shuffle(empty);\n         let mut one = [1i];\n         r.shuffle(one);\n-        assert_eq!(one.as_slice(), &[1]);\n+        let b: &[_] = &[1];\n+        assert_eq!(one.as_slice(), b);\n \n         let mut two = [1i, 2];\n         r.shuffle(two);\n         assert!(two == [1, 2] || two == [2, 1]);\n \n         let mut x = [1i, 1, 1];\n         r.shuffle(x);\n-        assert_eq!(x.as_slice(), &[1, 1, 1]);\n+        let b: &[_] = &[1, 1, 1];\n+        assert_eq!(x.as_slice(), b);\n     }\n \n     #[test]\n@@ -548,7 +550,8 @@ mod test {\n         r.gen::<int>();\n         let mut v = [1i, 1, 1];\n         r.shuffle(v);\n-        assert_eq!(v.as_slice(), &[1, 1, 1]);\n+        let b: &[_] = &[1, 1, 1];\n+        assert_eq!(v.as_slice(), b);\n         assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n "}, {"sha": "f68ace395aaa5f97483ebec2c33fa1243bd7ccfd", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -100,7 +100,8 @@ fn main() {\n     let mut rand = Vec::with_capacity(n_keys);\n \n     {\n-        let mut rng: IsaacRng = SeedableRng::from_seed(&[1, 1, 1, 1, 1, 1, 1]);\n+        let seed: &[_] = &[1, 1, 1, 1, 1, 1, 1];\n+        let mut rng: IsaacRng = SeedableRng::from_seed(seed);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.gen();"}, {"sha": "7f85bc1d700aff3ef683b073563a9b98bb168c0a", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -164,7 +164,7 @@ fn main() {\n         }\n     };\n \n-    let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let max = 200000;\n \n     {"}, {"sha": "058dc426766bce81c451211b61554fdb230b4833", "filename": "src/test/run-pass/byte-literals.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -37,13 +37,16 @@ pub fn main() {\n         _ => fail!()\n     }\n \n-    assert_eq!(b\"a\\n\\r\\t\\\\\\'\\\"\\0\\xF0\",\n-               &[97u8, 10u8, 13u8, 9u8, 92u8, 39u8, 34u8, 0u8, 240u8]);\n+    let expected: &[_] = &[97u8, 10u8, 13u8, 9u8, 92u8, 39u8, 34u8, 0u8, 240u8];\n+    assert_eq!(b\"a\\n\\r\\t\\\\\\'\\\"\\0\\xF0\", expected);\n+    let expected: &[_] = &[97u8, 98u8];\n     assert_eq!(b\"a\\\n-                 b\", &[97u8, 98u8]);\n-    assert_eq!(BAR, &[97u8, 240u8, 9u8]);\n+                 b\", expected);\n+    let expected: &[_] = &[97u8, 240u8, 9u8];\n+    assert_eq!(BAR, expected);\n \n-    match &[97u8, 10u8] {\n+    let val: &[_] = &[97u8, 10u8];\n+    match val {\n         b\"a\\n\" => {},\n         _ => fail!(),\n     }\n@@ -55,9 +58,12 @@ pub fn main() {\n          _ => 3u\n     }, 2);\n \n-    assert_eq!(BAZ, &[97u8, 92u8, 110u8]);\n-    assert_eq!(br\"a\\n\", &[97u8, 92u8, 110u8]);\n+    let expected: &[_] = &[97u8, 92u8, 110u8];\n+    assert_eq!(BAZ, expected);\n+    let expected: &[_] = &[97u8, 92u8, 110u8];\n+    assert_eq!(br\"a\\n\", expected);\n     assert_eq!(br\"a\\n\", b\"a\\\\n\");\n-    assert_eq!(br###\"a\"##b\"###, &[97u8, 34u8, 35u8, 35u8, 98u8]);\n+    let expected: &[_] = &[97u8, 34u8, 35u8, 35u8, 98u8];\n+    assert_eq!(br###\"a\"##b\"###, expected);\n     assert_eq!(br###\"a\"##b\"###, b\"a\\\"##b\");\n }"}, {"sha": "3f559df4b7e7a7098b9624705c565487fd75027c", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -43,14 +43,22 @@ fn main() {\n     let args = os::args();\n     let me = args.get(0).as_slice();\n \n-    pass(Command::new(me).arg(&[1u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[2u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[3u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[4u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[5u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[6u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[7u8]).output().unwrap());\n-    pass(Command::new(me).arg(&[8u8]).output().unwrap());\n+    let x: &[u8] = &[1u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[2u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[3u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[4u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[5u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[6u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[7u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n+    let x: &[u8] = &[8u8];\n+    pass(Command::new(me).arg(x).output().unwrap());\n }\n \n fn pass(output: ProcessOutput) {"}, {"sha": "8d5333e5b3fc5aa4d79af138a7412940f19ee115", "filename": "src/test/run-pass/syntax-extension-bytes.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -12,13 +12,17 @@ static static_vec: &'static [u8] = bytes!(\"abc\", 0xFF, '!');\n \n pub fn main() {\n     let vec = bytes!(\"abc\");\n-    assert_eq!(vec, &[97_u8, 98_u8, 99_u8]);\n+    let expected: &[u8] = &[97_u8, 98_u8, 99_u8];\n+    assert_eq!(vec, expected);\n \n     let vec = bytes!(\"null\", 0);\n-    assert_eq!(vec, &[110_u8, 117_u8, 108_u8, 108_u8, 0_u8]);\n+    let expected: &[u8] = &[110_u8, 117_u8, 108_u8, 108_u8, 0_u8];\n+    assert_eq!(vec, expected);\n \n     let vec = bytes!(' ', \" \", 32, 32u8);\n-    assert_eq!(vec, &[32_u8, 32_u8, 32_u8, 32_u8]);\n+    let expected: &[u8] = &[32_u8, 32_u8, 32_u8, 32_u8];\n+    assert_eq!(vec, expected);\n \n-    assert_eq!(static_vec, &[97_u8, 98_u8, 99_u8, 255_u8, 33_u8]);\n+    let expected: &[u8] = &[97_u8, 98_u8, 99_u8, 255_u8, 33_u8];\n+    assert_eq!(static_vec, expected);\n }"}, {"sha": "10c91274f10f81387d45299c82f5f45a41967a8a", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -15,10 +15,11 @@ static CONSTEXPR: *const int = &413 as *const _;\n \n pub fn main() {\n     let x: Vec<_> = range(0u, 5).collect();\n-    assert_eq!(x.as_slice(), &[0u,1,2,3,4]);\n+    let expected: &[uint] = &[0,1,2,3,4];\n+    assert_eq!(x.as_slice(), expected);\n \n     let x = range(0u, 5).collect::<Vec<_>>();\n-    assert_eq!(x.as_slice(), &[0u,1,2,3,4]);\n+    assert_eq!(x.as_slice(), expected);\n \n     let y: _ = \"hello\";\n     assert_eq!(y.len(), 5);"}, {"sha": "2fd8a4ab256fd8fb1dee7ed20966c5fc2b280b4f", "filename": "src/test/run-pass/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -10,6 +10,7 @@\n \n pub fn main() {\n     let x = &[1i, 2, 3, 4, 5];\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n     if !x.is_empty() {\n         let el = match x {\n             [1, ..ref tail] => &tail[0],"}, {"sha": "76f3b7bc280772994ae3895a57ce426f6099d3ae", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -23,20 +23,23 @@ fn b() {\n         [a, b, ..c] => {\n             assert_eq!(a, 1);\n             assert_eq!(b, 2);\n-            assert_eq!(c, &[3]);\n+            let expected: &[_] = &[3];\n+            assert_eq!(c, expected);\n         }\n     }\n     match x {\n         [..a, b, c] => {\n-            assert_eq!(a, &[1]);\n+            let expected: &[_] = &[1];\n+            assert_eq!(a, expected);\n             assert_eq!(b, 2);\n             assert_eq!(c, 3);\n         }\n     }\n     match x {\n         [a, ..b, c] => {\n             assert_eq!(a, 1);\n-            assert_eq!(b, &[2]);\n+            let expected: &[_] = &[2];\n+            assert_eq!(b, expected);\n             assert_eq!(c, 3);\n         }\n     }"}, {"sha": "b96761f8b64933ed04952ea48c6745f57edeee6a", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a94b80f207e86017e54056ced2dc9674907ae3/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=37a94b80f207e86017e54056ced2dc9674907ae3", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!((vec!(0i, 1)).to_string(), \"[0, 1]\".to_string());\n-    assert_eq!((&[1i, 2]).to_string(), \"[1, 2]\".to_string());\n+    assert_eq!((vec!(0, 1)).to_string(), \"[0, 1]\".to_string());\n \n-    let foo = vec!(3i, 4);\n-    let bar = &[4i, 5];\n+    let foo = vec!(3, 4);\n+    let bar: &[int] = &[4, 5];\n \n     assert_eq!(foo.to_string(), \"[3, 4]\".to_string());\n     assert_eq!(bar.to_string(), \"[4, 5]\".to_string());"}]}