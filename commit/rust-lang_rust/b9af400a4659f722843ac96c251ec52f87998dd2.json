{"sha": "b9af400a4659f722843ac96c251ec52f87998dd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YWY0MDBhNDY1OWY3MjI4NDNhYzk2YzI1MWVjNTJmODc5OThkZDI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-05T10:27:51Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-16T11:11:01Z"}, "message": "rustc_mir: generate an extra temporary during borrowed rvalue promotion.", "tree": {"sha": "50b80590c83a2fba0827778d59b32c53360bde63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50b80590c83a2fba0827778d59b32c53360bde63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9af400a4659f722843ac96c251ec52f87998dd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9af400a4659f722843ac96c251ec52f87998dd2", "html_url": "https://github.com/rust-lang/rust/commit/b9af400a4659f722843ac96c251ec52f87998dd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9af400a4659f722843ac96c251ec52f87998dd2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ec2058bfee1e6c57d4c84d873737f84d4636bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec2058bfee1e6c57d4c84d873737f84d4636bea", "html_url": "https://github.com/rust-lang/rust/commit/3ec2058bfee1e6c57d4c84d873737f84d4636bea"}], "stats": {"total": 158, "additions": 98, "deletions": 60}, "files": [{"sha": "fb7eb60545c976c82bedf4c69d29e5b34ea774c9", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 92, "deletions": 58, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b9af400a4659f722843ac96c251ec52f87998dd2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9af400a4659f722843ac96c251ec52f87998dd2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b9af400a4659f722843ac96c251ec52f87998dd2", "patch": "@@ -25,14 +25,12 @@\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n-use std::iter;\n-use std::mem;\n-use std::usize;\n+use std::{cmp, iter, mem, usize};\n \n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -150,9 +148,11 @@ pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Local, T\n }\n \n struct Promoter<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: &'a mut Mir<'tcx>,\n     promoted: Mir<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n+    extra_statements: &'a mut Vec<(Location, Statement<'tcx>)>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n@@ -288,38 +288,78 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate) {\n-        let span = self.promoted.span;\n-        let new_operand = Operand::Constant(box Constant {\n-            span,\n-            ty: self.promoted.return_ty(),\n-            literal: Literal::Promoted {\n+        let mut rvalue = {\n+            let promoted = &mut self.promoted;\n+            let literal = Literal::Promoted {\n                 index: Promoted::new(self.source.promoted.len())\n-            }\n-        });\n-        let mut rvalue = match candidate {\n-            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                let ref mut statement = self.source[bb].statements[stmt_idx];\n-                match statement.kind {\n-                    StatementKind::Assign(_, ref mut rvalue) => {\n-                        mem::replace(rvalue, Rvalue::Use(new_operand))\n+            };\n+            let operand = |ty, span| {\n+                promoted.span = span;\n+                promoted.local_decls[RETURN_PLACE] =\n+                    LocalDecl::new_return_place(ty, span);\n+                Operand::Constant(box Constant {\n+                    span,\n+                    ty,\n+                    literal\n+                })\n+            };\n+            let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n+            match candidate {\n+                Candidate::Ref(loc) => {\n+                    let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n+                    match statement.kind {\n+                        StatementKind::Assign(_, Rvalue::Ref(r, bk, ref mut place)) => {\n+                            let ty = place.ty(local_decls, self.tcx).to_ty(self.tcx);\n+                            let ref_ty = self.tcx.mk_ref(r,\n+                                ty::TypeAndMut {\n+                                    ty,\n+                                    mutbl: bk.to_mutbl_lossy()\n+                                }\n+                            );\n+                            let span = statement.source_info.span;\n+\n+                            // Create a temp to hold the promoted reference.\n+                            // This is because `*r` requires `r` to be a local,\n+                            // otherwise we would use the `promoted` directly.\n+                            let mut promoted_ref = LocalDecl::new_temp(ref_ty, span);\n+                            promoted_ref.source_info = statement.source_info;\n+                            let promoted_ref = local_decls.push(promoted_ref);\n+                            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+                            self.extra_statements.push((loc, Statement {\n+                                source_info: statement.source_info,\n+                                kind: StatementKind::Assign(\n+                                    Place::Local(promoted_ref),\n+                                    Rvalue::Use(operand(ref_ty, span)),\n+                                )\n+                            }));\n+                            let promoted_place = Place::Local(promoted_ref).deref();\n+\n+                            Rvalue::Ref(r, bk, mem::replace(place, promoted_place))\n+                        }\n+                        _ => bug!()\n                     }\n-                    _ => bug!()\n                 }\n-            }\n-            Candidate::Argument { bb, index } => {\n-                match self.source[bb].terminator_mut().kind {\n-                    TerminatorKind::Call { ref mut args, .. } => {\n-                        Rvalue::Use(mem::replace(&mut args[index], new_operand))\n+                Candidate::Argument { bb, index } => {\n+                    let terminator = blocks[bb].terminator_mut();\n+                    match terminator.kind {\n+                        TerminatorKind::Call { ref mut args, .. } => {\n+                            let ty = args[index].ty(local_decls, self.tcx);\n+                            let span = terminator.source_info.span;\n+                            Rvalue::Use(mem::replace(&mut args[index], operand(ty, span)))\n+                        }\n+                        _ => bug!()\n                     }\n-                    _ => bug!()\n                 }\n             }\n         };\n+\n+        assert_eq!(self.new_block(), START_BLOCK);\n         self.visit_rvalue(&mut rvalue, Location {\n             block: BasicBlock::new(0),\n             statement_index: usize::MAX\n         });\n \n+        let span = self.promoted.span;\n         self.assign(RETURN_PLACE, rvalue, span);\n         self.source.promoted.push(self.promoted);\n     }\n@@ -343,43 +383,29 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n+\n+    let mut extra_statements = vec![];\n     for candidate in candidates.into_iter().rev() {\n-        let (span, ty) = match candidate {\n-            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                let statement = &mir[bb].statements[stmt_idx];\n-                let dest = match statement.kind {\n-                    StatementKind::Assign(ref dest, _) => dest,\n-                    _ => {\n-                        span_bug!(statement.source_info.span,\n-                                  \"expected assignment to promote\");\n-                    }\n-                };\n-                if let Place::Local(index) = *dest {\n-                    if temps[index] == TempState::PromotedOut {\n-                        // Already promoted.\n-                        continue;\n+        match candidate {\n+            Candidate::Ref(Location { block, statement_index }) => {\n+                match mir[block].statements[statement_index].kind {\n+                    StatementKind::Assign(Place::Local(local), _) => {\n+                        if temps[local] == TempState::PromotedOut {\n+                            // Already promoted.\n+                            continue;\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                (statement.source_info.span, dest.ty(mir, tcx).to_ty(tcx))\n-            }\n-            Candidate::Argument { bb, index } => {\n-                let terminator = mir[bb].terminator();\n-                let ty = match terminator.kind {\n-                    TerminatorKind::Call { ref args, .. } => {\n-                        args[index].ty(mir, tcx)\n-                    }\n-                    _ => {\n-                        span_bug!(terminator.source_info.span,\n-                                  \"expected call argument to promote\");\n-                    }\n-                };\n-                (terminator.source_info.span, ty)\n             }\n-        };\n+            Candidate::Argument { .. } => {}\n+        }\n+\n \n-        // Declare return place local\n-        let initial_locals = iter::once(LocalDecl::new_return_place(ty, span))\n-            .collect();\n+        // Declare return place local so that `Mir::new` doesn't complain.\n+        let initial_locals = iter::once(\n+            LocalDecl::new_return_place(tcx.types.never, mir.span)\n+        ).collect();\n \n         let mut promoter = Promoter {\n             promoted: Mir::new(\n@@ -393,16 +419,24 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 initial_locals,\n                 0,\n                 vec![],\n-                span\n+                mir.span\n             ),\n+            tcx,\n             source: mir,\n             temps: &mut temps,\n+            extra_statements: &mut extra_statements,\n             keep_original: false\n         };\n-        assert_eq!(promoter.new_block(), START_BLOCK);\n         promoter.promote_candidate(candidate);\n     }\n \n+    // Insert each of `extra_statements` before its indicated location, which\n+    // has to be done in reverse location order, to not invalidate the rest.\n+    extra_statements.sort_by_key(|&(loc, _)| cmp::Reverse(loc));\n+    for (loc, statement) in extra_statements {\n+        mir[loc.block].statements.insert(loc.statement_index, statement);\n+    }\n+\n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in mir.basic_blocks_mut() {"}, {"sha": "15b104f6c2ff74b9206f5c38872395a3a0883b70", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9af400a4659f722843ac96c251ec52f87998dd2/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9af400a4659f722843ac96c251ec52f87998dd2/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=b9af400a4659f722843ac96c251ec52f87998dd2", "patch": "@@ -130,17 +130,21 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //     let mut _7: &'10s S1;\n //     let mut _8: &'10s S1;\n //     let mut _9: S1;\n+//     let mut _10: &'10s S1;\n+//     let mut _11: &'12ds S1;\n //\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         _5 = promoted[1];\n+//         _11 = promoted[1];\n+//         _5 = &'12ds (*_11);\n //         _4 = &'12ds (*_5);\n //         StorageLive(_7);\n //         StorageLive(_8);\n-//         _8 = promoted[0];\n+//         _10 = promoted[0];\n+//         _8 = &'10s (*_10);\n //         _7 = &'10s (*_8);\n //         _3 = D1<'12ds, '10s>::{{constructor}}(move _4, move _7);\n //         EndRegion('10s);"}]}