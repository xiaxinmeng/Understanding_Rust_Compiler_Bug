{"sha": "55f4b802fb91ee366ebca8a333dc01f04e0d71e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZjRiODAyZmI5MWVlMzY2ZWJjYThhMzMzZGMwMWYwNGUwZDcxZTU=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-05T09:29:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-05T09:29:35Z"}, "message": "Rollup merge of #76718 - poliorcetics:vec-ui-to-unit-test, r=jyn514\n\nMove Vec UI tests to unit tests when possible\n\nHelps with #76268.\n\nI'm moving the tests using `Vec` or `VecDeque`.\n\n````@rustbot```` modify labels: A-testsuite C-cleanup T-libs", "tree": {"sha": "32474b1ad6c09f641d29536d546069688e397ec8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32474b1ad6c09f641d29536d546069688e397ec8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55f4b802fb91ee366ebca8a333dc01f04e0d71e5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfo8YACRBK7hj4Ov3rIwAAdHIIAESCwx+b6/EgGRDuyhhcujeR\ns7Nb/eCUtP2kiq5Ophr7TvcEkNLizXNcfPGLscipnVVl8yKRYVromQ798OZmADUi\nCBfiwLgNh26v/KIUPOeejzb28bvVb1NvqU9rSD2JrgceVRrBXH4HhXlzU8Ekl5S5\nIlqpjV/Jyv5IKPZKyWxZk3nVVMZRD1+1RU1iMSfQa8CiDA6PbyHL/WfqXyLoCwDn\nykHtxfMHxb5BClWVTW52lm5U/4VLudhtbL5sGXu+uuyTOOYBl8Hs99lBkys65ElL\n0QQ0ygBjKDsHYT0+x4PQg96hZhy+S3AERSzbhjgCdv6E12CMr916i7r61Li0YH4=\n=XXSO\n-----END PGP SIGNATURE-----\n", "payload": "tree 32474b1ad6c09f641d29536d546069688e397ec8\nparent 8c2070121905b66698ebbfb105eab30f3484e602\nparent 1bdee96c5e6de445f09df34447a42553294f21ed\nauthor Mara Bos <m-ou.se@m-ou.se> 1604568575 +0100\ncommitter GitHub <noreply@github.com> 1604568575 +0100\n\nRollup merge of #76718 - poliorcetics:vec-ui-to-unit-test, r=jyn514\n\nMove Vec UI tests to unit tests when possible\n\nHelps with #76268.\n\nI'm moving the tests using `Vec` or `VecDeque`.\n\n````@rustbot```` modify labels: A-testsuite C-cleanup T-libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55f4b802fb91ee366ebca8a333dc01f04e0d71e5", "html_url": "https://github.com/rust-lang/rust/commit/55f4b802fb91ee366ebca8a333dc01f04e0d71e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55f4b802fb91ee366ebca8a333dc01f04e0d71e5/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c2070121905b66698ebbfb105eab30f3484e602", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2070121905b66698ebbfb105eab30f3484e602", "html_url": "https://github.com/rust-lang/rust/commit/8c2070121905b66698ebbfb105eab30f3484e602"}, {"sha": "1bdee96c5e6de445f09df34447a42553294f21ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bdee96c5e6de445f09df34447a42553294f21ed", "html_url": "https://github.com/rust-lang/rust/commit/1bdee96c5e6de445f09df34447a42553294f21ed"}], "stats": {"total": 401, "additions": 193, "deletions": 208}, "files": [{"sha": "a4f0fb415fb3cc79b8045c98471371fd28c2e6da", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/55f4b802fb91ee366ebca8a333dc01f04e0d71e5/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f4b802fb91ee366ebca8a333dc01f04e0d71e5/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=55f4b802fb91ee366ebca8a333dc01f04e0d71e5", "patch": "@@ -1,5 +1,6 @@\n use std::cell::Cell;\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n+use std::convert::identity;\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n@@ -1778,3 +1779,122 @@ fn repeat_generic_slice() {\n     assert_eq!([1, 2, 3, 4].repeat(1), vec![1, 2, 3, 4]);\n     assert_eq!([1, 2, 3, 4].repeat(3), vec![1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n }\n+\n+#[test]\n+#[allow(unreachable_patterns)]\n+fn subslice_patterns() {\n+    // This test comprehensively checks the passing static and dynamic semantics\n+    // of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n+    // in slice patterns `[$($pat), $(,)?]` .\n+\n+    #[derive(PartialEq, Debug, Clone)]\n+    struct N(u8);\n+\n+    macro_rules! n {\n+        ($($e:expr),* $(,)?) => {\n+            [$(N($e)),*]\n+        }\n+    }\n+\n+    macro_rules! c {\n+        ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n+            assert_eq!($out, identity::<$typ>($inp));\n+        };\n+    }\n+\n+    macro_rules! m {\n+        ($e:expr, $p:pat => $b:expr) => {\n+            match $e {\n+                $p => $b,\n+                _ => panic!(),\n+            }\n+        };\n+    }\n+\n+    // == Slices ==\n+\n+    // Matching slices using `ref` patterns:\n+    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n+    let mut vc = (0..=4).collect::<Vec<u8>>();\n+\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using `ref mut` patterns:\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using default binding modes (&):\n+    let [..] = &v[..]; // Always matches.\n+    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n+\n+    // Matching slices using default binding modes (&mut):\n+    let [..] = &mut v[..]; // Always matches.\n+    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n+\n+    // == Arrays ==\n+    let mut v = n![0, 1, 2, 3, 4];\n+    let vc = [0, 1, 2, 3, 4];\n+\n+    // Matching arrays by value:\n+    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n+    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n+    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n+    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n+    m!(v.clone(), [..] => ());\n+\n+    // Matching arrays by ref patterns:\n+    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching arrays by ref mut patterns:\n+    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+\n+    // Matching arrays by default binding modes (&):\n+    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [..] => ());\n+    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n+\n+    // Matching arrays by default binding modes (&mut):\n+    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [..] => ());\n+    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n+}"}, {"sha": "47ebe56f9fd3bcfc379e7a2dd7e2c87877905341", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/55f4b802fb91ee366ebca8a333dc01f04e0d71e5/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f4b802fb91ee366ebca8a333dc01f04e0d71e5/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=55f4b802fb91ee366ebca8a333dc01f04e0d71e5", "patch": "@@ -3,7 +3,7 @@ use std::cell::Cell;\n use std::collections::TryReserveError::*;\n use std::fmt::Debug;\n use std::iter::InPlaceIterable;\n-use std::mem::size_of;\n+use std::mem::{size_of, swap};\n use std::ops::Bound::*;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n@@ -1912,3 +1912,45 @@ fn test_vec_cycle_wrapped() {\n     c3.refs.v[0].set(Some(&c1));\n     c3.refs.v[1].set(Some(&c2));\n }\n+\n+#[test]\n+fn test_zero_sized_vec_push() {\n+    const N: usize = 8;\n+\n+    for len in 0..N {\n+        let mut tester = Vec::with_capacity(len);\n+        assert_eq!(tester.len(), 0);\n+        assert!(tester.capacity() >= len);\n+        for _ in 0..len {\n+            tester.push(());\n+        }\n+        assert_eq!(tester.len(), len);\n+        assert_eq!(tester.iter().count(), len);\n+        tester.clear();\n+    }\n+}\n+\n+#[test]\n+fn test_vec_macro_repeat() {\n+    assert_eq!(vec![1; 3], vec![1, 1, 1]);\n+    assert_eq!(vec![1; 2], vec![1, 1]);\n+    assert_eq!(vec![1; 1], vec![1]);\n+    assert_eq!(vec![1; 0], vec![]);\n+\n+    // from_elem syntax (see RFC 832)\n+    let el = Box::new(1);\n+    let n = 3;\n+    assert_eq!(vec![el; n], vec![Box::new(1), Box::new(1), Box::new(1)]);\n+}\n+\n+#[test]\n+fn test_vec_swap() {\n+    let mut a: Vec<isize> = vec![0, 1, 2, 3, 4, 5, 6];\n+    a.swap(2, 4);\n+    assert_eq!(a[2], 4);\n+    assert_eq!(a[4], 2);\n+    let mut n = 42;\n+    swap(&mut n, &mut a[0]);\n+    assert_eq!(a[0], 42);\n+    assert_eq!(n, 0);\n+}"}, {"sha": "705f0d62fbb7a8643f497a21c832d4aaf87883f3", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55f4b802fb91ee366ebca8a333dc01f04e0d71e5/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f4b802fb91ee366ebca8a333dc01f04e0d71e5/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=55f4b802fb91ee366ebca8a333dc01f04e0d71e5", "patch": "@@ -1698,3 +1698,33 @@ fn test_binary_search_by_key() {\n     assert_eq!(deque.binary_search_by_key(&3, |&(v,)| v), Ok(2));\n     assert_eq!(deque.binary_search_by_key(&4, |&(v,)| v), Err(3));\n }\n+\n+#[test]\n+fn test_zero_sized_push() {\n+    const N: usize = 8;\n+\n+    // Zero sized type\n+    struct Zst;\n+\n+    // Test that for all possible sequences of push_front / push_back,\n+    // we end up with a deque of the correct size\n+\n+    for len in 0..N {\n+        let mut tester = VecDeque::with_capacity(len);\n+        assert_eq!(tester.len(), 0);\n+        assert!(tester.capacity() >= len);\n+        for case in 0..(1 << len) {\n+            assert_eq!(tester.len(), 0);\n+            for bit in 0..len {\n+                if case & (1 << bit) != 0 {\n+                    tester.push_front(Zst);\n+                } else {\n+                    tester.push_back(Zst);\n+                }\n+            }\n+            assert_eq!(tester.len(), len);\n+            assert_eq!(tester.iter().count(), len);\n+            tester.clear();\n+        }\n+    }\n+}"}, {"sha": "e05790911f52d9b3e0ca2eb9fcb233ba7607edbf", "filename": "src/test/ui/array-slice-vec/subslice-patterns-pass.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,126 +0,0 @@\n-// This test comprehensively checks the passing static and dynamic semantics\n-// of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n-// in slice patterns `[$($pat), $(,)?]` .\n-\n-// run-pass\n-\n-#![allow(unreachable_patterns)]\n-\n-use std::convert::identity;\n-\n-#[derive(PartialEq, Debug, Clone)]\n-struct N(u8);\n-\n-macro_rules! n {\n-    ($($e:expr),* $(,)?) => {\n-        [$(N($e)),*]\n-    }\n-}\n-\n-macro_rules! c {\n-    ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n-        assert_eq!($out, identity::<$typ>($inp));\n-    }\n-}\n-\n-macro_rules! m {\n-    ($e:expr, $p:pat => $b:expr) => {\n-        match $e {\n-            $p => $b,\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-fn main() {\n-    slices();\n-    arrays();\n-}\n-\n-fn slices() {\n-    // Matching slices using `ref` patterns:\n-    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n-    let mut vc = (0..=4).collect::<Vec<u8>>();\n-\n-    let [..] = v[..]; // Always matches.\n-    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n-    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n-    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n-    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n-    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n-    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching slices using `ref mut` patterns:\n-    let [..] = v[..]; // Always matches.\n-    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n-    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n-    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n-    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching slices using default binding modes (&):\n-    let [..] = &v[..]; // Always matches.\n-    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n-    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n-    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n-    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n-    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n-    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n-\n-    // Matching slices using default binding modes (&mut):\n-    let [..] = &mut v[..]; // Always matches.\n-    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n-    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n-    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n-    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n-}\n-\n-fn arrays() {\n-    let mut v = n![0, 1, 2, 3, 4];\n-    let vc = [0, 1, 2, 3, 4];\n-\n-    // Matching arrays by value:\n-    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n-    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n-    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n-    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n-    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n-    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n-    m!(v.clone(), [..] => ());\n-\n-    // Matching arrays by ref patterns:\n-    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n-    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n-    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n-    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching arrays by ref mut patterns:\n-    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n-    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n-    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n-    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n-    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n-\n-    // Matching arrays by default binding modes (&):\n-    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n-    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n-    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n-    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(&v, [..] => ());\n-    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n-\n-    // Matching arrays by default binding modes (&mut):\n-    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n-    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n-    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n-    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n-    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n-    m!(&mut v, [..] => ());\n-    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n-}"}, {"sha": "7be8dadbe170eb2ba5ffe865ea2b7961197f580d", "filename": "src/test/ui/array-slice-vec/vec-macro-repeat.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-macro-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-macro-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-macro-repeat.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,15 +0,0 @@\n-// run-pass\n-\n-\n-\n-pub fn main() {\n-    assert_eq!(vec![1; 3], vec![1, 1, 1]);\n-    assert_eq!(vec![1; 2], vec![1, 1]);\n-    assert_eq!(vec![1; 1], vec![1]);\n-    assert_eq!(vec![1; 0], vec![]);\n-\n-    // from_elem syntax (see RFC 832)\n-    let el = Box::new(1);\n-    let n = 3;\n-    assert_eq!(vec![el; n], vec![Box::new(1), Box::new(1), Box::new(1)]);\n-}"}, {"sha": "c8f298ec0e5cb9d87b8dc7b12d88bcc5b39ca9f2", "filename": "src/test/ui/swap-2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fswap-2.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,14 +0,0 @@\n-// run-pass\n-\n-use std::mem::swap;\n-\n-pub fn main() {\n-    let mut a: Vec<isize> = vec![0, 1, 2, 3, 4, 5, 6];\n-    a.swap(2, 4);\n-    assert_eq!(a[2], 4);\n-    assert_eq!(a[4], 2);\n-    let mut n = 42;\n-    swap(&mut n, &mut a[0]);\n-    assert_eq!(a[0], 42);\n-    assert_eq!(n, 0);\n-}"}, {"sha": "c541208703b6b0cb03cb197eef469f61315f088d", "filename": "src/test/ui/zero-sized/zero-sized-vec-deque-push.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-deque-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-deque-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-deque-push.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,32 +0,0 @@\n-// run-pass\n-use std::collections::VecDeque;\n-use std::iter::Iterator;\n-\n-fn main() {\n-    const N: usize = 8;\n-\n-    // Zero sized type\n-    struct Zst;\n-\n-    // Test that for all possible sequences of push_front / push_back,\n-    // we end up with a deque of the correct size\n-\n-    for len in 0..N {\n-        let mut tester = VecDeque::with_capacity(len);\n-        assert_eq!(tester.len(), 0);\n-        assert!(tester.capacity() >= len);\n-        for case in 0..(1 << len) {\n-            assert_eq!(tester.len(), 0);\n-            for bit in 0..len {\n-                if case & (1 << bit) != 0 {\n-                    tester.push_front(Zst);\n-                } else {\n-                    tester.push_back(Zst);\n-                }\n-            }\n-            assert_eq!(tester.len(), len);\n-            assert_eq!(tester.iter().count(), len);\n-            tester.clear();\n-        }\n-    }\n-}"}, {"sha": "9e9fbc972d5c15d205aac9c7534a79e86eca6e0b", "filename": "src/test/ui/zero-sized/zero-sized-vec-push.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-push.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,20 +0,0 @@\n-// run-pass\n-#![allow(unused_variables)]\n-use std::iter::Iterator;\n-use std::vec::Vec;\n-\n-fn main() {\n-    const N: usize = 8;\n-\n-    for len in 0..N {\n-        let mut tester = Vec::with_capacity(len);\n-        assert_eq!(tester.len(), 0);\n-        assert!(tester.capacity() >= len);\n-        for bit in 0..len {\n-            tester.push(());\n-        }\n-        assert_eq!(tester.len(), len);\n-        assert_eq!(tester.iter().count(), len);\n-        tester.clear();\n-    }\n-}"}]}