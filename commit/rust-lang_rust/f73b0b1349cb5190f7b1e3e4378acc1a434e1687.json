{"sha": "f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "node_id": "C_kwDOAAsO6NoAKGY3M2IwYjEzNDljYjUxOTBmN2IxZTNlNDM3OGFjYzFhNDM0ZTE2ODc", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-01T20:03:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-01T20:03:01Z"}, "message": "Merge pull request #1302 from bjorn3/build_system_rework4\n\nAllow specifying where build artifacts should be written to", "tree": {"sha": "749662ee1faeeb6dbbc8127bb365270461224cc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/749662ee1faeeb6dbbc8127bb365270461224cc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjiQh1CRBK7hj4Ov3rIwAAyAUIAE+huT86hF5aQXYHHOEJQ0wo\nbYuKaWsQjcL2Rt80vANTcfaa6WRAvkG+iXCIQh8ot0SThOD/8LzHzkX6iHUx0dfK\nHiP4dtQfKtp8S9+s4X8UirVp2nyrbgrDljouxS5I5vo7iq0VYmHnIoIV9CsoOoCb\n+j5s7DHUIUGYzHwV4+VRagH3zDNCRcfi98+S6VR/df8oRBkIXpNkB6SgtDlzz8Er\n9/q1d4p79yQqGE4Gtmta57APcZ8caXRsQ8xp9ju+k224FP/bJFnNeWXUTiNhMptE\n+EufTFslj78smCoyq3rMFTHf6MJRrFhIHXaVFv8oCepOVxn8X1q5DFwZMT8snzg=\n=LKgG\n-----END PGP SIGNATURE-----\n", "payload": "tree 749662ee1faeeb6dbbc8127bb365270461224cc9\nparent 450257c4c6109eefb55e96c6995031090971c6b6\nparent b6ac5a3cebcb6b4cc23bf5e883899e075774781f\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1669924981 +0100\ncommitter GitHub <noreply@github.com> 1669924981 +0100\n\nMerge pull request #1302 from bjorn3/build_system_rework4\n\nAllow specifying where build artifacts should be written to"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "html_url": "https://github.com/rust-lang/rust/commit/f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "450257c4c6109eefb55e96c6995031090971c6b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/450257c4c6109eefb55e96c6995031090971c6b6", "html_url": "https://github.com/rust-lang/rust/commit/450257c4c6109eefb55e96c6995031090971c6b6"}, {"sha": "b6ac5a3cebcb6b4cc23bf5e883899e075774781f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ac5a3cebcb6b4cc23bf5e883899e075774781f", "html_url": "https://github.com/rust-lang/rust/commit/b6ac5a3cebcb6b4cc23bf5e883899e075774781f"}], "stats": {"total": 589, "additions": 339, "deletions": 250}, "files": [{"sha": "424ede3614508c7bf79dcc91693ffe59bfc54f9e", "filename": ".github/workflows/main.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmain.yml?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -63,7 +63,7 @@ jobs:\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Install MinGW toolchain and wine\n@@ -164,7 +164,7 @@ jobs:\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Set MinGW as the default toolchain"}, {"sha": "bef806318efa836aeeb8d6df06d880b77be677fb", "filename": ".github/workflows/rustc.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frustc.yml?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -27,7 +27,7 @@ jobs:\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Prepare dependencies\n@@ -65,7 +65,7 @@ jobs:\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Prepare dependencies"}, {"sha": "a081fdaa1c7e6475a727f764c033f07090b2b87e", "filename": "build_system/abi_cafe.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fabi_cafe.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -2,19 +2,20 @@ use std::path::Path;\n \n use super::build_sysroot;\n use super::config;\n+use super::path::Dirs;\n use super::prepare::GitRepo;\n use super::utils::{spawn_and_wait, CargoProject, Compiler};\n use super::SysrootKind;\n \n pub(crate) static ABI_CAFE_REPO: GitRepo =\n     GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n \n-static ABI_CAFE: CargoProject = CargoProject::git(&ABI_CAFE_REPO, \".\");\n+static ABI_CAFE: CargoProject = CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n \n pub(crate) fn run(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    dist_dir: &Path,\n+    dirs: &Dirs,\n     cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n@@ -31,9 +32,9 @@ pub(crate) fn run(\n \n     eprintln!(\"Building sysroot for abi-cafe\");\n     build_sysroot::build_sysroot(\n+        dirs,\n         channel,\n         sysroot_kind,\n-        dist_dir,\n         cg_clif_dylib,\n         host_triple,\n         target_triple,\n@@ -43,13 +44,13 @@ pub(crate) fn run(\n \n     let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n \n-    let mut cmd = ABI_CAFE.run(&Compiler::host());\n+    let mut cmd = ABI_CAFE.run(&Compiler::host(), dirs);\n     cmd.arg(\"--\");\n     cmd.arg(\"--pairs\");\n     cmd.args(pairs);\n     cmd.arg(\"--add-rustc-codegen-backend\");\n     cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib.display()));\n-    cmd.current_dir(ABI_CAFE.source_dir());\n+    cmd.current_dir(ABI_CAFE.source_dir(dirs));\n \n     spawn_and_wait(cmd);\n }"}, {"sha": "fde8ef424ccc5441e0198ef7b33b23c39dbe37bc", "filename": "build_system/build_backend.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_backend.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -1,17 +1,19 @@\n use std::env;\n use std::path::PathBuf;\n \n+use super::path::{Dirs, RelPath};\n use super::rustc_info::get_file_name;\n use super::utils::{is_ci, CargoProject, Compiler};\n \n-static CG_CLIF: CargoProject = CargoProject::local(\".\");\n+static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n \n pub(crate) fn build_backend(\n+    dirs: &Dirs,\n     channel: &str,\n     host_triple: &str,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let mut cmd = CG_CLIF.build(&Compiler::host());\n+    let mut cmd = CG_CLIF.build(&Compiler::host(), dirs);\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -43,8 +45,7 @@ pub(crate) fn build_backend(\n     super::utils::spawn_and_wait(cmd);\n \n     CG_CLIF\n-        .source_dir()\n-        .join(\"target\")\n+        .target_dir(dirs)\n         .join(host_triple)\n         .join(channel)\n         .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"))"}, {"sha": "35c972e6b383a806def6302496998d0c19161609", "filename": "build_system/build_sysroot.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_sysroot.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -1,37 +1,41 @@\n use std::fs;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::process::{self, Command};\n \n+use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n use super::utils::{spawn_and_wait, try_hard_link, CargoProject, Compiler};\n use super::SysrootKind;\n \n+static DIST_DIR: RelPath = RelPath::DIST;\n+static BIN_DIR: RelPath = RelPath::DIST.join(\"bin\");\n+static LIB_DIR: RelPath = RelPath::DIST.join(\"lib\");\n+static RUSTLIB_DIR: RelPath = LIB_DIR.join(\"rustlib\");\n+\n pub(crate) fn build_sysroot(\n+    dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    dist_dir: &Path,\n     cg_clif_dylib_src: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n     eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n \n-    if dist_dir.exists() {\n-        fs::remove_dir_all(dist_dir).unwrap();\n-    }\n-    fs::create_dir_all(dist_dir.join(\"bin\")).unwrap();\n-    fs::create_dir_all(dist_dir.join(\"lib\")).unwrap();\n+    DIST_DIR.ensure_fresh(dirs);\n+    BIN_DIR.ensure_exists(dirs);\n+    LIB_DIR.ensure_exists(dirs);\n \n     // Copy the backend\n-    let cg_clif_dylib_path = dist_dir\n-        .join(if cfg!(windows) {\n-            // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n-            // binaries.\n-            \"bin\"\n-        } else {\n-            \"lib\"\n-        })\n-        .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n+    let cg_clif_dylib_path = if cfg!(windows) {\n+        // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n+        // binaries.\n+        BIN_DIR\n+    } else {\n+        LIB_DIR\n+    }\n+    .to_path(dirs)\n+    .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n     try_hard_link(cg_clif_dylib_src, &cg_clif_dylib_path);\n \n     // Build and copy rustc and cargo wrappers\n@@ -40,18 +44,17 @@ pub(crate) fn build_sysroot(\n \n         let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n         build_cargo_wrapper_cmd\n-            .arg(PathBuf::from(\"scripts\").join(format!(\"{wrapper}.rs\")))\n+            .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(dist_dir.join(wrapper_name))\n+            .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n             .arg(\"-g\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }\n \n     let default_sysroot = super::rustc_info::get_default_sysroot();\n \n-    let rustlib = dist_dir.join(\"lib\").join(\"rustlib\");\n-    let host_rustlib_lib = rustlib.join(host_triple).join(\"lib\");\n-    let target_rustlib_lib = rustlib.join(target_triple).join(\"lib\");\n+    let host_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(host_triple).join(\"lib\");\n+    let target_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(target_triple).join(\"lib\");\n     fs::create_dir_all(&host_rustlib_lib).unwrap();\n     fs::create_dir_all(&target_rustlib_lib).unwrap();\n \n@@ -112,13 +115,7 @@ pub(crate) fn build_sysroot(\n             }\n         }\n         SysrootKind::Clif => {\n-            build_clif_sysroot_for_triple(\n-                channel,\n-                dist_dir,\n-                host_triple,\n-                &cg_clif_dylib_path,\n-                None,\n-            );\n+            build_clif_sysroot_for_triple(dirs, channel, host_triple, &cg_clif_dylib_path, None);\n \n             if host_triple != target_triple {\n                 // When cross-compiling it is often necessary to manually pick the right linker\n@@ -128,8 +125,8 @@ pub(crate) fn build_sysroot(\n                     None\n                 };\n                 build_clif_sysroot_for_triple(\n+                    dirs,\n                     channel,\n-                    dist_dir,\n                     target_triple,\n                     &cg_clif_dylib_path,\n                     linker,\n@@ -142,23 +139,26 @@ pub(crate) fn build_sysroot(\n                 let file = file.unwrap().path();\n                 let filename = file.file_name().unwrap().to_str().unwrap();\n                 if filename.contains(\"std-\") && !filename.contains(\".rlib\") {\n-                    try_hard_link(&file, dist_dir.join(\"lib\").join(file.file_name().unwrap()));\n+                    try_hard_link(&file, LIB_DIR.to_path(dirs).join(file.file_name().unwrap()));\n                 }\n             }\n         }\n     }\n }\n \n-static STANDARD_LIBRARY: CargoProject = CargoProject::local(\"build_sysroot\");\n+// FIXME move to download/ or dist/\n+pub(crate) static SYSROOT_RUSTC_VERSION: RelPath = RelPath::BUILD_SYSROOT.join(\"rustc_version\");\n+pub(crate) static SYSROOT_SRC: RelPath = RelPath::BUILD_SYSROOT.join(\"sysroot_src\");\n+static STANDARD_LIBRARY: CargoProject = CargoProject::new(&RelPath::BUILD_SYSROOT, \"build_sysroot\");\n \n fn build_clif_sysroot_for_triple(\n+    dirs: &Dirs,\n     channel: &str,\n-    dist_dir: &Path,\n     triple: &str,\n     cg_clif_dylib_path: &Path,\n     linker: Option<&str>,\n ) {\n-    match fs::read_to_string(Path::new(\"build_sysroot\").join(\"rustc_version\")) {\n+    match fs::read_to_string(SYSROOT_RUSTC_VERSION.to_path(dirs)) {\n         Err(e) => {\n             eprintln!(\"Failed to get rustc version for patched sysroot source: {}\", e);\n             eprintln!(\"Hint: Try `./y.rs prepare` to patch the sysroot source\");\n@@ -176,7 +176,7 @@ fn build_clif_sysroot_for_triple(\n         }\n     }\n \n-    let build_dir = Path::new(\"build_sysroot\").join(\"target\").join(triple).join(channel);\n+    let build_dir = STANDARD_LIBRARY.target_dir(dirs).join(triple).join(channel);\n \n     if !super::config::get_bool(\"keep_sysroot\") {\n         // Cleanup the deps dir, but keep build scripts and the incremental cache for faster\n@@ -189,7 +189,7 @@ fn build_clif_sysroot_for_triple(\n     // Build sysroot\n     let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n-    rustflags.push_str(&format!(\" --sysroot={}\", dist_dir.to_str().unwrap()));\n+    rustflags.push_str(&format!(\" --sysroot={}\", DIST_DIR.to_path(dirs).to_str().unwrap()));\n     if channel == \"release\" {\n         rustflags.push_str(\" -Zmir-opt-level=3\");\n     }\n@@ -199,18 +199,15 @@ fn build_clif_sysroot_for_triple(\n     }\n     let mut compiler = Compiler::with_triple(triple.to_owned());\n     compiler.rustflags = rustflags;\n-    let mut build_cmd = STANDARD_LIBRARY.build(&compiler);\n+    let mut build_cmd = STANDARD_LIBRARY.build(&compiler, dirs);\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n     }\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     spawn_and_wait(build_cmd);\n \n     // Copy all relevant files to the sysroot\n-    for entry in\n-        fs::read_dir(Path::new(\"build_sysroot/target\").join(triple).join(channel).join(\"deps\"))\n-            .unwrap()\n-    {\n+    for entry in fs::read_dir(build_dir.join(\"deps\")).unwrap() {\n         let entry = entry.unwrap();\n         if let Some(ext) = entry.path().extension() {\n             if ext == \"rmeta\" || ext == \"d\" || ext == \"dSYM\" || ext == \"clif\" {\n@@ -221,7 +218,7 @@ fn build_clif_sysroot_for_triple(\n         };\n         try_hard_link(\n             entry.path(),\n-            dist_dir.join(\"lib\").join(\"rustlib\").join(triple).join(\"lib\").join(entry.file_name()),\n+            RUSTLIB_DIR.to_path(dirs).join(triple).join(\"lib\").join(entry.file_name()),\n         );\n     }\n }"}, {"sha": "1afc9a55c73b5318bbc9ed006899c4f5ab3647c3", "filename": "build_system/mod.rs", "status": "modified", "additions": 65, "deletions": 26, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fmod.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -8,20 +8,37 @@ mod abi_cafe;\n mod build_backend;\n mod build_sysroot;\n mod config;\n+mod path;\n mod prepare;\n mod rustc_info;\n mod tests;\n mod utils;\n \n+const USAGE: &str = r#\"The build system of cg_clif.\n+\n+USAGE:\n+    ./y.rs prepare [--out-dir DIR]\n+    ./y.rs build [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs test [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+\n+OPTIONS:\n+    --sysroot none|clif|llvm\n+            Which sysroot libraries to use:\n+            `none` will not include any standard library in the sysroot.\n+            `clif` will build the standard library using Cranelift.\n+            `llvm` will use the pre-compiled standard library of rustc which is compiled with LLVM.\n+\n+    --out-dir DIR\n+            Specify the directory in which the download, build and dist directories are stored.\n+            By default this is the working directory.\n+\n+    --no-unstable-features\n+            fSome features are not yet ready for production usage. This option will disable these\n+            features. This includes the JIT mode and inline assembly support.\n+\"#;\n+\n fn usage() {\n-    eprintln!(\"Usage:\");\n-    eprintln!(\"  ./y.rs prepare\");\n-    eprintln!(\n-        \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--dist-dir DIR] [--no-unstable-features]\"\n-    );\n-    eprintln!(\n-        \"  ./y.rs test [--debug] [--sysroot none|clif|llvm] [--dist-dir DIR] [--no-unstable-features]\"\n-    );\n+    eprintln!(\"{USAGE}\");\n }\n \n macro_rules! arg_error {\n@@ -34,6 +51,7 @@ macro_rules! arg_error {\n \n #[derive(PartialEq, Debug)]\n enum Command {\n+    Prepare,\n     Build,\n     Test,\n }\n@@ -48,8 +66,6 @@ pub(crate) enum SysrootKind {\n pub fn main() {\n     env::set_var(\"CG_CLIF_DISPLAY_CG_TIME\", \"1\");\n     env::set_var(\"CG_CLIF_DISABLE_INCR_CACHE\", \"1\");\n-    // The target dir is expected in the default location. Guard against the user changing it.\n-    env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n \n     if is_ci() {\n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n@@ -58,13 +74,7 @@ pub fn main() {\n \n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n-        Some(\"prepare\") => {\n-            if args.next().is_some() {\n-                arg_error!(\"./y.rs prepare doesn't expect arguments\");\n-            }\n-            prepare::prepare();\n-            process::exit(0);\n-        }\n+        Some(\"prepare\") => Command::Prepare,\n         Some(\"build\") => Command::Build,\n         Some(\"test\") => Command::Test,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n@@ -75,15 +85,15 @@ pub fn main() {\n         }\n     };\n \n-    let mut dist_dir = PathBuf::from(\"dist\");\n+    let mut out_dir = PathBuf::from(\".\");\n     let mut channel = \"release\";\n     let mut sysroot_kind = SysrootKind::Clif;\n     let mut use_unstable_features = true;\n     while let Some(arg) = args.next().as_deref() {\n         match arg {\n-            \"--dist-dir\" => {\n-                dist_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n-                    arg_error!(\"--dist-dir requires argument\");\n+            \"--out-dir\" => {\n+                out_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n+                    arg_error!(\"--out-dir requires argument\");\n                 }))\n             }\n             \"--debug\" => channel = \"debug\",\n@@ -101,7 +111,6 @@ pub fn main() {\n             arg => arg_error!(\"Unexpected argument {}\", arg),\n         }\n     }\n-    dist_dir = std::env::current_dir().unwrap().join(dist_dir);\n \n     let host_triple = if let Ok(host_triple) = std::env::var(\"HOST_TRIPLE\") {\n         host_triple\n@@ -122,13 +131,43 @@ pub fn main() {\n         host_triple.clone()\n     };\n \n-    let cg_clif_dylib = build_backend::build_backend(channel, &host_triple, use_unstable_features);\n+    // FIXME allow changing the location of these dirs using cli arguments\n+    let current_dir = std::env::current_dir().unwrap();\n+    out_dir = current_dir.join(out_dir);\n+    let dirs = path::Dirs {\n+        source_dir: current_dir.clone(),\n+        download_dir: out_dir.join(\"download\"),\n+        build_dir: out_dir.join(\"build\"),\n+        dist_dir: out_dir.join(\"dist\"),\n+    };\n+\n+    path::RelPath::BUILD.ensure_exists(&dirs);\n+\n+    {\n+        // Make sure we always explicitly specify the target dir\n+        let target =\n+            path::RelPath::BUILD.join(\"target_dir_should_be_set_explicitly\").to_path(&dirs);\n+        env::set_var(\"CARGO_TARGET_DIR\", &target);\n+        let _ = std::fs::remove_file(&target);\n+        std::fs::File::create(target).unwrap();\n+    }\n+\n+    if command == Command::Prepare {\n+        prepare::prepare(&dirs);\n+        process::exit(0);\n+    }\n+\n+    let cg_clif_dylib =\n+        build_backend::build_backend(&dirs, channel, &host_triple, use_unstable_features);\n     match command {\n+        Command::Prepare => {\n+            // Handled above\n+        }\n         Command::Test => {\n             tests::run_tests(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &dist_dir,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n@@ -137,17 +176,17 @@ pub fn main() {\n             abi_cafe::run(\n                 channel,\n                 sysroot_kind,\n-                &dist_dir,\n+                &dirs,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );\n         }\n         Command::Build => {\n             build_sysroot::build_sysroot(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &dist_dir,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,"}, {"sha": "e93981f1d64d369b28672c0e61ff5a533c271a23", "filename": "build_system/path.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fpath.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -0,0 +1,70 @@\n+use std::fs;\n+use std::path::PathBuf;\n+\n+#[derive(Debug, Clone)]\n+pub(crate) struct Dirs {\n+    pub(crate) source_dir: PathBuf,\n+    pub(crate) download_dir: PathBuf,\n+    pub(crate) build_dir: PathBuf,\n+    pub(crate) dist_dir: PathBuf,\n+}\n+\n+#[doc(hidden)]\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum PathBase {\n+    Source,\n+    Download,\n+    Build,\n+    Dist,\n+}\n+\n+impl PathBase {\n+    fn to_path(self, dirs: &Dirs) -> PathBuf {\n+        match self {\n+            PathBase::Source => dirs.source_dir.clone(),\n+            PathBase::Download => dirs.download_dir.clone(),\n+            PathBase::Build => dirs.build_dir.clone(),\n+            PathBase::Dist => dirs.dist_dir.clone(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum RelPath {\n+    Base(PathBase),\n+    Join(&'static RelPath, &'static str),\n+}\n+\n+impl RelPath {\n+    pub(crate) const SOURCE: RelPath = RelPath::Base(PathBase::Source);\n+    pub(crate) const DOWNLOAD: RelPath = RelPath::Base(PathBase::Download);\n+    pub(crate) const BUILD: RelPath = RelPath::Base(PathBase::Build);\n+    pub(crate) const DIST: RelPath = RelPath::Base(PathBase::Dist);\n+\n+    pub(crate) const SCRIPTS: RelPath = RelPath::SOURCE.join(\"scripts\");\n+    pub(crate) const BUILD_SYSROOT: RelPath = RelPath::SOURCE.join(\"build_sysroot\");\n+    pub(crate) const PATCHES: RelPath = RelPath::SOURCE.join(\"patches\");\n+\n+    pub(crate) const fn join(&'static self, suffix: &'static str) -> RelPath {\n+        RelPath::Join(self, suffix)\n+    }\n+\n+    pub(crate) fn to_path(&self, dirs: &Dirs) -> PathBuf {\n+        match self {\n+            RelPath::Base(base) => base.to_path(dirs),\n+            RelPath::Join(base, suffix) => base.to_path(dirs).join(suffix),\n+        }\n+    }\n+\n+    pub(crate) fn ensure_exists(&self, dirs: &Dirs) {\n+        fs::create_dir_all(self.to_path(dirs)).unwrap();\n+    }\n+\n+    pub(crate) fn ensure_fresh(&self, dirs: &Dirs) {\n+        let path = self.to_path(dirs);\n+        if path.exists() {\n+            fs::remove_dir_all(&path).unwrap();\n+        }\n+        fs::create_dir_all(path).unwrap();\n+    }\n+}"}, {"sha": "28322c1cb512802a7b310e891983b54497e5a82f", "filename": "build_system/prepare.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fprepare.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -1,72 +1,79 @@\n-use std::env;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use super::build_sysroot::{SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n+use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n use super::utils::{copy_dir_recursively, spawn_and_wait, Compiler};\n \n-pub(crate) fn prepare() {\n-    if Path::new(\"download\").exists() {\n-        std::fs::remove_dir_all(Path::new(\"download\")).unwrap();\n+pub(crate) fn prepare(dirs: &Dirs) {\n+    if RelPath::DOWNLOAD.to_path(dirs).exists() {\n+        std::fs::remove_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n     }\n-    std::fs::create_dir_all(Path::new(\"download\")).unwrap();\n+    std::fs::create_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n \n-    prepare_sysroot();\n+    prepare_sysroot(dirs);\n \n     // FIXME maybe install this only locally?\n     eprintln!(\"[INSTALL] hyperfine\");\n-    Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n+    Command::new(\"cargo\")\n+        .arg(\"install\")\n+        .arg(\"hyperfine\")\n+        .env_remove(\"CARGO_TARGET_DIR\")\n+        .spawn()\n+        .unwrap()\n+        .wait()\n+        .unwrap();\n \n-    super::abi_cafe::ABI_CAFE_REPO.fetch();\n-    super::tests::RAND_REPO.fetch();\n-    super::tests::REGEX_REPO.fetch();\n-    super::tests::PORTABLE_SIMD_REPO.fetch();\n-    super::tests::SIMPLE_RAYTRACER_REPO.fetch();\n+    super::abi_cafe::ABI_CAFE_REPO.fetch(dirs);\n+    super::tests::RAND_REPO.fetch(dirs);\n+    super::tests::REGEX_REPO.fetch(dirs);\n+    super::tests::PORTABLE_SIMD_REPO.fetch(dirs);\n+    super::tests::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n \n     eprintln!(\"[LLVM BUILD] simple-raytracer\");\n     let host_compiler = Compiler::host();\n-    let build_cmd = super::tests::SIMPLE_RAYTRACER.build(&host_compiler);\n+    let build_cmd = super::tests::SIMPLE_RAYTRACER.build(&host_compiler, dirs);\n     spawn_and_wait(build_cmd);\n     fs::copy(\n         super::tests::SIMPLE_RAYTRACER\n-            .target_dir()\n+            .target_dir(dirs)\n             .join(&host_compiler.triple)\n             .join(\"debug\")\n             .join(get_file_name(\"main\", \"bin\")),\n-        super::tests::SIMPLE_RAYTRACER_REPO\n-            .source_dir()\n-            .join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }\n \n-fn prepare_sysroot() {\n+fn prepare_sysroot(dirs: &Dirs) {\n     let rustc_path = get_rustc_path();\n     let sysroot_src_orig = rustc_path.parent().unwrap().join(\"../lib/rustlib/src/rust\");\n-    let sysroot_src = env::current_dir().unwrap().join(\"build_sysroot\").join(\"sysroot_src\");\n+    let sysroot_src = SYSROOT_SRC;\n \n     assert!(sysroot_src_orig.exists());\n \n-    if sysroot_src.exists() {\n-        fs::remove_dir_all(&sysroot_src).unwrap();\n-    }\n-    fs::create_dir_all(sysroot_src.join(\"library\")).unwrap();\n+    sysroot_src.ensure_fresh(dirs);\n+    fs::create_dir_all(sysroot_src.to_path(dirs).join(\"library\")).unwrap();\n     eprintln!(\"[COPY] sysroot src\");\n-    copy_dir_recursively(&sysroot_src_orig.join(\"library\"), &sysroot_src.join(\"library\"));\n+    copy_dir_recursively(\n+        &sysroot_src_orig.join(\"library\"),\n+        &sysroot_src.to_path(dirs).join(\"library\"),\n+    );\n \n     let rustc_version = get_rustc_version();\n-    fs::write(Path::new(\"build_sysroot\").join(\"rustc_version\"), &rustc_version).unwrap();\n+    fs::write(SYSROOT_RUSTC_VERSION.to_path(dirs), &rustc_version).unwrap();\n \n     eprintln!(\"[GIT] init\");\n     let mut git_init_cmd = Command::new(\"git\");\n-    git_init_cmd.arg(\"init\").arg(\"-q\").current_dir(&sysroot_src);\n+    git_init_cmd.arg(\"init\").arg(\"-q\").current_dir(sysroot_src.to_path(dirs));\n     spawn_and_wait(git_init_cmd);\n \n-    init_git_repo(&sysroot_src);\n+    init_git_repo(&sysroot_src.to_path(dirs));\n \n-    apply_patches(\"sysroot\", &sysroot_src);\n+    apply_patches(dirs, \"sysroot\", &sysroot_src.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {\n@@ -89,21 +96,25 @@ impl GitRepo {\n         GitRepo { url: GitRepoUrl::Github { user, repo }, rev, patch_name }\n     }\n \n-    pub(crate) fn source_dir(&self) -> PathBuf {\n+    pub(crate) const fn source_dir(&self) -> RelPath {\n         match self.url {\n-            GitRepoUrl::Github { user: _, repo } => {\n-                std::env::current_dir().unwrap().join(\"download\").join(repo)\n-            }\n+            GitRepoUrl::Github { user: _, repo } => RelPath::DOWNLOAD.join(repo),\n         }\n     }\n \n-    fn fetch(&self) {\n+    fn fetch(&self, dirs: &Dirs) {\n         match self.url {\n             GitRepoUrl::Github { user, repo } => {\n-                clone_repo_shallow_github(&self.source_dir(), user, repo, self.rev);\n+                clone_repo_shallow_github(\n+                    dirs,\n+                    &self.source_dir().to_path(dirs),\n+                    user,\n+                    repo,\n+                    self.rev,\n+                );\n             }\n         }\n-        apply_patches(self.patch_name, &self.source_dir());\n+        apply_patches(dirs, self.patch_name, &self.source_dir().to_path(dirs));\n     }\n }\n \n@@ -122,18 +133,16 @@ fn clone_repo(download_dir: &Path, repo: &str, rev: &str) {\n     spawn_and_wait(checkout_cmd);\n }\n \n-fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &str) {\n+fn clone_repo_shallow_github(dirs: &Dirs, download_dir: &Path, user: &str, repo: &str, rev: &str) {\n     if cfg!(windows) {\n         // Older windows doesn't have tar or curl by default. Fall back to using git.\n         clone_repo(download_dir, &format!(\"https://github.com/{}/{}.git\", user, repo), rev);\n         return;\n     }\n \n-    let downloads_dir = std::env::current_dir().unwrap().join(\"download\");\n-\n     let archive_url = format!(\"https://github.com/{}/{}/archive/{}.tar.gz\", user, repo, rev);\n-    let archive_file = downloads_dir.join(format!(\"{}.tar.gz\", rev));\n-    let archive_dir = downloads_dir.join(format!(\"{}-{}\", repo, rev));\n+    let archive_file = RelPath::DOWNLOAD.to_path(dirs).join(format!(\"{}.tar.gz\", rev));\n+    let archive_dir = RelPath::DOWNLOAD.to_path(dirs).join(format!(\"{}-{}\", repo, rev));\n \n     eprintln!(\"[DOWNLOAD] {}/{} from {}\", user, repo, archive_url);\n \n@@ -149,7 +158,7 @@ fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &\n \n     // Unpack tar archive\n     let mut unpack_cmd = Command::new(\"tar\");\n-    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(downloads_dir);\n+    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(RelPath::DOWNLOAD.to_path(dirs));\n     spawn_and_wait(unpack_cmd);\n \n     // Rename unpacked dir to the expected name\n@@ -175,8 +184,8 @@ fn init_git_repo(repo_dir: &Path) {\n     spawn_and_wait(git_commit_cmd);\n }\n \n-fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n-    let mut patches: Vec<_> = fs::read_dir(source_dir.join(\"patches\"))\n+fn get_patches(dirs: &Dirs, crate_name: &str) -> Vec<PathBuf> {\n+    let mut patches: Vec<_> = fs::read_dir(RelPath::PATCHES.to_path(dirs))\n         .unwrap()\n         .map(|entry| entry.unwrap().path())\n         .filter(|path| path.extension() == Some(OsStr::new(\"patch\")))\n@@ -195,12 +204,12 @@ fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n     patches\n }\n \n-fn apply_patches(crate_name: &str, target_dir: &Path) {\n+fn apply_patches(dirs: &Dirs, crate_name: &str, target_dir: &Path) {\n     if crate_name == \"<none>\" {\n         return;\n     }\n \n-    for patch in get_patches(&std::env::current_dir().unwrap(), crate_name) {\n+    for patch in get_patches(dirs, crate_name) {\n         eprintln!(\n             \"[PATCH] {:?} <- {:?}\",\n             target_dir.file_name().unwrap(),"}, {"sha": "bd31d5e6bbf28c7ed6a62d08fe7c384235156c73", "filename": "build_system/tests.rs", "status": "modified", "additions": 68, "deletions": 78, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Ftests.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -1,19 +1,20 @@\n-use crate::build_system::rustc_info::get_cargo_path;\n-\n use super::build_sysroot;\n use super::config;\n+use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n-use super::rustc_info::get_wrapper_file_name;\n+use super::rustc_info::{get_cargo_path, get_wrapper_file_name};\n use super::utils::{\n     hyperfine_command, spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler,\n };\n use super::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n use std::fs;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::process::Command;\n \n+static BUILD_EXAMPLE_OUT_DIR: RelPath = RelPath::BUILD.join(\"example\");\n+\n struct TestCase {\n     config: &'static str,\n     func: &'static dyn Fn(&TestRunner),\n@@ -223,12 +224,12 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n pub(crate) static RAND_REPO: GitRepo =\n     GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n \n-static RAND: CargoProject = CargoProject::git(&RAND_REPO, \".\");\n+static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n \n pub(crate) static REGEX_REPO: GitRepo =\n     GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n \n-static REGEX: CargoProject = CargoProject::git(&REGEX_REPO, \".\");\n+static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n \n pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"rust-lang\",\n@@ -237,7 +238,8 @@ pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"portable-simd\",\n );\n \n-static PORTABLE_SIMD: CargoProject = CargoProject::git(&PORTABLE_SIMD_REPO, \".\");\n+static PORTABLE_SIMD: CargoProject =\n+    CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n \n pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n     \"ebobby\",\n@@ -246,23 +248,24 @@ pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n     \"<none>\",\n );\n \n-pub(crate) static SIMPLE_RAYTRACER: CargoProject = CargoProject::git(&SIMPLE_RAYTRACER_REPO, \".\");\n+pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n+    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n \n static LIBCORE_TESTS: CargoProject =\n-    CargoProject::local(\"build_sysroot/sysroot_src/library/core/tests\");\n+    CargoProject::new(&RelPath::BUILD_SYSROOT.join(\"sysroot_src/library/core/tests\"), \"core_tests\");\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        spawn_and_wait(RAND.clean(&runner.target_compiler.cargo));\n+        spawn_and_wait(RAND.clean(&runner.target_compiler.cargo, &runner.dirs));\n \n         if runner.is_native {\n             eprintln!(\"[TEST] rust-random/rand\");\n-            let mut test_cmd = RAND.test(&runner.target_compiler);\n+            let mut test_cmd = RAND.test(&runner.target_compiler, &runner.dirs);\n             test_cmd.arg(\"--workspace\");\n             spawn_and_wait(test_cmd);\n         } else {\n             eprintln!(\"[AOT] rust-random/rand\");\n-            let mut build_cmd = RAND.build(&runner.target_compiler);\n+            let mut build_cmd = RAND.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--workspace\").arg(\"--tests\");\n             spawn_and_wait(build_cmd);\n         }\n@@ -272,13 +275,11 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n \n         if runner.is_native {\n             eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-            let cargo_clif = env::current_dir()\n-                .unwrap()\n-                .join(\"dist\")\n+            let cargo_clif = RelPath::DIST\n+                .to_path(&runner.dirs)\n                 .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-            let source_dir = SIMPLE_RAYTRACER.source_dir();\n-            let manifest_path = SIMPLE_RAYTRACER.manifest_path();\n-            let target_dir = SIMPLE_RAYTRACER.target_dir();\n+            let manifest_path = SIMPLE_RAYTRACER.manifest_path(&runner.dirs);\n+            let target_dir = SIMPLE_RAYTRACER.target_dir(&runner.dirs);\n \n             let clean_cmd = format!(\n                 \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n@@ -303,58 +304,58 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(bench_compile);\n \n             eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n-            fs::copy(target_dir.join(\"debug\").join(\"main\"), source_dir.join(\"raytracer_cg_clif\"))\n-                .unwrap();\n-\n-            let mut bench_run = hyperfine_command(\n-                0,\n-                run_runs,\n-                None,\n-                &source_dir.join(\"raytracer_cg_llvm\").display().to_string(),\n-                &source_dir.join(\"raytracer_cg_clif\").display().to_string(),\n-            );\n-            bench_run.current_dir(SIMPLE_RAYTRACER.source_dir());\n+            fs::copy(\n+                target_dir.join(\"debug\").join(\"main\"),\n+                RelPath::BUILD.to_path(&runner.dirs).join(\"raytracer_cg_clif\"),\n+            )\n+            .unwrap();\n+\n+            let mut bench_run =\n+                hyperfine_command(0, run_runs, None, \"./raytracer_cg_llvm\", \"./raytracer_cg_clif\");\n+            bench_run.current_dir(RelPath::BUILD.to_path(&runner.dirs));\n             spawn_and_wait(bench_run);\n         } else {\n-            spawn_and_wait(SIMPLE_RAYTRACER.clean(&runner.target_compiler.cargo));\n+            spawn_and_wait(SIMPLE_RAYTRACER.clean(&runner.target_compiler.cargo, &runner.dirs));\n             eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n             eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-            spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler));\n+            spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n             eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n         }\n     }),\n     TestCase::new(\"test.libcore\", &|runner| {\n-        spawn_and_wait(LIBCORE_TESTS.clean(&runner.host_compiler.cargo));\n+        spawn_and_wait(LIBCORE_TESTS.clean(&runner.host_compiler.cargo, &runner.dirs));\n \n         if runner.is_native {\n-            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler));\n+            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n-            let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler);\n+            let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--tests\");\n             spawn_and_wait(build_cmd);\n         }\n     }),\n     TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        spawn_and_wait(REGEX.clean(&runner.target_compiler.cargo));\n+        spawn_and_wait(REGEX.clean(&runner.target_compiler.cargo, &runner.dirs));\n \n         // newer aho_corasick versions throw a deprecation warning\n         let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n \n-        let mut build_cmd = REGEX.build(&runner.target_compiler);\n+        let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n         build_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n         build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n         spawn_and_wait(build_cmd);\n \n         if runner.is_native {\n-            let mut run_cmd = REGEX.run(&runner.target_compiler);\n+            let mut run_cmd = REGEX.run(&runner.target_compiler, &runner.dirs);\n             run_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n             run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n \n-            let input =\n-                fs::read_to_string(REGEX.source_dir().join(\"examples\").join(\"regexdna-input.txt\"))\n-                    .unwrap();\n-            let expected_path = REGEX.source_dir().join(\"examples\").join(\"regexdna-output.txt\");\n+            let input = fs::read_to_string(\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n+            )\n+            .unwrap();\n+            let expected_path =\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-output.txt\");\n             let expected = fs::read_to_string(&expected_path).unwrap();\n \n             let output = spawn_and_wait_with_input(run_cmd, input);\n@@ -368,7 +369,7 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n \n             let output_matches = expected.lines().eq(output.lines());\n             if !output_matches {\n-                let res_path = REGEX.source_dir().join(\"res.txt\");\n+                let res_path = REGEX.source_dir(&runner.dirs).join(\"res.txt\");\n                 fs::write(&res_path, &output).unwrap();\n \n                 if cfg!(windows) {\n@@ -388,13 +389,13 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n         }\n     }),\n     TestCase::new(\"test.regex\", &|runner| {\n-        spawn_and_wait(REGEX.clean(&runner.host_compiler.cargo));\n+        spawn_and_wait(REGEX.clean(&runner.host_compiler.cargo, &runner.dirs));\n \n         // newer aho_corasick versions throw a deprecation warning\n         let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n \n         if runner.is_native {\n-            let mut run_cmd = REGEX.test(&runner.target_compiler);\n+            let mut run_cmd = REGEX.test(&runner.target_compiler, &runner.dirs);\n             run_cmd.args([\n                 \"--tests\",\n                 \"--\",\n@@ -408,48 +409,48 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(run_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n-            let mut build_cmd = REGEX.build(&runner.target_compiler);\n+            let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--tests\");\n             build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n             spawn_and_wait(build_cmd);\n         }\n     }),\n     TestCase::new(\"test.portable-simd\", &|runner| {\n-        spawn_and_wait(PORTABLE_SIMD.clean(&runner.host_compiler.cargo));\n+        spawn_and_wait(PORTABLE_SIMD.clean(&runner.host_compiler.cargo, &runner.dirs));\n \n-        let mut build_cmd = PORTABLE_SIMD.build(&runner.target_compiler);\n+        let mut build_cmd = PORTABLE_SIMD.build(&runner.target_compiler, &runner.dirs);\n         build_cmd.arg(\"--all-targets\");\n         spawn_and_wait(build_cmd);\n \n         if runner.is_native {\n-            let mut test_cmd = PORTABLE_SIMD.test(&runner.target_compiler);\n+            let mut test_cmd = PORTABLE_SIMD.test(&runner.target_compiler, &runner.dirs);\n             test_cmd.arg(\"-q\");\n             spawn_and_wait(test_cmd);\n         }\n     }),\n ];\n \n pub(crate) fn run_tests(\n+    dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    dist_dir: &Path,\n     cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n-    let runner = TestRunner::new(host_triple.to_string(), target_triple.to_string());\n+    let runner = TestRunner::new(dirs.clone(), host_triple.to_string(), target_triple.to_string());\n \n     if config::get_bool(\"testsuite.no_sysroot\") {\n         build_sysroot::build_sysroot(\n+            dirs,\n             channel,\n             SysrootKind::None,\n-            &dist_dir,\n             cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n         );\n \n-        let _ = fs::remove_dir_all(Path::new(\"target\").join(\"out\"));\n+        BUILD_EXAMPLE_OUT_DIR.ensure_fresh(dirs);\n         runner.run_testsuite(NO_SYSROOT_SUITE);\n     } else {\n         eprintln!(\"[SKIP] no_sysroot tests\");\n@@ -460,9 +461,9 @@ pub(crate) fn run_tests(\n \n     if run_base_sysroot || run_extended_sysroot {\n         build_sysroot::build_sysroot(\n+            dirs,\n             channel,\n             sysroot_kind,\n-            &dist_dir,\n             cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n@@ -483,32 +484,23 @@ pub(crate) fn run_tests(\n }\n \n struct TestRunner {\n-    out_dir: PathBuf,\n     is_native: bool,\n     jit_supported: bool,\n+    dirs: Dirs,\n     host_compiler: Compiler,\n     target_compiler: Compiler,\n }\n \n impl TestRunner {\n-    pub fn new(host_triple: String, target_triple: String) -> Self {\n-        let root_dir = env::current_dir().unwrap();\n-\n-        let mut out_dir = root_dir.clone();\n-        out_dir.push(\"target\");\n-        out_dir.push(\"out\");\n-\n+    pub fn new(dirs: Dirs, host_triple: String, target_triple: String) -> Self {\n         let is_native = host_triple == target_triple;\n         let jit_supported =\n             target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n \n-        let mut rustc_clif = root_dir.clone();\n-        rustc_clif.push(\"dist\");\n-        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n-\n-        let mut rustdoc_clif = root_dir.clone();\n-        rustdoc_clif.push(\"dist\");\n-        rustdoc_clif.push(get_wrapper_file_name(\"rustdoc-clif\", \"bin\"));\n+        let rustc_clif =\n+            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n+        let rustdoc_clif =\n+            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustdoc-clif\", \"bin\"));\n \n         let mut rustflags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n         let mut runner = vec![];\n@@ -551,15 +543,15 @@ impl TestRunner {\n \n         let target_compiler = Compiler {\n             cargo: get_cargo_path(),\n-            rustc: rustc_clif.clone(),\n-            rustdoc: rustdoc_clif.clone(),\n+            rustc: rustc_clif,\n+            rustdoc: rustdoc_clif,\n             rustflags: rustflags.clone(),\n             rustdocflags: rustflags,\n             triple: target_triple,\n             runner,\n         };\n \n-        Self { out_dir, is_native, jit_supported, host_compiler, target_compiler }\n+        Self { is_native, jit_supported, dirs, host_compiler, target_compiler }\n     }\n \n     pub fn run_testsuite(&self, tests: &[TestCase]) {\n@@ -588,9 +580,9 @@ impl TestRunner {\n         let mut cmd = Command::new(&self.target_compiler.rustc);\n         cmd.args(self.target_compiler.rustflags.split_whitespace());\n         cmd.arg(\"-L\");\n-        cmd.arg(format!(\"crate={}\", self.out_dir.display()));\n+        cmd.arg(format!(\"crate={}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"--out-dir\");\n-        cmd.arg(format!(\"{}\", self.out_dir.display()));\n+        cmd.arg(format!(\"{}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"-Cdebuginfo=2\");\n         cmd.args(args);\n         cmd\n@@ -615,11 +607,9 @@ impl TestRunner {\n             full_cmd.extend(self.target_compiler.runner.iter().cloned());\n         }\n \n-        full_cmd.push({\n-            let mut out_path = self.out_dir.clone();\n-            out_path.push(name);\n-            out_path.to_str().unwrap().to_string()\n-        });\n+        full_cmd.push(\n+            BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).join(name).to_str().unwrap().to_string(),\n+        );\n \n         for arg in args.into_iter() {\n             full_cmd.push(arg.to_string());"}, {"sha": "dab6308bc1d547135868ba28652525884a006c0e", "filename": "build_system/utils.rs", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/build_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Futils.rs?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -4,7 +4,7 @@ use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::process::{self, Command, Stdio};\n \n-use super::prepare::GitRepo;\n+use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_cargo_path, get_host_triple, get_rustc_path, get_rustdoc_path};\n \n pub(crate) struct Compiler {\n@@ -43,60 +43,42 @@ impl Compiler {\n     }\n }\n \n-enum CargoProjectSource {\n-    Local,\n-    GitRepo(&'static GitRepo),\n-}\n-\n pub(crate) struct CargoProject {\n-    source: CargoProjectSource,\n-    path: &'static str,\n+    source: &'static RelPath,\n+    target: &'static str,\n }\n \n impl CargoProject {\n-    pub(crate) const fn local(path: &'static str) -> CargoProject {\n-        CargoProject { source: CargoProjectSource::Local, path }\n-    }\n-\n-    pub(crate) const fn git(git_repo: &'static GitRepo, path: &'static str) -> CargoProject {\n-        CargoProject { source: CargoProjectSource::GitRepo(git_repo), path }\n+    pub(crate) const fn new(path: &'static RelPath, target: &'static str) -> CargoProject {\n+        CargoProject { source: path, target }\n     }\n \n-    pub(crate) fn source_dir(&self) -> PathBuf {\n-        match self.source {\n-            CargoProjectSource::Local => std::env::current_dir().unwrap(),\n-            CargoProjectSource::GitRepo(git_repo) => git_repo.source_dir(),\n-        }\n-        .join(self.path)\n+    pub(crate) fn source_dir(&self, dirs: &Dirs) -> PathBuf {\n+        self.source.to_path(dirs)\n     }\n \n-    pub(crate) fn manifest_path(&self) -> PathBuf {\n-        self.source_dir().join(\"Cargo.toml\")\n+    pub(crate) fn manifest_path(&self, dirs: &Dirs) -> PathBuf {\n+        self.source_dir(dirs).join(\"Cargo.toml\")\n     }\n \n-    pub(crate) fn target_dir(&self) -> PathBuf {\n-        match self.source {\n-            CargoProjectSource::Local => std::env::current_dir().unwrap(),\n-            CargoProjectSource::GitRepo(git_repo) => git_repo.source_dir(),\n-        }\n-        .join(self.path)\n-        .join(\"target\")\n+    pub(crate) fn target_dir(&self, dirs: &Dirs) -> PathBuf {\n+        RelPath::BUILD.join(self.target).to_path(dirs)\n     }\n \n-    fn base_cmd(&self, command: &str, cargo: &Path) -> Command {\n+    fn base_cmd(&self, command: &str, cargo: &Path, dirs: &Dirs) -> Command {\n         let mut cmd = Command::new(cargo);\n \n         cmd.arg(command)\n             .arg(\"--manifest-path\")\n-            .arg(self.manifest_path())\n+            .arg(self.manifest_path(dirs))\n             .arg(\"--target-dir\")\n-            .arg(self.target_dir());\n+            .arg(self.target_dir(dirs));\n \n         cmd\n     }\n \n-    fn build_cmd(&self, command: &str, compiler: &Compiler) -> Command {\n-        let mut cmd = self.base_cmd(command, &compiler.cargo);\n+    fn build_cmd(&self, command: &str, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        let mut cmd = self.base_cmd(command, &compiler.cargo, dirs);\n \n         cmd.arg(\"--target\").arg(&compiler.triple);\n \n@@ -115,32 +97,32 @@ impl CargoProject {\n     }\n \n     #[must_use]\n-    pub(crate) fn fetch(&self, cargo: impl AsRef<Path>) -> Command {\n+    pub(crate) fn fetch(&self, cargo: impl AsRef<Path>, dirs: &Dirs) -> Command {\n         let mut cmd = Command::new(cargo.as_ref());\n \n-        cmd.arg(\"fetch\").arg(\"--manifest-path\").arg(self.manifest_path());\n+        cmd.arg(\"fetch\").arg(\"--manifest-path\").arg(self.manifest_path(dirs));\n \n         cmd\n     }\n \n     #[must_use]\n-    pub(crate) fn clean(&self, cargo: &Path) -> Command {\n-        self.base_cmd(\"clean\", cargo)\n+    pub(crate) fn clean(&self, cargo: &Path, dirs: &Dirs) -> Command {\n+        self.base_cmd(\"clean\", cargo, dirs)\n     }\n \n     #[must_use]\n-    pub(crate) fn build(&self, compiler: &Compiler) -> Command {\n-        self.build_cmd(\"build\", compiler)\n+    pub(crate) fn build(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"build\", compiler, dirs)\n     }\n \n     #[must_use]\n-    pub(crate) fn test(&self, compiler: &Compiler) -> Command {\n-        self.build_cmd(\"test\", compiler)\n+    pub(crate) fn test(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"test\", compiler, dirs)\n     }\n \n     #[must_use]\n-    pub(crate) fn run(&self, compiler: &Compiler) -> Command {\n-        self.build_cmd(\"run\", compiler)\n+    pub(crate) fn run(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"run\", compiler, dirs)\n     }\n }\n "}, {"sha": "1760e5836ecce00a48f7a0236748dfb94329fce0", "filename": "clean_all.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/clean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/clean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clean_all.sh?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -2,9 +2,9 @@\n set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n-rm -rf target/ dist/ perf.data{,.old} y.bin\n+rm -rf target/ build/ dist/ perf.data{,.old} y.bin\n rm -rf download/\n \n # Kept for now in case someone updates their checkout of cg_clif before running clean_all.sh\n # FIXME remove at some point in the future\n-rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/ abi-cafe/ build/\n+rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/ abi-cafe/"}, {"sha": "13e7784539d5a9b9cdb3c81dd7f548afcb0c418b", "filename": "test.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f73b0b1349cb5190f7b1e3e4378acc1a434e1687/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=f73b0b1349cb5190f7b1e3e4378acc1a434e1687", "patch": "@@ -1,2 +1,2 @@\n #!/usr/bin/env bash\n-exec ./y.rs test\n+exec ./y.rs test \"$@\""}]}