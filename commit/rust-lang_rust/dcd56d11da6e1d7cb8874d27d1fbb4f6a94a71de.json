{"sha": "dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZDU2ZDExZGE2ZTFkN2NiODg3NGQyN2QxZmJiNGY2YTk0YTcxZGU=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2019-01-18T20:10:45Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2019-01-18T20:10:45Z"}, "message": "remove more old readmes", "tree": {"sha": "70e12a126727019578f89b094034ffecd3eada89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70e12a126727019578f89b094034ffecd3eada89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "html_url": "https://github.com/rust-lang/rust/commit/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "228969c696b380716ad7547e87c4b52f3df50c96", "url": "https://api.github.com/repos/rust-lang/rust/commits/228969c696b380716ad7547e87c4b52f3df50c96", "html_url": "https://github.com/rust-lang/rust/commit/228969c696b380716ad7547e87c4b52f3df50c96"}], "stats": {"total": 710, "additions": 8, "deletions": 702}, "files": [{"sha": "e7afaa5beb0a75adcc35dca489ddbfe834cc0419", "filename": "src/librustc/infer/higher_ranked/README.md", "status": "modified", "additions": 6, "deletions": 401, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md?ref=dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "patch": "@@ -1,403 +1,8 @@\n-# Skolemization and functions\n+To learn more about how Higher-ranked trait bounds work in the _old_ trait\n+solver, see [this chapter][oldhrtb] of the rustc-guide.\n \n-One of the trickiest and most subtle aspects of regions is dealing\n-with higher-ranked things which include bound region variables, such\n-as function types. I strongly suggest that if you want to understand\n-the situation, you read this paper (which is, admittedly, very long,\n-but you don't have to read the whole thing):\n+To learn more about how they work in the _new_ trait solver, see [this\n+chapter][newhrtb].\n \n-http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-Although my explanation will never compete with SPJ's (for one thing,\n-his is approximately 100 pages), I will attempt to explain the basic\n-problem and also how we solve it. Note that the paper only discusses\n-subtyping, not the computation of LUB/GLB.\n-\n-The problem we are addressing is that there is a kind of subtyping\n-between functions with bound region parameters. Consider, for\n-example, whether the following relation holds:\n-\n-    for<'a> fn(&'a isize) <: for<'b> fn(&'b isize)? (Yes, a => b)\n-\n-The answer is that of course it does. These two types are basically\n-the same, except that in one we used the name `a` and one we used\n-the name `b`.\n-\n-In the examples that follow, it becomes very important to know whether\n-a lifetime is bound in a function type (that is, is a lifetime\n-parameter) or appears free (is defined in some outer scope).\n-Therefore, from now on I will always write the bindings explicitly,\n-using the Rust syntax `for<'a> fn(&'a isize)` to indicate that `a` is a\n-lifetime parameter.\n-\n-Now let's consider two more function types. Here, we assume that the\n-`'b` lifetime is defined somewhere outside and hence is not a lifetime\n-parameter bound by the function type (it \"appears free\"):\n-\n-    for<'a> fn(&'a isize) <: fn(&'b isize)? (Yes, a => b)\n-\n-This subtyping relation does in fact hold. To see why, you have to\n-consider what subtyping means. One way to look at `T1 <: T2` is to\n-say that it means that it is always ok to treat an instance of `T1` as\n-if it had the type `T2`. So, with our functions, it is always ok to\n-treat a function that can take pointers with any lifetime as if it\n-were a function that can only take a pointer with the specific\n-lifetime `'b`. After all, `'b` is a lifetime, after all, and\n-the function can take values of any lifetime.\n-\n-You can also look at subtyping as the *is a* relationship. This amounts\n-to the same thing: a function that accepts pointers with any lifetime\n-*is a* function that accepts pointers with some specific lifetime.\n-\n-So, what if we reverse the order of the two function types, like this:\n-\n-    fn(&'b isize) <: for<'a> fn(&'a isize)? (No)\n-\n-Does the subtyping relationship still hold?  The answer of course is\n-no. In this case, the function accepts *only the lifetime `'b`*,\n-so it is not reasonable to treat it as if it were a function that\n-accepted any lifetime.\n-\n-What about these two examples:\n-\n-    for<'a,'b> fn(&'a isize, &'b isize) <: for<'a>    fn(&'a isize, &'a isize)? (Yes)\n-    for<'a>    fn(&'a isize, &'a isize) <: for<'a,'b> fn(&'a isize, &'b isize)? (No)\n-\n-Here, it is true that functions which take two pointers with any two\n-lifetimes can be treated as if they only accepted two pointers with\n-the same lifetime, but not the reverse.\n-\n-## The algorithm\n-\n-Here is the algorithm we use to perform the subtyping check:\n-\n-1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with placeholder\n-   equivalents. A \"placeholder\" region is just a new fresh region\n-   name.\n-3. Check that the parameter and return types match as normal\n-4. Ensure that no placeholder regions 'leak' into region variables\n-   visible from \"the outside\"\n-\n-Let's walk through some examples and see how this algorithm plays out.\n-\n-#### First example\n-\n-We'll start with the first example, which was:\n-\n-    1. for<'a> fn(&'a T) <: for<'b> fn(&'b T)?        Yes: a -> b\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    1. fn(&'A T) <: fn(&'x T)?\n-\n-Here the upper case `&A` indicates a *region variable*, that is, a\n-region whose value is being inferred by the system. I also replaced\n-`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate placeholder region names. We can assume they don't appear\n-elsewhere. Note that neither the sub- nor the supertype bind any\n-region names anymore (as indicated by the absence of `<` and `>`).\n-\n-The next step is to check that the parameter types match. Because\n-parameters are contravariant, this means that we check whether:\n-\n-    &'x T <: &'A T\n-\n-Region pointers are contravariant so this implies that\n-\n-    &A <= &x\n-\n-must hold, where `<=` is the subregion relationship. Processing\n-*this* constrain simply adds a constraint into our graph that `&A <=\n-&x` and is considered successful (it can, for example, be satisfied by\n-choosing the value `&x` for `&A`).\n-\n-So far we have encountered no error, so the subtype check succeeds.\n-\n-#### The third example\n-\n-Now let's look first at the third example, which was:\n-\n-    3. fn(&'a T)    <: for<'b> fn(&'b T)?        No!\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    3. fn(&'a T) <: fn(&'x T)?\n-\n-This looks pretty much the same as before, except that on the LHS\n-`'a` was not bound, and hence was left as-is and not replaced with\n-a variable. The next step is again to check that the parameter types\n-match. This will ultimately require (as before) that `'a` <= `&x`\n-must hold: but this does not hold. `self` and `x` are both distinct\n-free regions. So the subtype check fails.\n-\n-#### Checking for placeholder leaks\n-\n-You may be wondering about that mysterious last step in the algorithm.\n-So far it has not been relevant. The purpose of that last step is to\n-catch something like *this*:\n-\n-    for<'a> fn() -> fn(&'a T) <: fn() -> for<'b> fn(&'b T)?   No.\n-\n-Here the function types are the same but for where the binding occurs.\n-The subtype returns a function that expects a value in precisely one\n-region. The supertype returns a function that expects a value in any\n-region. If we allow an instance of the subtype to be used where the\n-supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&'b T)` when it really has type\n-`fn(&'a T)` (this is case #3, above). Bad.\n-\n-So let's step through what happens when we perform this subtype check.\n-We first replace the bound regions in the subtype (the supertype has\n-no bound regions). This gives us:\n-\n-    fn() -> fn(&'A T) <: fn() -> for<'b> fn(&'b T)?\n-\n-Now we compare the return types, which are covariant, and hence we have:\n-\n-    fn(&'A T) <: for<'b> fn(&'b T)?\n-\n-Here we replace the bound region in the supertype with a placeholder to yield:\n-\n-    fn(&'A T) <: fn(&'x T)?\n-\n-And then proceed to compare the argument types:\n-\n-    &'x T <: &'A T\n-    'A <= 'x\n-\n-Finally, this is where it gets interesting!  This is where an error\n-*should* be reported. But in fact this will not happen. The reason why\n-is that `A` is a variable: we will infer that its value is the fresh\n-region `x` and think that everything is happy. In fact, this behavior\n-is *necessary*, it was key to the first example we walked through.\n-\n-The difference between this example and the first one is that the variable\n-`A` already existed at the point where the placeholders were added. In\n-the first example, you had two functions:\n-\n-    for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n-\n-and hence `&A` and `&x` were created \"together\". In general, the\n-intention of the placeholder names is that they are supposed to be\n-fresh names that could never be equal to anything from the outside.\n-But when inference comes into play, we might not be respecting this\n-rule.\n-\n-So the way we solve this is to add a fourth step that examines the\n-constraints that refer to placeholder names. Basically, consider a\n-non-directed version of the constraint graph. Let `Tainted(x)` be the\n-set of all things reachable from a placeholder variable `x`.\n-`Tainted(x)` should not contain any regions that existed before the\n-step at which the placeholders were created. So this case here\n-would fail because `&x` was created alone, but is relatable to `&A`.\n-\n-## Computing the LUB and GLB\n-\n-The paper I pointed you at is written for Haskell. It does not\n-therefore considering subtyping and in particular does not consider\n-LUB or GLB computation. We have to consider this. Here is the\n-algorithm I implemented.\n-\n-First though, let's discuss what we are trying to compute in more\n-detail. The LUB is basically the \"common supertype\" and the GLB is\n-\"common subtype\"; one catch is that the LUB should be the\n-*most-specific* common supertype and the GLB should be *most general*\n-common subtype (as opposed to any common supertype or any common\n-subtype).\n-\n-Anyway, to help clarify, here is a table containing some function\n-pairs and their LUB/GLB (for conciseness, in this table, I'm just\n-including the lifetimes here, not the rest of the types, and I'm\n-writing `fn<>` instead of `for<> fn`):\n-\n-```\n-Type 1                Type 2                LUB                    GLB\n-fn<'a>('a)            fn('X)                fn('X)                 fn<'a>('a)\n-fn('a)                fn('X)                --                     fn<'a>('a)\n-fn<'a,'b>('a, 'b)     fn<'x>('x, 'x)        fn<'a>('a, 'a)         fn<'a,'b>('a, 'b)\n-fn<'a,'b>('a, 'b, 'a) fn<'x,'y>('x, 'y, 'y) fn<'a>('a, 'a, 'a)     fn<'a,'b,'c>('a,'b,'c)\n-```\n-\n-### Conventions\n-\n-I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n-letters for free regions (`&A`).  Region variables written with a\n-dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n-bound-regions on the fn type as well (e.g., `for<'a> fn(&a)`).\n-\n-### High-level summary\n-\n-Both the LUB and the GLB algorithms work in a similar fashion.  They\n-begin by replacing all bound regions (on both sides) with fresh region\n-inference variables.  Therefore, both functions are converted to types\n-that contain only free regions.  We can then compute the LUB/GLB in a\n-straightforward way, as described in `combine.rs`.  This results in an\n-interim type T.  The algorithms then examine the regions that appear\n-in T and try to, in some cases, replace them with bound regions to\n-yield the final result.\n-\n-To decide whether to replace a region `R` that appears in `T` with\n-a bound region, the algorithms make use of two bits of\n-information.  First is a set `V` that contains all region\n-variables created as part of the LUB/GLB computation (roughly; see\n-`region_vars_confined_to_snapshot()` for full details). `V` will\n-contain the region variables created to replace the bound regions\n-in the input types, but it also contains 'intermediate' variables\n-created to represent the LUB/GLB of individual regions.\n-Basically, when asked to compute the LUB/GLB of a region variable\n-with another region, the inferencer cannot oblige immediately\n-since the values of that variables are not known.  Therefore, it\n-creates a new variable that is related to the two regions.  For\n-example, the LUB of two variables `$x` and `$y` is a fresh\n-variable `$z` that is constrained such that `$x <= $z` and `$y <=\n-$z`.  So `V` will contain these intermediate variables as well.\n-\n-The other important factor in deciding how to replace a region in T is\n-the function `Tainted($r)` which, for a region variable, identifies\n-all regions that the region variable is related to in some way\n-(`Tainted()` made an appearance in the subtype computation as well).\n-\n-### LUB\n-\n-The LUB algorithm proceeds in three steps:\n-\n-1. Replace all bound regions (on both sides) with fresh region\n-   inference variables.\n-2. Compute the LUB \"as normal\", meaning compute the GLB of each\n-   pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type `F`.\n-3. Replace each region `R` that appears in `F` as follows:\n-   - Let `V` be the set of variables created during the LUB\n-     computational steps 1 and 2, as described in the previous section.\n-   - If `R` is not in `V`, replace `R` with itself.\n-   - If `Tainted(R)` contains a region that is not in `V`,\n-     replace `R` with itself.\n-   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n-     from the left-hand side and replace `R` with the bound region that\n-     this variable was a replacement for.\n-\n-So, let's work through the simplest example: `fn(&A)` and `for<'a> fn(&a)`.\n-In this case, `&a` will be replaced with `$a` and the interim LUB type\n-`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n-{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n-`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n-we leave `$b` as is.  When region inference happens, `$b` will be\n-resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n-this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n-&h)` and a graph that looks like:\n-\n-```\n-     $a        $b     *--$x\n-       \\        \\    /  /\n-        \\        $h-*  /\n-         $g-----------*\n-```\n-\n-Here `$g` and `$h` are fresh variables that are created to represent\n-the LUB/GLB of things requiring inference.  This means that `V` and\n-`Tainted` will look like:\n-\n-```\n-V = {$a, $b, $g, $h, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n-```\n-\n-Therefore we replace both `$g` and `$h` with `$a`, and end up\n-with the type `fn(&a, &a)`.\n-\n-### GLB\n-\n-The procedure for computing the GLB is similar.  The difference lies\n-in computing the replacements for the various variables. For each\n-region `R` that appears in the type `F`, we again compute `Tainted(R)`\n-and examine the results:\n-\n-1. If `R` is not in `V`, it is not replaced.\n-2. Else, if `Tainted(R)` contains only variables in `V`, and it\n-   contains exactly one variable from the LHS and one variable from\n-   the RHS, then `R` can be mapped to the bound version of the\n-   variable from the LHS.\n-3. Else, if `Tainted(R)` contains no variable from the LHS and no\n-   variable from the RHS, then `R` can be mapped to itself.\n-4. Else, `R` is mapped to a fresh bound variable.\n-\n-These rules are pretty complex.  Let's look at some examples to see\n-how they play out.\n-\n-Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n-be replaced with `$a` and we will ultimately compute a\n-(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n-Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n-replacement for `$g` we consult the rules above:\n-- Rule (1) does not apply because `$g \\in V`\n-- Rule (2) does not apply because `&X \\in Tainted($g)`\n-- Rule (3) does not apply because `$a \\in Tainted($g)`\n-- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n-So our final result is `fn(&z)`, which is correct.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n-have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n-Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n-by rule (3), `$g` is mapped to itself, and hence the result is\n-`fn($g)`.  This result is correct (in this case, at least), but it is\n-indicative of a case that *can* lead us into concluding that there is\n-no GLB when in fact a GLB does exist.  See the section \"Questionable\n-Results\" below for more details.\n-\n-The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n-before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n-Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n-we'll select fresh bound variables `y` and `z` and wind up with\n-`fn(&y, &z)`.\n-\n-For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n-$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n-$x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n-is the desired result.\n-\n-### Shortcomings and correctness\n-\n-You may be wondering whether this algorithm is correct.  The answer is\n-\"sort of\".  There are definitely cases where they fail to compute a\n-result even though a correct result exists.  I believe, though, that\n-if they succeed, then the result is valid, and I will attempt to\n-convince you.  The basic argument is that the \"pre-replacement\" step\n-computes a set of constraints.  The replacements, then, attempt to\n-satisfy those constraints, using bound identifiers where needed.\n-\n-For now I will briefly go over the cases for LUB/GLB and identify\n-their intent:\n-\n-- LUB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains only values in V, then this region is unconstrained\n-    and can therefore be generalized, otherwise it cannot.\n-- GLB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains exactly one variable from each side, and\n-    only variables in V, that indicates that those two bound regions\n-    must be equated.\n-  - Otherwise, if Tainted(R) references any variables from left or right\n-    side, then it is trying to combine a bound region with a free one or\n-    multiple bound regions, so we need to select fresh bound regions.\n-\n-Sorry this is more of a shorthand to myself.  I will try to write up something\n-more convincing in the future.\n-\n-#### Where are the algorithms wrong?\n-\n-- The pre-replacement computation can fail even though using a\n-  bound-region would have succeeded.\n-- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n-  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n-  to regions without a GLB, then this is effectively a failure to compute\n-  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+[oldhrtb]: https://rust-lang.github.io/rustc-guide/traits/hrtb.html\n+[newhrtb]: https://rust-lang.github.io/rustc-guide/borrow_check/region_inference.html#placeholders-and-universes"}, {"sha": "4b5e08cecd99c0719783fd538fe5e8044c293b3f", "filename": "src/librustc/ty/query/README.md", "status": "modified", "additions": 2, "deletions": 301, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2FREADME.md?ref=dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "patch": "@@ -1,302 +1,3 @@\n-# The Rust Compiler Query System\n-\n-The Compiler Query System is the key to our new demand-driven\n-organization.  The idea is pretty simple. You have various queries\n-that compute things about the input -- for example, there is a query\n-called `type_of(def_id)` that, given the def-id of some item, will\n-compute the type of that item and return it to you.\n-\n-Query execution is **memoized** -- so the first time you invoke a\n-query, it will go do the computation, but the next time, the result is\n-returned from a hashtable. Moreover, query execution fits nicely into\n-**incremental computation**; the idea is roughly that, when you do a\n-query, the result **may** be returned to you by loading stored data\n-from disk (but that's a separate topic we won't discuss further here).\n-\n-The overall vision is that, eventually, the entire compiler\n-control-flow will be query driven. There will effectively be one\n-top-level query (\"compile\") that will run compilation on a crate; this\n-will in turn demand information about that crate, starting from the\n-*end*.  For example:\n-\n-- This \"compile\" query might demand to get a list of codegen-units\n-  (i.e., modules that need to be compiled by LLVM).\n-- But computing the list of codegen-units would invoke some subquery\n-  that returns the list of all modules defined in the Rust source.\n-- That query in turn would invoke something asking for the HIR.\n-- This keeps going further and further back until we wind up doing the\n-  actual parsing.\n-\n-However, that vision is not fully realized. Still, big chunks of the\n-compiler (for example, generating MIR) work exactly like this.\n-\n-### Invoking queries\n-\n-To invoke a query is simple. The tcx (\"type context\") offers a method\n-for each defined query. So, for example, to invoke the `type_of`\n-query, you would just do this:\n-\n-```rust\n-let ty = tcx.type_of(some_def_id);\n-```\n-\n-### Cycles between queries\n-\n-Currently, cycles during query execution should always result in a\n-compilation error. Typically, they arise because of illegal programs\n-that contain cyclic references they shouldn't (though sometimes they\n-arise because of compiler bugs, in which case we need to factor our\n-queries in a more fine-grained fashion to avoid them).\n-\n-However, it is nonetheless often useful to *recover* from a cycle\n-(after reporting an error, say) and try to soldier on, so as to give a\n-better user experience. In order to recover from a cycle, you don't\n-get to use the nice method-call-style syntax. Instead, you invoke\n-using the `try_get` method, which looks roughly like this:\n-\n-```rust\n-use ty::query::queries;\n-...\n-match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {\n-  Ok(result) => {\n-    // no cycle occurred! You can use `result`\n-  }\n-  Err(err) => {\n-    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,\n-    // meaning essentially an \"in-progress\", not-yet-reported error message.\n-    // See below for more details on what to do here.\n-  }\n-}\n-```\n-\n-So, if you get back an `Err` from `try_get`, then a cycle *did* occur. This means that\n-you must ensure that a compiler error message is reported. You can do that in two ways:\n-\n-The simplest is to invoke `err.emit()`. This will emit the cycle error to the user.\n-\n-However, often cycles happen because of an illegal program, and you\n-know at that point that an error either already has been reported or\n-will be reported due to this cycle by some other bit of code. In that\n-case, you can invoke `err.cancel()` to not emit any error. It is\n-traditional to then invoke:\n-\n-```\n-tcx.sess.delay_span_bug(some_span, \"some message\")\n-```\n-\n-`delay_span_bug()` is a helper that says: we expect a compilation\n-error to have happened or to happen in the future; so, if compilation\n-ultimately succeeds, make an ICE with the message `\"some\n-message\"`. This is basically just a precaution in case you are wrong.\n-\n-### How the compiler executes a query\n-\n-So you may be wondering what happens when you invoke a query\n-method. The answer is that, for each query, the compiler maintains a\n-cache -- if your query has already been executed, then, the answer is\n-simple: we clone the return value out of the cache and return it\n-(therefore, you should try to ensure that the return types of queries\n-are cheaply cloneable; insert a `Rc` if necessary).\n-\n-#### Providers\n-\n-If, however, the query is *not* in the cache, then the compiler will\n-try to find a suitable **provider**. A provider is a function that has\n-been defined and linked into the compiler somewhere that contains the\n-code to compute the result of the query.\n-\n-**Providers are defined per-crate.** The compiler maintains,\n-internally, a table of providers for every crate, at least\n-conceptually. Right now, there are really two sets: the providers for\n-queries about the **local crate** (that is, the one being compiled)\n-and providers for queries about **external crates** (that is,\n-dependencies of the local crate). Note that what determines the crate\n-that a query is targeting is not the *kind* of query, but the *key*.\n-For example, when you invoke `tcx.type_of(def_id)`, that could be a\n-local query or an external query, depending on what crate the `def_id`\n-is referring to (see the `self::keys::Key` trait for more information\n-on how that works).\n-\n-Providers always have the same signature:\n-\n-```rust\n-fn provider<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-                       key: QUERY_KEY)\n-                       -> QUERY_RESULT\n-{\n-    ...\n-}\n-```\n-\n-Providers take two arguments: the `tcx` and the query key. Note also\n-that they take the *global* tcx (i.e., they use the `'tcx` lifetime\n-twice), rather than taking a tcx with some active inference context.\n-They return the result of the query.\n-\n-####  How providers are setup\n-\n-When the tcx is created, it is given the providers by its creator using\n-the `Providers` struct. This struct is generate by the macros here, but it\n-is basically a big list of function pointers:\n-\n-```rust\n-struct Providers {\n-    type_of: for<'cx, 'tcx> fn(TyCtxt<'cx, 'tcx, 'tcx>, DefId) -> Ty<'tcx>,\n-    ...\n-}\n-```\n-\n-At present, we have one copy of the struct for local crates, and one\n-for external crates, though the plan is that we may eventually have\n-one per crate.\n-\n-These `Provider` structs are ultimately created and populated by\n-`librustc_driver`, but it does this by distributing the work\n-throughout the other `rustc_*` crates. This is done by invoking\n-various `provide` functions. These functions tend to look something\n-like this:\n-\n-```rust\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        type_of,\n-        ..*providers\n-    };\n-}\n-```\n-\n-That is, they take an `&mut Providers` and mutate it in place. Usually\n-we use the formulation above just because it looks nice, but you could\n-as well do `providers.type_of = type_of`, which would be equivalent.\n-(Here, `type_of` would be a top-level function, defined as we saw\n-before.) So, if we want to add a provider for some other query,\n-let's call it `fubar`, into the crate above, we might modify the `provide()`\n-function like so:\n-\n-```rust\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        type_of,\n-        fubar,\n-        ..*providers\n-    };\n-}\n-\n-fn fubar<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>, key: DefId) -> Fubar<'tcx> { .. }\n-```\n-\n-NB. Most of the `rustc_*` crates only provide **local\n-providers**. Almost all **extern providers** wind up going through the\n-`rustc_metadata` crate, which loads the information from the crate\n-metadata.  But in some cases there are crates that provide queries for\n-*both* local and external crates, in which case they define both a\n-`provide` and a `provide_extern` function that `rustc_driver` can\n-invoke.\n-\n-### Adding a new kind of query\n-\n-So suppose you want to add a new kind of query, how do you do so?\n-Well, defining a query takes place in two steps:\n-\n-1. first, you have to specify the query name and arguments; and then,\n-2. you have to supply query providers where needed.\n-\n-To specify the query name and arguments, you simply add an entry\n-to the big macro invocation in `mod.rs`. This will probably have changed\n-by the time you read this README, but at present it looks something\n-like:\n-\n-```\n-define_queries! { <'tcx>\n-    /// Records the type of every item.\n-    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-\n-    ...\n-}\n-```\n-\n-Each line of the macro defines one query. The name is broken up like this:\n-\n-```\n-[] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^\n-|     |        |          |         |\n-|     |        |          |         result type of query\n-|     |        |          query key type\n-|     |        dep-node constructor\n-|     name of query\n-query flags\n-```\n-\n-Let's go over them one by one:\n-\n-- **Query flags:** these are largely unused right now, but the intention\n-  is that we'll be able to customize various aspects of how the query is\n-  processed.\n-- **Name of query:** the name of the query method\n-  (`tcx.type_of(..)`). Also used as the name of a struct\n-  (`ty::query::queries::type_of`) that will be generated to represent\n-  this query.\n-- **Dep-node constructor:** indicates the constructor function that\n-  connects this query to incremental compilation. Typically, this is a\n-  `DepNode` variant, which can be added by modifying the\n-  `define_dep_nodes!` macro invocation in\n-  `librustc/dep_graph/dep_node.rs`.\n-  - However, sometimes we use a custom function, in which case the\n-    name will be in snake case and the function will be defined at the\n-    bottom of the file. This is typically used when the query key is\n-    not a def-id, or just not the type that the dep-node expects.\n-- **Query key type:** the type of the argument to this query.\n-  This type must implement the `ty::query::keys::Key` trait, which\n-  defines (for example) how to map it to a crate, and so forth.\n-- **Result type of query:** the type produced by this query. This type\n-  should (a) not use `RefCell` or other interior mutability and (b) be\n-  cheaply cloneable. Interning or using `Rc` or `Arc` is recommended for\n-  non-trivial data types.\n-  - The one exception to those rules is the `ty::steal::Steal` type,\n-    which is used to cheaply modify MIR in place. See the definition\n-    of `Steal` for more details. New uses of `Steal` should **not** be\n-    added without alerting `@rust-lang/compiler`.\n-\n-So, to add a query:\n-\n-- Add an entry to `define_queries!` using the format above.\n-- Possibly add a corresponding entry to the dep-node macro.\n-- Link the provider by modifying the appropriate `provide` method;\n-  or add a new one if needed and ensure that `rustc_driver` is invoking it.\n-\n-#### Query structs and descriptions\n-\n-For each kind, the `define_queries` macro will generate a \"query struct\"\n-named after the query. This struct is a kind of a place-holder\n-describing the query. Each such struct implements the\n-`self::config::QueryConfig` trait, which has associated types for the\n-key/value of that particular query. Basically the code generated looks something\n-like this:\n-\n-```rust\n-// Dummy struct representing a particular kind of query:\n-pub struct type_of<'tcx> { phantom: PhantomData<&'tcx ()> }\n-\n-impl<'tcx> QueryConfig for type_of<'tcx> {\n-  type Key = DefId;\n-  type Value = Ty<'tcx>;\n-}\n-```\n-\n-There is an additional trait that you may wish to implement called\n-`self::config::QueryDescription`. This trait is used during cycle\n-errors to give a \"human readable\" name for the query, so that we can\n-summarize what was happening when the cycle occurred. Implementing\n-this trait is optional if the query key is `DefId`, but if you *don't*\n-implement it, you get a pretty generic error (\"processing `foo`...\").\n-You can put new impls into the `config` module. They look something like this:\n-\n-```rust\n-impl<'tcx> QueryDescription for queries::type_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: DefId) -> String {\n-        format!(\"computing the type of `{}`\", tcx.item_path_str(key))\n-    }\n-}\n-```\n+For more information about how the query system works, see the [rustc guide].\n \n+[rustc guide]: https://rust-lang.github.io/rustc-guide/query.html"}]}