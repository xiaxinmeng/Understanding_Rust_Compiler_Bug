{"sha": "36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZDEzY2IwMWJhNmEwYTliN2MxM2NhMmI5NDYxYTExMWNiM2UzOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-29T13:59:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-29T13:59:22Z"}, "message": "Auto merge of #67343 - ecstatic-morse:qualif-structural-match, r=pnkfelix\n\nConst qualification for `StructuralEq`\n\nFurthers #62411. Resolves #62614.\n\nThe goal of this PR is to implement the logic in #67088 on the MIR instead of the HIR. It uses the `Qualif` trait to track `StructuralPartialEq`/`StructuralEq` in the final value of a `const`. Then, if we encounter a constant during HAIR lowering whose value may not be structurally matchable, we emit the `indirect_structural_match` lint.\n\nThis PR contains all the tests present in #67088 and emits the proper warnings for the corner cases. This PR does not handle #65466, which would require that we be [more aggressive](https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src/librustc_mir_build/hair/pattern/const_to_pat.rs#L126-L130) when checking matched types for `PartialEq`. I think that should be done separately.\n\nBecause this works on MIR and uses dataflow, this PR should accept more cases than #67088. Notably, the qualifs in the final value of a const are encoded cross-crate, so matching on a constant whose value is defined in another crate to be `Option::<TyWithCustomEqImpl>::None` should work. Additionally, if a `const` has branching/looping, we will only emit the warning if any possible control flow path could result in a type with a custom `PartialEq` impl ending up as the final value of a `const`. I'm not sure how #67088 handled this.\n\nAFAIK, it's not settled that these are the semantics we actually want: it's just how the `Qualif` framework happens to work. If the cross-crate part is undesirable, it would be quite easy to change the result of `mir_const_qualif().custom_eq` to `true` before encoding it in the crate metadata. This way, other crates would have to assume that all publicly exported constants may not be safe for matching.\n\nr? @pnkfelix\ncc @eddyb", "tree": {"sha": "c575e226d1ccd83b833151e1dd3cd8e5e18d3d43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c575e226d1ccd83b833151e1dd3cd8e5e18d3d43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "html_url": "https://github.com/rust-lang/rust/commit/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e91aebc1a3835b9b420da0c021e211175a724b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e91aebc1a3835b9b420da0c021e211175a724b8d", "html_url": "https://github.com/rust-lang/rust/commit/e91aebc1a3835b9b420da0c021e211175a724b8d"}, {"sha": "e4c650c00dfdf2581c54688a6ff98ebe006c80b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c650c00dfdf2581c54688a6ff98ebe006c80b1", "html_url": "https://github.com/rust-lang/rust/commit/e4c650c00dfdf2581c54688a6ff98ebe006c80b1"}], "stats": {"total": 906, "additions": 819, "deletions": 87}, "files": [{"sha": "95a28df99aad0a2b53d4a1ff2476ef833caa7352", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -80,6 +80,7 @@ pub struct BorrowCheckResult<'tcx> {\n pub struct ConstQualifs {\n     pub has_mut_interior: bool,\n     pub needs_drop: bool,\n+    pub custom_eq: bool,\n }\n \n /// After we borrow check a closure, we are left with various"}, {"sha": "fc6860b40e8d27528c433313fda4f16e4a7d7294", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -2,16 +2,19 @@\n //!\n //! See the `Qualif` trait for more info.\n \n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, AdtDef, Ty};\n+use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n+use rustc_trait_selection::traits;\n \n use super::ConstCx;\n \n pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs {\n     ConstQualifs {\n         has_mut_interior: HasMutInterior::in_any_value_of_ty(cx, ty),\n         needs_drop: NeedsDrop::in_any_value_of_ty(cx, ty),\n+        custom_eq: CustomEq::in_any_value_of_ty(cx, ty),\n     }\n }\n \n@@ -53,7 +56,11 @@ pub trait Qualif {\n     /// with a custom `Drop` impl is inherently `NeedsDrop`.\n     ///\n     /// Returning `true` for `in_adt_inherently` but `false` for `in_any_value_of_ty` is unsound.\n-    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool;\n+    fn in_adt_inherently(\n+        cx: &ConstCx<'_, 'tcx>,\n+        adt: &'tcx AdtDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> bool;\n }\n \n /// Constant containing interior mutability (`UnsafeCell<T>`).\n@@ -74,7 +81,7 @@ impl Qualif for HasMutInterior {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n     }\n \n-    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool {\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &'tcx AdtDef, _: SubstsRef<'tcx>) -> bool {\n         // Exactly one type, `UnsafeCell`, has the `HasMutInterior` qualif inherently.\n         // It arises structurally for all other types.\n         Some(adt.did) == cx.tcx.lang_items().unsafe_cell_type()\n@@ -99,11 +106,44 @@ impl Qualif for NeedsDrop {\n         ty.needs_drop(cx.tcx, cx.param_env)\n     }\n \n-    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool {\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &'tcx AdtDef, _: SubstsRef<'tcx>) -> bool {\n         adt.has_dtor(cx.tcx)\n     }\n }\n \n+/// A constant that cannot be used as part of a pattern in a `match` expression.\n+pub struct CustomEq;\n+\n+impl Qualif for CustomEq {\n+    const ANALYSIS_NAME: &'static str = \"flow_custom_eq\";\n+\n+    fn in_qualifs(qualifs: &ConstQualifs) -> bool {\n+        qualifs.custom_eq\n+    }\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        // If *any* component of a composite data type does not implement `Structural{Partial,}Eq`,\n+        // we know that at least some values of that type are not structural-match. I say \"some\"\n+        // because that component may be part of an enum variant (e.g.,\n+        // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n+        // structural-match (`Option::None`).\n+        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id.as_local().unwrap());\n+        traits::search_for_structural_match_violation(id, cx.body.span, cx.tcx, ty).is_some()\n+    }\n+\n+    fn in_adt_inherently(\n+        cx: &ConstCx<'_, 'tcx>,\n+        adt: &'tcx AdtDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> bool {\n+        let ty = cx.tcx.mk_ty(ty::Adt(adt, substs));\n+        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id.as_local().unwrap());\n+        cx.tcx\n+            .infer_ctxt()\n+            .enter(|infcx| !traits::type_marked_structural(id, cx.body.span, &infcx, ty))\n+    }\n+}\n+\n // FIXME: Use `mir::visit::Visitor` for the `in_*` functions if/when it supports early return.\n \n /// Returns `true` if this `Rvalue` contains qualif `Q`.\n@@ -147,8 +187,8 @@ where\n         Rvalue::Aggregate(kind, operands) => {\n             // Return early if we know that the struct or enum being constructed is always\n             // qualified.\n-            if let AggregateKind::Adt(def, ..) = **kind {\n-                if Q::in_adt_inherently(cx, def) {\n+            if let AggregateKind::Adt(def, _, substs, ..) = **kind {\n+                if Q::in_adt_inherently(cx, def, substs) {\n                     return true;\n                 }\n             }"}, {"sha": "c5938426f61a93cccc16e7ceb9a42b853d3c38bb", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -17,7 +17,7 @@ use std::borrow::Cow;\n use std::ops::Deref;\n \n use super::ops::{self, NonConstOp};\n-use super::qualifs::{self, HasMutInterior, NeedsDrop};\n+use super::qualifs::{self, CustomEq, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstCx, ConstKind, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n@@ -142,9 +142,35 @@ impl Qualifs<'mir, 'tcx> {\n \n         let return_loc = ccx.body.terminator_loc(return_block);\n \n+        let custom_eq = match ccx.const_kind() {\n+            // We don't care whether a `const fn` returns a value that is not structurally\n+            // matchable. Functions calls are opaque and always use type-based qualification, so\n+            // this value should never be used.\n+            ConstKind::ConstFn => true,\n+\n+            // If we know that all values of the return type are structurally matchable, there's no\n+            // need to run dataflow.\n+            ConstKind::Const | ConstKind::Static | ConstKind::StaticMut\n+                if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) =>\n+            {\n+                false\n+            }\n+\n+            ConstKind::Const | ConstKind::Static | ConstKind::StaticMut => {\n+                let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n+                    .into_engine(ccx.tcx, &ccx.body, ccx.def_id)\n+                    .iterate_to_fixpoint()\n+                    .into_results_cursor(&ccx.body);\n+\n+                cursor.seek_after(return_loc);\n+                cursor.contains(RETURN_PLACE)\n+            }\n+        };\n+\n         ConstQualifs {\n             needs_drop: self.needs_drop(ccx, RETURN_PLACE, return_loc),\n             has_mut_interior: self.has_mut_interior(ccx, RETURN_PLACE, return_loc),\n+            custom_eq,\n         }\n     }\n }"}, {"sha": "ad87afc3e0301b659a1e09176df7cee0456c15d1", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -22,13 +22,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n+        mir_structural_match_violation: bool,\n     ) -> Pat<'tcx> {\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n \n         self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n-            convert.to_pat(cv)\n+            convert.to_pat(cv, mir_structural_match_violation)\n         })\n     }\n }\n@@ -81,7 +82,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         traits::type_marked_structural(self.id, self.span, &self.infcx, ty)\n     }\n \n-    fn to_pat(&mut self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n+    fn to_pat(\n+        &mut self,\n+        cv: &'tcx ty::Const<'tcx>,\n+        mir_structural_match_violation: bool,\n+    ) -> Pat<'tcx> {\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n         // invoked except by this method.\n@@ -100,6 +105,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 \"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n                 cv.ty, structural\n             );\n+\n+            if structural.is_none() && mir_structural_match_violation {\n+                bug!(\"MIR const-checker found novel structural match violation\");\n+            }\n+\n             if let Some(non_sm_ty) = structural {\n                 let adt_def = match non_sm_ty {\n                     traits::NonStructuralMatchTy::Adt(adt_def) => adt_def,\n@@ -146,13 +156,18 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 if !ty_is_partial_eq {\n                     // span_fatal avoids ICE from resolution of non-existent method (rare case).\n                     self.tcx().sess.span_fatal(self.span, &make_msg());\n-                } else {\n+                } else if mir_structural_match_violation {\n                     self.tcx().struct_span_lint_hir(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n                         |lint| lint.build(&make_msg()).emit(),\n                     );\n+                } else {\n+                    debug!(\n+                        \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n+                          not in the qualifs for that `const`\"\n+                    );\n                 }\n             }\n         }"}, {"sha": "bd75f11fb8f9465d4516964057e84fc74de0560e", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 71, "deletions": 60, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::interpret::{get_slice_bytes, sign_extend, ConstValue, ErrorHandled};\n+use rustc_middle::mir::interpret::{get_slice_bytes, sign_extend, ConstValue};\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n@@ -762,69 +762,80 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n         let ty = self.tables.node_type(id);\n         let res = self.tables.qpath_res(qpath, id);\n-        let is_associated_const = match res {\n-            Res::Def(DefKind::AssocConst, _) => true,\n-            _ => false,\n+\n+        let pat_from_kind = |kind| Pat { span, ty, kind: Box::new(kind) };\n+\n+        let (def_id, is_associated_const) = match res {\n+            Res::Def(DefKind::Const, def_id) => (def_id, false),\n+            Res::Def(DefKind::AssocConst, def_id) => (def_id, true),\n+\n+            _ => return pat_from_kind(self.lower_variant_or_leaf(res, id, span, ty, vec![])),\n         };\n-        let kind = match res {\n-            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n-                let substs = self.tables.node_substs(id);\n-                // Use `Reveal::All` here because patterns are always monomorphic even if their function isn't.\n-                match self.tcx.const_eval_resolve(\n-                    self.param_env.with_reveal_all(),\n-                    def_id,\n-                    substs,\n-                    None,\n-                    Some(span),\n-                ) {\n-                    Ok(value) => {\n-                        let const_ =\n-                            ty::Const::from_value(self.tcx, value, self.tables.node_type(id));\n-\n-                        let pattern = self.const_to_pat(&const_, id, span);\n-                        if !is_associated_const {\n-                            return pattern;\n-                        }\n \n-                        let user_provided_types = self.tables().user_provided_types();\n-                        return if let Some(u_ty) = user_provided_types.get(id) {\n-                            let user_ty = PatTyProj::from_user_type(*u_ty);\n-                            Pat {\n-                                span,\n-                                kind: Box::new(PatKind::AscribeUserType {\n-                                    subpattern: pattern,\n-                                    ascription: Ascription {\n-                                        /// Note that use `Contravariant` here. See the\n-                                        /// `variance` field documentation for details.\n-                                        variance: ty::Variance::Contravariant,\n-                                        user_ty,\n-                                        user_ty_span: span,\n-                                    },\n-                                }),\n-                                ty: const_.ty,\n-                            }\n-                        } else {\n-                            pattern\n-                        };\n-                    }\n-                    Err(ErrorHandled::TooGeneric) => {\n-                        self.errors.push(if is_associated_const {\n-                            PatternError::AssocConstInPattern(span)\n-                        } else {\n-                            PatternError::StaticInPattern(span)\n-                        });\n-                        PatKind::Wild\n-                    }\n-                    Err(_) => {\n-                        self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n-                        PatKind::Wild\n-                    }\n-                }\n+        // Use `Reveal::All` here because patterns are always monomorphic even if their function\n+        // isn't.\n+        let param_env_reveal_all = self.param_env.with_reveal_all();\n+        let substs = self.tables.node_substs(id);\n+        let instance = match ty::Instance::resolve(self.tcx, param_env_reveal_all, def_id, substs) {\n+            Ok(Some(i)) => i,\n+            Ok(None) => {\n+                self.errors.push(if is_associated_const {\n+                    PatternError::AssocConstInPattern(span)\n+                } else {\n+                    PatternError::StaticInPattern(span)\n+                });\n+\n+                return pat_from_kind(PatKind::Wild);\n+            }\n+\n+            Err(_) => {\n+                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                return pat_from_kind(PatKind::Wild);\n             }\n-            _ => self.lower_variant_or_leaf(res, id, span, ty, vec![]),\n         };\n \n-        Pat { span, ty, kind: Box::new(kind) }\n+        // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n+        // defined, not where it is declared. The difference is significant for associated\n+        // constants.\n+        let mir_structural_match_violation = self.tcx.mir_const_qualif(instance.def_id()).custom_eq;\n+        debug!(\"mir_structural_match_violation({:?}) -> {}\", qpath, mir_structural_match_violation);\n+\n+        match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n+            Ok(value) => {\n+                let const_ = ty::Const::from_value(self.tcx, value, self.tables.node_type(id));\n+\n+                let pattern = self.const_to_pat(&const_, id, span, mir_structural_match_violation);\n+\n+                if !is_associated_const {\n+                    return pattern;\n+                }\n+\n+                let user_provided_types = self.tables().user_provided_types();\n+                if let Some(u_ty) = user_provided_types.get(id) {\n+                    let user_ty = PatTyProj::from_user_type(*u_ty);\n+                    Pat {\n+                        span,\n+                        kind: Box::new(PatKind::AscribeUserType {\n+                            subpattern: pattern,\n+                            ascription: Ascription {\n+                                /// Note that use `Contravariant` here. See the\n+                                /// `variance` field documentation for details.\n+                                variance: ty::Variance::Contravariant,\n+                                user_ty,\n+                                user_ty_span: span,\n+                            },\n+                        }),\n+                        ty: const_.ty,\n+                    }\n+                } else {\n+                    pattern\n+                }\n+            }\n+            Err(_) => {\n+                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                pat_from_kind(PatKind::Wild)\n+            }\n+        }\n     }\n \n     /// Converts literals, paths and negation of literals to patterns.\n@@ -849,7 +860,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n             let lit_input = LitToConstInput { lit: &lit.node, ty: self.tables.expr_ty(expr), neg };\n             match self.tcx.at(expr.span).lit_to_const(lit_input) {\n-                Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span).kind,\n+                Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n                 Err(LitToConstError::UnparseableFloat) => {\n                     self.errors.push(PatternError::FloatBug);\n                     PatKind::Wild"}, {"sha": "5093fe5391547d3650b952348a2537a426a51a83", "filename": "src/test/ui/consts/const_in_pattern/accept_structural.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Faccept_structural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Faccept_structural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Faccept_structural.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,66 @@\n+// run-pass\n+\n+#![warn(indirect_structural_match)]\n+\n+// This test is checking our logic for structural match checking by enumerating\n+// the different kinds of const expressions. This test is collecting cases where\n+// we have accepted the const expression as a pattern in the past and wish to\n+// continue doing so.\n+//\n+// Even if a non-structural-match type is part of an expression in a const's\n+// definition, that does not necessarily disqualify the const from being a match\n+// pattern: in principle, we just need the types involved in the final value to\n+// be structurally matchable.\n+\n+// See also RFC 1445\n+\n+#![feature(type_ascription)]\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoPartialEq(u32);\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoDerive(u32);\n+\n+// This impl makes `NoDerive` irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+impl Eq for NoDerive { }\n+\n+type OND = Option<NoDerive>;\n+\n+fn main() {\n+    const FIELD1: u32 = NoPartialEq(1).0;\n+    match 1 { FIELD1 => dbg!(FIELD1), _ => panic!(\"whoops\"), };\n+    const FIELD2: u32 = NoDerive(1).0;\n+    match 1 { FIELD2 => dbg!(FIELD2), _ => panic!(\"whoops\"), };\n+\n+    enum CLike { One = 1, #[allow(dead_code)] Two = 2, }\n+    const ONE_CAST: u32 = CLike::One as u32;\n+    match 1 { ONE_CAST => dbg!(ONE_CAST), _ => panic!(\"whoops\"), };\n+\n+    const NO_DERIVE_NONE: OND = None;\n+    const INDIRECT: OND = NO_DERIVE_NONE;\n+    match None { INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+\n+    const TUPLE: (OND, OND) = (None, None);\n+    match (None, None) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+\n+    const TYPE_ASCRIPTION: OND = None: OND;\n+    match None { TYPE_ASCRIPTION => dbg!(TYPE_ASCRIPTION), _ => panic!(\"whoops\"), };\n+\n+    const ARRAY: [OND; 2] = [None, None];\n+    match [None; 2] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+\n+    const REPEAT: [OND; 2] = [None; 2];\n+    match [None, None] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+\n+    trait Trait: Sized { const ASSOC: Option<Self>; }\n+    impl Trait for NoDerive { const ASSOC: Option<NoDerive> = None; }\n+    match None { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+\n+    const BLOCK: OND = { NoDerive(10); None };\n+    match None { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+\n+    const ADDR_OF: &OND = &None;\n+    match &None { ADDR_OF => dbg!(ADDR_OF),  _ => panic!(\"whoops\"), };\n+}"}, {"sha": "303c2f12bbce9d9327ed0d99787b4b561fc65f0d", "filename": "src/test/ui/consts/const_in_pattern/auxiliary/consts.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fauxiliary%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fauxiliary%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fauxiliary%2Fconsts.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,11 @@\n+pub struct CustomEq;\n+\n+impl Eq for CustomEq {}\n+impl PartialEq for CustomEq {\n+    fn eq(&self, _: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+pub const NONE: Option<CustomEq> = None;\n+pub const SOME: Option<CustomEq> = Some(CustomEq);"}, {"sha": "c9e6050fdc508d66b6a9adcd9eddfcb835764e28", "filename": "src/test/ui/consts/const_in_pattern/cross-crate-fail.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,15 @@\n+// aux-build:consts.rs\n+\n+#![warn(indirect_structural_match)]\n+\n+extern crate consts;\n+\n+fn main() {\n+    match None {\n+        consts::SOME => panic!(),\n+        //~^ must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+        _ => {}\n+    }\n+}"}, {"sha": "c97298f66e6772d6ca03016fafe7598013cbd8b4", "filename": "src/test/ui/consts/const_in_pattern/cross-crate-fail.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,14 @@\n+error: to use a constant of type `consts::CustomEq` in a pattern, `consts::CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cross-crate-fail.rs:9:9\n+   |\n+LL |         consts::SOME => panic!(),\n+   |         ^^^^^^^^^^^^\n+\n+error: to use a constant of type `consts::CustomEq` in a pattern, `consts::CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cross-crate-fail.rs:9:9\n+   |\n+LL |         consts::SOME => panic!(),\n+   |         ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ccf655c11cf8afc81618aa3d9f1eb5c9d5fcef13", "filename": "src/test/ui/consts/const_in_pattern/cross-crate-pass.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-pass.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+// aux-build:consts.rs\n+\n+#![warn(indirect_structural_match)]\n+\n+extern crate consts;\n+use consts::CustomEq;\n+\n+fn main() {\n+    match Some(CustomEq) {\n+        consts::NONE => panic!(),\n+        _ => {}\n+    }\n+}"}, {"sha": "81a2024a81b7bc5a07f75db8e17fc0f9e7d4988a", "filename": "src/test/ui/consts/const_in_pattern/custom-eq-branch-pass.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-pass.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,33 @@\n+// run-pass\n+\n+#![feature(const_if_match)]\n+#![warn(indirect_structural_match)]\n+\n+struct CustomEq;\n+\n+impl Eq for CustomEq {}\n+impl PartialEq for CustomEq {\n+    fn eq(&self, _: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum Foo {\n+    Bar,\n+    Baz,\n+    Qux(CustomEq),\n+}\n+\n+const BAR_BAZ: Foo = if 42 == 42 {\n+    Foo::Bar\n+} else {\n+    Foo::Baz\n+};\n+\n+fn main() {\n+    match Foo::Qux(CustomEq) {\n+        BAR_BAZ => panic!(),\n+        _ => {}\n+    }\n+}"}, {"sha": "21c4de6fbb1f1d9f57bbb0393f92e84c0a715f6c", "filename": "src/test/ui/consts/const_in_pattern/custom-eq-branch-warn.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+\n+#![feature(const_if_match)]\n+#![warn(indirect_structural_match)]\n+//~^ NOTE lint level is defined here\n+\n+struct CustomEq;\n+\n+impl Eq for CustomEq {}\n+impl PartialEq for CustomEq {\n+    fn eq(&self, _: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum Foo {\n+    Bar,\n+    Baz,\n+    Qux(CustomEq),\n+}\n+\n+// We know that `BAR_BAZ` will always be `Foo::Bar` and thus eligible for structural matching, but\n+// dataflow will be more conservative.\n+const BAR_BAZ: Foo = if 42 == 42 {\n+    Foo::Bar\n+} else {\n+    Foo::Qux(CustomEq)\n+};\n+\n+fn main() {\n+    match Foo::Qux(CustomEq) {\n+        BAR_BAZ => panic!(),\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN this was previously accepted\n+        //~| NOTE see issue #62411\n+        _ => {}\n+    }\n+}"}, {"sha": "06ec2a7fdd35c963e453cb22baa3f18f4fcb0789", "filename": "src/test/ui/consts/const_in_pattern/custom-eq-branch-warn.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,16 @@\n+warning: to use a constant of type `CustomEq` in a pattern, `CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/custom-eq-branch-warn.rs:33:9\n+   |\n+LL |         BAR_BAZ => panic!(),\n+   |         ^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/custom-eq-branch-warn.rs:4:9\n+   |\n+LL | #![warn(indirect_structural_match)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: 1 warning emitted\n+"}, {"sha": "4ea9a283618ea385cbacee8610916f8b6616e9d7", "filename": "src/test/ui/consts/const_in_pattern/issue-62614.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-62614.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-62614.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-62614.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+struct Sum(u32, u32);\n+\n+impl PartialEq for Sum {\n+    fn eq(&self, other: &Self) -> bool { self.0 + self.1 == other.0 + other.1 }\n+}\n+\n+impl Eq for Sum { }\n+\n+#[derive(PartialEq, Eq)]\n+enum Eek {\n+    TheConst,\n+    UnusedByTheConst(Sum)\n+}\n+\n+const THE_CONST: Eek = Eek::TheConst;\n+\n+pub fn main() {\n+    match Eek::UnusedByTheConst(Sum(1,2)) {\n+        THE_CONST => { panic!(); }\n+        _ => {}\n+    }\n+}"}, {"sha": "0e3e0f6dd88343f6e2bbcc22a64d709c18943287", "filename": "src/test/ui/consts/const_in_pattern/issue-65466.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,23 @@\n+// FIXME: This still ICEs.\n+//\n+// ignore-test\n+\n+#![deny(indirect_structural_match)]\n+\n+#[derive(PartialEq, Eq)]\n+enum O<T> {\n+    Some(*const T), // Can also use PhantomData<T>\n+    None,\n+}\n+\n+struct B;\n+\n+const C: &[O<B>] = &[O::None];\n+\n+fn main() {\n+    let x = O::None;\n+    match &[x][..] {\n+        C => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "9fe3049d1d85f3a6346dc25a90a0f104de7f6784", "filename": "src/test/ui/consts/const_in_pattern/issue-65466.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,15 @@\n+error[E0601]: `main` function not found in crate `issue_65466`\n+  --> $DIR/issue-65466.rs:1:1\n+   |\n+LL | / #![deny(indirect_structural_match)]\n+LL | |\n+LL | | #[derive(PartialEq, Eq)]\n+LL | | enum O<T> {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^ consider adding a `main` function to `$DIR/issue-65466.rs`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "28b3fbb952563fc5168999c067ebfd64eaf3a2e1", "filename": "src/test/ui/consts/const_in_pattern/no-eq-branch-fail.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,27 @@\n+#![feature(const_if_match)]\n+#![warn(indirect_structural_match)]\n+\n+struct NoEq;\n+\n+enum Foo {\n+    Bar,\n+    Baz,\n+    Qux(NoEq),\n+}\n+\n+// Even though any of these values can be compared structurally, we still disallow it in a pattern\n+// because `Foo` does not impl `PartialEq`.\n+const BAR_BAZ: Foo = if 42 == 42 {\n+    Foo::Baz\n+} else {\n+    Foo::Bar\n+};\n+\n+fn main() {\n+    match Foo::Qux(NoEq) {\n+        BAR_BAZ => panic!(),\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => {}\n+    }\n+}"}, {"sha": "cb870ec7dbcf2738013ecd9d8886442811f676df", "filename": "src/test/ui/consts/const_in_pattern/no-eq-branch-fail.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,14 @@\n+error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/no-eq-branch-fail.rs:22:9\n+   |\n+LL |         BAR_BAZ => panic!(),\n+   |         ^^^^^^^\n+\n+error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/no-eq-branch-fail.rs:22:9\n+   |\n+LL |         BAR_BAZ => panic!(),\n+   |         ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a8216901c027f2f057dd416da6961430727c9aae", "filename": "src/test/ui/consts/const_in_pattern/reject_non_partial_eq.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,32 @@\n+// This test is illustrating the difference between how failing to derive\n+// `PartialEq` is handled compared to failing to implement it at all.\n+\n+// See also RFC 1445\n+\n+#[derive(PartialEq, Eq)]\n+struct Structural(u32);\n+\n+struct NoPartialEq(u32);\n+\n+struct NoDerive(u32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+const NO_DERIVE_NONE: Option<NoDerive> = None;\n+const NO_PARTIAL_EQ_NONE: Option<NoPartialEq> = None;\n+\n+fn main() {\n+    match None {\n+        NO_DERIVE_NONE => println!(\"NO_DERIVE_NONE\"),\n+        _ => panic!(\"whoops\"),\n+    }\n+\n+    match None {\n+        NO_PARTIAL_EQ_NONE => println!(\"NO_PARTIAL_EQ_NONE\"),\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => panic!(\"whoops\"),\n+    }\n+}"}, {"sha": "95cfa4a9ebe95a24b6f29a0f4e0998e68d14f747", "filename": "src/test/ui/consts/const_in_pattern/reject_non_partial_eq.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,8 @@\n+error: to use a constant of type `NoPartialEq` in a pattern, `NoPartialEq` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_partial_eq.rs:28:9\n+   |\n+LL |         NO_PARTIAL_EQ_NONE => println!(\"NO_PARTIAL_EQ_NONE\"),\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bbeaeea1f87d8da3a036ee6050fb0aa3bd08d009", "filename": "src/test/ui/consts/const_in_pattern/reject_non_structural.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,93 @@\n+// This test of structural match checking enumerates the different kinds of\n+// const definitions, collecting cases where the const pattern is rejected.\n+//\n+// Note: Even if a non-structural-match type is part of an expression in a\n+// const's definition, that does not necessarily disqualify the const from being\n+// a match pattern: in principle, we just need the types involved in the final\n+// value to be structurally matchable.\n+\n+// See also RFC 1445\n+\n+#![feature(type_ascription)]\n+#![warn(indirect_structural_match)]\n+//~^ NOTE lint level is defined here\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoPartialEq;\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoDerive;\n+\n+// This impl makes `NoDerive` irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+type OND = Option<NoDerive>;\n+\n+struct TrivialEq(OND);\n+\n+// This impl makes `TrivialEq` trivial.\n+impl PartialEq for TrivialEq { fn eq(&self, _: &Self) -> bool { true } }\n+\n+impl Eq for TrivialEq { }\n+\n+fn main() {\n+    #[derive(PartialEq, Eq, Debug)]\n+    enum Derive<X> { Some(X), None, }\n+\n+    const ENUM: Derive<NoDerive> = Derive::Some(NoDerive);\n+    match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const FIELD: OND = TrivialEq(Some(NoDerive)).0;\n+    match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const NO_DERIVE_SOME: OND = Some(NoDerive);\n+    const INDIRECT: OND = NO_DERIVE_SOME;\n+    match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const TUPLE: (OND, OND) = (None, Some(NoDerive));\n+    match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const TYPE_ASCRIPTION: OND = Some(NoDerive): OND;\n+    match Some(NoDerive) { TYPE_ASCRIPTION => dbg!(TYPE_ASCRIPTION), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const ARRAY: [OND; 2] = [None, Some(NoDerive)];\n+    match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const REPEAT: [OND; 2] = [Some(NoDerive); 2];\n+    match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    trait Trait: Sized { const ASSOC: Option<Self>; }\n+    impl Trait for NoDerive { const ASSOC: Option<NoDerive> = Some(NoDerive); }\n+    match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const BLOCK: OND = { NoDerive; Some(NoDerive) };\n+    match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const ADDR_OF: &OND = &Some(NoDerive);\n+    match &Some(NoDerive) { ADDR_OF => dbg!(ADDR_OF), _ => panic!(\"whoops\"), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN previously accepted by the compiler but is being phased out\n+    //~| NOTE for more information, see issue #62411\n+}"}, {"sha": "b1310cf101eaa31d54b9f95fa191140038bbfefe", "filename": "src/test/ui/consts/const_in_pattern/reject_non_structural.stderr", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,136 @@\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:40:36\n+   |\n+LL |     match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:45:28\n+   |\n+LL |     match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:51:27\n+   |\n+LL |     match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+   |                           ^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:56:36\n+   |\n+LL |     match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:61:28\n+   |\n+LL |     match Some(NoDerive) { TYPE_ASCRIPTION => dbg!(TYPE_ASCRIPTION), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:66:36\n+   |\n+LL |     match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:79:28\n+   |\n+LL |     match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:84:28\n+   |\n+LL |     match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:89:29\n+   |\n+LL |     match &Some(NoDerive) { ADDR_OF => dbg!(ADDR_OF), _ => panic!(\"whoops\"), };\n+   |                             ^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reject_non_structural.rs:12:9\n+   |\n+LL | #![warn(indirect_structural_match)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:40:36\n+   |\n+LL |     match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:45:28\n+   |\n+LL |     match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:51:27\n+   |\n+LL |     match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+   |                           ^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:56:36\n+   |\n+LL |     match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:61:28\n+   |\n+LL |     match Some(NoDerive) { TYPE_ASCRIPTION => dbg!(TYPE_ASCRIPTION), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:66:36\n+   |\n+LL |     match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:79:28\n+   |\n+LL |     match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:84:28\n+   |\n+LL |     match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+error: aborting due to 20 previous errors; 1 warning emitted\n+"}, {"sha": "c6b794de195261329749a6ee6c1140577012bab5", "filename": "src/test/ui/consts/const_in_pattern/warn_corner_cases.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+\n+// This test is checking our logic for structural match checking by enumerating\n+// the different kinds of const expressions. This test is collecting cases where\n+// we have accepted the const expression as a pattern in the past but we want\n+// to begin warning the user that a future version of Rust may start rejecting\n+// such const expressions.\n+\n+// The specific corner cases we are exploring here are instances where the\n+// const-evaluator computes a value that *does* meet the conditions for\n+// structural-match, but the const expression itself has abstractions (like\n+// calls to const functions) that may fit better with a type-based analysis\n+// rather than a committment to a specific value.\n+\n+#![warn(indirect_structural_match)]\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoDerive(u32);\n+\n+// This impl makes `NoDerive` irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+impl Eq for NoDerive { }\n+\n+fn main() {\n+    const INDEX: Option<NoDerive> = [None, Some(NoDerive(10))][0];\n+    match None { Some(_) => panic!(\"whoops\"), INDEX => dbg!(INDEX), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN this was previously accepted\n+\n+    const fn build() -> Option<NoDerive> { None }\n+    const CALL: Option<NoDerive> = build();\n+    match None { Some(_) => panic!(\"whoops\"), CALL => dbg!(CALL), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN this was previously accepted\n+\n+    impl NoDerive { const fn none() -> Option<NoDerive> { None } }\n+    const METHOD_CALL: Option<NoDerive> = NoDerive::none();\n+    match None { Some(_) => panic!(\"whoops\"), METHOD_CALL => dbg!(METHOD_CALL), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN this was previously accepted\n+}"}, {"sha": "3e7ed573c74d75e6259e05fd50ac97ee209eda04", "filename": "src/test/ui/consts/const_in_pattern/warn_corner_cases.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -0,0 +1,34 @@\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/warn_corner_cases.rs:26:47\n+   |\n+LL |     match None { Some(_) => panic!(\"whoops\"), INDEX => dbg!(INDEX), };\n+   |                                               ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/warn_corner_cases.rs:15:9\n+   |\n+LL | #![warn(indirect_structural_match)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/warn_corner_cases.rs:32:47\n+   |\n+LL |     match None { Some(_) => panic!(\"whoops\"), CALL => dbg!(CALL), };\n+   |                                               ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/warn_corner_cases.rs:38:47\n+   |\n+LL |     match None { Some(_) => panic!(\"whoops\"), METHOD_CALL => dbg!(METHOD_CALL), };\n+   |                                               ^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "7dfa9c7bcdffebeeed1429c4620af026b1edd172", "filename": "src/test/ui/issues/issue-55511.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -14,8 +14,6 @@ fn main() {\n     //~^ ERROR `a` does not live long enough [E0597]\n     match b {\n         <() as Foo<'static>>::C => { }\n-        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n         _ => { }\n     }\n }"}, {"sha": "bf3e58e8cdb19b1c5cfea5247b1bba8e6cc4af73", "filename": "src/test/ui/issues/issue-55511.stderr", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr?ref=36d13cb01ba6a0a9b7c13ca2b9461a111cb3e395", "patch": "@@ -1,17 +1,3 @@\n-warning: to use a constant of type `std::cell::Cell` in a pattern, `std::cell::Cell` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/issue-55511.rs:16:9\n-   |\n-LL |         <() as Foo<'static>>::C => { }\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/issue-55511.rs:1:9\n-   |\n-LL | #![warn(indirect_structural_match)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n-\n error[E0597]: `a` does not live long enough\n   --> $DIR/issue-55511.rs:13:28\n    |\n@@ -24,6 +10,6 @@ LL |         <() as Foo<'static>>::C => { }\n LL | }\n    | - `a` dropped here while still borrowed\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0597`."}]}