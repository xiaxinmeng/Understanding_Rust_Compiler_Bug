{"sha": "d8bce01a04958337dc39b895655f8aa2e577b6d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YmNlMDFhMDQ5NTgzMzdkYzM5Yjg5NTY1NWY4YWEyZTU3N2I2ZDI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-30T11:59:40Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-20T11:21:40Z"}, "message": "Make link functions generic over archive builder", "tree": {"sha": "9e65e7563effc025a3e91e28618e791541d91c90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e65e7563effc025a3e91e28618e791541d91c90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8bce01a04958337dc39b895655f8aa2e577b6d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8bce01a04958337dc39b895655f8aa2e577b6d2", "html_url": "https://github.com/rust-lang/rust/commit/d8bce01a04958337dc39b895655f8aa2e577b6d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8bce01a04958337dc39b895655f8aa2e577b6d2/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "892c88b32f88777e9afcd3cdad6a0b2fa7ec526e", "url": "https://api.github.com/repos/rust-lang/rust/commits/892c88b32f88777e9afcd3cdad6a0b2fa7ec526e", "html_url": "https://github.com/rust-lang/rust/commit/892c88b32f88777e9afcd3cdad6a0b2fa7ec526e"}], "stats": {"total": 185, "additions": 101, "deletions": 84}, "files": [{"sha": "e0e26e9af2537796bdb37428eb82076f4cc34196", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 54, "deletions": 37, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d8bce01a04958337dc39b895655f8aa2e577b6d2/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bce01a04958337dc39b895655f8aa2e577b6d2/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=d8bce01a04958337dc39b895655f8aa2e577b6d2", "patch": "@@ -10,10 +10,10 @@ use std::str;\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind};\n use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n-use rustc_codegen_ssa::back::archive::find_library;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, find_library};\n use rustc::session::Session;\n \n-pub struct ArchiveConfig<'a> {\n+struct ArchiveConfig<'a> {\n     pub sess: &'a Session,\n     pub dst: PathBuf,\n     pub src: Option<PathBuf>,\n@@ -22,7 +22,7 @@ pub struct ArchiveConfig<'a> {\n \n /// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n-pub struct ArchiveBuilder<'a> {\n+pub struct LlvmArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n     removals: Vec<String>,\n     additions: Vec<Addition>,\n@@ -48,11 +48,26 @@ fn is_relevant_child(c: &Child<'_>) -> bool {\n     }\n }\n \n-impl<'a> ArchiveBuilder<'a> {\n+fn archive_config<'a>(sess: &'a Session,\n+                      output: &Path,\n+                      input: Option<&Path>) -> ArchiveConfig<'a> {\n+    use rustc_codegen_ssa::back::link::archive_search_paths;\n+    ArchiveConfig {\n+        sess,\n+        dst: output.to_path_buf(),\n+        src: input.map(|p| p.to_path_buf()),\n+        lib_search_paths: archive_search_paths(sess),\n+    }\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     /// Creates a new static archive, ready for modifying the archive specified\n     /// by `config`.\n-    pub fn new(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n-        ArchiveBuilder {\n+    fn new(sess: &'a Session,\n+            output: &Path,\n+            input: Option<&Path>) -> LlvmArchiveBuilder<'a> {\n+        let config = archive_config(sess, output, input);\n+        LlvmArchiveBuilder {\n             config,\n             removals: Vec::new(),\n             additions: Vec::new(),\n@@ -62,12 +77,12 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     /// Removes a file from this archive\n-    pub fn remove_file(&mut self, file: &str) {\n+    fn remove_file(&mut self, file: &str) {\n         self.removals.push(file.to_string());\n     }\n \n     /// Lists all files in an archive\n-    pub fn src_files(&mut self) -> Vec<String> {\n+    fn src_files(&mut self) -> Vec<String> {\n         if self.src_archive().is_none() {\n             return Vec::new()\n         }\n@@ -83,18 +98,9 @@ impl<'a> ArchiveBuilder<'a> {\n                .collect()\n     }\n \n-    fn src_archive(&mut self) -> Option<&ArchiveRO> {\n-        if let Some(ref a) = self.src_archive {\n-            return a.as_ref()\n-        }\n-        let src = self.config.src.as_ref()?;\n-        self.src_archive = Some(ArchiveRO::open(src).ok());\n-        self.src_archive.as_ref().unwrap().as_ref()\n-    }\n-\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    pub fn add_native_library(&mut self, name: &str) {\n+    fn add_native_library(&mut self, name: &str) {\n         let location = find_library(name, &self.config.lib_search_paths,\n                                     self.config.sess);\n         self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n@@ -108,7 +114,7 @@ impl<'a> ArchiveBuilder<'a> {\n     ///\n     /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n     /// then the object file also isn't added.\n-    pub fn add_rlib(&mut self,\n+    fn add_rlib(&mut self,\n                     rlib: &Path,\n                     name: &str,\n                     lto: bool,\n@@ -140,23 +146,8 @@ impl<'a> ArchiveBuilder<'a> {\n         })\n     }\n \n-    fn add_archive<F>(&mut self, archive: &Path, skip: F)\n-                      -> io::Result<()>\n-        where F: FnMut(&str) -> bool + 'static\n-    {\n-        let archive = match ArchiveRO::open(archive) {\n-            Ok(ar) => ar,\n-            Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n-        };\n-        self.additions.push(Addition::Archive {\n-            archive,\n-            skip: Box::new(skip),\n-        });\n-        Ok(())\n-    }\n-\n     /// Adds an arbitrary file to this archive\n-    pub fn add_file(&mut self, file: &Path) {\n+    fn add_file(&mut self, file: &Path) {\n         let name = file.file_name().unwrap().to_str().unwrap();\n         self.additions.push(Addition::File {\n             path: file.to_path_buf(),\n@@ -166,13 +157,13 @@ impl<'a> ArchiveBuilder<'a> {\n \n     /// Indicate that the next call to `build` should update all symbols in\n     /// the archive (equivalent to running 'ar s' over it).\n-    pub fn update_symbols(&mut self) {\n+    fn update_symbols(&mut self) {\n         self.should_update_symbols = true;\n     }\n \n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n-    pub fn build(&mut self) {\n+    fn build(mut self) {\n         let kind = self.llvm_archive_kind().unwrap_or_else(|kind|\n             self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind)));\n \n@@ -181,6 +172,32 @@ impl<'a> ArchiveBuilder<'a> {\n         }\n \n     }\n+}\n+\n+impl<'a> LlvmArchiveBuilder<'a> {\n+    fn src_archive(&mut self) -> Option<&ArchiveRO> {\n+        if let Some(ref a) = self.src_archive {\n+            return a.as_ref()\n+        }\n+        let src = self.config.src.as_ref()?;\n+        self.src_archive = Some(ArchiveRO::open(src).ok());\n+        self.src_archive.as_ref().unwrap().as_ref()\n+    }\n+\n+    fn add_archive<F>(&mut self, archive: &Path, skip: F)\n+                      -> io::Result<()>\n+        where F: FnMut(&str) -> bool + 'static\n+    {\n+        let archive = match ArchiveRO::open(archive) {\n+            Ok(ar) => ar,\n+            Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n+        };\n+        self.additions.push(Addition::Archive {\n+            archive,\n+            skip: Box::new(skip),\n+        });\n+        Ok(())\n+    }\n \n     fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n         let kind = &*self.config.sess.target.target.options.archive_format;"}, {"sha": "3658bb11862bf8cf3c12ecadc98a5e2f98ebfbef", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 31, "deletions": 46, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d8bce01a04958337dc39b895655f8aa2e577b6d2/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bce01a04958337dc39b895655f8aa2e577b6d2/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=d8bce01a04958337dc39b895655f8aa2e577b6d2", "patch": "@@ -1,10 +1,11 @@\n-use super::archive::{ArchiveBuilder, ArchiveConfig};\n+use super::archive::LlvmArchiveBuilder;\n use super::rpath::RPathConfig;\n use super::rpath;\n use crate::back::wasm;\n use crate::context::get_reloc_model;\n use crate::llvm;\n use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n+use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n use rustc_codegen_ssa::back::linker::Linker;\n use rustc_codegen_ssa::back::link::*;\n use rustc_codegen_ssa::back::command::Command;\n@@ -31,14 +32,11 @@ use std::io;\n use std::path::{Path, PathBuf};\n use std::str;\n \n-pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n-                                    invalid_output_for_target, filename_for_metadata,\n-                                    out_filename, check_file_is_writeable};\n-\n+pub use rustc_codegen_utils::link::*;\n \n /// Performs the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub(crate) fn link_binary(sess: &Session,\n+pub(crate) fn link_binary<'a>(sess: &'a Session,\n                           codegen_results: &CodegenResults,\n                           outputs: &OutputFilenames,\n                           crate_name: &str) -> Vec<PathBuf> {\n@@ -56,7 +54,7 @@ pub(crate) fn link_binary(sess: &Session,\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n         }\n-        let out_files = link_binary_output(sess,\n+        let out_files = link_binary_output::<LlvmArchiveBuilder<'a>>(sess,\n                                            codegen_results,\n                                            crate_type,\n                                            outputs,\n@@ -90,7 +88,7 @@ pub(crate) fn link_binary(sess: &Session,\n     out_filenames\n }\n \n-fn link_binary_output(sess: &Session,\n+fn link_binary_output<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                       codegen_results: &CodegenResults,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n@@ -126,17 +124,17 @@ fn link_binary_output(sess: &Session,\n         let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n         match crate_type {\n             config::CrateType::Rlib => {\n-                link_rlib(sess,\n+                link_rlib::<B>(sess,\n                           codegen_results,\n                           RlibFlavor::Normal,\n                           &out_filename,\n                           &tmpdir).build();\n             }\n             config::CrateType::Staticlib => {\n-                link_staticlib(sess, codegen_results, &out_filename, &tmpdir);\n+                link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n             }\n             _ => {\n-                link_natively(sess, crate_type, &out_filename, codegen_results, tmpdir.path());\n+                link_natively::<B>(sess, crate_type, &out_filename, codegen_results, tmpdir.path());\n             }\n         }\n         out_filenames.push(out_filename);\n@@ -149,17 +147,6 @@ fn link_binary_output(sess: &Session,\n     out_filenames\n }\n \n-fn archive_config<'a>(sess: &'a Session,\n-                      output: &Path,\n-                      input: Option<&Path>) -> ArchiveConfig<'a> {\n-    ArchiveConfig {\n-        sess,\n-        dst: output.to_path_buf(),\n-        src: input.map(|p| p.to_path_buf()),\n-        lib_search_paths: archive_search_paths(sess),\n-    }\n-}\n-\n /// We use a temp directory here to avoid races between concurrent rustc processes,\n /// such as builds in the same directory using the same filename for metadata while\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n@@ -191,13 +178,13 @@ enum RlibFlavor {\n // rlib primarily contains the object file of the crate, but it also contains\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n-fn link_rlib<'a>(sess: &'a Session,\n+fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                  codegen_results: &CodegenResults,\n                  flavor: RlibFlavor,\n                  out_filename: &Path,\n-                 tmpdir: &TempDir) -> ArchiveBuilder<'a> {\n+                 tmpdir: &TempDir) -> B {\n     info!(\"preparing rlib to {:?}\", out_filename);\n-    let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n+    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n \n     for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         ab.add_file(obj);\n@@ -305,11 +292,11 @@ fn link_rlib<'a>(sess: &'a Session,\n // There's no need to include metadata in a static archive, so ensure to not\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n-fn link_staticlib(sess: &Session,\n+fn link_staticlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                   codegen_results: &CodegenResults,\n                   out_filename: &Path,\n                   tempdir: &TempDir) {\n-    let mut ab = link_rlib(sess,\n+    let mut ab = link_rlib::<B>(sess,\n                            codegen_results,\n                            RlibFlavor::StaticlibBase,\n                            out_filename,\n@@ -363,7 +350,7 @@ fn link_staticlib(sess: &Session,\n //\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n-fn link_natively(sess: &Session,\n+fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                  crate_type: config::CrateType,\n                  out_filename: &Path,\n                  codegen_results: &CodegenResults,\n@@ -422,7 +409,7 @@ fn link_natively(sess: &Session,\n     {\n         let target_cpu = crate::llvm_util::target_cpu(sess);\n         let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n-        link_args(&mut *linker, flavor, sess, crate_type, tmpdir,\n+        link_args::<B>(&mut *linker, flavor, sess, crate_type, tmpdir,\n                   out_filename, codegen_results);\n         cmd = linker.finalize();\n     }\n@@ -603,9 +590,9 @@ fn link_natively(sess: &Session,\n     }\n }\n \n-fn link_args(cmd: &mut dyn Linker,\n+fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n              flavor: LinkerFlavor,\n-             sess: &Session,\n+             sess: &'a Session,\n              crate_type: config::CrateType,\n              tmpdir: &Path,\n              out_filename: &Path,\n@@ -759,7 +746,7 @@ fn link_args(cmd: &mut dyn Linker,\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n     // on other dylibs (e.g., other native deps).\n     add_local_native_libraries(cmd, sess, codegen_results);\n-    add_upstream_rust_crates(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n     add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n \n     // Tell the linker what we're doing.\n@@ -812,8 +799,8 @@ fn link_args(cmd: &mut dyn Linker,\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n-                            sess: &Session,\n+fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                            sess: &'a Session,\n                             codegen_results: &CodegenResults,\n                             crate_type: config::CrateType,\n                             tmpdir: &Path) {\n@@ -888,10 +875,10 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n             }\n             _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n-                link_sanitizer_runtime(cmd, sess, codegen_results, tmpdir, cnum);\n+                link_sanitizer_runtime::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n@@ -902,7 +889,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n             }\n             Linkage::Dynamic => {\n                 add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n@@ -920,7 +907,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n     // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+        add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -936,8 +923,8 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n     // it's packed in a .rlib, it contains stuff that are not objects that will\n     // make the linker error. So we must remove those bits from the .rlib before\n     // linking it.\n-    fn link_sanitizer_runtime(cmd: &mut dyn Linker,\n-                              sess: &Session,\n+    fn link_sanitizer_runtime<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                              sess: &'a Session,\n                               codegen_results: &CodegenResults,\n                               tmpdir: &Path,\n                               cnum: CrateNum) {\n@@ -957,8 +944,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n         }\n \n         let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let cfg = archive_config(sess, &dst, Some(cratepath));\n-        let mut archive = ArchiveBuilder::new(cfg);\n+        let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n         archive.update_symbols();\n \n         for f in archive.src_files() {\n@@ -1004,8 +990,8 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n     // (aka we're making an executable), we can just pass the rlib blindly to\n     // the linker (fast) because it's fine if it's not actually included as\n     // we're at the end of the dependency chain.\n-    fn add_static_crate(cmd: &mut dyn Linker,\n-                        sess: &Session,\n+    fn add_static_crate<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                        sess: &'a Session,\n                         codegen_results: &CodegenResults,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n@@ -1034,8 +1020,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n         time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n-            let cfg = archive_config(sess, &dst, Some(cratepath));\n-            let mut archive = ArchiveBuilder::new(cfg);\n+            let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n \n             let mut any_objects = false;"}, {"sha": "cfe75b7b9bcb674194305ba60d3b0ea982891a80", "filename": "src/librustc_codegen_ssa/back/archive.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8bce01a04958337dc39b895655f8aa2e577b6d2/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bce01a04958337dc39b895655f8aa2e577b6d2/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs?ref=d8bce01a04958337dc39b895655f8aa2e577b6d2", "patch": "@@ -1,6 +1,7 @@\n use rustc::session::Session;\n \n-use std::path::PathBuf;\n+use std::io;\n+use std::path::{Path, PathBuf};\n \n pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n                     -> PathBuf {\n@@ -24,3 +25,17 @@ pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n     sess.fatal(&format!(\"could not find native static library `{}`, \\\n                          perhaps an -L flag is missing?\", name));\n }\n+\n+pub trait ArchiveBuilder<'a> {\n+    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self;\n+\n+    fn add_file(&mut self, path: &Path);\n+    fn remove_file(&mut self, name: &str);\n+    fn src_files(&mut self) -> Vec<String>;\n+\n+    fn add_rlib(&mut self, path: &Path, name: &str, lto: bool, skip_objects: bool) -> io::Result<()>;\n+    fn add_native_library(&mut self, name: &str);\n+    fn update_symbols(&mut self);\n+\n+    fn build(self);\n+}"}]}