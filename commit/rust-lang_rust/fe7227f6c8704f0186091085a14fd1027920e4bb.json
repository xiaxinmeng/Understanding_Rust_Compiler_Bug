{"sha": "fe7227f6c8704f0186091085a14fd1027920e4bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNzIyN2Y2Yzg3MDRmMDE4NjA5MTA4NWExNGZkMTAyNzkyMGU0YmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-16T17:52:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-16T17:52:11Z"}, "message": "Auto merge of #42430 - nagisa:core-float, r=alexcrichton\n\nRe-implement float min/max in rust\n\nThis also adds the relevant implementations into libcore.\n\nSee #42423", "tree": {"sha": "8c3cb396146179783cb6d001fa7f4f67c6958575", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c3cb396146179783cb6d001fa7f4f67c6958575"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe7227f6c8704f0186091085a14fd1027920e4bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7227f6c8704f0186091085a14fd1027920e4bb", "html_url": "https://github.com/rust-lang/rust/commit/fe7227f6c8704f0186091085a14fd1027920e4bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe7227f6c8704f0186091085a14fd1027920e4bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b40be00a0cac84d23f51c5c5109c8f824ab19ab3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b40be00a0cac84d23f51c5c5109c8f824ab19ab3", "html_url": "https://github.com/rust-lang/rust/commit/b40be00a0cac84d23f51c5c5109c8f824ab19ab3"}, {"sha": "ba6cf1d80ac6f5ff3c36c7f6111197d429369d86", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba6cf1d80ac6f5ff3c36c7f6111197d429369d86", "html_url": "https://github.com/rust-lang/rust/commit/ba6cf1d80ac6f5ff3c36c7f6111197d429369d86"}], "stats": {"total": 130, "additions": 122, "deletions": 8}, "files": [{"sha": "cb28035682d650607409d522448243413a03630b", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=fe7227f6c8704f0186091085a14fd1027920e4bb", "patch": "@@ -242,4 +242,32 @@ impl Float for f32 {\n         let value: f32 = consts::PI;\n         self * (value / 180.0f32)\n     }\n+\n+    /// Returns the maximum of the two numbers.\n+    #[inline]\n+    fn max(self, other: f32) -> f32 {\n+        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || self.is_nan() { other } else { self }) * 1.0\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    #[inline]\n+    fn min(self, other: f32) -> f32 {\n+        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || other.is_nan() { self } else { other }) * 1.0\n+    }\n }"}, {"sha": "ac6b1e67cd2785b17154e76062210bb6f6f76f8c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=fe7227f6c8704f0186091085a14fd1027920e4bb", "patch": "@@ -242,4 +242,32 @@ impl Float for f64 {\n         let value: f64 = consts::PI;\n         self * (value / 180.0)\n     }\n+\n+    /// Returns the maximum of the two numbers.\n+    #[inline]\n+    fn max(self, other: f64) -> f64 {\n+        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || self.is_nan() { other } else { self }) * 1.0\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    #[inline]\n+    fn min(self, other: f64) -> f64 {\n+        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || other.is_nan() { self } else { other }) * 1.0\n+    }\n }"}, {"sha": "cbd59ed3713776f84b6cf42129c11c8742dc2ab9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=fe7227f6c8704f0186091085a14fd1027920e4bb", "patch": "@@ -2459,6 +2459,13 @@ pub trait Float: Sized {\n     /// Convert degrees to radians.\n     #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_radians(self) -> Self;\n+\n+    /// Returns the maximum of the two numbers.\n+    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n+    fn max(self, other: Self) -> Self;\n+    /// Returns the minimum of the two numbers.\n+    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n+    fn min(self, other: Self) -> Self;\n }\n \n macro_rules! from_str_radix_int_impl {"}, {"sha": "337f8aa31dc4603ee9a563c2a2f153a7b57ace6f", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=fe7227f6c8704f0186091085a14fd1027920e4bb", "patch": "@@ -13,6 +13,7 @@\n #![feature(box_syntax)]\n #![feature(char_escape_debug)]\n #![feature(const_fn)]\n+#![feature(core_float)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]"}, {"sha": "f233b649a8f3c6bda621047a70bae2ff9ff88381", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=fe7227f6c8704f0186091085a14fd1027920e4bb", "patch": "@@ -399,3 +399,57 @@ test_impl_try_from_signed_to_unsigned_err! { test_try_i32u16, i32, u16 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u8, i64, u8 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u16, i64, u16 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u32, i64, u32 }\n+\n+macro_rules! test_float {\n+    ($modname: ident, $fty: ty, $inf: expr, $neginf: expr, $nan: expr) => { mod $modname {\n+        use core::num::Float;\n+        // FIXME(nagisa): these tests should test for sign of -0.0\n+        #[test]\n+        fn min() {\n+            assert_eq!(0.0.min(0.0), 0.0);\n+            assert_eq!((-0.0).min(-0.0), -0.0);\n+            assert_eq!(9.0.min(9.0), 9.0);\n+            assert_eq!((-9.0).min(0.0), -9.0);\n+            assert_eq!(0.0.min(9.0), 0.0);\n+            assert_eq!((-0.0).min(-9.0), -9.0);\n+            assert_eq!($inf.min(9.0), 9.0);\n+            assert_eq!(9.0.min($inf), 9.0);\n+            assert_eq!($inf.min(-9.0), -9.0);\n+            assert_eq!((-9.0).min($inf), -9.0);\n+            assert_eq!($neginf.min(9.0), $neginf);\n+            assert_eq!(9.0.min($neginf), $neginf);\n+            assert_eq!($neginf.min(-9.0), $neginf);\n+            assert_eq!((-9.0).min($neginf), $neginf);\n+            assert_eq!($nan.min(9.0), 9.0);\n+            assert_eq!($nan.min(-9.0), -9.0);\n+            assert_eq!(9.0.min($nan), 9.0);\n+            assert_eq!((-9.0).min($nan), -9.0);\n+            assert!($nan.min($nan).is_nan());\n+        }\n+        #[test]\n+        fn max() {\n+            assert_eq!(0.0.max(0.0), 0.0);\n+            assert_eq!((-0.0).max(-0.0), -0.0);\n+            assert_eq!(9.0.max(9.0), 9.0);\n+            assert_eq!((-9.0).max(0.0), 0.0);\n+            assert_eq!(0.0.max(9.0), 9.0);\n+            assert_eq!((-0.0).max(-9.0), -0.0);\n+            assert_eq!($inf.max(9.0), $inf);\n+            assert_eq!(9.0.max($inf), $inf);\n+            assert_eq!($inf.max(-9.0), $inf);\n+            assert_eq!((-9.0).max($inf), $inf);\n+            assert_eq!($neginf.max(9.0), 9.0);\n+            assert_eq!(9.0.max($neginf), 9.0);\n+            assert_eq!($neginf.max(-9.0), -9.0);\n+            assert_eq!((-9.0).max($neginf), -9.0);\n+            assert_eq!($nan.max(9.0), 9.0);\n+            assert_eq!($nan.max(-9.0), -9.0);\n+            assert_eq!(9.0.max($nan), 9.0);\n+            assert_eq!((-9.0).max($nan), -9.0);\n+            assert!($nan.max($nan).is_nan());\n+        }\n+    } }\n+}\n+\n+test_float!(f32, f32, ::core::f32::INFINITY, ::core::f32::NEG_INFINITY, ::core::f32::NAN);\n+test_float!(f64, f64, ::core::f64::INFINITY, ::core::f64::NEG_INFINITY, ::core::f64::NAN);"}, {"sha": "6134b0b882c5bb80c133ee57b3cbd165294b3451", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=fe7227f6c8704f0186091085a14fd1027920e4bb", "patch": "@@ -46,8 +46,6 @@ mod cmath {\n         pub fn erfcf(n: c_float) -> c_float;\n         pub fn expm1f(n: c_float) -> c_float;\n         pub fn fdimf(a: c_float, b: c_float) -> c_float;\n-        pub fn fmaxf(a: c_float, b: c_float) -> c_float;\n-        pub fn fminf(a: c_float, b: c_float) -> c_float;\n         pub fn fmodf(a: c_float, b: c_float) -> c_float;\n         pub fn ilogbf(n: c_float) -> c_int;\n         pub fn logbf(n: c_float) -> c_float;\n@@ -673,7 +671,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f32) -> f32 {\n-        unsafe { cmath::fmaxf(self, other) }\n+        num::Float::max(self, other)\n     }\n \n     /// Returns the minimum of the two numbers.\n@@ -689,7 +687,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f32) -> f32 {\n-        unsafe { cmath::fminf(self, other) }\n+        num::Float::min(self, other)\n     }\n \n     /// The positive difference of two numbers."}, {"sha": "e8d25cfbf949a93c9f9ac81216d3ee16133be22f", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7227f6c8704f0186091085a14fd1027920e4bb/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=fe7227f6c8704f0186091085a14fd1027920e4bb", "patch": "@@ -51,8 +51,6 @@ mod cmath {\n         pub fn erfc(n: c_double) -> c_double;\n         pub fn expm1(n: c_double) -> c_double;\n         pub fn fdim(a: c_double, b: c_double) -> c_double;\n-        pub fn fmax(a: c_double, b: c_double) -> c_double;\n-        pub fn fmin(a: c_double, b: c_double) -> c_double;\n         pub fn fmod(a: c_double, b: c_double) -> c_double;\n         pub fn frexp(n: c_double, value: &mut c_int) -> c_double;\n         pub fn ilogb(n: c_double) -> c_int;\n@@ -587,7 +585,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f64) -> f64 {\n-        unsafe { cmath::fmax(self, other) }\n+        num::Float::max(self, other)\n     }\n \n     /// Returns the minimum of the two numbers.\n@@ -603,7 +601,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f64) -> f64 {\n-        unsafe { cmath::fmin(self, other) }\n+        num::Float::min(self, other)\n     }\n \n     /// The positive difference of two numbers."}]}