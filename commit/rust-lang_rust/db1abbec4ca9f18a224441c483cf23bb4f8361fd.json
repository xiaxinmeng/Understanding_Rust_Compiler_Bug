{"sha": "db1abbec4ca9f18a224441c483cf23bb4f8361fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMWFiYmVjNGNhOWYxOGEyMjQ0NDFjNDgzY2YyM2JiNGY4MzYxZmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-13T07:27:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-18T03:24:50Z"}, "message": "core: Add private global data interface. #3915", "tree": {"sha": "2adeac14bbca31e2bf09708ea1f36b6a39e65953", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2adeac14bbca31e2bf09708ea1f36b6a39e65953"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db1abbec4ca9f18a224441c483cf23bb4f8361fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db1abbec4ca9f18a224441c483cf23bb4f8361fd", "html_url": "https://github.com/rust-lang/rust/commit/db1abbec4ca9f18a224441c483cf23bb4f8361fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db1abbec4ca9f18a224441c483cf23bb4f8361fd/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac435af73a0009daf22164ee2f081a7c98ca844c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac435af73a0009daf22164ee2f081a7c98ca844c", "html_url": "https://github.com/rust-lang/rust/commit/ac435af73a0009daf22164ee2f081a7c98ca844c"}], "stats": {"total": 277, "additions": 275, "deletions": 2}, "files": [{"sha": "ef25cb52e8ba07f89e07065f9b7e924f95066939", "filename": "src/libcore/private.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=db1abbec4ca9f18a224441c483cf23bb4f8361fd", "patch": "@@ -30,6 +30,8 @@ use uint;\n \n #[path = \"private/at_exit.rs\"]\n pub mod at_exit;\n+#[path = \"private/global.rs\"]\n+pub mod global;\n \n extern mod rustrt {\n     #[legacy_exports];\n@@ -522,6 +524,12 @@ pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n     ArcDestruct((*rc).data)\n }\n \n+impl<T: Owned> SharedMutableState<T>: Clone {\n+    fn clone(&self) -> SharedMutableState<T> unsafe {\n+        clone_shared_mutable_state(self)\n+    }\n+}\n+\n /****************************************************************************/\n \n #[allow(non_camel_case_types)] // runtime type"}, {"sha": "8c1500353ae6758af8101f03e4cb953e55b14e64", "filename": "src/libcore/private/global.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Flibcore%2Fprivate%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Flibcore%2Fprivate%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fglobal.rs?ref=db1abbec4ca9f18a224441c483cf23bb4f8361fd", "patch": "@@ -0,0 +1,257 @@\n+/*!\n+Global data\n+\n+An interface for creating and retrieving values with global\n+(per-runtime) scope.\n+\n+Global values are stored in a map and protected by a single global\n+mutex. Operations are provided for accessing and cloning the value\n+under the mutex.\n+\n+Because all globals go through a single mutex, they should be used\n+sparingly.  The interface is intended to be used with clonable,\n+atomically reference counted synchronization types, like ARCs, in\n+which case the value should be cached locally whenever possible to\n+avoid hitting the mutex.\n+*/\n+\n+use cast::{transmute, reinterpret_cast};\n+use clone::Clone;\n+use kinds::Owned;\n+use libc::{c_void, uintptr_t};\n+use option::{Option, Some, None};\n+use ops::Drop;\n+use pipes;\n+use private::{Exclusive, exclusive};\n+use private::{SharedMutableState, shared_mutable_state};\n+use private::{get_shared_immutable_state};\n+use private::at_exit::at_exit;\n+use send_map::linear::LinearMap;\n+use sys::Closure;\n+use task::spawn;\n+use uint;\n+\n+pub type GlobalDataKey<T: Owned> = &fn(v: T);\n+\n+pub unsafe fn global_data_clone_create<T: Owned Clone>(\n+    key: GlobalDataKey<T>, create: &fn() -> ~T) -> T {\n+    /*!\n+     * Clone a global value or, if it has not been created,\n+     * first construct the value then return a clone.\n+     *\n+     * # Safety note\n+     *\n+     * Both the clone operation and the constructor are\n+     * called while the global lock is held. Recursive\n+     * use of the global interface in either of these\n+     * operations will result in deadlock.\n+     */\n+    global_data_clone_create_(key_ptr(key), create)\n+}\n+\n+unsafe fn global_data_clone_create_<T: Owned Clone>(\n+    key: uint, create: &fn() -> ~T) -> T {\n+\n+    let mut clone_value: Option<T> = None;\n+    do global_data_modify_(key) |value: Option<~T>| {\n+        match value {\n+            None => {\n+                let value = create();\n+                clone_value = Some(value.clone());\n+                Some(value)\n+            }\n+            Some(value) => {\n+                clone_value = Some(value.clone());\n+                Some(value)\n+            }\n+        }\n+    }\n+    return clone_value.unwrap();\n+}\n+\n+unsafe fn global_data_modify<T: Owned>(\n+    key: GlobalDataKey<T>, op: &fn(Option<~T>) -> Option<~T>) {\n+\n+    global_data_modify_(key_ptr(key), op)\n+}\n+\n+unsafe fn global_data_modify_<T: Owned>(\n+    key: uint, op: &fn(Option<~T>) -> Option<~T>) {\n+\n+    let mut old_dtor = None;\n+    do get_global_state().with |gs| unsafe {\n+        let (maybe_new_value, maybe_dtor) = match gs.map.pop(&key) {\n+            Some((ptr, dtor)) => {\n+                let value: ~T = transmute(ptr);\n+                (op(Some(value)), Some(dtor))\n+            }\n+            None => {\n+                (op(None), None)\n+            }\n+        };\n+        match maybe_new_value {\n+            Some(value) => {\n+                let data: *c_void = transmute(value);\n+                let dtor: ~fn() = match maybe_dtor {\n+                    Some(dtor) => dtor,\n+                    None => {\n+                        let dtor: ~fn() = || unsafe {\n+                            let _destroy_value: ~T = transmute(data);\n+                        };\n+                        dtor\n+                    }\n+                };\n+                let value = (data, dtor);\n+                gs.map.insert(key, value);\n+            }\n+            None => {\n+                match maybe_dtor {\n+                    Some(dtor) => old_dtor = Some(dtor),\n+                    None => ()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// GlobalState is a map from keys to unique pointers and a\n+// destructor. Keys are pointers derived from the type of the\n+// global value.  There is a single GlobalState instance per runtime.\n+struct GlobalState {\n+    map: LinearMap<uint, (*c_void, ~fn())>\n+}\n+\n+impl GlobalState: Drop {\n+    fn finalize(&self) {\n+        for self.map.each_value |v| {\n+            match v {\n+                &(_, ref dtor) => (*dtor)()\n+            }\n+        }\n+    }\n+}\n+\n+fn get_global_state() -> Exclusive<GlobalState> unsafe {\n+\n+    const POISON: int = -1;\n+\n+    // XXX: Doing atomic_cxchg to initialize the global state\n+    // lazily, which wouldn't be necessary with a runtime written\n+    // in Rust\n+    let global_ptr = rust_get_global_data_ptr();\n+\n+    if *global_ptr == 0 {\n+        // Global state doesn't exist yet, probably\n+\n+        // The global state object\n+        let state = GlobalState {\n+            map: LinearMap()\n+        };\n+\n+        // It's under a reference-counted mutex\n+        let state = ~exclusive(state);\n+\n+        // Convert it to an integer\n+        let state_ptr: &Exclusive<GlobalState> = state;\n+        let state_i: int = transmute(state_ptr);\n+\n+        // Swap our structure into the global pointer\n+        let prev_i = atomic_cxchg(&mut *global_ptr, 0, state_i);\n+\n+        // Sanity check that we're not trying to reinitialize after shutdown\n+        assert prev_i != POISON;\n+\n+        if prev_i == 0 {\n+            // Successfully installed the global pointer\n+\n+            // Take a handle to return\n+            let clone = state.clone();\n+\n+            // Install a runtime exit function to destroy the global object\n+            do at_exit || unsafe {\n+                // Poison the global pointer\n+                let prev_i = atomic_cxchg(&mut *global_ptr, state_i, POISON);\n+                assert prev_i == state_i;\n+\n+                // Capture the global state object in the at_exit closure\n+                // so that it is destroyed at the right time\n+                let _capture_global_state = &state;\n+            };\n+            return clone;\n+        } else {\n+            // Somebody else initialized the globals first\n+            let state: &Exclusive<GlobalState> = transmute(prev_i);\n+            return state.clone();\n+        }\n+    } else {\n+        let state: &Exclusive<GlobalState> = transmute(*global_ptr);\n+        return state.clone();\n+    }\n+}\n+\n+fn key_ptr<T: Owned>(key: GlobalDataKey<T>) -> uint unsafe {\n+    let closure: Closure = reinterpret_cast(&key);\n+    return transmute(closure.code);\n+}\n+\n+extern {\n+    fn rust_get_global_data_ptr() -> *mut int;\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+extern {\n+    fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n+}\n+\n+#[test]\n+fn test_clone_rc() unsafe {\n+    type MyType = SharedMutableState<int>;\n+\n+    fn key(_v: SharedMutableState<int>) { }\n+\n+    for uint::range(0, 100) |_| {\n+        do spawn unsafe {\n+            let val = do global_data_clone_create(key) {\n+                ~shared_mutable_state(10)\n+            };\n+\n+            assert get_shared_immutable_state(&val) == &10;\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_modify() unsafe {\n+    type MyType = SharedMutableState<int>;\n+\n+    fn key(_v: SharedMutableState<int>) { }\n+\n+    do global_data_modify(key) |v| unsafe {\n+        match v {\n+            None => {\n+                Some(~shared_mutable_state(10))\n+            }\n+            _ => fail\n+        }\n+    }\n+\n+    do global_data_modify(key) |v| {\n+        match v {\n+            Some(sms) => {\n+                let v = get_shared_immutable_state(sms);\n+                assert *v == 10;\n+                None\n+            },\n+            _ => fail\n+        }\n+    }\n+\n+    do global_data_modify(key) |v| unsafe {\n+        match v {\n+            None => {\n+                Some(~shared_mutable_state(10))\n+            }\n+            _ => fail\n+        }\n+    }\n+}"}, {"sha": "221afb89b237df78b8935d40b58d962b1bbff2b9", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=db1abbec4ca9f18a224441c483cf23bb4f8361fd", "patch": "@@ -1032,6 +1032,12 @@ rust_register_exit_function(spawn_fn runner, fn_env_pair *f) {\n     task->kernel->register_exit_function(runner, f);\n }\n \n+extern \"C\" void *\n+rust_get_global_data_ptr() {\n+    rust_task *task = rust_get_current_task();\n+    return &task->kernel->global_data;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "9c6ba9dcda3efab4950be57292518957afd45ff0", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=db1abbec4ca9f18a224441c483cf23bb4f8361fd", "patch": "@@ -38,8 +38,8 @@ rust_kernel::rust_kernel(rust_env *env) :\n     global_env_chan(0),\n     at_exit_runner(NULL),\n     at_exit_started(false),\n-    env(env)\n-\n+    env(env),\n+    global_data(0)\n {\n     // Create the single threaded scheduler that will run on the platform's\n     // main thread"}, {"sha": "99b230f7872bd1ab319174ac9aff0ac4e587d964", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=db1abbec4ca9f18a224441c483cf23bb4f8361fd", "patch": "@@ -144,6 +144,7 @@ class rust_kernel {\n \n public:\n     struct rust_env *env;\n+    uintptr_t global_data;\n \n     rust_kernel(rust_env *env);\n "}, {"sha": "8c26832f3498cabc6fefdfef876fb4711bd3e3b2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/db1abbec4ca9f18a224441c483cf23bb4f8361fd/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=db1abbec4ca9f18a224441c483cf23bb4f8361fd", "patch": "@@ -211,3 +211,4 @@ linenoiseHistoryLoad\n rust_raw_thread_start\n rust_raw_thread_join_delete\n rust_register_exit_function\n+rust_get_global_data_ptr\n\\ No newline at end of file"}]}