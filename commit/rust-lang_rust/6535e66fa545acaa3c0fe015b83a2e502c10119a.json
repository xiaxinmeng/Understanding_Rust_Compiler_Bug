{"sha": "6535e66fa545acaa3c0fe015b83a2e502c10119a", "node_id": "C_kwDOAAsO6NoAKDY1MzVlNjZmYTU0NWFjYWEzYzBmZTAxNWI4M2EyZTUwMmMxMDExOWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-27T06:46:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-27T06:46:55Z"}, "message": "Rollup merge of #109641 - compiler-errors:dont-elaborate-non-obl, r=oli-obk\n\nDon't elaborate non-obligations into obligations\n\nIt's suspicious to elaborate a `PolyTraitRef` or `Predicate` into an `Obligation`, since the former does not have a param-env associated with it, but the latter does. This is a footgun that, while not being misused *currently* in the compiler, easily could be misused by someone less familiar with the elaborator's inner workings.\n\nThis PR just changes the API -- ideally, the elaborator wouldn't even have to deal with obligations if we're not elaborating obligations, but that would require a bit more abstraction than I could be bothered with today.", "tree": {"sha": "8d982b4a968c7447561287a1ad00324ba8f0cf1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d982b4a968c7447561287a1ad00324ba8f0cf1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6535e66fa545acaa3c0fe015b83a2e502c10119a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkITvfCRBK7hj4Ov3rIwAADZgIAIz8jP/7hfwp7oMAaCYQBlJw\nKkvDIC85Aka4CPDW/wyk2RK1dfjA8dx2PmBg+Bw1JxacSiFGlLa9G8V1ogoWFOQ5\nBh88F2/Z6iGnYSMD1v3nr6DXbZR36W364+PSgnIHe+dZKgNTvczK15rDvW/XUkiT\nzC8mFQqYqpFZXC3zATSOyrfzYAvozbJkEexcYV7/3hUEE9bUOGNpCjqwjk1QeLES\nWgIY3cCQVhqRutNVgYkWwI8vv7r/ZTyOMy8v3XF6VuX49WADoP/AK0ybjjS+lq6B\nguEjktpySO9CecNWTTi4I5TKJ/pV5yPb5dEWnKG1/JhnAloyrPZRaoYhHn8B9sU=\n=NbAK\n-----END PGP SIGNATURE-----\n", "payload": "tree 8d982b4a968c7447561287a1ad00324ba8f0cf1c\nparent 2b7dc94535e2b4f922091ee1834e21a7d18ba4bf\nparent 1ce4b37900cf0c7f5e146b866b5a8fae2b93f9fc\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679899615 +0200\ncommitter GitHub <noreply@github.com> 1679899615 +0200\n\nRollup merge of #109641 - compiler-errors:dont-elaborate-non-obl, r=oli-obk\n\nDon't elaborate non-obligations into obligations\n\nIt's suspicious to elaborate a `PolyTraitRef` or `Predicate` into an `Obligation`, since the former does not have a param-env associated with it, but the latter does. This is a footgun that, while not being misused *currently* in the compiler, easily could be misused by someone less familiar with the elaborator's inner workings.\n\nThis PR just changes the API -- ideally, the elaborator wouldn't even have to deal with obligations if we're not elaborating obligations, but that would require a bit more abstraction than I could be bothered with today.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6535e66fa545acaa3c0fe015b83a2e502c10119a", "html_url": "https://github.com/rust-lang/rust/commit/6535e66fa545acaa3c0fe015b83a2e502c10119a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6535e66fa545acaa3c0fe015b83a2e502c10119a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b7dc94535e2b4f922091ee1834e21a7d18ba4bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b7dc94535e2b4f922091ee1834e21a7d18ba4bf", "html_url": "https://github.com/rust-lang/rust/commit/2b7dc94535e2b4f922091ee1834e21a7d18ba4bf"}, {"sha": "1ce4b37900cf0c7f5e146b866b5a8fae2b93f9fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce4b37900cf0c7f5e146b866b5a8fae2b93f9fc", "html_url": "https://github.com/rust-lang/rust/commit/1ce4b37900cf0c7f5e146b866b5a8fae2b93f9fc"}], "stats": {"total": 243, "additions": 112, "deletions": 131}, "files": [{"sha": "4ab6bb5908bcdc279cd2b3fd80e9af3b8dd44f57", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -1427,13 +1427,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for (base_trait_ref, span, constness) in regular_traits_refs_spans {\n             assert_eq!(constness, ty::BoundConstness::NotConst);\n \n-            for obligation in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n-                debug!(\n-                    \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n-                    obligation.predicate\n-                );\n+            for pred in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n+                debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", pred);\n \n-                let bound_predicate = obligation.predicate.kind();\n+                let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                         let pred = bound_predicate.rebind(pred);"}, {"sha": "c912a8a640d4567e1ff3dd464407282849b41453", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -1912,14 +1912,13 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         // Check elaborated bounds.\n         let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n \n-        for obligation in implied_obligations {\n+        for (pred, obligation_span) in implied_obligations {\n             // We lower empty bounds like `Vec<dyn Copy>:` as\n             // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n             // regular WF checking\n-            if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n+            if let ty::PredicateKind::WellFormed(..) = pred.kind().skip_binder() {\n                 continue;\n             }\n-            let pred = obligation.predicate;\n             // Match the existing behavior.\n             if pred.is_global() && !pred.has_late_bound_vars() {\n                 let pred = self.normalize(span, None, pred);\n@@ -1930,8 +1929,6 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n                 if let Some(hir::Generics { predicates, .. }) =\n                     hir_node.and_then(|node| node.generics())\n                 {\n-                    let obligation_span = obligation.cause.span();\n-\n                     span = predicates\n                         .iter()\n                         // There seems to be no better way to find out which predicate we are in"}, {"sha": "d2e45c28658bd5f1a9a84d78ff69cb7fd055c255", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -130,12 +130,9 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(\n-        util::elaborate_predicates(\n-            tcx,\n-            tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n-        )\n-        .map(|obligation| obligation.predicate),\n-    );\n+    let bounds = tcx.mk_predicates_from_iter(util::elaborate_predicates(\n+        tcx,\n+        tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n+    ));\n     ty::EarlyBinder(bounds)\n }"}, {"sha": "dfa9e6148aab5fe5ae2d0e07b51730974c604a35", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -318,16 +318,8 @@ fn check_predicates<'tcx>(\n     span: Span,\n ) {\n     let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n-    let impl1_predicates: Vec<_> = traits::elaborate_predicates_with_span(\n-        tcx,\n-        std::iter::zip(\n-            instantiated.predicates,\n-            // Don't drop predicates (unsound!) because `spans` is too short\n-            instantiated.spans.into_iter().chain(std::iter::repeat(span)),\n-        ),\n-    )\n-    .map(|obligation| (obligation.predicate, obligation.cause.span))\n-    .collect();\n+    let impl1_predicates: Vec<_> =\n+        traits::elaborate_predicates_with_span(tcx, instantiated.into_iter()).collect();\n \n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n         // Always applicable traits have to be always applicable without any\n@@ -341,7 +333,6 @@ fn check_predicates<'tcx>(\n                 .predicates\n                 .into_iter(),\n         )\n-        .map(|obligation| obligation.predicate)\n         .collect()\n     };\n     debug!(?impl1_predicates, ?impl2_predicates);\n@@ -361,12 +352,16 @@ fn check_predicates<'tcx>(\n     // which is sound because we forbid impls like the following\n     //\n     // impl<D: Debug> AlwaysApplicable for D { }\n-    let always_applicable_traits = impl1_predicates.iter().copied().filter(|&(predicate, _)| {\n-        matches!(\n-            trait_predicate_kind(tcx, predicate),\n-            Some(TraitSpecializationKind::AlwaysApplicable)\n-        )\n-    });\n+    let always_applicable_traits = impl1_predicates\n+        .iter()\n+        .copied()\n+        .filter(|&(predicate, _)| {\n+            matches!(\n+                trait_predicate_kind(tcx, predicate),\n+                Some(TraitSpecializationKind::AlwaysApplicable)\n+            )\n+        })\n+        .map(|(pred, _span)| pred);\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().subst_identity().substs {\n@@ -380,10 +375,7 @@ fn check_predicates<'tcx>(\n             traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n         )\n     }\n-    impl2_predicates.extend(\n-        traits::elaborate_predicates_with_span(tcx, always_applicable_traits)\n-            .map(|obligation| obligation.predicate),\n-    );\n+    impl2_predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n \n     for (predicate, span) in impl1_predicates {\n         if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {"}, {"sha": "47a8b0801664fec04f254dee2816e65a6146b67f", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -204,25 +204,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_sig = None;\n         let mut expected_kind = None;\n \n-        for obligation in traits::elaborate_predicates_with_span(\n+        for (pred, span) in traits::elaborate_predicates_with_span(\n             self.tcx,\n             // Reverse the obligations here, since `elaborate_*` uses a stack,\n             // and we want to keep inference generally in the same order of\n             // the registered obligations.\n             predicates.rev(),\n         ) {\n-            debug!(?obligation.predicate);\n-            let bound_predicate = obligation.predicate.kind();\n+            debug!(?pred);\n+            let bound_predicate = pred.kind();\n \n             // Given a Projection predicate, we can potentially infer\n             // the complete signature.\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n                 let inferred_sig = self.normalize(\n-                    obligation.cause.span,\n+                    span,\n                     self.deduce_sig_from_projection(\n-                    Some(obligation.cause.span),\n+                    Some(span),\n                         bound_predicate.rebind(proj_predicate),\n                     ),\n                 );"}, {"sha": "2762e778591eeca204e7aeed74f7ce048b0f00da", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -576,17 +576,13 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n-            .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n+            .filter_map(|pred| match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n                     if trait_pred.def_id() == sized_def_id =>\n                 {\n                     let span = predicates\n                         .iter()\n-                        .find_map(\n-                            |(p, span)| {\n-                                if p == obligation.predicate { Some(span) } else { None }\n-                            },\n-                        )\n+                        .find_map(|(p, span)| if p == pred { Some(span) } else { None })\n                         .unwrap_or(rustc_span::DUMMY_SP);\n                     Some((trait_pred, span))\n                 }"}, {"sha": "f3797499866acbe12c10e60f249ee4911a9d257b", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -74,44 +74,58 @@ pub struct Elaborator<'tcx> {\n pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Elaborator<'tcx> {\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n     elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate(tcx));\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n+    let predicates = trait_refs.map(move |trait_ref| trait_ref.without_const().to_predicate(tcx));\n     elaborate_predicates(tcx, predicates)\n }\n \n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let obligations = predicates\n-        .map(|predicate| {\n-            predicate_obligation(predicate, ty::ParamEnv::empty(), ObligationCause::dummy())\n-        })\n-        .collect();\n-    elaborate_obligations(tcx, obligations)\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n+    elaborate_obligations(\n+        tcx,\n+        predicates\n+            .map(|predicate| {\n+                Obligation::new(\n+                    tcx,\n+                    // We'll dump the cause/param-env later\n+                    ObligationCause::dummy(),\n+                    ty::ParamEnv::empty(),\n+                    predicate,\n+                )\n+            })\n+            .collect(),\n+    )\n+    .map(|obl| obl.predicate)\n }\n \n pub fn elaborate_predicates_with_span<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = (ty::Predicate<'tcx>, Span)>,\n-) -> Elaborator<'tcx> {\n-    let obligations = predicates\n-        .map(|(predicate, span)| {\n-            predicate_obligation(\n-                predicate,\n-                ty::ParamEnv::empty(),\n-                ObligationCause::dummy_with_span(span),\n-            )\n-        })\n-        .collect();\n-    elaborate_obligations(tcx, obligations)\n+) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n+    elaborate_obligations(\n+        tcx,\n+        predicates\n+            .map(|(predicate, span)| {\n+                Obligation::new(\n+                    tcx,\n+                    // We'll dump the cause/param-env later\n+                    ObligationCause::dummy_with_span(span),\n+                    ty::ParamEnv::empty(),\n+                    predicate,\n+                )\n+            })\n+            .collect(),\n+    )\n+    .map(|obl| (obl.predicate, obl.cause.span))\n }\n \n pub fn elaborate_obligations<'tcx>(\n@@ -141,10 +155,6 @@ impl<'tcx> Elaborator<'tcx> {\n         self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n     }\n \n-    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n-        FilterToTraits::new(self)\n-    }\n-\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n@@ -325,20 +335,18 @@ impl<'tcx> Iterator for Elaborator<'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n-\n pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    FilterToTraits::new(elaborate_trait_ref(tcx, trait_ref))\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    FilterToTraits::new(elaborate_trait_refs(tcx, trait_refs))\n }\n \n /// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n@@ -393,12 +401,12 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n-        while let Some(obligation) = self.base_iterator.next() {\n-            if let Some(data) = obligation.predicate.to_opt_poly_trait_pred() {\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let Some(data) = pred.to_opt_poly_trait_pred() {\n                 return Some(data.map_bound(|t| t.trait_ref));\n             }\n         }"}, {"sha": "42e59f92840e08d11ef08e7f8761606bae231148", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -258,11 +258,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n                     )\n-                    .find_map(|obligation| {\n+                    .find_map(|(pred, _span)| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Clause(ty::Clause::Trait(\n                             ref poly_trait_predicate,\n-                        )) = obligation.predicate.kind().skip_binder()\n+                        )) = pred.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n "}, {"sha": "e7075d5e79120fbbf78bcf2844a9aa1723a81ffa", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n-            traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n         ) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;"}, {"sha": "60401b054922a85ca1fc955210af8766024458cb", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -93,7 +93,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n-            traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n         ) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;"}, {"sha": "b2658614fd3df77ca6f1d2b37303bf6c20efce43", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -470,7 +470,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_object_bound_candidate(self, goal, assumption.predicate) {\n+            match G::consider_object_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "878c502655cf6897494364b3ab0ae8ab36d0e7bf", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -349,8 +349,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             let normalized_preds = elaborate_predicates(\n                 tcx,\n                 computed_preds.clone().chain(user_computed_preds.iter().cloned()),\n-            )\n-            .map(|o| o.predicate);\n+            );\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates_from_iter(normalized_preds),\n                 param_env.reveal(),"}, {"sha": "03ba125cf2b5f8cea70c9f1a2a4d18cdcf1d2af1", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -367,8 +367,8 @@ fn negative_impl_exists<'tcx>(\n     }\n \n     // Try to prove a negative obligation exists for super predicates\n-    for o in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n-        if resolve_negative_obligation(infcx.fork(), &o, body_def_id) {\n+    for pred in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n+        if resolve_negative_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n             return true;\n         }\n     }"}, {"sha": "672b3365ff4a9d41d694c64718d05eb149064827", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -82,15 +82,15 @@ pub fn recompute_applicable_impls<'tcx>(\n \n     let predicates =\n         tcx.predicates_of(obligation.cause.body_id.to_def_id()).instantiate_identity(tcx);\n-    for obligation in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n-        let kind = obligation.predicate.kind();\n+    for (pred, span) in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n+        let kind = pred.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = kind.skip_binder()\n             && param_env_candidate_may_apply(kind.rebind(trait_pred))\n         {\n             if kind.rebind(trait_pred.trait_ref) == ty::TraitRef::identity(tcx, trait_pred.def_id()) {\n                 ambiguities.push(Ambiguity::ParamEnv(tcx.def_span(trait_pred.def_id())))\n             } else {\n-                ambiguities.push(Ambiguity::ParamEnv(obligation.cause.span))\n+                ambiguities.push(Ambiguity::ParamEnv(span))\n             }\n         }\n     }"}, {"sha": "c19798213b70ce9ef482e6c0cc9e6a666f270d53", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -1624,8 +1624,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n \n-        for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            let bound_predicate = obligation.predicate.kind();\n+        for pred in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n+            let bound_predicate = pred.kind();\n             if let ty::PredicateKind::Clause(ty::Clause::Trait(implication)) =\n                 bound_predicate.skip_binder()\n             {"}, {"sha": "8d831dca6e3099c2508763a64e58d626227b39de", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -66,7 +66,7 @@ pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n-    SupertraitDefIds, Supertraits,\n+    SupertraitDefIds,\n };\n \n pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;\n@@ -267,9 +267,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n     let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds().into_iter())\n-            .map(|obligation| obligation.predicate)\n-            .collect();\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n "}, {"sha": "dbf6b78572a191f0285776e26fe389e93260234a", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -379,26 +379,24 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n-    elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n-        match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(ref trait_pred)) => {\n-                trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n-            }\n-            ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-            | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::AliasRelate(..)\n-            | ty::PredicateKind::Ambiguous\n-            | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n+    elaborate_predicates(tcx, predicates.into_iter()).any(|pred| match pred.kind().skip_binder() {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(ref trait_pred)) => {\n+            trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n         }\n+        ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+        | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::Coerce(..)\n+        | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::AliasRelate(..)\n+        | ty::PredicateKind::Ambiguous\n+        | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n     })\n }\n \n@@ -669,9 +667,9 @@ fn object_ty_for_trait<'tcx>(\n     debug!(?trait_predicate);\n \n     let mut elaborated_predicates: Vec<_> = elaborate_trait_ref(tcx, trait_ref)\n-        .filter_map(|obligation| {\n-            debug!(?obligation);\n-            let pred = obligation.predicate.to_opt_poly_projection_pred()?;\n+        .filter_map(|pred| {\n+            debug!(?pred);\n+            let pred = pred.to_opt_poly_projection_pred()?;\n             Some(pred.map_bound(|p| {\n                 ty::ExistentialPredicate::Projection(ty::ExistentialProjection::erase_self_ty(\n                     tcx, p,"}, {"sha": "156674e33c334c58f594cabfd3daf300e094f798", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -921,9 +921,9 @@ pub(crate) fn required_region_bounds<'tcx>(\n     assert!(!erased_self_ty.has_escaping_bound_vars());\n \n     traits::elaborate_predicates(tcx, predicates)\n-        .filter_map(|obligation| {\n-            debug!(?obligation);\n-            match obligation.predicate.kind().skip_binder() {\n+        .filter_map(|pred| {\n+            debug!(?pred);\n+            match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))"}, {"sha": "327e090d38be886e612786373c783a1620e720be", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -124,9 +124,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n             .filter(|p| !p.is_global())\n-            .filter_map(|obligation| {\n+            .filter_map(|pred| {\n                 // Note that we do not want to deal with qualified predicates here.\n-                match obligation.predicate.kind().no_bound_vars() {\n+                match pred.kind().no_bound_vars() {\n                     Some(ty::PredicateKind::Clause(ty::Clause::Trait(pred))) if pred.def_id() != sized_trait => {\n                         Some(pred)\n                     },"}, {"sha": "fd06c0b86775a12dc3fe56625a3eb96aa1e1962d", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6535e66fa545acaa3c0fe015b83a2e502c10119a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535e66fa545acaa3c0fe015b83a2e502c10119a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=6535e66fa545acaa3c0fe015b83a2e502c10119a", "patch": "@@ -2106,7 +2106,6 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n     traits::impossible_predicates(\n         cx.tcx,\n         traits::elaborate_predicates(cx.tcx, predicates)\n-            .map(|o| o.predicate)\n             .collect::<Vec<_>>(),\n     )\n }"}]}