{"sha": "c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NTA5YTQ1OTJiNjdhY2M0YTk5YTdmZmQ2ZGQ2ODhiYzZjZDI5YmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T12:27:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T12:27:15Z"}, "message": "internal: move missing_fields diagnostics", "tree": {"sha": "d174244c1e35cc91a98d1aced254a560079e48c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d174244c1e35cc91a98d1aced254a560079e48c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "html_url": "https://github.com/rust-lang/rust/commit/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efa069d28818dd074afd2c7cee776907b63ca012", "url": "https://api.github.com/repos/rust-lang/rust/commits/efa069d28818dd074afd2c7cee776907b63ca012", "html_url": "https://github.com/rust-lang/rust/commit/efa069d28818dd074afd2c7cee776907b63ca012"}], "stats": {"total": 207, "additions": 98, "deletions": 109}, "files": [{"sha": "a5e982b75b085e90372ef8b84b11483d8272bcbd", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "patch": "@@ -16,7 +16,7 @@ pub use crate::diagnostics_sink::{\n };\n \n macro_rules! diagnostics {\n-    ($($diag:ident)*) => {\n+    ($($diag:ident),*) => {\n         pub enum AnyDiagnostic {$(\n             $diag(Box<$diag>),\n         )*}\n@@ -31,7 +31,7 @@ macro_rules! diagnostics {\n     };\n }\n \n-diagnostics![UnresolvedModule];\n+diagnostics![UnresolvedModule, MissingFields];\n \n #[derive(Debug)]\n pub struct UnresolvedModule {\n@@ -321,17 +321,6 @@ impl Diagnostic for MissingUnsafe {\n     }\n }\n \n-// Diagnostic: missing-structure-fields\n-//\n-// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.\n-//\n-// Example:\n-//\n-// ```rust\n-// struct A { a: u8, b: u8 }\n-//\n-// let a = A { a: 10 };\n-// ```\n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,\n@@ -340,34 +329,6 @@ pub struct MissingFields {\n     pub missed_fields: Vec<Name>,\n }\n \n-impl Diagnostic for MissingFields {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-structure-fields\")\n-    }\n-    fn message(&self) -> String {\n-        let mut buf = String::from(\"Missing structure fields:\\n\");\n-        for field in &self.missed_fields {\n-            format_to!(buf, \"- {}\\n\", field);\n-        }\n-        buf\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile {\n-            file_id: self.file,\n-            value: self\n-                .field_list_parent_path\n-                .clone()\n-                .map(SyntaxNodePtr::from)\n-                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n-        }\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n // Diagnostic: missing-pat-fields\n //\n // This diagnostic is triggered if pattern lacks some fields that exist in the corresponding structure."}, {"sha": "583d92f2093a928c779d5af765a15fc1d6b96df7", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "patch": "@@ -609,23 +609,21 @@ impl Module {\n         }\n         for decl in self.declarations(db) {\n             match decl {\n-                crate::ModuleDef::Function(f) => f.diagnostics(db, sink, internal_diagnostics),\n-                crate::ModuleDef::Module(m) => {\n+                ModuleDef::Function(f) => acc.extend(f.diagnostics(db, sink, internal_diagnostics)),\n+                ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n                     if def_map[m.id.local_id].origin.is_inline() {\n                         acc.extend(m.diagnostics(db, sink, internal_diagnostics))\n                     }\n                 }\n-                _ => {\n-                    decl.diagnostics(db, sink);\n-                }\n+                _ => decl.diagnostics(db, sink),\n             }\n         }\n \n         for impl_def in self.impl_defs(db) {\n             for item in impl_def.items(db) {\n                 if let AssocItem::Function(f) = item {\n-                    f.diagnostics(db, sink, internal_diagnostics);\n+                    acc.extend(f.diagnostics(db, sink, internal_diagnostics));\n                 }\n             }\n         }\n@@ -1033,7 +1031,8 @@ impl Function {\n         db: &dyn HirDatabase,\n         sink: &mut DiagnosticSink,\n         internal_diagnostics: bool,\n-    ) {\n+    ) -> Vec<AnyDiagnostic> {\n+        let mut acc: Vec<AnyDiagnostic> = Vec::new();\n         let krate = self.module(db).id.krate();\n \n         let source_map = db.body_with_source_map(self.id.into()).1;\n@@ -1114,14 +1113,17 @@ impl Function {\n                                     .into_iter()\n                                     .map(|idx| variant_data.fields()[idx].name.clone())\n                                     .collect();\n-                                sink.push(MissingFields {\n-                                    file: source_ptr.file_id,\n-                                    field_list_parent: AstPtr::new(record_expr),\n-                                    field_list_parent_path: record_expr\n-                                        .path()\n-                                        .map(|path| AstPtr::new(&path)),\n-                                    missed_fields,\n-                                })\n+                                acc.push(\n+                                    MissingFields {\n+                                        file: source_ptr.file_id,\n+                                        field_list_parent: AstPtr::new(record_expr),\n+                                        field_list_parent_path: record_expr\n+                                            .path()\n+                                            .map(|path| AstPtr::new(&path)),\n+                                        missed_fields,\n+                                    }\n+                                    .into(),\n+                                )\n                             }\n                         }\n                     }\n@@ -1234,6 +1236,7 @@ impl Function {\n         for diag in hir_ty::diagnostics::validate_module_item(db, krate, self.id.into()) {\n             sink.push(diag)\n         }\n+        acc\n     }\n \n     /// Whether this function declaration has a definition."}, {"sha": "ef8c8044cd251d3a3fae59919885c2eb7290c9b5", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "patch": "@@ -5,6 +5,7 @@\n //! original files. So we need to map the ranges.\n \n mod unresolved_module;\n+mod missing_fields;\n \n mod fixes;\n mod field_shorthand;\n@@ -123,9 +124,6 @@ pub(crate) fn diagnostics(\n     }\n     let res = RefCell::new(res);\n     let sink_builder = DiagnosticSinkBuilder::new()\n-        .on::<hir::diagnostics::MissingFields, _>(|d| {\n-            res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n-        })\n         .on::<hir::diagnostics::MissingOkOrSomeInTailExpr, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n         })\n@@ -232,7 +230,8 @@ pub(crate) fn diagnostics(\n     let ctx = DiagnosticsContext { config, sema, resolve };\n     for diag in diags {\n         let d = match diag {\n-            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::render(&ctx, &d),\n+            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n+            AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n         };\n         if let Some(code) = d.code {\n             if ctx.config.disabled.contains(code.as_str()) {"}, {"sha": "a2e792b3b61a43997906e2fede40dcf8aec551d2", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "patch": "@@ -2,7 +2,6 @@\n //! The same module also has all curret custom fixes for the diagnostics implemented.\n mod change_case;\n mod create_field;\n-mod fill_missing_fields;\n mod remove_semicolon;\n mod replace_with_find_map;\n mod wrap_tail_expr;"}, {"sha": "aee780972db78b533ce638557bf695a645d01300", "filename": "crates/ide/src/diagnostics/missing_fields.rs", "status": "renamed", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs?ref=c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "patch": "@@ -1,53 +1,77 @@\n-use hir::{db::AstDatabase, diagnostics::MissingFields, Semantics};\n-use ide_assists::AssistResolveStrategy;\n-use ide_db::{source_change::SourceChange, RootDatabase};\n-use syntax::{algo, ast::make, AstNode};\n+use hir::{db::AstDatabase, InFile};\n+use ide_assists::Assist;\n+use ide_db::source_change::SourceChange;\n+use stdx::format_to;\n+use syntax::{algo, ast::make, AstNode, SyntaxNodePtr};\n use text_edit::TextEdit;\n \n-use crate::{\n-    diagnostics::{fix, fixes::DiagnosticWithFixes},\n-    Assist,\n-};\n-\n-impl DiagnosticWithFixes for MissingFields {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        // Note that although we could add a diagnostics to\n-        // fill the missing tuple field, e.g :\n-        // `struct A(usize);`\n-        // `let a = A { 0: () }`\n-        // but it is uncommon usage and it should not be encouraged.\n-        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n-            return None;\n-        }\n-\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let field_list_parent = self.field_list_parent.to_node(&root);\n-        let old_field_list = field_list_parent.record_expr_field_list()?;\n-        let new_field_list = old_field_list.clone_for_update();\n-        for f in self.missed_fields.iter() {\n-            let field =\n-                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n-                    .clone_for_update();\n-            new_field_list.add_field(field);\n-        }\n-\n-        let edit = {\n-            let mut builder = TextEdit::builder();\n-            algo::diff(old_field_list.syntax(), new_field_list.syntax())\n-                .into_text_edit(&mut builder);\n-            builder.finish()\n-        };\n-        Some(vec![fix(\n-            \"fill_missing_fields\",\n-            \"Fill struct fields\",\n-            SourceChange::from_text_edit(self.file.original_file(sema.db), edit),\n-            sema.original_range(field_list_parent.syntax()).range,\n-        )])\n+use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: missing-structure-fields\n+//\n+// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.\n+//\n+// Example:\n+//\n+// ```rust\n+// struct A { a: u8, b: u8 }\n+//\n+// let a = A { a: 10 };\n+// ```\n+pub(super) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {\n+    let mut message = String::from(\"Missing structure fields:\\n\");\n+    for field in &d.missed_fields {\n+        format_to!(message, \"- {}\\n\", field);\n     }\n+\n+    let ptr = InFile::new(\n+        d.file,\n+        d.field_list_parent_path\n+            .clone()\n+            .map(SyntaxNodePtr::from)\n+            .unwrap_or_else(|| d.field_list_parent.clone().into()),\n+    );\n+\n+    Diagnostic::new(\n+        \"missing-structure-fields\",\n+        message,\n+        ctx.sema.diagnostics_display_range(ptr).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Assist>> {\n+    // Note that although we could add a diagnostics to\n+    // fill the missing tuple field, e.g :\n+    // `struct A(usize);`\n+    // `let a = A { 0: () }`\n+    // but it is uncommon usage and it should not be encouraged.\n+    if d.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n+        return None;\n+    }\n+\n+    let root = ctx.sema.db.parse_or_expand(d.file)?;\n+    let field_list_parent = d.field_list_parent.to_node(&root);\n+    let old_field_list = field_list_parent.record_expr_field_list()?;\n+    let new_field_list = old_field_list.clone_for_update();\n+    for f in d.missed_fields.iter() {\n+        let field =\n+            make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n+                .clone_for_update();\n+        new_field_list.add_field(field);\n+    }\n+\n+    let edit = {\n+        let mut builder = TextEdit::builder();\n+        algo::diff(old_field_list.syntax(), new_field_list.syntax()).into_text_edit(&mut builder);\n+        builder.finish()\n+    };\n+    Some(vec![fix(\n+        \"fill_missing_fields\",\n+        \"Fill struct fields\",\n+        SourceChange::from_text_edit(d.file.original_file(ctx.sema.db), edit),\n+        ctx.sema.original_range(field_list_parent.syntax()).range,\n+    )])\n }\n \n #[cfg(test)]", "previous_filename": "crates/ide/src/diagnostics/fixes/fill_missing_fields.rs"}, {"sha": "4c8c74ff75174485cc406438abe1f9a263879fa1", "filename": "crates/ide/src/diagnostics/unresolved_module.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6509a4592b67acc4a99a7ffd6dd688bc6cd29be/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs?ref=c6509a4592b67acc4a99a7ffd6dd688bc6cd29be", "patch": "@@ -8,7 +8,10 @@ use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n // Diagnostic: unresolved-module\n //\n // This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n-pub(super) fn render(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedModule) -> Diagnostic {\n+pub(super) fn unresolved_module(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedModule,\n+) -> Diagnostic {\n     Diagnostic::new(\n         \"unresolved-module\",\n         \"unresolved module\","}]}