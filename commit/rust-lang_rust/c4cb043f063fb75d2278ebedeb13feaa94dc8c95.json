{"sha": "c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "node_id": "C_kwDOAAsO6NoAKGM0Y2IwNDNmMDYzZmI3NWQyMjc4ZWJlZGViMTNmZWFhOTRkYzhjOTU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-15T00:32:45Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-15T15:54:20Z"}, "message": "interpret/visitor: support visiting with a PlaceTy", "tree": {"sha": "7f834d6818d59331205148b34e37aee3fe057593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f834d6818d59331205148b34e37aee3fe057593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "html_url": "https://github.com/rust-lang/rust/commit/c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c6cccdd9b7f9c4a4fee19cf7881fbef081eda71", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c6cccdd9b7f9c4a4fee19cf7881fbef081eda71", "html_url": "https://github.com/rust-lang/rust/commit/6c6cccdd9b7f9c4a4fee19cf7881fbef081eda71"}], "stats": {"total": 316, "additions": 268, "deletions": 48}, "files": [{"sha": "8fff4571d127c4ac263f7856e50b6a28051eb990", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "patch": "@@ -436,7 +436,7 @@ fn valtree_into_mplace<'tcx>(\n \n                         let offset = place_adjusted.layout.fields.offset(i);\n                         place\n-                            .offset(\n+                            .offset_with_meta(\n                                 offset,\n                                 MemPlaceMeta::Meta(Scalar::from_machine_usize(\n                                     num_elems as u64,"}, {"sha": "22dc1e80f13a825e6a057d685614c5e635180419", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "patch": "@@ -297,15 +297,15 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n         }\n     }\n \n-    pub fn offset(\n+    pub fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         match self.try_as_mplace() {\n-            Ok(mplace) => Ok(mplace.offset(offset, meta, layout, cx)?.into()),\n+            Ok(mplace) => Ok(mplace.offset_with_meta(offset, meta, layout, cx)?.into()),\n             Err(imm) => {\n                 assert!(\n                     matches!(*imm, Immediate::Uninit),\n@@ -317,6 +317,16 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n             }\n         }\n     }\n+\n+    pub fn offset(\n+        &self,\n+        offset: Size,\n+        layout: TyAndLayout<'tcx>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Self> {\n+        assert!(!layout.is_unsized());\n+        self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n+    }\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {"}, {"sha": "4ee6ed29b1e76f97aef6f4892cf944970dfe272a", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "patch": "@@ -171,7 +171,7 @@ impl<Tag: Provenance> MemPlace<Tag> {\n     }\n \n     #[inline]\n-    pub fn offset<'tcx>(\n+    pub fn offset_with_meta<'tcx>(\n         self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n@@ -205,20 +205,30 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub fn offset(\n+    pub fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MPlaceTy {\n-            mplace: self.mplace.offset(offset, meta, cx)?,\n+            mplace: self.mplace.offset_with_meta(offset, meta, cx)?,\n             align: self.align.restrict_for_offset(offset),\n             layout,\n         })\n     }\n \n+    pub fn offset(\n+        &self,\n+        offset: Size,\n+        layout: TyAndLayout<'tcx>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Self> {\n+        assert!(!layout.is_unsized());\n+        self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n+    }\n+\n     #[inline]\n     pub fn from_aligned_ptr(ptr: Pointer<Option<Tag>>, layout: TyAndLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr), layout, align: layout.align.abi }"}, {"sha": "22ec276250fa87e101229f2f91fa343ec745dc9c", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "patch": "@@ -63,7 +63,7 @@ where\n \n         // We do not look at `base.layout.align` nor `field_layout.align`, unlike\n         // codegen -- mostly to see if we can get away with that\n-        base.offset(offset, meta, field_layout, self)\n+        base.offset_with_meta(offset, meta, field_layout, self)\n     }\n \n     /// Gets the place of a field inside the place, and also the field's type.\n@@ -193,9 +193,7 @@ where\n                 let offset = stride * index; // `Size` multiplication\n                 // All fields have the same layout.\n                 let field_layout = base.layout.field(self, 0);\n-                assert!(!field_layout.is_unsized());\n-\n-                base.offset(offset, MemPlaceMeta::None, field_layout, self)\n+                base.offset(offset, field_layout, self)\n             }\n             _ => span_bug!(\n                 self.cur_span(),\n@@ -215,10 +213,10 @@ where\n         let abi::FieldsShape::Array { stride, .. } = base.layout.fields else {\n             span_bug!(self.cur_span(), \"operand_array_fields: expected an array layout\");\n         };\n-        let layout = base.layout.field(self, 0);\n+        let field_layout = base.layout.field(self, 0);\n         let dl = &self.tcx.data_layout;\n         // `Size` multiplication\n-        Ok((0..len).map(move |i| base.offset(stride * i, MemPlaceMeta::None, layout, dl)))\n+        Ok((0..len).map(move |i| base.offset(stride * i, field_layout, dl)))\n     }\n \n     /// Index into an array.\n@@ -326,7 +324,7 @@ where\n             }\n         };\n         let layout = self.layout_of(ty)?;\n-        base.offset(from_offset, meta, layout, self)\n+        base.offset_with_meta(from_offset, meta, layout, self)\n     }\n \n     pub fn place_subslice("}, {"sha": "f6a0c19d2595332c2bff285802d5251374a5764b", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 237, "deletions": 35, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cb043f063fb75d2278ebedeb13feaa94dc8c95/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=c4cb043f063fb75d2278ebedeb13feaa94dc8c95", "patch": "@@ -8,23 +8,33 @@ use rustc_target::abi::{FieldsShape, VariantIdx, Variants};\n \n use std::num::NonZeroUsize;\n \n-use super::{InterpCx, MPlaceTy, Machine, OpTy};\n+use super::{InterpCx, MPlaceTy, Machine, OpTy, PlaceTy};\n \n-// A thing that we can project into, and that has a layout.\n-// This wouldn't have to depend on `Machine` but with the current type inference,\n-// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n+/// A thing that we can project into, and that has a layout.\n+/// This wouldn't have to depend on `Machine` but with the current type inference,\n+/// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n-    /// Makes this into an `OpTy`.\n-    fn to_op(&self, ecx: &InterpCx<'mir, 'tcx, M>)\n-    -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    /// Makes this into an `OpTy`, in a cheap way that is good for reading.\n+    fn to_op_for_read(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+\n+    /// Makes this into an `OpTy`, in a potentially more expensive way that is good for projections.\n+    fn to_op_for_proj(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        self.to_op_for_read(ecx)\n+    }\n \n     /// Creates this from an `OpTy`.\n     ///\n-    /// If `to_op` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n-    fn from_op(mplace: OpTy<'tcx, M::PointerTag>) -> Self;\n+    /// If `to_op_for_proj` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self;\n \n     /// Projects to the given enum variant.\n     fn project_downcast(\n@@ -41,25 +51,67 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     ) -> InterpResult<'tcx, Self>;\n }\n \n-// Operands and memory-places are both values.\n-// Places in general are not due to `place_field` having to do `force_allocation`.\n+/// A thing that we can project into given *mutable* access to `ecx`, and that has a layout.\n+/// This wouldn't have to depend on `Machine` but with the current type inference,\n+/// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n+pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n+    /// Gets this value's layout.\n+    fn layout(&self) -> TyAndLayout<'tcx>;\n+\n+    /// Makes this into an `OpTy`, in a cheap way that is good for reading.\n+    fn to_op_for_read(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+\n+    /// Makes this into an `OpTy`, in a potentially more expensive way that is good for projections.\n+    fn to_op_for_proj(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+\n+    /// Creates this from an `OpTy`.\n+    ///\n+    /// If `to_op_for_proj` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self;\n+\n+    /// Projects to the given enum variant.\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self>;\n+\n+    /// Projects to the n-th field.\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self>;\n+}\n+\n+// We cannot have a general impl which shows that Value implies ValueMut. (When we do, it says we\n+// cannot `impl ValueMut for PlaceTy` because some downstream crate could `impl Value for PlaceTy`.)\n+// So we have some copy-paste here. (We could have a macro but since we only have 2 types with this\n+// double-impl, that would barely make the code shorter, if at all.)\n+\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout\n     }\n \n     #[inline(always)]\n-    fn to_op(\n+    fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(*self)\n     }\n \n     #[inline(always)]\n-    fn from_op(op: OpTy<'tcx, M::PointerTag>) -> Self {\n-        op\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        *op\n     }\n \n     #[inline(always)]\n@@ -81,6 +133,54 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n     }\n }\n \n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n+    for OpTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_read(\n+        &self,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(*self)\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_proj(\n+        &self,\n+        _ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(*self)\n+    }\n+\n+    #[inline(always)]\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        *op\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.operand_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.operand_field(self, field)\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     for MPlaceTy<'tcx, M::PointerTag>\n {\n@@ -90,16 +190,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     }\n \n     #[inline(always)]\n-    fn to_op(\n+    fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n \n     #[inline(always)]\n-    fn from_op(op: OpTy<'tcx, M::PointerTag>) -> Self {\n-        // assert is justified because our `to_op` only ever produces `Indirect` operands.\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        // assert is justified because our `to_op_for_read` only ever produces `Indirect` operands.\n         op.assert_mem_place()\n     }\n \n@@ -122,11 +222,111 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     }\n }\n \n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n+    for MPlaceTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_read(\n+        &self,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(self.into())\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_proj(\n+        &self,\n+        _ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(self.into())\n+    }\n+\n+    #[inline(always)]\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        // assert is justified because our `to_op_for_proj` only ever produces `Indirect` operands.\n+        op.assert_mem_place()\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.mplace_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.mplace_field(self, field)\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n+    for PlaceTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_read(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        // We `force_allocation` here so that `from_op` below can work.\n+        ecx.place_to_op(self)\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_proj(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        // We `force_allocation` here so that `from_op` below can work.\n+        Ok(ecx.force_allocation(self)?.into())\n+    }\n+\n+    #[inline(always)]\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        // assert is justified because our `to_op` only ever produces `Indirect` operands.\n+        op.assert_mem_place().into()\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.place_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.place_field(self, field)\n+    }\n+}\n+\n macro_rules! make_value_visitor {\n-    ($visitor_trait_name:ident, $($mutability:ident)?) => {\n+    ($visitor_trait:ident, $value_trait:ident, $($mutability:ident)?) => {\n         // How to traverse a value and what to do when we are at the leaves.\n-        pub trait $visitor_trait_name<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n-            type V: Value<'mir, 'tcx, M>;\n+        pub trait $visitor_trait<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n+            type V: $value_trait<'mir, 'tcx, M>;\n \n             /// The visitor must have an `InterpCx` in it.\n             fn ecx(&$($mutability)? self)\n@@ -215,19 +415,20 @@ macro_rules! make_value_visitor {\n             }\n             fn walk_value(&mut self, v: &Self::V) -> InterpResult<'tcx>\n             {\n-                trace!(\"walk_value: type: {}\", v.layout().ty);\n+                let ty = v.layout().ty;\n+                trace!(\"walk_value: type: {ty}\");\n \n                 // Special treatment for special types, where the (static) layout is not sufficient.\n-                match *v.layout().ty.kind() {\n+                match *ty.kind() {\n                     // If it is a trait object, switch to the real type that was used to create it.\n                     ty::Dynamic(..) => {\n                         // unsized values are never immediate, so we can assert_mem_place\n-                        let op = v.to_op(self.ecx())?;\n+                        let op = v.to_op_for_read(self.ecx())?;\n                         let dest = op.assert_mem_place();\n-                        let inner = self.ecx().unpack_dyn_trait(&dest)?.1;\n-                        trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n+                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?.1;\n+                        trace!(\"walk_value: dyn object layout: {:#?}\", inner_mplace.layout);\n                         // recurse with the inner type\n-                        return self.visit_field(&v, 0, &Value::from_op(inner.into()));\n+                        return self.visit_field(&v, 0, &$value_trait::from_op(&inner_mplace.into()));\n                     },\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n@@ -278,10 +479,10 @@ macro_rules! make_value_visitor {\n \n                 // Visit the fields of this value.\n                 match v.layout().fields {\n-                    FieldsShape::Primitive => {},\n+                    FieldsShape::Primitive => {}\n                     FieldsShape::Union(fields) => {\n                         self.visit_union(v, fields)?;\n-                    },\n+                    }\n                     FieldsShape::Arbitrary { ref offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n@@ -291,16 +492,17 @@ macro_rules! make_value_visitor {\n                             })\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;\n-                    },\n+                    }\n                     FieldsShape::Array { .. } => {\n-                        // Let's get an mplace first.\n-                        let op = v.to_op(self.ecx())?;\n+                        // Let's get an mplace (or immediate) first.\n+                        // This might `force_allocate` if `v` is a `PlaceTy`, but `place_index` does that anyway.\n+                        let op = v.to_op_for_proj(self.ecx())?;\n                         // Now we can go over all the fields.\n                         // This uses the *run-time length*, i.e., if we are a slice,\n                         // the dynamic info from the metadata is used.\n                         let iter = self.ecx().operand_array_fields(&op)?\n                             .map(|f| f.and_then(|f| {\n-                                Ok(Value::from_op(f))\n+                                Ok($value_trait::from_op(&f))\n                             }));\n                         self.visit_aggregate(v, iter)?;\n                     }\n@@ -310,7 +512,7 @@ macro_rules! make_value_visitor {\n                     // If this is a multi-variant layout, find the right variant and proceed\n                     // with *its* fields.\n                     Variants::Multiple { .. } => {\n-                        let op = v.to_op(self.ecx())?;\n+                        let op = v.to_op_for_read(self.ecx())?;\n                         let idx = self.read_discriminant(&op)?;\n                         let inner = v.project_downcast(self.ecx(), idx)?;\n                         trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n@@ -325,5 +527,5 @@ macro_rules! make_value_visitor {\n     }\n }\n \n-make_value_visitor!(ValueVisitor,);\n-make_value_visitor!(MutValueVisitor, mut);\n+make_value_visitor!(ValueVisitor, Value,);\n+make_value_visitor!(MutValueVisitor, ValueMut, mut);"}]}