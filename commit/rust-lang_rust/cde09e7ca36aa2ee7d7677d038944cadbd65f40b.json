{"sha": "cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZTA5ZTdjYTM2YWEyZWU3ZDc2NzdkMDM4OTQ0Y2FkYmQ2NWY0MGI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-02T22:22:31Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-03T09:59:51Z"}, "message": "rewrite metadata indexing\n\nthis improves the compilation time for small crates by ~20%", "tree": {"sha": "96add6d859ab201eaef853b651faba3a598f2a33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96add6d859ab201eaef853b651faba3a598f2a33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "html_url": "https://github.com/rust-lang/rust/commit/cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/comments", "author": null, "committer": null, "parents": [{"sha": "fcad49e4161f2083db3ea3c3534d13d10bd130eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcad49e4161f2083db3ea3c3534d13d10bd130eb", "html_url": "https://github.com/rust-lang/rust/commit/fcad49e4161f2083db3ea3c3534d13d10bd130eb"}], "stats": {"total": 566, "additions": 322, "deletions": 244}, "files": [{"sha": "755d83bf8ec9da38e06e84986bc93f8f69fb325f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -51,7 +51,6 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(scoped_tls)]\n-#![feature(slice_bytes)]\n #![feature(slice_splits)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]"}, {"sha": "0fb55bd7907667cfc99a144ca285b20201beb734", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -45,13 +45,7 @@ pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n \n pub const tag_index: usize = 0x2a;\n \n-pub const tag_index_buckets: usize = 0x2b;\n-\n-pub const tag_index_buckets_bucket: usize = 0x2c;\n-\n-pub const tag_index_buckets_bucket_elt: usize = 0x2d;\n-\n-pub const tag_index_table: usize = 0x2e;\n+// GAP 0x2b, 0x2c, 0x2d, 0x2e\n \n pub const tag_meta_item_name_value: usize = 0x2f;\n "}, {"sha": "5ac84578369d2fc2736475c7506a2fb4797a441b", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -304,6 +304,7 @@ impl<'a> CrateReader<'a> {\n         let cmeta = Rc::new(cstore::crate_metadata {\n             name: name.to_string(),\n             local_path: RefCell::new(SmallVector::zero()),\n+            index: decoder::load_index(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n@@ -521,7 +522,7 @@ impl<'a> CrateReader<'a> {\n         }\n \n         let registrar = decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n-            .map(|id| decoder::get_symbol(ekrate.metadata.as_slice(), id));\n+            .map(|id| decoder::get_symbol_from_buf(ekrate.metadata.as_slice(), id));\n \n         match (ekrate.dylib.as_ref(), registrar) {\n             (Some(dylib), Some(reg)) => Some((dylib.to_path_buf(), reg)),"}, {"sha": "c539bfc596413a78cccb156027fde7626bdc4369", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -11,23 +11,18 @@\n // Searching for information from the cstore\n \n use front::map as ast_map;\n-use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::inline::InlinedItem;\n use middle::def_id::DefId;\n use middle::lang_items;\n use middle::ty;\n+use util::nodemap::FnvHashMap;\n \n-use rbml;\n-use rbml::reader;\n use std::rc::Rc;\n use syntax::ast;\n use rustc_front::attr;\n use rustc_front::hir;\n-use syntax::diagnostic::expect;\n-\n-use std::collections::hash_map::HashMap;\n \n #[derive(Copy, Clone)]\n pub struct MethodInfo {\n@@ -38,7 +33,7 @@ pub struct MethodInfo {\n \n pub fn get_symbol(cstore: &cstore::CStore, def: DefId) -> String {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_symbol(cdata.data(), def.node)\n+    decoder::get_symbol(&cdata, def.node)\n }\n \n /// Iterates over all the language items in the given crate.\n@@ -201,7 +196,7 @@ pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::N\n     decoder::get_struct_field_names(&cstore.intr, &*cdata, def.node)\n }\n \n-pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> HashMap<ast::NodeId,\n+pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> FnvHashMap<ast::NodeId,\n         Vec<hir::Attribute>> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_field_attrs(&*cdata)\n@@ -243,31 +238,6 @@ pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n     decoder::get_super_predicates(&*cdata, def.node, tcx)\n }\n \n-pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: DefId,\n-                            def: DefId) -> ty::TypeScheme<'tcx> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(class_id.krate);\n-    let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n-    let class_doc = expect(tcx.sess.diagnostic(),\n-                           decoder::maybe_find_item(class_id.node, all_items),\n-                           || {\n-        (format!(\"get_field_type: class ID {:?} not found\",\n-                 class_id)).to_string()\n-    });\n-    let the_field = expect(tcx.sess.diagnostic(),\n-        decoder::maybe_find_item(def.node, class_doc),\n-        || {\n-            (format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n-                    class_id,\n-                    def)).to_string()\n-        });\n-    let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n-    ty::TypeScheme {\n-        generics: ty::Generics::empty(),\n-        ty: ty,\n-    }\n-}\n-\n pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                def: DefId)\n                                -> Option<hir::ImplPolarity>"}, {"sha": "42f52b2d20b1b949151ad64c66778983b7a7efb1", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -18,7 +18,7 @@ pub use self::LinkagePreference::*;\n pub use self::NativeLibraryKind::*;\n \n use back::svh::Svh;\n-use metadata::{creader, decoder, loader};\n+use metadata::{creader, decoder, index, loader};\n use session::search_paths::PathKind;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n@@ -65,6 +65,7 @@ pub struct crate_metadata {\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub span: codemap::Span,\n     pub staged_api: bool,\n+    pub index: index::Index,\n \n     /// Flag if this crate is required by an rlib version of this crate, or in\n     /// other words whether it was explicitly linked to. An example of a crate"}, {"sha": "309a18feb9aad123750e0467b7715a61f4ef0567", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 73, "deletions": 114, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -26,6 +26,7 @@ use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::encoder::def_to_u64;\n+use metadata::index;\n use metadata::inline::InlinedItem;\n use metadata::tydecode::TyDecoder;\n use middle::def;\n@@ -37,12 +38,9 @@ use middle::ty::{self, RegionEscape, Ty};\n use util::nodemap::FnvHashMap;\n \n use std::cell::{Cell, RefCell};\n-use std::collections::HashMap;\n-use std::hash::{Hash, SipHasher, Hasher};\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n-use std::slice::bytes;\n use std::str;\n \n use rbml::reader;\n@@ -59,57 +57,24 @@ use syntax::ptr::P;\n \n pub type Cmd<'a> = &'a crate_metadata;\n \n-// A function that takes a def_id relative to the crate being searched and\n-// returns a def_id relative to the compilation environment, i.e. if we hit a\n-// def_id for an item defined in another crate, somebody needs to figure out\n-// what crate that's in and give us a def_id that makes sense for the current\n-// build.\n-\n-fn u32_from_be_bytes(bytes: &[u8]) -> u32 {\n-    let mut b = [0; 4];\n-    bytes::copy_memory(&bytes[..4], &mut b);\n-    unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n-}\n-\n-fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml::Doc<'a>> where\n-    F: FnMut(&[u8]) -> bool,\n-{\n-    let index = reader::get_doc(d, tag_index);\n-    let table = reader::get_doc(index, tag_index_table);\n-    let hash_pos = table.start + (hash % 256 * 4) as usize;\n-    let pos = u32_from_be_bytes(&d.data[hash_pos..]) as usize;\n-    let tagged_doc = reader::doc_at(d.data, pos).unwrap();\n-\n-    reader::tagged_docs(tagged_doc.doc, tag_index_buckets_bucket_elt).find(|elt| {\n-        eq_fn(&elt.data[elt.start + 4 .. elt.end])\n-    }).map(|elt| {\n-        let pos = u32_from_be_bytes(&elt.data[elt.start..]) as usize;\n-        reader::doc_at(d.data, pos).unwrap().doc\n-    })\n-}\n-\n-pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n-                           items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n-    fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n-        u32_from_be_bytes(bytes) == item_id\n+impl crate_metadata {\n+    fn get_item(&self, item_id: ast::NodeId) -> Option<rbml::Doc> {\n+        self.index.lookup_item(self.data(), item_id).map(|pos| {\n+            reader::doc_at(self.data(), pos as usize).unwrap().doc\n+        })\n     }\n-    let mut s = SipHasher::new_with_keys(0, 0);\n-    (item_id as i64).hash(&mut s);\n-    lookup_hash(items, |a| eq_item(a, item_id), s.finish())\n-}\n \n-fn find_item<'a>(item_id: ast::NodeId, items: rbml::Doc<'a>) -> rbml::Doc<'a> {\n-    match maybe_find_item(item_id, items) {\n-       None => panic!(\"lookup_item: id not found: {}\", item_id),\n-       Some(d) => d\n+    fn lookup_item(&self, item_id: ast::NodeId) -> rbml::Doc {\n+        match self.get_item(item_id) {\n+            None => panic!(\"lookup_item: id not found: {}\", item_id),\n+            Some(d) => d\n+        }\n     }\n }\n \n-// Looks up an item in the given metadata and returns an rbml doc pointing\n-// to the item data.\n-fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> rbml::Doc<'a> {\n-    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n-    find_item(item_id, items)\n+pub fn load_index(data: &[u8]) -> index::Index {\n+    let index = reader::get_doc(rbml::Doc::new(data), tag_index);\n+    index::Index::from_buf(index.data, index.start, index.end)\n }\n \n #[derive(Debug, PartialEq)]\n@@ -380,7 +345,7 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n                            item_id: ast::NodeId,\n                            tcx: &ty::ctxt<'tcx>) -> ty::TraitDef<'tcx>\n {\n-    let item_doc = lookup_item(item_id, cdata.data());\n+    let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     let unsafety = parse_unsafety(item_doc);\n     let associated_type_names = parse_associated_type_names(item_doc);\n@@ -410,7 +375,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n-            let item = lookup_item(did.node, cdata.data());\n+            let item = cdata.lookup_item(did.node);\n \n             if let Some(disr) = variant_disr_val(item) {\n                 disr_val = disr;\n@@ -459,7 +424,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         }\n     }\n \n-    let doc = lookup_item(item_id, cdata.data());\n+    let doc = cdata.lookup_item(item_id);\n     let did = DefId { krate: cdata.cnum, node: item_id };\n     let (kind, variants) = match item_family(doc) {\n         Enum => (ty::AdtKind::Enum,\n@@ -516,7 +481,7 @@ pub fn get_predicates<'tcx>(cdata: Cmd,\n                             tcx: &ty::ctxt<'tcx>)\n                             -> ty::GenericPredicates<'tcx>\n {\n-    let item_doc = lookup_item(item_id, cdata.data());\n+    let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n }\n \n@@ -525,14 +490,14 @@ pub fn get_super_predicates<'tcx>(cdata: Cmd,\n                                   tcx: &ty::ctxt<'tcx>)\n                                   -> ty::GenericPredicates<'tcx>\n {\n-    let item_doc = lookup_item(item_id, cdata.data());\n+    let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n                       -> ty::TypeScheme<'tcx>\n {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     let t = item_type(DefId { krate: cdata.cnum, node: id }, item_doc, tcx,\n                       cdata);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n@@ -543,15 +508,15 @@ pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n }\n \n pub fn get_stability(cdata: Cmd, id: ast::NodeId) -> Option<attr::Stability> {\n-    let item = lookup_item(id, cdata.data());\n+    let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_stability).map(|doc| {\n         let mut decoder = reader::Decoder::new(doc);\n         Decodable::decode(&mut decoder).unwrap()\n     })\n }\n \n pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n-    let item = lookup_item(id, cdata.data());\n+    let item = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {\n         let mut decoder = reader::Decoder::new(doc);\n         Decodable::decode(&mut decoder).unwrap()\n@@ -565,7 +530,7 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n                                id: ast::NodeId)\n                                -> Option<hir::ImplPolarity>\n {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     let fam = item_family(item_doc);\n     match fam {\n         Family::Impl => {\n@@ -578,7 +543,7 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n pub fn get_custom_coerce_unsized_kind<'tcx>(cdata: Cmd,\n                                             id: ast::NodeId)\n                                             -> Option<ty::CustomCoerceUnsized> {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n         let mut decoder = reader::Decoder::new(kind_doc);\n         Decodable::decode(&mut decoder).unwrap()\n@@ -590,7 +555,7 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             tcx: &ty::ctxt<'tcx>)\n                             -> Option<ty::TraitRef<'tcx>>\n {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     let fam = item_family(item_doc);\n     match fam {\n         Family::Impl | Family::DefaultImpl => {\n@@ -602,8 +567,16 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n-    return item_symbol(lookup_item(id, data));\n+pub fn get_symbol(cdata: Cmd, id: ast::NodeId) -> String {\n+    return item_symbol(cdata.lookup_item(id));\n+}\n+\n+/// If you have a crate_metadata, call get_symbol instead\n+pub fn get_symbol_from_buf(data: &[u8], id: ast::NodeId) -> String {\n+    let index = load_index(data);\n+    let pos = index.lookup_item(data, id).unwrap();\n+    let doc = reader::doc_at(data, pos as usize).unwrap().doc;\n+    item_symbol(doc)\n }\n \n // Something that a name can resolve to.\n@@ -655,10 +628,8 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(rbml::Doc::new(crate_data.data()), tag_items);\n-\n         // Get the item.\n-        match maybe_find_item(child_def_id.node, other_crates_items) {\n+        match crate_data.get_item(child_def_id.node) {\n             None => {}\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n@@ -676,13 +647,12 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     for inherent_impl_def_id_doc in reader::tagged_docs(item_doc,\n                                                              tag_items_data_item_inherent_impl) {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc, cdata);\n-        let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n-        if let Some(inherent_impl_doc) = maybe_find_item(inherent_impl_def_id.node, items) {\n+        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.node) {\n             for impl_item_def_id_doc in reader::tagged_docs(inherent_impl_doc,\n                                                                  tag_item_impl_item) {\n                 let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n                                                    cdata);\n-                if let Some(impl_method_doc) = maybe_find_item(impl_item_def_id.node, items) {\n+                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.node) {\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n                         let static_method_name = item_name(&*intr, impl_method_doc);\n@@ -717,10 +687,8 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(rbml::Doc::new(crate_data.data()), tag_items);\n-\n         // Get the item.\n-        if let Some(child_item_doc) = maybe_find_item(child_def_id.node, other_crates_items) {\n+        if let Some(child_item_doc) = crate_data.get_item(child_def_id.node) {\n             // Hand off the item to the callback.\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n@@ -740,9 +708,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Find the item.\n-    let root_doc = rbml::Doc::new(cdata.data());\n-    let items = reader::get_doc(root_doc, tag_items);\n-    let item_doc = match maybe_find_item(id, items) {\n+    let item_doc = match cdata.get_item(id) {\n         None => return,\n         Some(item_doc) => item_doc,\n     };\n@@ -775,11 +741,11 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n }\n \n pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n-    item_path(lookup_item(id, cdata.data()))\n+    item_path(cdata.lookup_item(id))\n }\n \n pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId) -> ast::Name {\n-    item_name(intr, lookup_item(id, cdata.data()))\n+    item_name(intr, cdata.lookup_item(id))\n }\n \n pub type DecodeInlinedItem<'a> =\n@@ -793,14 +759,14 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n                                 mut decode_inlined_item: DecodeInlinedItem)\n                                 -> csearch::FoundAst<'tcx> {\n     debug!(\"Looking up item: {}\", id);\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     let path = item_path(item_doc).split_last().unwrap().1.to_vec();\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n         Err(path) => {\n             match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n-                    let parent_item = lookup_item(did.node, cdata.data());\n+                    let parent_item = cdata.lookup_item(did.node);\n                     match decode_inlined_item(cdata, tcx, path, parent_item) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n                         Err(_) => csearch::FoundAst::NotFound\n@@ -842,7 +808,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n /// Returns the def IDs of all the items in the given implementation.\n pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n-    reader::tagged_docs(lookup_item(impl_id, cdata.data()), tag_item_impl_item).map(|doc| {\n+    reader::tagged_docs(cdata.lookup_item(impl_id), tag_item_impl_item).map(|doc| {\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n             Some('C') => ty::ConstTraitItemId(def_id),\n@@ -857,12 +823,12 @@ pub fn get_trait_name(intr: Rc<IdentInterner>,\n                       cdata: Cmd,\n                       id: ast::NodeId)\n                       -> ast::Name {\n-    let doc = lookup_item(id, cdata.data());\n+    let doc = cdata.lookup_item(id);\n     item_name(&*intr, doc)\n }\n \n pub fn is_static_method(cdata: Cmd, id: ast::NodeId) -> bool {\n-    let doc = lookup_item(id, cdata.data());\n+    let doc = cdata.lookup_item(id);\n     match item_sort(doc) {\n         Some('r') | Some('p') => {\n             get_explicit_self(doc) == ty::StaticExplicitSelfCategory\n@@ -876,12 +842,12 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                     id: ast::NodeId,\n                                     tcx: &ty::ctxt<'tcx>)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n \n     let def_id = item_def_id(item_doc, cdata);\n \n     let container_id = item_require_parent_item(cdata, item_doc);\n-    let container_doc = lookup_item(container_id.node, cdata.data());\n+    let container_doc = cdata.lookup_item(container_id.node);\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n@@ -936,8 +902,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n \n pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n                               -> Vec<ty::ImplOrTraitItemId> {\n-    let data = cdata.data();\n-    let item = lookup_item(id, data);\n+    let item = cdata.lookup_item(id);\n     reader::tagged_docs(item, tag_item_trait_item).map(|mth| {\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n@@ -950,8 +915,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n }\n \n pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n-    let data = cdata.data();\n-    let item_doc = lookup_item(id, data);\n+    let item_doc = cdata.lookup_item(id);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder::new(variance_doc);\n     Decodable::decode(&mut decoder).unwrap()\n@@ -962,12 +926,11 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                         id: ast::NodeId,\n                                         tcx: &ty::ctxt<'tcx>)\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n-    let data = cdata.data();\n-    let item = lookup_item(id, data);\n+    let item = cdata.lookup_item(id);\n \n     reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n         let did = item_def_id(mth_id, cdata);\n-        let mth = lookup_item(did.node, data);\n+        let mth = cdata.lookup_item(did.node);\n \n         if item_sort(mth) == Some('p') {\n             let trait_item = get_impl_or_trait_item(intr.clone(),\n@@ -990,13 +953,12 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n                                    id: ast::NodeId,\n                                    tcx: &ty::ctxt<'tcx>)\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n-    let data = cdata.data();\n-    let item = lookup_item(id, data);\n+    let item = cdata.lookup_item(id);\n \n     [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n         reader::tagged_docs(item, tag).filter_map(|ac_id| {\n             let did = item_def_id(ac_id, cdata);\n-            let ac_doc = lookup_item(did.node, data);\n+            let ac_doc = cdata.lookup_item(did.node);\n \n             if item_sort(ac_doc) == Some('C') {\n                 let trait_item = get_impl_or_trait_item(intr.clone(),\n@@ -1017,7 +979,7 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n \n pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::Name> {\n-    let item = lookup_item(node_id, cdata.data());\n+    let item = cdata.lookup_item(node_id);\n     if item_family(item) != Impl {\n         return None;\n     }\n@@ -1031,7 +993,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n                                   cdata: Cmd,\n                                   node_id: ast::NodeId)\n                                -> Option<Vec<MethodInfo> > {\n-    let item = lookup_item(node_id, cdata.data());\n+    let item = cdata.lookup_item(node_id);\n     if item_family(item) != Impl {\n         return None;\n     }\n@@ -1046,7 +1008,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n \n     let mut impl_methods = Vec::new();\n     for impl_method_id in impl_method_ids {\n-        let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n+        let impl_method_doc = cdata.lookup_item(impl_method_id.node);\n         let family = item_family(impl_method_doc);\n         match family {\n             StaticMethod | Method => {\n@@ -1069,7 +1031,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n                                            node_id: ast::NodeId)\n     -> Option<DefId>\n {\n-    let item = lookup_item(node_id, cdata.data());\n+    let item = cdata.lookup_item(node_id);\n     reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor).next().map(|_| {\n         item_require_parent_item(cdata, item)\n     })\n@@ -1083,11 +1045,11 @@ pub fn get_item_attrs(cdata: Cmd,\n     // look at the definition\n     let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n     let node_id = node_id.map(|x| x.node).unwrap_or(orig_node_id);\n-    let item = lookup_item(node_id, cdata.data());\n+    let item = cdata.lookup_item(node_id);\n     get_attributes(item)\n }\n \n-pub fn get_struct_field_attrs(cdata: Cmd) -> HashMap<ast::NodeId, Vec<hir::Attribute>> {\n+pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<ast::NodeId, Vec<hir::Attribute>> {\n     let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n     reader::tagged_docs(fields, tag_struct_field).map(|field| {\n@@ -1107,8 +1069,7 @@ fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n \n pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId)\n     -> Vec<ast::Name> {\n-    let data = cdata.data();\n-    let item = lookup_item(id, data);\n+    let item = cdata.lookup_item(id);\n     reader::tagged_docs(item, tag_item_field).map(|an_item| {\n         item_name(intr, an_item)\n     }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n@@ -1299,7 +1260,7 @@ pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n                                                 mut callback: F)\n     where F: FnMut(DefId),\n {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl) {\n         if reader::maybe_get_doc(impl_doc, tag_item_trait_ref).is_none() {\n             callback(item_def_id(impl_doc, cdata));\n@@ -1313,7 +1274,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     F: FnMut(DefId),\n {\n     if cdata.cnum == def_id.krate {\n-        let item_doc = lookup_item(def_id.node, cdata.data());\n+        let item_doc = cdata.lookup_item(def_id.node);\n         for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_extension_impl) {\n             callback(item_def_id(impl_doc, cdata));\n         }\n@@ -1337,12 +1298,12 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n \n pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                          -> Option<DefId> {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_doc = lookup_item(parent_item_id.node, cdata.data());\n+    let parent_item_doc = cdata.lookup_item(parent_item_id.node);\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n         Impl | DefaultImpl => {\n@@ -1423,7 +1384,7 @@ pub fn get_missing_lang_items(cdata: Cmd)\n }\n \n pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n-    let method_doc = lookup_item(id, cdata.data());\n+    let method_doc = cdata.lookup_item(id);\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n         Some(args_doc) => {\n             reader::tagged_docs(args_doc, tag_method_argument_name).map(|name_doc| {\n@@ -1446,23 +1407,23 @@ pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n }\n \n pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {\n         Type => true,\n         _ => false,\n     }\n }\n \n pub fn is_const_fn(cdata: Cmd, id: ast::NodeId) -> bool {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     match fn_constness(item_doc) {\n         hir::Constness::Const => true,\n         hir::Constness::NotConst => false,\n     }\n }\n \n pub fn is_impl(cdata: Cmd, id: ast::NodeId) -> bool {\n-    let item_doc = lookup_item(id, cdata.data());\n+    let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {\n         Impl => true,\n         _ => false,\n@@ -1543,14 +1504,14 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n }\n \n pub fn is_defaulted_trait(cdata: Cmd, trait_id: ast::NodeId) -> bool {\n-    let trait_doc = lookup_item(trait_id, cdata.data());\n+    let trait_doc = cdata.lookup_item(trait_id);\n     assert!(item_family(trait_doc) == Family::Trait);\n     let defaulted_doc = reader::get_doc(trait_doc, tag_defaulted_trait);\n     reader::doc_as_u8(defaulted_doc) != 0\n }\n \n pub fn is_default_impl(cdata: Cmd, impl_id: ast::NodeId) -> bool {\n-    let impl_doc = lookup_item(impl_id, cdata.data());\n+    let impl_doc = cdata.lookup_item(impl_id);\n     item_family(impl_doc) == Family::DefaultImpl\n }\n \n@@ -1565,9 +1526,7 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n }\n \n pub fn is_extern_fn(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt) -> bool {\n-    let root_doc = rbml::Doc::new(cdata.data());\n-    let items = reader::get_doc(root_doc, tag_items);\n-    let item_doc = match maybe_find_item(id, items) {\n+    let item_doc = match cdata.get_item(id) {\n         Some(doc) => doc,\n         None => return false,\n     };"}, {"sha": "ff24541692eccfd6ceaa80fdf368d628c6f30eac", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 87, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -19,6 +19,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n+use metadata::index::{self, IndexEntry};\n use metadata::inline::InlinedItemRef;\n use middle::def;\n use middle::def_id::{DefId, LOCAL_CRATE};\n@@ -29,7 +30,6 @@ use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n-use std::hash::{Hash, Hasher, SipHasher};\n use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n@@ -86,12 +86,6 @@ fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n     rbml_w.wr_tagged_u64(tag_def_id, def_to_u64(id));\n }\n \n-#[derive(Clone)]\n-struct entry<T> {\n-    val: T,\n-    pos: u64\n-}\n-\n fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n                               trait_ref: ty::TraitRef<'tcx>,\n@@ -279,7 +273,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             rbml_w: &mut Encoder,\n                             id: NodeId,\n                             vis: ast::Visibility,\n-                            index: &mut Vec<entry<i64>>) {\n+                            index: &mut Vec<IndexEntry>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n@@ -296,8 +290,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             }\n         }\n \n-        index.push(entry {\n-            val: vid.node as i64,\n+        index.push(IndexEntry {\n+            node: vid.node,\n             pos: rbml_w.mark_stable_position(),\n         });\n         rbml_w.start_tag(tag_items_data_item);\n@@ -625,13 +619,13 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           field: ty::FieldDef<'tcx>,\n-                          global_index: &mut Vec<entry<i64>>) {\n+                          global_index: &mut Vec<IndexEntry>) {\n     let nm = field.name;\n     let id = field.did.node;\n \n     let pos = rbml_w.mark_stable_position();\n-    global_index.push(entry {\n-        val: id as i64,\n+    global_index.push(IndexEntry {\n+        node: id,\n         pos: pos,\n     });\n     rbml_w.start_tag(tag_items_data_item);\n@@ -651,10 +645,10 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                rbml_w: &mut Encoder,\n                                name: Name,\n                                ctor_id: NodeId,\n-                               index: &mut Vec<entry<i64>>,\n+                               index: &mut Vec<IndexEntry>,\n                                struct_id: NodeId) {\n-    index.push(entry {\n-        val: ctor_id as i64,\n+    index.push(IndexEntry {\n+        node: ctor_id,\n         pos: rbml_w.mark_stable_position(),\n     });\n \n@@ -989,15 +983,15 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n fn encode_info_for_item(ecx: &EncodeContext,\n                         rbml_w: &mut Encoder,\n                         item: &ast::Item,\n-                        index: &mut Vec<entry<i64>>,\n+                        index: &mut Vec<IndexEntry>,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index(item: &ast::Item, rbml_w: &mut Encoder,\n-                    index: &mut Vec<entry<i64>>) {\n-        index.push(entry {\n-            val: item.id as i64,\n+                    index: &mut Vec<IndexEntry>) {\n+        index.push(IndexEntry {\n+            node: item.id,\n             pos: rbml_w.mark_stable_position(),\n         });\n     }\n@@ -1261,8 +1255,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 None\n             };\n \n-            index.push(entry {\n-                val: trait_item_def_id.def_id().node as i64,\n+            index.push(IndexEntry {\n+                node: trait_item_def_id.def_id().node,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n@@ -1352,8 +1346,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-            index.push(entry {\n-                val: item_def_id.def_id().node as i64,\n+            index.push(IndexEntry {\n+                node: item_def_id.def_id().node,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n@@ -1474,11 +1468,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 rbml_w: &mut Encoder,\n                                 nitem: &ast::ForeignItem,\n-                                index: &mut Vec<entry<i64>>,\n+                                index: &mut Vec<IndexEntry>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n-    index.push(entry {\n-        val: nitem.id as i64,\n+    index.push(IndexEntry {\n+        node: nitem.id,\n         pos: rbml_w.mark_stable_position(),\n     });\n \n@@ -1522,7 +1516,7 @@ fn my_visit_expr(_e: &ast::Expr) { }\n fn my_visit_item(i: &ast::Item,\n                  rbml_w: &mut Encoder,\n                  ecx: &EncodeContext,\n-                 index: &mut Vec<entry<i64>>) {\n+                 index: &mut Vec<IndexEntry>) {\n     ecx.tcx.map.with_path(i.id, |path| {\n         encode_info_for_item(ecx, rbml_w, i, index, path, i.vis);\n     });\n@@ -1531,7 +1525,7 @@ fn my_visit_item(i: &ast::Item,\n fn my_visit_foreign_item(ni: &ast::ForeignItem,\n                          rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n-                         index: &mut Vec<entry<i64>>) {\n+                         index: &mut Vec<IndexEntry>) {\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n             ni.ident);\n@@ -1547,7 +1541,7 @@ fn my_visit_foreign_item(ni: &ast::ForeignItem,\n struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx: &'a EncodeContext<'c,'tcx>,\n-    index: &'a mut Vec<entry<i64>>,\n+    index: &'a mut Vec<IndexEntry>,\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n@@ -1574,11 +1568,11 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n fn encode_info_for_items(ecx: &EncodeContext,\n                          rbml_w: &mut Encoder,\n                          krate: &ast::Crate)\n-                         -> Vec<entry<i64>> {\n+                         -> Vec<IndexEntry> {\n     let mut index = Vec::new();\n     rbml_w.start_tag(tag_items_data);\n-    index.push(entry {\n-        val: CRATE_NODE_ID as i64,\n+    index.push(IndexEntry {\n+        node: CRATE_NODE_ID,\n         pos: rbml_w.mark_stable_position(),\n     });\n     encode_info_for_mod(ecx,\n@@ -1601,62 +1595,13 @@ fn encode_info_for_items(ecx: &EncodeContext,\n }\n \n \n-// Path and definition ID indexing\n \n-fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n-    F: FnMut(&mut Cursor<Vec<u8>>, &T),\n-    T: Hash,\n-{\n-    let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n-    for elt in index {\n-        let mut s = SipHasher::new();\n-        elt.val.hash(&mut s);\n-        let h = s.finish() as usize;\n-        (&mut buckets[h % 256]).push(elt);\n-    }\n \n+fn encode_index(rbml_w: &mut Encoder, index: Vec<IndexEntry>)\n+{\n     rbml_w.start_tag(tag_index);\n-    let mut bucket_locs = Vec::new();\n-    rbml_w.start_tag(tag_index_buckets);\n-    for bucket in &buckets {\n-        bucket_locs.push(rbml_w.mark_stable_position());\n-        rbml_w.start_tag(tag_index_buckets_bucket);\n-        for elt in bucket {\n-            rbml_w.start_tag(tag_index_buckets_bucket_elt);\n-            assert!(elt.pos < 0xffff_ffff);\n-            {\n-                let wr: &mut Cursor<Vec<u8>> = rbml_w.writer;\n-                write_be_u32(wr, elt.pos as u32);\n-            }\n-            write_fn(rbml_w.writer, &elt.val);\n-            rbml_w.end_tag();\n-        }\n-        rbml_w.end_tag();\n-    }\n+    index::write_index(index, rbml_w.writer);\n     rbml_w.end_tag();\n-    rbml_w.start_tag(tag_index_table);\n-    for pos in &bucket_locs {\n-        assert!(*pos < 0xffff_ffff);\n-        let wr: &mut Cursor<Vec<u8>> = rbml_w.writer;\n-        write_be_u32(wr, *pos as u32);\n-    }\n-    rbml_w.end_tag();\n-    rbml_w.end_tag();\n-}\n-\n-fn write_i64(writer: &mut Cursor<Vec<u8>>, &n: &i64) {\n-    let wr: &mut Cursor<Vec<u8>> = writer;\n-    assert!(n < 0x7fff_ffff);\n-    write_be_u32(wr, n as u32);\n-}\n-\n-fn write_be_u32(w: &mut Write, u: u32) {\n-    w.write_all(&[\n-        (u >> 24) as u8,\n-        (u >> 16) as u8,\n-        (u >>  8) as u8,\n-        (u >>  0) as u8,\n-    ]);\n }\n \n fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n@@ -2160,11 +2105,11 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     let items_index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n     stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    rbml_w.end_tag();\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_index(&mut rbml_w, items_index, write_i64);\n+    encode_index(&mut rbml_w, items_index);\n     stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n-    rbml_w.end_tag();\n \n     encode_struct_field_attrs(&mut rbml_w, krate);\n "}, {"sha": "b02a9022a7a6e835f37f24592cb8ab24a34afce9", "filename": "src/librustc/metadata/index.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Findex.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::{Cursor, Write};\n+use std::slice;\n+use std::u32;\n+use syntax::ast::NodeId;\n+\n+#[derive(Copy, Clone, PartialEq, PartialOrd, Eq, Ord)]\n+pub struct IndexEntry {\n+    pub node: NodeId,\n+    pub pos: u64\n+}\n+\n+#[derive(Debug)]\n+pub struct IndexArrayEntry {\n+    bits: u32,\n+    first_pos: u32\n+}\n+\n+impl IndexArrayEntry {\n+    fn encode_to<W: Write>(&self, b: &mut W) {\n+        write_be_u32(b, self.bits);\n+        write_be_u32(b, self.first_pos);\n+    }\n+\n+    fn decode_from(b: &[u32]) -> Self {\n+        IndexArrayEntry {\n+            bits: b[0].to_be(),\n+            first_pos: b[1].to_be()\n+        }\n+    }\n+}\n+\n+/// The Item Index\n+///\n+/// This index maps the NodeId of each item to its location in the\n+/// metadata.\n+///\n+/// The index is a sparse bit-vector consisting of a index-array\n+/// and a position-array. Each entry in the index-array handles 32 nodes.\n+/// The first word is a bit-array consisting of the nodes that hold items,\n+/// the second is the index of the first of the items in the position-array.\n+/// If there is a large set of non-item trailing nodes, they can be omitted\n+/// from the index-array.\n+///\n+/// The index is serialized as an array of big-endian 32-bit words.\n+/// The first word is the number of items in the position-array.\n+/// Then, for each item, its position in the metadata follows.\n+/// After that the index-array is stored.\n+///\n+/// struct index {\n+///     u32 item_count;\n+///     u32 items[self.item_count];\n+///     struct { u32 bits; u32 offset; } positions[..];\n+/// }\n+pub struct Index {\n+    position_start: usize,\n+    index_start: usize,\n+    index_end: usize,\n+}\n+\n+pub fn write_index(mut entries: Vec<IndexEntry>, buf: &mut Cursor<Vec<u8>>) {\n+    assert!(entries.len() < u32::MAX as usize);\n+    entries.sort();\n+\n+    let mut last_entry = IndexArrayEntry { bits: 0, first_pos: 0 };\n+\n+    write_be_u32(buf, entries.len() as u32);\n+    for &IndexEntry { pos, .. } in &entries {\n+        assert!(pos < u32::MAX as u64);\n+        write_be_u32(buf, pos as u32);\n+    }\n+\n+    let mut pos_in_index_array = 0;\n+    for (i, &IndexEntry { node, .. }) in entries.iter().enumerate() {\n+        let (x, s) = (node / 32 as u32, node % 32 as u32);\n+        while x > pos_in_index_array {\n+            pos_in_index_array += 1;\n+            last_entry.encode_to(buf);\n+            last_entry = IndexArrayEntry { bits: 0, first_pos: i as u32 };\n+        }\n+        last_entry.bits |= 1<<s;\n+    }\n+    last_entry.encode_to(buf);\n+\n+    info!(\"write_index: {} items, {} array entries\",\n+          entries.len(), pos_in_index_array);\n+}\n+\n+impl Index {\n+    fn lookup_index(&self, index: &[u32], i: u32) -> Option<IndexArrayEntry> {\n+        let ix = (i as usize)*2;\n+        if ix >= index.len() {\n+            None\n+        } else {\n+            Some(IndexArrayEntry::decode_from(&index[ix..ix+2]))\n+        }\n+    }\n+\n+    fn item_from_pos(&self, positions: &[u32], pos: u32) -> u32 {\n+        positions[pos as usize].to_be()\n+    }\n+\n+    #[inline(never)]\n+    pub fn lookup_item(&self, buf: &[u8], node: NodeId) -> Option<u32> {\n+        let index = bytes_to_words(&buf[self.index_start..self.index_end]);\n+        let positions = bytes_to_words(&buf[self.position_start..self.index_start]);\n+        let (x, s) = (node / 32 as u32, node % 32 as u32);\n+        let result = match self.lookup_index(index, x) {\n+            Some(IndexArrayEntry { bits, first_pos }) => {\n+                let bit = 1<<s;\n+                if bits & bit == 0 {\n+                    None\n+                } else {\n+                    let prev_nodes_for_entry = (bits&(bit-1)).count_ones();\n+                    Some(self.item_from_pos(\n+                        positions,\n+                        first_pos+prev_nodes_for_entry))\n+                }\n+            }\n+            None => None // trailing zero\n+        };\n+        debug!(\"lookup_item({:?}) = {:?}\", node, result);\n+        result\n+    }\n+\n+    pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n+        let buf = bytes_to_words(&buf[start..end]);\n+        let position_count = buf[0].to_be() as usize;\n+        let position_len = position_count*4;\n+        info!(\"loaded index - position: {}-{}-{}\", start, start+position_len, end);\n+        debug!(\"index contents are {:?}\",\n+               buf.iter().map(|b| format!(\"{:08x}\", b)).collect::<Vec<_>>().concat());\n+        assert!(end-4-start >= position_len);\n+        assert_eq!((end-4-start-position_len)%8, 0);\n+        Index {\n+            position_start: start+4,\n+            index_start: start+position_len+4,\n+            index_end: end\n+        }\n+    }\n+}\n+\n+fn write_be_u32<W: Write>(w: &mut W, u: u32) {\n+    let _ = w.write_all(&[\n+        (u >> 24) as u8,\n+        (u >> 16) as u8,\n+        (u >>  8) as u8,\n+        (u >>  0) as u8,\n+    ]);\n+}\n+\n+fn bytes_to_words(b: &[u8]) -> &[u32] {\n+    assert!(b.len() % 4 == 0);\n+    unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len()/4) }\n+}\n+\n+#[test]\n+fn test_index() {\n+    let entries = vec![\n+        IndexEntry { node: 0, pos: 17 },\n+        IndexEntry { node: 31, pos: 29 },\n+        IndexEntry { node: 32, pos: 1175 },\n+        IndexEntry { node: 191, pos: 21 },\n+        IndexEntry { node: 128, pos: 34 },\n+        IndexEntry { node: 145, pos: 70 },\n+        IndexEntry { node: 305, pos: 93214 },\n+        IndexEntry { node: 138, pos: 64 },\n+        IndexEntry { node: 129, pos: 53 },\n+        IndexEntry { node: 192, pos: 33334 },\n+        IndexEntry { node: 200, pos: 80123 },\n+    ];\n+    let mut c = Cursor::new(vec![]);\n+    write_index(entries.clone(), &mut c);\n+    let mut buf = c.into_inner();\n+    let expected: &[u8] = &[\n+        0, 0, 0, 11, // # entries\n+        // values:\n+        0,0,0,17, 0,0,0,29, 0,0,4,151, 0,0,0,34,\n+        0,0,0,53, 0,0,0,64, 0,0,0,70, 0,0,0,21,\n+        0,0,130,54, 0,1,56,251, 0,1,108,30,\n+        // index:\n+        128,0,0,1,0,0,0,0, 0,0,0,1,0,0,0,2,\n+        0,0,0,0,0,0,0,3,   0,0,0,0,0,0,0,3,\n+        0,2,4,3,0,0,0,3,   128,0,0,0,0,0,0,7,\n+        0,0,1,1,0,0,0,8,   0,0,0,0,0,0,0,10,\n+        0,0,0,0,0,0,0,10,  0,2,0,0,0,0,0,10\n+    ];\n+    assert_eq!(buf, expected);\n+\n+    // insert some junk padding\n+    for i in 0..17 { buf.insert(0, i); buf.push(i) }\n+    let index = Index::from_buf(&buf, 17, buf.len()-17);\n+\n+    // test round-trip\n+    for i in 0..4096 {\n+        assert_eq!(index.lookup_item(&buf, i),\n+                   entries.iter().find(|e| e.node == i).map(|n| n.pos as u32));\n+    }\n+}"}, {"sha": "e532388d52ed8a4788ea98143cd945e17ef40cbe", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde09e7ca36aa2ee7d7677d038944cadbd65f40b/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=cde09e7ca36aa2ee7d7677d038944cadbd65f40b", "patch": "@@ -16,6 +16,7 @@ pub mod decoder;\n pub mod creader;\n pub mod cstore;\n pub mod csearch;\n+pub mod index;\n pub mod loader;\n pub mod filesearch;\n pub mod macro_import;"}]}