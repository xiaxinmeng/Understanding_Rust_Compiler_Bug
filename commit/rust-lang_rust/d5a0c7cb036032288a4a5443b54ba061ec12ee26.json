{"sha": "d5a0c7cb036032288a4a5443b54ba061ec12ee26", "node_id": "C_kwDOAAsO6NoAKGQ1YTBjN2NiMDM2MDMyMjg4YTRhNTQ0M2I1NGJhMDYxZWMxMmVlMjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-15T06:55:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-15T06:55:01Z"}, "message": "Auto merge of #90645 - terrarier2111:master, r=estebank\n\nImplement diagnostic for String conversion\n\nThis is my first real contribution to rustc, any feedback is highly appreciated.\nThis should fix https://github.com/rust-lang/rust/issues/89856\n\nThanks to `@estebank` for guiding me.", "tree": {"sha": "d723172ea55478cc6290b7bd35aca9625e6c8b74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d723172ea55478cc6290b7bd35aca9625e6c8b74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5a0c7cb036032288a4a5443b54ba061ec12ee26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a0c7cb036032288a4a5443b54ba061ec12ee26", "html_url": "https://github.com/rust-lang/rust/commit/d5a0c7cb036032288a4a5443b54ba061ec12ee26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5a0c7cb036032288a4a5443b54ba061ec12ee26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42054811104bb005ded241ea8846ba7383921c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/42054811104bb005ded241ea8846ba7383921c46", "html_url": "https://github.com/rust-lang/rust/commit/42054811104bb005ded241ea8846ba7383921c46"}, {"sha": "829a5288ec5e33f10e6f5fe2dc891a037d125e6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/829a5288ec5e33f10e6f5fe2dc891a037d125e6c", "html_url": "https://github.com/rust-lang/rust/commit/829a5288ec5e33f10e6f5fe2dc891a037d125e6c"}], "stats": {"total": 121, "additions": 85, "deletions": 36}, "files": [{"sha": "6c7d3a0c9c0bb1af96ea9e805b5d57b88ab2ea09", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d5a0c7cb036032288a4a5443b54ba061ec12ee26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a0c7cb036032288a4a5443b54ba061ec12ee26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=d5a0c7cb036032288a4a5443b54ba061ec12ee26", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Binder, Ty};\n use rustc_span::symbol::{kw, sym};\n \n+use rustc_middle::ty::subst::GenericArgKind;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -232,48 +233,72 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let is_struct_pat_shorthand_field =\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n-            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n-                let mut suggestions = iter::zip(iter::repeat(&expr_text), &methods)\n-                    .filter_map(|(receiver, method)| {\n-                        let method_call = format!(\".{}()\", method.ident);\n-                        if receiver.ends_with(&method_call) {\n-                            None // do not suggest code that is already there (#53348)\n-                        } else {\n-                            let method_call_list = [\".to_vec()\", \".to_string()\"];\n-                            let mut sugg = if receiver.ends_with(\".clone()\")\n-                                && method_call_list.contains(&method_call.as_str())\n-                            {\n-                                let max_len = receiver.rfind('.').unwrap();\n-                                vec![(\n-                                    expr.span,\n-                                    format!(\"{}{}\", &receiver[..max_len], method_call),\n-                                )]\n+            if !methods.is_empty() {\n+                if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n+                    let mut suggestions = iter::zip(iter::repeat(&expr_text), &methods)\n+                        .filter_map(|(receiver, method)| {\n+                            let method_call = format!(\".{}()\", method.ident);\n+                            if receiver.ends_with(&method_call) {\n+                                None // do not suggest code that is already there (#53348)\n                             } else {\n-                                if expr.precedence().order() < ExprPrecedence::MethodCall.order() {\n-                                    vec![\n-                                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                                        (expr.span.shrink_to_hi(), format!(\"){}\", method_call)),\n-                                    ]\n+                                let method_call_list = [\".to_vec()\", \".to_string()\"];\n+                                let mut sugg = if receiver.ends_with(\".clone()\")\n+                                    && method_call_list.contains(&method_call.as_str())\n+                                {\n+                                    let max_len = receiver.rfind('.').unwrap();\n+                                    vec![(\n+                                        expr.span,\n+                                        format!(\"{}{}\", &receiver[..max_len], method_call),\n+                                    )]\n                                 } else {\n-                                    vec![(expr.span.shrink_to_hi(), method_call)]\n+                                    if expr.precedence().order()\n+                                        < ExprPrecedence::MethodCall.order()\n+                                    {\n+                                        vec![\n+                                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                                            (expr.span.shrink_to_hi(), format!(\"){}\", method_call)),\n+                                        ]\n+                                    } else {\n+                                        vec![(expr.span.shrink_to_hi(), method_call)]\n+                                    }\n+                                };\n+                                if is_struct_pat_shorthand_field {\n+                                    sugg.insert(\n+                                        0,\n+                                        (expr.span.shrink_to_lo(), format!(\"{}: \", receiver)),\n+                                    );\n                                 }\n-                            };\n-                            if is_struct_pat_shorthand_field {\n-                                sugg.insert(\n-                                    0,\n-                                    (expr.span.shrink_to_lo(), format!(\"{}: \", receiver)),\n+                                Some(sugg)\n+                            }\n+                        })\n+                        .peekable();\n+                    if suggestions.peek().is_some() {\n+                        err.multipart_suggestions(\n+                            \"try using a conversion method\",\n+                            suggestions,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            } else if found.to_string().starts_with(\"Option<\")\n+                && expected.to_string() == \"Option<&str>\"\n+            {\n+                if let ty::Adt(_def, subst) = found.kind() {\n+                    if subst.len() != 0 {\n+                        if let GenericArgKind::Type(ty) = subst[0].unpack() {\n+                            let peeled = ty.peel_refs().to_string();\n+                            if peeled == \"String\" {\n+                                let ref_cnt = ty.to_string().len() - peeled.len();\n+                                let result = format!(\".map(|x| &*{}x)\", \"*\".repeat(ref_cnt));\n+                                err.span_suggestion_verbose(\n+                                    expr.span.shrink_to_hi(),\n+                                    \"try converting the passed type into a `&str`\",\n+                                    result,\n+                                    Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            Some(sugg)\n                         }\n-                    })\n-                    .peekable();\n-                if suggestions.peek().is_some() {\n-                    err.multipart_suggestions(\n-                        \"try using a conversion method\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    }\n                 }\n             }\n         }"}, {"sha": "b021e349e358c1f9ac83745c8d1ce2b014e0a34d", "filename": "src/test/ui/typeck/issue-89856.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5a0c7cb036032288a4a5443b54ba061ec12ee26/src%2Ftest%2Fui%2Ftypeck%2Fissue-89856.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a0c7cb036032288a4a5443b54ba061ec12ee26/src%2Ftest%2Fui%2Ftypeck%2Fissue-89856.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-89856.rs?ref=d5a0c7cb036032288a4a5443b54ba061ec12ee26", "patch": "@@ -0,0 +1,8 @@\n+fn take_str_maybe(x: Option<&str>) -> Option<&str> { None }\n+\n+fn main() {\n+    let string = String::from(\"Hello, world\");\n+    let option = Some(&string);\n+    take_str_maybe(option);\n+    //~^ ERROR: mismatched types [E0308]\n+}"}, {"sha": "4cb46a34a07a11b76b93c7cbc4b0f3014077bf9a", "filename": "src/test/ui/typeck/issue-89856.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d5a0c7cb036032288a4a5443b54ba061ec12ee26/src%2Ftest%2Fui%2Ftypeck%2Fissue-89856.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5a0c7cb036032288a4a5443b54ba061ec12ee26/src%2Ftest%2Fui%2Ftypeck%2Fissue-89856.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-89856.stderr?ref=d5a0c7cb036032288a4a5443b54ba061ec12ee26", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-89856.rs:6:20\n+   |\n+LL |     take_str_maybe(option);\n+   |                    ^^^^^^ expected `str`, found struct `String`\n+   |\n+   = note: expected enum `Option<&str>`\n+              found enum `Option<&String>`\n+help: try converting the passed type into a `&str`\n+   |\n+LL |     take_str_maybe(option.map(|x| &**x));\n+   |                          ++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}