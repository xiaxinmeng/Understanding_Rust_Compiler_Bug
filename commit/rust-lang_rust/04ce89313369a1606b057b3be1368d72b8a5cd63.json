{"sha": "04ce89313369a1606b057b3be1368d72b8a5cd63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0Y2U4OTMxMzM2OWExNjA2YjA1N2IzYmUxMzY4ZDcyYjhhNWNkNjM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-25T11:25:53Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-25T11:25:53Z"}, "message": "Merge #638\n\n638: reduce visibility r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d85e49c985b92a9ccf1303a089dccdd4c805db1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d85e49c985b92a9ccf1303a089dccdd4c805db1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04ce89313369a1606b057b3be1368d72b8a5cd63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04ce89313369a1606b057b3be1368d72b8a5cd63", "html_url": "https://github.com/rust-lang/rust/commit/04ce89313369a1606b057b3be1368d72b8a5cd63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04ce89313369a1606b057b3be1368d72b8a5cd63/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ae97cd59ff086e7efb6409f14c2f8ae8861596e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae97cd59ff086e7efb6409f14c2f8ae8861596e4", "html_url": "https://github.com/rust-lang/rust/commit/ae97cd59ff086e7efb6409f14c2f8ae8861596e4"}, {"sha": "64d4f4255880bbfb400551db38b76871276eaca6", "url": "https://api.github.com/repos/rust-lang/rust/commits/64d4f4255880bbfb400551db38b76871276eaca6", "html_url": "https://github.com/rust-lang/rust/commit/64d4f4255880bbfb400551db38b76871276eaca6"}], "stats": {"total": 280, "additions": 143, "deletions": 137}, "files": [{"sha": "97f5548384176e99e510a355454df0c1ac3b185f", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=04ce89313369a1606b057b3be1368d72b8a5cd63", "patch": "@@ -4,6 +4,7 @@ use std::{\n     fmt,\n     marker::PhantomData,\n     ops::{Index, IndexMut},\n+    iter::FromIterator,\n };\n \n pub mod map;\n@@ -109,3 +110,15 @@ impl<ID: ArenaId, T> IndexMut<ID> for Arena<ID, T> {\n         &mut self.data[idx]\n     }\n }\n+\n+impl<ID: ArenaId, T> FromIterator<T> for Arena<ID, T> {\n+    fn from_iter<I>(iter: I) -> Self\n+    where\n+        I: IntoIterator<Item = T>,\n+    {\n+        Arena {\n+            data: Vec::from_iter(iter),\n+            _ty: PhantomData,\n+        }\n+    }\n+}"}, {"sha": "ec6a10353ab47ca57ea18482e60f2e45f328b384", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 40, "deletions": 60, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=04ce89313369a1606b057b3be1368d72b8a5cd63", "patch": "@@ -79,12 +79,13 @@ impl EnumVariant {\n             .to_owned();\n         (file_id, var)\n     }\n+    pub(crate) fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n+        db.enum_data(self.parent).variants[self.id]\n+            .variant_data\n+            .clone()\n+    }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct EnumVariantId(RawId);\n-impl_arena_id!(EnumVariantId);\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub(crate) name: Option<Name>,\n@@ -94,105 +95,84 @@ pub struct EnumData {\n impl EnumData {\n     pub(crate) fn enum_data_query(db: &impl HirDatabase, e: Enum) -> Arc<EnumData> {\n         let (_file_id, enum_def) = e.source(db);\n-        let mut res = EnumData {\n-            name: enum_def.name().map(|n| n.as_name()),\n-            variants: Arena::default(),\n-        };\n-        for var in variants(&*enum_def) {\n-            let data = EnumVariantData {\n+        let name = enum_def.name().map(|n| n.as_name());\n+        let variants = variants(&*enum_def)\n+            .map(|var| EnumVariantData {\n                 name: var.name().map(|it| it.as_name()),\n                 variant_data: Arc::new(VariantData::new(var.flavor())),\n-            };\n-            res.variants.alloc(data);\n-        }\n-\n-        Arc::new(res)\n+            })\n+            .collect();\n+        Arc::new(EnumData { name, variants })\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct EnumVariantId(RawId);\n+impl_arena_id!(EnumVariantId);\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct EnumVariantData {\n+pub(crate) struct EnumVariantData {\n     pub(crate) name: Option<Name>,\n-    pub(crate) variant_data: Arc<VariantData>,\n+    variant_data: Arc<VariantData>,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct StructFieldId(RawId);\n+impl_arena_id!(StructFieldId);\n+\n /// A single field of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct StructField {\n+pub struct StructFieldData {\n     pub(crate) name: Name,\n     pub(crate) type_ref: TypeRef,\n }\n \n /// Fields of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum VariantData {\n-    Struct(Vec<StructField>),\n-    Tuple(Vec<StructField>),\n+pub(crate) struct VariantData(VariantDataInner);\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+enum VariantDataInner {\n+    Struct(Arena<StructFieldId, StructFieldData>),\n+    Tuple(Arena<StructFieldId, StructFieldData>),\n     Unit,\n }\n \n impl VariantData {\n-    pub fn fields(&self) -> &[StructField] {\n-        match self {\n-            VariantData::Struct(fields) | VariantData::Tuple(fields) => fields,\n-            _ => &[],\n-        }\n-    }\n-\n-    pub fn is_struct(&self) -> bool {\n-        match self {\n-            VariantData::Struct(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_tuple(&self) -> bool {\n-        match self {\n-            VariantData::Tuple(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_unit(&self) -> bool {\n-        match self {\n-            VariantData::Unit => true,\n-            _ => false,\n+    pub(crate) fn fields(&self) -> Option<&Arena<StructFieldId, StructFieldData>> {\n+        match &self.0 {\n+            VariantDataInner::Struct(fields) | VariantDataInner::Tuple(fields) => Some(fields),\n+            _ => None,\n         }\n     }\n }\n \n impl VariantData {\n     fn new(flavor: StructFlavor) -> Self {\n-        match flavor {\n+        let inner = match flavor {\n             StructFlavor::Tuple(fl) => {\n                 let fields = fl\n                     .fields()\n                     .enumerate()\n-                    .map(|(i, fd)| StructField {\n+                    .map(|(i, fd)| StructFieldData {\n                         name: Name::tuple_field_name(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();\n-                VariantData::Tuple(fields)\n+                VariantDataInner::Tuple(fields)\n             }\n             StructFlavor::Named(fl) => {\n                 let fields = fl\n                     .fields()\n-                    .map(|fd| StructField {\n+                    .map(|fd| StructFieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();\n-                VariantData::Struct(fields)\n+                VariantDataInner::Struct(fields)\n             }\n-            StructFlavor::Unit => VariantData::Unit,\n-        }\n-    }\n-\n-    pub(crate) fn get_field_type_ref(&self, field_name: &Name) -> Option<&TypeRef> {\n-        self.fields()\n-            .iter()\n-            .find(|f| f.name == *field_name)\n-            .map(|f| &f.type_ref)\n+            StructFlavor::Unit => VariantDataInner::Unit,\n+        };\n+        VariantData(inner)\n     }\n }"}, {"sha": "118562984d37ec7ea422f5fdb70be248ef096c88", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=04ce89313369a1606b057b3be1368d72b8a5cd63", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     db::HirDatabase,\n     expr::BodySyntaxMapping,\n     ty::{InferenceResult, VariantDef},\n-    adt::{VariantData, EnumVariantId},\n+    adt::{EnumVariantId, StructFieldId},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n@@ -177,19 +177,25 @@ impl Module {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructField {\n     parent: VariantDef,\n-    name: Name,\n+    pub(crate) id: StructFieldId,\n }\n \n impl StructField {\n-    pub fn name(&self) -> &Name {\n-        &self.name\n+    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+        self.parent.variant_data(db).fields().unwrap()[self.id]\n+            .name\n+            .clone()\n     }\n \n-    pub fn ty(&self, db: &impl HirDatabase) -> Option<Ty> {\n-        db.type_for_field(self.parent, self.name.clone())\n+    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n+        db.type_for_field(*self)\n+    }\n+\n+    pub fn parent_def(&self, _db: &impl HirDatabase) -> VariantDef {\n+        self.parent\n     }\n }\n \n@@ -215,14 +221,28 @@ impl Struct {\n         db.struct_data(*self)\n             .variant_data\n             .fields()\n-            .iter()\n-            .map(|it| StructField {\n+            .into_iter()\n+            .flat_map(|it| it.iter())\n+            .map(|(id, _)| StructField {\n                 parent: (*self).into(),\n-                name: it.name.clone(),\n+                id,\n             })\n             .collect()\n     }\n \n+    pub fn field(&self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        db.struct_data(*self)\n+            .variant_data\n+            .fields()\n+            .into_iter()\n+            .flat_map(|it| it.iter())\n+            .find(|(_id, data)| data.name == *name)\n+            .map(|(id, _)| StructField {\n+                parent: (*self).into(),\n+                id,\n+            })\n+    }\n+\n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n@@ -300,22 +320,29 @@ impl EnumVariant {\n         db.enum_data(self.parent).variants[self.id].name.clone()\n     }\n \n-    pub fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n-        db.enum_data(self.parent).variants[self.id]\n-            .variant_data\n-            .clone()\n-    }\n-\n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<StructField> {\n         self.variant_data(db)\n             .fields()\n-            .iter()\n-            .map(|it| StructField {\n+            .into_iter()\n+            .flat_map(|it| it.iter())\n+            .map(|(id, _)| StructField {\n                 parent: (*self).into(),\n-                name: it.name.clone(),\n+                id,\n             })\n             .collect()\n     }\n+\n+    pub fn field(&self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        self.variant_data(db)\n+            .fields()\n+            .into_iter()\n+            .flat_map(|it| it.iter())\n+            .find(|(_id, data)| data.name == *name)\n+            .map(|(id, _)| StructField {\n+                parent: (*self).into(),\n+                id,\n+            })\n+    }\n }\n \n impl Docs for EnumVariant {"}, {"sha": "3c82262a28b818bb4484ee919bf037646f64fbce", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=04ce89313369a1606b057b3be1368d72b8a5cd63", "patch": "@@ -4,15 +4,15 @@ use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n use ra_db::{SyntaxDatabase, CrateId, salsa};\n \n use crate::{\n-    MacroCallId, Name, HirFileId,\n+    MacroCallId, HirFileId,\n     SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     query_definitions,\n     Function, FnSignature, FnScopes,\n-    Struct, Enum,\n+    Struct, Enum, StructField,\n     macros::MacroExpansion,\n     module_tree::ModuleTree,\n     nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, VariantDef},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef},\n     adt::{StructData, EnumData},\n     impl_block::ModuleImplBlocks,\n     generics::{GenericParams, GenericDef},\n@@ -42,7 +42,7 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn type_for_def(&self, def: TypableDef) -> Ty;\n \n     #[salsa::invoke(crate::ty::type_for_field)]\n-    fn type_for_field(&self, def: VariantDef, field: Name) -> Option<Ty>;\n+    fn type_for_field(&self, field: StructField) -> Ty;\n \n     #[salsa::invoke(query_definitions::file_items)]\n     fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;"}, {"sha": "c57e222ddddf7b6b4ed65ac601fd0a1b15133b19", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 38, "deletions": 52, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=04ce89313369a1606b057b3be1368d72b8a5cd63", "patch": "@@ -38,6 +38,7 @@ use crate::{\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n     generics::GenericParams,\n     path::GenericArg,\n+    adt::VariantData,\n };\n \n /// The ID of a type variable.\n@@ -702,19 +703,30 @@ pub enum VariantDef {\n }\n impl_froms!(VariantDef: Struct, EnumVariant);\n \n-pub(super) fn type_for_field(db: &impl HirDatabase, def: VariantDef, field: Name) -> Option<Ty> {\n-    let (variant_data, generics, module) = match def {\n-        VariantDef::Struct(s) => (s.variant_data(db), s.generic_params(db), s.module(db)),\n-        VariantDef::EnumVariant(var) => (\n-            var.variant_data(db),\n-            var.parent_enum(db).generic_params(db),\n-            var.module(db),\n-        ),\n+impl VariantDef {\n+    pub(crate) fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        match self {\n+            VariantDef::Struct(it) => it.field(db, name),\n+            VariantDef::EnumVariant(it) => it.field(db, name),\n+        }\n+    }\n+    pub(crate) fn variant_data(self, db: &impl HirDatabase) -> Arc<VariantData> {\n+        match self {\n+            VariantDef::Struct(it) => it.variant_data(db),\n+            VariantDef::EnumVariant(it) => it.variant_data(db),\n+        }\n+    }\n+}\n+\n+pub(super) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n+    let parent_def = field.parent_def(db);\n+    let (generics, module) = match parent_def {\n+        VariantDef::Struct(it) => (it.generic_params(db), it.module(db)),\n+        VariantDef::EnumVariant(it) => (it.parent_enum(db).generic_params(db), it.module(db)),\n     };\n-    // We can't have an impl block ere, right?\n-    // let impl_block = def_id.impl_block(db);\n-    let type_ref = variant_data.get_field_type_ref(&field)?;\n-    Some(Ty::from_hir(db, &module, None, &generics, &type_ref))\n+    let var_data = parent_def.variant_data(db);\n+    let type_ref = &var_data.fields().unwrap()[field.id].type_ref;\n+    Ty::from_hir(db, &module, None, &generics, type_ref)\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -1122,39 +1134,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    fn resolve_fields(&mut self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n-        let (ty, def) = self.resolve_variant(path);\n-        match def? {\n-            VariantDef::Struct(s) => {\n-                let fields = s.fields(self.db);\n-                Some((ty, fields))\n-            }\n-            VariantDef::EnumVariant(var) => {\n-                let fields = var.fields(self.db);\n-                Some((ty, fields))\n-            }\n-        }\n-    }\n-\n     fn infer_tuple_struct_pat(\n         &mut self,\n         path: Option<&Path>,\n         subpats: &[PatId],\n         expected: &Ty,\n     ) -> Ty {\n-        let (ty, fields) = self\n-            .resolve_fields(path)\n-            .unwrap_or((Ty::Unknown, Vec::new()));\n+        let (ty, def) = self.resolve_variant(path);\n \n         self.unify(&ty, expected);\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n \n         for (i, &subpat) in subpats.iter().enumerate() {\n-            let expected_ty = fields\n-                .get(i)\n-                .and_then(|field| field.ty(self.db))\n-                .unwrap_or(Ty::Unknown)\n+            let expected_ty = def\n+                .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n+                .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n             self.infer_pat(subpat, &expected_ty);\n         }\n@@ -1163,19 +1158,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat], expected: &Ty) -> Ty {\n-        let (ty, fields) = self\n-            .resolve_fields(path)\n-            .unwrap_or((Ty::Unknown, Vec::new()));\n+        let (ty, def) = self.resolve_variant(path);\n \n         self.unify(&ty, expected);\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n \n         for subpat in subpats {\n-            let matching_field = fields.iter().find(|field| field.name() == &subpat.name);\n+            let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n             let expected_ty = matching_field\n-                .and_then(|field| field.ty(self.db))\n-                .unwrap_or(Ty::Unknown)\n+                .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n             self.infer_pat(subpat.pat, &expected_ty);\n         }\n@@ -1420,14 +1412,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n                 for field in fields {\n-                    let field_ty = if let Some(def_id) = def_id {\n-                        self.db\n-                            .type_for_field(def_id.into(), field.name.clone())\n-                            .unwrap_or(Ty::Unknown)\n-                            .subst(&substs)\n-                    } else {\n-                        Ty::Unknown\n-                    };\n+                    let field_ty = def_id\n+                        .and_then(|it| it.field(self.db, &field.name))\n+                        .map_or(Ty::Unknown, |field| field.ty(self.db))\n+                        .subst(&substs);\n                     self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n@@ -1440,7 +1428,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = receiver_ty\n                     .autoderef(self.db)\n                     .find_map(|derefed_ty| match derefed_ty {\n-                        // this is more complicated than necessary because type_for_field is cancelable\n                         Ty::Tuple(fields) => {\n                             let i = name.to_string().parse::<usize>().ok();\n                             i.and_then(|i| fields.get(i).cloned())\n@@ -1449,10 +1436,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             def_id: AdtDef::Struct(s),\n                             ref substs,\n                             ..\n-                        } => self\n-                            .db\n-                            .type_for_field(s.into(), name.clone())\n-                            .map(|ty| ty.subst(substs)),\n+                        } => s\n+                            .field(self.db, name)\n+                            .map(|field| field.ty(self.db).subst(substs)),\n                         _ => None,\n                     })\n                     .unwrap_or(Ty::Unknown);"}, {"sha": "060a46c5e0b05a31d20efdbd7e18cb2042c75b5f", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ce89313369a1606b057b3be1368d72b8a5cd63/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=04ce89313369a1606b057b3be1368d72b8a5cd63", "patch": "@@ -34,10 +34,10 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                             CompletionItem::new(\n                                 CompletionKind::Reference,\n                                 ctx.source_range(),\n-                                field.name().to_string(),\n+                                field.name(ctx.db).to_string(),\n                             )\n                             .kind(CompletionItemKind::Field)\n-                            .set_detail(field.ty(ctx.db).map(|ty| ty.subst(substs).to_string()))\n+                            .detail(field.ty(ctx.db).subst(substs).to_string())\n                             .add_to(acc);\n                         }\n                     }"}]}