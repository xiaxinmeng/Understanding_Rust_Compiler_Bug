{"sha": "b0097783b980056b67020f0e65107f87ed813275", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMDk3NzgzYjk4MDA1NmI2NzAyMGYwZTY1MTA3Zjg3ZWQ4MTMyNzU=", "commit": {"author": {"name": "GuillaumeGomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-02-04T00:04:50Z"}, "committer": {"name": "GuillaumeGomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-02-06T11:01:57Z"}, "message": "librustc_trans has been updated", "tree": {"sha": "1283371164eb3db1425b5325468c609cfe71068f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1283371164eb3db1425b5325468c609cfe71068f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0097783b980056b67020f0e65107f87ed813275", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0097783b980056b67020f0e65107f87ed813275", "html_url": "https://github.com/rust-lang/rust/commit/b0097783b980056b67020f0e65107f87ed813275", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0097783b980056b67020f0e65107f87ed813275/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff6e5356ce26a073149d0c10b82aaa8b80fb093", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff6e5356ce26a073149d0c10b82aaa8b80fb093", "html_url": "https://github.com/rust-lang/rust/commit/1ff6e5356ce26a073149d0c10b82aaa8b80fb093"}], "stats": {"total": 126, "additions": 63, "deletions": 63}, "files": [{"sha": "bfeb73bb546226a40b7d7a20fd2e134493866589", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -141,7 +141,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, ref name)) = attr_crate_name {\n-                if *s != name.get() {\n+                if *s != &name[] {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n@@ -153,7 +153,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n \n     if let Some((attr, s)) = attr_crate_name {\n-        return validate(s.get().to_string(), Some(attr.span));\n+        return validate(s.to_string(), Some(attr.span));\n     }\n     if let Input::File(ref path) = *input {\n         if let Some(s) = path.filestem_str() {\n@@ -293,7 +293,7 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, &token::get_name(e.name()).get()[])\n+        push(&mut n, &token::get_name(e.name())[])\n     }\n \n     match hash {"}, {"sha": "49fd040b25a479fce14eaaa0ee3a8e633b1763ea", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -355,7 +355,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n         };\n \n-        let qualname = format!(\"{}::{}\", qualname, get_ident(method.pe_ident()).get());\n+        let qualname = format!(\"{}::{}\", qualname, &get_ident(method.pe_ident())[]);\n         let qualname = &qualname[];\n \n         // record the decl for this def (if it has one)\n@@ -436,7 +436,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         &name.get()[],\n+                                                         &name[],\n                                                          &qualname[],\n                                                          &typ[],\n                                                          scope_id),\n@@ -525,7 +525,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.static_str(item.span,\n                             sub_span,\n                             item.id,\n-                            get_ident(item.ident).get(),\n+                            &get_ident(item.ident)[],\n                             &qualname[],\n                             &value[],\n                             &ty_to_string(&*typ)[],\n@@ -548,7 +548,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.static_str(item.span,\n                             sub_span,\n                             item.id,\n-                            get_ident(item.ident).get(),\n+                            &get_ident(item.ident)[],\n                             &qualname[],\n                             \"\",\n                             &ty_to_string(&*typ)[],\n@@ -607,7 +607,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n         for variant in &enum_definition.variants {\n             let name = get_ident(variant.node.name);\n-            let name = name.get();\n+            let name = &name[];\n             let mut qualname = enum_name.clone();\n             qualname.push_str(\"::\");\n             qualname.push_str(name);\n@@ -1094,7 +1094,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                sub_span,\n                                                item.id,\n                                                mod_id,\n-                                               get_ident(ident).get(),\n+                                               &get_ident(ident)[],\n                                                self.cur_scope);\n                         self.write_sub_paths_truncated(path, true);\n                     }\n@@ -1149,9 +1149,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             }\n             ast::ItemExternCrate(ref s) => {\n                 let name = get_ident(item.ident);\n-                let name = name.get();\n+                let name = &name[];\n                 let location = match *s {\n-                    Some((ref s, _)) => s.get().to_string(),\n+                    Some((ref s, _)) => s.to_string(),\n                     None => name.to_string(),\n                 };\n                 let alias_span = self.span.span_for_last_ident(item.span);\n@@ -1259,7 +1259,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     },\n                 };\n \n-                qualname.push_str(get_ident(method_type.ident).get());\n+                qualname.push_str(&get_ident(method_type.ident)[]);\n                 let qualname = &qualname[];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n@@ -1541,7 +1541,7 @@ pub fn process_crate(sess: &Session,\n \n     assert!(analysis.glob_map.is_some());\n     let cratename = match attr::find_crate_name(&krate.attrs[]) {\n-        Some(name) => name.get().to_string(),\n+        Some(name) => name.to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n             String::from_str(\"unknown_crate\")"}, {"sha": "7ec371cec253cfb84b1bfe72c2214f47e0dcd12e", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -77,13 +77,13 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n     let mut constraints = constraints.iter()\n-                                     .map(|s| s.get().to_string())\n+                                     .map(|s| s.to_string())\n                                      .chain(ext_constraints.into_iter())\n                                      .collect::<Vec<String>>()\n                                      .connect(\",\");\n \n     let mut clobbers = ia.clobbers.iter()\n-                                  .map(|s| format!(\"~{{{}}}\", s.get()))\n+                                  .map(|s| format!(\"~{{{}}}\", &s[]))\n                                   .collect::<Vec<String>>()\n                                   .connect(\",\");\n     let more_clobbers = get_clobbers();\n@@ -120,7 +120,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         ast::AsmIntel => llvm::AD_Intel\n     };\n \n-    let asm = CString::from_slice(ia.asm.get().as_bytes());\n+    let asm = CString::from_slice(ia.asm.as_bytes());\n     let constraints = CString::from_slice(constraints.as_bytes());\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),"}, {"sha": "089292fa64eada7bba10edb90b48f1f52be2e34f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -444,7 +444,7 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n \n     for attr in attrs {\n         let mut used = true;\n-        match attr.name().get() {\n+        match &attr.name()[] {\n             \"no_stack_check\" => unset_split_stack(llfn),\n             \"no_split_stack\" => {\n                 unset_split_stack(llfn);\n@@ -2248,7 +2248,7 @@ pub fn update_linkage(ccx: &CrateContext,\n         let item = ccx.tcx().map.get(id);\n         if let ast_map::NodeItem(i) = item {\n             if let Some(name) = attr::first_attr_value_str_by_name(&i.attrs, \"linkage\") {\n-                if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n+                if let Some(linkage) = llvm_linkage_by_name(&name[]) {\n                     llvm::SetLinkage(llval, linkage);\n                 } else {\n                     ccx.sess().span_fatal(i.span, \"invalid linkage specified\");\n@@ -2721,15 +2721,15 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n \n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n-        Some(name) => name.get().to_string(),\n+        Some(name) => name.to_string(),\n \n         _ => ccx.tcx().map.with_path(id, |path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n                 path.last().unwrap().to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n-                    Some(name) => name.get().to_string(),\n+                    Some(name) => name.to_string(),\n                     None => {\n                         // Usual name mangling\n                         mangle_exported_name(ccx, path, ty, id)\n@@ -2824,12 +2824,12 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             match attr::first_attr_value_str_by_name(&i.attrs[],\n                                                      \"link_section\") {\n                 Some(sect) => {\n-                    if contains_null(sect.get()) {\n+                    if contains_null(&sect[]) {\n                         ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get())[]);\n+                                                 &sect[])[]);\n                     }\n                     unsafe {\n-                        let buf = CString::from_slice(sect.get().as_bytes());\n+                        let buf = CString::from_slice(sect.as_bytes());\n                         llvm::LLVMSetSection(v, buf.as_ptr());\n                     }\n                 },\n@@ -2869,7 +2869,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, &name.get()[])\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, &name[])\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)"}, {"sha": "87b7f413fd1e55b112cc1259f275766caba222f8", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -590,7 +590,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n     pub fn ident(&self, ident: Ident) -> String {\n-        token::get_ident(ident).get().to_string()\n+        token::get_ident(ident).to_string()\n     }\n \n     pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n@@ -834,8 +834,8 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n-                                                s.get().as_ptr() as *const c_char,\n-                                                s.get().len() as c_uint,\n+                                                s.as_ptr() as *const c_char,\n+                                                s.len() as c_uint,\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n@@ -853,7 +853,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n-    let len = s.get().len();\n+    let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n     C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }"}, {"sha": "18968e6f8858024d15b8626c86ea4440156e56b7", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -58,13 +58,13 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n-            C_floating(fs.get(), Type::float_from_ty(cx, t))\n+            C_floating(&fs[], Type::float_from_ty(cx, t))\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n             let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match lit_float_ty.sty {\n                 ty::ty_float(t) => {\n-                    C_floating(fs.get(), Type::float_from_ty(cx, t))\n+                    C_floating(&fs[], Type::float_from_ty(cx, t))\n                 }\n                 _ => {\n                     cx.sess().span_bug(lit.span,"}, {"sha": "400f03dbb51754b083c12c038209bf82297f9567", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -802,7 +802,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let variable_type = ty::node_id_to_type(cx.tcx(), node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n-    let var_name = token::get_ident(ident).get().to_string();\n+    let var_name = token::get_ident(ident).to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(&var_name[]);\n     let var_scope = namespace_node.scope;\n@@ -1350,7 +1350,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let mut function_name = String::from_str(token::get_ident(ident).get());\n+    let mut function_name = String::from_str(&token::get_ident(ident)[]);\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -1499,7 +1499,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let ident = special_idents::type_self;\n \n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.get().as_bytes());\n+                let name = CString::from_slice(ident.as_bytes());\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1533,7 +1533,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.get().as_bytes());\n+                let name = CString::from_slice(ident.as_bytes());\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1656,7 +1656,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let name = CString::from_slice(name.get().as_bytes());\n+    let name = CString::from_slice(name.as_bytes());\n     match (variable_access, [].as_slice()) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {\n@@ -1993,7 +1993,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             let name = if field.name == special_idents::unnamed_field.name {\n                 \"\".to_string()\n             } else {\n-                token::get_name(field.name).get().to_string()\n+                token::get_name(field.name).to_string()\n             };\n \n             let offset = if self.is_simd {\n@@ -2223,7 +2223,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_ident(names[0]).get().to_string(),\n+                        Some(ref names) => token::get_ident(names[0]).to_string(),\n                         None => \"\".to_string()\n                     },\n                     llvm_type: non_null_llvm_type,\n@@ -2237,13 +2237,13 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                                       .get_unique_type_id_of_enum_variant(\n                                                           cx,\n                                                           self.enum_type,\n-                                                          non_null_variant_name.get());\n+                                                          &non_null_variant_name[]);\n \n                 // Now we can create the metadata of the artificial struct\n                 let artificial_struct_metadata =\n                     composite_type_metadata(cx,\n                                             artificial_struct_llvm_type,\n-                                            non_null_variant_name.get(),\n+                                            &non_null_variant_name[],\n                                             unique_type_id,\n                                             &[sole_struct_member_description],\n                                             self.containing_scope,\n@@ -2373,7 +2373,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // Could do some consistency checks here: size, align, field count, discr type\n \n     let variant_name = token::get_name(variant_info.name);\n-    let variant_name = variant_name.get();\n+    let variant_name = &variant_name[];\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n@@ -2392,7 +2392,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Some(ref names) => {\n             names.iter()\n                  .map(|ident| {\n-                     token::get_ident(*ident).get().to_string()\n+                     token::get_ident(*ident).to_string()\n                  }).collect()\n         }\n         None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n@@ -2443,7 +2443,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         .iter()\n         .map(|v| {\n             let token = token::get_name(v.name);\n-            let name = CString::from_slice(token.get().as_bytes());\n+            let name = CString::from_slice(token.as_bytes());\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerator(\n                     DIB(cx),\n@@ -2473,7 +2473,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n-                let name = CString::from_slice(discriminant_name.get().as_bytes());\n+                let name = CString::from_slice(discriminant_name.as_bytes());\n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerationType(\n                         DIB(cx),\n@@ -3126,7 +3126,7 @@ fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n         let meta_item: &ast::MetaItem = &*attr.node.value;\n         match meta_item.node {\n-            ast::MetaWord(ref value) => value.get() == \"no_debug\",\n+            ast::MetaWord(ref value) => &value[] == \"no_debug\",\n             _ => false\n         }\n     })\n@@ -3847,7 +3847,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut path_element_count = 0;\n                 for path_element in path {\n                     let name = token::get_name(path_element.name());\n-                    output.push_str(name.get());\n+                    output.push_str(&name[]);\n                     output.push_str(\"::\");\n                     path_element_count += 1;\n                 }\n@@ -3862,7 +3862,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let name = token::get_name(path.last()\n                                                .expect(\"debuginfo: Empty item path?\")\n                                                .name());\n-                output.push_str(name.get());\n+                output.push_str(&name[]);\n             }\n         });\n     }\n@@ -3912,8 +3912,8 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(&format!(\"{}\", string.get().len())[]);\n-            output.push_str(string.get());\n+            output.push_str(&format!(\"{}\", string.len())[]);\n+            output.push_str(&string[]);\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n@@ -3970,7 +3970,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                     };\n                     let namespace_name = token::get_name(name);\n                     let namespace_name = CString::from_slice(namespace_name\n-                                                                .get().as_bytes());\n+                                                                .as_bytes());\n                     let scope = unsafe {\n                         llvm::LLVMDIBuilderCreateNameSpace(\n                             DIB(cx),"}, {"sha": "a2fe5fa3f170c3d86c04ce9566eeeacdcc215245", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -118,7 +118,7 @@ pub fn register_static(ccx: &CrateContext,\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n         Some(name) => {\n-            let linkage = match llvm_linkage_by_name(name.get()) {\n+            let linkage = match llvm_linkage_by_name(&name[]) {\n                 Some(linkage) => linkage,\n                 None => {\n                     ccx.sess().span_fatal(foreign_item.span,\n@@ -134,7 +134,7 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let buf = CString::from_slice(ident.get().as_bytes());\n+                let buf = CString::from_slice(ident.as_bytes());\n                 let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n                                              buf.as_ptr());\n                 llvm::SetLinkage(g1, linkage);\n@@ -146,7 +146,7 @@ pub fn register_static(ccx: &CrateContext,\n                 // `extern_with_linkage_foo` will instead be initialized to\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                real_name.push_str(ident.get());\n+                real_name.push_str(&ident[]);\n                 let real_name = CString::from_vec(real_name.into_bytes());\n                 let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n                                              real_name.as_ptr());\n@@ -157,7 +157,7 @@ pub fn register_static(ccx: &CrateContext,\n         }\n         None => unsafe {\n             // Generate an external declaration.\n-            let buf = CString::from_slice(ident.get().as_bytes());\n+            let buf = CString::from_slice(ident.as_bytes());\n             llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n         }\n     }\n@@ -468,7 +468,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                     }\n \n                     register_foreign_item_fn(ccx, abi, ty,\n-                                             &lname.get()[]);\n+                                             &lname[]);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -478,7 +478,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n         }\n \n         ccx.item_symbols().borrow_mut().insert(foreign_item.id,\n-                                             lname.get().to_string());\n+                                             lname.to_string());\n     }\n }\n "}, {"sha": "9ac4f04f7427a3543f249300d04591392e925768", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use util::ppaux::{Repr, ty_to_string};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n-    let name = match token::get_ident(item.ident).get() {\n+    let name = match &token::get_ident(item.ident)[] {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\",\n@@ -166,7 +166,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = token::get_ident(foreign_item.ident);\n \n     // For `transmute` we can just trans the input expr directly into dest\n-    if name.get() == \"transmute\" {\n+    if &name[] == \"transmute\" {\n         let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n@@ -274,13 +274,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n \n     // These are the only intrinsic functions that diverge.\n-    if name.get() == \"abort\" {\n+    if &name[] == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n         Call(bcx, llfn, &[], None, call_debug_location);\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n-    } else if name.get() == \"unreachable\" {\n+    } else if &name[] == \"unreachable\" {\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n@@ -307,7 +307,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n-    let llval = match (simple, name.get()) {\n+    let llval = match (simple, &name[]) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, None, call_debug_location)\n         }"}, {"sha": "bce93cbf2eb9d3971c55d6bcee3f32220c5e418a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0097783b980056b67020f0e65107f87ed813275/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=b0097783b980056b67020f0e65107f87ed813275", "patch": "@@ -209,7 +209,7 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match dest {\n         Ignore => bcx,\n         SaveIn(lldest) => {\n-            let bytes = str_lit.get().len();\n+            let bytes = str_lit.len();\n             let llbytes = C_uint(bcx.ccx(), bytes);\n             let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n             let llcstr = consts::ptrcast(llcstr, Type::i8p(bcx.ccx()));\n@@ -242,7 +242,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     match dest {\n                         Ignore => return bcx,\n                         SaveIn(lldest) => {\n-                            let bytes = s.get().len();\n+                            let bytes = s.len();\n                             let llbytes = C_uint(bcx.ccx(), bytes);\n                             let llcstr = C_cstr(bcx.ccx(), (*s).clone(), false);\n                             base::call_memcpy(bcx,\n@@ -343,7 +343,7 @@ pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     match content_expr.node {\n         ast::ExprLit(ref lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => s.get().len(),\n+                ast::LitStr(ref s, _) => s.len(),\n                 _ => {\n                     bcx.tcx().sess.span_bug(content_expr.span,\n                                             \"unexpected evec content\")"}]}