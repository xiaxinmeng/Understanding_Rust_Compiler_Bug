{"sha": "6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNTQwYmQ0MGM2NzUxZDZkNWVmYWE3ZmNjN2NkMjhkNDczYjU5NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-21T01:16:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-21T01:16:15Z"}, "message": "Auto merge of #86502 - JohnTitor:rollup-wge0f3x, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #83739 (Account for bad placeholder errors on consts/statics with trait objects)\n - #85637 (document PartialEq, PartialOrd, Ord requirements more explicitly)\n - #86152 (Lazify is_really_default condition in the RustdocGUI bootstrap step)\n - #86156 (Fix a bug in the linkchecker)\n - #86427 (Updated release note)\n - #86452 (fix panic-safety in specialized Zip::next_back)\n - #86484 (Do not set depth to 0 in fully_expand_fragment)\n - #86491 (expand: Move some more derive logic to rustc_builtin_macros)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1894020967e3fa84cc803574840665b60609d97a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1894020967e3fa84cc803574840665b60609d97a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "html_url": "https://github.com/rust-lang/rust/commit/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03b845a41f1666654ecffcbaa6a582170ec0ed8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b845a41f1666654ecffcbaa6a582170ec0ed8d", "html_url": "https://github.com/rust-lang/rust/commit/03b845a41f1666654ecffcbaa6a582170ec0ed8d"}, {"sha": "8b9e138ecdb0891a8626f89994eb725e00b79d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b9e138ecdb0891a8626f89994eb725e00b79d7e", "html_url": "https://github.com/rust-lang/rust/commit/8b9e138ecdb0891a8626f89994eb725e00b79d7e"}], "stats": {"total": 398, "additions": 291, "deletions": 107}, "files": [{"sha": "5e2987ee8267ed21a8e3aeca2eaa44bb5f3704a8", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -179,6 +179,7 @@ dependencies = [\n  \"libc\",\n  \"merge\",\n  \"num_cpus\",\n+ \"once_cell\",\n  \"opener\",\n  \"pretty_assertions\",\n  \"serde\","}, {"sha": "2b159e7d00434bd53f215bdbe71cbabb5eda8a22", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -1749,6 +1749,7 @@ Language\n - [You can now use `#[repr(transparent)]` on univariant `enum`s.][68122] Meaning\n   that you can create an enum that has the exact layout and ABI of the type\n   it contains.\n+- [You can now use outer attribute procedural macros on inline modules.][64273]  \n - [There are some *syntax-only* changes:][67131]\n    - `default` is syntactically allowed before items in `trait` definitions.\n    - Items in `impl`s (i.e. `const`s, `type`s, and `fn`s) may syntactically\n@@ -1810,6 +1811,7 @@ Compatibility Notes\n [67935]: https://github.com/rust-lang/rust/pull/67935/\n [68339]: https://github.com/rust-lang/rust/pull/68339/\n [68122]: https://github.com/rust-lang/rust/pull/68122/\n+[64273]: https://github.com/rust-lang/rust/pull/64273/\n [67712]: https://github.com/rust-lang/rust/pull/67712/\n [67887]: https://github.com/rust-lang/rust/pull/67887/\n [67131]: https://github.com/rust-lang/rust/pull/67131/"}, {"sha": "d7b46f282151fe32ac11e8dc1432d98f0ba58bb6", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -24,61 +24,60 @@ crate fn expand(\n     annotatable: Annotatable,\n ) -> Vec<Annotatable> {\n     check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n-    cfg_eval(ecx, annotatable)\n+    vec![cfg_eval(ecx, annotatable)]\n }\n \n-crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Vec<Annotatable> {\n-    let mut visitor = CfgEval {\n+crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Annotatable {\n+    CfgEval {\n         cfg: &mut StripUnconfigured {\n             sess: ecx.sess,\n             features: ecx.ecfg.features,\n             config_tokens: true,\n         },\n-    };\n-    let annotatable = visitor.configure_annotatable(annotatable);\n-    vec![annotatable]\n+    }\n+    .configure_annotatable(annotatable)\n+    // Since the item itself has already been configured by the `InvocationCollector`,\n+    // we know that fold result vector will contain exactly one element.\n+    .unwrap()\n }\n \n struct CfgEval<'a, 'b> {\n     cfg: &'a mut StripUnconfigured<'b>,\n }\n \n-fn flat_map_annotatable(vis: &mut impl MutVisitor, annotatable: Annotatable) -> Annotatable {\n-    // Since the item itself has already been configured by the InvocationCollector,\n-    // we know that fold result vector will contain exactly one element\n+fn flat_map_annotatable(\n+    vis: &mut impl MutVisitor,\n+    annotatable: Annotatable,\n+) -> Option<Annotatable> {\n     match annotatable {\n-        Annotatable::Item(item) => Annotatable::Item(vis.flat_map_item(item).pop().unwrap()),\n+        Annotatable::Item(item) => vis.flat_map_item(item).pop().map(Annotatable::Item),\n         Annotatable::TraitItem(item) => {\n-            Annotatable::TraitItem(vis.flat_map_trait_item(item).pop().unwrap())\n+            vis.flat_map_trait_item(item).pop().map(Annotatable::TraitItem)\n         }\n         Annotatable::ImplItem(item) => {\n-            Annotatable::ImplItem(vis.flat_map_impl_item(item).pop().unwrap())\n+            vis.flat_map_impl_item(item).pop().map(Annotatable::ImplItem)\n         }\n         Annotatable::ForeignItem(item) => {\n-            Annotatable::ForeignItem(vis.flat_map_foreign_item(item).pop().unwrap())\n+            vis.flat_map_foreign_item(item).pop().map(Annotatable::ForeignItem)\n         }\n         Annotatable::Stmt(stmt) => {\n-            Annotatable::Stmt(stmt.map(|stmt| vis.flat_map_stmt(stmt).pop().unwrap()))\n+            vis.flat_map_stmt(stmt.into_inner()).pop().map(P).map(Annotatable::Stmt)\n         }\n-        Annotatable::Expr(mut expr) => Annotatable::Expr({\n+        Annotatable::Expr(mut expr) => {\n             vis.visit_expr(&mut expr);\n-            expr\n-        }),\n-        Annotatable::Arm(arm) => Annotatable::Arm(vis.flat_map_arm(arm).pop().unwrap()),\n-        Annotatable::ExprField(field) => {\n-            Annotatable::ExprField(vis.flat_map_expr_field(field).pop().unwrap())\n+            Some(Annotatable::Expr(expr))\n         }\n-        Annotatable::PatField(fp) => {\n-            Annotatable::PatField(vis.flat_map_pat_field(fp).pop().unwrap())\n+        Annotatable::Arm(arm) => vis.flat_map_arm(arm).pop().map(Annotatable::Arm),\n+        Annotatable::ExprField(field) => {\n+            vis.flat_map_expr_field(field).pop().map(Annotatable::ExprField)\n         }\n+        Annotatable::PatField(fp) => vis.flat_map_pat_field(fp).pop().map(Annotatable::PatField),\n         Annotatable::GenericParam(param) => {\n-            Annotatable::GenericParam(vis.flat_map_generic_param(param).pop().unwrap())\n-        }\n-        Annotatable::Param(param) => Annotatable::Param(vis.flat_map_param(param).pop().unwrap()),\n-        Annotatable::FieldDef(sf) => {\n-            Annotatable::FieldDef(vis.flat_map_field_def(sf).pop().unwrap())\n+            vis.flat_map_generic_param(param).pop().map(Annotatable::GenericParam)\n         }\n-        Annotatable::Variant(v) => Annotatable::Variant(vis.flat_map_variant(v).pop().unwrap()),\n+        Annotatable::Param(param) => vis.flat_map_param(param).pop().map(Annotatable::Param),\n+        Annotatable::FieldDef(sf) => vis.flat_map_field_def(sf).pop().map(Annotatable::FieldDef),\n+        Annotatable::Variant(v) => vis.flat_map_variant(v).pop().map(Annotatable::Variant),\n     }\n }\n \n@@ -123,11 +122,11 @@ impl CfgEval<'_, '_> {\n         self.cfg.configure(node)\n     }\n \n-    pub fn configure_annotatable(&mut self, mut annotatable: Annotatable) -> Annotatable {\n+    fn configure_annotatable(&mut self, mut annotatable: Annotatable) -> Option<Annotatable> {\n         // Tokenizing and re-parsing the `Annotatable` can have a significant\n         // performance impact, so try to avoid it if possible\n         if !CfgFinder::has_cfg_or_cfg_attr(&annotatable) {\n-            return annotatable;\n+            return Some(annotatable);\n         }\n \n         // The majority of parsed attribute targets will never need to have early cfg-expansion"}, {"sha": "60d6bae38b56c89c251913fd2eea4235611d87b6", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -26,6 +26,8 @@ impl MultiItemModifier for Expander {\n             return ExpandResult::Ready(vec![item]);\n         }\n \n+        let item = cfg_eval(ecx, item);\n+\n         let result =\n             ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n                 let template =\n@@ -54,12 +56,12 @@ impl MultiItemModifier for Expander {\n                         report_path_args(sess, &meta);\n                         meta.path\n                     })\n-                    .map(|path| (path, None))\n+                    .map(|path| (path, item.clone(), None))\n                     .collect()\n             });\n \n         match result {\n-            Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n+            Ok(()) => ExpandResult::Ready(vec![item]),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }"}, {"sha": "96fd6cb68e8b93419cc6d9a40b9d02327fc9cba3", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -835,7 +835,7 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n-pub type DeriveResolutions = Vec<(ast::Path, Option<Lrc<SyntaxExtension>>)>;\n+pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>)>;\n \n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;"}, {"sha": "f8a12ef8a208197d381fc8c1d5989ad26c49f4e0", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -427,7 +427,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         let orig_force_mode = self.cx.force_mode;\n-        self.cx.current_expansion.depth = 0;\n \n         // Collect all macro invocations and replace them with placeholders.\n         let (mut fragment_with_placeholders, mut invocations) =\n@@ -488,6 +487,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n \n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n+            let depth = depth - orig_expansion_data.depth;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n             self.cx.force_mode = force;\n \n@@ -500,42 +500,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         .resolver\n                         .take_derive_resolutions(expn_id)\n                         .map(|derives| {\n-                            enum AnnotatableRef<'a> {\n-                                Item(&'a P<ast::Item>),\n-                                Stmt(&'a ast::Stmt),\n-                            }\n-                            let item = match &fragment {\n-                                AstFragment::Items(items) => match &items[..] {\n-                                    [item] => AnnotatableRef::Item(item),\n-                                    _ => unreachable!(),\n-                                },\n-                                AstFragment::Stmts(stmts) => match &stmts[..] {\n-                                    [stmt] => AnnotatableRef::Stmt(stmt),\n-                                    _ => unreachable!(),\n-                                },\n-                                _ => unreachable!(),\n-                            };\n-\n                             derive_invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(path, _exts)| {\n+                                .map(|(path, item, _exts)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = ExpnId::fresh(None);\n                                     derive_invocations.push((\n                                         Invocation {\n-                                            kind: InvocationKind::Derive {\n-                                                path,\n-                                                item: match item {\n-                                                    AnnotatableRef::Item(item) => {\n-                                                        Annotatable::Item(item.clone())\n-                                                    }\n-                                                    AnnotatableRef::Stmt(stmt) => {\n-                                                        Annotatable::Stmt(P(stmt.clone()))\n-                                                    }\n-                                                },\n-                                            },\n+                                            kind: InvocationKind::Derive { path, item },\n                                             fragment_kind,\n                                             expansion_data: ExpansionData {\n                                                 id: expn_id,"}, {"sha": "38d052f988c63fefa192da601a8ef0507bf09d2c", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -380,7 +380,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             has_derive_copy: false,\n         });\n         let parent_scope = self.invocation_parent_scopes[&expn_id];\n-        for (i, (path, opt_ext)) in entry.resolutions.iter_mut().enumerate() {\n+        for (i, (path, _, opt_ext)) in entry.resolutions.iter_mut().enumerate() {\n             if opt_ext.is_none() {\n                 *opt_ext = Some(\n                     match self.resolve_macro_path("}, {"sha": "ae61dd1cfce4abd44a22350b4e890749d0b577d0", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -813,6 +813,14 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             match it.kind {\n                 hir::ItemKind::Fn(..) => tcx.ensure().fn_sig(def_id),\n                 hir::ItemKind::OpaqueTy(..) => tcx.ensure().item_bounds(def_id),\n+                hir::ItemKind::Const(ty, ..) | hir::ItemKind::Static(ty, ..) => {\n+                    // (#75889): Account for `const C: dyn Fn() -> _ = \"\";`\n+                    if let hir::TyKind::TraitObject(..) = ty.kind {\n+                        let mut visitor = PlaceholderHirTyCollector::default();\n+                        visitor.visit_item(it);\n+                        placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n+                    }\n+                }\n                 _ => (),\n             }\n         }"}, {"sha": "6c2f09514a611a38e978daeb9144e7cfd6468832", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -27,12 +27,25 @@ use self::Ordering::*;\n /// Trait for equality comparisons which are [partial equivalence\n /// relations](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n+/// `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`.\n+/// We use the easier-to-read infix notation in the remainder of this documentation.\n+///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not [`trait@Eq`].\n ///\n-/// Formally, the equality must be (for all `a`, `b`, `c` of type `A`, `B`,\n-/// `C`):\n+/// Implementations must ensure that `eq` and `ne` are consistent with each other:\n+///\n+/// - `a != b` if and only if `!(a == b)`\n+///   (ensured by the default implementation).\n+///\n+/// If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also\n+/// be consistent with `PartialEq` (see the documentation of those traits for the exact\n+/// requirememts). It's easy to accidentally make them disagree by deriving some of the traits and\n+/// manually implementing others.\n+///\n+/// The equality relation `==` must satisfy the following conditions\n+/// (for all `a`, `b`, `c` of type `A`, `B`, `C`):\n ///\n /// - **Symmetric**: if `A: PartialEq<B>` and `B: PartialEq<A>`, then **`a == b`\n ///   implies `b == a`**; and\n@@ -53,15 +66,6 @@ use self::Ordering::*;\n ///\n /// ## How can I implement `PartialEq`?\n ///\n-/// `PartialEq` only requires the [`eq`] method to be implemented; [`ne`] is defined\n-/// in terms of it by default. Any manual implementation of [`ne`] *must* respect\n-/// the rule that [`eq`] is a strict inverse of [`ne`]; that is, `!(a == b)` if and\n-/// only if `a != b`.\n-///\n-/// Implementations of `PartialEq`, [`PartialOrd`], and [`Ord`] *must* agree with\n-/// each other. It's easy to accidentally make them disagree by deriving some\n-/// of the traits and manually implementing others.\n-///\n /// An example implementation for a domain in which two books are considered\n /// the same book if their ISBN matches, even if the formats differ:\n ///\n@@ -631,10 +635,25 @@ impl<T: Clone> Clone for Reverse<T> {\n \n /// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n ///\n-/// An order is a total order if it is (for all `a`, `b` and `c`):\n+/// Implementations must be consistent with the [`PartialOrd`] implementation, and ensure\n+/// `max`, `min`, and `clamp` are consistent with `cmp`:\n+///\n+/// - `partial_cmp(a, b) == Some(cmp(a, b))`.\n+/// - `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation).\n+/// - `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation).\n+/// - For `a.clamp(min, max)`, see the [method docs](#method.clamp)\n+///   (ensured by the default implementation).\n+///\n+/// It's easy to accidentally make `cmp` and `partial_cmp` disagree by\n+/// deriving some of the traits and manually implementing others.\n+///\n+/// ## Corollaries\n+///\n+/// From the above and the requirements of `PartialOrd`, it follows that `<` defines a strict total order.\n+/// This means that for all `a`, `b` and `c`:\n ///\n-/// - total and asymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n-/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+/// - exactly one of `a < b`, `a == b` or `a > b` is true; and\n+/// - `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n ///\n /// ## Derivable\n ///\n@@ -659,12 +678,6 @@ impl<T: Clone> Clone for Reverse<T> {\n /// Then you must define an implementation for [`cmp`]. You may find it useful to use\n /// [`cmp`] on your type's fields.\n ///\n-/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must*\n-/// agree with each other. That is, `a.cmp(b) == Ordering::Equal` if\n-/// and only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\n-/// all `a` and `b`. It's easy to accidentally make them disagree by\n-/// deriving some of the traits and manually implementing others.\n-///\n /// Here's an example where you want to sort people by height only, disregarding `id`\n /// and `name`:\n ///\n@@ -824,15 +837,45 @@ impl PartialOrd for Ordering {\n \n /// Trait for values that can be compared for a sort-order.\n ///\n+/// The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using\n+/// the `<`, `<=`, `>`, and `>=` operators, respectively.\n+///\n+/// The methods of this trait must be consistent with each other and with those of `PartialEq` in\n+/// the following sense:\n+///\n+/// - `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n+/// - `a < b` if and only if `partial_cmp(a, b) == Some(Less)`\n+///   (ensured by the default implementation).\n+/// - `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`\n+///   (ensured by the default implementation).\n+/// - `a <= b` if and only if `a < b || a == b`\n+///   (ensured by the default implementation).\n+/// - `a >= b` if and only if `a > b || a == b`\n+///   (ensured by the default implementation).\n+/// - `a != b` if and only if `!(a == b)` (already part of `PartialEq`).\n+///\n+/// If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with\n+/// `partial_cmp` (see the documentation of that trait for the exact requirements). It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// The comparison must satisfy, for all `a`, `b` and `c`:\n ///\n-/// - asymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and\n /// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+/// - duality: `a < b` if and only if `b > a`.\n ///\n /// Note that these requirements mean that the trait itself must be implemented symmetrically and\n /// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n /// PartialOrd<V>`.\n ///\n+/// ## Corollaries\n+///\n+/// The following corollaries follow from the above requirements:\n+///\n+/// - irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`\n+/// - transitivity of `>`: if `a > b` and `b > c` then `a > c`\n+/// - duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`\n+///\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n@@ -850,10 +893,6 @@ impl PartialOrd for Ordering {\n ///\n /// `PartialOrd` requires your type to be [`PartialEq`].\n ///\n-/// Implementations of [`PartialEq`], `PartialOrd`, and [`Ord`] *must* agree with each other. It's\n-/// easy to accidentally make them disagree by deriving some of the traits and manually\n-/// implementing others.\n-///\n /// If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n ///\n /// ```"}, {"sha": "46bf93dcc01e2b5a130b5ad2621fbf93b1967d99", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -295,9 +295,10 @@ where\n                 let sz_a = self.a.size();\n                 if A::MAY_HAVE_SIDE_EFFECT && sz_a > self.len {\n                     for _ in 0..sz_a - self.len {\n+                        self.a_len -= 1;\n                         self.a.next_back();\n                     }\n-                    self.a_len = self.len;\n+                    debug_assert_eq!(self.a_len, self.len);\n                 }\n                 let sz_b = self.b.size();\n                 if B::MAY_HAVE_SIDE_EFFECT && sz_b > self.len {"}, {"sha": "585cfbb90e40c1d3cfcd5d1718b0f77d7765d1c3", "filename": "library/core/tests/iter/adapters/zip.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -232,6 +232,33 @@ fn test_zip_trusted_random_access_composition() {\n     assert_eq!(z2.next().unwrap(), ((1, 1), 1));\n }\n \n+#[test]\n+#[cfg(panic = \"unwind\")]\n+fn test_zip_trusted_random_access_next_back_drop() {\n+    use std::panic::catch_unwind;\n+    use std::panic::AssertUnwindSafe;\n+\n+    let mut counter = 0;\n+\n+    let it = [42].iter().map(|e| {\n+        let c = counter;\n+        counter += 1;\n+        if c == 0 {\n+            panic!(\"bomb\");\n+        }\n+\n+        e\n+    });\n+    let it2 = [(); 0].iter();\n+    let mut zip = it.zip(it2);\n+    catch_unwind(AssertUnwindSafe(|| {\n+        zip.next_back();\n+    }))\n+    .unwrap_err();\n+    assert!(zip.next().is_none());\n+    assert_eq!(counter, 1);\n+}\n+\n #[test]\n fn test_double_ended_zip() {\n     let xs = [1, 2, 3, 4, 5, 6];"}, {"sha": "d1e666936f88a3b778bbd33574c38061a3297cd7", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -50,6 +50,7 @@ time = \"0.1\"\n ignore = \"0.4.10\"\n opener = \"0.4\"\n merge = \"0.1.0\"\n+once_cell = \"1.7.2\"\n \n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\""}, {"sha": "e2f605257bd9548235776640c268f435708d3851", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -29,6 +29,8 @@ use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir};\n use crate::{Build, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n+// FIXME: replace with std::lazy after it gets stabilized and reaches beta\n+use once_cell::sync::Lazy;\n \n pub struct Builder<'a> {\n     pub build: &'a Build,\n@@ -195,7 +197,7 @@ impl StepDescription {\n \n         if paths.is_empty() || builder.config.include_default_paths {\n             for (desc, should_run) in v.iter().zip(&should_runs) {\n-                if desc.default && should_run.is_really_default {\n+                if desc.default && should_run.is_really_default() {\n                     for pathset in &should_run.paths {\n                         desc.maybe_run(builder, pathset);\n                     }\n@@ -228,31 +230,47 @@ impl StepDescription {\n     }\n }\n \n-#[derive(Clone)]\n+enum ReallyDefault<'a> {\n+    Bool(bool),\n+    Lazy(Lazy<bool, Box<dyn Fn() -> bool + 'a>>),\n+}\n+\n pub struct ShouldRun<'a> {\n     pub builder: &'a Builder<'a>,\n     // use a BTreeSet to maintain sort order\n     paths: BTreeSet<PathSet>,\n \n     // If this is a default rule, this is an additional constraint placed on\n     // its run. Generally something like compiler docs being enabled.\n-    is_really_default: bool,\n+    is_really_default: ReallyDefault<'a>,\n }\n \n impl<'a> ShouldRun<'a> {\n     fn new(builder: &'a Builder<'_>) -> ShouldRun<'a> {\n         ShouldRun {\n             builder,\n             paths: BTreeSet::new(),\n-            is_really_default: true, // by default no additional conditions\n+            is_really_default: ReallyDefault::Bool(true), // by default no additional conditions\n         }\n     }\n \n     pub fn default_condition(mut self, cond: bool) -> Self {\n-        self.is_really_default = cond;\n+        self.is_really_default = ReallyDefault::Bool(cond);\n+        self\n+    }\n+\n+    pub fn lazy_default_condition(mut self, lazy_cond: Box<dyn Fn() -> bool + 'a>) -> Self {\n+        self.is_really_default = ReallyDefault::Lazy(Lazy::new(lazy_cond));\n         self\n     }\n \n+    pub fn is_really_default(&self) -> bool {\n+        match &self.is_really_default {\n+            ReallyDefault::Bool(val) => *val,\n+            ReallyDefault::Lazy(lazy) => *lazy.deref(),\n+        }\n+    }\n+\n     /// Indicates it should run if the command-line selects the given crate or\n     /// any of its (local) dependencies.\n     ///"}, {"sha": "e7fb8c0d4d5d20357d85afdb462ad3dbc69c7d39", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -613,9 +613,14 @@ mod dist {\n         // Note that the stages here are +1 than what they actually are because\n         // Rustdoc::run swaps out the compiler with stage minus 1 if --stage is\n         // not 0.\n+        //\n+        // The stage 0 copy is the one downloaded for bootstrapping. It is\n+        // (currently) needed to run \"cargo test\" on the linkchecker, and\n+        // should be relatively \"free\".\n         assert_eq!(\n             first(builder.cache.all::<tool::Rustdoc>()),\n             &[\n+                tool::Rustdoc { compiler: Compiler { host: a, stage: 0 } },\n                 tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n                 tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },\n             ]"}, {"sha": "93ba8b07f5b3a108a28ca2dc6e17a97454f27523", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -124,8 +124,25 @@ You can skip linkcheck with --exclude src/tools/linkchecker\"\n \n         builder.info(&format!(\"Linkcheck ({})\", host));\n \n+        // Test the linkchecker itself.\n+        let bootstrap_host = builder.config.build;\n+        let compiler = builder.compiler(0, bootstrap_host);\n+        let cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolBootstrap,\n+            bootstrap_host,\n+            \"test\",\n+            \"src/tools/linkchecker\",\n+            SourceType::InTree,\n+            &[],\n+        );\n+        try_run(builder, &mut cargo.into());\n+\n+        // Build all the default documentation.\n         builder.default_doc(&[]);\n \n+        // Run the linkchecker.\n         let _time = util::timeit(&builder);\n         try_run(\n             builder,\n@@ -806,15 +823,15 @@ impl Step for RustdocGUI {\n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         let run = run.suite_path(\"src/test/rustdoc-gui\");\n-        run.default_condition(\n+        run.lazy_default_condition(Box::new(move || {\n             builder.config.nodejs.is_some()\n                 && builder\n                     .config\n                     .npm\n                     .as_ref()\n                     .map(|p| check_if_browser_ui_test_is_installed(p))\n-                    .unwrap_or(false),\n-        )\n+                    .unwrap_or(false)\n+        }))\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "98cd6d54c1fd4e00732c196172da08157c1caf01", "filename": "src/test/ui/error-codes/E0121.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Ferror-codes%2FE0121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Ferror-codes%2FE0121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0121.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -2,5 +2,4 @@ fn foo() -> _ { 5 } //~ ERROR E0121\n \n static BAR: _ = \"test\"; //~ ERROR E0121\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "9139775c805a22424010b12fb991f018a442ab46", "filename": "src/test/ui/macros/issue-84632-eager-expansion-recursion-limit.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Fmacros%2Fissue-84632-eager-expansion-recursion-limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Fmacros%2Fissue-84632-eager-expansion-recursion-limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-84632-eager-expansion-recursion-limit.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -0,0 +1,16 @@\n+// Regression test for #84632: Recursion limit is ignored\n+// for builtin macros that eagerly expands.\n+\n+#![recursion_limit = \"15\"]\n+macro_rules! a {\n+    () => (\"\");\n+    (A) => (concat!(\"\", a!()));\n+    (A, $($A:ident),*) => (concat!(\"\", a!($($A),*)))\n+    //~^ ERROR recursion limit reached\n+    //~| HELP consider adding\n+}\n+\n+fn main() {\n+    a!(A, A, A, A, A);\n+    a!(A, A, A, A, A, A, A, A, A, A, A);\n+}"}, {"sha": "e6067e333498808231d917468045546a09b144c4", "filename": "src/test/ui/macros/issue-84632-eager-expansion-recursion-limit.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Fmacros%2Fissue-84632-eager-expansion-recursion-limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Fmacros%2Fissue-84632-eager-expansion-recursion-limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-84632-eager-expansion-recursion-limit.stderr?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -0,0 +1,14 @@\n+error: recursion limit reached while expanding `concat!`\n+  --> $DIR/issue-84632-eager-expansion-recursion-limit.rs:8:28\n+   |\n+LL |     (A, $($A:ident),*) => (concat!(\"\", a!($($A),*)))\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     a!(A, A, A, A, A, A, A, A, A, A, A);\n+   |     ------------------------------------ in this macro invocation\n+   |\n+   = help: consider adding a `#![recursion_limit=\"30\"]` attribute to your crate (`issue_84632_eager_expansion_recursion_limit`)\n+   = note: this error originates in the macro `a` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "84c067ed0c7a5e55ece420368a91a4e00138eece", "filename": "src/test/ui/typeck/issue-75889.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -0,0 +1,6 @@\n+// Regression test for #75889.\n+\n+const FOO: dyn Fn() -> _ = \"\"; //~ ERROR E0121\n+static BOO: dyn Fn() -> _ = \"\"; //~ ERROR E0121\n+\n+fn main() {}"}, {"sha": "0a8a3c9e7433e3a299556c2f83b1db3b7304012d", "filename": "src/test/ui/typeck/issue-75889.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.stderr?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -0,0 +1,15 @@\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-75889.rs:3:24\n+   |\n+LL | const FOO: dyn Fn() -> _ = \"\";\n+   |                        ^ not allowed in type signatures\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-75889.rs:4:25\n+   |\n+LL | static BOO: dyn Fn() -> _ = \"\";\n+   |                         ^ not allowed in type signatures\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "15edd628cdffcfa4532f48f6b30175143ceeba0f", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -347,7 +347,7 @@ impl Checker {\n                 } else {\n                     report.errors += 1;\n                     print!(\"{}:{}: broken link fragment \", pretty_path, i + 1);\n-                    println!(\"`#{}` pointing to `{}`\", fragment, pretty_path);\n+                    println!(\"`#{}` pointing to `{}`\", fragment, target_pretty_path);\n                 };\n             }\n         });"}, {"sha": "9c580d8e07ee8c6ce7f3eef11cd76d8c31873448", "filename": "src/tools/linkchecker/tests/broken_redir/redir-bad.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Fredir-bad.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Fredir-bad.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Fredir-bad.html?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -2,6 +2,7 @@\n <html lang=\"en\">\n <head>\n     <meta http-equiv=\"refresh\" content=\"0;URL=sometarget\">\n+    <title>Redirection</title>\n </head>\n <body>\n     <p>Redirecting to <a href=\"sometarget\">sometarget</a>...</p>"}, {"sha": "1a0b1b00e0de095dde50d75f8a2cbe7f8a2a9bf8", "filename": "src/tools/linkchecker/tests/checks.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fchecks.rs?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -15,7 +15,7 @@ fn run(dirname: &str) -> (ExitStatus, String, String) {\n fn broken_test(dirname: &str, expected: &str) {\n     let (status, stdout, stderr) = run(dirname);\n     assert!(!status.success());\n-    if !stdout.contains(expected) {\n+    if !contains(expected, &stdout) {\n         panic!(\n             \"stdout did not contain expected text: {}\\n\\\n             --- stdout:\\n\\\n@@ -27,6 +27,25 @@ fn broken_test(dirname: &str, expected: &str) {\n     }\n }\n \n+fn contains(expected: &str, actual: &str) -> bool {\n+    // Normalize for Windows paths.\n+    let actual = actual.replace('\\\\', \"/\");\n+    actual.lines().any(|mut line| {\n+        for (i, part) in expected.split(\"[..]\").enumerate() {\n+            match line.find(part) {\n+                Some(j) => {\n+                    if i == 0 && j != 0 {\n+                        return false;\n+                    }\n+                    line = &line[j + part.len()..];\n+                }\n+                None => return false,\n+            }\n+        }\n+        line.is_empty() || expected.ends_with(\"[..]\")\n+    })\n+}\n+\n fn valid_test(dirname: &str) {\n     let (status, stdout, stderr) = run(dirname);\n     if !status.success() {\n@@ -48,30 +67,47 @@ fn valid() {\n \n #[test]\n fn basic_broken() {\n-    broken_test(\"basic_broken\", \"bar.html\");\n+    broken_test(\"basic_broken\", \"foo.html:3: broken link - `bar.html`\");\n }\n \n #[test]\n fn broken_fragment_local() {\n-    broken_test(\"broken_fragment_local\", \"#somefrag\");\n+    broken_test(\n+        \"broken_fragment_local\",\n+        \"foo.html:3: broken link fragment `#somefrag` pointing to `foo.html`\",\n+    );\n }\n \n #[test]\n fn broken_fragment_remote() {\n-    broken_test(\"broken_fragment_remote/inner\", \"#somefrag\");\n+    broken_test(\n+        \"broken_fragment_remote/inner\",\n+        \"foo.html:3: broken link fragment `#somefrag` pointing to \\\n+         `[..]/broken_fragment_remote/bar.html`\",\n+    );\n }\n \n #[test]\n fn broken_redir() {\n-    broken_test(\"broken_redir\", \"sometarget\");\n+    broken_test(\n+        \"broken_redir\",\n+        \"foo.html:3: broken redirect from `redir-bad.html` to `sometarget`\",\n+    );\n }\n \n #[test]\n fn directory_link() {\n-    broken_test(\"directory_link\", \"somedir\");\n+    broken_test(\n+        \"directory_link\",\n+        \"foo.html:3: directory link to `somedir` (directory links should use index.html instead)\",\n+    );\n }\n \n #[test]\n fn redirect_loop() {\n-    broken_test(\"redirect_loop\", \"redir-bad.html\");\n+    broken_test(\n+        \"redirect_loop\",\n+        \"foo.html:3: redirect from `redir-bad.html` to `[..]redirect_loop/redir-bad.html` \\\n+         which is also a redirect (not supported)\",\n+    );\n }"}, {"sha": "bc567caa78b7e500efaba0d7c2290fc73931a39d", "filename": "src/tools/linkchecker/tests/redirect_loop/redir-bad.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Fredir-bad.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Fredir-bad.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Fredir-bad.html?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -2,6 +2,7 @@\n <html lang=\"en\">\n <head>\n     <meta http-equiv=\"refresh\" content=\"0;URL=redir-bad.html\">\n+    <title>Redirection</title>\n </head>\n <body>\n     <p>Redirecting to <a href=\"redir-bad.html\">redir-bad.html</a>...</p>"}, {"sha": "f32683efe67ec8bf382534aa88f201d38b19d61f", "filename": "src/tools/linkchecker/tests/valid/inner/redir-bad.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-bad.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-bad.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-bad.html?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -2,6 +2,7 @@\n <html lang=\"en\">\n <head>\n     <meta http-equiv=\"refresh\" content=\"0;URL=xxx\">\n+    <title>Redirection</title>\n </head>\n <body>\n     <p>Redirecting to <a href=\"xxx\">xxx</a>...</p>"}, {"sha": "3a52a8973853738b9b882e5aaeba45c341f58572", "filename": "src/tools/linkchecker/tests/valid/inner/redir.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir.html", "raw_url": "https://github.com/rust-lang/rust/raw/6a540bd40c6751d6d5efaa7fcc7cd28d473b5946/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir.html?ref=6a540bd40c6751d6d5efaa7fcc7cd28d473b5946", "patch": "@@ -2,6 +2,7 @@\n <html lang=\"en\">\n <head>\n     <meta http-equiv=\"refresh\" content=\"0;URL=redir-target.html\">\n+    <title>Redirection</title>\n </head>\n <body>\n     <p>Redirecting to <a href=\"redir-target.html\">redir-target.html</a>...</p>"}]}