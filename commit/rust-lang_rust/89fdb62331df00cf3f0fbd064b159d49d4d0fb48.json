{"sha": "89fdb62331df00cf3f0fbd064b159d49d4d0fb48", "node_id": "C_kwDOAAsO6NoAKDg5ZmRiNjIzMzFkZjAwY2YzZjBmYmQwNjRiMTU5ZDQ5ZDRkMGZiNDg", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-03-18T01:51:45Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-03-18T17:11:04Z"}, "message": "Fix inherent impls on negative coherence", "tree": {"sha": "350743f319277cd7f7fcdf5cc1bc87c53fac6dec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350743f319277cd7f7fcdf5cc1bc87c53fac6dec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89fdb62331df00cf3f0fbd064b159d49d4d0fb48", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmI0vSgACgkQgTGiTgx5\n76/5BA//Q/4N8VYssnwZnFe79gvfx3MUz+AJMPZN+7eIEPipPXwM2jT41nYAXS+e\n4wROtlPMG1BEWRz8pMZyHPIXWkvtzXDrMC63NOHnP0LXY1yrfn49NDY3jCQnCZ1A\nlJBcQqq2hV+KEGtbdoMil7wXAYNrv5hp5t0YfHBhqw5wFIqkhfdASiizZiscnmz8\nS0t+94iaQKWWxLMVnl/VvWibJamh3uX3iPmS0wbRCFRY91vYREIgGzllLC1+NKCV\nt/iSDKJJWtVunml2nYgYKBs722QZsmLaUazA6Mbtf5awVkmgYn+7syR/8sCk/8im\nbDUlWAl38uJn9hIDx/mpYhehL8o1DdTqT2SSypXfDqf2t1mWT5HRdnjW9RbEV7jn\nfYSbiP/Z5R1oXW4PzJkaj+17dNoxlCuqnANwLxfhukIzJQje9ftuLVQJe+iUgS6V\nOgcvgzVFAQjn974OonPBUsOpGO3ObR1mKHs6FofOcwGpf7xbs77Vvj/QNauhEDo2\nuSoGqYM8V60aGlcaSNtJetaQQZJd3rcMYRpKlyCxOEOheJITPAsdNlUSucM2IQhn\n8gFZ43NvA4I6M9od+50q8WCwZ+q9Dmd3gXpLs1yVnry0ETwrH2LwLi0uu8C0DTZp\n9ihKrTyLxiISKzrVBXWz5joja8VpOdSQOjTz9JuoYYvYGMI93Pw=\n=Oipy\n-----END PGP SIGNATURE-----", "payload": "tree 350743f319277cd7f7fcdf5cc1bc87c53fac6dec\nparent a8adf7685a4ddd16e985d34d9838a75a04ca4181\nauthor Santiago Pastorino <spastorino@gmail.com> 1647568305 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1647623464 -0300\n\nFix inherent impls on negative coherence\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89fdb62331df00cf3f0fbd064b159d49d4d0fb48", "html_url": "https://github.com/rust-lang/rust/commit/89fdb62331df00cf3f0fbd064b159d49d4d0fb48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89fdb62331df00cf3f0fbd064b159d49d4d0fb48/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8adf7685a4ddd16e985d34d9838a75a04ca4181", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8adf7685a4ddd16e985d34d9838a75a04ca4181", "html_url": "https://github.com/rust-lang/rust/commit/a8adf7685a4ddd16e985d34d9838a75a04ca4181"}], "stats": {"total": 132, "additions": 89, "deletions": 43}, "files": [{"sha": "83f54d6dc3d40439eba7642f783ee92bdc639c53", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 67, "deletions": 43, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb62331df00cf3f0fbd064b159d49d4d0fb48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb62331df00cf3f0fbd064b159d49d4d0fb48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=89fdb62331df00cf3f0fbd064b159d49d4d0fb48", "patch": "@@ -300,55 +300,79 @@ fn negative_impl<'cx, 'tcx>(\n     debug!(\"negative_impl(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n     let tcx = selcx.infcx().tcx;\n \n-    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n-    let impl1_env = tcx.param_env(impl1_def_id);\n-    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n-\n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     tcx.infer_ctxt().enter(|infcx| {\n-        // Normalize the trait reference. The WF rules ought to ensure\n-        // that this always succeeds.\n-        let impl1_trait_ref = match traits::fully_normalize(\n-            &infcx,\n-            FulfillmentContext::new(),\n-            ObligationCause::dummy(),\n-            impl1_env,\n-            impl1_trait_ref,\n-        ) {\n-            Ok(impl1_trait_ref) => impl1_trait_ref,\n-            Err(err) => {\n-                bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n-            }\n-        };\n+        // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n+        let impl1_env = tcx.param_env(impl1_def_id);\n+\n+        if let Some(impl1_trait_ref) = tcx.impl_trait_ref(impl1_def_id) {\n+            // Normalize the trait reference. The WF rules ought to ensure\n+            // that this always succeeds.\n+            let impl1_trait_ref = match traits::fully_normalize(\n+                &infcx,\n+                FulfillmentContext::new(),\n+                ObligationCause::dummy(),\n+                impl1_env,\n+                impl1_trait_ref,\n+            ) {\n+                Ok(impl1_trait_ref) => impl1_trait_ref,\n+                Err(err) => {\n+                    bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n+                }\n+            };\n \n-        // Attempt to prove that impl2 applies, given all of the above.\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n-        let (impl2_trait_ref, obligations) =\n-            impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n+            // Attempt to prove that impl2 applies, given all of the above.\n+            let selcx = &mut SelectionContext::new(&infcx);\n+            let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n+            let (impl2_trait_ref, obligations) =\n+                impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n \n-        // do the impls unify? If not, not disjoint.\n-        let Ok(InferOk { obligations: more_obligations, .. }) = infcx\n+            // do the impls unify? If not, not disjoint.\n+            let Ok(InferOk { obligations: more_obligations, .. }) = infcx\n             .at(&ObligationCause::dummy(), impl1_env)\n-            .eq(impl1_trait_ref, impl2_trait_ref)\n-        else {\n-            debug!(\n-                \"explicit_disjoint: {:?} does not unify with {:?}\",\n-                impl1_trait_ref, impl2_trait_ref\n-            );\n-            return false;\n-        };\n-\n-        let opt_failing_obligation = obligations\n-            .into_iter()\n-            .chain(more_obligations)\n-            .find(|o| negative_impl_exists(selcx, impl1_env, impl1_def_id, o));\n-\n-        if let Some(failing_obligation) = opt_failing_obligation {\n-            debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n-            true\n+            .eq(impl1_trait_ref, impl2_trait_ref) else {\n+                debug!(\n+                    \"explicit_disjoint: {:?} does not unify with {:?}\",\n+                    impl1_trait_ref, impl2_trait_ref\n+                );\n+                return false;\n+            };\n+\n+            let opt_failing_obligation = obligations\n+                .into_iter()\n+                .chain(more_obligations)\n+                .find(|o| negative_impl_exists(selcx, impl1_env, impl1_def_id, o));\n+\n+            if let Some(failing_obligation) = opt_failing_obligation {\n+                debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n+                true\n+            } else {\n+                false\n+            }\n         } else {\n-            false\n+            let ty1 = tcx.type_of(impl1_def_id);\n+            let ty2 = tcx.type_of(impl2_def_id);\n+\n+            let Ok(InferOk { obligations, .. }) = infcx\n+            .at(&ObligationCause::dummy(), impl1_env)\n+            .eq(ty1, ty2) else {\n+                debug!(\n+                    \"explicit_disjoint: {:?} does not unify with {:?}\",\n+                    ty1, ty2\n+                );\n+                return false;\n+            };\n+\n+            let opt_failing_obligation = obligations\n+                .into_iter()\n+                .find(|o| negative_impl_exists(selcx, impl1_env, impl1_def_id, o));\n+\n+            if let Some(failing_obligation) = opt_failing_obligation {\n+                debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n+                true\n+            } else {\n+                false\n+            }\n         }\n     })\n }"}, {"sha": "a9e1acc8044a578f907b767082a20ca216d35a44", "filename": "src/test/ui/coherence/coherence-negative-inherent.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb62331df00cf3f0fbd064b159d49d4d0fb48/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb62331df00cf3f0fbd064b159d49d4d0fb48/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent.rs?ref=89fdb62331df00cf3f0fbd064b159d49d4d0fb48", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+#![feature(with_negative_coherence)]\n+\n+#[rustc_strict_coherence]\n+trait Foo {}\n+\n+impl !Foo for u32 {}\n+\n+struct MyStruct<T>(T);\n+\n+impl<T: Foo> MyStruct<T> {\n+    fn method(&self) {}\n+}\n+\n+impl MyStruct<u32> {\n+    fn method(&self) {}\n+}\n+\n+fn main() {}"}]}