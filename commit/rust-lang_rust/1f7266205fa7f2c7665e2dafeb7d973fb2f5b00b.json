{"sha": "1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNzI2NjIwNWZhN2YyYzc2NjVlMmRhZmViN2Q5NzNmYjJmNWIwMGI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-05-13T00:57:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-13T00:57:28Z"}, "message": "Rollup merge of #41876 - oli-obk:diagnosing_diagnostics, r=nagisa\n\nRefactor suggestion diagnostic API to allow for multiple suggestions\n\nr? @jonathandturner\n\ncc @nrc @petrochenkov", "tree": {"sha": "b6e6f97aef9cc745176736eef3bedc6809c57ef0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6e6f97aef9cc745176736eef3bedc6809c57ef0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "html_url": "https://github.com/rust-lang/rust/commit/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2519e90f951873091abeac6e8b797d87b0b71fc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2519e90f951873091abeac6e8b797d87b0b71fc8", "html_url": "https://github.com/rust-lang/rust/commit/2519e90f951873091abeac6e8b797d87b0b71fc8"}, {"sha": "3f2bbe3f4f69379b13190bfdc191a8e394b04998", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f2bbe3f4f69379b13190bfdc191a8e394b04998", "html_url": "https://github.com/rust-lang/rust/commit/3f2bbe3f4f69379b13190bfdc191a8e394b04998"}], "stats": {"total": 649, "additions": 392, "deletions": 257}, "files": [{"sha": "861880aa265ec140a1072f8b25a12bc211c827e6", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use CodeSuggestion;\n+use Substitution;\n use Level;\n use RenderSpan;\n use std::fmt;\n@@ -23,7 +24,7 @@ pub struct Diagnostic {\n     pub code: Option<String>,\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n-    pub suggestion: Option<CodeSuggestion>,\n+    pub suggestions: Vec<CodeSuggestion>,\n }\n \n /// For example a note attached to an error.\n@@ -87,7 +88,7 @@ impl Diagnostic {\n             code: code,\n             span: MultiSpan::new(),\n             children: vec![],\n-            suggestion: None,\n+            suggestions: vec![],\n         }\n     }\n \n@@ -204,10 +205,22 @@ impl Diagnostic {\n     ///\n     /// See `diagnostic::CodeSuggestion` for more information.\n     pub fn span_suggestion(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n-        assert!(self.suggestion.is_none());\n-        self.suggestion = Some(CodeSuggestion {\n-            msp: sp.into(),\n-            substitutes: vec![suggestion],\n+        self.suggestions.push(CodeSuggestion {\n+            substitution_parts: vec![Substitution {\n+                span: sp,\n+                substitutions: vec![suggestion],\n+            }],\n+            msg: msg.to_owned(),\n+        });\n+        self\n+    }\n+\n+    pub fn span_suggestions(&mut self, sp: Span, msg: &str, suggestions: Vec<String>) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitution_parts: vec![Substitution {\n+                span: sp,\n+                substitutions: suggestions,\n+            }],\n             msg: msg.to_owned(),\n         });\n         self"}, {"sha": "d03a4acb9fc580389224d8985ff449ca5f235467", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -148,6 +148,11 @@ impl<'a> DiagnosticBuilder<'a> {\n                                     msg: &str,\n                                     suggestion: String)\n                                     -> &mut Self);\n+    forward!(pub fn span_suggestions(&mut self,\n+                                     sp: Span,\n+                                     msg: &str,\n+                                     suggestions: Vec<String>)\n+                                     -> &mut Self);\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: String) -> &mut Self);\n "}, {"sha": "d1ec1be47b8ab85f5459b1fd98441801f3c0d04e", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -35,23 +35,32 @@ impl Emitter for EmitterWriter {\n         let mut primary_span = db.span.clone();\n         let mut children = db.children.clone();\n \n-        if let Some(sugg) = db.suggestion.clone() {\n-            assert_eq!(sugg.msp.primary_spans().len(), sugg.substitutes.len());\n-            // don't display multispans as labels\n-            if sugg.substitutes.len() == 1 &&\n+        if let Some((sugg, rest)) = db.suggestions.split_first() {\n+            if rest.is_empty() &&\n+               // don't display multipart suggestions as labels\n+               sugg.substitution_parts.len() == 1 &&\n+               // don't display multi-suggestions as labels\n+               sugg.substitutions() == 1 &&\n                // don't display long messages as labels\n                sugg.msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n-               sugg.substitutes[0].find('\\n').is_none() {\n-                let msg = format!(\"help: {} `{}`\", sugg.msg, sugg.substitutes[0]);\n-                primary_span.push_span_label(sugg.msp.primary_spans()[0], msg);\n+               sugg.substitution_parts[0].substitutions[0].find('\\n').is_none() {\n+                let substitution = &sugg.substitution_parts[0].substitutions[0];\n+                let msg = format!(\"help: {} `{}`\", sugg.msg, substitution);\n+                primary_span.push_span_label(sugg.substitution_spans().next().unwrap(), msg);\n             } else {\n-                children.push(SubDiagnostic {\n-                    level: Level::Help,\n-                    message: Vec::new(),\n-                    span: MultiSpan::new(),\n-                    render_span: Some(Suggestion(sugg)),\n-                });\n+                // if there are multiple suggestions, print them all in full\n+                // to be consistent. We could try to figure out if we can\n+                // make one (or the first one) inline, but that would give\n+                // undue importance to a semi-random suggestion\n+                for sugg in &db.suggestions {\n+                    children.push(SubDiagnostic {\n+                        level: Level::Help,\n+                        message: Vec::new(),\n+                        span: MultiSpan::new(),\n+                        render_span: Some(Suggestion(sugg.clone())),\n+                    });\n+                }\n             }\n         }\n \n@@ -66,6 +75,10 @@ impl Emitter for EmitterWriter {\n \n /// maximum number of lines we will print for each error; arbitrary.\n pub const MAX_HIGHLIGHT_LINES: usize = 6;\n+/// maximum number of suggestions to be shown\n+///\n+/// Arbitrary, but taken from trait import suggestion limit\n+pub const MAX_SUGGESTIONS: usize = 4;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum ColorConfig {\n@@ -1054,38 +1067,44 @@ impl EmitterWriter {\n                                -> io::Result<()> {\n         use std::borrow::Borrow;\n \n-        let primary_span = suggestion.msp.primary_span().unwrap();\n+        let primary_span = suggestion.substitution_spans().next().unwrap();\n         if let Some(ref cm) = self.cm {\n             let mut buffer = StyledBuffer::new();\n \n-            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n-            buffer.append(0, \": \", Style::HeaderMsg);\n-            self.msg_to_buffer(&mut buffer,\n-                               &[(suggestion.msg.to_owned(), Style::NoStyle)],\n-                               max_line_num_len,\n-                               \"suggestion\",\n-                               Some(Style::HeaderMsg));\n-\n             let lines = cm.span_to_lines(primary_span).unwrap();\n \n             assert!(!lines.lines.is_empty());\n \n-            let complete = suggestion.splice_lines(cm.borrow());\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            self.msg_to_buffer(&mut buffer,\n+                            &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+                            max_line_num_len,\n+                            \"suggestion\",\n+                            Some(Style::HeaderMsg));\n \n-            // print the suggestion without any line numbers, but leave\n-            // space for them. This helps with lining up with previous\n-            // snippets from the actual error being reported.\n-            let mut lines = complete.lines();\n+            let suggestions = suggestion.splice_lines(cm.borrow());\n             let mut row_num = 1;\n-            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                buffer.append(row_num, line, Style::NoStyle);\n-                row_num += 1;\n-            }\n+            for complete in suggestions.iter().take(MAX_SUGGESTIONS) {\n+\n+                // print the suggestion without any line numbers, but leave\n+                // space for them. This helps with lining up with previous\n+                // snippets from the actual error being reported.\n+                let mut lines = complete.lines();\n+                for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                    buffer.append(row_num, line, Style::NoStyle);\n+                    row_num += 1;\n+                }\n \n-            // if we elided some lines, add an ellipsis\n-            if let Some(_) = lines.next() {\n-                buffer.append(row_num, \"...\", Style::NoStyle);\n+                // if we elided some lines, add an ellipsis\n+                if let Some(_) = lines.next() {\n+                    buffer.append(row_num, \"...\", Style::NoStyle);\n+                }\n+            }\n+            if suggestions.len() > MAX_SUGGESTIONS {\n+                let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n+                buffer.append(row_num, &msg, Style::NoStyle);\n             }\n             emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n         }"}, {"sha": "e1ec23479ab8a7ef84249db60c626b04a116787c", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -23,6 +23,7 @@\n #![feature(staged_api)]\n #![feature(range_contains)]\n #![feature(libc)]\n+#![feature(conservative_impl_trait)]\n \n extern crate term;\n extern crate libc;\n@@ -65,11 +66,35 @@ pub enum RenderSpan {\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct CodeSuggestion {\n-    pub msp: MultiSpan,\n-    pub substitutes: Vec<String>,\n+    /// Each substitute can have multiple variants due to multiple\n+    /// applicable suggestions\n+    ///\n+    /// `foo.bar` might be replaced with `a.b` or `x.y` by replacing\n+    /// `foo` and `bar` on their own:\n+    ///\n+    /// ```\n+    /// vec![\n+    ///     (0..3, vec![\"a\", \"x\"]),\n+    ///     (4..7, vec![\"b\", \"y\"]),\n+    /// ]\n+    /// ```\n+    ///\n+    /// or by replacing the entire span:\n+    ///\n+    /// ```\n+    /// vec![(0..7, vec![\"a.b\", \"x.y\"])]\n+    /// ```\n+    pub substitution_parts: Vec<Substitution>,\n     pub msg: String,\n }\n \n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+/// See the docs on `CodeSuggestion::substitutions`\n+pub struct Substitution {\n+    pub span: Span,\n+    pub substitutions: Vec<String>,\n+}\n+\n pub trait CodeMapper {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n@@ -79,8 +104,18 @@ pub trait CodeMapper {\n }\n \n impl CodeSuggestion {\n-    /// Returns the assembled code suggestion.\n-    pub fn splice_lines(&self, cm: &CodeMapper) -> String {\n+    /// Returns the number of substitutions\n+    fn substitutions(&self) -> usize {\n+        self.substitution_parts[0].substitutions.len()\n+    }\n+\n+    /// Returns the number of substitutions\n+    pub fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n+        self.substitution_parts.iter().map(|sub| sub.span)\n+    }\n+\n+    /// Returns the assembled code suggestions.\n+    pub fn splice_lines(&self, cm: &CodeMapper) -> Vec<String> {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n         fn push_trailing(buf: &mut String,\n@@ -102,20 +137,22 @@ impl CodeSuggestion {\n             }\n         }\n \n-        let mut primary_spans = self.msp.primary_spans().to_owned();\n-\n-        assert_eq!(primary_spans.len(), self.substitutes.len());\n-        if primary_spans.is_empty() {\n-            return format!(\"\");\n+        if self.substitution_parts.is_empty() {\n+            return vec![String::new()];\n         }\n \n+        let mut primary_spans: Vec<_> = self.substitution_parts\n+            .iter()\n+            .map(|sub| (sub.span, &sub.substitutions))\n+            .collect();\n+\n         // Assumption: all spans are in the same file, and all spans\n         // are disjoint. Sort in ascending order.\n-        primary_spans.sort_by_key(|sp| sp.lo);\n+        primary_spans.sort_by_key(|sp| sp.0.lo);\n \n         // Find the bounding span.\n-        let lo = primary_spans.iter().map(|sp| sp.lo).min().unwrap();\n-        let hi = primary_spans.iter().map(|sp| sp.hi).min().unwrap();\n+        let lo = primary_spans.iter().map(|sp| sp.0.lo).min().unwrap();\n+        let hi = primary_spans.iter().map(|sp| sp.0.hi).min().unwrap();\n         let bounding_span = Span {\n             lo: lo,\n             hi: hi,\n@@ -138,33 +175,40 @@ impl CodeSuggestion {\n         prev_hi.col = CharPos::from_usize(0);\n \n         let mut prev_line = fm.get_line(lines.lines[0].line_index);\n-        let mut buf = String::new();\n+        let mut bufs = vec![String::new(); self.substitutions()];\n \n-        for (sp, substitute) in primary_spans.iter().zip(self.substitutes.iter()) {\n+        for (sp, substitutes) in primary_spans {\n             let cur_lo = cm.lookup_char_pos(sp.lo);\n-            if prev_hi.line == cur_lo.line {\n-                push_trailing(&mut buf, prev_line, &prev_hi, Some(&cur_lo));\n-            } else {\n-                push_trailing(&mut buf, prev_line, &prev_hi, None);\n-                // push lines between the previous and current span (if any)\n-                for idx in prev_hi.line..(cur_lo.line - 1) {\n-                    if let Some(line) = fm.get_line(idx) {\n-                        buf.push_str(line);\n-                        buf.push('\\n');\n+            for (buf, substitute) in bufs.iter_mut().zip(substitutes) {\n+                if prev_hi.line == cur_lo.line {\n+                    push_trailing(buf, prev_line, &prev_hi, Some(&cur_lo));\n+                } else {\n+                    push_trailing(buf, prev_line, &prev_hi, None);\n+                    // push lines between the previous and current span (if any)\n+                    for idx in prev_hi.line..(cur_lo.line - 1) {\n+                        if let Some(line) = fm.get_line(idx) {\n+                            buf.push_str(line);\n+                            buf.push('\\n');\n+                        }\n+                    }\n+                    if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n+                        buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n                     }\n                 }\n-                if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n-                    buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n-                }\n+                buf.push_str(substitute);\n             }\n-            buf.push_str(substitute);\n             prev_hi = cm.lookup_char_pos(sp.hi);\n             prev_line = fm.get_line(prev_hi.line - 1);\n         }\n-        push_trailing(&mut buf, prev_line, &prev_hi, None);\n-        // remove trailing newline\n-        buf.pop();\n-        buf\n+        for buf in &mut bufs {\n+            // if the replacement already ends with a newline, don't print the next line\n+            if !buf.ends_with('\\n') {\n+                push_trailing(buf, prev_line, &prev_hi, None);\n+            }\n+            // remove trailing newline\n+            buf.pop();\n+        }\n+        bufs\n     }\n }\n "}, {"sha": "57639a1ecef7b17b359436a928f5a815602e22c7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -150,7 +150,7 @@ impl<'a> Resolver<'a> {\n                                           view_path.span,\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         } else if source_name == \"$crate\" && full_path.segments.len() == 1 {\n-                            let crate_root = self.resolve_crate_var(source.ctxt);\n+                            let crate_root = self.resolve_crate_var(source.ctxt, item.span);\n                             let crate_name = match crate_root.kind {\n                                 ModuleKind::Def(_, name) => name,\n                                 ModuleKind::Block(..) => unreachable!(),\n@@ -247,7 +247,7 @@ impl<'a> Resolver<'a> {\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n-                let module = self.get_extern_crate_root(crate_id);\n+                let module = self.get_extern_crate_root(crate_id, item.span);\n                 self.populate_module_if_necessary(module);\n                 let used = self.process_legacy_macro_imports(item, module, expansion);\n                 let binding =\n@@ -279,7 +279,7 @@ impl<'a> Resolver<'a> {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n-                    ..ModuleData::new(Some(parent), module_kind, def_id)\n+                    ..ModuleData::new(Some(parent), module_kind, def_id, item.span)\n                 });\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(def_id, module);\n@@ -314,7 +314,10 @@ impl<'a> Resolver<'a> {\n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n                 let module_kind = ModuleKind::Def(def, ident.name);\n-                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                let module = self.new_module(parent,\n+                                             module_kind,\n+                                             parent.normal_ancestor_id,\n+                                             item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n@@ -370,7 +373,10 @@ impl<'a> Resolver<'a> {\n \n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(Def::Trait(def_id), ident.name);\n-                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                let module = self.new_module(parent,\n+                                             module_kind,\n+                                             parent.normal_ancestor_id,\n+                                             item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n@@ -418,8 +424,10 @@ impl<'a> Resolver<'a> {\n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n-            let module =\n-                self.new_module(parent, ModuleKind::Block(block.id), parent.normal_ancestor_id);\n+            let module = self.new_module(parent,\n+                                         ModuleKind::Block(block.id),\n+                                         parent.normal_ancestor_id,\n+                                         block.span);\n             self.block_map.insert(block.id, module);\n             self.current_module = module; // Descend into the block.\n         }\n@@ -431,10 +439,14 @@ impl<'a> Resolver<'a> {\n         let def = child.def;\n         let def_id = def.def_id();\n         let vis = self.session.cstore.visibility(def_id);\n+        let span = child.span;\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), def_id);\n+                let module = self.new_module(parent,\n+                                             ModuleKind::Def(def, ident.name),\n+                                             def_id,\n+                                             span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) | Def::TyAlias(..) => {\n@@ -454,7 +466,10 @@ impl<'a> Resolver<'a> {\n             }\n             Def::Trait(..) => {\n                 let module_kind = ModuleKind::Def(def, ident.name);\n-                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                let module = self.new_module(parent,\n+                                             module_kind,\n+                                             parent.normal_ancestor_id,\n+                                             span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 for child in self.session.cstore.item_children(def_id) {\n@@ -483,18 +498,18 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'a> {\n+    fn get_extern_crate_root(&mut self, cnum: CrateNum, span: Span) -> Module<'a> {\n         let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n         let name = self.session.cstore.crate_name(cnum);\n         let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n         let module_kind = ModuleKind::Def(Def::Mod(def_id), name);\n         let arenas = self.arenas;\n         *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleData::new(None, module_kind, def_id))\n+            arenas.alloc_module(ModuleData::new(None, module_kind, def_id, span))\n         })\n     }\n \n-    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n+    pub fn macro_def_scope(&mut self, expansion: Mark, span: Span) -> Module<'a> {\n         let def_id = self.macro_defs[&expansion];\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n@@ -503,7 +518,7 @@ impl<'a> Resolver<'a> {\n             self.graph_root\n         } else {\n             let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n-            self.get_extern_crate_root(module_def_id.krate)\n+            self.get_extern_crate_root(module_def_id.krate, span)\n         }\n     }\n \n@@ -593,7 +608,8 @@ impl<'a> Resolver<'a> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let ident = Ident::with_empty_ctxt(name);\n-                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS,\n+                                                          false, false, span);\n                 if let Ok(binding) = result {\n                     let directive = macro_use_directive(span);\n                     self.potentially_unused_imports.push(directive);\n@@ -607,7 +623,7 @@ impl<'a> Resolver<'a> {\n         for (name, span) in legacy_imports.reexports {\n             self.session.cstore.export_macros(module.def_id().unwrap().krate);\n             let ident = Ident::with_empty_ctxt(name);\n-            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n+            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def(), span: span });\n             } else {"}, {"sha": "6054f46370e3257ccc98c95ed8f16d9e34206128", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 77, "deletions": 61, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -613,7 +613,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n         } else if let TyKind::ImplicitSelf = ty.node {\n             let self_ty = keywords::SelfType.ident();\n-            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.span))\n+            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, true, ty.span)\n                           .map_or(Def::Err, |d| d.def());\n             self.record_def(ty.id, PathResolution::new(def));\n         } else if let TyKind::Array(ref element, ref length) = ty.node {\n@@ -865,12 +865,18 @@ pub struct ModuleData<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n+\n+    /// Span of the module itself. Used for error reporting.\n+    span: Span,\n }\n \n pub type Module<'a> = &'a ModuleData<'a>;\n \n impl<'a> ModuleData<'a> {\n-    fn new(parent: Option<Module<'a>>, kind: ModuleKind, normal_ancestor_id: DefId) -> Self {\n+    fn new(parent: Option<Module<'a>>,\n+           kind: ModuleKind,\n+           normal_ancestor_id: DefId,\n+           span: Span) -> Self {\n         ModuleData {\n             parent: parent,\n             kind: kind,\n@@ -884,6 +890,7 @@ impl<'a> ModuleData<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(normal_ancestor_id.is_local()),\n+            span: span,\n         }\n     }\n \n@@ -1260,11 +1267,11 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n-        match self.resolve_path(&path, Some(namespace), Some(span)) {\n+        match self.resolve_path(&path, Some(namespace), true, span) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(&path, None, Some(span)) {\n+            PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span) {\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n@@ -1298,7 +1305,7 @@ impl<'a> Resolver<'a> {\n         let root_module_kind = ModuleKind::Def(Def::Mod(root_def_id), keywords::Invalid.name());\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleData::new(None, root_module_kind, root_def_id)\n+            ..ModuleData::new(None, root_module_kind, root_def_id, krate.span)\n         });\n         let mut module_map = FxHashMap();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n@@ -1430,9 +1437,14 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n-    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, normal_ancestor_id: DefId)\n-                  -> Module<'a> {\n-        self.arenas.alloc_module(ModuleData::new(Some(parent), kind, normal_ancestor_id))\n+    fn new_module(\n+        &self,\n+        parent: Module<'a>,\n+        kind: ModuleKind,\n+        normal_ancestor_id: DefId,\n+        span: Span,\n+    ) -> Module<'a> {\n+        self.arenas.alloc_module(ModuleData::new(Some(parent), kind, normal_ancestor_id, span))\n     }\n \n     fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n@@ -1490,7 +1502,8 @@ impl<'a> Resolver<'a> {\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       mut ident: Ident,\n                                       ns: Namespace,\n-                                      record_used: Option<Span>)\n+                                      record_used: bool,\n+                                      path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n             ident = ident.unhygienize();\n@@ -1501,12 +1514,13 @@ impl<'a> Resolver<'a> {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Def(\n-                    self.adjust_local_def(ns, i, def, record_used)\n+                    self.adjust_local_def(ns, i, def, record_used, path_span)\n                 ));\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let item = self.resolve_ident_in_module(module, ident, ns, false, record_used);\n+                let item = self.resolve_ident_in_module(module, ident, ns, false,\n+                                                        record_used, path_span);\n                 if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1515,7 +1529,8 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_ident_in_module(prelude, ident, ns, false, None).ok()\n+                        self.resolve_ident_in_module(prelude, ident, ns, false,\n+                                                     false, path_span).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -1535,12 +1550,12 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext) -> Module<'a> {\n+    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext, span: Span) -> Module<'a> {\n         let mut ctxt_data = crate_var_ctxt.data();\n         while ctxt_data.prev_ctxt != SyntaxContext::empty() {\n             ctxt_data = ctxt_data.prev_ctxt.data();\n         }\n-        let module = self.macro_def_scope(ctxt_data.outer_mark);\n+        let module = self.macro_def_scope(ctxt_data.outer_mark, span);\n         if module.is_local() { self.graph_root } else { module }\n     }\n \n@@ -2135,7 +2150,8 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, None)\n+                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS,\n+                                                                      false, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n@@ -2241,7 +2257,7 @@ impl<'a> Resolver<'a> {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), None) {\n+                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), false, span) {\n                         PathResult::Module(module) => module.def(),\n                         _ => None,\n                     }.map_or(format!(\"\"), |def| format!(\"{} \", def.kind_name()));\n@@ -2271,8 +2287,10 @@ impl<'a> Resolver<'a> {\n             let name = path.last().unwrap().name;\n             let candidates = this.lookup_import_candidates(name, ns, is_expected);\n             if !candidates.is_empty() {\n+                let mut module_span = this.current_module.span;\n+                module_span.hi = module_span.lo;\n                 // Report import candidates as help and proceed searching for labels.\n-                show_candidates(&mut err, &candidates, def.is_some());\n+                show_candidates(&mut err, module_span, &candidates, def.is_some());\n             } else if is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates = this.lookup_import_candidates(name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n@@ -2289,9 +2307,9 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            if path.len() == 1 && this.self_type_is_available() {\n+            if path.len() == 1 && this.self_type_is_available(span) {\n                 if let Some(candidate) = this.lookup_assoc_candidate(name, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].ctxt);\n+                    let self_is_available = this.self_value_is_available(path[0].ctxt, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_label(span, format!(\"did you mean `self.{}`?\", path_str));\n@@ -2315,7 +2333,7 @@ impl<'a> Resolver<'a> {\n             let mut levenshtein_worked = false;\n \n             // Try Levenshtein.\n-            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n+            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected, span) {\n                 err.span_label(ident_span, format!(\"did you mean `{}`?\", candidate));\n                 levenshtein_worked = true;\n             }\n@@ -2420,14 +2438,15 @@ impl<'a> Resolver<'a> {\n         resolution\n     }\n \n-    fn self_type_is_available(&mut self) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(), TypeNS, None);\n+    fn self_type_is_available(&mut self, span: Span) -> bool {\n+        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n+                                                          TypeNS, false, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n-    fn self_value_is_available(&mut self, ctxt: SyntaxContext) -> bool {\n+    fn self_value_is_available(&mut self, ctxt: SyntaxContext, span: Span) -> bool {\n         let ident = Ident { name: keywords::SelfValue.name(), ctxt: ctxt };\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n@@ -2491,7 +2510,7 @@ impl<'a> Resolver<'a> {\n             ));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n+        let result = match self.resolve_path(&path, Some(ns), true, span) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(module) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n@@ -2537,7 +2556,7 @@ impl<'a> Resolver<'a> {\n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n            path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n@@ -2555,7 +2574,8 @@ impl<'a> Resolver<'a> {\n     fn resolve_path(&mut self,\n                     path: &[Ident],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n-                    record_used: Option<Span>)\n+                    record_used: bool,\n+                    path_span: Span)\n                     -> PathResult<'a> {\n         let mut module = None;\n         let mut allow_super = true;\n@@ -2584,25 +2604,25 @@ impl<'a> Resolver<'a> {\n                 module = Some(self.graph_root);\n                 continue\n             } else if i == 0 && ns == TypeNS && ident.name == \"$crate\" {\n-                module = Some(self.resolve_crate_var(ident.ctxt));\n+                module = Some(self.resolve_crate_var(ident.ctxt, path_span));\n                 continue\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, false, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n                         return PathResult::NonModule(PathResolution::with_unresolved_segments(\n                             def, path.len() - 1\n                         ));\n                     }\n-                    _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n+                    _ => Err(if record_used { Determined } else { Undetermined }),\n                 }\n             };\n \n@@ -2659,12 +2679,13 @@ impl<'a> Resolver<'a> {\n                         ns: Namespace,\n                         rib_index: usize,\n                         mut def: Def,\n-                        record_used: Option<Span>) -> Def {\n+                        record_used: bool,\n+                        span: Span) -> Def {\n         let ribs = &self.ribs[ns][rib_index + 1..];\n \n         // An invalid forward use of a type parameter from a previous default.\n         if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n-            if let Some(span) = record_used {\n+            if record_used {\n                 resolve_error(self, span,\n                         ResolutionError::ForwardDeclaredTyParam);\n             }\n@@ -2674,7 +2695,7 @@ impl<'a> Resolver<'a> {\n \n         match def {\n             Def::Upvar(..) => {\n-                span_bug!(record_used.unwrap_or(DUMMY_SP), \"unexpected {:?} in bindings\", def)\n+                span_bug!(span, \"unexpected {:?} in bindings\", def)\n             }\n             Def::Local(def_id) => {\n                 for rib in ribs {\n@@ -2700,7 +2721,7 @@ impl<'a> Resolver<'a> {\n                             let depth = vec.len();\n                             def = Def::Upvar(def_id, depth, function_id);\n \n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 vec.push(Freevar {\n                                     def: prev_def,\n                                     span: span,\n@@ -2712,15 +2733,15 @@ impl<'a> Resolver<'a> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n                             }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                         ResolutionError::AttemptToUseNonConstantValueInConstant);\n                             }\n@@ -2739,15 +2760,15 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind => {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                               ResolutionError::TypeParametersFromOuterFunction);\n                             }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                               ResolutionError::OuterTypeParameterContext);\n                             }\n@@ -2843,7 +2864,8 @@ impl<'a> Resolver<'a> {\n     fn lookup_typo_candidate<FilterFn>(&mut self,\n                                        path: &[Ident],\n                                        ns: Namespace,\n-                                       filter_fn: FilterFn)\n+                                       filter_fn: FilterFn,\n+                                       span: Span)\n                                        -> Option<Symbol>\n         where FilterFn: Fn(Def) -> bool\n     {\n@@ -2895,7 +2917,8 @@ impl<'a> Resolver<'a> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n+            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS),\n+                                                                  false, span) {\n                 add_module_candidates(module, &mut names);\n             }\n         }\n@@ -3396,7 +3419,10 @@ impl<'a> Resolver<'a> {\n                 continue\n             }\n             let ident = attr.path.segments[0].identifier;\n-            let result = self.resolve_lexical_macro_path_segment(ident, MacroNS, None);\n+            let result = self.resolve_lexical_macro_path_segment(ident,\n+                                                                 MacroNS,\n+                                                                 false,\n+                                                                 attr.path.span);\n             if let Ok(binding) = result {\n                 if let SyntaxExtension::AttrProcMacro(..) = *binding.binding().get_macro(self) {\n                     attr::mark_known(attr);\n@@ -3463,12 +3489,10 @@ fn import_candidate_to_paths(suggestion: &ImportSuggestion) -> (Span, String, St\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n-fn show_candidates(session: &mut DiagnosticBuilder,\n+fn show_candidates(err: &mut DiagnosticBuilder,\n+                   span: Span,\n                    candidates: &[ImportSuggestion],\n                    better: bool) {\n-    // don't show more than MAX_CANDIDATES results, so\n-    // we're consistent with the trait suggestions\n-    const MAX_CANDIDATES: usize = 4;\n \n     // we want consistent results across executions, but candidates are produced\n     // by iterating through a hash map, so make sure they are ordered:\n@@ -3481,21 +3505,13 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n         1 => \" is found in another module, you can import it\",\n         _ => \"s are found in other modules, you can import them\",\n     };\n+    let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n+\n+    for candidate in &mut path_strings {\n+        *candidate = format!(\"use {};\\n\", candidate);\n+    }\n \n-    let end = cmp::min(MAX_CANDIDATES, path_strings.len());\n-    session.help(&format!(\"possible {}candidate{} into scope:{}{}\",\n-                          better,\n-                          msg_diff,\n-                          &path_strings[0..end].iter().map(|candidate| {\n-                              format!(\"\\n  `use {};`\", candidate)\n-                          }).collect::<String>(),\n-                          if path_strings.len() > MAX_CANDIDATES {\n-                              format!(\"\\nand {} other candidates\",\n-                                      path_strings.len() - MAX_CANDIDATES)\n-                          } else {\n-                              \"\".to_owned()\n-                          }\n-                          ));\n+    err.span_suggestions(span, &msg, path_strings);\n }\n \n /// A somewhat inefficient routine to obtain the name of a module."}, {"sha": "c08421cb9374eb9efa04bf4183762a66c07287cc", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -123,14 +123,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> {\n-        struct EliminateCrateVar<'b, 'a: 'b>(&'b mut Resolver<'a>);\n+        struct EliminateCrateVar<'b, 'a: 'b>(&'b mut Resolver<'a>, Span);\n \n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == \"$crate\" {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_var(ident.ctxt);\n+                    let module = self.0.resolve_crate_var(ident.ctxt, self.1);\n                     if !module.is_local() {\n                         let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n@@ -149,7 +149,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         }\n \n-        EliminateCrateVar(self).fold_item(item).expect_one(\"\")\n+        EliminateCrateVar(self, item.span).fold_item(item).expect_one(\"\")\n     }\n \n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool {\n@@ -379,7 +379,7 @@ impl<'a> Resolver<'a> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let def = match self.resolve_path(&path, Some(MacroNS), None) {\n+            let def = match self.resolve_path(&path, Some(MacroNS), false, span) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => Ok(def),\n@@ -401,7 +401,7 @@ impl<'a> Resolver<'a> {\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -421,18 +421,19 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n                                               ident: Ident,\n                                               ns: Namespace,\n-                                              record_used: Option<Span>)\n+                                              record_used: bool,\n+                                              path_span: Span)\n                                               -> Result<MacroBinding<'a>, Determinacy> {\n         let mut module = Some(self.current_module);\n         let mut potential_illegal_shadower = Err(Determinacy::Determined);\n         let determinacy =\n-            if record_used.is_some() { Determinacy::Determined } else { Determinacy::Undetermined };\n+            if record_used { Determinacy::Determined } else { Determinacy::Undetermined };\n         loop {\n             let result = if let Some(module) = module {\n                 // Since expanded macros may not shadow the lexical scope and\n                 // globs may not shadow global macros (both enforced below),\n                 // we resolve with restricted shadowing (indicated by the penultimate argument).\n-                self.resolve_ident_in_module(module, ident, ns, true, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, true, record_used, path_span)\n                     .map(MacroBinding::Modern)\n             } else {\n                 self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n@@ -441,15 +442,18 @@ impl<'a> Resolver<'a> {\n \n             match result.map(MacroBinding::binding) {\n                 Ok(binding) => {\n-                    let span = match record_used {\n-                        Some(span) => span,\n-                        None => return result,\n-                    };\n+                    if !record_used {\n+                        return result;\n+                    }\n                     if let Ok(MacroBinding::Modern(shadower)) = potential_illegal_shadower {\n                         if shadower.def() != binding.def() {\n                             let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n-                                span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                                span: path_span,\n+                                name: name,\n+                                b1: shadower,\n+                                b2: binding,\n+                                lexical: true,\n                                 legacy: false,\n                             });\n                             return potential_illegal_shadower;\n@@ -543,7 +547,7 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(path, Some(MacroNS), Some(span)) {\n+            match self.resolve_path(path, Some(MacroNS), true, span) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -555,7 +559,7 @@ impl<'a> Resolver<'a> {\n         for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, span);\n             match (legacy_resolution, resolution) {\n                 (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n                     let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n@@ -579,7 +583,7 @@ impl<'a> Resolver<'a> {\n                             format!(\"cannot find derive macro `{}` in this scope\", ident),\n                     };\n                     let mut err = self.session.struct_span_err(span, &msg);\n-                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err);\n+                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n                 _ => {},\n@@ -588,7 +592,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n-                          err: &mut DiagnosticBuilder<'a>) {\n+                          err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n             find_best_match_for_name(self.macro_names.iter(), name, None)\n@@ -619,7 +623,7 @@ impl<'a> Resolver<'a> {\n                 }\n             };\n             let ident = Ident::from_str(name);\n-            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "1d4ba4ed100b72e3139fbcf29b42e70e1e9eed13", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -146,15 +146,16 @@ impl<'a> Resolver<'a> {\n                                    ident: Ident,\n                                    ns: Namespace,\n                                    restricted_shadowing: bool,\n-                                   record_used: Option<Span>)\n+                                   record_used: bool,\n+                                   path_span: Span)\n                                    -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n \n-        if let Some(span) = record_used {\n+        if record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n                     let name = ident.name;\n@@ -164,16 +165,20 @@ impl<'a> Resolver<'a> {\n                        ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n                        binding.def() != shadowed_glob.def() {\n                         self.ambiguity_errors.push(AmbiguityError {\n-                            span: span, name: name, lexical: false, b1: binding, b2: shadowed_glob,\n+                            span: path_span,\n+                            name: name,\n+                            lexical: false,\n+                            b1: binding,\n+                            b2: shadowed_glob,\n                             legacy: false,\n                         });\n                     }\n                 }\n-                if self.record_use(ident, ns, binding, span) {\n+                if self.record_use(ident, ns, binding, path_span) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(span, ident.name, binding));\n+                    self.privacy_errors.push(PrivacyError(path_span, ident.name, binding));\n                 }\n             }\n \n@@ -205,7 +210,7 @@ impl<'a> Resolver<'a> {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_ident_in_module(module, ident, ns, false, None) {\n+                match self.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n                     Err(Determined) => {}\n                     _ => return Err(Undetermined),\n                 }\n@@ -230,7 +235,12 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_ident_in_module(module, ident, ns, false, None);\n+                    let result = self.resolve_ident_in_module(module,\n+                                                              ident,\n+                                                              ns,\n+                                                              false,\n+                                                              false,\n+                                                              path_span);\n                     if let Err(Undetermined) = result {\n                         return Err(Undetermined);\n                     }\n@@ -499,7 +509,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path, None, None);\n+            let result = self.resolve_path(&directive.module_path, None, false, directive.span);\n             directive.vis.set(vis);\n \n             match result {\n@@ -523,7 +533,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n+                result[ns].set(this.resolve_ident_in_module(module,\n+                                                            source,\n+                                                            ns,\n+                                                            false,\n+                                                            false,\n+                                                            directive.span));\n             } else {\n                 return\n             };\n@@ -563,14 +578,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let module_result = self.resolve_path(&module_path, None, Some(span));\n+        let module_result = self.resolve_path(&module_path, None, true, span);\n         let module = match module_result {\n             PathResult::Module(module) => module,\n             PathResult::Failed(msg, _) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n                 if !self_path.is_empty() && !token::Ident(self_path[0]).is_path_segment_keyword() {\n                     self_path[0].name = keywords::SelfValue.name();\n-                    self_result = Some(self.resolve_path(&self_path, None, None));\n+                    self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n                     Some(format!(\"Did you mean `{}`?\", names_to_string(&self_path)))\n@@ -609,7 +624,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         Some(this.dummy_binding);\n                 }\n             }\n-        } else if let Ok(binding) = this.resolve_ident_in_module(module, ident, ns, false, None) {\n+        } else if let Ok(binding) = this.resolve_ident_in_module(module,\n+                                                                 ident,\n+                                                                 ns,\n+                                                                 false,\n+                                                                 false,\n+                                                                 directive.span) {\n             legacy_self_import = Some(directive);\n             let binding = this.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Import {\n@@ -630,7 +650,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n+                match this.resolve_ident_in_module(module, ident, ns, false, true, span) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }"}, {"sha": "06335584c96108571e0136a1ba84a052270820e9", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -22,9 +22,8 @@\n use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n-use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n+use errors::{DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n use errors::emitter::Emitter;\n-use errors::snippet::Style;\n \n use std::rc::Rc;\n use std::io::{self, Write};\n@@ -154,23 +153,26 @@ impl Diagnostic {\n     fn from_diagnostic_builder(db: &DiagnosticBuilder,\n                                je: &JsonEmitter)\n                                -> Diagnostic {\n-        let sugg = db.suggestion.as_ref().map(|sugg| {\n-            SubDiagnostic {\n-                level: Level::Help,\n-                message: vec![(sugg.msg.clone(), Style::NoStyle)],\n-                span: MultiSpan::new(),\n-                render_span: Some(RenderSpan::Suggestion(sugg.clone())),\n-            }\n+        let sugg = db.suggestions.iter().flat_map(|sugg| {\n+            je.render(sugg).into_iter().map(move |rendered| {\n+                Diagnostic {\n+                    message: sugg.msg.clone(),\n+                    code: None,\n+                    level: \"help\",\n+                    spans: DiagnosticSpan::from_suggestion(sugg, je),\n+                    children: vec![],\n+                    rendered: Some(rendered),\n+                }\n+            })\n         });\n-        let sugg = sugg.as_ref();\n         Diagnostic {\n             message: db.message(),\n             code: DiagnosticCode::map_opt_string(db.code.clone(), je),\n             level: db.level.to_str(),\n             spans: DiagnosticSpan::from_multispan(&db.span, je),\n-            children: db.children.iter().chain(sugg).map(|c| {\n+            children: db.children.iter().map(|c| {\n                 Diagnostic::from_sub_diagnostic(c, je)\n-            }).collect(),\n+            }).chain(sugg).collect(),\n             rendered: None,\n         }\n     }\n@@ -184,8 +186,7 @@ impl Diagnostic {\n                      .map(|sp| DiagnosticSpan::from_render_span(sp, je))\n                      .unwrap_or_else(|| DiagnosticSpan::from_multispan(&db.span, je)),\n             children: vec![],\n-            rendered: db.render_span.as_ref()\n-                                    .and_then(|rsp| je.render(rsp)),\n+            rendered: None,\n         }\n     }\n }\n@@ -278,14 +279,19 @@ impl DiagnosticSpan {\n \n     fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)\n                        -> Vec<DiagnosticSpan> {\n-        assert_eq!(suggestion.msp.span_labels().len(), suggestion.substitutes.len());\n-        suggestion.msp.span_labels()\n-                      .into_iter()\n-                      .zip(&suggestion.substitutes)\n-                      .map(|(span_label, suggestion)| {\n-                          DiagnosticSpan::from_span_label(span_label,\n-                                                          Some(suggestion),\n-                                                          je)\n+        suggestion.substitution_parts\n+                      .iter()\n+                      .flat_map(|substitution| {\n+                          substitution.substitutions.iter().map(move |suggestion| {\n+                              let span_label = SpanLabel {\n+                                  span: substitution.span,\n+                                  is_primary: true,\n+                                  label: None,\n+                              };\n+                              DiagnosticSpan::from_span_label(span_label,\n+                                                              Some(suggestion),\n+                                                              je)\n+                          })\n                       })\n                       .collect()\n     }\n@@ -294,8 +300,9 @@ impl DiagnosticSpan {\n         match *rsp {\n             RenderSpan::FullSpan(ref msp) =>\n                 DiagnosticSpan::from_multispan(msp, je),\n-            RenderSpan::Suggestion(ref suggestion) =>\n-                DiagnosticSpan::from_suggestion(suggestion, je),\n+            // regular diagnostics don't produce this anymore\n+            // FIXME(oli_obk): remove it entirely\n+            RenderSpan::Suggestion(_) => unreachable!(),\n         }\n     }\n }\n@@ -351,17 +358,8 @@ impl DiagnosticCode {\n }\n \n impl JsonEmitter {\n-    fn render(&self, render_span: &RenderSpan) -> Option<String> {\n-        use std::borrow::Borrow;\n-\n-        match *render_span {\n-            RenderSpan::FullSpan(_) => {\n-                None\n-            }\n-            RenderSpan::Suggestion(ref suggestion) => {\n-                Some(suggestion.splice_lines(self.cm.borrow()))\n-            }\n-        }\n+    fn render(&self, suggestion: &CodeSuggestion) -> Vec<String> {\n+        suggestion.splice_lines(&*self.cm)\n     }\n }\n "}, {"sha": "001c1f2eddca1e3ccbeabaf58450b6296547847c", "filename": "src/test/compile-fail/issue-35675.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Fruit {\n+// these two HELPs are actually in a new line between this line and the `enum Fruit` line\n+enum Fruit { //~ HELP possible candidate is found in another module, you can import it into scope\n+    //~^ HELP possible candidate is found in another module, you can import it into scope\n     Apple(i64),\n     //~^ HELP there is an enum variant `Fruit::Apple`, did you mean to use `Fruit`?\n     //~| HELP there is an enum variant `Fruit::Apple`, did you mean to use `Fruit`?\n@@ -21,7 +23,6 @@ fn should_return_fruit() -> Apple {\n     Apple(5)\n     //~^ ERROR cannot find function `Apple` in this scope\n     //~| NOTE not found in this scope\n-    //~| HELP possible candidate is found in another module, you can import it into scope\n }\n \n fn should_return_fruit_too() -> Fruit::Apple {\n@@ -30,7 +31,6 @@ fn should_return_fruit_too() -> Fruit::Apple {\n     Apple(5)\n     //~^ ERROR cannot find function `Apple` in this scope\n     //~| NOTE not found in this scope\n-    //~| HELP possible candidate is found in another module, you can import it into scope\n }\n \n fn foo() -> Ok {"}, {"sha": "17c5d5d15d40479415e0c5503c248ace94e25045", "filename": "src/test/ui/resolve/enums-are-namespaced-xc.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,26 +4,26 @@ error[E0425]: cannot find value `A` in module `namespaced_enums`\n 15 |     let _ = namespaced_enums::A;\n    |                               ^ not found in `namespaced_enums`\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use namespaced_enums::Foo::A;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use namespaced_enums::Foo::A;\n \n error[E0425]: cannot find function `B` in module `namespaced_enums`\n   --> $DIR/enums-are-namespaced-xc.rs:18:31\n    |\n 18 |     let _ = namespaced_enums::B(10);\n    |                               ^ not found in `namespaced_enums`\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use namespaced_enums::Foo::B;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use namespaced_enums::Foo::B;\n \n error[E0422]: cannot find struct, variant or union type `C` in module `namespaced_enums`\n   --> $DIR/enums-are-namespaced-xc.rs:21:31\n    |\n 21 |     let _ = namespaced_enums::C { a: 10 };\n    |                               ^ not found in `namespaced_enums`\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use namespaced_enums::Foo::C;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use namespaced_enums::Foo::C;\n \n error: aborting due to 3 previous errors\n "}, {"sha": "63d2ce109142c70116181304aad38511fcb51325", "filename": "src/test/ui/resolve/issue-16058.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,10 +4,10 @@ error[E0574]: expected struct, variant or union type, found enum `Result`\n 19 |         Result {\n    |         ^^^^^^ not a struct, variant or union type\n    |\n-   = help: possible better candidates are found in other modules, you can import them into scope:\n-             `use std::fmt::Result;`\n-             `use std::io::Result;`\n-             `use std::thread::Result;`\n+help: possible better candidates are found in other modules, you can import them into scope\n+   | use std::fmt::Result;\n+   | use std::io::Result;\n+   | use std::thread::Result;\n \n error: aborting due to previous error\n "}, {"sha": "c0438abfe43b45cd5458eb302868063ff96c15df", "filename": "src/test/ui/resolve/issue-17518.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,8 +4,8 @@ error[E0422]: cannot find struct, variant or union type `E` in this scope\n 16 |     E { name: \"foobar\" }; //~ ERROR unresolved struct, variant or union type `E`\n    |     ^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use SomeEnum::E;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use SomeEnum::E;\n \n error: aborting due to previous error\n "}, {"sha": "7315d295f7b8427a9c84cafe3cfa3a37539d3d89", "filename": "src/test/ui/resolve/issue-21221-1.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,23 +4,23 @@ error[E0405]: cannot find trait `Mul` in this scope\n 53 | impl Mul for Foo {\n    |      ^^^ not found in this scope\n    |\n-   = help: possible candidates are found in other modules, you can import them into scope:\n-             `use mul1::Mul;`\n-             `use mul2::Mul;`\n-             `use std::ops::Mul;`\n+help: possible candidates are found in other modules, you can import them into scope\n+   | use mul1::Mul;\n+   | use mul2::Mul;\n+   | use std::ops::Mul;\n \n error[E0412]: cannot find type `Mul` in this scope\n   --> $DIR/issue-21221-1.rs:72:16\n    |\n 72 | fn getMul() -> Mul {\n    |                ^^^ not found in this scope\n    |\n-   = help: possible candidates are found in other modules, you can import them into scope:\n-             `use mul1::Mul;`\n-             `use mul2::Mul;`\n-             `use mul3::Mul;`\n-             `use mul4::Mul;`\n-           and 2 other candidates\n+help: possible candidates are found in other modules, you can import them into scope\n+   | use mul1::Mul;\n+   | use mul2::Mul;\n+   | use mul3::Mul;\n+   | use mul4::Mul;\n+and 2 other candidates\n \n error[E0405]: cannot find trait `ThisTraitReallyDoesntExistInAnyModuleReally` in this scope\n   --> $DIR/issue-21221-1.rs:83:6\n@@ -34,8 +34,8 @@ error[E0405]: cannot find trait `Div` in this scope\n 88 | impl Div for Foo {\n    |      ^^^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use std::ops::Div;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use std::ops::Div;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "f0b22754e6444607af28f16310bbe92a490c5f7e", "filename": "src/test/ui/resolve/issue-21221-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,8 +4,8 @@ error[E0405]: cannot find trait `T` in this scope\n 28 | impl T for Foo { }\n    |      ^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use foo::bar::T;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use foo::bar::T;\n \n error: main function not found\n "}, {"sha": "a4a2496b19ae4c0b85c070945fa4fff4d35e0f54", "filename": "src/test/ui/resolve/issue-21221-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,8 +4,8 @@ error[E0405]: cannot find trait `OuterTrait` in this scope\n 25 | impl OuterTrait for Foo {}\n    |      ^^^^^^^^^^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use issue_21221_3::outer::OuterTrait;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use issue_21221_3::outer::OuterTrait;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "dc2f22717313320616be267464421c8f15841708", "filename": "src/test/ui/resolve/issue-21221-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,8 +4,8 @@ error[E0405]: cannot find trait `T` in this scope\n 20 | impl T for Foo {}\n    |      ^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use issue_21221_4::T;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use issue_21221_4::T;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "0bf39dc55cee76a5b30d073f3c532380d2b7c5af", "filename": "src/test/ui/resolve/issue-3907.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,8 +4,8 @@ error[E0404]: expected trait, found type alias `Foo`\n 20 | impl Foo for S { //~ ERROR expected trait, found type alias `Foo`\n    |      ^^^ type aliases cannot be used for traits\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use issue_3907::Foo;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use issue_3907::Foo;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "19940ff4586d2e3baf028f71ebecec7ba96804f9", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -8,8 +8,8 @@ error[E0423]: expected value, found struct `Z`\n    |         did you mean `S`?\n    |         constructor is not visible here due to private fields\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use m::n::Z;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use m::n::Z;\n \n error[E0423]: expected value, found struct `S`\n   --> $DIR/privacy-struct-ctor.rs:36:5\n@@ -20,8 +20,8 @@ error[E0423]: expected value, found struct `S`\n    |     did you mean `S { /* fields */ }`?\n    |     constructor is not visible here due to private fields\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use m::S;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use m::S;\n \n error[E0423]: expected value, found struct `xcrate::S`\n   --> $DIR/privacy-struct-ctor.rs:42:5\n@@ -32,8 +32,8 @@ error[E0423]: expected value, found struct `xcrate::S`\n    |     did you mean `xcrate::S { /* fields */ }`?\n    |     constructor is not visible here due to private fields\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use m::S;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use m::S;\n \n error: tuple struct `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:25:9"}, {"sha": "e53ea6a55afb5dc3a9b1028bba5f5d89312fe0e9", "filename": "src/test/ui/span/issue-35987.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr?ref=1f7266205fa7f2c7665e2dafeb7d973fb2f5b00b", "patch": "@@ -4,8 +4,8 @@ error[E0404]: expected trait, found type parameter `Add`\n 15 | impl<T: Clone, Add> Add for Foo<T> {\n    |                     ^^^ not a trait\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use std::ops::Add;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use std::ops::Add;\n \n error: main function not found\n "}]}