{"sha": "2ec0e148f1848a483104f809412cfc0bef1d3c3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYzBlMTQ4ZjE4NDhhNDgzMTA0ZjgwOTQxMmNmYzBiZWYxZDNjM2Y=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-05T16:47:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-05T16:47:47Z"}, "message": "Rollup merge of #70795 - Amanieu:btree_remove_tracking, r=Mark-Simulacrum\n\nKeep track of position when deleting from a BTreeMap\n\nThis improves the performance of drain_filter and is needed for future Cursor support for BTreeMap.\n\ncc @ssomers\nr? @Mark-Simulacrum", "tree": {"sha": "ec9a1941ae4741c61bb0bc4f38f98b6de6ace907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec9a1941ae4741c61bb0bc4f38f98b6de6ace907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ec0e148f1848a483104f809412cfc0bef1d3c3f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeiguzCRBK7hj4Ov3rIwAAdHIIAFsuMwLuoeKSDR8iIG+fmoCm\ndCHH6aP4CUw1AMicwREmnqIQtIPazH1aN8k4FyxwGCnP1pBt65PL22MslB/Ip3Wb\nofHzj3l9/Z0nTwtA5IUx4Y/DUAxBwF+WLDfAhgAgNSyXmQm8HPJ+WEgVSUNAXhDt\nBDoj/Pc8q4K4vjTL0pGjX2NO4hOtdcYSUO+ErlVwaFjrw+8Bow5bmpdmkLB8e5dJ\nQyDqo74cnLbWFuxMHCWY9gSZq0DcAv8soIdt1JQ7l0Wcy8NZfCutZ1zFi1GHG2ro\nV8VTIsBz/niwZt4Qd5yG0651CG3aNCyIeGp39h3AbT0mVFNK+GN61ARqN63l8UQ=\n=IYlZ\n-----END PGP SIGNATURE-----\n", "payload": "tree ec9a1941ae4741c61bb0bc4f38f98b6de6ace907\nparent c2595539e7fd3e8b1986d30c25d8bf8717402bec\nparent 51357cf1cd8804a69450a2908f24c4b50942c067\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586105267 +0200\ncommitter GitHub <noreply@github.com> 1586105267 +0200\n\nRollup merge of #70795 - Amanieu:btree_remove_tracking, r=Mark-Simulacrum\n\nKeep track of position when deleting from a BTreeMap\n\nThis improves the performance of drain_filter and is needed for future Cursor support for BTreeMap.\n\ncc @ssomers\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec0e148f1848a483104f809412cfc0bef1d3c3f", "html_url": "https://github.com/rust-lang/rust/commit/2ec0e148f1848a483104f809412cfc0bef1d3c3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ec0e148f1848a483104f809412cfc0bef1d3c3f/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2595539e7fd3e8b1986d30c25d8bf8717402bec", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2595539e7fd3e8b1986d30c25d8bf8717402bec", "html_url": "https://github.com/rust-lang/rust/commit/c2595539e7fd3e8b1986d30c25d8bf8717402bec"}, {"sha": "51357cf1cd8804a69450a2908f24c4b50942c067", "url": "https://api.github.com/repos/rust-lang/rust/commits/51357cf1cd8804a69450a2908f24c4b50942c067", "html_url": "https://github.com/rust-lang/rust/commit/51357cf1cd8804a69450a2908f24c4b50942c067"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "70968964f476e1b821631a4c56e237d006998a6f", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2ec0e148f1848a483104f809412cfc0bef1d3c3f/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec0e148f1848a483104f809412cfc0bef1d3c3f/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=2ec0e148f1848a483104f809412cfc0bef1d3c3f", "patch": "@@ -1780,18 +1780,12 @@ where\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        while let Some(kv) = unsafe { self.next_kv() } {\n-            let (k, v) = unsafe { ptr::read(&kv) }.into_kv_mut();\n+        while let Some(mut kv) = unsafe { self.next_kv() } {\n+            let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n                 let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n-                // `remove_kv_tracking` has either preserved or invalidated `self.cur_leaf_edge`\n-                if let Some(node) = leaf_edge_location {\n-                    match search::search_tree(node, &k) {\n-                        search::SearchResult::Found(_) => unreachable!(),\n-                        search::SearchResult::GoDown(leaf) => self.cur_leaf_edge = Some(leaf),\n-                    }\n-                };\n+                self.cur_leaf_edge = Some(leaf_edge_location);\n                 return Some((k, v));\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n@@ -2698,108 +2692,124 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the whereabouts of the leaf edge corresponding to that former pair:\n-    /// if None is returned, the leaf edge is still the left leaf edge of the KV handle;\n-    /// if a node is returned, it heads the subtree where the leaf edge may be found.\n+    /// the leaf edge corresponding to that former pair.\n     fn remove_kv_tracking(\n         self,\n-    ) -> (K, V, Option<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>>) {\n-        let mut levels_down_handled: isize;\n-        let (small_leaf, old_key, old_val) = match self.force() {\n+    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n-                levels_down_handled = 1; // handled at same level, but affects only the right side\n                 let (hole, old_key, old_val) = leaf.remove();\n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, false)\n             }\n             Internal(mut internal) => {\n                 // Replace the location freed in the internal node with the next KV,\n                 // and remove that next KV from its leaf.\n-                levels_down_handled = unsafe { ptr::read(&internal).into_node().height() } as isize;\n \n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                let to_remove = internal.right_edge().descend().first_leaf_edge().right_kv().ok();\n+                // Deleting from the left side is typically faster since we can\n+                // just pop an element from the end of the KV array without\n+                // needing to shift the other values.\n+                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n                 let (hole, key, val) = to_remove.remove();\n \n                 let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n                 let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n \n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, true)\n             }\n         };\n \n         // Handle underflow\n-        let mut cur_node = small_leaf.forget_type();\n+        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n+        let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n-                AtRoot(root) => {\n-                    cur_node = root;\n-                    break;\n-                }\n-                EmptyParent(_) => unreachable!(),\n-                Merged(parent) => {\n-                    levels_down_handled -= 1;\n+                AtRoot => break,\n+                Merged(edge, merged_with_left, offset) => {\n+                    // If we merged with our right sibling then our tracked\n+                    // position has not changed. However if we merged with our\n+                    // left sibling then our tracked position is now dangling.\n+                    if at_leaf && merged_with_left {\n+                        let idx = pos.idx() + offset;\n+                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n+                            Leaf(leaf) => leaf,\n+                            Internal(_) => unreachable!(),\n+                        };\n+                        pos = unsafe { Handle::new_edge(node, idx) };\n+                    }\n+\n+                    let parent = edge.into_node();\n                     if parent.len() == 0 {\n                         // We must be at the root\n-                        let root = parent.into_root_mut();\n-                        root.pop_level();\n-                        cur_node = root.as_mut();\n+                        parent.into_root_mut().pop_level();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n+                        at_leaf = false;\n                     }\n                 }\n-                Stole(internal_node) => {\n-                    levels_down_handled -= 1;\n-                    cur_node = internal_node.forget_type();\n+                Stole(stole_from_left) => {\n+                    // Adjust the tracked position if we stole from a left sibling\n+                    if stole_from_left && at_leaf {\n+                        // SAFETY: This is safe since we just added an element to our node.\n+                        unsafe {\n+                            pos.next_unchecked();\n+                        }\n+                    }\n+\n                     // This internal node might be underfull, but only if it's the root.\n                     break;\n                 }\n             }\n         }\n \n-        let leaf_edge_location = if levels_down_handled > 0 { None } else { Some(cur_node) };\n-        (old_key, old_val, leaf_edge_location)\n+        // If we deleted from an internal node then we need to compensate for\n+        // the earlier swap and adjust the tracked position to point to the\n+        // next element.\n+        if was_internal {\n+            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n+        }\n+\n+        (old_key, old_val, pos)\n     }\n }\n \n enum UnderflowResult<'a, K, V> {\n-    AtRoot(NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>),\n-    EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    AtRoot,\n+    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n+    Stole(bool),\n }\n \n fn handle_underfull_node<K, V>(\n     node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n ) -> UnderflowResult<'_, K, V> {\n     let parent = match node.ascend() {\n         Ok(parent) => parent,\n-        Err(root) => return AtRoot(root),\n+        Err(_) => return AtRoot,\n     };\n \n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n-        Err(parent) => match parent.right_kv() {\n-            Ok(right) => (false, right),\n-            Err(parent) => {\n-                return EmptyParent(parent.into_node());\n-            }\n-        },\n+        Err(parent) => {\n+            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n+            (false, right)\n+        }\n     };\n \n     if handle.can_merge() {\n-        Merged(handle.merge().into_node())\n+        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n+        Merged(handle.merge(), is_left, offset)\n     } else {\n         if is_left {\n             handle.steal_left();\n         } else {\n             handle.steal_right();\n         }\n-        Stole(handle.into_node())\n+        Stole(is_left)\n     }\n }\n "}, {"sha": "bc4e2711670865223950448621be816383e08cf4", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ec0e148f1848a483104f809412cfc0bef1d3c3f/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec0e148f1848a483104f809412cfc0bef1d3c3f/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=2ec0e148f1848a483104f809412cfc0bef1d3c3f", "patch": "@@ -723,6 +723,11 @@ impl<Node, Type> Handle<Node, Type> {\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n+\n+    /// Returns the position of this handle in the node.\n+    pub fn idx(&self) -> usize {\n+        self.idx\n+    }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {"}]}