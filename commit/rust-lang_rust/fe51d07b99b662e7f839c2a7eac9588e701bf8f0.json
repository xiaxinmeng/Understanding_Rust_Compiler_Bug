{"sha": "fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "node_id": "C_kwDOAAsO6NoAKGZlNTFkMDdiOTliNjYyZTdmODM5YzJhN2VhYzk1ODhlNzAxYmY4ZjA", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-07-27T02:52:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-27T02:52:55Z"}, "message": "Rollup merge of #99712 - davidtwco:translation-migrate-passes-2, r=compiler-errors\n\npasses: port more of `check_attr` module\n\nContinues from #99213.\n\nPort more diagnostics in `rustc_passes::check_attr` to using the diagnostic derive and translation machinery.\n\nr? `@compiler-errors`", "tree": {"sha": "2eeb8c14d1ee12262c91b707b6f269e7c4c6f129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eeb8c14d1ee12262c91b707b6f269e7c4c6f129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi4KiHCRBK7hj4Ov3rIwAAZu4IAGFFMg4jRy4H2VYyI9J7p7Jb\nRT3Pw1LAnuaaGwBSLdjiv0DjMWXumKngCjz4Bowehkcx1c1uByVqsMUO/zZu5aCs\nS6jUcq0bXFZjHa+g6rI4liQOvR1aZCxP5ES2ffY2bEP8lOw66fPY5saRD5Zebtxa\n+u/MwmNN7FeYhHmUOlhwAiy33LRUGO83wccWtz25NDP39FGgMbuqOtYRfETVIGte\nuORDQXuuU11nFj6bjQ7e2YYAbSJS06DUJewnx+Ow45GAGFl46gg6JgGsuaceqNsN\n5UFPvfj7UPs55tKQow7EuhSkcoSBDYGRsSmjoCIk9zLBWQ0E+sY+ljtyM/OL4nY=\n=7Qu1\n-----END PGP SIGNATURE-----\n", "payload": "tree 2eeb8c14d1ee12262c91b707b6f269e7c4c6f129\nparent 181bf05d86d906e5a8eea51f8fd702deb7a706cc\nparent 76cf6bd03e262a3350852491202f3371a9e6244a\nauthor Yuki Okushi <jtitor@2k36.org> 1658890375 +0900\ncommitter GitHub <noreply@github.com> 1658890375 +0900\n\nRollup merge of #99712 - davidtwco:translation-migrate-passes-2, r=compiler-errors\n\npasses: port more of `check_attr` module\n\nContinues from #99213.\n\nPort more diagnostics in `rustc_passes::check_attr` to using the diagnostic derive and translation machinery.\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "html_url": "https://github.com/rust-lang/rust/commit/fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "181bf05d86d906e5a8eea51f8fd702deb7a706cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/181bf05d86d906e5a8eea51f8fd702deb7a706cc", "html_url": "https://github.com/rust-lang/rust/commit/181bf05d86d906e5a8eea51f8fd702deb7a706cc"}, {"sha": "76cf6bd03e262a3350852491202f3371a9e6244a", "url": "https://api.github.com/repos/rust-lang/rust/commits/76cf6bd03e262a3350852491202f3371a9e6244a", "html_url": "https://github.com/rust-lang/rust/commit/76cf6bd03e262a3350852491202f3371a9e6244a"}], "stats": {"total": 786, "additions": 508, "deletions": 278}, "files": [{"sha": "f95e33cd16a7ddfcb48434e0fd1c6f01a81ba22e", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "patch": "@@ -149,3 +149,110 @@ passes-cold = {passes-should-be-applied-to-fn}\n passes-link = attribute should be applied to an `extern` block with non-Rust ABI\n     .warn = {-passes-previously-accepted}\n     .label = not an `extern` block\n+\n+passes-link-name = attribute should be applied to a foreign function or static\n+    .warn = {-passes-previously-accepted}\n+    .label = not a foreign function or static\n+    .help = try `#[link(name = \"{$value}\")]` instead\n+\n+passes-no-link = attribute should be applied to an `extern crate` item\n+    .label = not an `extern crate` item\n+\n+passes-export-name = attribute should be applied to a free function, impl method or static\n+    .label = not a free function, impl method or static\n+\n+passes-rustc-layout-scalar-valid-range-not-struct = attribute should be applied to a struct\n+    .label = not a struct\n+\n+passes-rustc-layout-scalar-valid-range-arg = expected exactly one integer literal argument\n+\n+passes-rustc-legacy-const-generics-only = #[rustc_legacy_const_generics] functions must only have const generics\n+    .label = non-const generic parameter\n+\n+passes-rustc-legacy-const-generics-index = #[rustc_legacy_const_generics] must have one index for each generic parameter\n+    .label = generic parameters\n+\n+passes-rustc-legacy-const-generics-index-exceed = index exceeds number of arguments\n+    .label = there {$arg_count ->\n+        [one] is\n+        *[other] are\n+    } only {$arg_count} {$arg_count ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+\n+passes-rustc-legacy-const-generics-index-negative = arguments should be non-negative integers\n+\n+passes-rustc-dirty-clean = attribute requires -Z query-dep-graph to be enabled\n+\n+passes-link-section = attribute should be applied to a function or static\n+    .warn = {-passes-previously-accepted}\n+    .label = not a function or static\n+\n+passes-no-mangle-foreign = `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+    .warn = {-passes-previously-accepted}\n+    .label = foreign {$foreign_item_kind}\n+    .note = symbol names in extern blocks are not mangled\n+    .suggestion = remove this attribute\n+\n+passes-no-mangle = attribute should be applied to a free function, impl method or static\n+    .warn = {-passes-previously-accepted}\n+    .label = not a free function, impl method or static\n+\n+passes-repr-ident = meta item in `repr` must be an identifier\n+\n+passes-repr-conflicting = conflicting representation hints\n+\n+passes-used-static = attribute must be applied to a `static` variable\n+\n+passes-used-compiler-linker = `used(compiler)` and `used(linker)` can't be used together\n+\n+passes-allow-internal-unstable = attribute should be applied to a macro\n+    .label = not a macro\n+\n+passes-debug-visualizer-placement = attribute should be applied to a module\n+\n+passes-debug-visualizer-invalid = invalid argument\n+    .note-1 = expected: `natvis_file = \"...\"`\n+    .note-2 = OR\n+    .note-3 = expected: `gdb_script_file = \"...\"`\n+\n+passes-rustc-allow-const-fn-unstable = attribute should be applied to `const fn`\n+    .label = not a `const fn`\n+\n+passes-rustc-std-internal-symbol = attribute should be applied to functions or statics\n+    .label = not a function or static\n+\n+passes-const-trait = attribute should be applied to a trait\n+\n+passes-stability-promotable = attribute cannot be applied to an expression\n+\n+passes-deprecated = attribute is ignored here\n+\n+passes-macro-use = `#[{$name}]` only has an effect on `extern crate` and modules\n+\n+passes-macro-export = `#[macro_export]` only has an effect on macro definitions\n+\n+passes-plugin-registrar = `#[plugin_registrar]` only has an effect on functions\n+\n+passes-unused-empty-lints-note = attribute `{$name}` with an empty list has no effect\n+\n+passes-unused-no-lints-note = attribute `{$name}` without any lints has no effect\n+\n+passes-unused-default-method-body-const-note =\n+    `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n+\n+passes-unused = unused attribute\n+    .suggestion = remove this attribute\n+\n+passes-non-exported-macro-invalid-attrs = attribute should be applied to function or closure\n+    .label = not a function or closure\n+\n+passes-unused-duplicate = unused attribute\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here\n+    .warn = {-passes-previously-accepted}\n+\n+passes-unused-multiple = multiple `{$name}` attributes\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here"}, {"sha": "f3ccbbb56792dc3493c88a2487fec396a6ecb669", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 125, "deletions": 267, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "patch": "@@ -7,7 +7,7 @@\n use crate::errors;\n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{fluent, pluralize, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{fluent, struct_span_err, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -1180,30 +1180,22 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 // FIXME: #[cold] was previously allowed on non-functions/statics and some crates\n                 // used this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    let mut diag =\n-                        lint.build(\"attribute should be applied to a foreign function or static\");\n-                    diag.warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                         being phased out; it will become a hard error in \\\n-                         a future release!\",\n+                let attr_span = matches!(target, Target::ForeignMod).then_some(attr.span);\n+                if let Some(s) = attr.value_str() {\n+                    self.tcx.emit_spanned_lint(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        attr.span,\n+                        errors::LinkName { span, attr_span, value: s.as_str() },\n                     );\n-\n-                    // See issue #47725\n-                    if let Target::ForeignMod = target {\n-                        if let Some(value) = attr.value_str() {\n-                            diag.span_help(\n-                                attr.span,\n-                                &format!(r#\"try `#[link(name = \"{value}\")]` instead\"#),\n-                            );\n-                        } else {\n-                            diag.span_help(attr.span, r#\"try `#[link(name = \"...\")]` instead\"#);\n-                        }\n-                    }\n-\n-                    diag.span_label(span, \"not a foreign function or static\");\n-                    diag.emit();\n-                });\n+                } else {\n+                    self.tcx.emit_spanned_lint(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        attr.span,\n+                        errors::LinkName { span, attr_span, value: \"...\" },\n+                    );\n+                };\n             }\n         }\n     }\n@@ -1221,14 +1213,7 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to an `extern crate` item\",\n-                    )\n-                    .span_label(span, \"not an `extern crate` item\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::NoLink { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1258,14 +1243,7 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to a free function, impl method or static\",\n-                    )\n-                    .span_label(span, \"not a free function, impl method or static\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::ExportName { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1278,11 +1256,10 @@ impl CheckAttrVisitor<'_> {\n         target: Target,\n     ) -> bool {\n         if target != Target::Struct {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute should be applied to a struct\")\n-                .span_label(span, \"not a struct\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLayoutScalarValidRangeNotStruct {\n+                attr_span: attr.span,\n+                span,\n+            });\n             return false;\n         }\n \n@@ -1293,10 +1270,7 @@ impl CheckAttrVisitor<'_> {\n         if matches!(&list[..], &[NestedMetaItem::Literal(Lit { kind: LitKind::Int(..), .. })]) {\n             true\n         } else {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"expected exactly one integer literal argument\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLayoutScalarValidRangeArg { attr_span: attr.span });\n             false\n         }\n     }\n@@ -1311,11 +1285,10 @@ impl CheckAttrVisitor<'_> {\n     ) -> bool {\n         let is_function = matches!(target, Target::Fn);\n         if !is_function {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                .span_label(span, \"not a function\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                attr_span: attr.span,\n+                defn_span: span,\n+            });\n             return false;\n         }\n \n@@ -1335,29 +1308,20 @@ impl CheckAttrVisitor<'_> {\n             match param.kind {\n                 hir::GenericParamKind::Const { .. } => {}\n                 _ => {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            attr.span,\n-                            \"#[rustc_legacy_const_generics] functions must \\\n-                             only have const generics\",\n-                        )\n-                        .span_label(param.span, \"non-const generic parameter\")\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsOnly {\n+                        attr_span: attr.span,\n+                        param_span: param.span,\n+                    });\n                     return false;\n                 }\n             }\n         }\n \n         if list.len() != generics.params.len() {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    attr.span,\n-                    \"#[rustc_legacy_const_generics] must have one index for each generic parameter\",\n-                )\n-                .span_label(generics.span, \"generic parameters\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndex {\n+                attr_span: attr.span,\n+                generics_span: generics.span,\n+            });\n             return false;\n         }\n \n@@ -1367,19 +1331,10 @@ impl CheckAttrVisitor<'_> {\n             if let Some(LitKind::Int(val, _)) = meta.literal().map(|lit| &lit.kind) {\n                 if *val >= arg_count {\n                     let span = meta.span();\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(span, \"index exceeds number of arguments\")\n-                        .span_label(\n-                            span,\n-                            format!(\n-                                \"there {} only {} argument{}\",\n-                                pluralize!(\"is\", arg_count),\n-                                arg_count,\n-                                pluralize!(arg_count)\n-                            ),\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndexExceed {\n+                        span,\n+                        arg_count: arg_count as usize,\n+                    });\n                     return false;\n                 }\n             } else {\n@@ -1388,10 +1343,7 @@ impl CheckAttrVisitor<'_> {\n         }\n \n         if !invalid_args.is_empty() {\n-            self.tcx\n-                .sess\n-                .struct_span_err(invalid_args, \"arguments should be non-negative integers\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndexNegative { invalid_args });\n             false\n         } else {\n             true\n@@ -1403,11 +1355,10 @@ impl CheckAttrVisitor<'_> {\n     fn check_applied_to_fn_or_method(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n         let is_function = matches!(target, Target::Fn | Target::Method(..));\n         if !is_function {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                .span_label(span, \"not a function\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                attr_span: attr.span,\n+                defn_span: span,\n+            });\n             false\n         } else {\n             true\n@@ -1437,10 +1388,7 @@ impl CheckAttrVisitor<'_> {\n         if self.tcx.sess.opts.unstable_opts.query_dep_graph {\n             true\n         } else {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute requires -Z query-dep-graph to be enabled\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcDirtyClean { span: attr.span });\n             false\n         }\n     }\n@@ -1459,16 +1407,12 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 // FIXME: #[link_section] was previously allowed on non-functions/statics and some\n                 // crates used this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute should be applied to a function or static\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .span_label(span, \"not a function or static\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::LinkSection { span },\n+                );\n             }\n         }\n     }\n@@ -1494,41 +1438,22 @@ impl CheckAttrVisitor<'_> {\n                     Target::ForeignStatic => \"static\",\n                     _ => unreachable!(),\n                 };\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(&format!(\n-                        \"`#[no_mangle]` has no effect on a foreign {foreign_item_kind}\"\n-                    ))\n-                    .warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                            being phased out; it will become a hard error in \\\n-                            a future release!\",\n-                    )\n-                    .span_label(span, format!(\"foreign {foreign_item_kind}\"))\n-                    .note(\"symbol names in extern blocks are not mangled\")\n-                    .span_suggestion(\n-                        attr.span,\n-                        \"remove this attribute\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::NoMangleForeign { span, attr_span: attr.span, foreign_item_kind },\n+                );\n             }\n             _ => {\n                 // FIXME: #[no_mangle] was previously allowed on non-functions/statics and some\n                 // crates used this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\n-                        \"attribute should be applied to a free function, impl method or static\",\n-                    )\n-                    .warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                         being phased out; it will become a hard error in \\\n-                         a future release!\",\n-                    )\n-                    .span_label(span, \"not a free function, impl method or static\")\n-                    .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::NoMangle { span },\n+                );\n             }\n         }\n     }\n@@ -1561,13 +1486,7 @@ impl CheckAttrVisitor<'_> {\n \n         for hint in &hints {\n             if !hint.is_meta_item() {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    hint.span(),\n-                    E0565,\n-                    \"meta item in `repr` must be an identifier\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(errors::ReprIdent { span: hint.span() });\n                 continue;\n             }\n \n@@ -1688,15 +1607,11 @@ impl CheckAttrVisitor<'_> {\n                     return false;\n                 }))\n         {\n-            self.tcx.struct_span_lint_hir(\n+            self.tcx.emit_spanned_lint(\n                 CONFLICTING_REPR_HINTS,\n                 hir_id,\n                 hint_spans.collect::<Vec<Span>>(),\n-                |lint| {\n-                    lint.build(\"conflicting representation hints\")\n-                        .code(rustc_errors::error_code!(E0566))\n-                        .emit();\n-                },\n+                errors::ReprConflicting,\n             );\n         }\n     }\n@@ -1706,9 +1621,7 @@ impl CheckAttrVisitor<'_> {\n         let mut used_compiler_span = None;\n         for attr in attrs.iter().filter(|attr| attr.has_name(sym::used)) {\n             if target != Target::Static {\n-                self.tcx\n-                    .sess\n-                    .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n+                self.tcx.sess.emit_err(errors::UsedStatic { span: attr.span });\n             }\n             let inner = attr.meta_item_list();\n             match inner.as_deref() {\n@@ -1734,14 +1647,9 @@ impl CheckAttrVisitor<'_> {\n             }\n         }\n         if let (Some(linker_span), Some(compiler_span)) = (used_linker_span, used_compiler_span) {\n-            let spans = vec![linker_span, compiler_span];\n             self.tcx\n                 .sess\n-                .struct_span_err(\n-                    spans,\n-                    \"`used(compiler)` and `used(linker)` can't be used together\",\n-                )\n-                .emit();\n+                .emit_err(errors::UsedCompilerLinker { spans: vec![linker_span, compiler_span] });\n         }\n     }\n \n@@ -1783,9 +1691,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a macro\")\n-                    .span_label(span, \"not a macro\")\n-                    .emit();\n+                    .emit_err(errors::AllowInternalUnstable { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1796,37 +1702,34 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Mod => {}\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a module\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::DebugVisualizerPlacement { span: attr.span });\n                 return false;\n             }\n         }\n \n         let Some(hints) = attr.meta_item_list() else {\n-            self.emit_debugger_visualizer_err(attr.span);\n+            self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n             return false;\n         };\n \n         let hint = match hints.len() {\n             1 => &hints[0],\n             _ => {\n-                self.emit_debugger_visualizer_err(attr.span);\n+                self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n                 return false;\n             }\n         };\n \n         let Some(meta_item) = hint.meta_item() else {\n-            self.emit_debugger_visualizer_err(attr.span);\n+            self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n             return false;\n         };\n \n         let visualizer_path = match (meta_item.name_or_empty(), meta_item.value_str()) {\n             (sym::natvis_file, Some(value)) => value,\n             (sym::gdb_script_file, Some(value)) => value,\n             (_, _) => {\n-                self.emit_debugger_visualizer_err(meta_item.span);\n+                self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: meta_item.span });\n                 return false;\n             }\n         };\n@@ -1855,16 +1758,6 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n-    fn emit_debugger_visualizer_err(&self, span: Span) {\n-        self.tcx\n-            .sess\n-            .struct_span_err(span, \"invalid argument\")\n-            .note(r#\"expected: `natvis_file = \"...\"`\"#)\n-            .note(r#\"OR\"#)\n-            .note(r#\"expected: `gdb_script_file = \"...\"`\"#)\n-            .emit();\n-    }\n-\n     /// Outputs an error for `#[allow_internal_unstable]` which can only be applied to macros.\n     /// (Allows proc_macro functions)\n     fn check_rustc_allow_const_fn_unstable(\n@@ -1891,9 +1784,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to `const fn`\")\n-                    .span_label(span, \"not a `const fn`\")\n-                    .emit();\n+                    .emit_err(errors::RustcAllowConstFnUnstable { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1910,9 +1801,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied functions or statics\")\n-                    .span_label(span, \"not a function or static\")\n-                    .emit();\n+                    .emit_err(errors::RustcStdInternalSymbol { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1923,10 +1812,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Trait => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a trait\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::ConstTrait { attr_span: attr.span });\n                 false\n             }\n         }\n@@ -1935,10 +1821,7 @@ impl CheckAttrVisitor<'_> {\n     fn check_stability_promotable(&self, attr: &Attribute, _span: Span, target: Target) -> bool {\n         match target {\n             Target::Expression => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute cannot be applied to an expression\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::StabilityPromotable { attr_span: attr.span });\n                 false\n             }\n             _ => true,\n@@ -1948,9 +1831,12 @@ impl CheckAttrVisitor<'_> {\n     fn check_deprecated(&self, hir_id: HirId, attr: &Attribute, _span: Span, target: Target) {\n         match target {\n             Target::Closure | Target::Expression | Target::Statement | Target::Arm => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute is ignored here\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::Deprecated,\n+                );\n             }\n             _ => {}\n         }\n@@ -1961,29 +1847,30 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::ExternCrate | Target::Mod => {}\n             _ => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(&format!(\n-                        \"`#[{name}]` only has an effect on `extern crate` and modules\"\n-                    ))\n-                    .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::MacroUse { name },\n+                );\n             }\n         }\n     }\n \n     fn check_macro_export(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n         if target != Target::MacroDef {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(\"`#[macro_export]` only has an effect on macro definitions\").emit();\n-            });\n+            self.tcx.emit_spanned_lint(UNUSED_ATTRIBUTES, hir_id, attr.span, errors::MacroExport);\n         }\n     }\n \n     fn check_plugin_registrar(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n         if target != Target::Fn {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(\"`#[plugin_registrar]` only has an effect on functions\").emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                errors::PluginRegistrar,\n+            );\n         }\n     }\n \n@@ -2002,10 +1889,7 @@ impl CheckAttrVisitor<'_> {\n                 | sym::target_feature\n         ) && attr.meta_item_list().map_or(false, |list| list.is_empty())\n         {\n-            format!(\n-                \"attribute `{}` with an empty list has no effect\",\n-                attr.name_or_empty()\n-            )\n+            errors::UnusedNote::EmptyList { name: attr.name_or_empty() }\n         } else if matches!(\n                 attr.name_or_empty(),\n                 sym::allow | sym::warn | sym::deny | sym::forbid | sym::expect\n@@ -2015,27 +1899,19 @@ impl CheckAttrVisitor<'_> {\n             && let MetaItemKind::NameValue(_) = &item.kind\n             && item.path == sym::reason\n         {\n-            format!(\n-                \"attribute `{}` without any lints has no effect\",\n-                attr.name_or_empty()\n-            )\n+            errors::UnusedNote::NoLints { name: attr.name_or_empty() }\n         } else if attr.name_or_empty() == sym::default_method_body_is_const {\n-            format!(\"`default_method_body_is_const` has been replaced with `#[const_trait]` on traits\")\n+            errors::UnusedNote::DefaultMethodBodyConst\n         } else {\n             return;\n         };\n \n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            lint.build(\"unused attribute\")\n-                .span_suggestion(\n-                    attr.span,\n-                    \"remove this attribute\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .note(&note)\n-                .emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::Unused { attr_span: attr.span, note },\n+        );\n     }\n }\n \n@@ -2206,14 +2082,7 @@ fn check_non_exported_macro_for_invalid_attrs(tcx: TyCtxt<'_>, item: &Item<'_>)\n \n     for attr in attrs {\n         if attr.has_name(sym::inline) {\n-            struct_span_err!(\n-                tcx.sess,\n-                attr.span,\n-                E0518,\n-                \"attribute should be applied to function or closure\",\n-            )\n-            .span_label(attr.span, \"not a function or closure\")\n-            .emit();\n+            tcx.sess.emit_err(errors::NonExportedMacroInvalidAttrs { attr_span: attr.span });\n         }\n     }\n }\n@@ -2253,23 +2122,20 @@ fn check_duplicates(\n                     } else {\n                         (attr.span, *entry.get())\n                     };\n-                    tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, this, |lint| {\n-                        let mut db = lint.build(\"unused attribute\");\n-                        db.span_note(other, \"attribute also specified here\").span_suggestion(\n+                    tcx.emit_spanned_lint(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        this,\n+                        errors::UnusedDuplicate {\n                             this,\n-                            \"remove this attribute\",\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                        if matches!(duplicates, FutureWarnFollowing | FutureWarnPreceding) {\n-                            db.warn(\n-                                \"this was previously accepted by the compiler but is \\\n-                                 being phased out; it will become a hard error in \\\n-                                 a future release!\",\n-                            );\n-                        }\n-                        db.emit();\n-                    });\n+                            other,\n+                            warning: matches!(\n+                                duplicates,\n+                                FutureWarnFollowing | FutureWarnPreceding\n+                            )\n+                            .then_some(()),\n+                        },\n+                    );\n                 }\n                 Entry::Vacant(entry) => {\n                     entry.insert(attr.span);\n@@ -2284,19 +2150,11 @@ fn check_duplicates(\n                 } else {\n                     (attr.span, *entry.get())\n                 };\n-                tcx.sess\n-                    .struct_span_err(\n-                        this,\n-                        &format!(\"multiple `{}` attributes\", attr.name_or_empty()),\n-                    )\n-                    .span_note(other, \"attribute also specified here\")\n-                    .span_suggestion(\n-                        this,\n-                        \"remove this attribute\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::UnusedMultiple {\n+                    this,\n+                    other,\n+                    name: attr.name_or_empty(),\n+                });\n             }\n             Entry::Vacant(entry) => {\n                 entry.insert(attr.span);"}, {"sha": "0d4317f6b8881e1dbaff8c9234d49e6e351d3be8", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 266, "deletions": 1, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "patch": "@@ -1,5 +1,5 @@\n use rustc_errors::{Applicability, MultiSpan};\n-use rustc_macros::{LintDiagnostic, SessionDiagnostic};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(LintDiagnostic)]\n@@ -360,3 +360,268 @@ pub struct Link {\n     #[label]\n     pub span: Option<Span>,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::link_name)]\n+#[warn_]\n+pub struct LinkName<'a> {\n+    #[help]\n+    pub attr_span: Option<Span>,\n+    #[label]\n+    pub span: Span,\n+    pub value: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::no_link)]\n+pub struct NoLink {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::export_name)]\n+pub struct ExportName {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_layout_scalar_valid_range_not_struct)]\n+pub struct RustcLayoutScalarValidRangeNotStruct {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_layout_scalar_valid_range_arg)]\n+pub struct RustcLayoutScalarValidRangeArg {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_only)]\n+pub struct RustcLegacyConstGenericsOnly {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub param_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_index)]\n+pub struct RustcLegacyConstGenericsIndex {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub generics_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_index_exceed)]\n+pub struct RustcLegacyConstGenericsIndexExceed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub arg_count: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_index_negative)]\n+pub struct RustcLegacyConstGenericsIndexNegative {\n+    #[primary_span]\n+    pub invalid_args: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_dirty_clean)]\n+pub struct RustcDirtyClean {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::link_section)]\n+#[warn_]\n+pub struct LinkSection {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_mangle_foreign)]\n+#[warn_]\n+#[note]\n+pub struct NoMangleForeign {\n+    #[label]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\")]\n+    pub attr_span: Span,\n+    pub foreign_item_kind: &'static str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_mangle)]\n+#[warn_]\n+pub struct NoMangle {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::repr_ident, code = \"E0565\")]\n+pub struct ReprIdent {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::repr_conflicting, code = \"E0566\")]\n+pub struct ReprConflicting;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::used_static)]\n+pub struct UsedStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::used_compiler_linker)]\n+pub struct UsedCompilerLinker {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::allow_internal_unstable)]\n+pub struct AllowInternalUnstable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::debug_visualizer_placement)]\n+pub struct DebugVisualizerPlacement {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::debug_visualizer_invalid)]\n+#[note(passes::note_1)]\n+#[note(passes::note_2)]\n+#[note(passes::note_3)]\n+pub struct DebugVisualizerInvalid {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_allow_const_fn_unstable)]\n+pub struct RustcAllowConstFnUnstable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_std_internal_symbol)]\n+pub struct RustcStdInternalSymbol {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::const_trait)]\n+pub struct ConstTrait {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::stability_promotable)]\n+pub struct StabilityPromotable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::deprecated)]\n+pub struct Deprecated;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::macro_use)]\n+pub struct MacroUse {\n+    pub name: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::macro_export)]\n+pub struct MacroExport;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::plugin_registrar)]\n+pub struct PluginRegistrar;\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum UnusedNote {\n+    #[note(passes::unused_empty_lints_note)]\n+    EmptyList { name: Symbol },\n+    #[note(passes::unused_no_lints_note)]\n+    NoLints { name: Symbol },\n+    #[note(passes::unused_default_method_body_const_note)]\n+    DefaultMethodBodyConst,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::unused)]\n+pub struct Unused {\n+    #[suggestion(applicability = \"machine-applicable\")]\n+    pub attr_span: Span,\n+    #[subdiagnostic]\n+    pub note: UnusedNote,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::non_exported_macro_invalid_attrs, code = \"E0518\")]\n+pub struct NonExportedMacroInvalidAttrs {\n+    #[primary_span]\n+    #[label]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::unused_duplicate)]\n+pub struct UnusedDuplicate {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub this: Span,\n+    #[note]\n+    pub other: Span,\n+    #[warn_]\n+    pub warning: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::unused_multiple)]\n+pub struct UnusedMultiple {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub this: Span,\n+    #[note]\n+    pub other: Span,\n+    pub name: Symbol,\n+}"}, {"sha": "e849ca2829e434c5532471666df115c9612498e4", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics_incorrect.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics_incorrect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics_incorrect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics_incorrect.stderr?ref=fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "patch": "@@ -4,14 +4,14 @@ error: malformed `rustc_lint_diagnostics` attribute input\n LL |     #[rustc_lint_diagnostics(a)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_lint_diagnostics]`\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/diagnostics_incorrect.rs:5:1\n    |\n LL | #[rustc_lint_diagnostics]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3f78b39edd96a3adcddf933de7e810ca03798eac", "filename": "src/test/ui-fulldeps/internal-lints/query_stability_incorrect.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr?ref=fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "patch": "@@ -4,14 +4,14 @@ error: malformed `rustc_lint_query_instability` attribute input\n LL |     #[rustc_lint_query_instability(a)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_lint_query_instability]`\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/query_stability_incorrect.rs:5:1\n    |\n LL | #[rustc_lint_query_instability]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1ced1433fe955c395c2760262ce1559f88e96a88", "filename": "src/test/ui/invalid/invalid-rustc_legacy_const_generics-arguments.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe51d07b99b662e7f839c2a7eac9588e701bf8f0/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr?ref=fe51d07b99b662e7f839c2a7eac9588e701bf8f0", "patch": "@@ -50,13 +50,13 @@ error: arguments should be non-negative integers\n LL | #[rustc_legacy_const_generics(1, a, 2, b)]\n    |                                  ^     ^\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:18:1\n    |\n LL | #[rustc_legacy_const_generics(0)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL | struct S;\n-   | --------- not a function\n+   | --------- not a function definition\n \n error: #[rustc_legacy_const_generics] functions must only have const generics\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:29:1\n@@ -66,21 +66,21 @@ LL | #[rustc_legacy_const_generics(0)]\n LL | fn foo8<X>() {}\n    |         - non-const generic parameter\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:33:5\n    |\n LL |     #[rustc_legacy_const_generics(0)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     fn foo9<const X: usize>() {}\n-   |     ---------------------------- not a function\n+   |     ---------------------------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:25:5\n    |\n LL |     #[rustc_legacy_const_generics(1)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     fn foo7<const X: usize>();\n-   |     -------------------------- not a function\n+   |     -------------------------- not a function definition\n \n error[E0044]: foreign items may not have const parameters\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:26:5"}]}