{"sha": "b1605643e3a9f62bdbe97c4854745e2f28ccd456", "node_id": "C_kwDOAAsO6NoAKGIxNjA1NjQzZTNhOWY2MmJkYmU5N2M0ODU0NzQ1ZTJmMjhjY2Q0NTY", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-15T04:41:20Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-18T20:39:19Z"}, "message": "Move expr-related pretty printing functions to module", "tree": {"sha": "d1000041f01cbe1b44f8935d5abd2775c4a47140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1000041f01cbe1b44f8935d5abd2775c4a47140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1605643e3a9f62bdbe97c4854745e2f28ccd456", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmHnJXcACgkQ+boUO5X/\nbYK/3RAAp8JJqjZzCPU/fU1IOy8RW19+e+8hZoJ5AGOLRyYdls8z2yMcRQymsmCx\nB16rCxS9UA4mM7Rj8Uucn7XMHM48bTo2MDrOYDj+PB2AgByDNMjF2g45eMPmbNB4\nhAJ4gxyVPDyLSBZ2f2KgimrBxFUiqaPlj4BNRCOPxXQEMSu3bhe8IWtGcnstFtq6\nyTF/Vm/SrjC8oodvZHT3H63oPoXtzVTZxawHB5YOimPU0zQ0j3X9JPXU6ftQ3daW\nBeo9orf2fNoGI29xoKkjXuzIWSFoGBWptKu2BXPrbLaS6j8PYknopRdbbGK7yB3t\nRuITuPz1AtfLU0L0RSKZM6hlZvpYodLb6lrJ2ZSIKKAo2iWaMjK8vbwpYxrcHAQH\nMEv0EHn2pGm+EKtIEG+K6lt2gv7VzzdCSLi6goJqusrCBmYuKSKV0jWySC0C7p0d\nMEhtKMJKfL/sCeVO237+ZKsed7AskYeyHC2FJD2Hq6YXLG/oFqJgQ6VmM7S+JYjK\nfwG7cm+FYfonUYQgPQNgZJSreYJxojBT0U213sp+ZvuhM04EpQaYZXAohwTo5s4U\n5IhdFJupjSlApfosnIJZEfZE67raJBijQcNbIl/Xu3p/7yR5JYZMBWE47GZ6Giqm\ngJi43SwWeinLQpTJ7H7EuHd6P8CJnSP3DQBJuL0+Jwzt/empstc=\n=0Fd7\n-----END PGP SIGNATURE-----", "payload": "tree d1000041f01cbe1b44f8935d5abd2775c4a47140\nparent 9ad5d82f822b3cb67637f11be2e65c5662b66ec0\nauthor David Tolnay <dtolnay@gmail.com> 1642221680 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1642538359 -0800\n\nMove expr-related pretty printing functions to module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1605643e3a9f62bdbe97c4854745e2f28ccd456", "html_url": "https://github.com/rust-lang/rust/commit/b1605643e3a9f62bdbe97c4854745e2f28ccd456", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1605643e3a9f62bdbe97c4854745e2f28ccd456/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "html_url": "https://github.com/rust-lang/rust/commit/9ad5d82f822b3cb67637f11be2e65c5662b66ec0"}], "stats": {"total": 1138, "additions": 574, "deletions": 564}, "files": [{"sha": "70202a380cc8b4eeaa9f123a00d7920c529f8f9d", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 3, "deletions": 564, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/b1605643e3a9f62bdbe97c4854745e2f28ccd456/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1605643e3a9f62bdbe97c4854745e2f28ccd456/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=b1605643e3a9f62bdbe97c4854745e2f28ccd456", "patch": "@@ -1,3 +1,5 @@\n+mod expr;\n+\n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n \n@@ -6,7 +8,7 @@ use rustc_ast::token::{self, BinOpToken, CommentKind, DelimToken, Nonterminal, T\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n-use rustc_ast::util::parser::{self, AssocOp, Fixity};\n+use rustc_ast::util::parser;\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use rustc_ast::{attr, Term};\n use rustc_ast::{GenericArg, MacArgs, ModKind};\n@@ -1682,42 +1684,6 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n     }\n \n-    fn print_else(&mut self, els: Option<&ast::Expr>) {\n-        if let Some(_else) = els {\n-            match _else.kind {\n-                // Another `else if` block.\n-                ast::ExprKind::If(ref i, ref then, ref e) => {\n-                    self.cbox(INDENT_UNIT - 1);\n-                    self.ibox(0);\n-                    self.word(\" else if \");\n-                    self.print_expr_as_cond(i);\n-                    self.space();\n-                    self.print_block(then);\n-                    self.print_else(e.as_deref())\n-                }\n-                // Final `else` block.\n-                ast::ExprKind::Block(ref b, _) => {\n-                    self.cbox(INDENT_UNIT - 1);\n-                    self.ibox(0);\n-                    self.word(\" else \");\n-                    self.print_block(b)\n-                }\n-                // Constraints would be great here!\n-                _ => {\n-                    panic!(\"print_if saw if with weird alternative\");\n-                }\n-            }\n-        }\n-    }\n-\n-    crate fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n-        self.head(\"if\");\n-        self.print_expr_as_cond(test);\n-        self.space();\n-        self.print_block(blk);\n-        self.print_else(elseopt)\n-    }\n-\n     crate fn print_mac(&mut self, m: &ast::MacCall) {\n         self.print_mac_common(\n             Some(MacHeader::Path(&m.path)),\n@@ -1730,477 +1696,6 @@ impl<'a> State<'a> {\n         );\n     }\n \n-    fn print_call_post(&mut self, args: &[P<ast::Expr>]) {\n-        self.popen();\n-        self.commasep_exprs(Inconsistent, args);\n-        self.pclose()\n-    }\n-\n-    crate fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) {\n-        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n-    }\n-\n-    /// Prints an expr using syntax that's acceptable in a condition position, such as the `cond` in\n-    /// `if cond { ... }`.\n-    crate fn print_expr_as_cond(&mut self, expr: &ast::Expr) {\n-        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n-    }\n-\n-    // Does `expr` need parentheses when printed in a condition position?\n-    //\n-    // These cases need parens due to the parse error observed in #26461: `if return {}`\n-    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n-    fn cond_needs_par(expr: &ast::Expr) -> bool {\n-        match expr.kind {\n-            ast::ExprKind::Break(..) | ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) => true,\n-            _ => parser::contains_exterior_struct_lit(expr),\n-        }\n-    }\n-\n-    /// Prints `expr` or `(expr)` when `needs_par` holds.\n-    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n-        if needs_par {\n-            self.popen();\n-        }\n-        self.print_expr(expr);\n-        if needs_par {\n-            self.pclose();\n-        }\n-    }\n-\n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"[\");\n-        self.commasep_exprs(Inconsistent, exprs);\n-        self.word(\"]\");\n-        self.end();\n-    }\n-\n-    fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"const\");\n-        self.print_expr(&expr.value);\n-        self.end();\n-    }\n-\n-    fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n-        self.ibox(INDENT_UNIT);\n-        self.word(\"[\");\n-        self.print_expr(element);\n-        self.word_space(\";\");\n-        self.print_expr(&count.value);\n-        self.word(\"]\");\n-        self.end();\n-    }\n-\n-    fn print_expr_struct(\n-        &mut self,\n-        qself: &Option<ast::QSelf>,\n-        path: &ast::Path,\n-        fields: &[ast::ExprField],\n-        rest: &ast::StructRest,\n-    ) {\n-        if let Some(qself) = qself {\n-            self.print_qpath(path, qself, true);\n-        } else {\n-            self.print_path(path, true, 0);\n-        }\n-        self.word(\"{\");\n-        self.commasep_cmnt(\n-            Consistent,\n-            fields,\n-            |s, field| {\n-                s.print_outer_attributes(&field.attrs);\n-                s.ibox(INDENT_UNIT);\n-                if !field.is_shorthand {\n-                    s.print_ident(field.ident);\n-                    s.word_space(\":\");\n-                }\n-                s.print_expr(&field.expr);\n-                s.end();\n-            },\n-            |f| f.span,\n-        );\n-        match rest {\n-            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n-                self.ibox(INDENT_UNIT);\n-                if !fields.is_empty() {\n-                    self.word(\",\");\n-                    self.space();\n-                }\n-                self.word(\"..\");\n-                if let ast::StructRest::Base(ref expr) = *rest {\n-                    self.print_expr(expr);\n-                }\n-                self.end();\n-            }\n-            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n-            _ => {}\n-        }\n-        self.word(\"}\");\n-    }\n-\n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n-        self.popen();\n-        self.commasep_exprs(Inconsistent, exprs);\n-        if exprs.len() == 1 {\n-            self.word(\",\");\n-        }\n-        self.pclose()\n-    }\n-\n-    fn print_expr_call(&mut self, func: &ast::Expr, args: &[P<ast::Expr>]) {\n-        let prec = match func.kind {\n-            ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n-            _ => parser::PREC_POSTFIX,\n-        };\n-\n-        self.print_expr_maybe_paren(func, prec);\n-        self.print_call_post(args)\n-    }\n-\n-    fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n-        let base_args = &args[1..];\n-        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n-        self.word(\".\");\n-        self.print_ident(segment.ident);\n-        if let Some(ref args) = segment.args {\n-            self.print_generic_args(args, true);\n-        }\n-        self.print_call_post(base_args)\n-    }\n-\n-    fn print_expr_binary(&mut self, op: ast::BinOp, lhs: &ast::Expr, rhs: &ast::Expr) {\n-        let assoc_op = AssocOp::from_ast_binop(op.node);\n-        let prec = assoc_op.precedence() as i8;\n-        let fixity = assoc_op.fixity();\n-\n-        let (left_prec, right_prec) = match fixity {\n-            Fixity::Left => (prec, prec + 1),\n-            Fixity::Right => (prec + 1, prec),\n-            Fixity::None => (prec + 1, prec + 1),\n-        };\n-\n-        let left_prec = match (&lhs.kind, op.node) {\n-            // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n-            // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n-            // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n-            (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt | ast::BinOpKind::Shl) => {\n-                parser::PREC_FORCE_PAREN\n-            }\n-            // We are given `(let _ = a) OP b`.\n-            //\n-            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n-            //   as the parser will interpret this as `(let _ = a) OP b`.\n-            //\n-            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n-            //   parens are required since the parser would interpret `let a = b < c` as\n-            //   `let a = (b < c)`. To achieve this, we force parens.\n-            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n-                parser::PREC_FORCE_PAREN\n-            }\n-            _ => left_prec,\n-        };\n-\n-        self.print_expr_maybe_paren(lhs, left_prec);\n-        self.space();\n-        self.word_space(op.node.to_string());\n-        self.print_expr_maybe_paren(rhs, right_prec)\n-    }\n-\n-    fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n-        self.word(ast::UnOp::to_string(op));\n-        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n-    }\n-\n-    fn print_expr_addr_of(\n-        &mut self,\n-        kind: ast::BorrowKind,\n-        mutability: ast::Mutability,\n-        expr: &ast::Expr,\n-    ) {\n-        self.word(\"&\");\n-        match kind {\n-            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n-            ast::BorrowKind::Raw => {\n-                self.word_nbsp(\"raw\");\n-                self.print_mutability(mutability, true);\n-            }\n-        }\n-        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n-    }\n-\n-    pub fn print_expr(&mut self, expr: &ast::Expr) {\n-        self.print_expr_outer_attr_style(expr, true)\n-    }\n-\n-    fn print_expr_outer_attr_style(&mut self, expr: &ast::Expr, is_inline: bool) {\n-        self.maybe_print_comment(expr.span.lo());\n-\n-        let attrs = &expr.attrs;\n-        if is_inline {\n-            self.print_outer_attributes_inline(attrs);\n-        } else {\n-            self.print_outer_attributes(attrs);\n-        }\n-\n-        self.ibox(INDENT_UNIT);\n-        self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.kind {\n-            ast::ExprKind::Box(ref expr) => {\n-                self.word_space(\"box\");\n-                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n-            }\n-            ast::ExprKind::Array(ref exprs) => {\n-                self.print_expr_vec(exprs);\n-            }\n-            ast::ExprKind::ConstBlock(ref anon_const) => {\n-                self.print_expr_anon_const(anon_const);\n-            }\n-            ast::ExprKind::Repeat(ref element, ref count) => {\n-                self.print_expr_repeat(element, count);\n-            }\n-            ast::ExprKind::Struct(ref se) => {\n-                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n-            }\n-            ast::ExprKind::Tup(ref exprs) => {\n-                self.print_expr_tup(exprs);\n-            }\n-            ast::ExprKind::Call(ref func, ref args) => {\n-                self.print_expr_call(func, &args);\n-            }\n-            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n-                self.print_expr_method_call(segment, &args);\n-            }\n-            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, lhs, rhs);\n-            }\n-            ast::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, expr);\n-            }\n-            ast::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, expr);\n-            }\n-            ast::ExprKind::Lit(ref lit) => {\n-                self.print_literal(lit);\n-            }\n-            ast::ExprKind::Cast(ref expr, ref ty) => {\n-                let prec = AssocOp::As.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.space();\n-                self.word_space(\"as\");\n-                self.print_type(ty);\n-            }\n-            ast::ExprKind::Type(ref expr, ref ty) => {\n-                let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.word_space(\":\");\n-                self.print_type(ty);\n-            }\n-            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n-                self.print_let(pat, scrutinee);\n-            }\n-            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(test, blk, elseopt.as_deref())\n-            }\n-            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"while\");\n-                self.print_expr_as_cond(test);\n-                self.space();\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"for\");\n-                self.print_pat(pat);\n-                self.space();\n-                self.word_space(\"in\");\n-                self.print_expr_as_cond(iter);\n-                self.space();\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Loop(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"loop\");\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Match(ref expr, ref arms) => {\n-                self.cbox(INDENT_UNIT);\n-                self.ibox(INDENT_UNIT);\n-                self.word_nbsp(\"match\");\n-                self.print_expr_as_cond(expr);\n-                self.space();\n-                self.bopen();\n-                self.print_inner_attributes_no_trailing_hardbreak(attrs);\n-                for arm in arms {\n-                    self.print_arm(arm);\n-                }\n-                let empty = attrs.is_empty() && arms.is_empty();\n-                self.bclose(expr.span, empty);\n-            }\n-            ast::ExprKind::Closure(\n-                capture_clause,\n-                asyncness,\n-                movability,\n-                ref decl,\n-                ref body,\n-                _,\n-            ) => {\n-                self.print_movability(movability);\n-                self.print_asyncness(asyncness);\n-                self.print_capture_clause(capture_clause);\n-\n-                self.print_fn_params_and_ret(decl, true);\n-                self.space();\n-                self.print_expr(body);\n-                self.end(); // need to close a box\n-\n-                // a box will be closed by print_expr, but we didn't want an overall\n-                // wrapper so we closed the corresponding opening. so create an\n-                // empty box to satisfy the close.\n-                self.ibox(0);\n-            }\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                // containing cbox, will be closed by print-block at }\n-                self.cbox(INDENT_UNIT);\n-                // head-box, will be closed by print-block after {\n-                self.ibox(0);\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n-                self.word_nbsp(\"async\");\n-                self.print_capture_clause(capture_clause);\n-                // cbox/ibox in analogy to the `ExprKind::Block` arm above\n-                self.cbox(INDENT_UNIT);\n-                self.ibox(0);\n-                self.print_block_with_attrs(blk, attrs);\n-            }\n-            ast::ExprKind::Await(ref expr) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\".await\");\n-            }\n-            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n-                let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.space();\n-                self.word_space(\"=\");\n-                self.print_expr_maybe_paren(rhs, prec);\n-            }\n-            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.space();\n-                self.word(op.node.to_string());\n-                self.word_space(\"=\");\n-                self.print_expr_maybe_paren(rhs, prec);\n-            }\n-            ast::ExprKind::Field(ref expr, ident) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\".\");\n-                self.print_ident(ident);\n-            }\n-            ast::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.word(\"[\");\n-                self.print_expr(index);\n-                self.word(\"]\");\n-            }\n-            ast::ExprKind::Range(ref start, ref end, limits) => {\n-                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n-                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n-                // Here we use a fake precedence value so that any child with lower precedence than\n-                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n-                let fake_prec = AssocOp::LOr.precedence() as i8;\n-                if let Some(ref e) = *start {\n-                    self.print_expr_maybe_paren(e, fake_prec);\n-                }\n-                if limits == ast::RangeLimits::HalfOpen {\n-                    self.word(\"..\");\n-                } else {\n-                    self.word(\"..=\");\n-                }\n-                if let Some(ref e) = *end {\n-                    self.print_expr_maybe_paren(e, fake_prec);\n-                }\n-            }\n-            ast::ExprKind::Underscore => self.word(\"_\"),\n-            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n-            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n-            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n-                self.word(\"break\");\n-                if let Some(label) = opt_label {\n-                    self.space();\n-                    self.print_ident(label.ident);\n-                }\n-                if let Some(ref expr) = *opt_expr {\n-                    self.space();\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::Continue(opt_label) => {\n-                self.word(\"continue\");\n-                if let Some(label) = opt_label {\n-                    self.space();\n-                    self.print_ident(label.ident);\n-                }\n-            }\n-            ast::ExprKind::Ret(ref result) => {\n-                self.word(\"return\");\n-                if let Some(ref expr) = *result {\n-                    self.word(\" \");\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::InlineAsm(ref a) => {\n-                self.word(\"asm!\");\n-                self.print_inline_asm(a);\n-            }\n-            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n-            ast::ExprKind::Paren(ref e) => {\n-                self.popen();\n-                self.print_expr(e);\n-                self.pclose();\n-            }\n-            ast::ExprKind::Yield(ref e) => {\n-                self.word(\"yield\");\n-\n-                if let Some(ref expr) = *e {\n-                    self.space();\n-                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                }\n-            }\n-            ast::ExprKind::Try(ref e) => {\n-                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n-                self.word(\"?\")\n-            }\n-            ast::ExprKind::TryBlock(ref blk) => {\n-                self.head(\"try\");\n-                self.print_block_with_attrs(blk, attrs)\n-            }\n-            ast::ExprKind::Err => {\n-                self.popen();\n-                self.word(\"/*ERROR*/\");\n-                self.pclose()\n-            }\n-        }\n-        self.ann.post(self, AnnNode::Expr(expr));\n-        self.end();\n-    }\n-\n     fn print_inline_asm(&mut self, asm: &ast::InlineAsm) {\n         enum AsmArg<'a> {\n             Template(String),\n@@ -2496,48 +1991,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    fn print_arm(&mut self, arm: &ast::Arm) {\n-        // Note, I have no idea why this check is necessary, but here it is.\n-        if arm.attrs.is_empty() {\n-            self.space();\n-        }\n-        self.cbox(INDENT_UNIT);\n-        self.ibox(0);\n-        self.maybe_print_comment(arm.pat.span.lo());\n-        self.print_outer_attributes(&arm.attrs);\n-        self.print_pat(&arm.pat);\n-        self.space();\n-        if let Some(ref e) = arm.guard {\n-            self.word_space(\"if\");\n-            self.print_expr(e);\n-            self.space();\n-        }\n-        self.word_space(\"=>\");\n-\n-        match arm.body.kind {\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-\n-                // The block will close the pattern's ibox.\n-                self.print_block_unclosed_indent(blk);\n-\n-                // If it is a user-provided unsafe block, print a comma after it.\n-                if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n-                    self.word(\",\");\n-                }\n-            }\n-            _ => {\n-                self.end(); // Close the ibox for the pattern.\n-                self.print_expr(&arm.body);\n-                self.word(\",\");\n-            }\n-        }\n-        self.end(); // Close enclosing cbox.\n-    }\n-\n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n@@ -2608,26 +2061,12 @@ impl<'a> State<'a> {\n         self.print_fn_ret_ty(&decl.output)\n     }\n \n-    crate fn print_movability(&mut self, movability: ast::Movability) {\n-        match movability {\n-            ast::Movability::Static => self.word_space(\"static\"),\n-            ast::Movability::Movable => {}\n-        }\n-    }\n-\n     crate fn print_asyncness(&mut self, asyncness: ast::Async) {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\");\n         }\n     }\n \n-    crate fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy) {\n-        match capture_clause {\n-            ast::CaptureBy::Value => self.word_space(\"move\"),\n-            ast::CaptureBy::Ref => {}\n-        }\n-    }\n-\n     pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound]) {\n         if !bounds.is_empty() {\n             self.word(prefix);"}, {"sha": "956200d60f5078940b1c7bc2188793ba61580397", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/b1605643e3a9f62bdbe97c4854745e2f28ccd456/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1605643e3a9f62bdbe97c4854745e2f28ccd456/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=b1605643e3a9f62bdbe97c4854745e2f28ccd456", "patch": "@@ -0,0 +1,571 @@\n+use crate::pp::Breaks::{Consistent, Inconsistent};\n+use crate::pprust::state::{AnnNode, PrintState, State, INDENT_UNIT};\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::util::parser::{self, AssocOp, Fixity};\n+use rustc_ast::{self as ast, BlockCheckMode};\n+\n+impl<'a> State<'a> {\n+    fn print_else(&mut self, els: Option<&ast::Expr>) {\n+        if let Some(_else) = els {\n+            match _else.kind {\n+                // Another `else if` block.\n+                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.word(\" else if \");\n+                    self.print_expr_as_cond(i);\n+                    self.space();\n+                    self.print_block(then);\n+                    self.print_else(e.as_deref())\n+                }\n+                // Final `else` block.\n+                ast::ExprKind::Block(ref b, _) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.word(\" else \");\n+                    self.print_block(b)\n+                }\n+                // Constraints would be great here!\n+                _ => {\n+                    panic!(\"print_if saw if with weird alternative\");\n+                }\n+            }\n+        }\n+    }\n+\n+    fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n+        self.head(\"if\");\n+        self.print_expr_as_cond(test);\n+        self.space();\n+        self.print_block(blk);\n+        self.print_else(elseopt)\n+    }\n+\n+    fn print_call_post(&mut self, args: &[P<ast::Expr>]) {\n+        self.popen();\n+        self.commasep_exprs(Inconsistent, args);\n+        self.pclose()\n+    }\n+\n+    fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) {\n+        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n+    }\n+\n+    /// Prints an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    fn print_expr_as_cond(&mut self, expr: &ast::Expr) {\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n+    }\n+\n+    // Does `expr` need parentheses when printed in a condition position?\n+    //\n+    // These cases need parens due to the parse error observed in #26461: `if return {}`\n+    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+    pub(super) fn cond_needs_par(expr: &ast::Expr) -> bool {\n+        match expr.kind {\n+            ast::ExprKind::Break(..) | ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) => true,\n+            _ => parser::contains_exterior_struct_lit(expr),\n+        }\n+    }\n+\n+    /// Prints `expr` or `(expr)` when `needs_par` holds.\n+    pub(super) fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n+        if needs_par {\n+            self.popen();\n+        }\n+        self.print_expr(expr);\n+        if needs_par {\n+            self.pclose();\n+        }\n+    }\n+\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"[\");\n+        self.commasep_exprs(Inconsistent, exprs);\n+        self.word(\"]\");\n+        self.end();\n+    }\n+\n+    pub(super) fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"const\");\n+        self.print_expr(&expr.value);\n+        self.end();\n+    }\n+\n+    fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n+        self.ibox(INDENT_UNIT);\n+        self.word(\"[\");\n+        self.print_expr(element);\n+        self.word_space(\";\");\n+        self.print_expr(&count.value);\n+        self.word(\"]\");\n+        self.end();\n+    }\n+\n+    fn print_expr_struct(\n+        &mut self,\n+        qself: &Option<ast::QSelf>,\n+        path: &ast::Path,\n+        fields: &[ast::ExprField],\n+        rest: &ast::StructRest,\n+    ) {\n+        if let Some(qself) = qself {\n+            self.print_qpath(path, qself, true);\n+        } else {\n+            self.print_path(path, true, 0);\n+        }\n+        self.word(\"{\");\n+        self.commasep_cmnt(\n+            Consistent,\n+            fields,\n+            |s, field| {\n+                s.print_outer_attributes(&field.attrs);\n+                s.ibox(INDENT_UNIT);\n+                if !field.is_shorthand {\n+                    s.print_ident(field.ident);\n+                    s.word_space(\":\");\n+                }\n+                s.print_expr(&field.expr);\n+                s.end();\n+            },\n+            |f| f.span,\n+        );\n+        match rest {\n+            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n+                self.ibox(INDENT_UNIT);\n+                if !fields.is_empty() {\n+                    self.word(\",\");\n+                    self.space();\n+                }\n+                self.word(\"..\");\n+                if let ast::StructRest::Base(ref expr) = *rest {\n+                    self.print_expr(expr);\n+                }\n+                self.end();\n+            }\n+            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n+            _ => {}\n+        }\n+        self.word(\"}\");\n+    }\n+\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n+        self.popen();\n+        self.commasep_exprs(Inconsistent, exprs);\n+        if exprs.len() == 1 {\n+            self.word(\",\");\n+        }\n+        self.pclose()\n+    }\n+\n+    fn print_expr_call(&mut self, func: &ast::Expr, args: &[P<ast::Expr>]) {\n+        let prec = match func.kind {\n+            ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n+            _ => parser::PREC_POSTFIX,\n+        };\n+\n+        self.print_expr_maybe_paren(func, prec);\n+        self.print_call_post(args)\n+    }\n+\n+    fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n+        let base_args = &args[1..];\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n+        self.word(\".\");\n+        self.print_ident(segment.ident);\n+        if let Some(ref args) = segment.args {\n+            self.print_generic_args(args, true);\n+        }\n+        self.print_call_post(base_args)\n+    }\n+\n+    fn print_expr_binary(&mut self, op: ast::BinOp, lhs: &ast::Expr, rhs: &ast::Expr) {\n+        let assoc_op = AssocOp::from_ast_binop(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        let left_prec = match (&lhs.kind, op.node) {\n+            // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n+            // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n+            // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n+            (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt | ast::BinOpKind::Shl) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n+            // We are given `(let _ = a) OP b`.\n+            //\n+            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n+            //   as the parser will interpret this as `(let _ = a) OP b`.\n+            //\n+            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n+            //   parens are required since the parser would interpret `let a = b < c` as\n+            //   `let a = (b < c)`. To achieve this, we force parens.\n+            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n+            _ => left_prec,\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec);\n+        self.space();\n+        self.word_space(op.node.to_string());\n+        self.print_expr_maybe_paren(rhs, right_prec)\n+    }\n+\n+    fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n+        self.word(ast::UnOp::to_string(op));\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n+    }\n+\n+    fn print_expr_addr_of(\n+        &mut self,\n+        kind: ast::BorrowKind,\n+        mutability: ast::Mutability,\n+        expr: &ast::Expr,\n+    ) {\n+        self.word(\"&\");\n+        match kind {\n+            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n+            ast::BorrowKind::Raw => {\n+                self.word_nbsp(\"raw\");\n+                self.print_mutability(mutability, true);\n+            }\n+        }\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n+    }\n+\n+    pub fn print_expr(&mut self, expr: &ast::Expr) {\n+        self.print_expr_outer_attr_style(expr, true)\n+    }\n+\n+    pub(super) fn print_expr_outer_attr_style(&mut self, expr: &ast::Expr, is_inline: bool) {\n+        self.maybe_print_comment(expr.span.lo());\n+\n+        let attrs = &expr.attrs;\n+        if is_inline {\n+            self.print_outer_attributes_inline(attrs);\n+        } else {\n+            self.print_outer_attributes(attrs);\n+        }\n+\n+        self.ibox(INDENT_UNIT);\n+        self.ann.pre(self, AnnNode::Expr(expr));\n+        match expr.kind {\n+            ast::ExprKind::Box(ref expr) => {\n+                self.word_space(\"box\");\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n+            }\n+            ast::ExprKind::Array(ref exprs) => {\n+                self.print_expr_vec(exprs);\n+            }\n+            ast::ExprKind::ConstBlock(ref anon_const) => {\n+                self.print_expr_anon_const(anon_const);\n+            }\n+            ast::ExprKind::Repeat(ref element, ref count) => {\n+                self.print_expr_repeat(element, count);\n+            }\n+            ast::ExprKind::Struct(ref se) => {\n+                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n+            }\n+            ast::ExprKind::Tup(ref exprs) => {\n+                self.print_expr_tup(exprs);\n+            }\n+            ast::ExprKind::Call(ref func, ref args) => {\n+                self.print_expr_call(func, &args);\n+            }\n+            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n+                self.print_expr_method_call(segment, &args);\n+            }\n+            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+                self.print_expr_binary(op, lhs, rhs);\n+            }\n+            ast::ExprKind::Unary(op, ref expr) => {\n+                self.print_expr_unary(op, expr);\n+            }\n+            ast::ExprKind::AddrOf(k, m, ref expr) => {\n+                self.print_expr_addr_of(k, m, expr);\n+            }\n+            ast::ExprKind::Lit(ref lit) => {\n+                self.print_literal(lit);\n+            }\n+            ast::ExprKind::Cast(ref expr, ref ty) => {\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec);\n+                self.space();\n+                self.word_space(\"as\");\n+                self.print_type(ty);\n+            }\n+            ast::ExprKind::Type(ref expr, ref ty) => {\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec);\n+                self.word_space(\":\");\n+                self.print_type(ty);\n+            }\n+            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+                self.print_let(pat, scrutinee);\n+            }\n+            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n+                self.print_if(test, blk, elseopt.as_deref())\n+            }\n+            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"while\");\n+                self.print_expr_as_cond(test);\n+                self.space();\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"for\");\n+                self.print_pat(pat);\n+                self.space();\n+                self.word_space(\"in\");\n+                self.print_expr_as_cond(iter);\n+                self.space();\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Loop(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                self.head(\"loop\");\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Match(ref expr, ref arms) => {\n+                self.cbox(INDENT_UNIT);\n+                self.ibox(INDENT_UNIT);\n+                self.word_nbsp(\"match\");\n+                self.print_expr_as_cond(expr);\n+                self.space();\n+                self.bopen();\n+                self.print_inner_attributes_no_trailing_hardbreak(attrs);\n+                for arm in arms {\n+                    self.print_arm(arm);\n+                }\n+                let empty = attrs.is_empty() && arms.is_empty();\n+                self.bclose(expr.span, empty);\n+            }\n+            ast::ExprKind::Closure(\n+                capture_clause,\n+                asyncness,\n+                movability,\n+                ref decl,\n+                ref body,\n+                _,\n+            ) => {\n+                self.print_movability(movability);\n+                self.print_asyncness(asyncness);\n+                self.print_capture_clause(capture_clause);\n+\n+                self.print_fn_params_and_ret(decl, true);\n+                self.space();\n+                self.print_expr(body);\n+                self.end(); // need to close a box\n+\n+                // a box will be closed by print_expr, but we didn't want an overall\n+                // wrapper so we closed the corresponding opening. so create an\n+                // empty box to satisfy the close.\n+                self.ibox(0);\n+            }\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+                // containing cbox, will be closed by print-block at }\n+                self.cbox(INDENT_UNIT);\n+                // head-box, will be closed by print-block after {\n+                self.ibox(0);\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+                self.word_nbsp(\"async\");\n+                self.print_capture_clause(capture_clause);\n+                // cbox/ibox in analogy to the `ExprKind::Block` arm above\n+                self.cbox(INDENT_UNIT);\n+                self.ibox(0);\n+                self.print_block_with_attrs(blk, attrs);\n+            }\n+            ast::ExprKind::Await(ref expr) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\".await\");\n+            }\n+            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n+                self.space();\n+                self.word_space(\"=\");\n+                self.print_expr_maybe_paren(rhs, prec);\n+            }\n+            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n+                self.space();\n+                self.word(op.node.to_string());\n+                self.word_space(\"=\");\n+                self.print_expr_maybe_paren(rhs, prec);\n+            }\n+            ast::ExprKind::Field(ref expr, ident) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\".\");\n+                self.print_ident(ident);\n+            }\n+            ast::ExprKind::Index(ref expr, ref index) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n+                self.word(\"[\");\n+                self.print_expr(index);\n+                self.word(\"]\");\n+            }\n+            ast::ExprKind::Range(ref start, ref end, limits) => {\n+                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n+                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n+                // Here we use a fake precedence value so that any child with lower precedence than\n+                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n+                let fake_prec = AssocOp::LOr.precedence() as i8;\n+                if let Some(ref e) = *start {\n+                    self.print_expr_maybe_paren(e, fake_prec);\n+                }\n+                if limits == ast::RangeLimits::HalfOpen {\n+                    self.word(\"..\");\n+                } else {\n+                    self.word(\"..=\");\n+                }\n+                if let Some(ref e) = *end {\n+                    self.print_expr_maybe_paren(e, fake_prec);\n+                }\n+            }\n+            ast::ExprKind::Underscore => self.word(\"_\"),\n+            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n+            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n+            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n+                self.word(\"break\");\n+                if let Some(label) = opt_label {\n+                    self.space();\n+                    self.print_ident(label.ident);\n+                }\n+                if let Some(ref expr) = *opt_expr {\n+                    self.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::Continue(opt_label) => {\n+                self.word(\"continue\");\n+                if let Some(label) = opt_label {\n+                    self.space();\n+                    self.print_ident(label.ident);\n+                }\n+            }\n+            ast::ExprKind::Ret(ref result) => {\n+                self.word(\"return\");\n+                if let Some(ref expr) = *result {\n+                    self.word(\" \");\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::InlineAsm(ref a) => {\n+                self.word(\"asm!\");\n+                self.print_inline_asm(a);\n+            }\n+            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n+            ast::ExprKind::Paren(ref e) => {\n+                self.popen();\n+                self.print_expr(e);\n+                self.pclose();\n+            }\n+            ast::ExprKind::Yield(ref e) => {\n+                self.word(\"yield\");\n+\n+                if let Some(ref expr) = *e {\n+                    self.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n+                }\n+            }\n+            ast::ExprKind::Try(ref e) => {\n+                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n+                self.word(\"?\")\n+            }\n+            ast::ExprKind::TryBlock(ref blk) => {\n+                self.head(\"try\");\n+                self.print_block_with_attrs(blk, attrs)\n+            }\n+            ast::ExprKind::Err => {\n+                self.popen();\n+                self.word(\"/*ERROR*/\");\n+                self.pclose()\n+            }\n+        }\n+        self.ann.post(self, AnnNode::Expr(expr));\n+        self.end();\n+    }\n+\n+    fn print_arm(&mut self, arm: &ast::Arm) {\n+        // Note, I have no idea why this check is necessary, but here it is.\n+        if arm.attrs.is_empty() {\n+            self.space();\n+        }\n+        self.cbox(INDENT_UNIT);\n+        self.ibox(0);\n+        self.maybe_print_comment(arm.pat.span.lo());\n+        self.print_outer_attributes(&arm.attrs);\n+        self.print_pat(&arm.pat);\n+        self.space();\n+        if let Some(ref e) = arm.guard {\n+            self.word_space(\"if\");\n+            self.print_expr(e);\n+            self.space();\n+        }\n+        self.word_space(\"=>\");\n+\n+        match arm.body.kind {\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident);\n+                    self.word_space(\":\");\n+                }\n+\n+                // The block will close the pattern's ibox.\n+                self.print_block_unclosed_indent(blk);\n+\n+                // If it is a user-provided unsafe block, print a comma after it.\n+                if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n+                    self.word(\",\");\n+                }\n+            }\n+            _ => {\n+                self.end(); // Close the ibox for the pattern.\n+                self.print_expr(&arm.body);\n+                self.word(\",\");\n+            }\n+        }\n+        self.end(); // Close enclosing cbox.\n+    }\n+\n+    fn print_movability(&mut self, movability: ast::Movability) {\n+        match movability {\n+            ast::Movability::Static => self.word_space(\"static\"),\n+            ast::Movability::Movable => {}\n+        }\n+    }\n+\n+    fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy) {\n+        match capture_clause {\n+            ast::CaptureBy::Value => self.word_space(\"move\"),\n+            ast::CaptureBy::Ref => {}\n+        }\n+    }\n+}"}]}