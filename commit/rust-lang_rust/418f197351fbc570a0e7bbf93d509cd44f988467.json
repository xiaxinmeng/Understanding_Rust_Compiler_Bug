{"sha": "418f197351fbc570a0e7bbf93d509cd44f988467", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOGYxOTczNTFmYmM1NzBhMGU3YmJmOTNkNTA5Y2Q0NGY5ODg0Njc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-08T06:39:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-08T06:58:55Z"}, "message": "Test fixes and rebase conflicts", "tree": {"sha": "3b2e197847d3cb44de1f4b456db3cbd84f04f86b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b2e197847d3cb44de1f4b456db3cbd84f04f86b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/418f197351fbc570a0e7bbf93d509cd44f988467", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/418f197351fbc570a0e7bbf93d509cd44f988467", "html_url": "https://github.com/rust-lang/rust/commit/418f197351fbc570a0e7bbf93d509cd44f988467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/418f197351fbc570a0e7bbf93d509cd44f988467/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e9530218124a277ae1febbc338c4de6f88711dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9530218124a277ae1febbc338c4de6f88711dd", "html_url": "https://github.com/rust-lang/rust/commit/8e9530218124a277ae1febbc338c4de6f88711dd"}], "stats": {"total": 20, "additions": 10, "deletions": 10}, "files": [{"sha": "36ae2ba06d52b562a14e4f9853bc776a1aabbf66", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=418f197351fbc570a0e7bbf93d509cd44f988467", "patch": "@@ -168,7 +168,7 @@ impl rtio::RtioPipe for UnixStream {\n             libc::send(fd,\n                        buf as *mut libc::c_void,\n                        len as libc::size_t,\n-                       flags)\n+                       flags) as i64\n         };\n         match net::write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n             Ok(_) => Ok(()),"}, {"sha": "999da1cfda718f7fa3a1c456a30f6797e6a12db2", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=418f197351fbc570a0e7bbf93d509cd44f988467", "patch": "@@ -645,7 +645,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                         n => Err(uv_error_to_io_error(UvError(n)))\n                     }\n                 }\n-                let new_cx = ~UdpSendCtx {\n+                let new_cx = box UdpSendCtx {\n                     result: 0,\n                     udp: 0 as *mut UdpWatcher,\n                     data: cx.data.take(),\n@@ -670,7 +670,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 let udp: &mut UdpWatcher = unsafe { &mut *cx.udp };\n                 wakeup(&mut udp.blocked_sender);\n             } else {\n-                let _cx: ~UdpSendCtx = unsafe { cast::transmute(cx) };\n+                let _cx: Box<UdpSendCtx> = unsafe { cast::transmute(cx) };\n             }\n         }\n     }"}, {"sha": "36b6ed09ca5668033c1e9bdf35adc48b3ea4fea1", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=418f197351fbc570a0e7bbf93d509cd44f988467", "patch": "@@ -205,7 +205,7 @@ impl StreamWatcher {\n                 // Note that we don't cache this write request back in the\n                 // stream watcher because we no longer have ownership of it, and\n                 // we never will.\n-                let new_wcx = ~WriteContext {\n+                let new_wcx = box WriteContext {\n                     result: 0,\n                     stream: 0 as *mut StreamWatcher,\n                     data: wcx.data.take(),\n@@ -272,6 +272,6 @@ extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n         let stream: &mut StreamWatcher = unsafe { &mut *wcx.stream };\n         wakeup(&mut stream.blocked_writer);\n     } else {\n-        let _wcx: ~WriteContext = unsafe { cast::transmute(wcx) };\n+        let _wcx: Box<WriteContext> = unsafe { cast::transmute(wcx) };\n     }\n }"}, {"sha": "3dbb34bb17a871f1290d874f92c7033fca022fcb", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418f197351fbc570a0e7bbf93d509cd44f988467/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=418f197351fbc570a0e7bbf93d509cd44f988467", "patch": "@@ -25,7 +25,7 @@ use {UvHandle, wait_until_woken_after};\n /// Managment of a timeout when gaining access to a portion of a duplex stream.\n pub struct AccessTimeout {\n     state: TimeoutState,\n-    timer: Option<~TimerWatcher>,\n+    timer: Option<Box<TimerWatcher>>,\n     pub access: access::Access,\n }\n \n@@ -119,8 +119,8 @@ impl AccessTimeout {\n         // If we have a timeout, lazily initialize the timer which will be used\n         // to fire when the timeout runs out.\n         if self.timer.is_none() {\n-            let mut timer = ~TimerWatcher::new_home(loop_, home.clone());\n-            let cx = ~TimerContext {\n+            let mut timer = box TimerWatcher::new_home(loop_, home.clone());\n+            let cx = box TimerContext {\n                 timeout: self as *mut _,\n                 callback: cb,\n                 payload: data,\n@@ -199,7 +199,7 @@ impl Drop for AccessTimeout {\n         match self.timer {\n             Some(ref timer) => unsafe {\n                 let data = uvll::get_data_for_uv_handle(timer.handle);\n-                let _data: ~TimerContext = cast::transmute(data);\n+                let _data: Box<TimerContext> = cast::transmute(data);\n             },\n             None => {}\n         }\n@@ -213,7 +213,7 @@ impl Drop for AccessTimeout {\n pub struct ConnectCtx {\n     pub status: c_int,\n     pub task: Option<BlockedTask>,\n-    pub timer: Option<~TimerWatcher>,\n+    pub timer: Option<Box<TimerWatcher>>,\n }\n \n pub struct AcceptTimeout {"}]}