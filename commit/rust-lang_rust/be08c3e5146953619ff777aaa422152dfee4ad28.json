{"sha": "be08c3e5146953619ff777aaa422152dfee4ad28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMDhjM2U1MTQ2OTUzNjE5ZmY3NzdhYWE0MjIxNTJkZmVlNGFkMjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-03T20:26:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-03T20:27:16Z"}, "message": "rustc: add rooting, write-guards to slices etc", "tree": {"sha": "0dd6cad23983eaea96cf6718e3fa6d672e077469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dd6cad23983eaea96cf6718e3fa6d672e077469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be08c3e5146953619ff777aaa422152dfee4ad28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be08c3e5146953619ff777aaa422152dfee4ad28", "html_url": "https://github.com/rust-lang/rust/commit/be08c3e5146953619ff777aaa422152dfee4ad28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be08c3e5146953619ff777aaa422152dfee4ad28/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3a6ea26437e240b02d749331b3a2d60aab0588b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a6ea26437e240b02d749331b3a2d60aab0588b", "html_url": "https://github.com/rust-lang/rust/commit/f3a6ea26437e240b02d749331b3a2d60aab0588b"}], "stats": {"total": 226, "additions": 194, "deletions": 32}, "files": [{"sha": "3b1cdf0ba47f7384bd24aab31dcb186143bef449", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -866,17 +866,28 @@ pub fn extract_variant_args(bcx: block,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n+fn match_datum(bcx: block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n+    //! Helper for converting from the ValueRef that we pass around in\n+    //! the match code, which is always by ref, into a Datum. Eventually\n+    //! we should just pass around a Datum and be done with it.\n+\n+    let ty = node_id_type(bcx, pat_id);\n+    Datum {val: val, ty: ty, mode: datum::ByRef, source: RevokeClean}\n+}\n+\n+\n pub fn extract_vec_elems(bcx: block,\n+                         pat_span: span,\n                          pat_id: ast::node_id,\n                          elem_count: uint,\n                          slice: Option<uint>,\n                          val: ValueRef,\n                          count: ValueRef)\n                       -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n+    let vec_datum = match_datum(bcx, val, pat_id);\n+    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n-    let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n-    let (base, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n \n     let mut elems = do vec::from_fn(elem_count) |i| {\n         match slice {\n@@ -1308,10 +1319,14 @@ pub fn compile_submatch(bcx: block,\n                                 vec::slice(vals, col + 1u, vals.len()));\n     let ccx = *bcx.fcx.ccx;\n     let mut pat_id = 0;\n+    let mut pat_span = dummy_sp();\n     for vec::each(m) |br| {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n-        if pat_id == 0 { pat_id = br.pats[col].id; }\n+        if pat_id == 0 {\n+            pat_id = br.pats[col].id;\n+            pat_span = br.pats[col].span;\n+        }\n     }\n \n     // If we are not matching against an `@T`, we should not be\n@@ -1579,8 +1594,8 @@ pub fn compile_submatch(bcx: block,\n                     vec_len_ge(_, i) => Some(i),\n                     _ => None\n                 };\n-                let args = extract_vec_elems(opt_cx, pat_id, n, slice,\n-                    val, test_val);\n+                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n, slice,\n+                                             val, test_val);\n                 size = args.vals.len();\n                 unpacked = /*bad*/copy args.vals;\n                 opt_cx = args.bcx;"}, {"sha": "c8699cc6371bc2670a0850d5fbc9016e4842d544", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -333,7 +333,7 @@ pub fn trans_fail_expr(bcx: block,\n                 bcx, expr::trans_to_datum(bcx, arg_expr));\n \n             if ty::type_is_str(arg_datum.ty) {\n-                let (lldata, _lllen) = arg_datum.get_base_and_len(bcx);\n+                let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);\n                 return trans_fail_value(bcx, sp_opt, lldata);\n             } else if bcx.unreachable || ty::type_is_bot(arg_datum.ty) {\n                 return bcx;"}, {"sha": "6ffe504b804fb93262a2a9da584535e6ace1a0c7", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -603,6 +603,8 @@ pub impl Datum {\n     }\n \n     fn perform_write_guard(&self, bcx: block, span: span) -> block {\n+        debug!(\"perform_write_guard\");\n+\n         // Create scratch space, but do not root it.\n         let llval = match self.mode {\n             ByValue => self.val,\n@@ -682,25 +684,10 @@ pub impl Datum {\n     {\n         let ccx = bcx.ccx();\n \n-        debug!(\"try_deref(expr_id=%d, derefs=%?, is_auto=%b, self=%?)\",\n+        debug!(\"try_deref(expr_id=%?, derefs=%?, is_auto=%b, self=%?)\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n-        let _indenter = indenter();\n-\n-        // root the autoderef'd value, if necessary:\n-        //\n-        // (Note: root'd values are always boxes)\n-        let key = root_map_key { id: expr_id, derefs: derefs };\n-        let bcx = match ccx.maps.root_map.find(&key) {\n-            None => bcx,\n-            Some(&root_info) => self.root(bcx, span, key, root_info)\n-        };\n \n-        // Perform the write guard, if necessary.\n-        //\n-        // (Note: write-guarded values are always boxes)\n-        let bcx = if ccx.maps.write_guard_map.contains(&key) {\n-            self.perform_write_guard(bcx, span)\n-        } else { bcx };\n+        let bcx = self.root_and_write_guard(bcx, span, expr_id, derefs);\n \n         match ty::get(self.ty).sty {\n             ty::ty_box(_) | ty::ty_uniq(_) => {\n@@ -854,8 +841,53 @@ pub impl Datum {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n-    fn get_base_and_len(&self, bcx: block) -> (ValueRef, ValueRef) {\n-        tvec::get_base_and_len(bcx, self.to_appropriate_llval(bcx), self.ty)\n+    fn root_and_write_guard(&self,\n+                            mut bcx: block,\n+                            span: span,\n+                            expr_id: ast::node_id,\n+                            derefs: uint) -> block {\n+        let key = root_map_key { id: expr_id, derefs: derefs };\n+        debug!(\"root_and_write_guard(key=%?)\", key);\n+\n+        // root the autoderef'd value, if necessary:\n+        //\n+        // (Note: root'd values are always boxes)\n+        let ccx = bcx.ccx();\n+        bcx = match ccx.maps.root_map.find(&key) {\n+            None => bcx,\n+            Some(&root_info) => self.root(bcx, span, key, root_info)\n+        };\n+\n+        // Perform the write guard, if necessary.\n+        //\n+        // (Note: write-guarded values are always boxes)\n+        if ccx.maps.write_guard_map.contains(&key) {\n+            self.perform_write_guard(bcx, span)\n+        } else {\n+            bcx\n+        }\n+    }\n+\n+    fn get_vec_base_and_len(&self,\n+                            mut bcx: block,\n+                            span: span,\n+                            expr_id: ast::node_id)\n+                            -> (block, ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Performs rooting\n+        //! and write guards checks.\n+\n+        // only imp't for @[] and @str, but harmless\n+        bcx = self.root_and_write_guard(bcx, span, expr_id, 0);\n+        let (base, len) = self.get_vec_base_and_len_no_root(bcx);\n+        (bcx, base, len)\n+    }\n+\n+    fn get_vec_base_and_len_no_root(&self, bcx: block) -> (ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Des not root\n+        //! nor perform write guard checks.\n+\n+        let llval = self.to_appropriate_llval(bcx);\n+        tvec::get_base_and_len(bcx, llval, self.ty)\n     }\n \n     fn to_result(&self, bcx: block) -> common::Result {"}, {"sha": "b8cdfeb796db05877b90e036b8588f4c1c61235b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -218,10 +218,10 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                     unpack_datum!(bcx, auto_ref(bcx, datum))\n                 }\n                 Some(AutoBorrowVec(*)) => {\n-                    unpack_datum!(bcx, auto_slice(bcx, datum))\n+                    unpack_datum!(bcx, auto_slice(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowVecRef(*)) => {\n-                    unpack_datum!(bcx, auto_slice_and_ref(bcx, datum))\n+                    unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowFn(*)) => {\n                     // currently, all closure types are\n@@ -241,7 +241,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n     }\n \n-    fn auto_slice(bcx: block, datum: Datum) -> DatumBlock {\n+    fn auto_slice(bcx: block, expr: @ast::expr, datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since slices\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -250,7 +250,9 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n-        let (base, len) = datum.get_base_and_len(bcx);\n+        // NOTE prob need to distinguish \"auto-slice\" from explicit index?\n+        let (bcx, base, len) =\n+            datum.get_vec_base_and_len(bcx, expr.span, expr.id);\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n@@ -283,8 +285,10 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn auto_slice_and_ref(bcx: block, datum: Datum) -> DatumBlock {\n-        let DatumBlock { bcx, datum } = auto_slice(bcx, datum);\n+    fn auto_slice_and_ref(bcx: block,\n+                          expr: @ast::expr,\n+                          datum: Datum) -> DatumBlock {\n+        let DatumBlock { bcx, datum } = auto_slice(bcx, expr, datum);\n         auto_ref(bcx, datum)\n     }\n }\n@@ -903,7 +907,8 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n         base::maybe_name_value(bcx.ccx(), scaled_ix, ~\"scaled_ix\");\n \n-        let mut (base, len) = base_datum.get_base_and_len(bcx);\n+        let mut (bcx, base, len) =\n+            base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id);\n \n         if ty::type_is_str(base_ty) {\n             // acccount for null terminator in the case of string"}, {"sha": "59a5fecd3400368ba4878d8620763fd48201734f", "filename": "src/test/run-fail/borrowck-wg-fail-2.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -1,5 +1,8 @@\n // error-pattern:borrowed\n \n+// Test that write guards trigger when there is a write to a field\n+// of a frozen structure.\n+\n struct S {\n     x: int\n }"}, {"sha": "ebff553aafbad1261c6c3e6e47832be31d5dd7fe", "filename": "src/test/run-fail/borrowck-wg-fail-3.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -1,5 +1,8 @@\n // error-pattern:borrowed\n \n+// Test that write guards trigger when there is a write to a directly\n+// frozen @mut box.\n+\n fn main() {\n     let x = @mut 3;\n     let y: &mut int = x;"}, {"sha": "939d802c21ca1d67617b239d5b944db4b9438745", "filename": "src/test/run-fail/borrowck-wg-fail.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -1,5 +1,8 @@\n // error-pattern:borrowed\n \n+// Test that write guards trigger when mut box is frozen\n+// as part of argument coercion.\n+\n fn f(_x: &int, y: @mut int) {\n     *y = 2;\n }"}, {"sha": "91df90f8b3ac950406e23a2c30a306bcdb5a817c", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm-slice-method.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -0,0 +1,37 @@\n+// error-pattern:borrowed\n+\n+// Test that write guards trigger when there is a coercion to\n+// a slice on the receiver of a method.\n+\n+trait MyMutSlice {\n+    fn my_mut_slice(self) -> Self;\n+}\n+\n+impl<'self, T> MyMutSlice for &'self mut [T] {\n+    fn my_mut_slice(self) -> &'self mut [T] {\n+        self\n+    }\n+}\n+\n+trait MySlice {\n+    fn my_slice(self) -> Self;\n+}\n+\n+impl<'self, T> MySlice for &'self [T] {\n+    fn my_slice(self) -> &'self [T] {\n+        self\n+    }\n+}\n+\n+fn add(x:&mut [int], y:&[int])\n+{\n+    x[0] = x[0] + y[0];\n+}\n+\n+pub fn main()\n+{\n+    let z = @mut [1,2,3];\n+    let z2 = z;\n+    add(z.my_mut_slice(), z2.my_slice());\n+    print(fmt!(\"%d\\n\", z[0]));\n+}"}, {"sha": "bae693ce4eae2efb99ffd0951a8ee2abfdd1b86d", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm-slices.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -0,0 +1,16 @@\n+// error-pattern:borrowed\n+\n+// Test that write guards trigger when arguments are coerced to slices.\n+\n+fn add(x:&mut [int], y:&[int])\n+{\n+    x[0] = x[0] + y[0];\n+}\n+\n+pub fn main()\n+{\n+    let z = @mut [1,2,3];\n+    let z2 = z;\n+    add(z, z2);\n+    print(fmt!(\"%d\\n\", z[0]));\n+}"}, {"sha": "9e2a02b32dfed076bf4c1af93074ee451ffdab63", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -0,0 +1,17 @@\n+// error-pattern:borrowed\n+\n+// Test that write guards trigger when we are indexing into\n+// an @mut vector.\n+\n+fn add(x:&mut int, y:&int)\n+{\n+    *x = *x + *y;\n+}\n+\n+pub fn main()\n+{\n+    let z = @mut [1,2,3];\n+    let z2 = z;\n+    add(&mut z[0], &z2[0]);\n+    print(fmt!(\"%d\\n\", z[0]));\n+}"}, {"sha": "ad68448876028c62313e188d9e17358764e3b27a", "filename": "src/test/run-fail/borrowck-wg-two-array-indices.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -0,0 +1,17 @@\n+// error-pattern:borrowed\n+\n+// Test that arguments trigger when there are *two mutable* borrows\n+// of indices.\n+\n+fn add(x:&mut int, y:&mut int)\n+{\n+    *x = *x + *y;\n+}\n+\n+pub fn main()\n+{\n+    let z = @mut [1,2,3];\n+    let z2 = z;\n+    add(&mut z[0], &mut z2[0]);\n+    print(fmt!(\"%d\\n\", z[0]));\n+}"}, {"sha": "20f824e969a48de8941ee64f6772b3df8658b305", "filename": "src/test/run-pass/borrowck-wg-two-imm-borrows.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be08c3e5146953619ff777aaa422152dfee4ad28/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs?ref=be08c3e5146953619ff777aaa422152dfee4ad28", "patch": "@@ -0,0 +1,14 @@\n+// Test that we can borrow the same @mut box twice, so long as both are imm.\n+\n+fn add(x:&int, y:&int)\n+{\n+    *x + *y;\n+}\n+\n+pub fn main()\n+{\n+    let z = @mut [1,2,3];\n+    let z2 = z;\n+    add(&z[0], &z2[0]);\n+    print(fmt!(\"%d\\n\", z[0]));\n+}"}]}