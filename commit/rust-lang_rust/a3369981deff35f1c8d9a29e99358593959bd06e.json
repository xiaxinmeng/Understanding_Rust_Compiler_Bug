{"sha": "a3369981deff35f1c8d9a29e99358593959bd06e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMzY5OTgxZGVmZjM1ZjFjOGQ5YTI5ZTk5MzU4NTkzOTU5YmQwNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-18T20:41:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-18T20:41:40Z"}, "message": "Auto merge of #61749 - davidtwco:rfc-2203-const-array-repeat-exprs, r=eddyb\n\nrustc/rustc_mir: Implement RFC 2203.\n\nThis PR implements RFC 2203, allowing constants in array repeat\nexpressions. Part of #49147.\n\nr? @eddyb", "tree": {"sha": "089b75e27e6cad0354cdd93f52b46870c5338994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/089b75e27e6cad0354cdd93f52b46870c5338994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3369981deff35f1c8d9a29e99358593959bd06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3369981deff35f1c8d9a29e99358593959bd06e", "html_url": "https://github.com/rust-lang/rust/commit/a3369981deff35f1c8d9a29e99358593959bd06e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3369981deff35f1c8d9a29e99358593959bd06e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "311376d30dc1cfa622142a9f50317b1e0cb4608a", "url": "https://api.github.com/repos/rust-lang/rust/commits/311376d30dc1cfa622142a9f50317b1e0cb4608a", "html_url": "https://github.com/rust-lang/rust/commit/311376d30dc1cfa622142a9f50317b1e0cb4608a"}, {"sha": "4b1bc2ded91915e232c38cc503b5f110556cf719", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1bc2ded91915e232c38cc503b5f110556cf719", "html_url": "https://github.com/rust-lang/rust/commit/4b1bc2ded91915e232c38cc503b5f110556cf719"}], "stats": {"total": 801, "additions": 659, "deletions": 142}, "files": [{"sha": "09d1b19b4c3c382868c7500a2557a48c241f4cba", "filename": "src/doc/unstable-book/src/language-features/const-in-array-repeat-expressions.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,11 @@\n+# `const_in_array_repeat_expressions`\n+\n+The tracking issue for this feature is: [#49147]\n+\n+[#44109]: https://github.com/rust-lang/rust/issues/49147\n+\n+------------------------\n+\n+Relaxes the rules for repeat expressions, `[x; N]` such that `x` may also be `const` (strictly\n+speaking rvalue promotable), in addition to `typeof(x): Copy`. The result of `[x; N]` where `x` is\n+`const` is itself also `const`."}, {"sha": "dbb5a52e0aaa8d6040a4b44438045f9c704045c9", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -35,7 +35,7 @@ use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n-use rustc::traits::{ObligationCause, PredicateObligations};\n+use rustc::traits::{self, ObligationCause, PredicateObligations};\n use rustc::ty::adjustment::{PointerCast};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, SubstsRef, UnpackedKind, UserSubsts};\n@@ -501,28 +501,38 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             // FIXME use place_projection.is_empty() when is available\n             if let Place::Base(_) = place {\n                 if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                    let tcx = self.tcx();\n-                    let trait_ref = ty::TraitRef {\n-                        def_id: tcx.lang_items().copy_trait().unwrap(),\n-                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    let is_promoted = match place {\n+                        Place::Base(PlaceBase::Static(box Static {\n+                            kind: StaticKind::Promoted(_),\n+                            ..\n+                        })) => true,\n+                        _ => false,\n                     };\n \n-                    // In order to have a Copy operand, the type T of the\n-                    // value must be Copy. Note that we prove that T: Copy,\n-                    // rather than using the `is_copy_modulo_regions`\n-                    // test. This is important because\n-                    // `is_copy_modulo_regions` ignores the resulting region\n-                    // obligations and assumes they pass. This can result in\n-                    // bounds from Copy impls being unsoundly ignored (e.g.,\n-                    // #29149). Note that we decide to use Copy before knowing\n-                    // whether the bounds fully apply: in effect, the rule is\n-                    // that if a value of some type could implement Copy, then\n-                    // it must.\n-                    self.cx.prove_trait_ref(\n-                        trait_ref,\n-                        location.to_locations(),\n-                        ConstraintCategory::CopyBound,\n-                    );\n+                    if !is_promoted {\n+                        let tcx = self.tcx();\n+                        let trait_ref = ty::TraitRef {\n+                            def_id: tcx.lang_items().copy_trait().unwrap(),\n+                            substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                        };\n+\n+                        // In order to have a Copy operand, the type T of the\n+                        // value must be Copy. Note that we prove that T: Copy,\n+                        // rather than using the `is_copy_modulo_regions`\n+                        // test. This is important because\n+                        // `is_copy_modulo_regions` ignores the resulting region\n+                        // obligations and assumes they pass. This can result in\n+                        // bounds from Copy impls being unsoundly ignored (e.g.,\n+                        // #29149). Note that we decide to use Copy before knowing\n+                        // whether the bounds fully apply: in effect, the rule is\n+                        // that if a value of some type could implement Copy, then\n+                        // it must.\n+                        self.cx.prove_trait_ref(\n+                            trait_ref,\n+                            location.to_locations(),\n+                            ConstraintCategory::CopyBound,\n+                        );\n+                    }\n                 }\n             }\n \n@@ -1953,18 +1963,32 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Repeat(operand, len) => if *len > 1 {\n-                let operand_ty = operand.ty(body, tcx);\n-\n-                let trait_ref = ty::TraitRef {\n-                    def_id: tcx.lang_items().copy_trait().unwrap(),\n-                    substs: tcx.mk_substs_trait(operand_ty, &[]),\n-                };\n-\n-                self.prove_trait_ref(\n-                    trait_ref,\n-                    location.to_locations(),\n-                    ConstraintCategory::CopyBound,\n-                );\n+                if let Operand::Move(_) = operand {\n+                    // While this is located in `nll::typeck` this error is not an NLL error, it's\n+                    // a required check to make sure that repeated elements implement `Copy`.\n+                    let span = body.source_info(location).span;\n+                    let ty = operand.ty(body, tcx);\n+                    if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n+                        self.infcx.report_selection_error(\n+                            &traits::Obligation::new(\n+                                ObligationCause::new(\n+                                    span,\n+                                    self.tcx().hir().def_index_to_hir_id(self.mir_def_id.index),\n+                                    traits::ObligationCauseCode::RepeatVec,\n+                                ),\n+                                self.param_env,\n+                                ty::Predicate::Trait(ty::Binder::bind(ty::TraitPredicate {\n+                                    trait_ref: ty::TraitRef::new(\n+                                        self.tcx().lang_items().copy_trait().unwrap(),\n+                                        tcx.mk_substs_trait(ty, &[]),\n+                                    ),\n+                                })),\n+                            ),\n+                            &traits::SelectionError::Unimplemented,\n+                            false,\n+                        );\n+                    }\n+                }\n             },\n \n             Rvalue::NullaryOp(_, ty) => {"}, {"sha": "33eb4106d073567ffc6ebdf05d35dd571ec9156e", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -60,6 +60,9 @@ pub enum Candidate {\n     /// Borrow of a constant temporary.\n     Ref(Location),\n \n+    /// Promotion of the `x` in `[x; 32]`.\n+    Repeat(Location),\n+\n     /// Currently applied to function calls where the callee has the unstable\n     /// `#[rustc_args_required_const]` attribute as well as the SIMD shuffle\n     /// intrinsic. The intrinsic requires the arguments are indeed constant and\n@@ -322,6 +325,17 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         _ => bug!()\n                     }\n                 }\n+                Candidate::Repeat(loc) => {\n+                    let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n+                    match statement.kind {\n+                        StatementKind::Assign(_, box Rvalue::Repeat(ref mut operand, _)) => {\n+                            let ty = operand.ty(local_decls, self.tcx);\n+                            let span = statement.source_info.span;\n+                            mem::replace(operand, Operand::Copy(promoted_place(ty, span)))\n+                        }\n+                        _ => bug!()\n+                    }\n+                },\n                 Candidate::Argument { bb, index } => {\n                     let terminator = blocks[bb].terminator_mut();\n                     match terminator.kind {\n@@ -380,6 +394,7 @@ pub fn promote_candidates<'tcx>(\n \n     for candidate in candidates.into_iter().rev() {\n         match candidate {\n+            Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n                 match body[block].statements[statement_index].kind {\n                     StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _) => {"}, {"sha": "4308af7c5ad8d565fd7148dff463c8a700f524cf", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 96, "deletions": 78, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -728,84 +728,97 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let mut qualifs = self.qualifs_in_value(source);\n \n-        if let ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) = source {\n-            // Getting `true` from `HasMutInterior::in_rvalue` means\n-            // the borrowed place is disallowed from being borrowed,\n-            // due to either a mutable borrow (with some exceptions),\n-            // or an shared borrow of a value with interior mutability.\n-            // Then `HasMutInterior` is replaced with `IsNotPromotable`,\n-            // to avoid duplicate errors (e.g. from reborrowing).\n-            if qualifs[HasMutInterior] {\n-                qualifs[HasMutInterior] = false;\n-                qualifs[IsNotPromotable] = true;\n+        match source {\n+            ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) => {\n+                // Getting `true` from `HasMutInterior::in_rvalue` means\n+                // the borrowed place is disallowed from being borrowed,\n+                // due to either a mutable borrow (with some exceptions),\n+                // or an shared borrow of a value with interior mutability.\n+                // Then `HasMutInterior` is replaced with `IsNotPromotable`,\n+                // to avoid duplicate errors (e.g. from reborrowing).\n+                if qualifs[HasMutInterior] {\n+                    qualifs[HasMutInterior] = false;\n+                    qualifs[IsNotPromotable] = true;\n \n-                if self.mode.requires_const_checking() {\n-                    if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        if let BorrowKind::Mut { .. } = kind {\n-                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                        \"references in {}s may only refer \\\n-                                                            to immutable values\", self.mode);\n-                            err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                                self.mode));\n-                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                err.note(\"References in statics and constants may only refer to \\\n-                                        immutable values.\\n\\n\\\n-                                        Statics are shared everywhere, and if they refer to \\\n-                                        mutable data one might violate memory safety since \\\n-                                        holding multiple mutable references to shared data is \\\n-                                        not allowed.\\n\\n\\\n-                                        If you really want global mutable state, try using \\\n-                                        static mut or a global UnsafeCell.\");\n+                    if self.mode.requires_const_checking() {\n+                        if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                            if let BorrowKind::Mut { .. } = kind {\n+                                let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                               \"references in {}s may only refer \\\n+                                                                to immutable values\", self.mode);\n+                                err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                                    self.mode));\n+                                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                    err.note(\"References in statics and constants may only refer \\\n+                                              to immutable values.\\n\\n\\\n+                                              Statics are shared everywhere, and if they refer to \\\n+                                              mutable data one might violate memory safety since \\\n+                                              holding multiple mutable references to shared data \\\n+                                              is not allowed.\\n\\n\\\n+                                              If you really want global mutable state, try using \\\n+                                              static mut or a global UnsafeCell.\");\n+                                }\n+                                err.emit();\n+                            } else {\n+                                span_err!(self.tcx.sess, self.span, E0492,\n+                                          \"cannot borrow a constant which may contain \\\n+                                           interior mutability, create a static instead\");\n                             }\n-                            err.emit();\n-                        } else {\n-                            span_err!(self.tcx.sess, self.span, E0492,\n-                                    \"cannot borrow a constant which may contain \\\n-                                    interior mutability, create a static instead\");\n                         }\n                     }\n-                }\n-            } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n-                // Don't promote BorrowKind::Shallow borrows, as they don't\n-                // reach codegen.\n-\n-                // We might have a candidate for promotion.\n-                let candidate = Candidate::Ref(location);\n-                // Start by traversing to the \"base\", with non-deref projections removed.\n-                let mut place = place;\n-                while let Place::Projection(ref proj) = *place {\n-                    if proj.elem == ProjectionElem::Deref {\n-                        break;\n+                } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n+                    // Don't promote BorrowKind::Shallow borrows, as they don't\n+                    // reach codegen.\n+\n+                    // We might have a candidate for promotion.\n+                    let candidate = Candidate::Ref(location);\n+                    // Start by traversing to the \"base\", with non-deref projections removed.\n+                    let mut place = place;\n+                    while let Place::Projection(ref proj) = *place {\n+                        if proj.elem == ProjectionElem::Deref {\n+                            break;\n+                        }\n+                        place = &proj.base;\n                     }\n-                    place = &proj.base;\n-                }\n-                debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n-                // We can only promote interior borrows of promotable temps (non-temps\n-                // don't get promoted anyway).\n-                // (If we bailed out of the loop due to a `Deref` above, we will definitely\n-                // not enter the conditional here.)\n-                if let Place::Base(PlaceBase::Local(local)) = *place {\n-                    if self.body.local_kind(local) == LocalKind::Temp {\n-                        debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n-                        // The borrowed place doesn't have `HasMutInterior`\n-                        // (from `in_rvalue`), so we can safely ignore\n-                        // `HasMutInterior` from the local's qualifications.\n-                        // This allows borrowing fields which don't have\n-                        // `HasMutInterior`, from a type that does, e.g.:\n-                        // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                        let mut local_qualifs = self.qualifs_in_local(local);\n-                        // Any qualifications, except HasMutInterior (see above), disqualify\n-                        // from promotion.\n-                        // This is, in particular, the \"implicit promotion\" version of\n-                        // the check making sure that we don't run drop glue during const-eval.\n-                        local_qualifs[HasMutInterior] = false;\n-                        if !local_qualifs.0.iter().any(|&qualif| qualif) {\n-                            debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n-                            self.promotion_candidates.push(candidate);\n+                    debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+                    // We can only promote interior borrows of promotable temps (non-temps\n+                    // don't get promoted anyway).\n+                    // (If we bailed out of the loop due to a `Deref` above, we will definitely\n+                    // not enter the conditional here.)\n+                    if let Place::Base(PlaceBase::Local(local)) = *place {\n+                        if self.body.local_kind(local) == LocalKind::Temp {\n+                            debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n+                            // The borrowed place doesn't have `HasMutInterior`\n+                            // (from `in_rvalue`), so we can safely ignore\n+                            // `HasMutInterior` from the local's qualifications.\n+                            // This allows borrowing fields which don't have\n+                            // `HasMutInterior`, from a type that does, e.g.:\n+                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                            let mut local_qualifs = self.qualifs_in_local(local);\n+                            // Any qualifications, except HasMutInterior (see above), disqualify\n+                            // from promotion.\n+                            // This is, in particular, the \"implicit promotion\" version of\n+                            // the check making sure that we don't run drop glue during const-eval.\n+                            local_qualifs[HasMutInterior] = false;\n+                            if !local_qualifs.0.iter().any(|&qualif| qualif) {\n+                                debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n+                                self.promotion_candidates.push(candidate);\n+                            }\n                         }\n                     }\n                 }\n-            }\n+            },\n+            ValueSource::Rvalue(&Rvalue::Repeat(ref operand, _)) => {\n+                let candidate = Candidate::Repeat(location);\n+                let not_promotable = IsNotImplicitlyPromotable::in_operand(self, operand) ||\n+                                     IsNotPromotable::in_operand(self, operand);\n+                debug!(\"assign: self.def_id={:?} operand={:?}\", self.def_id, operand);\n+                if !not_promotable && self.tcx.features().const_in_array_repeat_expressions {\n+                    debug!(\"assign: candidate={:?}\", candidate);\n+                    self.promotion_candidates.push(candidate);\n+                }\n+            },\n+            _ => {},\n         }\n \n         let mut dest = dest;\n@@ -935,15 +948,20 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         debug!(\"qualify_const: promotion_candidates={:?}\", self.promotion_candidates);\n         for candidate in &self.promotion_candidates {\n             match *candidate {\n+                Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n+                    if let StatementKind::Assign(_, box Rvalue::Repeat(\n+                        Operand::Move(Place::Base(PlaceBase::Local(index))),\n+                        _\n+                    )) = self.body[bb].statements[stmt_idx].kind {\n+                        promoted_temps.insert(index);\n+                    }\n+                }\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                    match self.body[bb].statements[stmt_idx].kind {\n-                        StatementKind::Assign(\n-                            _,\n-                            box Rvalue::Ref(_, _, Place::Base(PlaceBase::Local(index)))\n-                        ) => {\n-                            promoted_temps.insert(index);\n-                        }\n-                        _ => {}\n+                    if let StatementKind::Assign(\n+                        _,\n+                        box Rvalue::Ref(_, _, Place::Base(PlaceBase::Local(index)))\n+                    ) = self.body[bb].statements[stmt_idx].kind {\n+                        promoted_temps.insert(index);\n                     }\n                 }\n                 Candidate::Argument { .. } => {}"}, {"sha": "f2dbceb31b9ca58ea15cd43bc260a308a2e722cc", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -13,7 +13,6 @@ use crate::check::report_unexpected_variant_res;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n use crate::check::method::SelfSource;\n-use crate::middle::lang_items;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n@@ -863,7 +862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         element: &'tcx hir::Expr,\n         count: &'tcx hir::AnonConst,\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        _expr: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let count_def_id = tcx.hir().local_def_id(count.hir_id);\n@@ -911,16 +910,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        if let Ok(count) = count {\n-            let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n-            if !zero_or_one {\n-                // For [foo, ..n] where n > 1, `foo` must have\n-                // Copy type:\n-                let lang_item = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n-            }\n-        }\n-\n         if element_ty.references_error() {\n             tcx.types.err\n         } else if let Ok(count) = count {"}, {"sha": "6a3f58ec89e19112c571051b63234026dcf272a9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -559,10 +559,10 @@ declare_features! (\n     // Allows `if/while p && let q = r && ...` chains.\n     (active, let_chains, \"1.37.0\", Some(53667), None),\n \n-    // #[repr(transparent)] on enums.\n+    // Allows #[repr(transparent)] on enums (RFC 2645).\n     (active, transparent_enums, \"1.37.0\", Some(60405), None),\n \n-    // #[repr(transparent)] on unions.\n+    // Allows #[repr(transparent)] on unions (RFC 2645).\n     (active, transparent_unions, \"1.37.0\", Some(60405), None),\n \n     // Allows explicit discriminants on non-unit enum variants.\n@@ -577,6 +577,9 @@ declare_features! (\n     // Allows the use of `#[cfg(doctest)]`, set when rustdoc is collecting doctests\n     (active, cfg_doctest, \"1.37.0\", Some(62210), None),\n \n+    // Allows `[x; N]` where `x` is a constant (RFC 2203).\n+    (active, const_in_array_repeat_expressions, \"1.37.0\", Some(49147), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "8da3e6c19d5e309e3e7d453e217c9c481bf371fa", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -199,6 +199,7 @@ symbols! {\n         const_fn_union,\n         const_generics,\n         const_indexing,\n+        const_in_array_repeat_expressions,\n         const_let,\n         const_panic,\n         const_raw_ptr_deref,"}, {"sha": "7bb36f41b8f9d1a3cd0b76a3ed31fa99b79dd35e", "filename": "src/test/ui/const-generics/issue-61336-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -3,11 +3,12 @@\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; {N}]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n     [x; {N}]\n-    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {"}, {"sha": "473ed46b104e917e8f698ae248e1ab01fd5540ec", "filename": "src/test/ui/const-generics/issue-61336-2.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -4,15 +4,17 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n-  --> $DIR/issue-61336-2.rs:9:5\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336-2.rs:5:9\n    |\n LL |     [x; {N}]\n-   |     ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |         ^^^\n+\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336-2.rs:10:9\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n-   = note: the `Copy` trait is required because the repeated element will be copied\n+LL |     [x; {N}]\n+   |         ^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "edc012cbb3d13c7f30ee803381d5b4c94130a5bd", "filename": "src/test/ui/const-generics/issue-61336.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -3,11 +3,12 @@\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n+    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {"}, {"sha": "ae4ef3a906a4fd8c12c53f0878aaa8f11594c3e7", "filename": "src/test/ui/const-generics/issue-61336.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -4,15 +4,17 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n-  --> $DIR/issue-61336.rs:9:5\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336.rs:5:9\n    |\n LL |     [x; N]\n-   |     ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |         ^\n+\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336.rs:10:9\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n-   = note: the `Copy` trait is required because the repeated element will be copied\n+LL |     [x; N]\n+   |         ^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "68a9227dea96ed4dd22549b440f5271099744495", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/const-fns.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,26 @@\n+// ignore-tidy-linelength\n+// ignore-compare-mode-nll\n+#![feature(const_in_array_repeat_expressions, nll)]\n+#![allow(warnings)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+const fn type_no_copy() -> Option<Bar> {\n+    None\n+}\n+\n+const fn type_copy() -> u32 {\n+    3\n+}\n+\n+fn no_copy() {\n+    const ARR: [Option<Bar>; 2] = [type_no_copy(); 2];\n+    //~^ ERROR the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied [E0277]\n+}\n+\n+fn copy() {\n+    const ARR: [u32; 2] = [type_copy(); 2];\n+}\n+\n+fn main() {}"}, {"sha": "82272af958a2ee9b0657672a955d158865cad8bd", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/const-fns.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.stderr?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied\n+  --> $DIR/const-fns.rs:18:35\n+   |\n+LL |     const ARR: [Option<Bar>; 2] = [type_no_copy(); 2];\n+   |                                   ^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = help: the following implementations were found:\n+             <std::option::Option<T> as std::marker::Copy>\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "3b7d7e5b51a2251eca1ba25559c92688a5dac227", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-fail.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-fail.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,26 @@\n+// ignore-tidy-linelength\n+// ignore-compare-mode-nll\n+// compile-flags: -Z borrowck=migrate\n+#![feature(const_in_array_repeat_expressions)]\n+#![allow(warnings)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+mod non_constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied [E0277]\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied [E0277]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "aad6763f15094013aa157aea4a2c5d1ad4e6728b", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-fail.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-fail.stderr?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,23 @@\n+error[E0277]: the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied\n+  --> $DIR/migrate-fail.rs:15:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = help: the following implementations were found:\n+             <std::option::Option<T> as std::marker::Copy>\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error[E0277]: the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied\n+  --> $DIR/migrate-fail.rs:21:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = help: the following implementations were found:\n+             <std::option::Option<T> as std::marker::Copy>\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "bfa8ebcfdd32af3cffa16437284d453f6c7206c7", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-pass.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fmigrate-pass.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,128 @@\n+// check-pass\n+// compile-flags: -Z borrowck=migrate\n+// ignore-compare-mode-nll\n+#![feature(const_in_array_repeat_expressions)]\n+#![allow(warnings)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+mod constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+}\n+\n+mod non_constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        let x = None;\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "dc1193a2fe8f3820ba8c000d6fa4e737ad1179b5", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-fail.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-fail.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,25 @@\n+// ignore-tidy-linelength\n+// ignore-compare-mode-nll\n+#![feature(const_in_array_repeat_expressions, nll)]\n+#![allow(warnings)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+mod non_constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied [E0277]\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 2] = [x; 2];\n+        //~^ ERROR the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied [E0277]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fd32484ff92c106c4c256c1349e5e24378a09a35", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-fail.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-fail.stderr?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,23 @@\n+error[E0277]: the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied\n+  --> $DIR/nll-fail.rs:14:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = help: the following implementations were found:\n+             <std::option::Option<T> as std::marker::Copy>\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error[E0277]: the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied\n+  --> $DIR/nll-fail.rs:20:37\n+   |\n+LL |         let arr: [Option<Bar>; 2] = [x; 2];\n+   |                                     ^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+   |\n+   = help: the following implementations were found:\n+             <std::option::Option<T> as std::marker::Copy>\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a304f877ab7adc13ddcadf7b6ac812df7b7d33d2", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-pass.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fnll-pass.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,127 @@\n+// check-pass\n+// ignore-compare-mode-nll\n+#![allow(warnings)]\n+#![feature(const_in_array_repeat_expressions, nll)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+mod constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<Bar> = None;\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 0] = [FOO; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 1] = [FOO; 1];\n+    }\n+\n+    fn no_impl_copy_value_multiple_elements() {\n+        const FOO: Option<Bar> = Some(Bar);\n+        const ARR: [Option<Bar>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        const FOO: Option<u32> = None;\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 0] = [FOO; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 1] = [FOO; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        const FOO: Option<u32> = Some(4);\n+        const ARR: [Option<u32>; 2] = [FOO; 2];\n+    }\n+}\n+\n+mod non_constants {\n+    use Bar;\n+\n+    fn no_impl_copy_empty_value_no_elements() {\n+        let x = None;\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_empty_value_single_element() {\n+        let x = None;\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn no_impl_copy_value_no_elements() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 0] = [x; 0];\n+    }\n+\n+    fn no_impl_copy_value_single_element() {\n+        let x = Some(Bar);\n+        let arr: [Option<Bar>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_empty_value_no_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_empty_value_one_element() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_empty_value_multiple_elements() {\n+        let x: Option<u32> = None;\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+\n+    fn impl_copy_value_no_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 0] = [x; 0];\n+    }\n+\n+    fn impl_copy_value_one_element() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 1] = [x; 1];\n+    }\n+\n+    fn impl_copy_value_multiple_elements() {\n+        let x: Option<u32> = Some(4);\n+        let arr: [Option<u32>; 2] = [x; 2];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "27bf5dabf566b503719040e54dd4c5bba3883da0", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/run-pass.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Frun-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Frun-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Frun-pass.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+#![feature(const_in_array_repeat_expressions)]\n+\n+#[derive(Debug, Eq, PartialEq)]\n+struct Bar;\n+\n+fn main() {\n+    const FOO: Option<Bar> = None;\n+    const ARR: [Option<Bar>; 2] = [FOO; 2];\n+\n+    assert_eq!(ARR, [None::<Bar>, None::<Bar>]);\n+}"}, {"sha": "35484d265bb5eea102dec3cd643216cbdc3db91a", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/trait-error.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ftrait-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ftrait-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ftrait-error.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,10 @@\n+// ignore-tidy-linelength\n+#![feature(const_in_array_repeat_expressions)]\n+\n+#[derive(Copy, Clone)]\n+struct Foo<T>(T);\n+\n+fn main() {\n+    [Foo(String::new()); 4];\n+    //~^ ERROR the trait bound `Foo<std::string::String>: std::marker::Copy` is not satisfied [E0277]\n+}"}, {"sha": "186909e469e05ae6f12e93c3a5cdac13ee03ab93", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/trait-error.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ftrait-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ftrait-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ftrait-error.stderr?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the trait bound `Foo<std::string::String>: std::marker::Copy` is not satisfied\n+  --> $DIR/trait-error.rs:8:5\n+   |\n+LL |     [Foo(String::new()); 4];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `Foo<std::string::String>`\n+   |\n+   = help: the following implementations were found:\n+             <Foo<T> as std::marker::Copy>\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "be195271c10cec0d8a30e2419f9e33c8e4e2e90d", "filename": "src/test/ui/feature-gates/feature-gate-const_in_array_repeat_expressions.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,11 @@\n+// ignore-tidy-linelength\n+#![allow(warnings)]\n+\n+struct Bar;\n+\n+fn foo() {\n+    let arr: [Option<String>; 2] = [None::<String>; 2];\n+    //~^ ERROR the trait bound `std::option::Option<std::string::String>: std::marker::Copy` is not satisfied [E0277]\n+}\n+\n+fn main() {}"}, {"sha": "eed69a0c28db840dc74507b84ffb9921458cee0f", "filename": "src/test/ui/feature-gates/feature-gate-const_in_array_repeat_expressions.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.stderr?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the trait bound `std::option::Option<std::string::String>: std::marker::Copy` is not satisfied\n+  --> $DIR/feature-gate-const_in_array_repeat_expressions.rs:7:36\n+   |\n+LL |     let arr: [Option<String>; 2] = [None::<String>; 2];\n+   |                                    ^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<std::string::String>`\n+   |\n+   = help: the following implementations were found:\n+             <std::option::Option<T> as std::marker::Copy>\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d857178166a88e1f724ab0a58e5583109605e7bd", "filename": "src/test/ui/repeat-to-run-dtor-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3369981deff35f1c8d9a29e99358593959bd06e/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat-to-run-dtor-twice.rs?ref=a3369981deff35f1c8d9a29e99358593959bd06e", "patch": "@@ -15,5 +15,5 @@ impl Drop for Foo {\n fn main() {\n     let a = Foo { x: 3 };\n     let _ = [ a; 5 ];\n-    //~^ ERROR `Foo: std::marker::Copy` is not satisfied\n+    //~^ ERROR the trait bound `Foo: std::marker::Copy` is not satisfied [E0277]\n }"}]}