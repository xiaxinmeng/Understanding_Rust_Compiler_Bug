{"sha": "2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MjFjZGExZWM1ZTI0Y2NlODFlMjVmY2Y2NDI4MTU4NGZjZmRiNWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-10-15T00:00:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-02T21:14:19Z"}, "message": "work on making the size of ints depend on the target arch", "tree": {"sha": "8cf027a98c4c7bc28d225192f2c99565ec14a56b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cf027a98c4c7bc28d225192f2c99565ec14a56b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "html_url": "https://github.com/rust-lang/rust/commit/2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2521cda1ec5e24cce81e25fcf64281584fcfdb5d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9146bb09a14a66044206119366231a5296612d8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9146bb09a14a66044206119366231a5296612d8d", "html_url": "https://github.com/rust-lang/rust/commit/9146bb09a14a66044206119366231a5296612d8d"}], "stats": {"total": 152, "additions": 92, "deletions": 60}, "files": [{"sha": "138d3a3bbd554c9601c5936dba5034120affa0ea", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2521cda1ec5e24cce81e25fcf64281584fcfdb5d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2521cda1ec5e24cce81e25fcf64281584fcfdb5d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "patch": "@@ -134,9 +134,9 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         T_nil() /* ...I guess? */\n       }\n       ty::ty_bool. { T_bool() }\n-      ty::ty_int. { T_int(cx) }\n-      ty::ty_float. { T_float(cx) }\n-      ty::ty_uint. { T_int(cx) }\n+      ty::ty_int. { cx.int_type }\n+      ty::ty_float. { cx.float_type }\n+      ty::ty_uint. { cx.int_type }\n       ty::ty_machine(tm) {\n         alt tm {\n           ast::ty_i8. | ast::ty_u8. { T_i8() }\n@@ -345,8 +345,8 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n                         llmod: ModuleRef,\n                         name: str, n_args: int) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n-    let inputs = std::vec::init_elt::<TypeRef>(T_int(ccx), n_args as uint);\n-    let output = T_int(ccx);\n+    let inputs = std::vec::init_elt::<TypeRef>(ccx.int_type, n_args as uint);\n+    let output = ccx.int_type;\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n }\n@@ -405,12 +405,12 @@ fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n }\n \n fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), T_int(cx),\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n                                False);\n }\n \n fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), T_int(cx),\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n                                False);\n }\n \n@@ -597,7 +597,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         let ccx = bcx_ccx(bcx);\n         // Compute max(variant sizes).\n \n-        let max_size: ValueRef = alloca(bcx, T_int(ccx));\n+        let max_size: ValueRef = alloca(bcx, ccx.int_type);\n         Store(bcx, C_int(ccx, 0), max_size);\n         let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n         for variant: ty::variant_info in variants {\n@@ -618,7 +618,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         let max_size_val = Load(bcx, max_size);\n         let total_size =\n             if std::vec::len(variants) != 1u {\n-                Add(bcx, max_size_val, llsize_of(ccx, T_int(ccx)))\n+                Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n       }\n@@ -2161,7 +2161,7 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n         // if target int width is larger than host, at the moment;\n         // re-do the mach-int types using 'big' when that works.\n \n-        let t = T_int(cx);\n+        let t = cx.int_type;\n         let s = True;\n         alt tm {\n           ast::ty_u8. { t = T_i8(); s = False; }\n@@ -2177,7 +2177,7 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n       }\n       ast::lit_float(fs) { ret C_float(cx, fs); }\n       ast::lit_mach_float(tm, s) {\n-        let t = T_float(cx);\n+        let t = cx.float_type;\n         alt tm { ast::ty_f32. { t = T_f32(); } ast::ty_f64. { t = T_f64(); } }\n         ret C_floating(s, t);\n       }\n@@ -2961,7 +2961,7 @@ fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n         let gvar =\n             str::as_buf(sym,\n                         {|buf|\n-                            llvm::LLVMAddGlobal(ccx.llmod, T_int(ccx), buf)\n+                            llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n                         });\n         llvm::LLVMSetLinkage(gvar,\n                              lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n@@ -3120,11 +3120,11 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n     let ix_val;\n     let ix_size = llsize_of_real(bcx_ccx(cx), val_ty(ix.val));\n-    let int_size = llsize_of_real(bcx_ccx(cx), T_int(ccx));\n+    let int_size = llsize_of_real(bcx_ccx(cx), ccx.int_type);\n     if ix_size < int_size {\n-        ix_val = ZExt(bcx, ix.val, T_int(ccx));\n+        ix_val = ZExt(bcx, ix.val, ccx.int_type);\n     } else if ix_size > int_size {\n-        ix_val = Trunc(bcx, ix.val, T_int(ccx));\n+        ix_val = Trunc(bcx, ix.val, ccx.int_type);\n     } else { ix_val = ix.val; }\n \n     let unit_ty = node_id_type(bcx_ccx(cx), id);\n@@ -4420,10 +4420,10 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             lcx.ccx, lcx.module_path, \"loglevel\");\n         let global = str::as_buf(s, {|buf|\n-            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(ccx), buf)\n+            llvm::LLVMAddGlobal(lcx.ccx.llmod, ccx.int_type, buf)\n         });\n         llvm::LLVMSetGlobalConstant(global, False);\n-        llvm::LLVMSetInitializer(global, C_null(T_int(ccx)));\n+        llvm::LLVMSetInitializer(global, C_null(ccx.int_type));\n         llvm::LLVMSetLinkage(global,\n                              lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n         lcx.ccx.module_data.insert(modname, global);\n@@ -5651,14 +5651,14 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n         cast_to_i32 = true;\n       }\n       ast::native_abi_c_stack_cdecl. {\n-        let llfn = decl_cdecl_fn(ccx.llmod, name, T_fn([], T_int()));\n+        let llfn = decl_cdecl_fn(ccx.llmod, name, T_fn([], ccx.int_type));\n         ccx.item_ids.insert(id, llfn);\n         ccx.item_symbols.insert(id, name);\n         ret;\n       }\n       ast::native_abi_c_stack_stdcall. {\n         let llfn = decl_fn(ccx.llmod, name, lib::llvm::LLVMX86StdcallCallConv,\n-                           T_fn([], T_int()));\n+                           T_fn([], ccx.int_type));\n         ccx.item_ids.insert(id, llfn);\n         ccx.item_symbols.insert(id, name);\n         ret;\n@@ -5706,21 +5706,23 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n     fn convert_arg_to_i32(cx: @block_ctxt, v: ValueRef, t: ty::t,\n                           mode: ty::mode) -> ValueRef {\n         if mode == ast::by_ref || mode == ast::by_val {\n+            let ccx = bcx_ccx(cx);\n             if ty::type_is_integral(bcx_tcx(cx), t) {\n                 // FIXME: would be nice to have a postcondition that says\n                 // if a type is integral, then it has static size (#586)\n-                let lldsttype = T_int();\n-                let ccx = bcx_ccx(cx);\n+                let lldsttype = ccx.int_type;\n                 let sp = cx.sp;\n                 check (type_has_static_size(ccx, t));\n                 let llsrctype = type_of(ccx, sp, t);\n                 if llvm::LLVMGetIntTypeWidth(lldsttype) >\n                        llvm::LLVMGetIntTypeWidth(llsrctype) {\n-                    ret ZExtOrBitCast(cx, v, T_int());\n+                    ret ZExtOrBitCast(cx, v, ccx.int_type);\n                 }\n-                ret TruncOrBitCast(cx, v, T_int());\n+                ret TruncOrBitCast(cx, v, ccx.int_type);\n+            }\n+            if ty::type_is_fp(bcx_tcx(cx), t) {\n+                ret FPToSI(cx, v, ccx.int_type);\n             }\n-            if ty::type_is_fp(bcx_tcx(cx), t) { ret FPToSI(cx, v, T_int()); }\n         }\n         ret vp2i(cx, v);\n     }\n@@ -5927,11 +5929,10 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n             let p = new_pt + [it.ident, variant.node.name, \"discrim\"];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let discrim_gvar =\n-                str::as_buf(s,\n-                            {|buf|\n-                                llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n-                            });\n-            llvm::LLVMSetInitializer(discrim_gvar, C_int(i as int));\n+                str::as_buf(s, {|buf|\n+                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                });\n+            llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, i as int));\n             llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n             ccx.discrims.insert(\n                 ast_util::local_def(variant.node.id), discrim_gvar);\n@@ -5951,10 +5952,13 @@ fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n }\n \n fn vp2i(cx: @block_ctxt, v: ValueRef) -> ValueRef {\n-    ret PtrToInt(cx, v, T_int());\n+    let ccx = bcx_ccx(cx);\n+    ret PtrToInt(cx, v, ccx.int_type);\n }\n \n-fn p2i(v: ValueRef) -> ValueRef { ret llvm::LLVMConstPtrToInt(v, T_int()); }\n+fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n+    ret llvm::LLVMConstPtrToInt(v, ccx.int_type);\n+}\n \n fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n     let T_memmove32_args: [TypeRef] =\n@@ -6005,7 +6009,7 @@ fn trap(bcx: @block_ctxt) {\n }\n \n fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n-    let elttype = T_struct([T_int(), T_int()]);\n+    let elttype = T_struct([ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     let map =\n         str::as_buf(\"_rust_mod_map\",\n@@ -6057,6 +6061,24 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     subcrates += [C_int(0)];\n     llvm::LLVMSetInitializer(map, C_struct([p2i(create_module_map(ccx)),\n                                             C_array(T_int(), subcrates)]));\n+    subcrates += [C_int(ccx, 0)];\n+    let mapname;\n+    if ccx.sess.get_opts().library {\n+        mapname = ccx.link_meta.name;\n+    } else { mapname = \"toplevel\"; }\n+    let sym_name = \"_rust_crate_map_\" + mapname;\n+    let arrtype = T_array(ccx.int_type, std::vec::len::<ValueRef>(subcrates));\n+    let maptype = T_struct([ccx.int_type, arrtype]);\n+    let map =\n+        str::as_buf(sym_name,\n+                    {|buf| llvm::LLVMAddGlobal(ccx.llmod, maptype, buf) });\n+    llvm::LLVMSetLinkage(map,\n+                         lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n+    llvm::LLVMSetInitializer(map,\n+                             C_struct([p2i(create_module_map(ccx)),\n+                                       C_array(ccx.int_type, subcrates)]));\n+    ret map;\n+>>>>>>> work on making the size of ints depend on the target arch\n }\n \n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n@@ -6090,7 +6112,7 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n \n // Writes the current ABI version into the crate.\n fn write_abi_version(ccx: @crate_ctxt) {\n-    shape::mk_global(ccx, \"rust_abi_version\", C_uint(abi::abi_version),\n+    shape::mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }\n \n@@ -6110,8 +6132,12 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     let td = mk_target_data(sess.get_targ_cfg().target_strs.data_layout);\n     let tn = mk_type_names();\n     let intrinsics = declare_intrinsics(llmod);\n-    let task_type = T_task();\n-    let tydesc_type = T_tydesc();\n+    let int_type = T_int(sess.get_targ_cfg().arch);\n+    let float_type = T_float(sess.get_targ_cfg().arch);\n+    let task_type = T_task(sess.get_targ_cfg().arch);\n+    let taskptr_type = T_ptr(task_type);\n+    tn.associate(\"taskptr\", taskptr_type);\n+    let tydesc_type = T_tydesc(taskptr_type);\n     tn.associate(\"tydesc\", tydesc_type);\n     let hasher = ty::hash_ty;\n     let eqer = ty::eq_ty;\n@@ -6161,6 +6187,8 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n               upcall::declare_upcalls(tn, tydesc_type, llmod),\n           rust_object_type: T_rust_object(),\n           tydesc_type: tydesc_type,\n+          int_type: int_type,\n+          float_type: float_type,\n           task_type: task_type,\n           builder: BuilderRef_res(llvm::LLVMCreateBuilder()),\n           shape_cx: shape::mk_ctxt(llmod),"}, {"sha": "68cf33398ed2ccd6c3b41726705258664f02bf57", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2521cda1ec5e24cce81e25fcf64281584fcfdb5d/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2521cda1ec5e24cce81e25fcf64281584fcfdb5d/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "patch": "@@ -306,7 +306,7 @@ fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n     if cx.unreachable {\n         let ty = val_ty(PointerVal);\n         let eltty = if llvm::LLVMGetTypeKind(ty) == 11 {\n-            llvm::LLVMGetElementType(ty) } else { T_int(ccx) };\n+            llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n         ret llvm::LLVMGetUndef(eltty);\n     }\n     ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n@@ -492,7 +492,7 @@ fn _UndefReturn(cx: @block_ctxt, Fn: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n     let ty = val_ty(Fn);\n     let retty = if llvm::LLVMGetTypeKind(ty) == 8 {\n-        llvm::LLVMGetReturnType(ty) } else { T_int(ccx) };\n+        llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n     ret llvm::LLVMGetUndef(retty);\n }\n \n@@ -577,7 +577,7 @@ fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n \n fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_int(ccx)); }\n+    if cx.unreachable { ret llvm::LLVMGetUndef(ccx.int_type); }\n     ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n "}, {"sha": "0121b848a4c67440976bf4533c44dd3de05d88a0", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2521cda1ec5e24cce81e25fcf64281584fcfdb5d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2521cda1ec5e24cce81e25fcf64281584fcfdb5d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "patch": "@@ -120,6 +120,8 @@ type crate_ctxt =\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,\n      tydesc_type: TypeRef,\n+     int_type: TypeRef,\n+     float_type: TypeRef,\n      task_type: TypeRef,\n      builder: BuilderRef_res,\n      shape_cx: shape::ctxt,\n@@ -488,16 +490,16 @@ fn T_f64() -> TypeRef { ret llvm::LLVMDoubleType(); }\n \n fn T_bool() -> TypeRef { ret T_i1(); }\n \n-fn T_int(cx: @crate_ctxt) -> TypeRef {\n-    ret alt cx.sess.get_targ_cfg().arch {\n+fn T_int(arch: session::arch) -> TypeRef {\n+    ret alt arch {\n       arch_x86 { T_i32() }\n       arch_x86_64 { T_i64() }\n       arch_arm { T_i32() }\n     };\n }\n \n-fn T_float(cx: @crate_ctxt) -> TypeRef {\n-    ret alt cx.sess.get_targ_cfg().arch {\n+fn T_float(arch: session::arch) -> TypeRef {\n+    ret alt arch {\n       arch_x86 { T_f64() }\n       arch_x86_64 { T_f64() }\n       arch_arm { T_f64() }\n@@ -507,7 +509,7 @@ fn T_float(cx: @crate_ctxt) -> TypeRef {\n fn T_char() -> TypeRef { ret T_i32(); }\n \n fn T_size_t(cx: @crate_ctxt) -> TypeRef {\n-    ret T_int(cx);\n+    ret cx.int_type;\n }\n \n fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n@@ -551,7 +553,7 @@ fn T_rust_object() -> TypeRef {\n     ret t;\n }\n \n-fn T_task(cx: @crate_ctxt) -> TypeRef {\n+fn T_task(arch: session::arch) -> TypeRef {\n     let t = T_named_struct(\"task\");\n \n     // Refcount\n@@ -565,9 +567,10 @@ fn T_task(cx: @crate_ctxt) -> TypeRef {\n     // Domain pointer\n     // Crate cache pointer\n \n+    let t_int = T_int(arch);\n     let elems =\n-        [T_int(cx), T_int(cx), T_int(cx), T_int(cx),\n-         T_int(cx), T_int(cx), T_int(cx), T_int(cx)];\n+        [t_int, t_int, t_int, t_int,\n+         t_int, t_int, t_int, t_int];\n     set_struct_body(t, elems);\n     ret t;\n }\n@@ -612,9 +615,10 @@ fn T_tydesc(cx: @crate_ctxt) -> TypeRef {\n                     pvoid, pvoid, T_i8()], T_void()));\n \n     let elems =\n-        [tydescpp, T_int(cx), T_int(cx), glue_fn_ty, glue_fn_ty, glue_fn_ty,\n+        [tydescpp, cx.int_type, cx.int_type,\n+         glue_fn_ty, glue_fn_ty, glue_fn_ty,\n          T_ptr(T_i8()), glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty,\n-         T_ptr(T_i8()), T_ptr(T_i8()), T_int(cx), T_int(cx)];\n+         T_ptr(T_i8()), T_ptr(T_i8()), cx.int_type, cx.int_type];\n     set_struct_body(tydesc, elems);\n     ret tydesc;\n }\n@@ -626,25 +630,25 @@ fn T_array(t: TypeRef, n: uint) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n //\n // TODO: Support user-defined vector sizes.\n fn T_vec(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(cx), // fill\n-                  T_int(cx), // alloc\n+    ret T_struct([cx.int_type, // fill\n+                  cx.int_type, // alloc\n                   T_array(t, 0u)]); // elements\n }\n \n // Note that the size of this one is in bytes.\n fn T_opaque_vec(cx: @crate_ctxt) -> TypeRef { ret T_vec(cx, T_i8()); }\n \n fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(cx), t]);\n+    ret T_struct([cx.int_type, t]);\n }\n \n fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(cx)]); // Refcount\n+    ret T_struct([cx.int_type]); // Refcount\n \n }\n \n fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(cx)]); // Refcount\n+    ret T_struct([cx.int_type]); // Refcount\n \n }\n \n@@ -684,16 +688,16 @@ fn T_tag(cx: @crate_ctxt, size: uint) -> TypeRef {\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t =\n         if size == 0u {\n-            T_struct([T_int(cx)])\n-        } else { T_struct([T_int(cx), T_array(T_i8(), size)]) };\n+            T_struct([cx.int_type])\n+        } else { T_struct([cx.int_type, T_array(T_i8(), size)]) };\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_opaque_tag(cx: @crate_ctxt) -> TypeRef {\n     let s = \"opaque_tag\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n-    let t = T_struct([T_int(cx), T_i8()]);\n+    let t = T_struct([cx.int_type, T_i8()]);\n     cx.tn.associate(s, t);\n     ret t;\n }\n@@ -731,15 +735,15 @@ fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n     // FIXME: We can't use LLVM::ULongLong with our existing minimal native\n     // API, which only knows word-sized args.\n     //\n-    // ret llvm::LLVMConstInt(T_int(), t as LLVM::ULongLong, False);\n+    // ret llvm::LLVMConstInt(.int_type, t as LLVM::ULongLong, False);\n     //\n \n     ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n fn C_float(cx: @crate_ctxt, s: str) -> ValueRef {\n     ret str::as_buf(s, {|buf|\n-        llvm::LLVMConstRealOfString(T_float(cx), buf)\n+        llvm::LLVMConstRealOfString(cx.float_type, buf)\n     });\n }\n \n@@ -760,11 +764,11 @@ fn C_bool(b: bool) -> ValueRef {\n }\n \n fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n-    ret C_integral(T_int(cx), i as uint, True);\n+    ret C_integral(cx.int_type, i as uint, True);\n }\n \n fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n-    ret C_integral(T_int(cx), i, False);\n+    ret C_integral(cx.int_type, i, False);\n }\n \n fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }"}]}