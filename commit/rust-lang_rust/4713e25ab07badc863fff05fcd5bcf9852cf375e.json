{"sha": "4713e25ab07badc863fff05fcd5bcf9852cf375e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MTNlMjVhYjA3YmFkYzg2M2ZmZjA1ZmNkNWJjZjk4NTJjZjM3NWU=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-13T13:30:01Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-05-13T01:51:19Z"}, "message": "Cleanup of `while_let_on_iterator`", "tree": {"sha": "703b5ed9d8c38988e9783b97980572622d675cda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/703b5ed9d8c38988e9783b97980572622d675cda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4713e25ab07badc863fff05fcd5bcf9852cf375e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmCchhgACgkQ2lnoZDo37QZPSgD+MkSg65UUkb5/FmlxsPJFwRcc\nPjNisifLIXLC5e7HKXwA/A8Nli+zxofBKfbFLbThK4Adgua/3tGt1nHDeL2NGlgE\n=bjKa\n-----END PGP SIGNATURE-----", "payload": "tree 703b5ed9d8c38988e9783b97980572622d675cda\nparent daca50a515f28218142d9945ca714f7420b4fc75\nauthor Jason Newcomb <jsnewcomb@pm.me> 1618320601 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1620870679 -0400\n\nCleanup of `while_let_on_iterator`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4713e25ab07badc863fff05fcd5bcf9852cf375e", "html_url": "https://github.com/rust-lang/rust/commit/4713e25ab07badc863fff05fcd5bcf9852cf375e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4713e25ab07badc863fff05fcd5bcf9852cf375e/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daca50a515f28218142d9945ca714f7420b4fc75", "url": "https://api.github.com/repos/rust-lang/rust/commits/daca50a515f28218142d9945ca714f7420b4fc75", "html_url": "https://github.com/rust-lang/rust/commit/daca50a515f28218142d9945ca714f7420b4fc75"}], "stats": {"total": 146, "additions": 80, "deletions": 66}, "files": [{"sha": "63560047578a16aa0c39f8996745dbd02ab6c246", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/4713e25ab07badc863fff05fcd5bcf9852cf375e/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4713e25ab07badc863fff05fcd5bcf9852cf375e/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=4713e25ab07badc863fff05fcd5bcf9852cf375e", "patch": "@@ -2,73 +2,65 @@ use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{get_enclosing_loop, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used};\n+use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Node, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Match(scrutinee_expr, [arm, _], MatchSource::WhileLetDesugar) = expr.kind {\n-        let some_pat = match arm.pat.kind {\n-            PatKind::TupleStruct(QPath::Resolved(None, path), sub_pats, _) => match path.res {\n-                Res::Def(_, id) if match_def_path(cx, id, &paths::OPTION_SOME) => sub_pats.first(),\n-                _ => return,\n-            },\n-            _ => return,\n-        };\n-\n-        let iter_expr = match scrutinee_expr.kind {\n-            ExprKind::MethodCall(name, _, [iter_expr], _)\n-                if name.ident.name == sym::next && is_trait_method(cx, scrutinee_expr, sym::Iterator) =>\n-            {\n-                if let Some(iter_expr) = try_parse_iter_expr(cx, iter_expr) {\n-                    iter_expr\n-                } else {\n-                    return;\n-                }\n-            }\n-            _ => return,\n-        };\n-\n-        // Needed to find an outer loop, if there are any.\n-        let loop_expr = if let Some((_, Node::Expr(e))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1) {\n-            e\n+    let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n+        if let ExprKind::Match(scrutinee_expr, [arm, _], MatchSource::WhileLetDesugar) = expr.kind;\n+        // check for `Some(..)` pattern\n+        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = arm.pat.kind;\n+        if let Res::Def(_, pat_did) = pat_path.res;\n+        if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n+        // check for call to `Iterator::next`\n+        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = scrutinee_expr.kind;\n+        if method_name.ident.name == sym::next;\n+        if is_trait_method(cx, scrutinee_expr, sym::Iterator);\n+        if let Some(iter_expr) = try_parse_iter_expr(cx, iter_expr);\n+        // get the loop containing the match expression\n+        if let Some((_, Node::Expr(loop_expr))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n+        if !uses_iter(cx, &iter_expr, arm.body);\n+        then {\n+            (scrutinee_expr, iter_expr, some_pat, loop_expr)\n         } else {\n             return;\n-        };\n+        }\n+    };\n \n-        // Refutable patterns don't work with for loops.\n-        // The iterator also can't be accessed withing the loop.\n-        if some_pat.map_or(true, |p| is_refutable(cx, p)) || uses_iter(cx, &iter_expr, arm.body) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let loop_var = if let Some(some_pat) = some_pat.first() {\n+        if is_refutable(cx, some_pat) {\n+            // Refutable patterns don't work with for loops.\n             return;\n         }\n+        snippet_with_applicability(cx, some_pat.span, \"..\", &mut applicability)\n+    } else {\n+        \"_\".into()\n+    };\n \n-        // If the iterator is a field or the iterator is accessed after the loop is complete it needs to be\n-        // borrowed mutably.\n-        // TODO: If the struct can be partially moved from and the struct isn't used afterwards a mutable\n-        // borrow of a field isn't necessary.\n-        let ref_mut = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n-            \"&mut \"\n-        } else {\n-            \"\"\n-        };\n-        let mut applicability = Applicability::MachineApplicable;\n-        let iterator = snippet_with_applicability(cx, iter_expr.span, \"_\", &mut applicability);\n-        let loop_var = some_pat.map_or_else(\n-            || \"_\".into(),\n-            |pat| snippet_with_applicability(cx, pat.span, \"_\", &mut applicability).into_owned(),\n-        );\n-        span_lint_and_sugg(\n-            cx,\n-            WHILE_LET_ON_ITERATOR,\n-            expr.span.with_hi(scrutinee_expr.span.hi()),\n-            \"this loop could be written as a `for` loop\",\n-            \"try\",\n-            format!(\"for {} in {}{}\", loop_var, ref_mut, iterator),\n-            applicability,\n-        );\n-    }\n+    // If the iterator is a field or the iterator is accessed after the loop is complete it needs to be\n+    // borrowed mutably. TODO: If the struct can be partially moved from and the struct isn't used\n+    // afterwards a mutable borrow of a field isn't necessary.\n+    let ref_mut = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n+        \"&mut \"\n+    } else {\n+        \"\"\n+    };\n+\n+    let iterator = snippet_with_applicability(cx, iter_expr.span, \"_\", &mut applicability);\n+    span_lint_and_sugg(\n+        cx,\n+        WHILE_LET_ON_ITERATOR,\n+        expr.span.with_hi(scrutinee_expr.span.hi()),\n+        \"this loop could be written as a `for` loop\",\n+        \"try\",\n+        format!(\"for {} in {}{}\", loop_var, ref_mut, iterator),\n+        applicability,\n+    );\n }\n \n #[derive(Debug)]\n@@ -135,8 +127,10 @@ fn is_expr_same_field(cx: &LateContext<'_>, mut e: &Expr<'_>, mut fields: &[Symb\n     }\n }\n \n-/// Checks if the given expression is the same field as, is a child of, of the parent of the given\n-/// field. Used to check if the expression can be used while the given field is borrowed.\n+/// Checks if the given expression is the same field as, is a child of, or is the parent of the\n+/// given field. Used to check if the expression can be used while the given field is borrowed\n+/// mutably. e.g. if checking for `x.y`, then `x.y`, `x.y.z`, and `x` will all return true, but\n+/// `x.z`, and `y` will return false.\n fn is_expr_same_child_or_parent_field(cx: &LateContext<'_>, expr: &Expr<'_>, fields: &[Symbol], path_res: Res) -> bool {\n     match expr.kind {\n         ExprKind::Field(base, name) => {\n@@ -166,7 +160,7 @@ fn is_expr_same_child_or_parent_field(cx: &LateContext<'_>, expr: &Expr<'_>, fie\n                 }\n             }\n         },\n-        // If the path matches, this is either an exact match, of the expression is a parent of the field.\n+        // If the path matches, this is either an exact match, or the expression is a parent of the field.\n         ExprKind::Path(ref path) => cx.qpath_res(path, expr.hir_id) == path_res,\n         ExprKind::DropTemps(base) | ExprKind::Type(base, _) | ExprKind::AddrOf(_, _, base) => {\n             is_expr_same_child_or_parent_field(cx, base, fields, path_res)\n@@ -175,8 +169,8 @@ fn is_expr_same_child_or_parent_field(cx: &LateContext<'_>, expr: &Expr<'_>, fie\n     }\n }\n \n-/// Strips off all field and path expressions. Used to skip them after failing to check for\n-/// equality.\n+/// Strips off all field and path expressions. This will return true if a field or path has been\n+/// skipped. Used to skip them after failing to check for equality.\n fn skip_fields_and_path(expr: &'tcx Expr<'_>) -> (Option<&'tcx Expr<'tcx>>, bool) {\n     let mut e = expr;\n     let e = loop {\n@@ -257,7 +251,7 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n                         self.visit_expr(e);\n                     }\n                 } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n-                    self.used_iter |= is_res_used(self.cx, self.iter_expr.path, id);\n+                    self.used_iter = is_res_used(self.cx, self.iter_expr.path, id);\n                 } else {\n                     walk_expr(self, e);\n                 }\n@@ -309,7 +303,7 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n                         self.visit_expr(e);\n                     }\n                 } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n-                    self.used_after |= is_res_used(self.cx, self.iter_expr.path, id);\n+                    self.used_after = is_res_used(self.cx, self.iter_expr.path, id);\n                 } else {\n                     walk_expr(self, e);\n                 }"}, {"sha": "ecdc666b5f690a63ed7aa132a640f7b78361328f", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4713e25ab07badc863fff05fcd5bcf9852cf375e/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4713e25ab07badc863fff05fcd5bcf9852cf375e/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=4713e25ab07badc863fff05fcd5bcf9852cf375e", "patch": "@@ -241,7 +241,7 @@ pub fn visit_break_exprs<'tcx>(\n     node.visit(&mut V(f));\n }\n \n-/// Checks if the given resolved path is used the body.\n+/// Checks if the given resolved path is used in the given body.\n pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n     struct V<'a, 'tcx> {\n         cx: &'a LateContext<'tcx>,"}, {"sha": "389297eff0c4783daadcd6630b9d2d84a70b924e", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4713e25ab07badc863fff05fcd5bcf9852cf375e/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4713e25ab07badc863fff05fcd5bcf9852cf375e/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=4713e25ab07badc863fff05fcd5bcf9852cf375e", "patch": "@@ -288,6 +288,8 @@ fn issue1924() {\n             for i in &mut self.0.0.0 {\n                 if i == 1 {\n                     return self.0.1.take();\n+                } else {\n+                    self.0.1 = Some(i);\n                 }\n             }\n             None\n@@ -320,4 +322,9 @@ fn issue1924() {\n     println!(\"iterator field {}\", it.1);\n }\n \n-fn main() {}\n+fn main() {\n+    let mut it = 0..20;\n+    for _ in it {\n+        println!(\"test\");\n+    }\n+}"}, {"sha": "df932724a0d0001f67f58af8618030acfe3ff562", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4713e25ab07badc863fff05fcd5bcf9852cf375e/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4713e25ab07badc863fff05fcd5bcf9852cf375e/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=4713e25ab07badc863fff05fcd5bcf9852cf375e", "patch": "@@ -288,6 +288,8 @@ fn issue1924() {\n             while let Some(i) = self.0.0.0.next() {\n                 if i == 1 {\n                     return self.0.1.take();\n+                } else {\n+                    self.0.1 = Some(i);\n                 }\n             }\n             None\n@@ -320,4 +322,9 @@ fn issue1924() {\n     println!(\"iterator field {}\", it.1);\n }\n \n-fn main() {}\n+fn main() {\n+    let mut it = 0..20;\n+    while let Some(..) = it.next() {\n+        println!(\"test\");\n+    }\n+}"}, {"sha": "e8741f74981f8137ceb4604352538fbb777db3f1", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4713e25ab07badc863fff05fcd5bcf9852cf375e/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4713e25ab07badc863fff05fcd5bcf9852cf375e/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=4713e25ab07badc863fff05fcd5bcf9852cf375e", "patch": "@@ -99,10 +99,16 @@ LL |             while let Some(i) = self.0.0.0.next() {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in &mut self.0.0.0`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:315:5\n+  --> $DIR/while_let_on_iterator.rs:317:5\n    |\n LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in &mut it`\n \n-error: aborting due to 17 previous errors\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:327:5\n+   |\n+LL |     while let Some(..) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n+\n+error: aborting due to 18 previous errors\n "}]}