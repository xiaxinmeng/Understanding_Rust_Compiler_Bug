{"sha": "d86608205069aed5c78bcc38dd26bcf4213e23a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NjYwODIwNTA2OWFlZDVjNzhiY2MzOGRkMjZiY2Y0MjEzZTIzYTA=", "commit": {"author": {"name": "Emerentius", "email": "emerentius@arcor.de", "date": "2018-04-30T11:09:10Z"}, "committer": {"name": "Emerentius", "email": "emerentius@arcor.de", "date": "2018-06-01T15:13:24Z"}, "message": "optimize joining and concatenation for slices\n\nfor both Vec<T> and String\n- eliminates the boolean first flag in fn join()\n\nfor String only\n- eliminates repeated bounds checks in join(), concat()\n- adds fast paths for small string separators up to a len of 4 bytes", "tree": {"sha": "a507533a3d32c660c91d1f1d263a96f006dcdfc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a507533a3d32c660c91d1f1d263a96f006dcdfc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d86608205069aed5c78bcc38dd26bcf4213e23a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d86608205069aed5c78bcc38dd26bcf4213e23a0", "html_url": "https://github.com/rust-lang/rust/commit/d86608205069aed5c78bcc38dd26bcf4213e23a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d86608205069aed5c78bcc38dd26bcf4213e23a0/comments", "author": {"login": "Emerentius", "id": 9992929, "node_id": "MDQ6VXNlcjk5OTI5Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/9992929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emerentius", "html_url": "https://github.com/Emerentius", "followers_url": "https://api.github.com/users/Emerentius/followers", "following_url": "https://api.github.com/users/Emerentius/following{/other_user}", "gists_url": "https://api.github.com/users/Emerentius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emerentius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emerentius/subscriptions", "organizations_url": "https://api.github.com/users/Emerentius/orgs", "repos_url": "https://api.github.com/users/Emerentius/repos", "events_url": "https://api.github.com/users/Emerentius/events{/privacy}", "received_events_url": "https://api.github.com/users/Emerentius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Emerentius", "id": 9992929, "node_id": "MDQ6VXNlcjk5OTI5Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/9992929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emerentius", "html_url": "https://github.com/Emerentius", "followers_url": "https://api.github.com/users/Emerentius/followers", "following_url": "https://api.github.com/users/Emerentius/following{/other_user}", "gists_url": "https://api.github.com/users/Emerentius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emerentius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emerentius/subscriptions", "organizations_url": "https://api.github.com/users/Emerentius/orgs", "repos_url": "https://api.github.com/users/Emerentius/repos", "events_url": "https://api.github.com/users/Emerentius/events{/privacy}", "received_events_url": "https://api.github.com/users/Emerentius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "577a5b2703d97e5408664e409f35768944360fea", "url": "https://api.github.com/repos/rust-lang/rust/commits/577a5b2703d97e5408664e409f35768944360fea", "html_url": "https://github.com/rust-lang/rust/commit/577a5b2703d97e5408664e409f35768944360fea"}], "stats": {"total": 160, "additions": 113, "deletions": 47}, "files": [{"sha": "82578c3206f7c4e5766faaee575a5a2653bf4cb8", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d86608205069aed5c78bcc38dd26bcf4213e23a0/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86608205069aed5c78bcc38dd26bcf4213e23a0/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=d86608205069aed5c78bcc38dd26bcf4213e23a0", "patch": "@@ -566,18 +566,18 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n     }\n \n     fn join(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n-        let mut result = Vec::with_capacity(size + self.len());\n-        let mut first = true;\n-        for v in self {\n-            if first {\n-                first = false\n-            } else {\n-                result.push(sep.clone())\n+        let mut iter = self.iter();\n+        iter.next().map_or(vec![], |first| {\n+            let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n+            let mut result = Vec::with_capacity(size + self.len());\n+            result.extend_from_slice(first.borrow());\n+\n+            for v in iter {\n+                result.push(sep.clone());\n+                result.extend_from_slice(v.borrow())\n             }\n-            result.extend_from_slice(v.borrow())\n-        }\n-        result\n+            result\n+        })\n     }\n \n     fn connect(&self, sep: &T) -> Vec<T> {"}, {"sha": "45daabf86abdb7c5343f88cd8da07d6558f54be8", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 102, "deletions": 36, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/d86608205069aed5c78bcc38dd26bcf4213e23a0/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86608205069aed5c78bcc38dd26bcf4213e23a0/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=d86608205069aed5c78bcc38dd26bcf4213e23a0", "patch": "@@ -86,52 +86,118 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n     type Output = String;\n \n     fn concat(&self) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.borrow().len()).sum();\n-        let mut result = String::with_capacity(len);\n-\n-        for s in self {\n-            result.push_str(s.borrow())\n-        }\n-\n-        result\n+        self.join(\"\")\n     }\n \n     fn join(&self, sep: &str) -> String {\n-        if self.is_empty() {\n-            return String::new();\n+        unsafe {\n+            String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n         }\n+    }\n \n-        // concat is faster\n-        if sep.is_empty() {\n-            return self.concat();\n-        }\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n+    }\n+}\n \n-        // this is wrong without the guarantee that `self` is non-empty\n-        // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1) +\n-                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n-        let mut result = String::with_capacity(len);\n-        let mut first = true;\n+macro_rules! spezialize_for_lengths {\n+    ($separator:expr, $target:expr, $iter:expr; $($num:expr),*) => {\n+        let mut target = $target;\n+        let iter = $iter;\n+        let sep_len = $separator.len();\n+        let sep_bytes = $separator;\n+        match $separator.len() {\n+            $(\n+                // loops with hardcoded sizes run much faster\n+                // specialize the cases with small separator lengths\n+                $num => {\n+                    for s in iter {\n+                        target.get_unchecked_mut(..$num)\n+                            .copy_from_slice(sep_bytes);\n+\n+                        let s_bytes = s.borrow().as_ref();\n+                        let offset = s_bytes.len();\n+                        target = {target}.get_unchecked_mut($num..);\n+                        target.get_unchecked_mut(..offset)\n+                            .copy_from_slice(s_bytes);\n+                        target = {target}.get_unchecked_mut(offset..);\n+                    }\n+                },\n+            )*\n+            0 => {\n+                // concat, same principle without the separator\n+                for s in iter {\n+                    let s_bytes = s.borrow().as_ref();\n+                    let offset = s_bytes.len();\n+                    target.get_unchecked_mut(..offset)\n+                        .copy_from_slice(s_bytes);\n+                    target = {target}.get_unchecked_mut(offset..);\n+                }\n+            },\n+            _ => {\n+                // arbitrary non-zero size fallback\n+                for s in iter {\n+                    target.get_unchecked_mut(..sep_len)\n+                        .copy_from_slice(sep_bytes);\n+\n+                    let s_bytes = s.borrow().as_ref();\n+                    let offset = s_bytes.len();\n+                    target = {target}.get_unchecked_mut(sep_len..);\n+                    target.get_unchecked_mut(..offset)\n+                        .copy_from_slice(s_bytes);\n+                    target = {target}.get_unchecked_mut(offset..);\n+                }\n+            }\n+        }\n+    };\n+}\n \n-        for s in self {\n-            if first {\n-                first = false;\n-            } else {\n-                result.push_str(sep);\n+// Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n+// Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n+// For this reason SliceConcatExt<T> is not specialized for T: Copy and SliceConcatExt<str> is the\n+// only user of this function. It is left in place for the time when that is fixed.\n+//\n+// the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>\n+// [T] and str both impl AsRef<[T]> for some T\n+// => s.borrow().as_ref() and we always have slices\n+fn join_generic_copy<B, T, S>(slice: &[S], sep: &[T]) -> Vec<T>\n+where\n+    T: Copy,\n+    B: AsRef<[T]> + ?Sized,\n+    S: Borrow<B>,\n+{\n+    let sep_len = sep.len();\n+    let mut iter = slice.iter();\n+    iter.next().map_or(vec![], |first| {\n+        // this is wrong without the guarantee that `slice` is non-empty\n+        // if the `len` calculation overflows, we'll panic\n+        // we would have run out of memory anyway and the rest of the function requires\n+        // the entire String pre-allocated for safety\n+        //\n+        // this is the exact len of the resulting String\n+        let len =  sep_len.checked_mul(slice.len() - 1).and_then(|n| {\n+            slice.iter().map(|s| s.borrow().as_ref().len()).try_fold(n, usize::checked_add)\n+        }).expect(\"attempt to join into collection with len > usize::MAX\");\n+\n+        // crucial for safety\n+        let mut result = Vec::with_capacity(len);\n+\n+        unsafe {\n+            result.extend_from_slice(first.borrow().as_ref());\n+\n+            {\n+                let pos = result.len();\n+                let target = result.get_unchecked_mut(pos..len);\n+\n+                // copy separator and strs over without bounds checks\n+                // generate loops with hardcoded offsets for small separators\n+                // massive improvements possible (~ x2)\n+                spezialize_for_lengths!(sep, target, iter; 1, 2, 3, 4);\n             }\n-            result.push_str(s.borrow());\n+            result.set_len(len);\n         }\n         result\n-    }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n+    })\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}