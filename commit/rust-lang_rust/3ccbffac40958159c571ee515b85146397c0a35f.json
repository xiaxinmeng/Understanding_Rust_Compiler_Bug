{"sha": "3ccbffac40958159c571ee515b85146397c0a35f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjY2JmZmFjNDA5NTgxNTljNTcxZWU1MTViODUxNDYzOTdjMGEzNWY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-04-03T15:43:57Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-04-03T15:46:22Z"}, "message": "After a hash mismatch error, emit file-system paths of crates involved.\n\nFix #13266.\n\nThere is a little bit of acrobatics in the definition of `crate_paths`\nto avoid calling `clone()` on the dylib/rlib unless we actually are\ngoing to need them.\n\nThe other oddity is that I have replaced the `root_ident: Option<&str>`\nparameter with a `root: &Option<CratePaths>`, which may surprise one\nwho was expecting to see something like: `root: Option<&CratePaths>`.\nI went with the approach here because I could not come up with code for\nthe alternative that was acceptable to the borrow checker.", "tree": {"sha": "a08badc7e48e08b130fcb5877b0c120b8edd7c61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a08badc7e48e08b130fcb5877b0c120b8edd7c61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ccbffac40958159c571ee515b85146397c0a35f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccbffac40958159c571ee515b85146397c0a35f", "html_url": "https://github.com/rust-lang/rust/commit/3ccbffac40958159c571ee515b85146397c0a35f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ccbffac40958159c571ee515b85146397c0a35f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bda3df6ff894e9b522ede02b15b6772c99e7362", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bda3df6ff894e9b522ede02b15b6772c99e7362", "html_url": "https://github.com/rust-lang/rust/commit/7bda3df6ff894e9b522ede02b15b6772c99e7362"}], "stats": {"total": 98, "additions": 70, "deletions": 28}, "files": [{"sha": "44f85bdb20f36e31c9595baae4cf8e3c483f5f31", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3ccbffac40958159c571ee515b85146397c0a35f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccbffac40958159c571ee515b85146397c0a35f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3ccbffac40958159c571ee515b85146397c0a35f", "patch": "@@ -21,6 +21,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::Os;\n+use metadata::loader::CratePaths;\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -141,7 +142,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n     match extract_crate_info(e, i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e, None, info.ident, &info.crate_id, None,\n+            let cnum = resolve_crate(e, &None, info.ident, &info.crate_id, None,\n                                      i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n@@ -278,13 +279,13 @@ fn existing_match(e: &Env, crate_id: &CrateId,\n     None\n }\n \n-fn resolve_crate(e: &mut Env,\n-                 root_ident: Option<&str>,\n-                 ident: &str,\n-                 crate_id: &CrateId,\n-                 hash: Option<&Svh>,\n-                 span: Span)\n-              -> ast::CrateNum {\n+fn resolve_crate<'a>(e: &mut Env,\n+                     root: &Option<CratePaths>,\n+                     ident: &str,\n+                     crate_id: &CrateId,\n+                     hash: Option<&Svh>,\n+                     span: Span)\n+                     -> ast::CrateNum {\n     match existing_match(e, crate_id, hash) {\n         None => {\n             let id_hash = link::crate_id_hash(crate_id);\n@@ -297,11 +298,11 @@ fn resolve_crate(e: &mut Env,\n                 hash: hash.map(|a| &*a),\n                 os: e.os,\n                 intr: e.intr.clone(),\n-                rejected_via_hash: false,\n+                rejected_via_hash: None,\n             };\n             let loader::Library {\n                 dylib, rlib, metadata\n-            } = load_ctxt.load_library_crate(root_ident);\n+            } = load_ctxt.load_library_crate(root);\n \n             let crate_id = decoder::get_crate_id(metadata.as_slice());\n             let hash = decoder::get_crate_hash(metadata.as_slice());\n@@ -316,15 +317,22 @@ fn resolve_crate(e: &mut Env,\n             });\n             e.next_crate_num += 1;\n \n-            // Maintain a reference to the top most crate.\n-            let root_crate = match root_ident {\n-                Some(c) => c,\n-                None => load_ctxt.ident.clone()\n+            // Stash paths for top-most crate locally if necessary.\n+            let crate_paths = if root.is_none() {\n+                Some(CratePaths {\n+                    ident: load_ctxt.ident.to_owned(),\n+                    dylib: dylib.clone(),\n+                    rlib:  rlib.clone(),\n+                })\n+            } else {\n+                None\n             };\n+            // Maintain a reference to the top most crate.\n+            let root = if root.is_some() { root } else { &crate_paths };\n \n             // Now resolve the crates referenced by this crate\n             let cnum_map = resolve_crate_deps(e,\n-            Some(root_crate),\n+            root,\n             metadata.as_slice(),\n             span);\n \n@@ -349,7 +357,7 @@ fn resolve_crate(e: &mut Env,\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: &mut Env,\n-                      root_ident: Option<&str>,\n+                      root: &Option<CratePaths>,\n                       cdata: &[u8], span : Span)\n                    -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n@@ -360,7 +368,7 @@ fn resolve_crate_deps(e: &mut Env,\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n-        let local_cnum = resolve_crate(e, root_ident,\n+        let local_cnum = resolve_crate(e, root,\n                                        dep.crate_id.name.as_slice(),\n                                        &dep.crate_id,\n                                        Some(&dep.hash),\n@@ -393,7 +401,7 @@ impl<'a> Loader<'a> {\n impl<'a> CrateLoader for Loader<'a> {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n-        let cnum = resolve_crate(&mut self.env, None, info.ident,\n+        let cnum = resolve_crate(&mut self.env, &None, info.ident,\n                                  &info.crate_id, None, krate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {"}, {"sha": "caa2c6c01337f8bae5e40fa37d561b1b3775a0dd", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3ccbffac40958159c571ee515b85146397c0a35f/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccbffac40958159c571ee515b85146397c0a35f/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3ccbffac40958159c571ee515b85146397c0a35f", "patch": "@@ -45,6 +45,10 @@ pub enum Os {\n     OsFreebsd\n }\n \n+pub struct ViaHash {\n+    path: Path,\n+}\n+\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n@@ -54,7 +58,8 @@ pub struct Context<'a> {\n     pub hash: Option<&'a Svh>,\n     pub os: Os,\n     pub intr: Rc<IdentInterner>,\n-    pub rejected_via_hash: bool,\n+    /// Some if rejected\n+    pub rejected_via_hash: Option<ViaHash>\n }\n \n pub struct Library {\n@@ -69,6 +74,25 @@ pub struct ArchiveMetadata {\n     data: &'static [u8],\n }\n \n+pub struct CratePaths {\n+    pub ident: ~str,\n+    pub dylib: Option<Path>,\n+    pub rlib: Option<Path>\n+}\n+\n+impl CratePaths {\n+    fn describe_paths(&self) -> ~str {\n+        match (&self.dylib, &self.rlib) {\n+            (&None,    &None)\n+                => ~\"\",\n+            (&Some(ref p), &None) | (&None, &Some(ref p))\n+                => format!(\"{}\", p.display()),\n+            (&Some(ref p1), &Some(ref p2))\n+                => format!(\"{}, {}\", p1.display(), p2.display()),\n+        }\n+    }\n+}\n+\n // FIXME(#11857) this should be a \"real\" realpath\n fn realpath(p: &Path) -> Path {\n     use std::os;\n@@ -82,26 +106,35 @@ fn realpath(p: &Path) -> Path {\n }\n \n impl<'a> Context<'a> {\n-    pub fn load_library_crate(&mut self, root_ident: Option<&str>) -> Library {\n+    pub fn load_library_crate(&mut self, root: &Option<CratePaths>) -> Library {\n         match self.find_library_crate() {\n             Some(t) => t,\n             None => {\n                 self.sess.abort_if_errors();\n-                let message = if self.rejected_via_hash {\n+                let message = if self.rejected_via_hash.is_some() {\n                     format!(\"found possibly newer version of crate `{}`\",\n                             self.ident)\n                 } else {\n                     format!(\"can't find crate for `{}`\", self.ident)\n                 };\n-                let message = match root_ident {\n-                    None => message,\n-                    Some(c) => format!(\"{} which `{}` depends on\", message, c),\n+                let message = match root {\n+                    &None => message,\n+                    &Some(ref r) => format!(\"{} which `{}` depends on\",\n+                                            message, r.ident)\n                 };\n                 self.sess.span_err(self.span, message);\n \n-                if self.rejected_via_hash {\n+                if self.rejected_via_hash.is_some() {\n                     self.sess.span_note(self.span, \"perhaps this crate needs \\\n                                                     to be recompiled?\");\n+                    self.rejected_via_hash.as_ref().map(\n+                        |r| self.sess.note(format!(\n+                            \"crate `{}` at path: {}\",\n+                            self.ident, r.path.display())));\n+                    root.as_ref().map(\n+                        |r| self.sess.note(format!(\n+                            \"crate `{}` at path(s): {}\",\n+                            r.ident, r.describe_paths())));\n                 }\n                 self.sess.abort_if_errors();\n                 unreachable!()\n@@ -291,7 +324,7 @@ impl<'a> Context<'a> {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.os, &lib) {\n                 Ok(blob) => {\n-                    if self.crate_matches(blob.as_slice()) {\n+                    if self.crate_matches(blob.as_slice(), &lib) {\n                         blob\n                     } else {\n                         info!(\"metadata mismatch\");\n@@ -326,7 +359,7 @@ impl<'a> Context<'a> {\n         return if error > 0 {None} else {ret}\n     }\n \n-    fn crate_matches(&mut self, crate_data: &[u8]) -> bool {\n+    fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n         match decoder::maybe_get_crate_id(crate_data) {\n             Some(ref id) if self.crate_id.matches(id) => {}\n             _ => return false\n@@ -338,7 +371,8 @@ impl<'a> Context<'a> {\n             None => true,\n             Some(myhash) => {\n                 if *myhash != hash {\n-                    self.rejected_via_hash = true;\n+                    self.rejected_via_hash =\n+                        Some(ViaHash{ path: libpath.clone(), });\n                     false\n                 } else {\n                     true"}]}