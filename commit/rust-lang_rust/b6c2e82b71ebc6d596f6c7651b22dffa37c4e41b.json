{"sha": "b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2YzJlODJiNzFlYmM2ZDU5NmY2Yzc2NTFiMjJkZmZhMzdjNGU0MWI=", "commit": {"author": {"name": "Michael Macias", "email": "zaeleus@gmail.com", "date": "2015-04-06T17:06:39Z"}, "committer": {"name": "Michael Macias", "email": "zaeleus@gmail.com", "date": "2015-04-06T18:02:41Z"}, "message": "rustdoc: Add a custom callback for codespan to collapse whitespace\n\nBecause the current style for `code` in rustdoc is to prewrap\nwhitespace, code spans that are hard wrapped in the source\ndocumentation are prematurely wrapped when rendered in HTML.\n\nCommonMark 0.18 [[1]] specifies \"interior spaces and line endings are\ncollapsed into single spaces\" for code spans, which would actually\nprevent this issue, but hoedown does not currently conform to the\nCommonMark spec.\n\nThe added span-level callback attempts to adhere to how whitespace is\nhandled as described by CommonMark, fixing the issue of early,\nunintentional wrapping of code spans in rendered HTML.\n\n[1]: http://spec.commonmark.org/0.18/", "tree": {"sha": "cb6843dff2b6c7bc09e68adc42f68aec5c9a12af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb6843dff2b6c7bc09e68adc42f68aec5c9a12af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b", "html_url": "https://github.com/rust-lang/rust/commit/b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b/comments", "author": {"login": "zaeleus", "id": 191331, "node_id": "MDQ6VXNlcjE5MTMzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/191331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zaeleus", "html_url": "https://github.com/zaeleus", "followers_url": "https://api.github.com/users/zaeleus/followers", "following_url": "https://api.github.com/users/zaeleus/following{/other_user}", "gists_url": "https://api.github.com/users/zaeleus/gists{/gist_id}", "starred_url": "https://api.github.com/users/zaeleus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zaeleus/subscriptions", "organizations_url": "https://api.github.com/users/zaeleus/orgs", "repos_url": "https://api.github.com/users/zaeleus/repos", "events_url": "https://api.github.com/users/zaeleus/events{/privacy}", "received_events_url": "https://api.github.com/users/zaeleus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zaeleus", "id": 191331, "node_id": "MDQ6VXNlcjE5MTMzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/191331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zaeleus", "html_url": "https://github.com/zaeleus", "followers_url": "https://api.github.com/users/zaeleus/followers", "following_url": "https://api.github.com/users/zaeleus/following{/other_user}", "gists_url": "https://api.github.com/users/zaeleus/gists{/gist_id}", "starred_url": "https://api.github.com/users/zaeleus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zaeleus/subscriptions", "organizations_url": "https://api.github.com/users/zaeleus/orgs", "repos_url": "https://api.github.com/users/zaeleus/repos", "events_url": "https://api.github.com/users/zaeleus/events{/privacy}", "received_events_url": "https://api.github.com/users/zaeleus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f37ba64e812713b273ad9818f05d852f6563b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f37ba64e812713b273ad9818f05d852f6563b87", "html_url": "https://github.com/rust-lang/rust/commit/9f37ba64e812713b273ad9818f05d852f6563b87"}], "stats": {"total": 62, "additions": 59, "deletions": 3}, "files": [{"sha": "4b267982f3b8d78a9ff2b9afaf35d16f68700b0f", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b6c2e82b71ebc6d596f6c7651b22dffa37c4e41b", "patch": "@@ -72,6 +72,9 @@ type blockcodefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n type headerfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                               libc::c_int, *mut libc::c_void);\n \n+type codespanfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                *mut libc::c_void);\n+\n type linkfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n                              *const hoedown_buffer, *const hoedown_buffer,\n                              *mut libc::c_void) -> libc::c_int;\n@@ -89,11 +92,12 @@ struct hoedown_renderer {\n     blockhtml: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                     *mut libc::c_void)>,\n     header: Option<headerfn>,\n-\n     other_block_level_callbacks: [libc::size_t; 9],\n \n     /* span level callbacks - NULL or return 0 prints the span verbatim */\n-    other_span_level_callbacks_1: [libc::size_t; 9],\n+    autolink: libc::size_t, // unused\n+    codespan: Option<codespanfn>,\n+    other_span_level_callbacks_1: [libc::size_t; 7],\n     link: Option<linkfn>,\n     other_span_level_callbacks_2: [libc::size_t; 5],\n     // hoedown will add `math` callback here, but we use an old version of it.\n@@ -185,6 +189,30 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n+/// Returns a new string with all consecutive whitespace collapsed into\n+/// single spaces.\n+///\n+/// The input is assumed to be already trimmed.\n+fn collapse_whitespace(s: &str) -> String {\n+    let mut buffer = String::with_capacity(s.len());\n+    let mut previous_char_is_whitespace = false;\n+\n+    for c in s.chars() {\n+        if c.is_whitespace() {\n+            if !previous_char_is_whitespace {\n+                buffer.push(' ');\n+            }\n+\n+            previous_char_is_whitespace = true;\n+        } else {\n+            buffer.push(c);\n+            previous_char_is_whitespace = false;\n+        }\n+    }\n+\n+    buffer\n+}\n+\n thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, usize>> = {\n     RefCell::new(HashMap::new())\n });\n@@ -299,6 +327,20 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n     reset_headers();\n \n+    extern fn codespan(ob: *mut hoedown_buffer, text: *const hoedown_buffer, _: *mut libc::c_void) {\n+        let content = if text.is_null() {\n+            \"\".to_string()\n+        } else {\n+            let bytes = unsafe { (*text).as_bytes() };\n+            let s = str::from_utf8(bytes).unwrap();\n+            collapse_whitespace(s)\n+        };\n+\n+        let content = format!(\"<code>{}</code>\", Escape(&content));\n+        let element = CString::new(content).unwrap();\n+        unsafe { hoedown_buffer_puts(ob, element.as_ptr()); }\n+    }\n+\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(0, 0);\n@@ -310,6 +352,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 = &mut opaque as *mut _ as *mut libc::c_void;\n         (*renderer).blockcode = Some(block);\n         (*renderer).header = Some(header);\n+        (*renderer).codespan = Some(codespan);\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n         hoedown_document_render(document, ob, s.as_ptr(),\n@@ -523,7 +566,7 @@ pub fn plain_summary_line(md: &str) -> String {\n #[cfg(test)]\n mod tests {\n     use super::{LangString, Markdown};\n-    use super::plain_summary_line;\n+    use super::{collapse_whitespace, plain_summary_line};\n \n     #[test]\n     fn test_lang_string_parse() {\n@@ -571,4 +614,17 @@ mod tests {\n         t(\"# top header\", \"top header\");\n         t(\"## header\", \"header\");\n     }\n+\n+    #[test]\n+    fn test_collapse_whitespace() {\n+        fn t(input: &str, expected: &str) {\n+            let actual = collapse_whitespace(input);\n+            assert_eq!(actual, expected);\n+        }\n+\n+        t(\"foo\", \"foo\");\n+        t(\"foo   bar\", \"foo bar\");\n+        t(\"foo  bar\\nbaz\", \"foo bar baz\");\n+        t(\"foo bar \\n   baz\\t\\tqux\", \"foo bar baz qux\");\n+    }\n }"}]}