{"sha": "512a328e2fb32bddd206461770a2c058368519cc", "node_id": "C_kwDOAAsO6NoAKDUxMmEzMjhlMmZiMzJiZGRkMjA2NDYxNzcwYTJjMDU4MzY4NTE5Y2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T10:37:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T10:37:48Z"}, "message": "Auto merge of #95309 - lcnr:dropck-cleanup, r=nikomatsakis\n\nrewrite `ensure_drop_params_and_item_params_correspond`\n\nactually relating types here seems like it's overkill", "tree": {"sha": "8aee71994d49d567e1f031a7beec8b7fc483f728", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aee71994d49d567e1f031a7beec8b7fc483f728"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/512a328e2fb32bddd206461770a2c058368519cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/512a328e2fb32bddd206461770a2c058368519cc", "html_url": "https://github.com/rust-lang/rust/commit/512a328e2fb32bddd206461770a2c058368519cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/512a328e2fb32bddd206461770a2c058368519cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd73afadae5b0163f9285f1b5edbbd1c84fde410", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd73afadae5b0163f9285f1b5edbbd1c84fde410", "html_url": "https://github.com/rust-lang/rust/commit/cd73afadae5b0163f9285f1b5edbbd1c84fde410"}, {"sha": "4a82bc9ea058a3f64e0ffb9f08ce3302a60a0990", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a82bc9ea058a3f64e0ffb9f08ce3302a60a0990", "html_url": "https://github.com/rust-lang/rust/commit/4a82bc9ea058a3f64e0ffb9f08ce3302a60a0990"}], "stats": {"total": 401, "additions": 178, "deletions": 223}, "files": [{"sha": "4ef6f240c480878b07fb48799add5399b1cd80c0", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -181,7 +181,7 @@ pub struct InferCtxtInner<'tcx> {\n     ///\n     /// Before running `resolve_regions_and_report_errors`, the creator\n     /// of the inference context is expected to invoke\n-    /// `process_region_obligations` (defined in `self::region_obligations`)\n+    /// [`InferCtxt::process_registered_region_obligations`]\n     /// for each body-id in this map, which will process the\n     /// obligations within. This is expected to be done 'late enough'\n     /// that all type inference variables have been bound and so forth."}, {"sha": "2aa535da0e54cf1b26996511150025bba05256d5", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -136,7 +136,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ///\n     /// # Parameters\n     ///\n-    /// - `region_bound_pairs`: the set of region bounds implied by\n+    /// - `region_bound_pairs_map`: the set of region bounds implied by\n     ///   the parameters and where-clauses. In particular, each pair\n     ///   `('a, K)` in this list tells us that the bounds in scope\n     ///   indicate that `K: 'a`, where `K` is either a generic\n@@ -147,12 +147,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// - `param_env` is the parameter environment for the enclosing function.\n     /// - `body_id` is the body-id whose region obligations are being\n     ///   processed.\n-    ///\n-    /// # Returns\n-    ///\n-    /// This function may have to perform normalizations, and hence it\n-    /// returns an `InferOk` with subobligations that must be\n-    /// processed.\n     #[instrument(level = \"debug\", skip(self, region_bound_pairs_map))]\n     pub fn process_registered_region_obligations(\n         &self,"}, {"sha": "809e7ce2e745b39f3e93dd1d29f7205eb22d6784", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 92, "deletions": 32, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -5,10 +5,7 @@ use crate::ty::fold::{FallibleTypeFolder, TypeFolder};\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use crate::ty::{\n-    self, DebruijnIndex, DefIdTree, EarlyBinder, List, ReEarlyBound, Ty, TyCtxt, TyKind::*,\n-    TypeFoldable,\n-};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n@@ -18,6 +15,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_index::bit_set::GrowableBitSet;\n use rustc_macros::HashStable;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n@@ -32,6 +30,19 @@ pub struct Discr<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+/// Used as an input to [`TyCtxt::uses_unique_generic_params`].\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum IgnoreRegions {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum NotUniqueParam<'tcx> {\n+    DuplicateParam(ty::GenericArg<'tcx>),\n+    NotParam(ty::GenericArg<'tcx>),\n+}\n+\n impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.ty.kind() {\n@@ -49,8 +60,8 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n \n fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n     let (int, signed) = match *ty.kind() {\n-        Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n-        Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n+        ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n+        ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n         _ => bug!(\"non integer discriminant\"),\n     };\n     (int.size(), signed)\n@@ -176,7 +187,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let ty::Adt(def, substs) = *ty.kind() {\n             for field in def.all_fields() {\n                 let field_ty = field.ty(self, substs);\n-                if let Error(_) = field_ty.kind() {\n+                if let ty::Error(_) = field_ty.kind() {\n                     return true;\n                 }\n             }\n@@ -311,7 +322,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (mut a, mut b) = (source, target);\n         loop {\n             match (&a.kind(), &b.kind()) {\n-                (&Adt(a_def, a_substs), &Adt(b_def, b_substs))\n+                (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n                     if a_def == b_def && a_def.is_struct() =>\n                 {\n                     if let Some(f) = a_def.non_enum_variant().fields.last() {\n@@ -321,7 +332,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 }\n-                (&Tuple(a_tys), &Tuple(b_tys)) if a_tys.len() == b_tys.len() => {\n+                (&ty::Tuple(a_tys), &ty::Tuple(b_tys)) if a_tys.len() == b_tys.len() => {\n                     if let Some(&a_last) = a_tys.last() {\n                         a = a_last;\n                         b = *b_tys.last().unwrap();\n@@ -427,7 +438,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             .filter(|&(_, k)| {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(region) => match region.kind() {\n-                        ReEarlyBound(ref ebr) => {\n+                        ty::ReEarlyBound(ref ebr) => {\n                             !impl_generics.region_param(ebr, self).pure_wrt_drop\n                         }\n                         // Error: not a region param\n@@ -453,6 +464,47 @@ impl<'tcx> TyCtxt<'tcx> {\n         result\n     }\n \n+    /// Checks whether each generic argument is simply a unique generic parameter.\n+    pub fn uses_unique_generic_params(\n+        self,\n+        substs: SubstsRef<'tcx>,\n+        ignore_regions: IgnoreRegions,\n+    ) -> Result<(), NotUniqueParam<'tcx>> {\n+        let mut seen = GrowableBitSet::default();\n+        for arg in substs {\n+            match arg.unpack() {\n+                GenericArgKind::Lifetime(lt) => {\n+                    if ignore_regions == IgnoreRegions::No {\n+                        let ty::ReEarlyBound(p) = lt.kind() else {\n+                            return Err(NotUniqueParam::NotParam(lt.into()))\n+                        };\n+                        if !seen.insert(p.index) {\n+                            return Err(NotUniqueParam::DuplicateParam(lt.into()));\n+                        }\n+                    }\n+                }\n+                GenericArgKind::Type(t) => match t.kind() {\n+                    ty::Param(p) => {\n+                        if !seen.insert(p.index) {\n+                            return Err(NotUniqueParam::DuplicateParam(t.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(t.into())),\n+                },\n+                GenericArgKind::Const(c) => match c.val() {\n+                    ty::ConstKind::Param(p) => {\n+                        if !seen.insert(p.index) {\n+                            return Err(NotUniqueParam::DuplicateParam(c.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(c.into())),\n+                },\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Returns `true` if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n     /// that closures have a `DefId`, but the closure *expression* also\n     /// has a `HirId` that is located within the context where the\n@@ -594,30 +646,33 @@ impl<'tcx> TyCtxt<'tcx> {\n         if visitor.found_recursion { Err(expanded_type) } else { Ok(expanded_type) }\n     }\n \n-    pub fn bound_type_of(self, def_id: DefId) -> EarlyBinder<Ty<'tcx>> {\n-        EarlyBinder(self.type_of(def_id))\n+    pub fn bound_type_of(self, def_id: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.type_of(def_id))\n     }\n \n-    pub fn bound_fn_sig(self, def_id: DefId) -> EarlyBinder<ty::PolyFnSig<'tcx>> {\n-        EarlyBinder(self.fn_sig(def_id))\n+    pub fn bound_fn_sig(self, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'tcx>> {\n+        ty::EarlyBinder(self.fn_sig(def_id))\n     }\n \n-    pub fn bound_impl_trait_ref(self, def_id: DefId) -> Option<EarlyBinder<ty::TraitRef<'tcx>>> {\n-        self.impl_trait_ref(def_id).map(|i| EarlyBinder(i))\n+    pub fn bound_impl_trait_ref(\n+        self,\n+        def_id: DefId,\n+    ) -> Option<ty::EarlyBinder<ty::TraitRef<'tcx>>> {\n+        self.impl_trait_ref(def_id).map(|i| ty::EarlyBinder(i))\n     }\n \n     pub fn bound_explicit_item_bounds(\n         self,\n         def_id: DefId,\n-    ) -> EarlyBinder<&'tcx [(ty::Predicate<'tcx>, rustc_span::Span)]> {\n-        EarlyBinder(self.explicit_item_bounds(def_id))\n+    ) -> ty::EarlyBinder<&'tcx [(ty::Predicate<'tcx>, rustc_span::Span)]> {\n+        ty::EarlyBinder(self.explicit_item_bounds(def_id))\n     }\n \n     pub fn bound_item_bounds(\n         self,\n         def_id: DefId,\n-    ) -> EarlyBinder<&'tcx ty::List<ty::Predicate<'tcx>>> {\n-        EarlyBinder(self.item_bounds(def_id))\n+    ) -> ty::EarlyBinder<&'tcx ty::List<ty::Predicate<'tcx>>> {\n+        ty::EarlyBinder(self.item_bounds(def_id))\n     }\n }\n \n@@ -930,35 +985,40 @@ impl<'tcx> Ty<'tcx> {\n     pub fn is_structural_eq_shallow(self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n-            Adt(..) => tcx.has_structural_eq_impls(self),\n+            ty::Adt(..) => tcx.has_structural_eq_impls(self),\n \n             // Primitive types that satisfy `Eq`.\n-            Bool | Char | Int(_) | Uint(_) | Str | Never => true,\n+            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Str | ty::Never => true,\n \n             // Composite types that satisfy `Eq` when all of their fields do.\n             //\n             // Because this function is \"shallow\", we return `true` for these composites regardless\n             // of the type(s) contained within.\n-            Ref(..) | Array(..) | Slice(_) | Tuple(..) => true,\n+            ty::Ref(..) | ty::Array(..) | ty::Slice(_) | ty::Tuple(..) => true,\n \n             // Raw pointers use bitwise comparison.\n-            RawPtr(_) | FnPtr(_) => true,\n+            ty::RawPtr(_) | ty::FnPtr(_) => true,\n \n             // Floating point numbers are not `Eq`.\n-            Float(_) => false,\n+            ty::Float(_) => false,\n \n             // Conservatively return `false` for all others...\n \n             // Anonymous function types\n-            FnDef(..) | Closure(..) | Dynamic(..) | Generator(..) => false,\n+            ty::FnDef(..) | ty::Closure(..) | ty::Dynamic(..) | ty::Generator(..) => false,\n \n             // Generic or inferred types\n             //\n             // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n             // called for known, fully-monomorphized types.\n-            Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n+            ty::Projection(_)\n+            | ty::Opaque(..)\n+            | ty::Param(_)\n+            | ty::Bound(..)\n+            | ty::Placeholder(_)\n+            | ty::Infer(_) => false,\n \n-            Foreign(_) | GeneratorWitness(..) | Error(_) => false,\n+            ty::Foreign(_) | ty::GeneratorWitness(..) | ty::Error(_) => false,\n         }\n     }\n \n@@ -974,13 +1034,13 @@ impl<'tcx> Ty<'tcx> {\n     /// - `&'a *const &'b u8 -> *const &'b u8`\n     pub fn peel_refs(self) -> Ty<'tcx> {\n         let mut ty = self;\n-        while let Ref(_, inner_ty, _) = ty.kind() {\n+        while let ty::Ref(_, inner_ty, _) = ty.kind() {\n             ty = *inner_ty;\n         }\n         ty\n     }\n \n-    pub fn outer_exclusive_binder(self) -> DebruijnIndex {\n+    pub fn outer_exclusive_binder(self) -> ty::DebruijnIndex {\n         self.0.outer_exclusive_binder\n     }\n }\n@@ -1177,8 +1237,8 @@ pub struct AlwaysRequiresDrop;\n /// with their underlying types.\n pub fn normalize_opaque_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    val: &'tcx List<ty::Predicate<'tcx>>,\n-) -> &'tcx List<ty::Predicate<'tcx>> {\n+    val: &'tcx ty::List<ty::Predicate<'tcx>>,\n+) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n     let mut visitor = OpaqueTypeExpander {\n         seen_opaque_tys: FxHashSet::default(),\n         expanded_cache: FxHashMap::default(),"}, {"sha": "f8853014d2fd4ac212ac46e95cff18984cfd12db", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 29, "deletions": 73, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -2,17 +2,14 @@ use crate::check::regionck::RegionCtxt;\n use crate::hir;\n use crate::hir::def_id::{DefId, LocalDefId};\n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{InferOk, RegionckMode, TyCtxtInferExt};\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, EarlyBinder, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::util::IgnoreRegions;\n+use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::query::dropck_outlives::AtExt;\n-use rustc_trait_selection::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::ObligationCause;\n \n /// This function confirms that the `Drop` implementation identified by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -39,8 +36,8 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,\n                 drop_impl_did.expect_local(),\n-                dtor_self_type,\n                 adt_def.did(),\n+                self_to_impl_substs,\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n@@ -67,75 +64,34 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     drop_impl_did: LocalDefId,\n-    drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n+    drop_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let drop_impl_hir_id = tcx.hir().local_def_id_to_hir_id(drop_impl_did);\n-\n-    // check that the impl type can be made to match the trait type.\n-\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let impl_param_env = tcx.param_env(self_type_did);\n-        let tcx = infcx.tcx;\n-        let mut fulfillment_cx = <dyn TraitEngine<'_>>::new(tcx);\n-\n-        let named_type = tcx.type_of(self_type_did);\n-\n-        let drop_impl_span = tcx.def_span(drop_impl_did);\n-        let fresh_impl_substs =\n-            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did.to_def_id());\n-        let fresh_impl_self_ty = EarlyBinder(drop_impl_ty).subst(tcx, fresh_impl_substs);\n-\n-        let cause = &ObligationCause::misc(drop_impl_span, drop_impl_hir_id);\n-        match infcx.at(cause, impl_param_env).eq(named_type, fresh_impl_self_ty) {\n-            Ok(InferOk { obligations, .. }) => {\n-                fulfillment_cx.register_predicate_obligations(infcx, obligations);\n-            }\n-            Err(_) => {\n-                let item_span = tcx.def_span(self_type_did);\n-                let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n-                let reported = struct_span_err!(\n-                    tcx.sess,\n-                    drop_impl_span,\n-                    E0366,\n-                    \"`Drop` impls cannot be specialized\"\n-                )\n-                .span_note(\n-                    item_span,\n-                    &format!(\n-                        \"use the same sequence of generic type, lifetime and const parameters \\\n-                        as the {self_descr} definition\",\n-                    ),\n-                )\n-                .emit();\n-                return Err(reported);\n-            }\n+    let Err(arg) = tcx.uses_unique_generic_params(drop_impl_substs, IgnoreRegions::No) else {\n+        return Ok(())\n+    };\n+\n+    let drop_impl_span = tcx.def_span(drop_impl_did);\n+    let item_span = tcx.def_span(self_type_did);\n+    let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n+    let mut err =\n+        struct_span_err!(tcx.sess, drop_impl_span, E0366, \"`Drop` impls cannot be specialized\");\n+    match arg {\n+        ty::util::NotUniqueParam::DuplicateParam(arg) => {\n+            err.note(&format!(\"`{arg}` is mentioned multiple times\"))\n         }\n-\n-        let errors = fulfillment_cx.select_all_or_error(&infcx);\n-        if !errors.is_empty() {\n-            // this could be reached when we get lazy normalization\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n+        ty::util::NotUniqueParam::NotParam(arg) => {\n+            err.note(&format!(\"`{arg}` is not a generic parameter\"))\n         }\n-\n-        // NB. It seems a bit... suspicious to use an empty param-env\n-        // here. The correct thing, I imagine, would be\n-        // `OutlivesEnvironment::new(impl_param_env)`, which would\n-        // allow region solving to take any `a: 'b` relations on the\n-        // impl into account. But I could not create a test case where\n-        // it did the wrong thing, so I chose to preserve existing\n-        // behavior, since it ought to be simply more\n-        // conservative. -nmatsakis\n-        let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n-\n-        infcx.resolve_regions_and_report_errors(\n-            drop_impl_did.to_def_id(),\n-            &outlives_env,\n-            RegionckMode::default(),\n-        );\n-        Ok(())\n-    })\n+    };\n+    err.span_note(\n+        item_span,\n+        &format!(\n+            \"use the same sequence of generic lifetime, type and const parameters \\\n+                     as the {self_descr} definition\",\n+        ),\n+    );\n+    Err(err.emit())\n }\n \n /// Confirms that every predicate imposed by dtor_predicates is"}, {"sha": "eb6217f1174968dbb453399c252a036e0f46ac9f", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 15, "deletions": 60, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -5,10 +5,10 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n+use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{self, ImplPolarity, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -325,51 +325,6 @@ fn emit_orphan_check_error<'tcx>(\n     })\n }\n \n-#[derive(Default)]\n-struct AreUniqueParamsVisitor {\n-    seen: GrowableBitSet<u32>,\n-}\n-\n-#[derive(Copy, Clone)]\n-enum NotUniqueParam<'tcx> {\n-    DuplicateParam(GenericArg<'tcx>),\n-    NotParam(GenericArg<'tcx>),\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for AreUniqueParamsVisitor {\n-    type BreakTy = NotUniqueParam<'tcx>;\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match t.kind() {\n-            ty::Param(p) => {\n-                if self.seen.insert(p.index) {\n-                    ControlFlow::CONTINUE\n-                } else {\n-                    ControlFlow::Break(NotUniqueParam::DuplicateParam(t.into()))\n-                }\n-            }\n-            _ => ControlFlow::Break(NotUniqueParam::NotParam(t.into())),\n-        }\n-    }\n-    fn visit_region(&mut self, _: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // We don't drop candidates during candidate assembly because of region\n-        // constraints, so the behavior for impls only constrained by regions\n-        // will not change.\n-        ControlFlow::CONTINUE\n-    }\n-    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match c.val() {\n-            ty::ConstKind::Param(p) => {\n-                if self.seen.insert(p.index) {\n-                    ControlFlow::CONTINUE\n-                } else {\n-                    ControlFlow::Break(NotUniqueParam::DuplicateParam(c.into()))\n-                }\n-            }\n-            _ => ControlFlow::Break(NotUniqueParam::NotParam(c.into())),\n-        }\n-    }\n-}\n-\n /// Lint impls of auto traits if they are likely to have\n /// unsound or surprising effects on auto impls.\n fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDefId]) {\n@@ -400,9 +355,9 @@ fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDef\n         // Impls which completely cover a given root type are fine as they\n         // disable auto impls entirely. So only lint if the substs\n         // are not a permutation of the identity substs.\n-        match substs.visit_with(&mut AreUniqueParamsVisitor::default()) {\n-            ControlFlow::Continue(()) => {} // ok\n-            ControlFlow::Break(arg) => {\n+        match tcx.uses_unique_generic_params(substs, IgnoreRegions::Yes) {\n+            Ok(()) => {} // ok\n+            Err(arg) => {\n                 // Ideally:\n                 //\n                 // - compute the requirements for the auto impl candidate\n@@ -429,28 +384,28 @@ fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDef\n             tcx.hir().local_def_id_to_hir_id(impl_def_id),\n             tcx.def_span(impl_def_id),\n             |err| {\n+                let item_span = tcx.def_span(self_type_did);\n+                let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n                 let mut err = err.build(&format!(\n                     \"cross-crate traits with a default impl, like `{}`, \\\n                          should not be specialized\",\n                     tcx.def_path_str(trait_def_id),\n                 ));\n-                let item_span = tcx.def_span(self_type_did);\n-                let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n+                match arg {\n+                    ty::util::NotUniqueParam::DuplicateParam(arg) => {\n+                        err.note(&format!(\"`{}` is mentioned multiple times\", arg));\n+                    }\n+                    ty::util::NotUniqueParam::NotParam(arg) => {\n+                        err.note(&format!(\"`{}` is not a generic parameter\", arg));\n+                    }\n+                }\n                 err.span_note(\n                     item_span,\n                     &format!(\n                         \"try using the same sequence of generic parameters as the {} definition\",\n                         self_descr,\n                     ),\n                 );\n-                match arg {\n-                    NotUniqueParam::DuplicateParam(arg) => {\n-                        err.note(&format!(\"`{}` is mentioned multiple times\", arg));\n-                    }\n-                    NotUniqueParam::NotParam(arg) => {\n-                        err.note(&format!(\"`{}` is not a generic parameter\", arg));\n-                    }\n-                }\n                 err.emit();\n             },\n         );"}, {"sha": "03460b28dcd5a4e155768ead2e1baf39901f99a1", "filename": "src/test/ui/auto-traits/suspicious-impls-lint.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -11,12 +11,12 @@ LL | #![deny(suspicious_auto_trait_impls)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+   = note: `&T` is not a generic parameter\n note: try using the same sequence of generic parameters as the struct definition\n   --> $DIR/suspicious-impls-lint.rs:8:1\n    |\n LL | struct MayImplementSendErr<T>(T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: `&T` is not a generic parameter\n \n error: cross-crate traits with a default impl, like `Send`, should not be specialized\n   --> $DIR/suspicious-impls-lint.rs:21:1\n@@ -26,12 +26,12 @@ LL | unsafe impl Send for ContainsVec<i32> {}\n    |\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+   = note: `i32` is not a generic parameter\n note: try using the same sequence of generic parameters as the struct definition\n   --> $DIR/suspicious-impls-lint.rs:20:1\n    |\n LL | struct ContainsVec<T>(Vec<T>);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: `i32` is not a generic parameter\n \n error: cross-crate traits with a default impl, like `Send`, should not be specialized\n   --> $DIR/suspicious-impls-lint.rs:32:1\n@@ -41,12 +41,12 @@ LL | unsafe impl<T: Send> Send for TwoParamsSame<T, T> {}\n    |\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+   = note: `T` is mentioned multiple times\n note: try using the same sequence of generic parameters as the struct definition\n   --> $DIR/suspicious-impls-lint.rs:31:1\n    |\n LL | struct TwoParamsSame<T, U>(T, U);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: `T` is mentioned multiple times\n \n error: cross-crate traits with a default impl, like `Send`, should not be specialized\n   --> $DIR/suspicious-impls-lint.rs:40:1\n@@ -56,12 +56,12 @@ LL | unsafe impl<T> Send for WithPhantomDataSend<*const T, i8> {}\n    |\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+   = note: `*const T` is not a generic parameter\n note: try using the same sequence of generic parameters as the struct definition\n   --> $DIR/suspicious-impls-lint.rs:39:1\n    |\n LL | pub struct WithPhantomDataSend<T, U>(PhantomData<T>, U);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: `*const T` is not a generic parameter\n \n error: cross-crate traits with a default impl, like `Sync`, should not be specialized\n   --> $DIR/suspicious-impls-lint.rs:46:1\n@@ -71,12 +71,12 @@ LL | unsafe impl<T> Sync for WithLifetime<'static, Vec<T>> {}\n    |\n    = warning: this will change its meaning in a future release!\n    = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+   = note: `Vec<T>` is not a generic parameter\n note: try using the same sequence of generic parameters as the struct definition\n   --> $DIR/suspicious-impls-lint.rs:44:1\n    |\n LL | pub struct WithLifetime<'a, T>(&'a (), T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: `Vec<T>` is not a generic parameter\n \n error: aborting due to 5 previous errors\n "}, {"sha": "f267abc0bfa7989c07012fad855d747287123219", "filename": "src/test/ui/dropck/issue-38868.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fdropck%2Fissue-38868.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fdropck%2Fissue-38868.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fissue-38868.stderr?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -8,7 +8,8 @@ LL | |     }\n LL | | }\n    | |_^\n    |\n-note: use the same sequence of generic type, lifetime and const parameters as the struct definition\n+   = note: `i32` is not a generic parameter\n+note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n   --> $DIR/issue-38868.rs:1:1\n    |\n LL | / pub struct List<T> {"}, {"sha": "7a3bbe7cb093282ec5322ca820e4151acf2e7632", "filename": "src/test/ui/dropck/reject-specialized-drops-8142.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.rs?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -32,9 +32,7 @@ impl<'al,'adds_bnd>     Drop for L<'al,'adds_bnd> where 'adds_bnd:'al {    // RE\n impl<'ml>               Drop for M<'ml>         { fn drop(&mut self) { } } // ACCEPT\n \n impl                    Drop for N<'static>     { fn drop(&mut self) { } } // REJECT\n-//~^ ERROR mismatched types\n-//~| expected struct `N<'n>`\n-//~|    found struct `N<'static>`\n+//~^ ERROR `Drop` impls cannot be specialized\n \n impl<COkNoBound> Drop for O<COkNoBound> { fn drop(&mut self) { } } // ACCEPT\n \n@@ -57,7 +55,7 @@ impl<One>         Drop for V<One,One>     { fn drop(&mut self) { } } // REJECT\n //~^ ERROR `Drop` impls cannot be specialized\n \n impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n-//~^ ERROR cannot infer an appropriate lifetime for lifetime parameter `'lw`\n+//~^ ERROR `Drop` impls cannot be specialized\n \n impl              Drop for X<3>           { fn drop(&mut self) { } } // REJECT\n //~^ ERROR `Drop` impls cannot be specialized"}, {"sha": "7f50cf5ab15d27bfb6d1464da69161116d20a24f", "filename": "src/test/ui/dropck/reject-specialized-drops-8142.stderr", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/512a328e2fb32bddd206461770a2c058368519cc/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.stderr?ref=512a328e2fb32bddd206461770a2c058368519cc", "patch": "@@ -22,35 +22,34 @@ note: the implementor must specify the same requirement\n LL | struct L<'l1,'l2> { x: &'l1 i8, y: &'l2 u8 }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n+error[E0366]: `Drop` impls cannot be specialized\n   --> $DIR/reject-specialized-drops-8142.rs:34:1\n    |\n LL | impl                    Drop for N<'static>     { fn drop(&mut self) { } } // REJECT\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected struct `N<'n>`\n-              found struct `N<'static>`\n-note: the lifetime `'n` as defined here...\n-  --> $DIR/reject-specialized-drops-8142.rs:7:10\n+   = note: `'static` is not a generic parameter\n+note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n+  --> $DIR/reject-specialized-drops-8142.rs:7:1\n    |\n LL | struct N<'n> { x: &'n i8 }\n-   |          ^^\n-   = note: ...does not necessarily outlive the static lifetime\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0366]: `Drop` impls cannot be specialized\n-  --> $DIR/reject-specialized-drops-8142.rs:41:1\n+  --> $DIR/reject-specialized-drops-8142.rs:39:1\n    |\n LL | impl              Drop for P<i8>          { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: use the same sequence of generic type, lifetime and const parameters as the struct definition\n+   = note: `i8` is not a generic parameter\n+note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n   --> $DIR/reject-specialized-drops-8142.rs:9:1\n    |\n LL | struct P<Tp> { x: *const Tp }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0367]: `Drop` impl requires `AddsBnd: Bound` but the struct it is implemented for does not\n-  --> $DIR/reject-specialized-drops-8142.rs:44:14\n+  --> $DIR/reject-specialized-drops-8142.rs:42:14\n    |\n LL | impl<AddsBnd:Bound> Drop for Q<AddsBnd> { fn drop(&mut self) { } } // REJECT\n    |              ^^^^^\n@@ -62,7 +61,7 @@ LL | struct Q<Tq> { x: *const Tq }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0367]: `Drop` impl requires `AddsRBnd: 'rbnd` but the struct it is implemented for does not\n-  --> $DIR/reject-specialized-drops-8142.rs:47:21\n+  --> $DIR/reject-specialized-drops-8142.rs:45:21\n    |\n LL | impl<'rbnd,AddsRBnd:'rbnd> Drop for R<AddsRBnd> { fn drop(&mut self) { } } // REJECT\n    |                     ^^^^^\n@@ -74,67 +73,59 @@ LL | struct R<Tr> { x: *const Tr }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0366]: `Drop` impls cannot be specialized\n-  --> $DIR/reject-specialized-drops-8142.rs:56:1\n+  --> $DIR/reject-specialized-drops-8142.rs:54:1\n    |\n LL | impl<One>         Drop for V<One,One>     { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: use the same sequence of generic type, lifetime and const parameters as the struct definition\n+   = note: `One` is mentioned multiple times\n+note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n   --> $DIR/reject-specialized-drops-8142.rs:15:1\n    |\n LL | struct V<Tva, Tvb> { x: *const Tva, y: *const Tvb }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'lw` due to conflicting requirements\n-  --> $DIR/reject-specialized-drops-8142.rs:59:1\n+error[E0366]: `Drop` impls cannot be specialized\n+  --> $DIR/reject-specialized-drops-8142.rs:57:1\n    |\n LL | impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'l1` as defined here...\n-  --> $DIR/reject-specialized-drops-8142.rs:16:10\n-   |\n-LL | struct W<'l1, 'l2> { x: &'l1 i8, y: &'l2 u8 }\n-   |          ^^^\n-note: ...but the lifetime must also be valid for the lifetime `'l2` as defined here...\n-  --> $DIR/reject-specialized-drops-8142.rs:16:15\n+   = note: `'lw` is mentioned multiple times\n+note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n+  --> $DIR/reject-specialized-drops-8142.rs:16:1\n    |\n LL | struct W<'l1, 'l2> { x: &'l1 i8, y: &'l2 u8 }\n-   |               ^^^\n-note: ...so that the types are compatible\n-  --> $DIR/reject-specialized-drops-8142.rs:59:1\n-   |\n-LL | impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `W<'l1, 'l2>`\n-              found `W<'_, '_>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0366]: `Drop` impls cannot be specialized\n-  --> $DIR/reject-specialized-drops-8142.rs:62:1\n+  --> $DIR/reject-specialized-drops-8142.rs:60:1\n    |\n LL | impl              Drop for X<3>           { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: use the same sequence of generic type, lifetime and const parameters as the struct definition\n+   = note: `3_usize` is not a generic parameter\n+note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n   --> $DIR/reject-specialized-drops-8142.rs:17:1\n    |\n LL | struct X<const Ca: usize>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0366]: `Drop` impls cannot be specialized\n-  --> $DIR/reject-specialized-drops-8142.rs:65:1\n+  --> $DIR/reject-specialized-drops-8142.rs:63:1\n    |\n LL | impl<const Ca: usize> Drop for Y<Ca, Ca>     { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: use the same sequence of generic type, lifetime and const parameters as the struct definition\n+   = note: `Ca` is mentioned multiple times\n+note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n   --> $DIR/reject-specialized-drops-8142.rs:18:1\n    |\n LL | struct Y<const Ca: usize, const Cb: usize>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0367]: `Drop` impl requires `AddsBnd: Bound` but the enum it is implemented for does not\n-  --> $DIR/reject-specialized-drops-8142.rs:68:14\n+  --> $DIR/reject-specialized-drops-8142.rs:66:14\n    |\n LL | impl<AddsBnd:Bound> Drop for Enum<AddsBnd> { fn drop(&mut self) { } } // REJECT\n    |              ^^^^^\n@@ -146,7 +137,7 @@ LL | enum Enum<T> { Variant(T) }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0367]: `Drop` impl requires `AddsBnd: Bound` but the struct it is implemented for does not\n-  --> $DIR/reject-specialized-drops-8142.rs:71:14\n+  --> $DIR/reject-specialized-drops-8142.rs:69:14\n    |\n LL | impl<AddsBnd:Bound> Drop for TupleStruct<AddsBnd> { fn drop(&mut self) { } } // REJECT\n    |              ^^^^^\n@@ -158,7 +149,7 @@ LL | struct TupleStruct<T>(T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0367]: `Drop` impl requires `AddsBnd: Bound` but the union it is implemented for does not\n-  --> $DIR/reject-specialized-drops-8142.rs:74:21\n+  --> $DIR/reject-specialized-drops-8142.rs:72:21\n    |\n LL | impl<AddsBnd:Copy + Bound> Drop for Union<AddsBnd> { fn drop(&mut self) { } } // REJECT\n    |                     ^^^^^\n@@ -171,5 +162,5 @@ LL | union Union<T: Copy> { f: T }\n \n error: aborting due to 13 previous errors\n \n-Some errors have detailed explanations: E0308, E0366, E0367, E0495.\n-For more information about an error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0366, E0367.\n+For more information about an error, try `rustc --explain E0366`."}]}