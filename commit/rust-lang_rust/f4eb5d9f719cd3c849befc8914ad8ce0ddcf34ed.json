{"sha": "f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZWI1ZDlmNzE5Y2QzYzg0OWJlZmM4OTE0YWQ4Y2UwZGRjZjM0ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-25T19:03:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-25T19:03:37Z"}, "message": "Auto merge of #68828 - oli-obk:inline_cycle, r=wesleywiser\n\nPrevent query cycles in the MIR inliner\n\nr? `@eddyb` `@wesleywiser`\n\ncc `@rust-lang/wg-mir-opt`\n\nThe general design is that we have a new query that is run on the `validated_mir` instead of on the `optimized_mir`. That query is forced before going into the optimization pipeline, so as to not try to read from a stolen MIR.\n\nThe query should not be cached cross crate, as you should never call it for items from other crates. By its very design calls into other crates can never cause query cycles.\n\nThis is a pessimistic approach to inlining, since we strictly have more calls in the `validated_mir` than we have in `optimized_mir`, but that's not a problem imo.", "tree": {"sha": "5c6ab6af9a459f06209a8c5f9fe5112f4b3204fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c6ab6af9a459f06209a8c5f9fe5112f4b3204fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "html_url": "https://github.com/rust-lang/rust/commit/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fba12bb1d3877870758a7a53e2fe766bb19bd60", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fba12bb1d3877870758a7a53e2fe766bb19bd60", "html_url": "https://github.com/rust-lang/rust/commit/7fba12bb1d3877870758a7a53e2fe766bb19bd60"}, {"sha": "d38553ca82b23c85be3dcf202a4ae03b584b17a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d38553ca82b23c85be3dcf202a4ae03b584b17a8", "html_url": "https://github.com/rust-lang/rust/commit/d38553ca82b23c85be3dcf202a4ae03b584b17a8"}], "stats": {"total": 502, "additions": 484, "deletions": 18}, "files": [{"sha": "d89e3ab4352bb9c96a5ab1f9843ba598c9bf84ca", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -782,6 +782,27 @@ rustc_queries! {\n     }\n \n     Other {\n+        /// Check whether the function has any recursion that could cause the inliner to trigger\n+        /// a cycle. Returns the call stack causing the cycle. The call stack does not contain the\n+        /// current function, just all intermediate functions.\n+        query mir_callgraph_reachable(key: (ty::Instance<'tcx>, LocalDefId)) -> bool {\n+            fatal_cycle\n+            desc { |tcx|\n+                \"computing if `{}` (transitively) calls `{}`\",\n+                key.0,\n+                tcx.def_path_str(key.1.to_def_id()),\n+            }\n+        }\n+\n+        /// Obtain all the calls into other local functions\n+        query mir_inliner_callees(key: ty::InstanceDef<'tcx>) -> &'tcx [(DefId, SubstsRef<'tcx>)] {\n+            fatal_cycle\n+            desc { |tcx|\n+                \"computing all local function calls in `{}`\",\n+                tcx.def_path_str(key.def_id()),\n+            }\n+        }\n+\n         /// Evaluates a constant and returns the computed allocation.\n         ///\n         /// **Do not use this** directly, use the `tcx.eval_static_initializer` wrapper."}, {"sha": "bfa1581aaae29fc27e57c82e6a1627c9416aa0ba", "filename": "compiler/rustc_middle/src/ty/query/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -127,6 +127,17 @@ impl Key for (DefId, DefId) {\n     }\n }\n \n+impl Key for (ty::Instance<'tcx>, LocalDefId) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.query_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n impl Key for (DefId, LocalDefId) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "8b3881ef9de1025cf9c64a25bbafe1a00ca989c2", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -57,6 +57,8 @@ pub fn provide(providers: &mut Providers) {\n     providers.eval_to_const_value_raw = const_eval::eval_to_const_value_raw_provider;\n     providers.eval_to_allocation_raw = const_eval::eval_to_allocation_raw_provider;\n     providers.const_caller_location = const_eval::const_caller_location;\n+    providers.mir_callgraph_reachable = transform::inline::cycle::mir_callgraph_reachable;\n+    providers.mir_inliner_callees = transform::inline::cycle::mir_inliner_callees;\n     providers.destructure_const = |tcx, param_env_and_value| {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::destructure_const(tcx, param_env, value)"}, {"sha": "fd5c2236902a29a42873dea263434ef88cea7133", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -440,7 +440,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n-        match &self.source_scopes[source_info.scope].local_data {\n+        let mut data = &self.source_scopes[source_info.scope];\n+        // FIXME(oli-obk): we should be able to just walk the `inlined_parent_scope`, but it\n+        // does not work as I thought it would. Needs more investigation and documentation.\n+        while data.inlined.is_some() {\n+            trace!(?data);\n+            data = &self.source_scopes[data.parent_scope.unwrap()];\n+        }\n+        trace!(?data);\n+        match &data.local_data {\n             ClearCrossCrate::Set(data) => Some(data.lint_root),\n             ClearCrossCrate::Clear => None,\n         }"}, {"sha": "dd9a514466d4c0b0c0524035bbff5dc0f055e5a2", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 74, "deletions": 17, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -17,6 +17,8 @@ use crate::transform::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n \n+crate mod cycle;\n+\n const INSTR_COST: usize = 5;\n const CALL_PENALTY: usize = 25;\n const LANDINGPAD_PENALTY: usize = 50;\n@@ -37,6 +39,9 @@ struct CallSite<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for Inline {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // If you change this optimization level, also change the level in\n+        // `mir_drops_elaborated_and_const_checked` for the call to `mir_inliner_callees`.\n+        // Otherwise you will get an ICE about stolen MIR.\n         if tcx.sess.opts.debugging_opts.mir_opt_level < 2 {\n             return;\n         }\n@@ -50,6 +55,8 @@ impl<'tcx> MirPass<'tcx> for Inline {\n             return;\n         }\n \n+        let span = trace_span!(\"inline\", body = %tcx.def_path_str(body.source.def_id()));\n+        let _guard = span.enter();\n         if inline(tcx, body) {\n             debug!(\"running simplify cfg on {:?}\", body.source);\n             CfgSimplifier::new(body).simplify();\n@@ -90,8 +97,8 @@ struct Inliner<'tcx> {\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n     /// Caller HirID.\n     hir_id: hir::HirId,\n-    /// Stack of inlined instances.\n-    history: Vec<Instance<'tcx>>,\n+    /// Stack of inlined Instances.\n+    history: Vec<ty::Instance<'tcx>>,\n     /// Indicates that the caller body has been modified.\n     changed: bool,\n }\n@@ -103,13 +110,28 @@ impl Inliner<'tcx> {\n                 None => continue,\n                 Some(it) => it,\n             };\n+            let span = trace_span!(\"process_blocks\", %callsite.callee, ?bb);\n+            let _guard = span.enter();\n+\n+            trace!(\n+                \"checking for self recursion ({:?} vs body_source: {:?})\",\n+                callsite.callee.def_id(),\n+                caller_body.source.def_id()\n+            );\n+            if callsite.callee.def_id() == caller_body.source.def_id() {\n+                debug!(\"Not inlining a function into itself\");\n+                continue;\n+            }\n \n-            if !self.is_mir_available(&callsite.callee, caller_body) {\n+            if !self.is_mir_available(callsite.callee, caller_body) {\n                 debug!(\"MIR unavailable {}\", callsite.callee);\n                 continue;\n             }\n \n+            let span = trace_span!(\"instance_mir\", %callsite.callee);\n+            let instance_mir_guard = span.enter();\n             let callee_body = self.tcx.instance_mir(callsite.callee.def);\n+            drop(instance_mir_guard);\n             if !self.should_inline(callsite, callee_body) {\n                 continue;\n             }\n@@ -137,28 +159,61 @@ impl Inliner<'tcx> {\n         }\n     }\n \n-    fn is_mir_available(&self, callee: &Instance<'tcx>, caller_body: &Body<'tcx>) -> bool {\n-        if let InstanceDef::Item(_) = callee.def {\n-            if !self.tcx.is_mir_available(callee.def_id()) {\n-                return false;\n+    #[instrument(skip(self, caller_body))]\n+    fn is_mir_available(&self, callee: Instance<'tcx>, caller_body: &Body<'tcx>) -> bool {\n+        match callee.def {\n+            InstanceDef::Item(_) => {\n+                // If there is no MIR available (either because it was not in metadata or\n+                // because it has no MIR because it's an extern function), then the inliner\n+                // won't cause cycles on this.\n+                if !self.tcx.is_mir_available(callee.def_id()) {\n+                    return false;\n+                }\n             }\n+            // These have no own callable MIR.\n+            InstanceDef::Intrinsic(_) | InstanceDef::Virtual(..) => return false,\n+            // This cannot result in an immediate cycle since the callee MIR is a shim, which does\n+            // not get any optimizations run on it. Any subsequent inlining may cause cycles, but we\n+            // do not need to catch this here, we can wait until the inliner decides to continue\n+            // inlining a second time.\n+            InstanceDef::VtableShim(_)\n+            | InstanceDef::ReifyShim(_)\n+            | InstanceDef::FnPtrShim(..)\n+            | InstanceDef::ClosureOnceShim { .. }\n+            | InstanceDef::DropGlue(..)\n+            | InstanceDef::CloneShim(..) => return true,\n+        }\n+\n+        if self.tcx.is_constructor(callee.def_id()) {\n+            trace!(\"constructors always have MIR\");\n+            // Constructor functions cannot cause a query cycle.\n+            return true;\n         }\n \n         if let Some(callee_def_id) = callee.def_id().as_local() {\n             let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-            // Avoid a cycle here by only using `instance_mir` only if we have\n-            // a lower `HirId` than the callee. This ensures that the callee will\n-            // not inline us. This trick only works without incremental compilation.\n-            // So don't do it if that is enabled. Also avoid inlining into generators,\n+            // Avoid inlining into generators,\n             // since their `optimized_mir` is used for layout computation, which can\n             // create a cycle, even when no attempt is made to inline the function\n             // in the other direction.\n-            !self.tcx.dep_graph.is_fully_enabled()\n+            caller_body.generator_kind.is_none()\n+                && (\n+                    // Avoid a cycle here by only using `instance_mir` only if we have\n+                    // a lower `HirId` than the callee. This ensures that the callee will\n+                    // not inline us. This trick only works without incremental compilation.\n+                    // So don't do it if that is enabled.\n+                    !self.tcx.dep_graph.is_fully_enabled()\n                 && self.hir_id < callee_hir_id\n-                && caller_body.generator_kind.is_none()\n+                // If we know for sure that the function we're calling will itself try to\n+                // call us, then we avoid inlining that function.\n+                || !self.tcx.mir_callgraph_reachable((callee, caller_body.source.def_id().expect_local()))\n+                )\n         } else {\n-            // This cannot result in a cycle since the callee MIR is from another crate\n-            // and is already optimized.\n+            // This cannot result in an immediate cycle since the callee MIR is from another crate\n+            // and is already optimized. Any subsequent inlining may cause cycles, but we do\n+            // not need to catch this here, we can wait until the inliner decides to continue\n+            // inlining a second time.\n+            trace!(\"functions from other crates always have MIR\");\n             true\n         }\n     }\n@@ -203,8 +258,8 @@ impl Inliner<'tcx> {\n         None\n     }\n \n+    #[instrument(skip(self, callee_body))]\n     fn should_inline(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n-        debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n \n         if callsite.fn_sig.c_variadic() {\n@@ -333,7 +388,9 @@ impl Inliner<'tcx> {\n                         if let Ok(Some(instance)) =\n                             Instance::resolve(self.tcx, self.param_env, def_id, substs)\n                         {\n-                            if callsite.callee == instance || self.history.contains(&instance) {\n+                            if callsite.callee.def_id() == instance.def_id()\n+                                || self.history.contains(&instance)\n+                            {\n                                 debug!(\"`callee is recursive - not inlining\");\n                                 return false;\n                             }"}, {"sha": "e4d403fbf60c0edbac3583d89b9aaa57b4063ffa", "filename": "compiler/rustc_mir/src/transform/inline/cycle.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,157 @@\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_middle::mir::TerminatorKind;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{self, subst::SubstsRef, InstanceDef, TyCtxt};\n+\n+// FIXME: check whether it is cheaper to precompute the entire call graph instead of invoking\n+// this query riddiculously often.\n+#[instrument(skip(tcx, root, target))]\n+crate fn mir_callgraph_reachable(\n+    tcx: TyCtxt<'tcx>,\n+    (root, target): (ty::Instance<'tcx>, LocalDefId),\n+) -> bool {\n+    trace!(%root, target = %tcx.def_path_str(target.to_def_id()));\n+    let param_env = tcx.param_env_reveal_all_normalized(target);\n+    assert_ne!(\n+        root.def_id().expect_local(),\n+        target,\n+        \"you should not call `mir_callgraph_reachable` on immediate self recursion\"\n+    );\n+    assert!(\n+        matches!(root.def, InstanceDef::Item(_)),\n+        \"you should not call `mir_callgraph_reachable` on shims\"\n+    );\n+    assert!(\n+        !tcx.is_constructor(root.def_id()),\n+        \"you should not call `mir_callgraph_reachable` on enum/struct constructor functions\"\n+    );\n+    #[instrument(skip(tcx, param_env, target, stack, seen, recursion_limiter, caller))]\n+    fn process(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        caller: ty::Instance<'tcx>,\n+        target: LocalDefId,\n+        stack: &mut Vec<ty::Instance<'tcx>>,\n+        seen: &mut FxHashSet<ty::Instance<'tcx>>,\n+        recursion_limiter: &mut FxHashMap<DefId, usize>,\n+    ) -> bool {\n+        trace!(%caller);\n+        for &(callee, substs) in tcx.mir_inliner_callees(caller.def) {\n+            let substs = caller.subst_mir_and_normalize_erasing_regions(tcx, param_env, substs);\n+            let callee = match ty::Instance::resolve(tcx, param_env, callee, substs).unwrap() {\n+                Some(callee) => callee,\n+                None => {\n+                    trace!(?callee, \"cannot resolve, skipping\");\n+                    continue;\n+                }\n+            };\n+\n+            // Found a path.\n+            if callee.def_id() == target.to_def_id() {\n+                return true;\n+            }\n+\n+            if tcx.is_constructor(callee.def_id()) {\n+                trace!(\"constructors always have MIR\");\n+                // Constructor functions cannot cause a query cycle.\n+                continue;\n+            }\n+\n+            match callee.def {\n+                InstanceDef::Item(_) => {\n+                    // If there is no MIR available (either because it was not in metadata or\n+                    // because it has no MIR because it's an extern function), then the inliner\n+                    // won't cause cycles on this.\n+                    if !tcx.is_mir_available(callee.def_id()) {\n+                        trace!(?callee, \"no mir available, skipping\");\n+                        continue;\n+                    }\n+                }\n+                // These have no own callable MIR.\n+                InstanceDef::Intrinsic(_) | InstanceDef::Virtual(..) => continue,\n+                // These have MIR and if that MIR is inlined, substituted and then inlining is run\n+                // again, a function item can end up getting inlined. Thus we'll be able to cause\n+                // a cycle that way\n+                InstanceDef::VtableShim(_)\n+                | InstanceDef::ReifyShim(_)\n+                | InstanceDef::FnPtrShim(..)\n+                | InstanceDef::ClosureOnceShim { .. }\n+                | InstanceDef::CloneShim(..) => {}\n+                InstanceDef::DropGlue(..) => {\n+                    // FIXME: A not fully substituted drop shim can cause ICEs if one attempts to\n+                    // have its MIR built. Likely oli-obk just screwed up the `ParamEnv`s, so this\n+                    // needs some more analysis.\n+                    if callee.needs_subst() {\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            if seen.insert(callee) {\n+                let recursion = recursion_limiter.entry(callee.def_id()).or_default();\n+                trace!(?callee, recursion = *recursion);\n+                if tcx.sess.recursion_limit().value_within_limit(*recursion) {\n+                    *recursion += 1;\n+                    stack.push(callee);\n+                    let found_recursion = ensure_sufficient_stack(|| {\n+                        process(tcx, param_env, callee, target, stack, seen, recursion_limiter)\n+                    });\n+                    if found_recursion {\n+                        return true;\n+                    }\n+                    stack.pop();\n+                } else {\n+                    // Pessimistically assume that there could be recursion.\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+    process(\n+        tcx,\n+        param_env,\n+        root,\n+        target,\n+        &mut Vec::new(),\n+        &mut FxHashSet::default(),\n+        &mut FxHashMap::default(),\n+    )\n+}\n+\n+crate fn mir_inliner_callees<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: ty::InstanceDef<'tcx>,\n+) -> &'tcx [(DefId, SubstsRef<'tcx>)] {\n+    let steal;\n+    let guard;\n+    let body = match (instance, instance.def_id().as_local()) {\n+        (InstanceDef::Item(_), Some(def_id)) => {\n+            let def = ty::WithOptConstParam::unknown(def_id);\n+            steal = tcx.mir_promoted(def).0;\n+            guard = steal.borrow();\n+            &*guard\n+        }\n+        // Functions from other crates and MIR shims\n+        _ => tcx.instance_mir(instance),\n+    };\n+    let mut calls = Vec::new();\n+    for bb_data in body.basic_blocks() {\n+        let terminator = bb_data.terminator();\n+        if let TerminatorKind::Call { func, .. } = &terminator.kind {\n+            let ty = func.ty(&body.local_decls, tcx);\n+            let call = match ty.kind() {\n+                ty::FnDef(def_id, substs) => (*def_id, *substs),\n+                _ => continue,\n+            };\n+            // We've seen this before\n+            if calls.contains(&call) {\n+                continue;\n+            }\n+            calls.push(call);\n+        }\n+    }\n+    tcx.arena.alloc_slice(&calls)\n+}"}, {"sha": "2786127513d38d45dce4957097ccc0429f770712", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -419,6 +419,20 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n         tcx.ensure().mir_borrowck(def.did);\n     }\n \n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+    use rustc_middle::hir::map::blocks::FnLikeNode;\n+    let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n+    if is_fn_like {\n+        let did = def.did.to_def_id();\n+        let def = ty::WithOptConstParam::unknown(did);\n+\n+        // Do not compute the mir call graph without said call graph actually being used.\n+        // Keep this in sync with the mir inliner's optimization level.\n+        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+            let _ = tcx.mir_inliner_callees(ty::InstanceDef::Item(def));\n+        }\n+    }\n+\n     let (body, _) = tcx.mir_promoted(def);\n     let mut body = body.steal();\n "}, {"sha": "9e7055a370c9d6c7a76ded520199164e89f311f6", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -200,6 +200,7 @@ macro_rules! step_identical_methods {\n         }\n \n         #[inline]\n+        #[allow(arithmetic_overflow)]\n         fn forward(start: Self, n: usize) -> Self {\n             // In debug builds, trigger a panic on overflow.\n             // This should optimize completely out in release builds.\n@@ -211,6 +212,7 @@ macro_rules! step_identical_methods {\n         }\n \n         #[inline]\n+        #[allow(arithmetic_overflow)]\n         fn backward(start: Self, n: usize) -> Self {\n             // In debug builds, trigger a panic on overflow.\n             // This should optimize completely out in release builds."}, {"sha": "54dd545dfb9a6eaa4a081a0db321776352e04f70", "filename": "src/test/mir-opt/inline/cycle.f.Inline.diff", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.f.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.f.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.f.Inline.diff?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,42 @@\n+- // MIR for `f` before Inline\n++ // MIR for `f` after Inline\n+  \n+  fn f(_1: impl Fn()) -> () {\n+      debug g => _1;                       // in scope 0 at $DIR/cycle.rs:5:6: 5:7\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:5:20: 5:20\n+      let _2: ();                          // in scope 0 at $DIR/cycle.rs:6:5: 6:8\n+      let mut _3: &impl Fn();              // in scope 0 at $DIR/cycle.rs:6:5: 6:6\n+      let mut _4: ();                      // in scope 0 at $DIR/cycle.rs:6:5: 6:8\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/cycle.rs:6:5: 6:8\n+          StorageLive(_3);                 // scope 0 at $DIR/cycle.rs:6:5: 6:6\n+          _3 = &_1;                        // scope 0 at $DIR/cycle.rs:6:5: 6:6\n+          StorageLive(_4);                 // scope 0 at $DIR/cycle.rs:6:5: 6:8\n+          _2 = <impl Fn() as Fn<()>>::call(move _3, move _4) -> [return: bb1, unwind: bb3]; // scope 0 at $DIR/cycle.rs:6:5: 6:8\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:6:5: 6:6\n+                                           // + literal: Const { ty: for<'r> extern \"rust-call\" fn(&'r impl Fn(), ()) -> <impl Fn() as std::ops::FnOnce<()>>::Output {<impl Fn() as std::ops::Fn<()>>::call}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 0 at $DIR/cycle.rs:6:7: 6:8\n+          StorageDead(_3);                 // scope 0 at $DIR/cycle.rs:6:7: 6:8\n+          StorageDead(_2);                 // scope 0 at $DIR/cycle.rs:6:8: 6:9\n+          _0 = const ();                   // scope 0 at $DIR/cycle.rs:5:20: 7:2\n+          drop(_1) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/cycle.rs:7:1: 7:2\n+      }\n+  \n+      bb2: {\n+          return;                          // scope 0 at $DIR/cycle.rs:7:2: 7:2\n+      }\n+  \n+      bb3 (cleanup): {\n+          drop(_1) -> bb4;                 // scope 0 at $DIR/cycle.rs:7:1: 7:2\n+      }\n+  \n+      bb4 (cleanup): {\n+          resume;                          // scope 0 at $DIR/cycle.rs:5:1: 7:2\n+      }\n+  }\n+  "}, {"sha": "46f5e5e20655bd43d7fb50b6df1957a010396e74", "filename": "src/test/mir-opt/inline/cycle.g.Inline.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `g` before Inline\n++ // MIR for `g` after Inline\n+  \n+  fn g() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:11:8: 11:8\n+      let _1: ();                          // in scope 0 at $DIR/cycle.rs:12:5: 12:12\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/cycle.rs:12:5: 12:12\n+          _1 = f::<fn() {main}>(main) -> bb1; // scope 0 at $DIR/cycle.rs:12:5: 12:12\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:12:5: 12:6\n+                                           // + literal: Const { ty: fn(fn() {main}) {f::<fn() {main}>}, val: Value(Scalar(<ZST>)) }\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:12:7: 12:11\n+                                           // + literal: Const { ty: fn() {main}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:12:12: 12:13\n+          _0 = const ();                   // scope 0 at $DIR/cycle.rs:11:8: 13:2\n+          return;                          // scope 0 at $DIR/cycle.rs:13:2: 13:2\n+      }\n+  }\n+  "}, {"sha": "c8d1448d949d44707efac924bc109e865a084de7", "filename": "src/test/mir-opt/inline/cycle.main.Inline.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `main` before Inline\n++ // MIR for `main` after Inline\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:16:11: 16:11\n+      let _1: ();                          // in scope 0 at $DIR/cycle.rs:17:5: 17:9\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/cycle.rs:17:5: 17:9\n+          _1 = f::<fn() {g}>(g) -> bb1;    // scope 0 at $DIR/cycle.rs:17:5: 17:9\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:17:5: 17:6\n+                                           // + literal: Const { ty: fn(fn() {g}) {f::<fn() {g}>}, val: Value(Scalar(<ZST>)) }\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:17:7: 17:8\n+                                           // + literal: Const { ty: fn() {g}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:17:9: 17:10\n+          _0 = const ();                   // scope 0 at $DIR/cycle.rs:16:11: 18:2\n+          return;                          // scope 0 at $DIR/cycle.rs:18:2: 18:2\n+      }\n+  }\n+  "}, {"sha": "9e8950d8a3d61e160cd6ed701c18e3cf0c5e167d", "filename": "src/test/mir-opt/inline/cycle.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,18 @@\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+// EMIT_MIR cycle.f.Inline.diff\n+#[inline(always)]\n+fn f(g: impl Fn()) {\n+    g();\n+}\n+\n+// EMIT_MIR cycle.g.Inline.diff\n+#[inline(always)]\n+fn g() {\n+    f(main);\n+}\n+\n+// EMIT_MIR cycle.main.Inline.diff\n+fn main() {\n+    f(g);\n+}"}, {"sha": "24b4f37939ad1a4194e9c1dd97b733ce377df880", "filename": "src/test/mir-opt/inline/inline-cycle-generic.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle-generic.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,40 @@\n+// Check that inliner handles various forms of recursion and doesn't fall into\n+// an infinite inlining cycle. The particular outcome of inlining is not\n+// crucial otherwise.\n+//\n+// Regression test for issue #78573.\n+\n+// EMIT_MIR inline_cycle_generic.main.Inline.diff\n+fn main() {\n+    <C as Call>::call();\n+}\n+\n+pub trait Call {\n+    fn call();\n+}\n+\n+pub struct A;\n+pub struct B<T>(T);\n+pub struct C;\n+\n+impl Call for A {\n+    #[inline]\n+    fn call() {\n+        <B<C> as Call>::call()\n+    }\n+}\n+\n+\n+impl<T: Call> Call for B<T> {\n+    #[inline]\n+    fn call() {\n+        <T as Call>::call()\n+    }\n+}\n+\n+impl Call for C {\n+    #[inline]\n+    fn call() {\n+        <B<A> as Call>::call()\n+    }\n+}"}, {"sha": "9709f27377920a23c686e3f64c402bd74c60fff8", "filename": "src/test/mir-opt/inline/inline_cycle_generic.main.Inline.diff", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle_generic.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle_generic.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle_generic.main.Inline.diff?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,29 @@\n+- // MIR for `main` before Inline\n++ // MIR for `main` after Inline\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-cycle-generic.rs:8:11: 8:11\n+      let _1: ();                          // in scope 0 at $DIR/inline-cycle-generic.rs:9:5: 9:24\n++     scope 1 (inlined <C as Call>::call) { // at $DIR/inline-cycle-generic.rs:9:5: 9:24\n++         scope 2 (inlined <B<A> as Call>::call) { // at $DIR/inline-cycle-generic.rs:9:5: 9:24\n++         }\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-cycle-generic.rs:9:5: 9:24\n+-         _1 = <C as Call>::call() -> bb1; // scope 0 at $DIR/inline-cycle-generic.rs:9:5: 9:24\n++         _1 = <A as Call>::call() -> bb1; // scope 2 at $DIR/inline-cycle-generic.rs:9:5: 9:24\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-cycle-generic.rs:9:5: 9:22\n+-                                          // + literal: Const { ty: fn() {<C as Call>::call}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/inline-cycle-generic.rs:9:5: 9:24\n++                                          // + literal: Const { ty: fn() {<A as Call>::call}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-cycle-generic.rs:9:24: 9:25\n+          _0 = const ();                   // scope 0 at $DIR/inline-cycle-generic.rs:8:11: 10:2\n+          return;                          // scope 0 at $DIR/inline-cycle-generic.rs:10:2: 10:2\n+      }\n+  }\n+  "}, {"sha": "656ff02dc67efe28b6fd874a9e8c49225c63fb9d", "filename": "src/test/ui/const_prop/inline_spans_lint_attribute.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans_lint_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans_lint_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans_lint_attribute.rs?ref=f4eb5d9f719cd3c849befc8914ad8ce0ddcf34ed", "patch": "@@ -0,0 +1,15 @@\n+// Must be build-pass, because check-pass will not run const prop and thus not emit the lint anyway.\n+// build-pass\n+// compile-flags: -Zmir-opt-level=2\n+\n+#![deny(warnings)]\n+\n+fn main() {\n+    #[allow(arithmetic_overflow)]\n+    let _ = add(u8::MAX, 1);\n+}\n+\n+#[inline(always)]\n+fn add(x: u8, y: u8) -> u8 {\n+    x + y\n+}"}]}