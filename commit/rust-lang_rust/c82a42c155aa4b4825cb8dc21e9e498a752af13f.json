{"sha": "c82a42c155aa4b4825cb8dc21e9e498a752af13f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MmE0MmMxNTVhYTRiNDgyNWNiOGRjMjFlOWU0OThhNzUyYWYxM2Y=", "commit": {"author": {"name": "Edward Barnard", "email": "eabarnard@gmail.com", "date": "2019-03-03T19:47:17Z"}, "committer": {"name": "Edward Barnard", "email": "eabarnard@gmail.com", "date": "2019-03-04T12:33:15Z"}, "message": "Change `std::fs::copy` to use `copyfile` on MacOS and iOS", "tree": {"sha": "3af84100fe33ef9e33f4cdb8ce4c5f3fff471a81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3af84100fe33ef9e33f4cdb8ce4c5f3fff471a81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c82a42c155aa4b4825cb8dc21e9e498a752af13f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c82a42c155aa4b4825cb8dc21e9e498a752af13f", "html_url": "https://github.com/rust-lang/rust/commit/c82a42c155aa4b4825cb8dc21e9e498a752af13f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c82a42c155aa4b4825cb8dc21e9e498a752af13f/comments", "author": {"login": "ebarnard", "id": 1059683, "node_id": "MDQ6VXNlcjEwNTk2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1059683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebarnard", "html_url": "https://github.com/ebarnard", "followers_url": "https://api.github.com/users/ebarnard/followers", "following_url": "https://api.github.com/users/ebarnard/following{/other_user}", "gists_url": "https://api.github.com/users/ebarnard/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebarnard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebarnard/subscriptions", "organizations_url": "https://api.github.com/users/ebarnard/orgs", "repos_url": "https://api.github.com/users/ebarnard/repos", "events_url": "https://api.github.com/users/ebarnard/events{/privacy}", "received_events_url": "https://api.github.com/users/ebarnard/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebarnard", "id": 1059683, "node_id": "MDQ6VXNlcjEwNTk2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1059683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebarnard", "html_url": "https://github.com/ebarnard", "followers_url": "https://api.github.com/users/ebarnard/followers", "following_url": "https://api.github.com/users/ebarnard/following{/other_user}", "gists_url": "https://api.github.com/users/ebarnard/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebarnard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebarnard/subscriptions", "organizations_url": "https://api.github.com/users/ebarnard/orgs", "repos_url": "https://api.github.com/users/ebarnard/repos", "events_url": "https://api.github.com/users/ebarnard/events{/privacy}", "received_events_url": "https://api.github.com/users/ebarnard/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0086b9e8972fef9fd4af24bae20d45021ed06c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0086b9e8972fef9fd4af24bae20d45021ed06c6", "html_url": "https://github.com/rust-lang/rust/commit/c0086b9e8972fef9fd4af24bae20d45021ed06c6"}], "stats": {"total": 90, "additions": 88, "deletions": 2}, "files": [{"sha": "3454f847ef41461e032d79fc9b7aaf546a9f155c", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c82a42c155aa4b4825cb8dc21e9e498a752af13f/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82a42c155aa4b4825cb8dc21e9e498a752af13f/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=c82a42c155aa4b4825cb8dc21e9e498a752af13f", "patch": "@@ -1581,7 +1581,8 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// `O_CLOEXEC` is set for returned file descriptors.\n /// On Windows, this function currently corresponds to `CopyFileEx`. Alternate\n /// NTFS streams are copied but only the size of the main stream is returned by\n-/// this function.\n+/// this function. On MacOS, this function corresponds to `copyfile` with\n+/// `COPYFILE_ALL`\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: ../io/index.html#platform-specific-behavior"}, {"sha": "7ff098bc9e1237fd288beb1c2ecfa4a7cb8d9ea3", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c82a42c155aa4b4825cb8dc21e9e498a752af13f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82a42c155aa4b4825cb8dc21e9e498a752af13f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=c82a42c155aa4b4825cb8dc21e9e498a752af13f", "patch": "@@ -827,7 +827,10 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n-#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+#[cfg(not(any(target_os = \"linux\",\n+              target_os = \"android\",\n+              target_os = \"macos\",\n+              target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::fs::File;\n     if !from.is_file() {\n@@ -937,3 +940,85 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     writer.set_permissions(perm)?;\n     Ok(written)\n }\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    const COPYFILE_ACL: u32 = 1 << 0;\n+    const COPYFILE_STAT: u32 = 1 << 1;\n+    const COPYFILE_XATTR: u32 = 1 << 2;\n+    const COPYFILE_DATA: u32 = 1 << 3;\n+\n+    const COPYFILE_SECURITY: u32 = COPYFILE_STAT | COPYFILE_ACL;\n+    const COPYFILE_METADATA: u32 = COPYFILE_SECURITY | COPYFILE_XATTR;\n+    const COPYFILE_ALL: u32 = COPYFILE_METADATA | COPYFILE_DATA;\n+\n+    const COPYFILE_STATE_COPIED: u32 = 8;\n+\n+    #[allow(non_camel_case_types)]\n+    type copyfile_state_t = *mut libc::c_void;\n+    #[allow(non_camel_case_types)]\n+    type copyfile_flags_t = u32;\n+\n+    extern \"C\" {\n+        fn copyfile(\n+            from: *const libc::c_char,\n+            to: *const libc::c_char,\n+            state: copyfile_state_t,\n+            flags: copyfile_flags_t,\n+        ) -> libc::c_int;\n+        fn copyfile_state_alloc() -> copyfile_state_t;\n+        fn copyfile_state_free(state: copyfile_state_t) -> libc::c_int;\n+        fn copyfile_state_get(\n+            state: copyfile_state_t,\n+            flag: u32,\n+            dst: *mut libc::c_void,\n+        ) -> libc::c_int;\n+    }\n+\n+    struct FreeOnDrop(copyfile_state_t);\n+    impl Drop for FreeOnDrop {\n+        fn drop(&mut self) {\n+            // The code below ensures that `FreeOnDrop` is never a null pointer\n+            unsafe {\n+                // `copyfile_state_free` returns -1 if the `to` or `from` files\n+                // cannot be closed. However, this is not considerd this an\n+                // error.\n+                copyfile_state_free(self.0);\n+            }\n+        }\n+    }\n+\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    // We ensure that `FreeOnDrop` never contains a null pointer so it is\n+    // always safe to call `copyfile_state_free`\n+    let state = unsafe {\n+        let state = copyfile_state_alloc();\n+        if state.is_null() {\n+            return Err(crate::io::Error::last_os_error());\n+        }\n+        FreeOnDrop(state)\n+    };\n+\n+    cvt(unsafe {\n+        copyfile(\n+            cstr(from)?.as_ptr(),\n+            cstr(to)?.as_ptr(),\n+            state.0,\n+            COPYFILE_ALL,\n+        )\n+    })?;\n+\n+    let mut bytes_copied: libc::off_t = 0;\n+    cvt(unsafe {\n+        copyfile_state_get(\n+            state.0,\n+            COPYFILE_STATE_COPIED,\n+            &mut bytes_copied as *mut libc::off_t as *mut libc::c_void,\n+        )\n+    })?;\n+    Ok(bytes_copied as u64)\n+}"}]}