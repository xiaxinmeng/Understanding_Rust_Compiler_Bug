{"sha": "b7314c7cafc657afa6b98eb9c4958e56a82129bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MzE0YzdjYWZjNjU3YWZhNmI5OGViOWM0OTU4ZTU2YTgyMTI5YmI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-08-05T14:55:23Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-08-11T12:00:05Z"}, "message": "Actually make rustc_driver compile without llvm", "tree": {"sha": "81facc2dfbb425879b230d70085fa483b34fe936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81facc2dfbb425879b230d70085fa483b34fe936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7314c7cafc657afa6b98eb9c4958e56a82129bb", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQIcBAABCgAGBQJZjZxFAAoJEEpHzFJ6U7W8saMQALJf2w+3QmYRQTlmPoBENOeL\nQdDWSzLZiXgCqDPKDFaRh+EBvK87X89xBfnWgUWwANQY6Ms0Ns1QfCg3RGes4NrG\nsS7Lw4emlp8Uq6K+b5enEwuyEF5hLzhzzSIfvM/qgIvNXV5BYB9J8s8ebADfCQXt\nVvCMnJmOe7mkqy/5aEBwH1HGk11/go8doZwSeDBGfWheQHVOOvJhu+a1ItnARfRv\nR4G21BCdkmzeM3Asejv3uU8jiRQVGekde7esVDe/h1Lf+lv+eY+df87k2nWY68Bj\n50htPj/tv9IVo9fRGlbDHKrSwS5nmnKdXry4+4ji5yvOYDQkOD5n0YppKXaeML66\nvW+uLgdS+9c932wBvw4uv0Ot8EKkhCYTI8PTm+S2WXgWaluQappdSpdP2CQ3cU4i\nosZ3cXbwYo6iopPlkeJxp8Aq4zoUS5F5OcBXcNxrQkixi6PlETlXEtI4pPudQDQj\nRE1RBjovMrGNxwcFMKj57ymScpAh4iD3lXIZzDMpnoDzsGIoTTxXvXP+rW5MNtqj\nZdWe0O8J1riXn1ybY0emf9TDMEoUvoo+9ktGY4rWvP9SRX2613Zt22AiCw2GmzZp\nGoNePvqVTvW8+XfE9c+EdA5uRN9JaFNDQhGLiGELRe7lMX45fn4S+wbIfZEw+wWN\ndswDy2R/LVpW5H8Ixr2k\n=hdXh\n-----END PGP SIGNATURE-----", "payload": "tree 81facc2dfbb425879b230d70085fa483b34fe936\nparent b43c02b0aad08fe8ffef702423bc60e2fa869eee\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1501944923 +0200\ncommitter bjorn3 <bjorn3@users.noreply.github.com> 1502452805 +0200\n\nActually make rustc_driver compile without llvm\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7314c7cafc657afa6b98eb9c4958e56a82129bb", "html_url": "https://github.com/rust-lang/rust/commit/b7314c7cafc657afa6b98eb9c4958e56a82129bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7314c7cafc657afa6b98eb9c4958e56a82129bb/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b43c02b0aad08fe8ffef702423bc60e2fa869eee", "url": "https://api.github.com/repos/rust-lang/rust/commits/b43c02b0aad08fe8ffef702423bc60e2fa869eee", "html_url": "https://github.com/rust-lang/rust/commit/b43c02b0aad08fe8ffef702423bc60e2fa869eee"}], "stats": {"total": 466, "additions": 318, "deletions": 148}, "files": [{"sha": "4940dfd0e655c0a5e8fe8ecacb8ae89325bcac09", "filename": "src/Cargo.lock", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -1360,6 +1360,7 @@ dependencies = [\n  \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n  \"rustc_trans 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1551,6 +1552,26 @@ dependencies = [\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_trans_utils\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc 0.0.0\",\n+ \"rustc_allocator 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "04c0f9b35184ec2e3600ca17ca312107d80d5a1d", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -30,6 +30,7 @@ rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_trans = { path = \"../librustc_trans\", optional = true }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "be257c8524b697b111dd7d0ab2e941d3d52d7269", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 48, "deletions": 26, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -31,7 +31,9 @@ use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n+#[cfg(feature=\"llvm\")]\n use rustc_trans::back::{link, write};\n+#[cfg(feature=\"llvm\")]\n use rustc_trans as trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n@@ -113,7 +115,8 @@ pub fn compile_input(sess: &Session,\n         };\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n-        let crate_name = link::find_crate_name(Some(sess), &krate.attrs, input);\n+        let crate_name =\n+            ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n             phase_2_configure_and_expand(\n                 sess, &cstore, krate, registry, &crate_name, addl_plugins, control.make_glob_map,\n@@ -206,8 +209,12 @@ pub fn compile_input(sess: &Session,\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n+\n+            #[cfg(feature=\"llvm\")]\n             let trans = phase_4_translate_to_llvm(tcx, analysis, incremental_hashes_map,\n                                                   &outputs);\n+            #[cfg(not(feature=\"llvm\"))]\n+            let trans = { panic!(\"LLVM not supported by this rustc.\"); () };\n \n             if log_enabled!(::log::LogLevel::Info) {\n                 println!(\"Post-trans\");\n@@ -225,34 +232,42 @@ pub fn compile_input(sess: &Session,\n         })??\n     };\n \n-    if sess.opts.debugging_opts.print_type_sizes {\n-        sess.code_stats.borrow().print_type_sizes();\n-    }\n+    #[cfg(not(feature=\"llvm\"))]\n+    unreachable!();\n \n-    let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n+    #[cfg(feature=\"llvm\")]\n+    {\n+        if sess.opts.debugging_opts.print_type_sizes {\n+            sess.code_stats.borrow().print_type_sizes();\n+        }\n \n-    controller_entry_point!(after_llvm,\n-                            sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n-                            phase5_result);\n-    phase5_result?;\n+        let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n \n-    phase_6_link_output(sess, &trans, &outputs);\n+        controller_entry_point!(after_llvm,\n+                                sess,\n+                                CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n+                                phase5_result);\n+        phase5_result?;\n \n-    // Now that we won't touch anything in the incremental compilation directory\n-    // any more, we can finalize it (which involves renaming it)\n-    rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+        phase_6_link_output(sess, &trans, &outputs);\n \n-    if sess.opts.debugging_opts.perf_stats {\n-        sess.print_perf_stats();\n-    }\n+        // Now that we won't touch anything in the incremental compilation directory\n+        // any more, we can finalize it (which involves renaming it)\n+        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+\n+        if sess.opts.debugging_opts.perf_stats {\n+            sess.print_perf_stats();\n+        }\n \n-    controller_entry_point!(compilation_done,\n-                            sess,\n-                            CompileState::state_when_compilation_done(input, sess, outdir, output),\n-                            Ok(()));\n+        controller_entry_point!(\n+            compilation_done,\n+            sess,\n+            CompileState::state_when_compilation_done(input, sess, outdir, output),\n+            Ok(())\n+        );\n \n-    Ok(())\n+        Ok(())\n+    }\n }\n \n fn keep_hygiene_data(sess: &Session) -> bool {\n@@ -360,6 +375,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub resolutions: Option<&'a Resolutions>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    #[cfg(feature=\"llvm\")]\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -386,6 +402,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             resolutions: None,\n             analysis: None,\n             tcx: None,\n+            #[cfg(feature=\"llvm\")]\n             trans: None,\n         }\n     }\n@@ -474,7 +491,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-\n+    #[cfg(feature=\"llvm\")]\n     fn state_after_llvm(input: &'a Input,\n                         session: &'tcx Session,\n                         out_dir: &'a Option<PathBuf>,\n@@ -906,6 +923,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n+    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n@@ -918,6 +936,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n+    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n@@ -1063,6 +1082,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            analysis: ty::CrateAnalysis,\n                                            incremental_hashes_map: IncrementalHashesMap,\n@@ -1084,6 +1104,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: write::OngoingCrateTranslation)\n                                -> (CompileResult, trans::CrateTranslation) {\n@@ -1102,6 +1123,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n \n /// Run the linker on any artifacts that resulted from the LLVM run.\n /// This should produce either a finished executable or library.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n@@ -1123,7 +1145,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n         match *output_type {\n             OutputType::Exe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output, crate_name, outputs);\n+                    let p = ::rustc_trans_utils::link::filename_for_input(sess, *output, crate_name, outputs);\n                     out_filenames.push(p);\n                 }\n             }\n@@ -1233,15 +1255,15 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     if base.is_empty() {\n         base.extend(attr_types);\n         if base.is_empty() {\n-            base.push(link::default_output_for_target(session));\n+            base.push(::rustc_trans_utils::link::default_output_for_target(session));\n         }\n         base.sort();\n         base.dedup();\n     }\n \n     base.into_iter()\n         .filter(|crate_type| {\n-            let res = !link::invalid_output_for_target(session, *crate_type);\n+            let res = !rustc_trans_utils::link::invalid_output_for_target(session, *crate_type);\n \n             if !res {\n                 session.warn(&format!(\"dropping unsupported crate type `{}` for target `{}`\","}, {"sha": "d59b9f5402a732c4f2f38389988bedc27ddaf1e9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -54,6 +54,7 @@ extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n #[cfg(feature=\"llvm\")]\n extern crate rustc_trans;\n+extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n extern crate serialize;\n #[macro_use]\n@@ -68,7 +69,9 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n+#[cfg(feature=\"llvm\")]\n use rustc_trans::back::link;\n+#[cfg(feature=\"llvm\")]\n use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n@@ -83,6 +86,8 @@ use rustc::middle::cstore::MetadataLoader;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::{time, ErrorReported};\n+#[cfg(not(feature=\"llvm\"))]\n+use rustc_back::target::Target;\n \n use serialize::json::ToJson;\n \n@@ -95,6 +100,8 @@ use std::ffi::OsString;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n use std::path::PathBuf;\n+#[cfg(not(feature=\"llvm\"))]\n+use std::path::Path;\n use std::process::{self, Command, Stdio};\n use std::rc::Rc;\n use std::str;\n@@ -112,6 +119,7 @@ pub mod test;\n \n pub mod driver;\n pub mod pretty;\n+#[cfg(feature=\"llvm\")]\n pub mod target_features;\n mod derive_registrar;\n \n@@ -220,6 +228,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::enable_llvm_debug();\n     }\n \n@@ -249,10 +258,12 @@ pub fn run_compiler<'a>(args: &[String],\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );\n+    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n+    #[cfg(feature=\"llvm\")]\n     target_features::add_configuration(&mut cfg, &sess);\n     sess.parse_sess.config = cfg;\n \n@@ -528,9 +539,11 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n+                #[cfg(feature=\"llvm\")]\n                 rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n+                #[cfg(feature=\"llvm\")]\n                 target_features::add_configuration(&mut cfg, &sess);\n                 sess.parse_sess.config = cfg;\n                 let should_stop =\n@@ -723,14 +736,14 @@ impl RustcDefaultCalls {\n                     };\n                     let attrs = attrs.as_ref().unwrap();\n                     let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n-                    let id = link::find_crate_name(Some(sess), attrs, input);\n+                    let id = rustc_trans_utils::link::find_crate_name(Some(sess), attrs, input);\n                     if *req == PrintRequest::CrateName {\n                         println!(\"{}\", id);\n                         continue;\n                     }\n                     let crate_types = driver::collect_crate_types(sess, attrs);\n                     for &style in &crate_types {\n-                        let fname = link::filename_for_input(sess, style, &id, &t_outputs);\n+                        let fname = rustc_trans_utils::link::filename_for_input(sess, style, &id, &t_outputs);\n                         println!(\"{}\",\n                                  fname.file_name()\n                                       .unwrap()\n@@ -779,20 +792,25 @@ impl RustcDefaultCalls {\n                 }\n                 PrintRequest::RelocationModels => {\n                     println!(\"Available relocation models:\");\n+                    #[cfg(features=\"llvm\")]\n                     for &(name, _) in RELOC_MODEL_ARGS.iter() {\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::CodeModels => {\n                     println!(\"Available code models:\");\n+                    #[cfg(features=\"llvm\")]\n                     for &(name, _) in CODE_GEN_MODEL_ARGS.iter(){\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n+                    #[cfg(feature=\"llvm\")]\n                     rustc_trans::print(*req, sess);\n+                    #[cfg(not(feature=\"llvm\"))]\n+                    panic!(\"LLVM not supported by this rustc\")\n                 }\n             }\n         }\n@@ -831,6 +849,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_version();\n     }\n }\n@@ -1128,6 +1147,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_passes();\n         return None;\n     }\n@@ -1255,6 +1275,7 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    #[cfg(feature=\"llvm\")]\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);"}, {"sha": "7f65a8b97cd669b76297f14ea01d9681151982bd", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -14,6 +14,7 @@ use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n+#[cfg(feature=\"llvm\")]\n use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n@@ -113,6 +114,7 @@ fn test_env<F>(source_string: &str,\n                                        diagnostic_handler,\n                                        Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n+    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {"}, {"sha": "4a92a5798604af01b25330400c3873acc0b0a3ea", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -26,6 +26,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "e2db1721b262ef248aae451236a28eb5856e0470", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 120, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate rustc_trans_utils;\n+\n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n-use rustc::session::config::{self, NoDebugInfo, OutputFilenames, Input, OutputType};\n+use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n+use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n                             NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use CrateTranslation;\n@@ -44,9 +46,7 @@ use std::process::Command;\n use std::str;\n use flate2::Compression;\n use flate2::write::DeflateEncoder;\n-use syntax::ast;\n use syntax::attr;\n-use syntax_pos::Span;\n \n /// The LLVM module name containing crate-metadata. This includes a `.` on\n /// purpose, so it cannot clash with the name of a user-defined module.\n@@ -88,55 +88,7 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n-\n-pub fn find_crate_name(sess: Option<&Session>,\n-                       attrs: &[ast::Attribute],\n-                       input: &Input) -> String {\n-    let validate = |s: String, span: Option<Span>| {\n-        cstore::validate_crate_name(sess, &s, span);\n-        s\n-    };\n-\n-    // Look in attributes 100% of the time to make sure the attribute is marked\n-    // as used. After doing this, however, we still prioritize a crate name from\n-    // the command line over one found in the #[crate_name] attribute. If we\n-    // find both we ensure that they're the same later on as well.\n-    let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                               .and_then(|at| at.value_str().map(|s| (at, s)));\n-\n-    if let Some(sess) = sess {\n-        if let Some(ref s) = sess.opts.crate_name {\n-            if let Some((attr, name)) = attr_crate_name {\n-                if name != &**s {\n-                    let msg = format!(\"--crate-name and #[crate_name] are \\\n-                                       required to match, but `{}` != `{}`\",\n-                                      s, name);\n-                    sess.span_err(attr.span, &msg);\n-                }\n-            }\n-            return validate(s.clone(), None);\n-        }\n-    }\n-\n-    if let Some((attr, s)) = attr_crate_name {\n-        return validate(s.to_string(), Some(attr.span));\n-    }\n-    if let Input::File(ref path) = *input {\n-        if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n-            if s.starts_with(\"-\") {\n-                let msg = format!(\"crate names cannot start with a `-`, but \\\n-                                   `{}` has a leading hyphen\", s);\n-                if let Some(sess) = sess {\n-                    sess.err(&msg);\n-                }\n-            } else {\n-                return validate(s.replace(\"-\", \"_\"), None);\n-            }\n-        }\n-    }\n-\n-    \"rust_out\".to_string()\n-}\n+pub use self::rustc_trans_utils::link::{find_crate_name, filename_for_input, default_output_for_target, invalid_output_for_target};\n \n pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n     let krate_dep_node = &DepNode::new_no_params(DepKind::Krate);\n@@ -252,37 +204,6 @@ pub fn link_binary(sess: &Session,\n     out_filenames\n }\n \n-\n-/// Returns default crate type for target\n-///\n-/// Default crate type is used when crate type isn't provided neither\n-/// through cmd line arguments nor through crate attributes\n-///\n-/// It is CrateTypeExecutable for all platforms but iOS as there is no\n-/// way to run iOS binaries anyway without jailbreaking and\n-/// interaction with Rust code through static library is the only\n-/// option for now\n-pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n-    if !sess.target.target.options.executables {\n-        config::CrateTypeStaticlib\n-    } else {\n-        config::CrateTypeExecutable\n-    }\n-}\n-\n-/// Checks if target supports crate_type as output\n-pub fn invalid_output_for_target(sess: &Session,\n-                                 crate_type: config::CrateType) -> bool {\n-    match (sess.target.target.options.dynamic_linking,\n-           sess.target.target.options.executables, crate_type) {\n-        (false, _, config::CrateTypeCdylib) |\n-        (false, _, config::CrateTypeProcMacro) |\n-        (false, _, config::CrateTypeDylib) => true,\n-        (_, false, config::CrateTypeExecutable) => true,\n-        _ => false\n-    }\n-}\n-\n fn is_writeable(p: &Path) -> bool {\n     match p.metadata() {\n         Err(..) => true,\n@@ -299,42 +220,6 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n     out_filename\n }\n \n-pub fn filename_for_input(sess: &Session,\n-                          crate_type: config::CrateType,\n-                          crate_name: &str,\n-                          outputs: &OutputFilenames) -> PathBuf {\n-    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n-\n-    match crate_type {\n-        config::CrateTypeRlib => {\n-            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n-        }\n-        config::CrateTypeCdylib |\n-        config::CrateTypeProcMacro |\n-        config::CrateTypeDylib => {\n-            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n-                                    &sess.target.target.options.dll_suffix);\n-            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n-                                                suffix))\n-        }\n-        config::CrateTypeStaticlib => {\n-            let (prefix, suffix) = (&sess.target.target.options.staticlib_prefix,\n-                                    &sess.target.target.options.staticlib_suffix);\n-            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n-                                                suffix))\n-        }\n-        config::CrateTypeExecutable => {\n-            let suffix = &sess.target.target.options.exe_suffix;\n-            let out_filename = outputs.path(OutputType::Exe);\n-            if suffix.is_empty() {\n-                out_filename.to_path_buf()\n-            } else {\n-                out_filename.with_extension(&suffix[1..])\n-            }\n-        }\n-    }\n-}\n-\n pub fn each_linked_rlib(sess: &Session,\n                         f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();"}, {"sha": "4fa32389b71043c9572b067a5f080d732d1a1ef9", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -0,0 +1,25 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_trans_utils\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_trans_utils\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+test = false\n+\n+[dependencies]\n+rustc = { path = \"../librustc\" }\n+rustc_allocator = { path = \"../librustc_allocator\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_bitflags = { path = \"../librustc_bitflags\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }\n+rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "81e83076f8c0c9812f0059455aa36e08648811d5", "filename": "src/librustc_trans_utils/lib.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_trans_utils\"]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(const_fn)]\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n+#![feature(i128_type)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(slice_patterns)]\n+#![feature(conservative_impl_trait)]\n+\n+extern crate rustc;\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+pub mod link;"}, {"sha": "29bb062d34cf6212833d8f8c66a79a3fdee53193", "filename": "src/librustc_trans_utils/link.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7314c7cafc657afa6b98eb9c4958e56a82129bb/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=b7314c7cafc657afa6b98eb9c4958e56a82129bb", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::session::config::{self, /*NoDebugInfo,*/ OutputFilenames, Input, OutputType};\n+/*use rustc::session::filesearch;\n+use rustc::session::search_paths::PathKind;\n+*/use rustc::session::Session;\n+use rustc::middle::cstore;/*::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n+                            NativeLibraryKind};*/\n+/*use rustc::middle::dependency_format::Linkage;\n+use rustc::util::common::time;\n+use rustc::util::fs::fix_windows_verbatim_for_gcc;\n+use rustc::dep_graph::{DepKind, DepNode};\n+use rustc::hir::def_id::CrateNum;\n+use rustc::hir::svh::Svh;\n+use rustc_back::tempdir::TempDir;\n+use rustc_back::{PanicStrategy, RelroLevel};\n+use rustc_incremental::IncrementalHashesMap;*/\n+\n+/*use std::ascii;\n+use std::char;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, Read, Write};\n+use std::mem;\n+*/use std::path::PathBuf;/*{Path, PathBuf};\n+use std::process::Command;\n+use std::str;*/\n+use syntax::ast;\n+//use syntax::attr;\n+use syntax_pos::Span;\n+\n+pub fn find_crate_name(sess: Option<&Session>,\n+                       attrs: &[ast::Attribute],\n+                       input: &Input) -> String {\n+    let validate = |s: String, span: Option<Span>| {\n+        cstore::validate_crate_name(sess, &s, span);\n+        s\n+    };\n+\n+    // Look in attributes 100% of the time to make sure the attribute is marked\n+    // as used. After doing this, however, we still prioritize a crate name from\n+    // the command line over one found in the #[crate_name] attribute. If we\n+    // find both we ensure that they're the same later on as well.\n+    let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n+                               .and_then(|at| at.value_str().map(|s| (at, s)));\n+\n+    if let Some(sess) = sess {\n+        if let Some(ref s) = sess.opts.crate_name {\n+            if let Some((attr, name)) = attr_crate_name {\n+                if name != &**s {\n+                    let msg = format!(\"--crate-name and #[crate_name] are \\\n+                                       required to match, but `{}` != `{}`\",\n+                                      s, name);\n+                    sess.span_err(attr.span, &msg);\n+                }\n+            }\n+            return validate(s.clone(), None);\n+        }\n+    }\n+\n+    if let Some((attr, s)) = attr_crate_name {\n+        return validate(s.to_string(), Some(attr.span));\n+    }\n+    if let Input::File(ref path) = *input {\n+        if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n+            if s.starts_with(\"-\") {\n+                let msg = format!(\"crate names cannot start with a `-`, but \\\n+                                   `{}` has a leading hyphen\", s);\n+                if let Some(sess) = sess {\n+                    sess.err(&msg);\n+                }\n+            } else {\n+                return validate(s.replace(\"-\", \"_\"), None);\n+            }\n+        }\n+    }\n+\n+    \"rust_out\".to_string()\n+}\n+\n+pub fn filename_for_input(sess: &Session,\n+                          crate_type: config::CrateType,\n+                          crate_name: &str,\n+                          outputs: &OutputFilenames) -> PathBuf {\n+    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n+\n+    match crate_type {\n+        config::CrateTypeRlib => {\n+            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n+        }\n+        config::CrateTypeCdylib |\n+        config::CrateTypeProcMacro |\n+        config::CrateTypeDylib => {\n+            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n+                                    &sess.target.target.options.dll_suffix);\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n+        }\n+        config::CrateTypeStaticlib => {\n+            let (prefix, suffix) = (&sess.target.target.options.staticlib_prefix,\n+                                    &sess.target.target.options.staticlib_suffix);\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n+        }\n+        config::CrateTypeExecutable => {\n+            let suffix = &sess.target.target.options.exe_suffix;\n+            let out_filename = outputs.path(OutputType::Exe);\n+            if suffix.is_empty() {\n+                out_filename.to_path_buf()\n+            } else {\n+                out_filename.with_extension(&suffix[1..])\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns default crate type for target\n+///\n+/// Default crate type is used when crate type isn't provided neither\n+/// through cmd line arguments nor through crate attributes\n+///\n+/// It is CrateTypeExecutable for all platforms but iOS as there is no\n+/// way to run iOS binaries anyway without jailbreaking and\n+/// interaction with Rust code through static library is the only\n+/// option for now\n+pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n+    if !sess.target.target.options.executables {\n+        config::CrateTypeStaticlib\n+    } else {\n+        config::CrateTypeExecutable\n+    }\n+}\n+\n+/// Checks if target supports crate_type as output\n+pub fn invalid_output_for_target(sess: &Session,\n+                                 crate_type: config::CrateType) -> bool {\n+    match (sess.target.target.options.dynamic_linking,\n+           sess.target.target.options.executables, crate_type) {\n+        (false, _, config::CrateTypeCdylib) |\n+        (false, _, config::CrateTypeProcMacro) |\n+        (false, _, config::CrateTypeDylib) => true,\n+        (_, false, config::CrateTypeExecutable) => true,\n+        _ => false\n+    }\n+}"}]}