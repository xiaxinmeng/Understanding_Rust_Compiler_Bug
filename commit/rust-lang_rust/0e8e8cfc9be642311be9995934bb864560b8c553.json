{"sha": "0e8e8cfc9be642311be9995934bb864560b8c553", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOGU4Y2ZjOWJlNjQyMzExYmU5OTk1OTM0YmI4NjQ1NjBiOGM1NTM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-26T14:53:11Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-26T19:09:09Z"}, "message": "Basic framework for structured logging", "tree": {"sha": "5224670fb7aca7851ef9b62779e2d55063f8997d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5224670fb7aca7851ef9b62779e2d55063f8997d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e8e8cfc9be642311be9995934bb864560b8c553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8e8cfc9be642311be9995934bb864560b8c553", "html_url": "https://github.com/rust-lang/rust/commit/0e8e8cfc9be642311be9995934bb864560b8c553", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e8e8cfc9be642311be9995934bb864560b8c553/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac698826d729001fb502956cb6b34f19249909ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac698826d729001fb502956cb6b34f19249909ce", "html_url": "https://github.com/rust-lang/rust/commit/ac698826d729001fb502956cb6b34f19249909ce"}], "stats": {"total": 119, "additions": 73, "deletions": 46}, "files": [{"sha": "bd4be213b91213c2c72275ec5f96d11be7a73714", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -20,3 +20,7 @@ compiletest_rs = \"*\"\n regex = \"*\"\n regex_macros = \"*\"\n lazy_static = \"*\"\n+\n+[features]\n+\n+structured_logging = []\n\\ No newline at end of file"}, {"sha": "03d4da1ab7f403d1b5cc3efbbcc78b34365c41b0", "filename": "src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -7,6 +7,7 @@ use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n use std::f64::consts as f64;\n+use utils::span_lint;\n \n declare_lint! {\n     pub APPROX_CONSTANT,\n@@ -51,7 +52,7 @@ fn check_known_consts(cx: &Context, span: Span, str: &str, module: &str) {\n \tif let Ok(value) = str.parse::<f64>() {\n \t\tfor &(constant, name) in KNOWN_CONSTS {\n \t\t\tif within_epsilon(constant, value) {\n-\t\t\t\tcx.span_lint(APPROX_CONSTANT, span, &format!(\n+\t\t\t\tspan_lint(cx, APPROX_CONSTANT, span, &format!(\n \t\t\t\t\t\"Approximate value of {}::{} found, consider using it directly.\", module, &name));\n \t\t\t}\n \t\t}"}, {"sha": "647e471c45e5fec6cb54977ff3fd92fc8af17b06", "filename": "src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::*;\n use syntax::ptr::P;\n use syntax::codemap::{Span, ExpnInfo};\n use syntax::parse::token::InternedString;\n-use utils::{in_macro, match_path};\n+use utils::{in_macro, match_path, span_lint};\n \n declare_lint! { pub INLINE_ALWAYS, Warn,\n     \"#[inline(always)] is usually a bad idea.\"}\n@@ -100,7 +100,7 @@ fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n \t\t\tif values.len() != 1 || inline != &\"inline\" { continue; }\n \t\t\tif let MetaWord(ref always) = values[0].node {\n \t\t\t\tif always != &\"always\" { continue; }\n-\t\t\t\tcx.span_lint(INLINE_ALWAYS, attr.span, &format!(\n+\t\t\t\tspan_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n \t\t\t\t\t\"You have declared #[inline(always)] on {}. This \\\n \t\t\t\t\tis usually a bad idea. Are you sure?\", \n \t\t\t\t\tident.as_str()));"}, {"sha": "5ce574007bca3472fb077e7de21f58191e9289ec", "filename": "src/bit_mask.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -6,6 +6,7 @@ use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n+use utils::span_lint;\n \n declare_lint! {\n     pub BAD_BIT_MASK,\n@@ -95,41 +96,41 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n \t\tBiEq | BiNe => match bit_op {\n \t\t\tBiBitAnd => if mask_value & cmp_value != mask_value {\n \t\t\t\tif cmp_value != 0 {\n-\t\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\n+\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n \t\t\t\t\t\t\"incompatible bit mask: _ & {} can never be equal to {}\", \n \t\t\t\t\t\tmask_value, cmp_value));\n \t\t\t\t}\n \t\t\t} else { \n \t\t\t\tif mask_value == 0 {\n-\t\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, \n+\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, \n \t\t\t\t\t\t&format!(\"&-masking with zero\"));\n \t\t\t\t}\n \t\t\t},\n \t\t\tBiBitOr => if mask_value | cmp_value != cmp_value {\n-\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\n+\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n \t\t\t\t\t\"incompatible bit mask: _ | {} can never be equal to {}\", \n \t\t\t\t\tmask_value, cmp_value));\n \t\t\t},\n \t\t\t_ => ()\n \t\t},\n \t\tBiLt | BiGe => match bit_op {\n \t\t\tBiBitAnd => if mask_value < cmp_value {\n-\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\n+\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n \t\t\t\t\t\"incompatible bit mask: _ & {} will always be lower than {}\", \n \t\t\t\t\tmask_value, cmp_value));\n \t\t\t} else { \n \t\t\t\tif mask_value == 0 {\n-\t\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, \n+\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, \n \t\t\t\t\t\t&format!(\"&-masking with zero\"));\n \t\t\t\t}\n \t\t\t},\n \t\t\tBiBitOr => if mask_value >= cmp_value {\n-\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\n+\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n \t\t\t\t\t\"incompatible bit mask: _ | {} will never be lower than {}\", \n \t\t\t\t\tmask_value, cmp_value));\n \t\t\t} else {\n \t\t\t\tif mask_value < cmp_value {\n-\t\t\t\t\tcx.span_lint(INEFFECTIVE_BIT_MASK, *span, &format!(\n+\t\t\t\t\tspan_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n \t\t\t\t\t\t\"ineffective bit mask: x | {} compared to {} is the same as x compared directly\", \n \t\t\t\t\t\tmask_value, cmp_value)); \n \t\t\t\t}\n@@ -138,22 +139,22 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n \t\t},\n \t\tBiLe | BiGt => match bit_op {\n \t\t\tBiBitAnd => if mask_value <= cmp_value {\n-\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\n+\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n \t\t\t\t\t\"incompatible bit mask: _ & {} will never be higher than {}\", \n \t\t\t\t\tmask_value, cmp_value));\n \t\t\t} else { \n \t\t\t\tif mask_value == 0 {\n-\t\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, \n+\t\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, \n \t\t\t\t\t\t&format!(\"&-masking with zero\"));\n \t\t\t\t}\n \t\t\t},\n \t\t\tBiBitOr => if mask_value > cmp_value {\n-\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\n+\t\t\t\tspan_lint(cx, BAD_BIT_MASK, *span, &format!(\n \t\t\t\t\t\"incompatible bit mask: _ | {} will always be higher than {}\", \n \t\t\t\t\tmask_value, cmp_value));\t\t\t\t\n \t\t\t} else {\n \t\t\t\tif mask_value < cmp_value {\n-\t\t\t\t\tcx.span_lint(INEFFECTIVE_BIT_MASK, *span, &format!(\n+\t\t\t\t\tspan_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n \t\t\t\t\t\t\"ineffective bit mask: x | {} compared to {} is the same as x compared directly\", \n \t\t\t\t\t\tmask_value, cmp_value)); \n \t\t\t\t}"}, {"sha": "dc2d385223764675692e8eb5d41b8be7e55425e8", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -19,7 +19,7 @@ use syntax::ast::*;\n use syntax::ptr::P;\n use syntax::codemap::{Span, Spanned, ExpnInfo};\n use syntax::print::pprust::expr_to_string;\n-use utils::in_macro;\n+use utils::{in_macro, span_lint};\n \n declare_lint! {\n     pub COLLAPSIBLE_IF,\n@@ -47,7 +47,7 @@ fn check_expr_expd(cx: &Context, e: &Expr, info: Option<&ExpnInfo>) {\n \tif let ExprIf(ref check, ref then, None) = e.node {\n \t\tif let Some(&Expr{ node: ExprIf(ref check_inner, _, None), ..}) = \n \t\t\t\tsingle_stmt_of_block(then) {\n-\t\t\tcx.span_lint(COLLAPSIBLE_IF, e.span, &format!(\n+\t\t\tspan_lint(cx, COLLAPSIBLE_IF, e.span, &format!(\n \t\t\t\t\"This if statement can be collapsed. Try: if {} && {}\\n{:?}\", \n \t\t\t\tcheck_to_string(check), check_to_string(check_inner), e));\n \t\t}"}, {"sha": "10dbca2cf3c2146d2b58ff203c01a5e7282e4339", "filename": "src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -3,6 +3,7 @@ use syntax::ast::*;\n use syntax::ast_util as ast_util;\n use syntax::ptr::P;\n use syntax::codemap as code;\n+use utils::span_lint;\n \n declare_lint! {\n     pub EQ_OP,\n@@ -21,7 +22,7 @@ impl LintPass for EqOp {\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_cmp_or_bit(op) && is_exp_equal(left, right) {\n-                cx.span_lint(EQ_OP, e.span, &format!(\n+                span_lint(cx, EQ_OP, e.span, &format!(\n \t\t\t\t\t\"equal expressions as operands to {}\", \n \t\t\t\t\t\tast_util::binop_to_string(op.node)));\n             }"}, {"sha": "18011c618316b8918d1861739624d95bee038d01", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -3,6 +3,8 @@ use rustc::lint::{Context, LintPass, LintArray, Lint, Level};\n use syntax::codemap::{Span, Spanned};\n use syntax::print::pprust::expr_to_string;\n \n+use utils::span_lint;\n+\n \n #[allow(missing_copy_implementations)]\n pub struct EtaPass;\n@@ -48,7 +50,7 @@ impl LintPass for EtaPass {\n                             return\n                         }\n                     }\n-                    cx.span_lint(REDUNDANT_CLOSURE, expr.span,\n+                    span_lint(cx, REDUNDANT_CLOSURE, expr.span,\n                                  &format!(\"Redundant closure found, consider using `{}` in its place\",\n                                           expr_to_string(caller))[..])\n                 }"}, {"sha": "b3fb3e05447926e15c6ec19a3123624e7c7f0770", "filename": "src/identity_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -7,7 +7,7 @@ use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n \n-use utils::snippet;\n+use utils::{span_lint, snippet};\n \n declare_lint! { pub IDENTITY_OP, Warn,\n     \"Warn on identity operations, e.g. '_ + 0'\"}\n@@ -48,7 +48,7 @@ impl LintPass for IdentityOp {\n \n fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n     if have_lit(cx, e, m) {\n-        cx.span_lint(IDENTITY_OP, span, &format!(\n+        span_lint(cx, IDENTITY_OP, span, &format!(\n             \"The operation is ineffective. Consider reducing it to '{}'\", \n            snippet(cx, arg, \"..\")));\n     }"}, {"sha": "7e71df2dd7904e34061489eda11a19c768a5a393", "filename": "src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -10,6 +10,7 @@ use rustc::middle::def::{DefTy, DefStruct, DefTrait};\n use syntax::codemap::{Span, Spanned};\n use syntax::ast::*;\n use misc::walk_ty;\n+use utils::span_lint;\n \n declare_lint!(pub LEN_ZERO, Warn,\n               \"Warn when .is_empty() could be used instead of checking .len()\");\n@@ -54,10 +55,10 @@ fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n \t}\n \n \tif !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n-\t\t//cx.span_lint(LEN_WITHOUT_IS_EMPTY, item.span, &format!(\"trait {}\", item.ident.as_str()));\n+\t\t//span_lint(cx, LEN_WITHOUT_IS_EMPTY, item.span, &format!(\"trait {}\", item.ident.as_str()));\n \t\tfor i in trait_items {\n \t\t\tif is_named_self(i, \"len\") {\n-\t\t\t\tcx.span_lint(LEN_WITHOUT_IS_EMPTY, i.span,\n+\t\t\t\tspan_lint(cx, LEN_WITHOUT_IS_EMPTY, i.span,\n \t\t\t\t\t&format!(\"Trait '{}' has a '.len(_: &Self)' method, but no \\\n \t\t\t\t\t\t'.is_empty(_: &Self)' method. Consider adding one.\", \n \t\t\t\t\t\titem.ident.as_str()));\n@@ -76,7 +77,7 @@ fn check_impl_items(cx: &Context, item: &Item, impl_items: &[P<ImplItem>]) {\n \t\tfor i in impl_items {\n \t\t\tif is_named_self(i, \"len\") {\n \t\t\t\tlet s = i.span;\n-\t\t\t\tcx.span_lint(LEN_WITHOUT_IS_EMPTY, \n+\t\t\t\tspan_lint(cx, LEN_WITHOUT_IS_EMPTY, \n \t\t\t\t\tSpan{ lo: s.lo, hi: s.lo, expn_id: s.expn_id },\n \t\t\t\t\t&format!(\"Item '{}' has a '.len(_: &Self)' method, but no \\\n \t\t\t\t\t\t'.is_empty(_: &Self)' method. Consider adding one.\", \n@@ -107,7 +108,7 @@ fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n \tif let &Spanned{node: LitInt(0, _), ..} = lit {\n \t\tif method.node.as_str() == \"len\" && args.len() == 1 &&\n \t\t\thas_is_empty(cx, &*args[0]) {\n-\t\t\tcx.span_lint(LEN_ZERO, span, &format!(\n+\t\t\tspan_lint(cx, LEN_ZERO, span, &format!(\n \t\t\t\t\"Consider replacing the len comparison with '{}_.is_empty()'\",\n \t\t\t\t\tempty))\n \t\t}"}, {"sha": "a140671b1bbd42b96ffb3cb28cbd2a1c667e77d1", "filename": "src/misc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -8,7 +8,7 @@ use rustc::middle::ty;\n use syntax::codemap::{Span, Spanned};\n \n use types::span_note_and_lint;\n-use utils::{match_path, snippet};\n+use utils::{match_path, snippet, span_lint};\n \n pub fn walk_ty<'t>(ty: ty::Ty<'t>) -> ty::Ty<'t> {\n \tmatch ty.sty {\n@@ -72,7 +72,7 @@ impl LintPass for StrToStringPass {\n             ast::ExprMethodCall(ref method, _, ref args)\n                 if method.node.as_str() == \"to_string\"\n                 && is_str(cx, &*args[0]) => {\n-                cx.span_lint(STR_TO_STRING, expr.span, \"str.to_owned() is faster\");\n+                span_lint(cx, STR_TO_STRING, expr.span, \"str.to_owned() is faster\");\n             },\n             _ => ()\n         }\n@@ -100,7 +100,7 @@ impl LintPass for TopLevelRefPass {\n     fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         for ref arg in decl.inputs.iter() {\n             if let PatIdent(BindByRef(_), _, _) = arg.pat.node {\n-                cx.span_lint(\n+                span_lint(cx, \n                     TOPLEVEL_REF_ARG,\n                     arg.pat.span,\n                     \"`ref` directly on a function argument is ignored. Have you considered using a reference type instead?\"\n@@ -136,7 +136,7 @@ impl LintPass for CmpNan {\n \n fn check_nan(cx: &Context, path: &Path, span: Span) {\n \tpath.segments.last().map(|seg| if seg.identifier.as_str() == \"NAN\" {\n-\t\tcx.span_lint(CMP_NAN, span, \"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n+\t\tspan_lint(cx, CMP_NAN, span, \"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n \t});\n }\n \n@@ -155,7 +155,7 @@ impl LintPass for FloatCmp {\n \t\tif let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n \t\t\tlet op = cmp.node;\n \t\t\tif (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n-\t\t\t\tcx.span_lint(FLOAT_CMP, expr.span, &format!(\n+\t\t\t\tspan_lint(cx, FLOAT_CMP, expr.span, &format!(\n \t\t\t\t\t\"{}-Comparison of f32 or f64 detected. You may want to change this to 'abs({} - {}) < epsilon' for some suitable value of epsilon\",\n \t\t\t\t\tbinop_to_string(op), snippet(cx, left.span, \"..\"), \n \t\t\t\t\tsnippet(cx, right.span, \"..\")));\n@@ -186,7 +186,7 @@ impl LintPass for Precedence {\n \tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n \t\tif let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n \t\t\tif is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n-\t\t\t\tcx.span_lint(PRECEDENCE, expr.span, \n+\t\t\t\tspan_lint(cx, PRECEDENCE, expr.span, \n \t\t\t\t\t\"Operator precedence can trip the unwary. Consider adding parenthesis to the subexpression.\");\n \t\t\t}\n \t\t}\n@@ -241,7 +241,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n \t\t\tlet name = ident.as_str();\n \t\t\tif name == \"to_string\" || \n \t\t\t   name == \"to_owned\" && is_str_arg(cx, args) {\n-\t\t\t\tcx.span_lint(CMP_OWNED, expr.span, &format!(\n+\t\t\t\tspan_lint(cx, CMP_OWNED, expr.span, &format!(\n \t\t\t\t\t\"this creates an owned instance just for comparison. \\\n \t\t\t\t\tConsider using {}.as_slice() to compare without allocation\",\n \t\t\t\t\tsnippet(cx, other_span, \"..\")))\n@@ -251,7 +251,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n \t\t\tif let &ExprPath(None, ref path) = &path.node {\n \t\t\t\tif match_path(path, &[\"String\", \"from_str\"]) ||\n \t\t\t\t\t\tmatch_path(path, &[\"String\", \"from\"]) {\n-\t\t\t\t\tcx.span_lint(CMP_OWNED, expr.span, &format!(\n+\t\t\t\t\tspan_lint(cx, CMP_OWNED, expr.span, &format!(\n \t\t\t\t\t\"this creates an owned instance just for comparison. \\\n \t\t\t\t\tConsider using {}.as_slice() to compare without allocation\",\n \t\t\t\t\tsnippet(cx, other_span, \"..\")))"}, {"sha": "73e97ae31f42896296a4453d3c99eaee5d9c4b6c", "filename": "src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -3,7 +3,7 @@ use syntax::ast::*;\n use rustc::lint::{Context, LintPass, LintArray, Lint};\n use rustc::middle::ty::{TypeVariants, TypeAndMut, TyRef};\n use syntax::codemap::{BytePos, ExpnInfo, Span};\n-use utils::in_macro;\n+use utils::{in_macro, span_lint};\n \n declare_lint!(pub MUT_MUT, Warn,\n               \"Warn on usage of double-mut refs, e.g. '&mut &mut ...'\");\n@@ -22,7 +22,7 @@ impl LintPass for MutMut {\n \t}\n \t\n \tfn check_ty(&mut self, cx: &Context, ty: &Ty) {\n-\t\tunwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| cx.span_lint(MUT_MUT, \n+\t\tunwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| span_lint(cx, MUT_MUT, \n \t\t\tty.span, \"Generally you want to avoid &mut &mut _ if possible.\"))\n \t}\n }\n@@ -39,12 +39,12 @@ fn check_expr_expd(cx: &Context, expr: &Expr, info: Option<&ExpnInfo>) {\n \t\n \tunwrap_addr(expr).map_or((), |e| {\n \t\tunwrap_addr(e).map(|_| {\n-\t\t\tcx.span_lint(MUT_MUT, expr.span, \n+\t\t\tspan_lint(cx, MUT_MUT, expr.span, \n \t\t\t\t\"Generally you want to avoid &mut &mut _ if possible.\")\n \t\t}).unwrap_or_else(|| {\n \t\t\tif let TyRef(_, TypeAndMut{ty: _, mutbl: MutMutable}) = \n \t\t\t\t\tcx.tcx.expr_ty(e).sty {\n-\t\t\t\tcx.span_lint(MUT_MUT, expr.span,\n+\t\t\t\tspan_lint(cx, MUT_MUT, expr.span,\n \t\t\t\t\t\"This expression mutably borrows a mutable reference. \\\n \t\t\t\t\tConsider reborrowing\")\n \t\t\t}"}, {"sha": "35d921e8fa1f1cb6e29cdadbf35f3e2daf1065be", "filename": "src/needless_bool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -10,7 +10,7 @@ use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n-use utils::de_p;\n+use utils::{de_p, span_lint};\n \n declare_lint! {\n     pub NEEDLESS_BOOL,\n@@ -30,16 +30,16 @@ impl LintPass for NeedlessBool {\n         if let ExprIf(_, ref then_block, Option::Some(ref else_expr)) = e.node {\n \t\t\tmatch (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n \t\t\t\t(Option::Some(true), Option::Some(true)) => { \n-\t\t\t\t\tcx.span_lint(NEEDLESS_BOOL, e.span, \n+\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n \t\t\t\t\t\t\"your if-then-else expression will always return true\"); },\n \t\t\t\t(Option::Some(true), Option::Some(false)) => { \n-\t\t\t\t\tcx.span_lint(NEEDLESS_BOOL, e.span, \n+\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n \t\t\t\t\t\t\"you can reduce your if-statement to its predicate\"); },\n \t\t\t\t(Option::Some(false), Option::Some(true)) => { \n-\t\t\t\t\tcx.span_lint(NEEDLESS_BOOL, e.span, \n+\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n \t\t\t\t\t\t\"you can reduce your if-statement to '!' + your predicate\"); },\n \t\t\t\t(Option::Some(false), Option::Some(false)) => { \n-\t\t\t\t\tcx.span_lint(NEEDLESS_BOOL, e.span, \n+\t\t\t\t\tspan_lint(cx, NEEDLESS_BOOL, e.span, \n \t\t\t\t\t\t\"your if-then-else expression will always return false\"); },\n \t\t\t\t_ => ()\n \t\t\t}"}, {"sha": "dad4e48c832d0e8451d3f5f98a0cd871c779022d", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -11,6 +11,7 @@ use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n use types::match_ty_unwrap;\n+use utils::span_lint;\n \n declare_lint! {\n     pub PTR_ARG,\n@@ -58,10 +59,10 @@ fn check_fn(cx: &Context, decl: &FnDecl) {\n fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n \tmatch_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty, \n \t\t\t&[\"String\"]).map_or((), |_| {\n-\t\tcx.span_lint(PTR_ARG, span,\n+\t\tspan_lint(cx, PTR_ARG, span,\n \t\t\t\"Writing '&String' instead of '&str' involves a new Object \\\n \t\t\twhere a slices will do. Consider changing the type to &str\")\n-\t}), |_| cx.span_lint(PTR_ARG, span, \"Writing '&Vec<_>' instead of \\\n+\t}), |_| span_lint(cx, PTR_ARG, span, \"Writing '&Vec<_>' instead of \\\n \t\t\t'&[_]' involves one more reference and cannot be used with \\\n \t\t\tnon-vec-based slices. Consider changing the type to &[...]\")\n \t)"}, {"sha": "8c46fed2c1f89bc49da2d8d1189cb3843cc7830f", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -6,6 +6,8 @@ use syntax::ast::*;\n use rustc::lint::{Context, LintPass, LintArray, Lint, Level};\n use syntax::codemap::Span;\n \n+use utils::span_lint;\n+\n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n pub struct TypePass;\n@@ -40,7 +42,7 @@ pub fn match_ty_unwrap<'a>(ty: &'a Ty, segments: &[&str]) -> Option<&'a [P<Ty>]>\n \n /// Lets me span a note only if the lint is shown\n pub fn span_note_and_lint(cx: &Context, lint: &'static Lint, span: Span, msg: &str, note: &str) {\n-    cx.span_lint(lint, span, msg);\n+    span_lint(cx, lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n         cx.sess().span_note(span, note);\n     }"}, {"sha": "9b908c3f94f131d1d9ab0f6f26414449be322d7f", "filename": "src/unicode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -1,6 +1,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::{BytePos, Span};\n+use utils::span_lint;\n \n declare_lint!{ pub ZERO_WIDTH_SPACE, Deny, \"Zero-width space is confusing\" }\n \n@@ -36,7 +37,7 @@ fn check_str(cx: &Context, string: &str, span: Span) {\n \n fn lint_zero_width(cx: &Context, span: Span, start: Option<usize>) {\n \tstart.map(|index| {\n-\t\tcx.span_lint(ZERO_WIDTH_SPACE, Span {\n+\t\tspan_lint(cx, ZERO_WIDTH_SPACE, Span {\n \t\t\tlo: span.lo + BytePos(index as u32),\n \t\t\thi: span.lo + BytePos(index as u32),\n \t\t\texpn_id: span.expn_id,"}, {"sha": "e3cafc700a50bddb35da57ce8cbc1b902f34ec85", "filename": "src/utils.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e8cfc9be642311be9995934bb864560b8c553/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=0e8e8cfc9be642311be9995934bb864560b8c553", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::Context;\n+use rustc::lint::{Context, Lint};\n use syntax::ast::{DefId, Name, Path};\n use syntax::codemap::{ExpnInfo, Span};\n use syntax::ptr::P;\n@@ -52,3 +52,16 @@ pub fn snippet<'a>(cx: &Context, span: Span, default: &'a str) -> Cow<'a, str> {\n \n /// dereference a P<T> and return a ref on the result\n pub fn de_p<T>(p: &P<T>) -> &T { &*p }\n+\n+#[cfg(not(feature=\"structured_logging\"))]\n+pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n+\tcx.span_lint(lint, sp, msg);\n+}\n+\n+#[cfg(feature=\"structured_logging\")]\n+pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n+\t// lint.name / lint.desc is can give details of the lint\n+\t// cx.sess().codemap() has all these nice functions for line/column/snippet details\n+\t// http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n+\tcx.span_lint(lint, sp, msg);\n+}"}]}