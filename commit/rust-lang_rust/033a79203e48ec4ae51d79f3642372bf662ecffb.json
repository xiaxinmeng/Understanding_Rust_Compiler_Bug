{"sha": "033a79203e48ec4ae51d79f3642372bf662ecffb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzM2E3OTIwM2U0OGVjNGFlNTFkNzlmMzY0MjM3MmJmNjYyZWNmZmI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-12-16T23:23:55Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-12-16T23:23:55Z"}, "message": "Document std::mem", "tree": {"sha": "4bee56fde95a6fec6094a7eb1dba1b5e0155a4ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bee56fde95a6fec6094a7eb1dba1b5e0155a4ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/033a79203e48ec4ae51d79f3642372bf662ecffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/033a79203e48ec4ae51d79f3642372bf662ecffb", "html_url": "https://github.com/rust-lang/rust/commit/033a79203e48ec4ae51d79f3642372bf662ecffb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/033a79203e48ec4ae51d79f3642372bf662ecffb/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e9e70d15bcf8d29890bf93793be402ad629229", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e9e70d15bcf8d29890bf93793be402ad629229", "html_url": "https://github.com/rust-lang/rust/commit/92e9e70d15bcf8d29890bf93793be402ad629229"}], "stats": {"total": 185, "additions": 139, "deletions": 46}, "files": [{"sha": "11c3f7c289d24e5f4eb3429dd029285348b651cf", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 139, "deletions": 46, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/033a79203e48ec4ae51d79f3642372bf662ecffb/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/033a79203e48ec4ae51d79f3642372bf662ecffb/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=033a79203e48ec4ae51d79f3642372bf662ecffb", "patch": "@@ -29,13 +29,29 @@ pub use intrinsics::transmute;\n pub use intrinsics::forget;\n \n /// Returns the size of a type in bytes.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of::<i32>());\n+/// ```\n #[inline]\n #[stable]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n /// Returns the size of the type that `_val` points to in bytes.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of_val(&5i32));\n+/// ```\n #[inline]\n #[stable]\n pub fn size_of_val<T>(_val: &T) -> uint {\n@@ -44,16 +60,30 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n \n /// Returns the ABI-required minimum alignment of a type\n ///\n-/// This is the alignment used for struct fields. It may be smaller\n-/// than the preferred alignment.\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of::<i32>());\n+/// ```\n #[inline]\n #[stable]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that\n-/// `_val` points to\n+/// Returns the ABI-required minimum alignment of the type of the value that `_val` points to\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of_val(&5i32));\n+/// ```\n #[inline]\n #[stable]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n@@ -62,9 +92,16 @@ pub fn min_align_of_val<T>(_val: &T) -> uint {\n \n /// Returns the alignment in memory for a type.\n ///\n-/// This function will return the alignment, in bytes, of a type in memory. If\n-/// the alignment returned is adhered to, then the type is guaranteed to\n-/// function properly.\n+/// This function will return the alignment, in bytes, of a type in memory. If the alignment\n+/// returned is adhered to, then the type is guaranteed to function properly.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of::<i32>());\n+/// ```\n #[inline]\n #[stable]\n pub fn align_of<T>() -> uint {\n@@ -77,9 +114,16 @@ pub fn align_of<T>() -> uint {\n \n /// Returns the alignment of the type of the value that `_val` points to.\n ///\n-/// This is similar to `align_of`, but function will properly handle types such\n-/// as trait objects (in the future), returning the alignment for an arbitrary\n-/// value at runtime.\n+/// This is similar to `align_of`, but function will properly handle types such as trait objects\n+/// (in the future), returning the alignment for an arbitrary value at runtime.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of_val(&5i32));\n+/// ```\n #[inline]\n #[stable]\n pub fn align_of_val<T>(_val: &T) -> uint {\n@@ -88,15 +132,22 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n \n /// Create a value initialized to zero.\n ///\n-/// This function is similar to allocating space for a local variable and\n-/// zeroing it out (an unsafe operation).\n+/// This function is similar to allocating space for a local variable and zeroing it out (an unsafe\n+/// operation).\n ///\n-/// Care must be taken when using this function, if the type `T` has a\n-/// destructor and the value falls out of scope (due to unwinding or returning)\n-/// before being initialized, then the destructor will run on zeroed\n-/// data, likely leading to crashes.\n+/// Care must be taken when using this function, if the type `T` has a destructor and the value\n+/// falls out of scope (due to unwinding or returning) before being initialized, then the\n+/// destructor will run on zeroed data, likely leading to crashes.\n ///\n /// This is useful for FFI functions sometimes, but should generally be avoided.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x: int = unsafe { mem::zeroed() };\n+/// ```\n #[inline]\n #[stable]\n pub unsafe fn zeroed<T>() -> T {\n@@ -105,20 +156,41 @@ pub unsafe fn zeroed<T>() -> T {\n \n /// Create an uninitialized value.\n ///\n-/// Care must be taken when using this function, if the type `T` has a\n-/// destructor and the value falls out of scope (due to unwinding or returning)\n-/// before being initialized, then the destructor will run on uninitialized\n-/// data, likely leading to crashes.\n+/// Care must be taken when using this function, if the type `T` has a destructor and the value\n+/// falls out of scope (due to unwinding or returning) before being initialized, then the\n+/// destructor will run on uninitialized data, likely leading to crashes.\n ///\n /// This is useful for FFI functions sometimes, but should generally be avoided.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x: int = unsafe { mem::uninitialized() };\n+/// ```\n #[inline]\n #[stable]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Swap the values at two mutable locations of the same type, without\n-/// deinitialising or copying either one.\n+/// Swap the values at two mutable locations of the same type, without deinitialising or copying\n+/// either one.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x = &mut 5i;\n+/// let y = &mut 42i;\n+///\n+/// mem::swap(x, y);\n+///\n+/// assert_eq!(42i, *x);\n+/// assert_eq!(5i, *y);\n+/// ```\n #[inline]\n #[stable]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n@@ -137,13 +209,26 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n     }\n }\n \n-/// Replace the value at a mutable location with a new one, returning the old\n-/// value, without deinitialising or copying either one.\n+/// Replace the value at a mutable location with a new one, returning the old value, without\n+/// deinitialising or copying either one.\n+///\n+/// This is primarily used for transferring and swapping ownership of a value in a mutable\n+/// location.\n+///\n+/// # Examples\n+///\n+/// A simple example:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut v: Vec<i32> = Vec::new();\n+///\n+/// mem::replace(&mut v, Vec::new());\n+/// ```\n ///\n-/// This is primarily used for transferring and swapping ownership of a value\n-/// in a mutable location. For example, this function allows consumption of\n-/// one field of a struct by replacing it with another value. The normal approach\n-/// doesn't always work:\n+/// This function allows consumption of one field of a struct by replacing it with another value.\n+/// The normal approach doesn't always work:\n ///\n /// ```rust,ignore\n /// struct Buffer<T> { buf: Vec<T> }\n@@ -158,16 +243,16 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n ///\n-/// Note that `T` does not necessarily implement `Clone`, so it can't even\n-/// clone and reset `self.buf`. But `replace` can be used to disassociate\n-/// the original value of `self.buf` from `self`, allowing it to be returned:\n+/// Note that `T` does not necessarily implement `Clone`, so it can't even clone and reset\n+/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n+/// `self`, allowing it to be returned:\n ///\n /// ```rust\n+/// use std::mem;\n /// # struct Buffer<T> { buf: Vec<T> }\n /// impl<T> Buffer<T> {\n ///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         use std::mem::replace;\n-///         replace(&mut self.buf, Vec::new())\n+///         mem::replace(&mut self.buf, Vec::new())\n ///     }\n /// }\n /// ```\n@@ -180,10 +265,10 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n \n /// Disposes of a value.\n ///\n-/// This function can be used to destroy any value by allowing `drop` to take\n-/// ownership of its argument.\n+/// This function can be used to destroy any value by allowing `drop` to take ownership of its\n+/// argument.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -192,6 +277,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n ///\n /// let mut mutable_borrow = x.borrow_mut();\n /// *mutable_borrow = 1;\n+///\n /// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n ///\n /// let borrow = x.borrow();\n@@ -201,18 +287,25 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable]\n pub fn drop<T>(_x: T) { }\n \n-/// Interprets `src` as `&U`, and then reads `src` without moving the contained\n-/// value.\n+/// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n+///\n+/// This function will unsafely assume the pointer `src` is valid for `sizeof(U)` bytes by\n+/// transmuting `&T` to `&U` and then reading the `&U`. It will also unsafely create a copy of the\n+/// contained value instead of moving out of `src`.\n+///\n+/// It is not a compile-time error if `T` and `U` have different sizes, but it is highly encouraged\n+/// to only invoke this function where `T` and `U` have the same size. This function triggers\n+/// undefined behavior if `U` is larger than `T`.\n ///\n-/// This function will unsafely assume the pointer `src` is valid for\n-/// `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It\n-/// will also unsafely create a copy of the contained value instead of moving\n-/// out of `src`.\n+/// # Examples\n ///\n-/// It is not a compile-time error if `T` and `U` have different sizes, but it\n-/// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers undefined behavior if `U` is larger than\n-/// `T`.\n+/// ```\n+/// use std::mem;\n+///\n+/// let one = unsafe { mem::transmute_copy(&1i) };\n+///\n+/// assert_eq!(1u, one);\n+/// ```\n #[inline]\n #[stable]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {"}]}