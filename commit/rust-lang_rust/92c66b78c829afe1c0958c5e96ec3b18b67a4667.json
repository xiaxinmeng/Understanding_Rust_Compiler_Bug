{"sha": "92c66b78c829afe1c0958c5e96ec3b18b67a4667", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYzY2Yjc4YzgyOWFmZTFjMDk1OGM1ZTk2ZWMzYjE4YjY3YTQ2Njc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-14T08:14:44Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-14T10:25:24Z"}, "message": "Rollup merge of #48163 - alexcrichton:persistent-linker, r=rkruppe\n\nrustc: Persist LLVM's `Linker` in Fat LTO\n\nThis commit updates our Fat LTO logic to tweak our custom wrapper around LLVM's\n\"link modules\" functionality. Previously whenever the\n`LLVMRustLinkInExternalBitcode` function was called it would call LLVM's\n`Linker::linkModules` wrapper. Internally this would crate an instance of a\n`Linker` which internally creates an instance of an `IRMover`. Unfortunately for\nus the creation of `IRMover` is somewhat O(n) with the input module. This means\nthat every time we linked a module it was O(n) with respect to the entire module\nwe had built up!\n\nNow the modules we build up during LTO are quite large, so this quickly started\ncreating an O(n^2) problem for us! Discovered in #48025 it turns out this has\nalways been a problem and we just haven't noticed it. It became particularly\nworse recently though due to most libraries having 16x more object files than\nthey previously did (1 -> 16).\n\nThis commit fixes this performance issue by preserving the `Linker` instance\nacross all links into the main LLVM module. This means we only create one\n`IRMover` and allows LTO to progress much speedier.\n\nFrom the `cargo-cache` project in #48025 a **full build** locally went from\n5m15s to 2m24s. Looking at the timing logs each object file was linked in in\nsingle-digit millisecond rather than hundreds, clearly being a nice improvement!\n\nCloses #48025", "tree": {"sha": "f919076c68af2e54e2702ff6f90476384cfd177b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f919076c68af2e54e2702ff6f90476384cfd177b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92c66b78c829afe1c0958c5e96ec3b18b67a4667", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlqEDpQACgkQ/vbIBR0O\nATz5BA//cn7rgKR/YfqPiP36nvTWWUw7CQFb5qAjTyXz45BEZLD5lASzcc7QkPxE\n4LCQyu9t6tYRv6rTNxmbgg+v6s3nCW2mE26YLJ17xDHLwFLs74/Z02A/xT/qG232\nrEX1RRpIB/GM/WNfbBGio7FVB4eOV97iiMbgJimh0v5guSNGreupSgmeqFuCX0n2\nBk5ZtAqXXvnyTOaXr5SuWknI1w0rTdQMe+gZTtRkoCeRoOML+Ia2X/eVkLe0j5F4\nNsp9v7jt64M5p/huAIWEWsEduDIe/XIi7n42caPxPItlDXiX2HFr/Ry58/00G8YF\na/sr6h3xuj8oQPE2ZFfbQ2cm4uiqA043/XDDuqQl5pnxqOLcry8tVkKPgrDH4ncy\nfIcC5eFHAuMxT9audsxDW+Jn4FVaKHnF67S2SRmc+vJ4sZupX5tdwyxQg3dhOzV0\nLwawis4T/NYEsc5E1eCr86+erzJ2hcMsWCt9N6sAoDyz99cANQest0hKRTq38wHc\nvKunMEIDbPAi49hDJ0vI8Bvec0otyxO5IgM5mpVK8MN9p5Siu9x1HlrYbE2CwQ+l\nyHlKa0EW3FI0X0SChyJ+mNG5dLool6fMnRv3DnQAFMINgmU+859hxQYSXW/7uiwy\n+HnZI8zUndBmD+YLVbEhuDqNpshGxlA79JtfL/0l0lk5zIWIoig=\n=ZOV/\n-----END PGP SIGNATURE-----", "payload": "tree f919076c68af2e54e2702ff6f90476384cfd177b\nparent d38e11ee105bdf4eda7d7766330908019e2540fc\nparent 43e8ac27d9bf645b66a15f762be6969e9fe16285\nauthor kennytm <kennytm@gmail.com> 1518596084 +0800\ncommitter kennytm <kennytm@gmail.com> 1518603924 +0800\n\nRollup merge of #48163 - alexcrichton:persistent-linker, r=rkruppe\n\nrustc: Persist LLVM's `Linker` in Fat LTO\n\nThis commit updates our Fat LTO logic to tweak our custom wrapper around LLVM's\n\"link modules\" functionality. Previously whenever the\n`LLVMRustLinkInExternalBitcode` function was called it would call LLVM's\n`Linker::linkModules` wrapper. Internally this would crate an instance of a\n`Linker` which internally creates an instance of an `IRMover`. Unfortunately for\nus the creation of `IRMover` is somewhat O(n) with the input module. This means\nthat every time we linked a module it was O(n) with respect to the entire module\nwe had built up!\n\nNow the modules we build up during LTO are quite large, so this quickly started\ncreating an O(n^2) problem for us! Discovered in #48025 it turns out this has\nalways been a problem and we just haven't noticed it. It became particularly\nworse recently though due to most libraries having 16x more object files than\nthey previously did (1 -> 16).\n\nThis commit fixes this performance issue by preserving the `Linker` instance\nacross all links into the main LLVM module. This means we only create one\n`IRMover` and allows LTO to progress much speedier.\n\nFrom the `cargo-cache` project in #48025 a **full build** locally went from\n5m15s to 2m24s. Looking at the timing logs each object file was linked in in\nsingle-digit millisecond rather than hundreds, clearly being a nice improvement!\n\nCloses #48025\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92c66b78c829afe1c0958c5e96ec3b18b67a4667", "html_url": "https://github.com/rust-lang/rust/commit/92c66b78c829afe1c0958c5e96ec3b18b67a4667", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92c66b78c829afe1c0958c5e96ec3b18b67a4667/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d38e11ee105bdf4eda7d7766330908019e2540fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d38e11ee105bdf4eda7d7766330908019e2540fc", "html_url": "https://github.com/rust-lang/rust/commit/d38e11ee105bdf4eda7d7766330908019e2540fc"}, {"sha": "43e8ac27d9bf645b66a15f762be6969e9fe16285", "url": "https://api.github.com/repos/rust-lang/rust/commits/43e8ac27d9bf645b66a15f762be6969e9fe16285", "html_url": "https://github.com/rust-lang/rust/commit/43e8ac27d9bf645b66a15f762be6969e9fe16285"}], "stats": {"total": 163, "additions": 114, "deletions": 49}, "files": [{"sha": "54e3f544acb68b0258186b0729245a02b324070a", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=92c66b78c829afe1c0958c5e96ec3b18b67a4667", "patch": "@@ -155,6 +155,7 @@ fn main() {\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n+       .file(\"../rustllvm/Linker.cpp\")\n        .cpp(true)\n        .cpp_link_stdlib(None) // we handle this below\n        .compile(\"rustllvm\");"}, {"sha": "e71bef512cf067c84956d197d93394565fac9476", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=92c66b78c829afe1c0958c5e96ec3b18b67a4667", "patch": "@@ -444,6 +444,9 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n #[allow(missing_copy_implementations)]\n pub enum OperandBundleDef_opaque {}\n pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Linker_opaque {}\n+pub type LinkerRef = *mut Linker_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -1608,7 +1611,6 @@ extern \"C\" {\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef, AddLifetimes: bool);\n-    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef, bc: *const c_char, len: size_t) -> bool;\n     pub fn LLVMRustRunRestrictionPass(M: ModuleRef, syms: *const *const c_char, len: size_t);\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n@@ -1724,4 +1726,10 @@ extern \"C\" {\n                                            CU2: *mut *mut c_void);\n     pub fn LLVMRustThinLTOPatchDICompileUnit(M: ModuleRef, CU: *mut c_void);\n     pub fn LLVMRustThinLTORemoveAvailableExternally(M: ModuleRef);\n+\n+    pub fn LLVMRustLinkerNew(M: ModuleRef) -> LinkerRef;\n+    pub fn LLVMRustLinkerAdd(linker: LinkerRef,\n+                             bytecode: *const c_char,\n+                             bytecode_len: usize) -> bool;\n+    pub fn LLVMRustLinkerFree(linker: LinkerRef);\n }"}, {"sha": "a33270380196f5ec9ec5774eeecbd55ad5922029", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=92c66b78c829afe1c0958c5e96ec3b18b67a4667", "patch": "@@ -247,22 +247,20 @@ fn fat_lto(cgcx: &CodegenContext,\n     // know much about the memory management here so we err on the side of being\n     // save and persist everything with the original module.\n     let mut serialized_bitcode = Vec::new();\n+    let mut linker = Linker::new(llmod);\n     for (bc_decoded, name) in serialized_modules {\n         info!(\"linking {:?}\", name);\n-        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || unsafe {\n+        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n             let data = bc_decoded.data();\n-            if llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                   data.as_ptr() as *const libc::c_char,\n-                                                   data.len() as libc::size_t) {\n-                Ok(())\n-            } else {\n+            linker.add(&data).map_err(|()| {\n                 let msg = format!(\"failed to load bc of {:?}\", name);\n-                Err(write::llvm_err(&diag_handler, msg))\n-            }\n+                write::llvm_err(&diag_handler, msg)\n+            })\n         })?;\n         timeline.record(&format!(\"link {:?}\", name));\n         serialized_bitcode.push(bc_decoded);\n     }\n+    drop(linker);\n     cgcx.save_temp_bitcode(&module, \"lto.input\");\n \n     // Internalize everything that *isn't* in our whitelist to help strip out\n@@ -289,6 +287,32 @@ fn fat_lto(cgcx: &CodegenContext,\n     }])\n }\n \n+struct Linker(llvm::LinkerRef);\n+\n+impl Linker {\n+    fn new(llmod: ModuleRef) -> Linker {\n+        unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n+    }\n+\n+    fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+        unsafe {\n+            if llvm::LLVMRustLinkerAdd(self.0,\n+                                       bytecode.as_ptr() as *const libc::c_char,\n+                                       bytecode.len()) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Linker {\n+    fn drop(&mut self) {\n+        unsafe { llvm::LLVMRustLinkerFree(self.0); }\n+    }\n+}\n+\n /// Prepare \"thin\" LTO to get run on these modules.\n ///\n /// The general structure of ThinLTO is quite different from the structure of"}, {"sha": "534e4b910902e89ce567eb364a3bf4b5e2b3600f", "filename": "src/rustllvm/Linker.cpp", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Frustllvm%2FLinker.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Frustllvm%2FLinker.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FLinker.cpp?ref=92c66b78c829afe1c0958c5e96ec3b18b67a4667", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include \"llvm/Linker/Linker.h\"\n+\n+#include \"rustllvm.h\"\n+\n+using namespace llvm;\n+\n+struct RustLinker {\n+  Linker L;\n+  LLVMContext &Ctx;\n+\n+  RustLinker(Module &M) :\n+    L(M),\n+    Ctx(M.getContext())\n+  {}\n+};\n+\n+extern \"C\" RustLinker*\n+LLVMRustLinkerNew(LLVMModuleRef DstRef) {\n+  Module *Dst = unwrap(DstRef);\n+\n+  auto Ret = llvm::make_unique<RustLinker>(*Dst);\n+  return Ret.release();\n+}\n+\n+extern \"C\" void\n+LLVMRustLinkerFree(RustLinker *L) {\n+  delete L;\n+}\n+\n+extern \"C\" bool\n+LLVMRustLinkerAdd(RustLinker *L, char *BC, size_t Len) {\n+  std::unique_ptr<MemoryBuffer> Buf =\n+      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  Expected<std::unique_ptr<Module>> SrcOrError =\n+      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), L->Ctx);\n+  if (!SrcOrError) {\n+    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n+    return false;\n+  }\n+\n+  auto Src = std::move(*SrcOrError);\n+#else\n+  ErrorOr<std::unique_ptr<Module>> Src =\n+      llvm::getLazyBitcodeModule(std::move(Buf), L->Ctx);\n+  if (!Src) {\n+    LLVMRustSetLastError(Src.getError().message().c_str());\n+    return false;\n+  }\n+#endif\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  if (L->L.linkInModule(std::move(Src))) {\n+#else\n+  if (L->L.linkInModule(std::move(Src.get()))) {\n+#endif\n+    LLVMRustSetLastError(\"\");\n+    return false;\n+  }\n+  return true;\n+}"}, {"sha": "27d5496f57628c4c7d6c05c41a6fee03f12357c3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/92c66b78c829afe1c0958c5e96ec3b18b67a4667/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=92c66b78c829afe1c0958c5e96ec3b18b67a4667", "patch": "@@ -916,46 +916,6 @@ extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n   }\n }\n \n-extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef DstRef, char *BC,\n-                                              size_t Len) {\n-  Module *Dst = unwrap(DstRef);\n-\n-  std::unique_ptr<MemoryBuffer> Buf =\n-      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n-\n-#if LLVM_VERSION_GE(4, 0)\n-  Expected<std::unique_ptr<Module>> SrcOrError =\n-      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), Dst->getContext());\n-  if (!SrcOrError) {\n-    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n-    return false;\n-  }\n-\n-  auto Src = std::move(*SrcOrError);\n-#else\n-  ErrorOr<std::unique_ptr<Module>> Src =\n-      llvm::getLazyBitcodeModule(std::move(Buf), Dst->getContext());\n-  if (!Src) {\n-    LLVMRustSetLastError(Src.getError().message().c_str());\n-    return false;\n-  }\n-#endif\n-\n-  std::string Err;\n-\n-  raw_string_ostream Stream(Err);\n-  DiagnosticPrinterRawOStream DP(Stream);\n-#if LLVM_VERSION_GE(4, 0)\n-  if (Linker::linkModules(*Dst, std::move(Src))) {\n-#else\n-  if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n-#endif\n-    LLVMRustSetLastError(Err.c_str());\n-    return false;\n-  }\n-  return true;\n-}\n-\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The"}]}