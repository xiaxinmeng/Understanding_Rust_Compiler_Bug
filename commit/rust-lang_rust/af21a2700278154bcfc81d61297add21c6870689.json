{"sha": "af21a2700278154bcfc81d61297add21c6870689", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMjFhMjcwMDI3ODE1NGJjZmM4MWQ2MTI5N2FkZDIxYzY4NzA2ODk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-13T07:09:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-16T22:05:56Z"}, "message": "Port the compiler to the expr foo::<T> syntax.", "tree": {"sha": "105a8b41b3b99796103d5e43be79b18106bb3fcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/105a8b41b3b99796103d5e43be79b18106bb3fcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af21a2700278154bcfc81d61297add21c6870689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af21a2700278154bcfc81d61297add21c6870689", "html_url": "https://github.com/rust-lang/rust/commit/af21a2700278154bcfc81d61297add21c6870689", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af21a2700278154bcfc81d61297add21c6870689/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9327a61bb01acceb431c47931d5c49c998918cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9327a61bb01acceb431c47931d5c49c998918cd", "html_url": "https://github.com/rust-lang/rust/commit/d9327a61bb01acceb431c47931d5c49c998918cd"}], "stats": {"total": 664, "additions": 335, "deletions": 329}, "files": [{"sha": "28ad53f75559083c133bba4d532ee3013f4da10d", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -150,25 +150,25 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n         time(time_passes, \"freevar finding\",\n              bind freevars::annotate_freevars(sess, d, crate));\n     let ty_cx = ty::mk_ctxt(sess, d, ast_map, freevars);\n-    time[()](time_passes, \"typechecking\",\n+    time::<()>(time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, crate));\n-    time[()](time_passes, \"alt checking\",\n+    time::<()>(time_passes, \"alt checking\",\n              bind middle::check_alt::check_crate(ty_cx, crate));\n     if sess.get_opts().run_typestate {\n         time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n     time(time_passes, \"alias checking\",\n          bind middle::alias::check_crate(ty_cx, crate));\n-    time[()](time_passes, \"kind checking\",\n+    time::<()>(time_passes, \"kind checking\",\n              bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n     let llmod =\n-        time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n+        time::<llvm::llvm::ModuleRef>(time_passes, \"translation\",\n                                     bind trans::trans_crate(sess, crate,\n                                                             ty_cx, output,\n                                                             ast_map));\n-    time[()](time_passes, \"LLVM passes\",\n+    time::<()>(time_passes, \"LLVM passes\",\n              bind link::write::run_passes(sess, llmod, output));\n }\n \n@@ -459,14 +459,14 @@ fn main(args: vec<str>) {\n     }\n     let sopts = build_session_options(binary, match, binary_dir);\n     let sess = build_session(sopts);\n-    let n_inputs = vec::len[str](match.free);\n+    let n_inputs = vec::len::<str>(match.free);\n     let output_file = getopts::opt_maybe_str(match, \"o\");\n     let glue = opt_present(match, \"glue\");\n     if glue {\n         if n_inputs > 0u {\n             sess.fatal(\"No input files allowed with --glue.\");\n         }\n-        let out = option::from_maybe[str](\"glue.bc\", output_file);\n+        let out = option::from_maybe::<str>(\"glue.bc\", output_file);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n@@ -479,26 +479,28 @@ fn main(args: vec<str>) {\n     let saved_out_filename: str = \"\";\n     let cfg = build_configuration(sess, binary, ifile);\n     let expand =\n-        option::map[str,\n-                    pp_mode](bind parse_pretty(sess, _),\n-                             getopts::opt_default(match, \"expand\", \"normal\"));\n+        option::map::<str,\n+                      pp_mode>(bind parse_pretty(sess, _),\n+                               getopts::opt_default(match, \"expand\",\n+                                                    \"normal\"));\n     alt expand {\n-      some[pp_mode](ppm) {\n+      some::<pp_mode>(ppm) {\n         pretty_print_input(sess, cfg, ifile, ppm, true);\n         ret;\n       }\n-      none[pp_mode]. {/* continue */ }\n+      none::<pp_mode>. {/* continue */ }\n     }\n     let pretty =\n-        option::map[str,\n-                    pp_mode](bind parse_pretty(sess, _),\n-                             getopts::opt_default(match, \"pretty\", \"normal\"));\n+        option::map::<str,\n+                      pp_mode>(bind parse_pretty(sess, _),\n+                               getopts::opt_default(match, \"pretty\",\n+                                                    \"normal\"));\n     alt pretty {\n-      some[pp_mode](ppm) {\n+      some::<pp_mode>(ppm) {\n         pretty_print_input(sess, cfg, ifile, ppm, false);\n         ret;\n       }\n-      none[pp_mode]. {/* continue */ }\n+      none::<pp_mode>. {/* continue */ }\n     }\n     let ls = opt_present(match, \"ls\");\n     if ls {"}, {"sha": "c06e1810497bddb64c14c6d49076df810214df8d", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -178,7 +178,7 @@ fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n \n fn require_unique_names(sess: &session::session,\n                         metas: &[@ast::meta_item]) {\n-    let map = map::mk_hashmap[str, ()](str::hash, str::eq);\n+    let map = map::mk_hashmap::<str, ()>(str::hash, str::eq);\n     for meta: @ast::meta_item in metas {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {"}, {"sha": "4b8653088eef300a36f70c01ed0fceeb2b72223d", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -1303,15 +1303,15 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n        ValueRef {\n         assert (!*terminated);\n         let phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n-        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n+        assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n         llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                               vec::len(vals));\n         ret phi;\n     }\n \n     fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef],\n                         bbs: &[BasicBlockRef]) {\n-        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n+        assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n         llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                               vec::len(vals));\n     }\n@@ -1440,15 +1440,15 @@ obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n }\n \n fn mk_type_names() -> type_names {\n-    let nt = std::map::new_str_hash[TypeRef]();\n+    let nt = std::map::new_str_hash::<TypeRef>();\n \n     fn hash(t: &TypeRef) -> uint { ret t as uint; }\n \n     fn eq(a: &TypeRef, b: &TypeRef) -> bool { ret a as uint == b as uint; }\n \n     let hasher: std::map::hashfn<TypeRef> = hash;\n     let eqer: std::map::eqfn<TypeRef> = eq;\n-    let tn = std::map::mk_hashmap[TypeRef, str](hasher, eqer);\n+    let tn = std::map::mk_hashmap::<TypeRef, str>(hasher, eqer);\n \n     ret type_names(tn, nt);\n }\n@@ -1503,7 +1503,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n         let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args: uint = llvm::LLVMCountParamTypes(ty);\n-        let args: [TypeRef] = vec::init_elt[TypeRef](0 as TypeRef, n_args);\n+        let args: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_args);\n         llvm::LLVMGetParamTypes(ty, vec::to_ptr(args));\n         s += tys_str(names, outer, args);\n         s += \") -> \";\n@@ -1515,7 +1515,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       9 {\n         let s: str = \"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n-        let elts: [TypeRef] = vec::init_elt[TypeRef](0 as TypeRef, n_elts);\n+        let elts: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_elts);\n         llvm::LLVMGetStructElementTypes(ty, vec::to_ptr(elts));\n         s += tys_str(names, outer, elts);\n         s += \"}\";\n@@ -1534,7 +1534,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n         for tout: TypeRef in outer0 {\n             i += 1u;\n             if tout as int == ty as int {\n-                let n: uint = vec::len[TypeRef](outer0) - i;\n+                let n: uint = vec::len::<TypeRef>(outer0) - i;\n                 ret \"*\\\\\" + std::int::str(n as int);\n             }\n         }"}, {"sha": "4adceacdfde427411ac8b56fd554e483a7edad2e", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -32,7 +32,7 @@ export list_file_metadata;\n fn read_crates(sess: session::session, crate: &ast::crate) {\n     let e =\n         @{sess: sess,\n-          crate_cache: @std::map::new_str_hash[int](),\n+          crate_cache: @std::map::new_str_hash::<int>(),\n           library_search_paths: sess.get_opts().library_search_paths,\n           mutable next_crate_num: 1};\n     let v =\n@@ -186,7 +186,7 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n     let b = str::buf(filename);\n     let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n-    if mb as int == 0 { ret option::none[@[u8]]; }\n+    if mb as int == 0 { ret option::none::<@[u8]>; }\n     let of = mk_object_file(mb);\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -196,11 +196,11 @@ fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi);\n             let cvbuf: *u8 = std::unsafe::reinterpret_cast(cbuf);\n-            ret option::some[@[u8]](@vec::unsafe::from_buf(cvbuf, csz));\n+            ret option::some::<@[u8]>(@vec::unsafe::from_buf(cvbuf, csz));\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n-    ret option::none[@[u8]];\n+    ret option::none::<@[u8]>;\n }\n \n fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n@@ -249,7 +249,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n     log \"resolving deps of external crate\";\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n-    let cnum_map = new_int_hash[ast::crate_num]();\n+    let cnum_map = new_int_hash::<ast::crate_num>();\n     for dep: decoder::crate_dep in decoder::get_crate_deps(cdata) {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;"}, {"sha": "155597f94fa8e38883f602462503ba04b34c2dbd", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -52,8 +52,8 @@ type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n fn p(cstore: &cstore) -> cstore_private { alt cstore { private(p) { p } } }\n \n fn mk_cstore() -> cstore {\n-    let meta_cache = map::new_int_hash[crate_metadata]();\n-    let crate_map = map::new_int_hash[ast::crate_num]();\n+    let meta_cache = map::new_int_hash::<crate_metadata>();\n+    let crate_map = map::new_int_hash::<ast::crate_num>();\n     ret private(@{metas: meta_cache,\n                   use_crate_map: crate_map,\n                   mutable used_crate_files: ~[],"}, {"sha": "03a65dfd44c670d70bd03d51e73b597e71a1b185", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -48,7 +48,7 @@ fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n     let belt = tag_index_buckets_bucket_elt;\n     for each elt: ebml::doc in ebml::tagged_docs(bucket, belt) {\n         let pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n-        if eq_fn(vec::slice[u8](*elt.data, elt.start + 4u, elt.end)) {\n+        if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n             result += ~[ebml::doc_at(d.data, pos)];\n         }\n     }\n@@ -63,8 +63,8 @@ fn maybe_find_item(item_id: int, items: &ebml::doc) ->\n     let eqer = bind eq_item(_, item_id);\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n     if vec::len(found) == 0u {\n-        ret option::none[ebml::doc];\n-    } else { ret option::some[ebml::doc](found.(0)); }\n+        ret option::none::<ebml::doc>;\n+    } else { ret option::some::<ebml::doc>(found.(0)); }\n }\n \n fn find_item(item_id: int, items: &ebml::doc) -> ebml::doc {\n@@ -269,7 +269,7 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n fn read_path(d: &ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n-    let pathbytes = vec::slice[u8](desc, 4u, vec::len[u8](desc));\n+    let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::unsafe_from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }"}, {"sha": "32c21d116a9becaaaf1682fdb3d9021275a15f4c", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -176,7 +176,7 @@ fn def_to_str(did: &def_id) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n \n fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n-    ebml::write_vint(ebml_w.writer, vec::len[ty_param](tps));\n+    ebml::write_vint(ebml_w.writer, vec::len::<ty_param>(tps));\n     for tp: ty_param in tps {\n         let c = alt tp.kind {\n           kind_unique. { 'u' }\n@@ -236,7 +236,7 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n         encode_tag_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_monotype(ecx.ccx.tcx, variant.node.id));\n-        if vec::len[variant_arg](variant.node.args) > 0u {\n+        if vec::len::<variant_arg>(variant.node.args) > 0u {\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);"}, {"sha": "05e01d8af636081967ef096dd23641b073305222", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -71,7 +71,7 @@ fn parse_constrs(st: @pstate, sd: str_def) -> [@ty::constr] {\n         do  {\n             next(st);\n             let one: @ty::constr =\n-                parse_constr[uint](st, sd, parse_constr_arg);\n+                parse_constr::<uint>(st, sd, parse_constr_arg);\n             rslt += ~[one];\n         } while peek(st) as char == ';'\n       }\n@@ -88,7 +88,7 @@ fn parse_ty_constrs(st: @pstate, sd: str_def) -> [@ty::type_constr] {\n         do  {\n             next(st);\n             let one: @ty::type_constr =\n-                parse_constr[path](st, sd, parse_ty_constr_arg);\n+                parse_constr::<path>(st, sd, parse_ty_constr_arg);\n             rslt += ~[one];\n         } while peek(st) as char == ';'\n       }\n@@ -406,14 +406,14 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n // Rust metadata parsing\n fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let colon_idx = 0u;\n-    let len = vec::len[u8](buf);\n+    let len = vec::len::<u8>(buf);\n     while colon_idx < len && buf.(colon_idx) != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         log_err \"didn't find ':' when parsing def id\";\n         fail;\n     }\n-    let crate_part = vec::slice[u8](buf, 0u, colon_idx);\n-    let def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n+    let crate_part = vec::slice::<u8>(buf, 0u, colon_idx);\n+    let def_part = vec::slice::<u8>(buf, colon_idx + 1u, len);\n \n     let crate_part_vec = ~[];\n     let def_part_vec = ~[];"}, {"sha": "a9cd0a869b03a3ee75bb13e6248b44be226743a3", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -46,7 +46,7 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n               visit_item: bind visit_item(cx, _, _, _),\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_decl: bind visit_decl(cx, _, _, _)\n-              with *visit::default_visitor[scope]()};\n+              with *visit::default_visitor::<scope>()};\n     visit::visit_crate(*crate, @~[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "a348787c76107659657bac2a2ccc0708f9a4696d", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -18,13 +18,13 @@ fn map_crate(c: &crate) -> map {\n     // FIXME: This is using an adapter to convert the smallintmap\n     // interface to the hashmap interface. It would be better to just\n     // convert everything to use the smallintmap.\n-    let map = new_smallintmap_int_adapter[ast_node]();\n+    let map = new_smallintmap_int_adapter::<ast_node>();\n \n     let v_map =\n         @{visit_item: bind map_item(map, _, _, _),\n           visit_native_item: bind map_native_item(map, _, _, _),\n           visit_expr: bind map_expr(map, _, _, _)\n-             with *visit::default_visitor[()]()};\n+             with *visit::default_visitor::<()>()};\n     visit::visit_crate(c, (), visit::mk_vt(v_map));\n     ret map;\n }\n@@ -110,7 +110,7 @@ fn new_smallintmap_adapter<@K,\n         }\n     }\n \n-    let map = smallintmap::mk[V]();\n+    let map = smallintmap::mk::<V>();\n     ret adapter(map, key_idx, idx_key);\n }\n "}, {"sha": "29be298aad1f18fa453f1b20005d5780d6164daf", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -5,7 +5,7 @@ fn check_crate(tcx: &ty::ctxt, crate: &@crate) {\n     let v =\n         @{visit_expr: bind check_expr(tcx, _, _, _),\n           visit_local: bind check_local(tcx, _, _, _)\n-          with *visit::default_visitor[()]()};\n+          with *visit::default_visitor::<()>()};\n     visit::visit_crate(*crate, (), visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "b87f3bbda4b93c912798bf5f328e95b06c558965", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -86,7 +86,7 @@ fn new_ext_hash() -> ext_hash {\n         ret util::common::def_eq(v1.did, v2.did) &&\n                 str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n     }\n-    ret std::map::mk_hashmap[key, def](hash, eq);\n+    ret std::map::mk_hashmap::<key, def>(hash, eq);\n }\n \n tag mod_index_entry {\n@@ -135,11 +135,11 @@ fn resolve_crate(sess: session, amap: &ast_map::map, crate: @ast::crate) ->\n    def_map {\n     let e =\n         @{cstore: sess.get_cstore(),\n-          def_map: new_int_hash[def](),\n+          def_map: new_int_hash::<def>(),\n           ast_map: amap,\n-          imports: new_int_hash[import_state](),\n-          mod_map: new_int_hash[@indexed_mod](),\n-          ext_map: new_def_hash[[ident]](),\n+          imports: new_int_hash::<import_state>(),\n+          mod_map: new_int_hash::<@indexed_mod>(),\n+          ext_map: new_def_hash::<[ident]>(),\n           ext_cache: new_ext_hash(),\n           mutable reported: ~[],\n           sess: sess};\n@@ -159,15 +159,15 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n     let v_map_mod =\n         @{visit_view_item: bind index_vi(e, _, _, _),\n           visit_item: bind index_i(e, _, _, _)\n-             with *visit::default_visitor[scopes]()};\n+             with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v_map_mod));\n     // Register the top-level mod\n \n     e.mod_map.insert(-1,\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n                        mutable glob_imports: ~[],\n-                       glob_imported_names: new_str_hash[import_state]()});\n+                       glob_imported_names: new_str_hash::<import_state>()});\n     fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, v: &vt<scopes>) {\n         alt i.node {\n           ast::view_item_import(_, ids, id) {\n@@ -180,17 +180,17 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n         visit_item_with_scope(i, sc, v);\n         alt i.node {\n           ast::item_mod(md) {\n-            let s = new_str_hash[import_state]();\n+            let s = new_str_hash::<import_state>();\n             e.mod_map.insert(i.id,\n                              @{m: some(md),\n                                index: index_mod(md),\n                                mutable glob_imports: ~[],\n                                glob_imported_names: s});\n           }\n           ast::item_native_mod(nmd) {\n-            let s = new_str_hash[import_state]();\n+            let s = new_str_hash::<import_state>();\n             e.mod_map.insert(i.id,\n-                             @{m: none[ast::_mod],\n+                             @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n                                mutable glob_imports: ~[],\n                                glob_imported_names: s});\n@@ -203,7 +203,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n     let v_link_glob =\n         @{visit_view_item: bind link_glob(e, _, _, _),\n           visit_item: visit_item_with_scope\n-             with *visit::default_visitor[scopes]()};\n+             with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_link_glob));\n     fn link_glob(e: @env, vi: &@ast::view_item, sc: &scopes, v: &vt<scopes>) {\n@@ -387,7 +387,7 @@ fn visit_arm_with_scope(a: &ast::arm, sc: &scopes, v: &vt<scopes>) {\n fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n     alt x.node {\n       ast::expr_for(decl, coll, blk) | ast::expr_for_each(decl, coll, blk) {\n-        let new_sc = cons[scope](scope_loop(decl), @sc);\n+        let new_sc = cons::<scope>(scope_loop(decl), @sc);\n         v.visit_expr(coll, sc, v);\n         v.visit_local(decl, new_sc, v);\n         v.visit_block(blk, new_sc, v);\n@@ -684,15 +684,15 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n             }\n           }\n         }\n-        ret none[def];\n+        ret none::<def>;\n     }\n     let left_fn = false;\n     // Used to determine whether obj fields are in scope\n \n     let left_fn_level2 = false;\n     while true {\n         alt { sc } {\n-          nil. { ret none[def]; }\n+          nil. { ret none::<def>; }\n           cons(hd, tl) {\n             let fnd = in_scope(e, sp, name, hd, ns);\n             if !is_none(fnd) {\n@@ -734,7 +734,7 @@ fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n         if str::eq(tp.ident, name) { ret some(ast::def_ty_arg(i,tp.kind)); }\n         i += 1u;\n     }\n-    ret none[def];\n+    ret none::<def>;\n }\n \n fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n@@ -758,10 +758,10 @@ fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n                 ret some(ast::def_arg(local_def(a.id)));\n             }\n         }\n-        ret none[def];\n+        ret none::<def>;\n       }\n       ns_type. { ret lookup_in_ty_params(name, ty_params); }\n-      _ { ret none[def]; }\n+      _ { ret none::<def>; }\n     }\n }\n \n@@ -774,10 +774,10 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n                 ret some(ast::def_obj_field(local_def(f.id)));\n             }\n         }\n-        ret none[def];\n+        ret none::<def>;\n       }\n       ns_type. { ret lookup_in_ty_params(name, ty_params); }\n-      _ { ret none[def]; }\n+      _ { ret none::<def>; }\n     }\n }\n \n@@ -835,7 +835,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n           _ { }\n         }\n     }\n-    ret none[def];\n+    ret none::<def>;\n }\n \n fn found_def_item(i: &@ast::item, ns: namespace) -> option::t<def> {\n@@ -880,7 +880,7 @@ fn found_def_item(i: &@ast::item, ns: namespace) -> option::t<def> {\n       }\n       _ { }\n     }\n-    ret none[def];\n+    ret none::<def>;\n }\n \n fn lookup_in_mod_strict(e: &env, sc: &scopes, m: def, sp: &span, name: &ident,\n@@ -929,7 +929,7 @@ fn found_view_item(e: &env, vi: @ast::view_item, ns: namespace) ->\n         ret lookup_import(e, local_def(id), ns);\n       }\n       ast::view_item_import_glob(_, defid) {\n-        ret none[def]; //will be handled in the fallback glob pass\n+        ret none::<def>; //will be handled in the fallback glob pass\n \n       }\n     }\n@@ -959,7 +959,7 @@ fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n     if dr == outside && !ast::is_exported(id, option::get(info.m)) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n \n-        ret none[def]; // name is not visible\n+        ret none::<def>; // name is not visible\n \n     }\n     alt info.index.find(id) {\n@@ -1027,7 +1027,7 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n     alt info.glob_imported_names.get(id) {\n       todo(_, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n       resolving(sp) {\n-        ret none[def]; //circularity is okay in import globs\n+        ret none::<def>; //circularity is okay in import globs\n \n       }\n       resolved(val, typ, md) {\n@@ -1052,7 +1052,7 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n                 let vid = variants.(variant_idx).node.id;\n                 ret some(ast::def_variant(local_def(item.id),\n                                           local_def(vid)));\n-            } else { ret none[def]; }\n+            } else { ret none::<def>; }\n           }\n         }\n       }\n@@ -1072,21 +1072,21 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n       }\n       _ { }\n     }\n-    ret none[def];\n+    ret none::<def>;\n }\n \n \n // Module indexing\n fn add_to_index(index: &hashmap<ident, list<mod_index_entry>>, id: &ident,\n                 ent: &mod_index_entry) {\n     alt index.find(id) {\n-      none. { index.insert(id, cons(ent, @nil[mod_index_entry])); }\n+      none. { index.insert(id, cons(ent, @nil::<mod_index_entry>)); }\n       some(prev) { index.insert(id, cons(ent, @prev)); }\n     }\n }\n \n fn index_mod(md: &ast::_mod) -> mod_index {\n-    let index = new_str_hash[list<mod_index_entry>]();\n+    let index = new_str_hash::<list<mod_index_entry>>();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n           ast::view_item_import(ident, _, _) | ast::view_item_use(ident, _, _)\n@@ -1121,7 +1121,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n }\n \n fn index_nmod(md: &ast::native_mod) -> mod_index {\n-    let index = new_str_hash[list<mod_index_entry>]();\n+    let index = new_str_hash::<list<mod_index_entry>>();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n           ast::view_item_use(ident, _, _) | ast::view_item_import(ident, _, _)\n@@ -1163,7 +1163,7 @@ fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n         if ns == ns_for_def(d) { ret some(d); }\n     }\n-    ret none[def];\n+    ret none::<def>;\n }\n \n "}, {"sha": "ed9a4120c62a58a57a2e4f54cd050d2fd51d56e8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 86, "deletions": 83, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -379,7 +379,7 @@ fn get_extern_const(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n \n fn get_simple_extern_fn(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n                         name: &str, n_args: int) -> ValueRef {\n-    let inputs = std::vec::init_elt[TypeRef](T_int(), n_args as uint);\n+    let inputs = std::vec::init_elt::<TypeRef>(T_int(), n_args as uint);\n     let output = T_int();\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n@@ -389,7 +389,7 @@ fn trans_native_call(b: &builder, glues: @glue_fns, lltaskptr: ValueRef,\n                      externs: &hashmap<str, ValueRef>, tn: &type_names,\n                      llmod: ModuleRef, name: &str, pass_task: bool,\n                      args: &[ValueRef]) -> ValueRef {\n-    let n: int = std::vec::len[ValueRef](args) as int;\n+    let n: int = std::vec::len::<ValueRef>(args) as int;\n     let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n     let call_args: [ValueRef] = ~[];\n     for a: ValueRef in args { call_args += ~[b.ZExtOrBitCast(a, T_int())]; }\n@@ -712,7 +712,7 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &[int]) ->\n \n     fn split_type(ccx: &@crate_ctxt, t: &ty::t, ixs: &[int], n: uint) ->\n        {prefix: [ty::t], target: ty::t} {\n-        let len: uint = std::vec::len[int](ixs);\n+        let len: uint = std::vec::len::<int>(ixs);\n         // We don't support 0-index or 1-index GEPs: The former is nonsense\n         // and the latter would only be meaningful if we supported non-0\n         // values for the 0th index (we don't).\n@@ -878,7 +878,7 @@ fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) ->\n // tydesc if necessary.\n fn field_of_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool, field: int) ->\n    result {\n-    let ti = none[@tydesc_info];\n+    let ti = none::<@tydesc_info>;\n     let tydesc = get_tydesc(cx, t, escapes, ti);\n     ret rslt(tydesc.bcx,\n              tydesc.bcx.build.GEP(tydesc.val, ~[C_int(0), C_int(field)]));\n@@ -954,10 +954,10 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n     let bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n     let n_params: uint = ty::count_ty_params(bcx_tcx(bcx), t);\n     let tys = linearize_ty_params(bcx, t);\n-    assert (n_params == std::vec::len[uint](tys.params));\n-    assert (n_params == std::vec::len[ValueRef](tys.descs));\n+    assert (n_params == std::vec::len::<uint>(tys.params));\n+    assert (n_params == std::vec::len::<ValueRef>(tys.descs));\n     let root_ti = get_static_tydesc(bcx, t, tys.params);\n-    static_ti = some[@tydesc_info](root_ti);\n+    static_ti = some::<@tydesc_info>(root_ti);\n     lazily_emit_all_tydesc_glue(cx, static_ti);\n     let root = root_ti.tydesc;\n     let sz = size_of(bcx, t);\n@@ -1033,7 +1033,7 @@ fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n     let info = get_static_tydesc(cx, t, ~[]);\n-    static_ti = some[@tydesc_info](info);\n+    static_ti = some::<@tydesc_info>(info);\n     ret rslt(cx, info.tydesc);\n }\n \n@@ -1110,10 +1110,10 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: &ty::t, ty_params: &[uint])\n           tydesc: gvar,\n           size: llsize,\n           align: llalign,\n-          mutable copy_glue: none[ValueRef],\n-          mutable drop_glue: none[ValueRef],\n-          mutable free_glue: none[ValueRef],\n-          mutable cmp_glue: none[ValueRef],\n+          mutable copy_glue: none::<ValueRef>,\n+          mutable drop_glue: none::<ValueRef>,\n+          mutable free_glue: none::<ValueRef>,\n+          mutable cmp_glue: none::<ValueRef>,\n           ty_params: ty_params};\n     log \"--- declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n     ret info;\n@@ -1150,7 +1150,7 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n     if ty::type_has_dynamic_size(cx.ccx.tcx, t) {\n         llty = T_ptr(T_i8());\n     } else { llty = T_ptr(type_of(cx.ccx, sp, t)); }\n-    let ty_param_count = std::vec::len[uint](ty_params);\n+    let ty_param_count = std::vec::len::<uint>(ty_params);\n     let lltyparams = llvm::LLVMGetParam(llfn, 3u);\n     let copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let lltydescs = ~[mutable];\n@@ -1341,7 +1341,7 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n                 cx.build.GEP(body,\n                              ~[C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n             let tydesc = cx.build.Load(tydescptr);\n-            let ti = none[@tydesc_info];\n+            let ti = none::<@tydesc_info>;\n             call_tydesc_glue_full(cx, body, tydesc,\n                                   abi::tydesc_field_drop_glue, ti);\n             if (!bcx_ccx(cx).sess.get_opts().do_gc) {\n@@ -1362,7 +1362,7 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n             let tydescptr =\n                 cx.build.GEP(body,\n                              ~[C_int(0), C_int(abi::closure_elt_tydesc)]);\n-            let ti = none[@tydesc_info];\n+            let ti = none::<@tydesc_info>;\n             call_tydesc_glue_full(cx, bindings, cx.build.Load(tydescptr),\n                                   abi::tydesc_field_drop_glue, ti);\n             if (!bcx_ccx(cx).sess.get_opts().do_gc) {\n@@ -1571,7 +1571,7 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"), C_bool(false));\n       }\n       ty::ty_native(_) {\n-        trans_fail(cx, none[span],\n+        trans_fail(cx, none::<span>,\n                    \"attempt to compare values of type native\");\n         ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"), C_bool(false));\n       }\n@@ -1757,7 +1757,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n     fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n                     variant: &ty::variant_info, tps: &[ty::t],\n                     tid: &ast::def_id, f: &val_and_ty_fn) -> result {\n-        if std::vec::len[ty::t](variant.args) == 0u {\n+        if std::vec::len::<ty::t>(variant.args) == 0u {\n             ret rslt(cx, C_nil());\n         }\n         let fn_ty = variant.ctor_ty;\n@@ -2012,7 +2012,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n                                          \"copy\");\n-                ti.copy_glue = some[ValueRef](glue_fn);\n+                ti.copy_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   make_copy_glue, ti.ty_params,\n                                   \"take\");\n@@ -2030,7 +2030,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n                                          \"drop\");\n-                ti.drop_glue = some[ValueRef](glue_fn);\n+                ti.drop_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   make_drop_glue, ti.ty_params,\n                                   \"drop\");\n@@ -2048,7 +2048,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n                                          \"free\");\n-                ti.free_glue = some[ValueRef](glue_fn);\n+                ti.free_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   make_free_glue, ti.ty_params,\n                                   \"free\");\n@@ -2114,7 +2114,7 @@ fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n \n fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t, field: int) ->\n    result {\n-    let ti: option::t<@tydesc_info> = none[@tydesc_info];\n+    let ti: option::t<@tydesc_info> = none::<@tydesc_info>;\n     let td = get_tydesc(cx, t, false, ti);\n     call_tydesc_glue_full(td.bcx, spill_if_immediate(td.bcx, v, t), td.val,\n                           field, ti);\n@@ -2130,7 +2130,7 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n     let llrhs = spill_if_immediate(cx, rhs, t);\n     let llrawlhsptr = cx.build.BitCast(lllhs, T_ptr(T_i8()));\n     let llrawrhsptr = cx.build.BitCast(llrhs, T_ptr(T_i8()));\n-    let ti = none[@tydesc_info];\n+    let ti = none::<@tydesc_info>;\n     let r = get_tydesc(cx, t, false, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, ti);\n     let lltydesc = r.val;\n@@ -2545,10 +2545,10 @@ fn trans_vec_append(cx: &@block_ctxt, t: &ty::t, lhs: ValueRef, rhs: ValueRef)\n       _ { }\n     }\n     let bcx = cx;\n-    let ti = none[@tydesc_info];\n+    let ti = none::<@tydesc_info>;\n     let llvec_tydesc = get_tydesc(bcx, t, false, ti);\n     bcx = llvec_tydesc.bcx;\n-    ti = none[@tydesc_info];\n+    ti = none::<@tydesc_info>;\n     let llelt_tydesc = get_tydesc(bcx, elt_ty, false, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_copy_glue, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, ti);\n@@ -3346,13 +3346,13 @@ fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &[result]) ->\n             bbs += ~[r.bcx.llbb];\n         }\n     }\n-    alt std::vec::len[result](live) {\n+    alt std::vec::len::<result>(live) {\n       0u {\n         // No incoming edges are live, so we're in dead-code-land.\n         // Arbitrarily pick the first dead edge, since the caller\n         // is just going to propagate it outward.\n \n-        assert (std::vec::len[result](ins) >= 1u);\n+        assert (std::vec::len::<result>(ins) >= 1u);\n         ret ins.(0);\n       }\n       _ {/* fall through */ }\n@@ -3427,7 +3427,8 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n              body: &ast::blk, outer_next_cx: @block_ctxt) -> result {\n         let next_cx = new_sub_block_ctxt(cx, \"next\");\n         let scope_cx =\n-            new_loop_scope_block_ctxt(cx, option::some[@block_ctxt](next_cx),\n+            new_loop_scope_block_ctxt(cx,\n+                                      option::some::<@block_ctxt>(next_cx),\n                                       outer_next_cx, \"for loop scope\");\n         cx.build.Br(scope_cx.llbb);\n         let local_res = alloc_local(scope_cx, local);\n@@ -3728,7 +3729,7 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n       ast::expr_call(f, args) {\n         let pair =\n             create_real_fn_pair(cx, iter_body_llty, lliterbody, llenv.ptr);\n-        r = trans_call(cx, f, some[ValueRef](cx.build.Load(pair)), args,\n+        r = trans_call(cx, f, some::<ValueRef>(cx.build.Load(pair)), args,\n                        seq.id);\n         ret rslt(r.bcx, C_nil());\n       }\n@@ -3740,7 +3741,7 @@ fn trans_while(cx: &@block_ctxt, cond: &@ast::expr, body: &ast::blk) ->\n     let cond_cx = new_scope_block_ctxt(cx, \"while cond\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let body_cx =\n-        new_loop_scope_block_ctxt(cx, option::none[@block_ctxt], next_cx,\n+        new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"while loop body\");\n     let body_res = trans_block(body_cx, body, return);\n     let cond_res = trans_expr(cond_cx, cond);\n@@ -3755,7 +3756,7 @@ fn trans_do_while(cx: &@block_ctxt, body: &ast::blk, cond: &@ast::expr) ->\n    result {\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let body_cx =\n-        new_loop_scope_block_ctxt(cx, option::none[@block_ctxt], next_cx,\n+        new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"do-while loop body\");\n     let body_res = trans_block(body_cx, body, return);\n     if is_terminated(body_res.bcx) {\n@@ -3791,17 +3792,17 @@ type lval_result =\n fn lval_mem(cx: &@block_ctxt, val: ValueRef) -> lval_result {\n     ret {res: rslt(cx, val),\n          is_mem: true,\n-         generic: none[generic_info],\n-         llobj: none[ValueRef],\n-         method_ty: none[ty::t]};\n+         generic: none::<generic_info>,\n+         llobj: none::<ValueRef>,\n+         method_ty: none::<ty::t>};\n }\n \n fn lval_val(cx: &@block_ctxt, val: ValueRef) -> lval_result {\n     ret {res: rslt(cx, val),\n          is_mem: false,\n-         generic: none[generic_info],\n-         llobj: none[ValueRef],\n-         method_ty: none[ty::t]};\n+         generic: none::<generic_info>,\n+         llobj: none::<ValueRef>,\n+         method_ty: none::<ty::t>};\n }\n \n fn trans_external_path(cx: &@block_ctxt, did: &ast::def_id,\n@@ -3824,14 +3825,14 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n         lv = lval_val(cx, trans_external_path(cx, fn_id, tpt));\n     }\n     let tys = ty::node_id_to_type_params(bcx_tcx(cx), id);\n-    if std::vec::len[ty::t](tys) != 0u {\n+    if std::vec::len::<ty::t>(tys) != 0u {\n         let bcx = lv.res.bcx;\n         let tydescs: [ValueRef] = ~[];\n         let tis: [option::t<@tydesc_info>] = ~[];\n         for t: ty::t in tys {\n             // TODO: Doesn't always escape.\n \n-            let ti = none[@tydesc_info];\n+            let ti = none::<@tydesc_info>;\n             let td = get_tydesc(bcx, t, true, ti);\n             tis += ~[ti];\n             bcx = td.bcx;\n@@ -3972,7 +3973,7 @@ fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: &ty::t,\n                             ty::ty_fn_ret(tcx, fn_ty), 0u);\n         v = r.bcx.build.PointerCast(v, T_ptr(T_ptr(ll_fn_ty)));\n         let lvo = lval_mem(r.bcx, v);\n-        ret {llobj: some[ValueRef](r.val), method_ty: some[ty::t](fn_ty)\n+        ret {llobj: some::<ValueRef>(r.val), method_ty: some::<ty::t>(fn_ty)\n                 with lvo};\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"field variant in trans_field\"); }\n@@ -4027,7 +4028,7 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n     bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n     // fail: bad bounds check.\n \n-    trans_fail(fail_cx, some[span](sp), \"bounds check\");\n+    trans_fail(fail_cx, some::<span>(sp), \"bounds check\");\n     let body;\n     alt interior_len_and_data {\n       some(lad) { body = lad.data; }\n@@ -4126,7 +4127,7 @@ fn trans_lval(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n       some(gi) {\n         let t = ty::expr_ty(bcx_tcx(cx), e);\n         let n_args = std::vec::len(ty::ty_fn_args(bcx_tcx(cx), t));\n-        let args = std::vec::init_elt(none[@ast::expr], n_args);\n+        let args = std::vec::init_elt(none::<@ast::expr>, n_args);\n         let bound = trans_bind_1(lv.res.bcx, e, lv, args, e.id);\n         ret lval_val(bound.bcx, bound.val);\n       }\n@@ -4768,7 +4769,7 @@ fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     let data_sz =\n-        bcx.build.Mul(C_uint(std::vec::len[@ast::expr](args)), unit_sz.val);\n+        bcx.build.Mul(C_uint(std::vec::len::<@ast::expr>(args)), unit_sz.val);\n     // FIXME: pass tydesc properly.\n \n     let vec_val =\n@@ -4781,7 +4782,7 @@ fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n     let body = bcx.build.GEP(vec_val, ~[C_int(0), C_int(abi::vec_elt_data)]);\n     let pseudo_tup_ty =\n         ty::mk_tup(bcx_tcx(cx),\n-                       std::vec::init_elt[ty::t](unit_ty,\n+                       std::vec::init_elt::<ty::t>(unit_ty,\n                                                   std::vec::len(args)));\n     let i: int = 0;\n     for e: @ast::expr in args {\n@@ -5100,7 +5101,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       }\n       ast::expr_bind(f, args) { ret trans_bind(cx, f, args, e.id); }\n       ast::expr_call(f, args) {\n-        ret trans_call(cx, f, none[ValueRef], args, e.id);\n+        ret trans_call(cx, f, none::<ValueRef>, args, e.id);\n       }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n       ast::expr_vec(args, _, ast::sk_rc.) { ret trans_vec(cx, args, e.id); }\n@@ -5237,7 +5238,7 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     let e_ty = ty::expr_ty(bcx_tcx(cx), e);\n     let log_bcx = sub.bcx;\n \n-    let ti = none[@tydesc_info];\n+    let ti = none::<@tydesc_info>;\n     let r = get_tydesc(log_bcx, e_ty, false, ti);\n     log_bcx = r.bcx;\n \n@@ -5257,7 +5258,7 @@ fn trans_check_expr(cx: &@block_ctxt, e: &@ast::expr, s: &str) -> result {\n     let cond_res = trans_expr(cx, e);\n     let expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n     let fail_cx = new_sub_block_ctxt(cx, \"fail\");\n-    trans_fail(fail_cx, some[span](e.span), expr_str);\n+    trans_fail(fail_cx, some::<span>(e.span), expr_str);\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     cond_res.bcx.build.CondBr(cond_res.val, next_cx.llbb, fail_cx.llbb);\n     ret rslt(next_cx, C_nil());\n@@ -5587,9 +5588,9 @@ fn trans_block_cleanups(cx: &@block_ctxt, cleanup_cx: &@block_ctxt) ->\n    @block_ctxt {\n     let bcx = cx;\n     if cleanup_cx.kind == NON_SCOPE_BLOCK {\n-        assert (std::vec::len[cleanup](cleanup_cx.cleanups) == 0u);\n+        assert (std::vec::len::<cleanup>(cleanup_cx.cleanups) == 0u);\n     }\n-    let i = std::vec::len[cleanup](cleanup_cx.cleanups);\n+    let i = std::vec::len::<cleanup>(cleanup_cx.cleanups);\n     while i > 0u {\n         i -= 1u;\n         let c = cleanup_cx.cleanups.(i);\n@@ -5788,13 +5789,15 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: &span, llfndecl: ValueRef,\n     let llretptr: ValueRef = llvm::LLVMGetParam(llfndecl, 0u);\n     let lltaskptr: ValueRef = llvm::LLVMGetParam(llfndecl, 1u);\n     let llenv: ValueRef = llvm::LLVMGetParam(llfndecl, 2u);\n-    let llargs: hashmap<ast::node_id, ValueRef> = new_int_hash[ValueRef]();\n+    let llargs: hashmap<ast::node_id, ValueRef> = new_int_hash::<ValueRef>();\n     let llobjfields: hashmap<ast::node_id, ValueRef> =\n-        new_int_hash[ValueRef]();\n-    let lllocals: hashmap<ast::node_id, ValueRef> = new_int_hash[ValueRef]();\n-    let llupvars: hashmap<ast::node_id, ValueRef> = new_int_hash[ValueRef]();\n+        new_int_hash::<ValueRef>();\n+    let lllocals: hashmap<ast::node_id, ValueRef> =\n+        new_int_hash::<ValueRef>();\n+    let llupvars: hashmap<ast::node_id, ValueRef> =\n+        new_int_hash::<ValueRef>();\n     let derived_tydescs =\n-        map::mk_hashmap[ty::t, derived_tydesc_info](ty::hash_ty, ty::eq_ty);\n+        map::mk_hashmap::<ty::t, derived_tydesc_info>(ty::hash_ty, ty::eq_ty);\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n           lltaskptr: lltaskptr,\n@@ -5805,9 +5808,9 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: &span, llfndecl: ValueRef,\n           mutable llderivedtydescs_first: llbbs.dt,\n           mutable llderivedtydescs: llbbs.dt,\n           mutable lldynamicallocas: llbbs.da,\n-          mutable llself: none[val_self_pair],\n-          mutable lliterbody: none[ValueRef],\n-          mutable iterbodyty: none[ty::t],\n+          mutable llself: none::<val_self_pair>,\n+          mutable lliterbody: none::<ValueRef>,\n+          mutable iterbodyty: none::<ty::t>,\n           llargs: llargs,\n           llobjfields: llobjfields,\n           lllocals: lllocals,\n@@ -5845,7 +5848,7 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n     // way.\n     let arg_n = 3u;\n     alt ty_self {\n-      some(tt) { cx.llself = some[val_self_pair]({v: cx.llenv, t: tt}); }\n+      some(tt) { cx.llself = some::<val_self_pair>({v: cx.llenv, t: tt}); }\n       none. {\n         let i = 0u;\n         for tp: ast::ty_param in ty_params {\n@@ -5865,7 +5868,7 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n         cx.iterbodyty = some(ty::mk_iter_body_fn(fcx_tcx(cx), ret_ty));\n         let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n         assert (llarg as int != 0);\n-        cx.lliterbody = some[ValueRef](llarg);\n+        cx.lliterbody = some::<ValueRef>(llarg);\n         arg_n += 1u;\n     }\n \n@@ -5942,7 +5945,7 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     // its magic.\n \n     let fields_tup_ty = ty::mk_tup(fcx.lcx.ccx.tcx, field_tys);\n-    let n_typarams = std::vec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n+    let n_typarams = std::vec::len::<ast::ty_param>(bcx.fcx.lcx.obj_typarams);\n     let llobj_box_ty: TypeRef = T_obj_ptr(*bcx_ccx(bcx), n_typarams);\n     let box_cell =\n         bcx.build.GEP(llself.v, ~[C_int(0), C_int(abi::obj_field_box)]);\n@@ -6100,7 +6103,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t], ret_t,\n+    create_llargs_for_fn_args(fcx, ast::proto_fn, none::<ty::t>, ret_t,\n                               dtor.decl.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n@@ -6132,7 +6135,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n                      variant: &ast::variant, index: int, is_degen: bool,\n                      ty_params: &[ast::ty_param]) {\n-    if std::vec::len[ast::variant_arg](variant.node.args) == 0u {\n+    if std::vec::len::<ast::variant_arg>(variant.node.args) == 0u {\n         ret; // nullary constructors are just constants\n \n     }\n@@ -6157,7 +6160,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n       }\n     }\n     let fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n+    create_llargs_for_fn_args(fcx, ast::proto_fn, none::<ty::t>,\n                               ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n                               fn_args, ty_params);\n     let ty_param_substs: [ty::t] = ~[];\n@@ -6328,7 +6331,7 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n       ty::ty_fn(proto, inputs, output, _, _) {\n         llfty =\n             type_of_fn(ccx, sp, proto, inputs, output,\n-                       std::vec::len[ast::ty_param](ty_params));\n+                       std::vec::len::<ast::ty_param>(ty_params));\n       }\n       _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n     }\n@@ -6349,7 +6352,7 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n                        main_llfn: ValueRef, main_node_type: ty::t) {\n \n-    if ccx.main_fn != none[ValueRef] {\n+    if ccx.main_fn != none::<ValueRef> {\n         ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n     }\n \n@@ -6537,7 +6540,7 @@ fn native_fn_ty_param_count(cx: &@crate_ctxt, id: ast::node_id) -> uint {\n                         actually a fn\");\n       }\n       ast::native_item_fn(_, _, tps) {\n-        count = std::vec::len[ast::ty_param](tps);\n+        count = std::vec::len::<ast::ty_param>(tps);\n       }\n     }\n     ret count;\n@@ -6850,7 +6853,7 @@ fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n     alt it.node {\n       ast::item_tag(variants, _) {\n         let i = 0u;\n-        let n_variants = std::vec::len[ast::variant](variants);\n+        let n_variants = std::vec::len::<ast::variant>(variants);\n         while i < n_variants {\n             let variant = variants.(i);\n             let p = new_pt + ~[it.ident, variant.node.name, \"discrim\"];\n@@ -6917,7 +6920,7 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n         decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i64\",\n                       T_fn(T_memset64_args, T_void()));\n     let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args, T_void()));\n-    let intrinsics = new_str_hash[ValueRef]();\n+    let intrinsics = new_str_hash::<ValueRef>();\n     intrinsics.insert(\"llvm.gcread\", gcread);\n     intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n     intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n@@ -7019,7 +7022,7 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n         mapname = ccx.link_meta.name;\n     } else { mapname = \"toplevel\"; }\n     let sym_name = \"_rust_crate_map_\" + mapname;\n-    let arrtype = T_array(T_int(), std::vec::len[ValueRef](subcrates));\n+    let arrtype = T_array(T_int(), std::vec::len::<ValueRef>(subcrates));\n     let maptype = T_struct(~[T_int(), arrtype]);\n     let map = llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(sym_name));\n     llvm::LLVMSetLinkage(map,\n@@ -7073,32 +7076,32 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n     let glues = make_glues(llmod, taskptr_type);\n     let hasher = ty::hash_ty;\n     let eqer = ty::eq_ty;\n-    let tag_sizes = map::mk_hashmap[ty::t, uint](hasher, eqer);\n-    let tydescs = map::mk_hashmap[ty::t, @tydesc_info](hasher, eqer);\n-    let lltypes = map::mk_hashmap[ty::t, TypeRef](hasher, eqer);\n-    let sha1s = map::mk_hashmap[ty::t, str](hasher, eqer);\n-    let short_names = map::mk_hashmap[ty::t, str](hasher, eqer);\n+    let tag_sizes = map::mk_hashmap::<ty::t, uint>(hasher, eqer);\n+    let tydescs = map::mk_hashmap::<ty::t, @tydesc_info>(hasher, eqer);\n+    let lltypes = map::mk_hashmap::<ty::t, TypeRef>(hasher, eqer);\n+    let sha1s = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n+    let short_names = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n     let sha = std::sha1::mk_sha1();\n     let ccx =\n         @{sess: sess,\n           llmod: llmod,\n           td: td,\n           tn: tn,\n-          externs: new_str_hash[ValueRef](),\n+          externs: new_str_hash::<ValueRef>(),\n           intrinsics: intrinsics,\n-          item_ids: new_int_hash[ValueRef](),\n+          item_ids: new_int_hash::<ValueRef>(),\n           ast_map: amap,\n-          item_symbols: new_int_hash[str](),\n-          mutable main_fn: none[ValueRef],\n+          item_symbols: new_int_hash::<str>(),\n+          mutable main_fn: none::<ValueRef>,\n           link_meta: link::build_link_meta(sess, *crate, output, sha),\n           tag_sizes: tag_sizes,\n-          discrims: new_int_hash[ValueRef](),\n-          discrim_symbols: new_int_hash[str](),\n-          fn_pairs: new_int_hash[ValueRef](),\n-          consts: new_int_hash[ValueRef](),\n-          obj_methods: new_int_hash[()](),\n+          discrims: new_int_hash::<ValueRef>(),\n+          discrim_symbols: new_int_hash::<str>(),\n+          fn_pairs: new_int_hash::<ValueRef>(),\n+          consts: new_int_hash::<ValueRef>(),\n+          obj_methods: new_int_hash::<()>(),\n           tydescs: tydescs,\n-          module_data: new_str_hash[ValueRef](),\n+          module_data: new_str_hash::<ValueRef>(),\n           lltypes: lltypes,\n           glues: glues,\n           names: namegen(0),"}, {"sha": "1c7be7a3583550201ab10b2ab88599dc1e8ae18e", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -250,7 +250,7 @@ type fn_ctxt = {\n \n     // For convenience, a vector of the incoming tydescs for each of\n     // this functions type parameters, fetched via llvm::LLVMGetParam.\n-    // For example, for a function foo[A, B, C](), lltydescs contains\n+    // For example, for a function foo::<A, B, C>(), lltydescs contains\n     // the ValueRefs for the tydescs for A, B, and C.\n     mutable lltydescs: [ValueRef],\n \n@@ -510,7 +510,7 @@ fn T_size_t() -> TypeRef {\n \n fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n     ret llvm::LLVMFunctionType(output, std::vec::to_ptr(inputs),\n-                               std::vec::len[TypeRef](inputs), False);\n+                               std::vec::len::<TypeRef>(inputs), False);\n }\n \n fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n@@ -570,9 +570,9 @@ fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n-        std::vec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n+        std::vec::init_elt::<TypeRef>(T_nil(), abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n-                                    std::vec::to_ptr[TypeRef](tydesc_elts));\n+                                    std::vec::to_ptr::<TypeRef>(tydesc_elts));\n     let t = llvm::LLVMGetElementType(tydesc_elts.(field));\n     ret t;\n }\n@@ -742,7 +742,7 @@ fn T_opaque_tag_ptr(tn: &type_names) -> TypeRef {\n }\n \n fn T_captured_tydescs(cx: &crate_ctxt, n: uint) -> TypeRef {\n-    ret T_struct(std::vec::init_elt[TypeRef](T_ptr(cx.tydesc_type), n));\n+    ret T_struct(std::vec::init_elt::<TypeRef>(T_ptr(cx.tydesc_type), n));\n }\n \n fn T_obj_ptr(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {"}, {"sha": "4b2e8f20738faffbeda5d55aeb2d49314e3f0d2d", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -51,7 +51,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n     // Both regular arguments and type parameters are handled here.\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n+    create_llargs_for_fn_args(fcx, ast::proto_fn, none::<ty::t>,\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n                               ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n@@ -95,8 +95,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // typarams, and fields.\n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n \n-    if std::vec::len[ast::ty_param](ty_params) == 0u &&\n-           std::vec::len[ty::arg](arg_tys) == 0u {\n+    if std::vec::len::<ast::ty_param>(ty_params) == 0u &&\n+           std::vec::len::<ty::arg>(arg_tys) == 0u {\n         // If the object we're translating has no fields or type parameters,\n         // there's not much to do.\n \n@@ -132,7 +132,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n             GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n-        let ti = none[@tydesc_info];\n+        let ti = none::<@tydesc_info>;\n         let body_td = get_tydesc(bcx, body_ty, true, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n@@ -295,7 +295,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     // typarams, fields, and a pointer to our inner_obj.\n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n \n-    if std::vec::len[ast::anon_obj_field](additional_fields) == 0u &&\n+    if std::vec::len::<ast::anon_obj_field>(additional_fields) == 0u &&\n            anon_obj.inner_obj == none {\n \n         // If the object we're translating has no fields and no inner_obj,\n@@ -326,7 +326,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n             GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n-        let ti = none[@tydesc_info];\n+        let ti = none::<@tydesc_info>;\n         let body_td = get_tydesc(bcx, body_ty, true, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n@@ -460,7 +460,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n \n         // Sort and process all the methods.\n         let meths =\n-            std::sort::merge_sort[@ast::method]\n+            std::sort::merge_sort::<@ast::method>\n             (bind ast_mthd_lteq(_, _), ob.methods);\n \n         for m: @ast::method in meths {\n@@ -496,15 +496,15 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n         // Filter out any methods that we don't need forwarding slots for\n         // because they're being overridden.\n         let f = bind filtering_fn(cx, _, ob.methods);\n-        meths = std::vec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n+        meths = std::vec::filter_map::<vtbl_mthd, vtbl_mthd>(f, meths);\n \n         // And now add the additional ones, both overriding ones and entirely\n         // new ones.  These will just be normal methods.\n         for m: @ast::method in ob.methods { meths += ~[normal_mthd(m)]; }\n \n         // Sort all the methods and process them.\n         meths =\n-            std::sort::merge_sort[vtbl_mthd]\n+            std::sort::merge_sort::<vtbl_mthd>\n             (bind vtbl_mthd_lteq(_, _), meths);\n \n         // To create forwarding methods, we'll need a \"backwarding\" vtbl.  See\n@@ -615,7 +615,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Get the backwarding function's type and declare it.\n     let llbackwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n-                        std::vec::len[ast::ty_param](ty_params));\n+                        std::vec::len::<ast::ty_param>(ty_params));\n     let llbackwarding_fn: ValueRef =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llbackwarding_fn_ty);\n \n@@ -684,7 +684,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         type_of_fn_full(bcx_ccx(bcx), sp,\n                         ty::ty_fn_proto(bcx_tcx(bcx), outer_mthd_ty), true,\n                         m.inputs, m.output,\n-                        std::vec::len[ast::ty_param](ty_params));\n+                        std::vec::len::<ast::ty_param>(ty_params));\n     llouter_mthd =\n         bcx.build.PointerCast(llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n     llouter_mthd = bcx.build.Load(llouter_mthd);\n@@ -747,7 +747,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Get the forwarding function's type and declare it.\n     let llforwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n-                        std::vec::len[ast::ty_param](ty_params));\n+                        std::vec::len::<ast::ty_param>(ty_params));\n     let llforwarding_fn: ValueRef =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n \n@@ -844,7 +844,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         type_of_fn_full(bcx_ccx(bcx), sp,\n                         ty::ty_fn_proto(bcx_tcx(bcx), orig_mthd_ty), true,\n                         m.inputs, m.output,\n-                        std::vec::len[ast::ty_param](ty_params));\n+                        std::vec::len::<ast::ty_param>(ty_params));\n     llorig_mthd =\n         bcx.build.PointerCast(llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n     llorig_mthd = bcx.build.Load(llorig_mthd);\n@@ -923,7 +923,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       ty::ty_fn(proto, inputs, output, _, _) {\n         llfnty =\n             type_of_fn_full(cx.ccx, m.span, proto, true, inputs, output,\n-                            std::vec::len[ast::ty_param](ty_params));\n+                            std::vec::len::<ast::ty_param>(ty_params));\n       }\n     }\n     let mcx: @local_ctxt ="}, {"sha": "30799bdbc950971e49d6f580ca3d695d38e78cbf", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -170,8 +170,8 @@ fn log_states_err(pp: &pre_and_post_state) {\n fn print_ident(i: &ident) { log \" \" + i + \" \"; }\n \n fn print_idents(idents: &mutable [ident]) {\n-    if vec::len[ident](idents) == 0u { ret; }\n-    log \"an ident: \" + vec::pop[ident](idents);\n+    if vec::len::<ident>(idents) == 0u { ret; }\n+    log \"an ident: \" + vec::pop::<ident>(idents);\n     print_idents(idents);\n }\n \n@@ -320,8 +320,8 @@ fn add_node(ccx: &crate_ctxt, i: node_id, a: &ts_ann) {\n \n fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t<ts_ann> {\n     if i as uint < vec::len(*ccx.node_anns) {\n-        ret some[ts_ann](ccx.node_anns.(i));\n-    } else { ret none[ts_ann]; }\n+        ret some::<ts_ann>(ccx.node_anns.(i));\n+    } else { ret none::<ts_ann>; }\n }\n \n \n@@ -508,7 +508,7 @@ fn num_constraints(m: fn_info) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n     let na: [mutable ts_ann] = ~[mutable];\n-    ret {tcx: cx, node_anns: @mutable na, fm: @new_int_hash[fn_info]()};\n+    ret {tcx: cx, node_anns: @mutable na, fm: @new_int_hash::<fn_info>()};\n }\n \n /* Use e's type to determine whether it returns."}, {"sha": "7ead3a9d8362ccdb0527193f1a563a8fc5582bec", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -160,7 +160,7 @@ fn relax_precond_block_inner(b: &blk, cx: &relax_ctxt,\n \n fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b:&blk) {\n     let cx = {fcx: fcx, i: i};\n-    let visitor = visit::default_visitor[relax_ctxt]();\n+    let visitor = visit::default_visitor::<relax_ctxt>();\n     visitor =\n         @{visit_block: relax_precond_block_inner,\n           visit_expr: relax_precond_expr,"}, {"sha": "00b5ba3d7ecbf94a23b6053f279a10d945dd1cb1", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -131,7 +131,7 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n        because we want the smallest possible erroneous statement\n        or expression. */\n \n-    let visitor = visit::default_visitor[fn_ctxt]();\n+    let visitor = visit::default_visitor::<fn_ctxt>();\n \n     visitor =\n         @{visit_stmt: check_states_stmt,\n@@ -205,7 +205,7 @@ fn check_crate(cx: ty::ctxt, crate: @crate) {\n     annotate_crate(ccx, *crate);\n     /* Compute the pre and postcondition for every subexpression */\n \n-    let vtor = visit::default_visitor[crate_ctxt]();\n+    let vtor = visit::default_visitor::<crate_ctxt>();\n     vtor = @{visit_fn: fn_pre_post with *vtor};\n     visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n "}, {"sha": "ad975f54216c2b96cf03a39ed56ac264b07b06fb", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -46,7 +46,7 @@ fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n                i: &fn_ident, id: node_id) -> ctxt {\n     let cx: ctxt = {cs: @mutable ~[], tcx: tcx};\n-    let visitor = visit::default_visitor[ctxt]();\n+    let visitor = visit::default_visitor::<ctxt>();\n \n     visitor =\n         @{visit_local: collect_local,\n@@ -91,7 +91,7 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n               f_name: &fn_ident, id: node_id) {\n     let name = fn_ident_to_string(id, f_name);\n-    let res_map = @new_def_hash[constraint]();\n+    let res_map = @new_def_hash::<constraint>();\n     let next: uint = 0u;\n \n     let cx: ctxt = find_locals(ccx.tcx, f, tp, f_sp, f_name, id);"}, {"sha": "5f6d0dcdf01c639a9b8159f1c95c7d16872244f7", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -75,7 +75,7 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n         let v: @mutable [node_id] = @mutable ~[];\n         let fake_fcx =\n             {enclosing:\n-                 {constrs: @new_def_hash[constraint](),\n+                 {constrs: @new_def_hash::<constraint>(),\n                   num_constraints: 0u,\n                   cf: return,\n                   // just bogus\n@@ -115,7 +115,7 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n    the preconditions for <args>, and the postcondition in a to\n    be the union of all postconditions for <args> */\n fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n-    if vec::len[@expr](args) > 0u {\n+    if vec::len::<@expr>(args) > 0u {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args.(0));\n     }\n@@ -125,7 +125,7 @@ fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n     fn get_pp(ccx: crate_ctxt, e: &@expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    let pps = vec::map[@expr, pre_and_post](bind get_pp(fcx.ccx, _), args);\n+    let pps = vec::map::<@expr, pre_and_post>(bind get_pp(fcx.ccx, _), args);\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n                      seq_postconds(fcx, vec::map(get_post, pps)));\n@@ -509,7 +509,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n               postcondition: false_postcond(num_local_vars)};\n         let g = bind combine_pp(antec_pp, fcx, _, _);\n         let alts_overall_pp =\n-            vec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n+            vec::foldl::<pre_and_post, pre_and_post>(g, e_pp, alt_pps);\n         set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n                          alts_overall_pp.postcondition);\n       }\n@@ -680,7 +680,7 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n     for s: @stmt in b.node.stmts { do_one_(fcx, s); }\n     fn do_inner_(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n     let do_inner = bind do_inner_(fcx, _);\n-    option::map[@expr, ()](do_inner, b.node.expr);\n+    option::map::<@expr, ()>(do_inner, b.node.expr);\n \n     let pps: [pre_and_post] = ~[];\n     for s: @stmt in b.node.stmts { pps += ~[stmt_pp(fcx.ccx, *s)]; }"}, {"sha": "c7de964bb8d3aca7900a9c5627fcc32bc7fc8a5d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -398,9 +398,9 @@ fn mk_rcache() -> creader_cache {\n fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map) -> ctxt {\n     let ntt: node_type_table =\n-        @smallintmap::mk[ty::ty_param_substs_opt_and_ty]();\n-    let tcache = new_def_hash[ty::ty_param_kinds_and_ty]();\n-    let ts = @interner::mk[@raw_t](hash_raw_ty, eq_raw_ty);\n+        @smallintmap::mk::<ty::ty_param_substs_opt_and_ty>();\n+    let tcache = new_def_hash::<ty::ty_param_kinds_and_ty>();\n+    let ts = @interner::mk::<@raw_t>(hash_raw_ty, eq_raw_ty);\n     let cx =\n         @{ts: ts,\n           sess: s,\n@@ -428,7 +428,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t<str>) -> @raw_t {\n     let has_vars: bool = false;\n     fn derive_flags_t(cx: &ctxt, has_params: &mutable bool,\n                       has_vars: &mutable bool, tt: &t) {\n-        let rt = interner::get[@raw_t](*cx.ts, tt);\n+        let rt = interner::get::<@raw_t>(*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n         has_vars = has_vars || rt.has_vars;\n     }\n@@ -1148,7 +1148,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_istr. { ret false; }\n       ty_tag(_, subtys) {\n         let i = 0u;\n-        while i < vec::len[t](subtys) {\n+        while i < vec::len::<t>(subtys) {\n             if type_has_dynamic_size(cx, subtys.(i)) { ret true; }\n             i += 1u;\n         }\n@@ -1160,7 +1160,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_ptr(_) { ret false; }\n       ty_rec(fields) {\n         let i = 0u;\n-        while i < vec::len[field](fields) {\n+        while i < vec::len::<field>(fields) {\n             if type_has_dynamic_size(cx, fields.(i).mt.ty) { ret true; }\n             i += 1u;\n         }\n@@ -1599,8 +1599,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n     fn equal_fn(args_a: &[arg], rty_a: &t, args_b: &[arg], rty_b: &t) ->\n        bool {\n         if !eq_ty(rty_a, rty_b) { ret false; }\n-        let len = vec::len[arg](args_a);\n-        if len != vec::len[arg](args_b) { ret false; }\n+        let len = vec::len::<arg>(args_a);\n+        if len != vec::len::<arg>(args_b) { ret false; }\n         let i = 0u;\n         while i < len {\n             let arg_a = args_a.(i);\n@@ -1636,8 +1636,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n         alt b {\n           ty_tag(id_b, tys_b) {\n             if !equal_def(id_a, id_b) { ret false; }\n-            let len = vec::len[t](tys_a);\n-            if len != vec::len[t](tys_b) { ret false; }\n+            let len = vec::len::<t>(tys_a);\n+            if len != vec::len::<t>(tys_b) { ret false; }\n             let i = 0u;\n             while i < len {\n                 if !eq_ty(tys_a.(i), tys_b.(i)) { ret false; }\n@@ -1663,8 +1663,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n       ty_rec(flds_a) {\n         alt b {\n           ty_rec(flds_b) {\n-            let len = vec::len[field](flds_a);\n-            if len != vec::len[field](flds_b) { ret false; }\n+            let len = vec::len::<field>(flds_a);\n+            if len != vec::len::<field>(flds_b) { ret false; }\n             let i = 0u;\n             while i < len {\n                 let fld_a = flds_a.(i);\n@@ -1716,8 +1716,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n       ty_obj(methods_a) {\n         alt b {\n           ty_obj(methods_b) {\n-            let len = vec::len[method](methods_a);\n-            if len != vec::len[method](methods_b) { ret false; }\n+            let len = vec::len::<method>(methods_a);\n+            if len != vec::len::<method>(methods_b) { ret false; }\n             let i = 0u;\n             while i < len {\n                 let m_a = methods_a.(i);\n@@ -1874,7 +1874,7 @@ fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n     let param_indices: @mutable [uint] = @mutable ~[];\n     let f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n-    ret vec::len[uint](*param_indices);\n+    ret vec::len::<uint>(*param_indices);\n }\n \n fn type_contains_vars(cx: &ctxt, typ: &t) -> bool {\n@@ -1995,7 +1995,7 @@ fn sort_methods(meths: &[method]) -> [method] {\n     fn method_lteq(a: &method, b: &method) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n-    ret std::sort::merge_sort[method](bind method_lteq(_, _), meths);\n+    ret std::sort::merge_sort::<method>(bind method_lteq(_, _), meths);\n }\n \n fn is_lval(expr: &@ast::expr) -> bool {\n@@ -2071,7 +2071,7 @@ mod unify {\n     type ctxt = {vb: @var_bindings, tcx: ty_ctxt};\n \n     fn mk_var_bindings() -> @var_bindings {\n-        ret @{sets: ufind::make(), types: smallintmap::mk[t]()};\n+        ret @{sets: ufind::make(), types: smallintmap::mk::<t>()};\n     }\n \n     // Unifies two sets.\n@@ -2084,7 +2084,7 @@ mod unify {\n             bind fn (cx: &@ctxt, t: t, set_a: uint, set_b: uint) {\n                      ufind::union(cx.vb.sets, set_a, set_b);\n                      let root_c: uint = ufind::find(cx.vb.sets, set_a);\n-                     smallintmap::insert[t](cx.vb.types, root_c, t);\n+                     smallintmap::insert::<t>(cx.vb.types, root_c, t);\n                  }(_, _, set_a, set_b);\n \n \n@@ -2115,7 +2115,7 @@ mod unify {\n         ufind::grow(cx.vb.sets, (key as uint) + 1u);\n         let root = ufind::find(cx.vb.sets, key as uint);\n         let result_type = typ;\n-        alt smallintmap::find[t](cx.vb.types, root) {\n+        alt smallintmap::find::<t>(cx.vb.types, root) {\n           some(old_type) {\n             alt unify_step(cx, old_type, typ) {\n               ures_ok(unified_type) { result_type = unified_type; }\n@@ -2124,7 +2124,7 @@ mod unify {\n           }\n           none. {/* fall through */ }\n         }\n-        smallintmap::insert[t](cx.vb.types, root, result_type);\n+        smallintmap::insert::<t>(cx.vb.types, root, result_type);\n         ret ures_ok(typ);\n     }\n \n@@ -2212,8 +2212,8 @@ mod unify {\n                        expected_inputs: &[arg], expected_output: &t,\n                        actual_inputs: &[arg], actual_output: &t) ->\n        fn_common_res {\n-        let expected_len = vec::len[arg](expected_inputs);\n-        let actual_len = vec::len[arg](actual_inputs);\n+        let expected_len = vec::len::<arg>(expected_inputs);\n+        let actual_len = vec::len::<arg>(actual_inputs);\n         if expected_len != actual_len {\n             ret fn_common_res_err(ures_err(terr_arg_count));\n         }\n@@ -2309,8 +2309,8 @@ mod unify {\n        result {\n         let result_meths: [method] = ~[];\n         let i: uint = 0u;\n-        let expected_len: uint = vec::len[method](expected_meths);\n-        let actual_len: uint = vec::len[method](actual_meths);\n+        let expected_len: uint = vec::len::<method>(expected_meths);\n+        let actual_len: uint = vec::len::<method>(actual_meths);\n         if expected_len != actual_len { ret ures_err(terr_meth_count); }\n         while i < expected_len {\n             let e_meth = expected_meths.(i);\n@@ -2350,7 +2350,7 @@ mod unify {\n                 ret fix_err(vid);\n             }\n             let root_id = ufind::find(vb.sets, vid as uint);\n-            alt smallintmap::find[t](vb.types, root_id) {\n+            alt smallintmap::find::<t>(vb.types, root_id) {\n               none. { ret fix_err(vid); }\n               some(rt) { ret fix_ok(rt); }\n             }\n@@ -2451,7 +2451,7 @@ mod unify {\n                 // TODO: factor this cruft out\n                 let result_tps: [t] = ~[];\n                 let i = 0u;\n-                let expected_len = vec::len[t](expected_tps);\n+                let expected_len = vec::len::<t>(expected_tps);\n                 while i < expected_len {\n                     let expected_tp = expected_tps.(i);\n                     let actual_tp = actual_tps.(i);\n@@ -2592,8 +2592,8 @@ mod unify {\n           ty::ty_rec(expected_fields) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_rec(actual_fields) {\n-                let expected_len = vec::len[field](expected_fields);\n-                let actual_len = vec::len[field](actual_fields);\n+                let expected_len = vec::len::<field>(expected_fields);\n+                let actual_len = vec::len::<field>(actual_fields);\n                 if expected_len != actual_len {\n                     let err = terr_record_size(expected_len, actual_len);\n                     ret ures_err(err);\n@@ -2733,17 +2733,17 @@ mod unify {\n     }\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n         let i = 0u;\n-        while i < vec::len[ufind::node](vb.sets.nodes) {\n+        while i < vec::len::<ufind::node>(vb.sets.nodes) {\n             let sets = \"\";\n             let j = 0u;\n-            while j < vec::len[option::t<uint>](vb.sets.nodes) {\n+            while j < vec::len::<option::t<uint>>(vb.sets.nodes) {\n                 if ufind::find(vb.sets, j) == i {\n                     sets += #fmt(\" %u\", j);\n                 }\n                 j += 1u;\n             }\n             let typespec;\n-            alt smallintmap::find[t](vb.types, i) {\n+            alt smallintmap::find::<t>(vb.types, i) {\n               none. { typespec = \"\"; }\n               some(typ) { typespec = \" =\" + ty_to_str(tcx, typ); }\n             }\n@@ -2767,7 +2767,7 @@ mod unify {\n                 ret ty::mk_var(tcx, vid);\n             }\n             let root_id = ufind::find(vb.sets, vid as uint);\n-            alt smallintmap::find[t](vb.types, root_id) {\n+            alt smallintmap::find::<t>(vb.types, root_id) {\n               none. { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n               some(rt) {\n                 if occurs_check_fails(tcx, sp, vid, rt) {\n@@ -2779,7 +2779,7 @@ mod unify {\n               }\n             }\n         }\n-        let unresolved = @mutable none[int];\n+        let unresolved = @mutable none::<int>;\n         let rty =\n             fold_ty(tcx, fm_var(bind subst_vars(tcx, sp, vb, unresolved, _)),\n                     typ);\n@@ -2794,7 +2794,7 @@ mod unify {\n        fixup_result {\n         if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufind::find(vb.sets, vid as uint);\n-        alt smallintmap::find[t](vb.types, root_id) {\n+        alt smallintmap::find::<t>(vb.types, root_id) {\n           none. { ret fix_err(vid); }\n           some(rt) { ret fixup_vars(tcx, sp, vb, rt); }\n         }\n@@ -2947,7 +2947,7 @@ fn tag_variant_with_id(cx: &ctxt, tag_id: &ast::def_id,\n                        variant_id: &ast::def_id) -> variant_info {\n     let variants = tag_variants(cx, tag_id);\n     let i = 0u;\n-    while i < vec::len[variant_info](variants) {\n+    while i < vec::len::<variant_info>(variants) {\n         let variant = variants.(i);\n         if def_eq(variant.id, variant_id) { ret variant; }\n         i += 1u;"}, {"sha": "13d5fef9ded56a430fd114e0bdc240fd805910d2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -164,7 +164,7 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n                             ty_param_count);\n     let ty_param_vars = bind_result.ids;\n     let ty_substs_opt;\n-    let ty_substs_len = vec::len[@ast::ty](pth.node.types);\n+    let ty_substs_len = vec::len::<@ast::ty>(pth.node.types);\n     if ty_substs_len > 0u {\n         let param_var_len = vec::len(ty_param_vars);\n         if param_var_len == 0u {\n@@ -186,7 +186,7 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n             ty_substs += ~[res_ty];\n             i += 1u;\n         }\n-        ty_substs_opt = some[[ty::t]](ty_substs);\n+        ty_substs_opt = some::<[ty::t]>(ty_substs);\n         if ty_param_count == 0u {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                         \"this item does not take type \\\n@@ -200,7 +200,7 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n             ty_substs += ~[ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n             i += 1u;\n         }\n-        ty_substs_opt = some[[ty::t]](ty_substs);\n+        ty_substs_opt = some::<[ty::t]>(ty_substs);\n     }\n     ret {substs: ty_substs_opt, ty: tpt.ty};\n }\n@@ -271,7 +271,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       none. { }\n     } /* go on */\n \n-    tcx.ast_ty_to_ty_cache.insert(ast_ty, none[ty::t]);\n+    tcx.ast_ty_to_ty_cache.insert(ast_ty, none::<ty::t>);\n     fn ast_arg_to_arg(tcx: &ty::ctxt, getter: &ty_getter, arg: &ast::ty_arg)\n        -> {mode: ty::mode, ty: ty::t} {\n         let ty_mode = ast_mode_to_mode(arg.node.mode);\n@@ -309,7 +309,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         ret typ;\n     }\n     let typ;\n-    let cname = none[str];\n+    let cname = none::<str>;\n     alt ast_ty.node {\n       ast::ty_nil. { typ = ty::mk_nil(tcx); }\n       ast::ty_bot. { typ = ty::mk_bot(tcx); }\n@@ -476,23 +476,23 @@ mod write {\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(tcx: &ty::ctxt, node_id: ast::node_id, typ: ty::t) {\n-        ty(tcx, node_id, {substs: none[[ty::t]], ty: typ});\n+        ty(tcx, node_id, {substs: none::<[ty::t]>, ty: typ});\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(fcx: @fn_ctxt, node_id: ast::node_id, typ: ty::t) {\n-        ret ty_fixup(fcx, node_id, {substs: none[[ty::t]], ty: typ});\n+        ret ty_fixup(fcx, node_id, {substs: none::<[ty::t]>, ty: typ});\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(tcx: &ty::ctxt, node_id: ast::node_id) {\n-        ret ty(tcx, node_id, {substs: none[[ty::t]], ty: ty::mk_nil(tcx)});\n+        ret ty(tcx, node_id, {substs: none::<[ty::t]>, ty: ty::mk_nil(tcx)});\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(tcx: &ty::ctxt, node_id: ast::node_id) {\n-        ret ty(tcx, node_id, {substs: none[[ty::t]], ty: ty::mk_bot(tcx)});\n+        ret ty(tcx, node_id, {substs: none::<[ty::t]>, ty: ty::mk_bot(tcx)});\n     }\n }\n \n@@ -745,7 +745,7 @@ mod collect {\n             // constructors get turned into functions.\n \n             let result_ty;\n-            if vec::len[ast::variant_arg](variant.node.args) == 0u {\n+            if vec::len::<ast::variant_arg>(variant.node.args) == 0u {\n                 result_ty = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n@@ -784,7 +784,7 @@ mod collect {\n           ast::item_native_mod(native_mod) {\n             // Propagate the native ABI down to convert_native() below,\n             // but otherwise do nothing, as native modules have no types.\n-            *abi = some[ast::native_abi](native_mod.abi);\n+            *abi = some::<ast::native_abi>(native_mod.abi);\n           }\n           ast::item_tag(variants, ty_params) {\n             let tpt = ty_of_item(cx, it);\n@@ -806,7 +806,7 @@ mod collect {\n             // ty_of_obj().)\n             let method_types = get_obj_method_types(cx, object);\n             let i = 0u;\n-            while i < vec::len[@ast::method](object.methods) {\n+            while i < vec::len::<@ast::method>(object.methods) {\n                 write::ty_only(cx.tcx, object.methods.(i).node.id,\n                                ty::method_ty_to_fn_ty(cx.tcx,\n                                                       method_types.(i)));\n@@ -818,7 +818,7 @@ mod collect {\n             // an assertion in trans.\n             let args = ty::ty_fn_args(cx.tcx, tpt.ty);\n             i = 0u;\n-            while i < vec::len[ty::arg](args) {\n+            while i < vec::len::<ty::arg>(args) {\n                 let fld = object.fields.(i);\n                 write::ty_only(cx.tcx, fld.id, args.(i).ty);\n                 i += 1u;\n@@ -856,7 +856,8 @@ mod collect {\n         // type of the native item. We simply write it into the node type\n         // table.\n         let tpt =\n-            ty_of_native_item(cx, i, option::get[ast::native_abi]({ *abi }));\n+            ty_of_native_item(cx, i,\n+                              option::get::<ast::native_abi>({ *abi }));\n         alt i.node {\n           ast::native_item_ty. {\n             // FIXME: Native types have no annotation. Should they? --pcw\n@@ -869,7 +870,7 @@ mod collect {\n     fn collect_item_types(tcx: &ty::ctxt, crate: &@ast::crate) {\n         // We have to propagate the surrounding ABI to the native items\n         // contained within the native module.\n-        let abi = @mutable none[ast::native_abi];\n+        let abi = @mutable none::<ast::native_abi>;\n         let cx = @{tcx: tcx};\n         let visit = visit::mk_simple_visitor\n             (@{visit_item: bind convert(cx, abi, _),\n@@ -1101,16 +1102,16 @@ mod writeback {\n             };\n         let new_substs_opt;\n         alt tpot.substs {\n-          none[[ty::t]]. { new_substs_opt = none[[ty::t]]; }\n-          some[[ty::t]](substs) {\n+          none::<[ty::t]>. { new_substs_opt = none::<[ty::t]>; }\n+          some::<[ty::t]>(substs) {\n             let new_substs: [ty::t] = ~[];\n             for subst: ty::t in substs {\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n                   some(t) { new_substs += ~[t]; }\n                   none. { wbcx.success = false; ret; }\n                 }\n             }\n-            new_substs_opt = some[[ty::t]](new_substs);\n+            new_substs_opt = some::<[ty::t]>(new_substs);\n           }\n         }\n         write::ty(fcx.ccx.tcx, id, {substs: new_substs_opt, ty: new_ty});\n@@ -1207,8 +1208,8 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     let {vb, locals, local_names, nvi} = alt old_fcx {\n       none. {\n         { vb: ty::unify::mk_var_bindings(),\n-          locals: new_int_hash[int](),\n-          local_names: new_int_hash[ast::ident](),\n+          locals: new_int_hash::<int>(),\n+          local_names: new_int_hash::<ast::ident>(),\n           nvi: @mutable 0 }\n       }\n       some(fcx) {\n@@ -1357,17 +1358,17 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                 demand::with_substs(fcx, pat.span, expected, ctor_ty,\n                                     expected_tps);\n             path_tpot =\n-                {substs: some[[ty::t]](path_tpt.substs), ty: path_tpt.ty};\n+                {substs: some::<[ty::t]>(path_tpt.substs), ty: path_tpt.ty};\n \n             // Get the number of arguments in this tag variant.\n             let arg_types =\n                 variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n                                   expected_tps);\n-            let subpats_len = std::vec::len[@ast::pat](subpats);\n-            if std::vec::len[ty::t](arg_types) > 0u {\n+            let subpats_len = std::vec::len::<@ast::pat>(subpats);\n+            if std::vec::len::<ty::t>(arg_types) > 0u {\n                 // N-ary variant.\n \n-                let arg_len = vec::len[ty::t](arg_types);\n+                let arg_len = vec::len::<ty::t>(arg_types);\n                 if arg_len != subpats_len {\n                     // TODO: note definition of tag variant\n                     // TODO (issue #448): Wrap a #fmt string over multiple\n@@ -1586,8 +1587,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n \n         // Check that the correct number of arguments were supplied.\n-        let expected_arg_count = vec::len[ty::arg](arg_tys);\n-        let supplied_arg_count = vec::len[option::t<@ast::expr>](args);\n+        let expected_arg_count = vec::len::<ty::arg>(arg_tys);\n+        let supplied_arg_count = vec::len::<option::t<@ast::expr>>(args);\n         if expected_arg_count != supplied_arg_count {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                         #fmt(\"this function takes %u \\\n@@ -1649,7 +1650,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                   args: &[@ast::expr], call_kind: call_kind) -> bool {\n         let args_opt_0: [option::t<@ast::expr>] = ~[];\n         for arg: @ast::expr in args {\n-            args_opt_0 += ~[some[@ast::expr](arg)];\n+            args_opt_0 += ~[some::<@ast::expr>(arg)];\n         }\n \n         // Call the generic checker.\n@@ -1870,7 +1871,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         } else {\n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n-            if vec::len[@ast::ty](pth.node.types) > 0u {\n+            if vec::len::<@ast::ty>(pth.node.types) > 0u {\n                 tcx.sess.span_fatal(expr.span,\n                                     \"this kind of value does not \\\n                                      take type parameters\");\n@@ -2093,7 +2094,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             // For each blank argument, add the type of that argument\n             // to the resulting function type.\n             let i = 0u;\n-            while i < vec::len[option::t<@ast::expr>](args) {\n+            while i < vec::len::<option::t<@ast::expr>>(args) {\n                 alt args.(i) {\n                   some(_) {/* no-op */ }\n                   none. { arg_tys_1 += ~[arg_tys.(i)]; }\n@@ -2259,15 +2260,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           ty::ty_rec(fields) {\n             let ix: uint =\n                 ty::field_idx(tcx.sess, expr.span, field, fields);\n-            if ix >= vec::len[ty::field](fields) {\n+            if ix >= vec::len::<ty::field>(fields) {\n                 tcx.sess.span_fatal(expr.span, \"bad index on record\");\n             }\n             write::ty_only_fixup(fcx, id, fields.(ix).mt.ty);\n           }\n           ty::ty_obj(methods) {\n             let ix: uint =\n                 ty::method_idx(tcx.sess, expr.span, field, methods);\n-            if ix >= vec::len[ty::method](methods) {\n+            if ix >= vec::len::<ty::method>(methods) {\n                 tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n             }\n             let meth = methods.(ix);\n@@ -2420,8 +2421,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n \n             let f = bind filtering_fn(fcx.ccx, _, ao.methods);\n             inner_obj_methods =\n-                std::vec::filter_map[ty::method,\n-                                      ty::method](f, inner_obj_methods);\n+                std::vec::filter_map::<ty::method,\n+                                       ty::method>(f, inner_obj_methods);\n \n             method_types += inner_obj_methods;\n         }\n@@ -2433,7 +2434,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         // Write the methods into the node type table.  (This happens in\n         // collect::convert for regular objects.)\n         let i = 0u;\n-        while i < vec::len[@ast::method](ao.methods) {\n+        while i < vec::len::<@ast::method>(ao.methods) {\n             write::ty_only(tcx, ao.methods.(i).node.id,\n                            ty::method_ty_to_fn_ty(tcx,\n                                                   method_types.(i)));\n@@ -2446,7 +2447,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n \n         // Now remove the info from the stack.\n-        vec::pop[obj_info](fcx.ccx.obj_infos);\n+        vec::pop::<obj_info>(fcx.ccx.obj_infos);\n       }\n       ast::expr_uniq(x) {\n         let t = next_ty_var(fcx);\n@@ -2474,7 +2475,7 @@ fn next_ty_var(fcx: &@fn_ctxt) -> ty::t {\n }\n \n fn get_obj_info(ccx: &@crate_ctxt) -> option::t<obj_info> {\n-    ret vec::last[obj_info](ccx.obj_infos);\n+    ret vec::last::<obj_info>(ccx.obj_infos);\n }\n \n fn check_decl_initializer(fcx: &@fn_ctxt, nid: ast::node_id,\n@@ -2569,8 +2570,8 @@ fn check_const(ccx: &@crate_ctxt, sp: &span, e: &@ast::expr,\n           purity: ast::pure_fn,\n           proto: ast::proto_fn,\n           var_bindings: ty::unify::mk_var_bindings(),\n-          locals: new_int_hash[int](),\n-          local_names: new_int_hash[ast::ident](),\n+          locals: new_int_hash::<int>(),\n+          local_names: new_int_hash::<ast::ident>(),\n           next_var_id: @mutable 0,\n           mutable fixups: fixups,\n           ccx: ccx};\n@@ -2653,7 +2654,7 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n         for method: @ast::method in ob.methods { check_method(ccx, method); }\n \n         // Now remove the info from the stack.\n-        vec::pop[obj_info](ccx.obj_infos);\n+        vec::pop::<obj_info>(ccx.obj_infos);\n       }\n       _ {/* nothing to do */ }\n     }"}, {"sha": "9fedd515620bb1237206e9b1e170711e1731c17c", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -142,7 +142,7 @@ type pat_id_map = std::map::hashmap<str, ast::node_id>;\n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(pat: &@pat) -> pat_id_map {\n-    let map = std::map::new_str_hash[node_id]();\n+    let map = std::map::new_str_hash::<node_id>();\n     for each bound in pat_bindings(pat) {\n         let name = alt bound.node { pat_bind(n) { n } };\n         map.insert(name, bound.id);\n@@ -661,7 +661,7 @@ fn eq_ty(a: &@ty, b: &@ty) -> bool { ret std::box::ptr_eq(a, b); }\n fn hash_ty(t: &@ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n \n fn block_from_expr(e: @expr) -> blk {\n-    let blk_ = {stmts: ~[], expr: option::some[@expr](e), id: e.id};\n+    let blk_ = {stmts: ~[], expr: option::some::<@expr>(e), id: e.id};\n     ret {node: blk_, span: e.span};\n }\n "}, {"sha": "9c0ea438678e966c5c95a8acd5348450bbb36873", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -20,7 +20,7 @@ tag syntax_extension {\n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n-    let syntax_expanders = new_str_hash[syntax_extension]();\n+    let syntax_expanders = new_str_hash::<syntax_extension>();\n     syntax_expanders.insert(\"fmt\", normal(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\"env\", normal(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(\"macro\","}, {"sha": "0ec14a1a39947468cfaeb2f703b741c0c74cc12c", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -16,7 +16,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\") }\n     };\n-    if vec::len[@ast::expr](args) != 1u {\n+    if vec::len::<@ast::expr>(args) != 1u {\n         cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an"}, {"sha": "2dd607d1cfb1a3a766e7d4732ac444618d9fd2c5", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -21,7 +21,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\") }\n     };\n-    if vec::len[@ast::expr](args) == 0u {\n+    if vec::len::<@ast::expr>(args) == 0u {\n         cx.span_fatal(sp, \"#fmt requires a format string\");\n     }\n     let fmt =\n@@ -93,7 +93,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 {node: {mut: ast::imm, ident: ident, expr: val}, span: sp};\n             astfields += ~[astfield];\n         }\n-        let recexpr = ast::expr_rec(astfields, option::none[@ast::expr]);\n+        let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n         ret @{id: cx.next_id(), node: recexpr, span: sp};\n     }\n     fn make_path_vec(cx: &ext_ctxt, ident: str) -> [str] {\n@@ -130,7 +130,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n \n-            if vec::len[@ast::expr](flagexprs) == 0u {\n+            if vec::len::<@ast::expr>(flagexprs) == 0u {\n                 flagexprs += ~[make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n@@ -307,7 +307,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     let fmt_sp = args.(0).span;\n     let n = 0u;\n     let tmp_expr = make_new_str(cx, sp, \"\");\n-    let nargs = vec::len[@ast::expr](args);\n+    let nargs = vec::len::<@ast::expr>(args);\n     for pc: piece in pieces {\n         alt pc {\n           piece_string(s) {"}, {"sha": "41ef3e976ea988a4d05675ec55d08635872cb4b2", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -9,7 +9,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\") }\n     };\n-    if vec::len[@ast::expr](args) != 1u {\n+    if vec::len::<@ast::expr>(args) != 1u {\n         cx.span_fatal(sp, \"malformed #ident_to_str call\");\n     }\n "}, {"sha": "a0443aeee82901447aff621b46645726576c5180", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -167,7 +167,7 @@ fn acumm_bindings(cx: &ext_ctxt, b_dest: &bindings, b_src: &bindings) { }\n \n fn pattern_to_selectors(cx: &ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n-        {real_binders: new_str_hash[selector](),\n+        {real_binders: new_str_hash::<selector>(),\n          mutable literal_ast_matchers: ~[]};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n@@ -183,7 +183,7 @@ bindings. Most of the work is done in p_t_s, which generates the\n selectors. */\n \n fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n-    let res = new_str_hash[arb_depth<matchable>]();\n+    let res = new_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for sel: selector in b.literal_ast_matchers {\n         alt sel(match_expr(e)) { none. { ret none; } _ { } }\n@@ -262,7 +262,7 @@ fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n \n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n iter free_vars(b: &bindings, e: @expr) -> ident {\n-    let idents: hashmap<ident, ()> = new_str_hash[()]();\n+    let idents: hashmap<ident, ()> = new_str_hash::<()>();\n     fn mark_ident(i: &ident, fld: ast_fold, b: &bindings,\n                   idents: &hashmap<ident, ()>) -> ident {\n         if b.contains_key(i) { idents.insert(i, ()); }"}, {"sha": "eadb63f766cd94c24239c2a04265c63c6457b46e", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -488,9 +488,9 @@ fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n     ret {ty: fld.fold_ty(l.ty),\n          pat: fld.fold_pat(l.pat),\n          init: alt l.init {\n-           option::none[initializer]. { l.init }\n-           option::some[initializer](init) {\n-             option::some[initializer]({op: init.op,\n+           option::none::<initializer>. { l.init }\n+           option::some::<initializer>(init) {\n+             option::some::<initializer>({op: init.op,\n                                         expr: fld.fold_expr(init.expr)})\n            }\n          },"}, {"sha": "ecf3cf87fa6781633682b9b29ddc41ca7c208c8c", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -188,7 +188,7 @@ fn scan_exponent(rdr: &reader) -> option::t<str> {\n         if str::byte_len(exponent) > 0u {\n             ret some(rslt + exponent);\n         } else { rdr.err(\"scan_exponent: bad fp literal\"); fail; }\n-    } else { ret none[str]; }\n+    } else { ret none::<str>; }\n }\n \n fn scan_dec_digits(rdr: &reader) -> str {\n@@ -301,14 +301,14 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n \n             }\n         } else {\n-            ret token::LIT_FLOAT(interner::intern[str](*rdr.get_interner(),\n+            ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n                                                        float_str));\n         }\n     }\n     let maybe_exponent = scan_exponent(rdr);\n     alt maybe_exponent {\n       some(s) {\n-        ret token::LIT_FLOAT(interner::intern[str](*rdr.get_interner(),\n+        ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n                                                    dec_str + s));\n       }\n       none. { ret token::LIT_INT(accum_int); }\n@@ -350,7 +350,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n         }\n         if str::eq(accum_str, \"_\") { ret token::UNDERSCORE; }\n         let is_mod_name = c == ':' && rdr.next() == ':';\n-        ret token::IDENT(interner::intern[str](*rdr.get_interner(),\n+        ret token::IDENT(interner::intern::<str>(*rdr.get_interner(),\n                                                accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) { ret scan_number(c, rdr); }\n@@ -510,7 +510,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n             }\n         }\n         rdr.bump();\n-        ret token::LIT_STR(interner::intern[str](*rdr.get_interner(),\n+        ret token::LIT_STR(interner::intern::<str>(*rdr.get_interner(),\n                                                  accum_str));\n       }\n       '-' {\n@@ -712,7 +712,7 @@ fn gather_comments_and_literals(cm: &codemap::codemap, path: str,\n                                 srdr: io::reader) ->\n    {cmnts: [cmnt], lits: [lit]} {\n     let src = str::unsafe_from_bytes(srdr.read_whole_stream());\n-    let itr = @interner::mk[str](str::hash, str::eq);\n+    let itr = @interner::mk::<str>(str::hash, str::eq);\n     let rdr = new_reader(cm, src, codemap::new_filemap(path, 0u, 0u), itr);\n     let comments: [cmnt] = ~[];\n     let literals: [lit] = ~[];"}, {"sha": "2cd31d5b3c184a19203ff0fb809b1025ff098b03", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -672,7 +672,7 @@ fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: fn(&parser) -> T,\n                       p: &parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, token::LT);\n-    let result = parse_seq_to_before_gt[T](sep, f, p);\n+    let result = parse_seq_to_before_gt::<T>(sep, f, p);\n     let hi = p.get_hi_pos();\n     expect_gt(p);\n     ret spanned(lo, hi, result);\n@@ -705,7 +705,7 @@ fn parse_seq<T>(bra: token::token, ket: token::token,\n                 p: &parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, bra);\n-    let result = parse_seq_to_before_end[T](ket, sep, f, p);\n+    let result = parse_seq_to_before_end::<T>(ket, sep, f, p);\n     let hi = p.get_hi_pos();\n     p.bump();\n     ret spanned(lo, hi, result);"}, {"sha": "64088ec8f0a18542cc1c4323616567b18c8c28fc", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -153,12 +153,12 @@ fn to_str(r: lexer::reader, t: token) -> str {\n         ret int::to_str(i, 10u) + \"_\" + ty_mach_to_str(tm);\n       }\n       LIT_MACH_FLOAT(tm, s) {\n-        ret interner::get[str](*r.get_interner(), s) + \"_\" +\n+        ret interner::get::<str>(*r.get_interner(), s) + \"_\" +\n                 ty_mach_to_str(tm);\n       }\n-      LIT_FLOAT(s) { ret interner::get[str](*r.get_interner(), s); }\n+      LIT_FLOAT(s) { ret interner::get::<str>(*r.get_interner(), s); }\n       LIT_STR(s) { // FIXME: escape.\n-        ret \"\\\"\" + interner::get[str](*r.get_interner(), s) + \"\\\"\";\n+        ret \"\\\"\" + interner::get::<str>(*r.get_interner(), s) + \"\\\"\";\n       }\n       LIT_CHAR(c) {\n         // FIXME: escape.\n@@ -171,7 +171,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n       /* Name components */\n       IDENT(s, _) {\n-        ret interner::get[str](*r.get_interner(), s);\n+        ret interner::get::<str>(*r.get_interner(), s);\n       }\n       IDX(i) { ret \"_\" + int::to_str(i, 10u); }\n       UNDERSCORE. { ret \"_\"; }"}, {"sha": "7bd89ed36d9e99d3580dd5e9d7c02f5e9b87fbe4", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -55,9 +55,9 @@ fn end(s: &ps) { vec::pop(s.boxes); pp::end(s.s); }\n fn rust_printer(writer: io::writer) -> ps {\n     let boxes: [pp::breaks] = ~[];\n     ret @{s: pp::mk_printer(writer, default_columns),\n-          cm: none[codemap],\n-          comments: none[[lexer::cmnt]],\n-          literals: none[[lexer::lit]],\n+          cm: none::<codemap>,\n+          comments: none::<[lexer::cmnt]>,\n+          literals: none::<[lexer::lit]>,\n           mutable cur_cmnt: 0u,\n           mutable cur_lit: 0u,\n           mutable boxes: boxes,\n@@ -231,7 +231,7 @@ fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n                      get_span: fn(&IN) -> codemap::span ) {\n     box(s, 0u, b);\n-    let len = vec::len[IN](elts);\n+    let len = vec::len::<IN>(elts);\n     let i = 0u;\n     for elt: IN in elts {\n         maybe_print_comment(s, get_span(elt).hi);\n@@ -327,7 +327,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n           pclose(s);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n-        print_ty_fn(s, proto, none[str], inputs, output, cf, constrs);\n+        print_ty_fn(s, proto, none::<str>, inputs, output, cf, constrs);\n       }\n       ast::ty_obj(methods) {\n         head(s, \"obj\");\n@@ -486,7 +486,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n                     pclose(s);\n                 }\n                 word(s.s, \";\");\n-                maybe_print_trailing_comment(s, v.span, none[uint]);\n+                maybe_print_trailing_comment(s, v.span, none::<uint>);\n             }\n             bclose(s, item.span);\n         }\n@@ -575,7 +575,7 @@ fn print_stmt(s: &ps, st: &ast::stmt) {\n       ast::stmt_expr(expr, _) { space_if_not_bol(s); print_expr(s, expr); }\n     }\n     if parse::parser::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n-    maybe_print_trailing_comment(s, st.span, none[uint]);\n+    maybe_print_trailing_comment(s, st.span, none::<uint>);\n }\n \n fn print_block(s: &ps, blk: &ast::blk) {\n@@ -1436,9 +1436,9 @@ fn next_lit(s: &ps) -> option::t<lexer::lit> {\n       some(lits) {\n         if s.cur_lit < vec::len(lits) {\n             ret some(lits.(s.cur_lit));\n-        } else { ret none[lexer::lit]; }\n+        } else { ret none::<lexer::lit>; }\n       }\n-      _ { ret none[lexer::lit]; }\n+      _ { ret none::<lexer::lit>; }\n     }\n }\n \n@@ -1528,9 +1528,9 @@ fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n       some(cmnts) {\n         if s.cur_cmnt < vec::len(cmnts) {\n             ret some(cmnts.(s.cur_cmnt));\n-        } else { ret none[lexer::cmnt]; }\n+        } else { ret none::<lexer::cmnt>; }\n       }\n-      _ { ret none[lexer::cmnt]; }\n+      _ { ret none::<lexer::cmnt>; }\n     }\n }\n \n@@ -1542,7 +1542,7 @@ fn constr_args_to_str<T>(f: &fn(&T) -> str ,\n     let s = \"(\";\n     for a: @ast::sp_constr_arg<T> in args {\n         if comma { s += \", \"; } else { comma = true; }\n-        s += constr_arg_to_str[T](f, a.node);\n+        s += constr_arg_to_str::<T>(f, a.node);\n     }\n     s += \")\";\n     ret s;\n@@ -1611,7 +1611,7 @@ fn proto_to_str(p: &ast::proto) -> str {\n \n fn ty_constr_to_str(c: &@ast::ty_constr) -> str {\n     ret path_to_str(c.node.path) +\n-            constr_args_to_str[ast::path](path_to_str, c.node.args);\n+            constr_args_to_str::<ast::path>(path_to_str, c.node.args);\n }\n \n "}, {"sha": "0b80bdd5bfde7b02349fcacb327fb70aa2970cb3", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -17,15 +17,15 @@ type interner<T> =\n      eqer: eqfn<T>};\n \n fn mk<@T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n-    let m = map::mk_hashmap[T, uint](hasher, eqer);\n+    let m = map::mk_hashmap::<T, uint>(hasher, eqer);\n     ret {map: m, mutable vect: ~[], hasher: hasher, eqer: eqer};\n }\n \n fn intern<@T>(itr: &interner<T>, val: &T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {\n-        let new_idx = vec::len[T](itr.vect);\n+        let new_idx = vec::len::<T>(itr.vect);\n         itr.map.insert(val, new_idx);\n         itr.vect += ~[val];\n         ret new_idx;"}, {"sha": "fd7a6b22661a0f6403e477e6be56294d54dd02f1", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -36,20 +36,20 @@ type visitor<E> =\n           fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt<E>) };\n \n fn default_visitor<E>() -> visitor<E> {\n-    ret @{visit_mod: bind visit_mod[E](_, _, _, _),\n-          visit_view_item: bind visit_view_item[E](_, _, _),\n-          visit_native_item: bind visit_native_item[E](_, _, _),\n-          visit_item: bind visit_item[E](_, _, _),\n-          visit_local: bind visit_local[E](_, _, _),\n-          visit_block: bind visit_block[E](_, _, _),\n-          visit_stmt: bind visit_stmt[E](_, _, _),\n-          visit_arm: bind visit_arm[E](_, _, _),\n-          visit_pat: bind visit_pat[E](_, _, _),\n-          visit_decl: bind visit_decl[E](_, _, _),\n-          visit_expr: bind visit_expr[E](_, _, _),\n-          visit_ty: bind visit_ty[E](_, _, _),\n-          visit_constr: bind visit_constr[E](_, _, _, _, _),\n-          visit_fn: bind visit_fn[E](_, _, _, _, _, _, _)};\n+    ret @{visit_mod: bind visit_mod::<E>(_, _, _, _),\n+          visit_view_item: bind visit_view_item::<E>(_, _, _),\n+          visit_native_item: bind visit_native_item::<E>(_, _, _),\n+          visit_item: bind visit_item::<E>(_, _, _),\n+          visit_local: bind visit_local::<E>(_, _, _),\n+          visit_block: bind visit_block::<E>(_, _, _),\n+          visit_stmt: bind visit_stmt::<E>(_, _, _),\n+          visit_arm: bind visit_arm::<E>(_, _, _),\n+          visit_pat: bind visit_pat::<E>(_, _, _),\n+          visit_decl: bind visit_decl::<E>(_, _, _),\n+          visit_expr: bind visit_expr::<E>(_, _, _),\n+          visit_ty: bind visit_ty::<E>(_, _, _),\n+          visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n+          visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _)};\n }\n \n fn visit_crate<E>(c: &crate, e: &E, v: &vt<E>) {"}, {"sha": "984e047834bb9b68e90429d44887ef6d2b3c6172", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -44,7 +44,7 @@ fn hash_def(d: &ast::def_id) -> uint {\n fn new_def_hash<@V>() -> std::map::hashmap<ast::def_id, V> {\n     let hasher: std::map::hashfn<ast::def_id> = hash_def;\n     let eqer: std::map::eqfn<ast::def_id> = def_eq;\n-    ret std::map::mk_hashmap[ast::def_id, V](hasher, eqer);\n+    ret std::map::mk_hashmap::<ast::def_id, V>(hasher, eqer);\n }\n \n fn field_expr(f: &ast::field) -> @ast::expr { ret f.node.expr; }"}, {"sha": "37ba49b0a676113bb915b031b695b83c70958616", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af21a2700278154bcfc81d61297add21c6870689/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=af21a2700278154bcfc81d61297add21c6870689", "patch": "@@ -61,7 +61,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         ret s;\n     }\n     fn method_to_str(cx: &ctxt, m: &method) -> str {\n-        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident), m.inputs,\n+        ret fn_to_str(cx, m.proto, some::<ast::ident>(m.ident), m.inputs,\n                       m.output, m.cf, m.constrs) + \";\";\n     }\n     fn field_to_str(cx: &ctxt, f: &field) -> str {\n@@ -109,7 +109,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         // The user should never see this if the cname is set properly!\n \n         s += \"<tag#\" + int::str(id.crate) + \":\" + int::str(id.node) + \">\";\n-        if vec::len[t](tps) > 0u {\n+        if vec::len::<t>(tps) > 0u {\n             let strs: [str] = ~[];\n             for typ: t in tps { strs += ~[ty_to_str(cx, typ)]; }\n             s += \"[\" + str::connect(strs, \",\") + \"]\";\n@@ -165,7 +165,7 @@ fn constrs_str(constrs: &[@constr]) -> str {\n fn ty_constr_to_str<Q>(c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n    -> str {\n     ret path_to_str(c.node.path) +\n-            constr_args_to_str[ast::path](path_to_str, c.node.args);\n+            constr_args_to_str::<ast::path>(path_to_str, c.node.args);\n }\n \n // Local Variables:"}]}