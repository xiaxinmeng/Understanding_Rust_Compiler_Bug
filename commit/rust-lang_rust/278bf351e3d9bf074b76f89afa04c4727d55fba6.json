{"sha": "278bf351e3d9bf074b76f89afa04c4727d55fba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OGJmMzUxZTNkOWJmMDc0Yjc2Zjg5YWZhMDRjNDcyN2Q1NWZiYTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-23T15:35:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-23T15:35:31Z"}, "message": "Merge #4065\n\n4065: Complete unqualified enum names in patterns and expressions r=matklad a=nathanwhit\n\nThis PR implements the completion described in #4014.\r\nThe result looks like so for patterns:\r\n<img width=\"542\" alt=\"Screen Shot 2020-04-20 at 3 53 55 PM\" src=\"https://user-images.githubusercontent.com/17734409/79794010-8f529400-831f-11ea-9673-f838aa9bc962.png\">\r\n\r\nand for `expr`s:\r\n<img width=\"620\" alt=\"Screen Shot 2020-04-21 at 3 51 24 PM\" src=\"https://user-images.githubusercontent.com/17734409/79908784-d73ded80-83e9-11ea-991d-921f0cb27e6f.png\">\r\n\r\n\r\nI'm not confident that the completion text itself is very robust, as it will unconditionally add completions for enum variants with the form `Enum::Variant`. This means (I believe) it would still suggest `Enum::Variant` even if the local name is changed i.e. `use Enum as Foo` or the variants are brought into scope such as through `use Enum::*`.\n\nCo-authored-by: nathanwhit <nathan.whitaker01@gmail.com>", "tree": {"sha": "5c0dcf6a4e47a90f1d650fd7c33a6438a4bc3262", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c0dcf6a4e47a90f1d650fd7c33a6438a4bc3262"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/278bf351e3d9bf074b76f89afa04c4727d55fba6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeobXDCRBK7hj4Ov3rIwAAdHIIAF7JGDkgWysHBas41XJTuvMW\n2q6nDHYwgc6PN7quidDmSMeu8XCm2NrsHYwNN6IZdjrLD+v1BuEtjvTj+Ya75dY4\ntujbvf7pbKaQj1nwkgK1kPR7k5U4Nb/kmIbChjwuFrXigWPCUbY+5Doynlvynf8c\nyaJT1YQzlJxzWpF4q7wjic1AV2sXoBlkpO7XOsx095OELFMwaJy7LZzCPB4ox3pi\nhexUTMwdUI21OwGc7P4e4C2pqLT6f1S4YmJxVzwtIxPLpfj6IsG1EjvfgScEvjuz\nzSq/Vm/fCwD8BWqT5M2L1w5S97qYQ3mm0SBDD6XFMrWq+Dy7oMtQpg6tvUxAAiQ=\n=W8t6\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c0dcf6a4e47a90f1d650fd7c33a6438a4bc3262\nparent 4a18509a98149fb3d5c73dbf0c6de4cfa8d4596c\nparent dfde73ef90194f90704287876f0e5d3b0cfa2b11\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587656131 +0000\ncommitter GitHub <noreply@github.com> 1587656131 +0000\n\nMerge #4065\n\n4065: Complete unqualified enum names in patterns and expressions r=matklad a=nathanwhit\n\nThis PR implements the completion described in #4014.\r\nThe result looks like so for patterns:\r\n<img width=\"542\" alt=\"Screen Shot 2020-04-20 at 3 53 55 PM\" src=\"https://user-images.githubusercontent.com/17734409/79794010-8f529400-831f-11ea-9673-f838aa9bc962.png\">\r\n\r\nand for `expr`s:\r\n<img width=\"620\" alt=\"Screen Shot 2020-04-21 at 3 51 24 PM\" src=\"https://user-images.githubusercontent.com/17734409/79908784-d73ded80-83e9-11ea-991d-921f0cb27e6f.png\">\r\n\r\n\r\nI'm not confident that the completion text itself is very robust, as it will unconditionally add completions for enum variants with the form `Enum::Variant`. This means (I believe) it would still suggest `Enum::Variant` even if the local name is changed i.e. `use Enum as Foo` or the variants are brought into scope such as through `use Enum::*`.\n\nCo-authored-by: nathanwhit <nathan.whitaker01@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/278bf351e3d9bf074b76f89afa04c4727d55fba6", "html_url": "https://github.com/rust-lang/rust/commit/278bf351e3d9bf074b76f89afa04c4727d55fba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/278bf351e3d9bf074b76f89afa04c4727d55fba6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a18509a98149fb3d5c73dbf0c6de4cfa8d4596c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a18509a98149fb3d5c73dbf0c6de4cfa8d4596c", "html_url": "https://github.com/rust-lang/rust/commit/4a18509a98149fb3d5c73dbf0c6de4cfa8d4596c"}, {"sha": "dfde73ef90194f90704287876f0e5d3b0cfa2b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfde73ef90194f90704287876f0e5d3b0cfa2b11", "html_url": "https://github.com/rust-lang/rust/commit/dfde73ef90194f90704287876f0e5d3b0cfa2b11"}], "stats": {"total": 224, "additions": 217, "deletions": 7}, "files": [{"sha": "ad00154a3245614a754b802096c25a96575f9ba2", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 205, "deletions": 6, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/278bf351e3d9bf074b76f89afa04c4727d55fba6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278bf351e3d9bf074b76f89afa04c4727d55fba6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=278bf351e3d9bf074b76f89afa04c4727d55fba6", "patch": "@@ -4,20 +4,23 @@ use hir::ScopeDef;\n use test_utils::tested_by;\n \n use crate::completion::{CompletionContext, Completions};\n+use hir::{Adt, ModuleDef};\n use ra_syntax::AstNode;\n \n pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path {\n-        return;\n-    }\n-\n-    if ctx.is_pat_binding_or_const\n+    if (!ctx.is_trivial_path && !ctx.is_pat_binding_or_const)\n         || ctx.record_lit_syntax.is_some()\n         || ctx.record_pat_syntax.is_some()\n     {\n         return;\n     }\n \n+    complete_enum_variants(acc, ctx);\n+\n+    if ctx.is_pat_binding_or_const {\n+        return;\n+    }\n+\n     ctx.scope().process_all_names(&mut |name, res| {\n         if ctx.use_item_syntax.is_some() {\n             if let (ScopeDef::Unknown, Some(name_ref)) = (&res, &ctx.name_ref_syntax) {\n@@ -31,6 +34,24 @@ pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     });\n }\n \n+fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext) {\n+    if let Some(ty) = ctx.expected_type_of(&ctx.token.parent()) {\n+        if let Some(Adt::Enum(enum_data)) = ty.as_adt() {\n+            let variants = enum_data.variants(ctx.db);\n+            let module = enum_data.module(ctx.db);\n+            for variant in variants {\n+                if let Some(path) = module.find_use_path(ctx.db, ModuleDef::from(variant)) {\n+                    // Variants with trivial paths are already added by the existing completion logic,\n+                    // so we should avoid adding these twice\n+                    if path.segments.len() > 1 {\n+                        acc.add_enum_variant(ctx, variant, Some(path.to_string()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n@@ -82,7 +103,7 @@ mod tests {\n                 }\n                 \"\n             ),\n-            @r###\"[]\"###\n+            @\"[]\"\n         );\n     }\n \n@@ -1109,4 +1130,182 @@ mod tests {\n         \"###\n         );\n     }\n+    #[test]\n+    fn completes_enum_variant_matcharm() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                enum Foo {\n+                    Bar,\n+                    Baz,\n+                    Quux\n+                }\n+\n+                fn main() {\n+                    let foo = Foo::Quux;\n+\n+                    match foo {\n+                        Qu<|>\n+                    }\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Foo\",\n+                source_range: [248; 250),\n+                delete: [248; 250),\n+                insert: \"Foo\",\n+                kind: Enum,\n+            },\n+            CompletionItem {\n+                label: \"Foo::Bar\",\n+                source_range: [248; 250),\n+                delete: [248; 250),\n+                insert: \"Foo::Bar\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Foo::Baz\",\n+                source_range: [248; 250),\n+                delete: [248; 250),\n+                insert: \"Foo::Baz\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Foo::Quux\",\n+                source_range: [248; 250),\n+                delete: [248; 250),\n+                insert: \"Foo::Quux\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+        ]\n+        \"###\n+        )\n+    }\n+\n+    #[test]\n+    fn completes_enum_variant_iflet() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                enum Foo {\n+                    Bar,\n+                    Baz,\n+                    Quux\n+                }\n+\n+                fn main() {\n+                    let foo = Foo::Quux;\n+\n+                    if let Qu<|> = foo {\n+\n+                    }\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Foo\",\n+                source_range: [219; 221),\n+                delete: [219; 221),\n+                insert: \"Foo\",\n+                kind: Enum,\n+            },\n+            CompletionItem {\n+                label: \"Foo::Bar\",\n+                source_range: [219; 221),\n+                delete: [219; 221),\n+                insert: \"Foo::Bar\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Foo::Baz\",\n+                source_range: [219; 221),\n+                delete: [219; 221),\n+                insert: \"Foo::Baz\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Foo::Quux\",\n+                source_range: [219; 221),\n+                delete: [219; 221),\n+                insert: \"Foo::Quux\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+        ]\n+        \"###\n+        )\n+    }\n+\n+    #[test]\n+    fn completes_enum_variant_basic_expr() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                enum Foo {\n+                    Bar,\n+                    Baz,\n+                    Quux\n+                }\n+\n+                fn main() {\n+                    let foo: Foo = Q<|>\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Foo\",\n+                source_range: [185; 186),\n+                delete: [185; 186),\n+                insert: \"Foo\",\n+                kind: Enum,\n+            },\n+            CompletionItem {\n+                label: \"Foo::Bar\",\n+                source_range: [185; 186),\n+                delete: [185; 186),\n+                insert: \"Foo::Bar\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Foo::Baz\",\n+                source_range: [185; 186),\n+                delete: [185; 186),\n+                insert: \"Foo::Baz\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Foo::Quux\",\n+                source_range: [185; 186),\n+                delete: [185; 186),\n+                insert: \"Foo::Quux\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"main()\",\n+                source_range: [185; 186),\n+                delete: [185; 186),\n+                insert: \"main()$0\",\n+                kind: Function,\n+                lookup: \"main\",\n+                detail: \"fn main()\",\n+            },\n+        ]\n+        \"###\n+        )\n+    }\n }"}, {"sha": "cfc5c34df0851fd96974dc33881001ffb7e8d112", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/278bf351e3d9bf074b76f89afa04c4727d55fba6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278bf351e3d9bf074b76f89afa04c4727d55fba6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=278bf351e3d9bf074b76f89afa04c4727d55fba6", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Semantics, SemanticsScope};\n+use hir::{Semantics, SemanticsScope, Type};\n use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n@@ -168,6 +168,17 @@ impl<'a> CompletionContext<'a> {\n         self.sema.scope_at_offset(&self.token.parent(), self.offset)\n     }\n \n+    pub(crate) fn expected_type_of(&self, node: &SyntaxNode) -> Option<Type> {\n+        for ancestor in node.ancestors() {\n+            if let Some(pat) = ast::Pat::cast(ancestor.clone()) {\n+                return self.sema.type_of_pat(&pat);\n+            } else if let Some(expr) = ast::Expr::cast(ancestor) {\n+                return self.sema.type_of_expr(&expr);\n+            }\n+        }\n+        None\n+    }\n+\n     fn fill(\n         &mut self,\n         original_file: &SyntaxNode,"}]}