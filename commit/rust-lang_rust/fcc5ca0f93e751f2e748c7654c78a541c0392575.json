{"sha": "fcc5ca0f93e751f2e748c7654c78a541c0392575", "node_id": "C_kwDOAAsO6NoAKGZjYzVjYTBmOTNlNzUxZjJlNzQ4Yzc2NTRjNzhhNTQxYzAzOTI1NzU", "commit": {"author": {"name": "Sean Stangl", "email": "sean.stangl@gmail.com", "date": "2022-04-11T06:08:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-11T06:08:34Z"}, "message": "rust-lang/portable-simd#273: Documentation update for reduce functions, swizzle\n\nWorking through giving example documentation to every Simd function.\r\n\r\nThe major change in this patch is using doc macros to generate\r\ntype-specific examples for each function, using a visually-apparent type\r\nconstructor. This makes it feel nicer to have twelve separate\r\ndocumentation entries for reduce_product(), for example.", "tree": {"sha": "a49a50b5ff25adab901e6840edccc183bfcfb168", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a49a50b5ff25adab901e6840edccc183bfcfb168"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcc5ca0f93e751f2e748c7654c78a541c0392575", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiU8XiCRBK7hj4Ov3rIwAA2BQIAG4bFqakMlqxgnbQM6vl+x5m\numeN4YiInWxyXGJbFKlRHaSDUQUbkXLLsv7q3zzxrAbqTKHx1APN4SsEH5z52cRK\nDHaVyaP/7kK3rvqomp2FzFoPn2KDqxhWK5zyELjVrefZOiHIIYupa3vI+zT1h3B/\nteAHW2Ik2HAcqjfLnvfo31wjcuKEtxtsZmw3bgoxA6YUss7F/kRdOjdxoqJ7YkVL\n0pQH62CuXbU4qc7reB5aUXyUBPVG/9o0GnJ/zXTx2sQK1oORfCnc3Am4Q61SR/cs\nl70jAJhG2BKY+f2EJfkdL7vUZKGF2jh/20NftLasS7j5zEeEuMI4hK7e200zzIo=\n=dRCP\n-----END PGP SIGNATURE-----\n", "payload": "tree a49a50b5ff25adab901e6840edccc183bfcfb168\nparent 7136841cbd22ba66dbd49331f276bdb16401ec11\nauthor Sean Stangl <sean.stangl@gmail.com> 1649657314 -0600\ncommitter GitHub <noreply@github.com> 1649657314 -0700\n\nrust-lang/portable-simd#273: Documentation update for reduce functions, swizzle\n\nWorking through giving example documentation to every Simd function.\r\n\r\nThe major change in this patch is using doc macros to generate\r\ntype-specific examples for each function, using a visually-apparent type\r\nconstructor. This makes it feel nicer to have twelve separate\r\ndocumentation entries for reduce_product(), for example."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc5ca0f93e751f2e748c7654c78a541c0392575", "html_url": "https://github.com/rust-lang/rust/commit/fcc5ca0f93e751f2e748c7654c78a541c0392575", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcc5ca0f93e751f2e748c7654c78a541c0392575/comments", "author": {"login": "sstangl", "id": 171223, "node_id": "MDQ6VXNlcjE3MTIyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/171223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sstangl", "html_url": "https://github.com/sstangl", "followers_url": "https://api.github.com/users/sstangl/followers", "following_url": "https://api.github.com/users/sstangl/following{/other_user}", "gists_url": "https://api.github.com/users/sstangl/gists{/gist_id}", "starred_url": "https://api.github.com/users/sstangl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sstangl/subscriptions", "organizations_url": "https://api.github.com/users/sstangl/orgs", "repos_url": "https://api.github.com/users/sstangl/repos", "events_url": "https://api.github.com/users/sstangl/events{/privacy}", "received_events_url": "https://api.github.com/users/sstangl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7136841cbd22ba66dbd49331f276bdb16401ec11", "url": "https://api.github.com/repos/rust-lang/rust/commits/7136841cbd22ba66dbd49331f276bdb16401ec11", "html_url": "https://github.com/rust-lang/rust/commit/7136841cbd22ba66dbd49331f276bdb16401ec11"}], "stats": {"total": 228, "additions": 195, "deletions": 33}, "files": [{"sha": "63723e2ec13c4902cb8daa6c06674889747ab2f4", "filename": "crates/core_simd/src/lane_count.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=fcc5ca0f93e751f2e748c7654c78a541c0392575", "patch": "@@ -3,15 +3,19 @@ mod sealed {\n }\n use sealed::Sealed;\n \n-/// A type representing a vector lane count.\n+/// Specifies the number of lanes in a SIMD vector as a type.\n pub struct LaneCount<const LANES: usize>;\n \n impl<const LANES: usize> LaneCount<LANES> {\n     /// The number of bytes in a bitmask with this many lanes.\n     pub const BITMASK_LEN: usize = (LANES + 7) / 8;\n }\n \n-/// Helper trait for vector lane counts.\n+/// Statically guarantees that a lane count is marked as supported.\n+///\n+/// This trait is *sealed*: the list of implementors below is total.\n+/// Users do not have the ability to mark additional `LaneCount<N>` values as supported.\n+/// Only SIMD vectors with supported lane counts are constructable.\n pub trait SupportedLaneCount: Sealed {\n     #[doc(hidden)]\n     type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;"}, {"sha": "642ab319cdda05aa90211fb293147562151f91c4", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 117, "deletions": 3, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=fcc5ca0f93e751f2e748c7654c78a541c0392575", "patch": "@@ -12,27 +12,75 @@ macro_rules! impl_integer_reductions {\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Reducing wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n+            /// assert_eq!(v.reduce_sum(), 10);\n+            ///\n+            /// // SIMD integer addition is always wrapping\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([\", stringify!($scalar) ,\"::MAX, 1, 0, 0]);\")]\n+            #[doc = concat!(\"assert_eq!(v.reduce_sum(), \", stringify!($scalar), \"::MIN);\")]\n+            /// ```\n             #[inline]\n             pub fn reduce_sum(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_add_ordered(self, 0) }\n             }\n \n-            /// Reducing wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n+            /// Reducing wrapping multiply. Returns the product of the lanes of the vector, with wrapping multiplication.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n+            /// assert_eq!(v.reduce_product(), 24);\n+            ///\n+            /// // SIMD integer multiplication is always wrapping\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([\", stringify!($scalar) ,\"::MAX, 2, 1, 1]);\")]\n+            #[doc = concat!(\"assert!(v.reduce_product() < \", stringify!($scalar), \"::MAX);\")]\n+            /// ```\n             #[inline]\n             pub fn reduce_product(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n             /// Reducing maximum.  Returns the maximum lane in the vector.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n+            /// assert_eq!(v.reduce_max(), 4);\n+            /// ```\n             #[inline]\n             pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n             /// Reducing minimum.  Returns the minimum lane in the vector.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n+            /// assert_eq!(v.reduce_min(), 1);\n+            /// ```\n             #[inline]\n             pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n@@ -61,6 +109,16 @@ macro_rules! impl_float_reductions {\n         {\n \n             /// Reducing add.  Returns the sum of the lanes of the vector.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., 2.]);\")]\n+            /// assert_eq!(v.reduce_sum(), 3.);\n+            /// ```\n             #[inline]\n             pub fn reduce_sum(self) -> $scalar {\n                 // LLVM sum is inaccurate on i586\n@@ -73,6 +131,16 @@ macro_rules! impl_float_reductions {\n             }\n \n             /// Reducing multiply.  Returns the product of the lanes of the vector.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([3., 4.]);\")]\n+            /// assert_eq!(v.reduce_product(), 12.);\n+            /// ```\n             #[inline]\n             pub fn reduce_product(self) -> $scalar {\n                 // LLVM product is inaccurate on i586\n@@ -87,7 +155,30 @@ macro_rules! impl_float_reductions {\n             /// Reducing maximum.  Returns the maximum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n+            /// return either.\n+            ///\n+            /// This function will not return `NaN` unless all lanes are `NaN`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., 2.]);\")]\n+            /// assert_eq!(v.reduce_max(), 2.);\n+            ///\n+            /// // NaN values are skipped...\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., \", stringify!($scalar), \"::NAN]);\")]\n+            /// assert_eq!(v.reduce_max(), 1.);\n+            ///\n+            /// // ...unless all values are NaN\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([\",\n+                stringify!($scalar), \"::NAN, \",\n+                stringify!($scalar), \"::NAN]);\"\n+            )]\n+            /// assert!(v.reduce_max().is_nan());\n+            /// ```\n             #[inline]\n             pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is a float vector\n@@ -97,7 +188,30 @@ macro_rules! impl_float_reductions {\n             /// Reducing minimum.  Returns the minimum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n+            /// return either.\n+            ///\n+            /// This function will not return `NaN` unless all lanes are `NaN`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core::simd::Simd;\n+            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([3., 7.]);\")]\n+            /// assert_eq!(v.reduce_min(), 3.);\n+            ///\n+            /// // NaN values are skipped...\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., \", stringify!($scalar), \"::NAN]);\")]\n+            /// assert_eq!(v.reduce_min(), 1.);\n+            ///\n+            /// // ...unless all values are NaN\n+            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([\",\n+                stringify!($scalar), \"::NAN, \",\n+                stringify!($scalar), \"::NAN]);\"\n+            )]\n+            /// assert!(v.reduce_min().is_nan());\n+            /// ```\n             #[inline]\n             pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is a float vector"}, {"sha": "22999d24950f8d866e90c9a15a7ac3c4bc5f03ee", "filename": "crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=fcc5ca0f93e751f2e748c7654c78a541c0392575", "patch": "@@ -1,44 +1,46 @@\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n \n-/// Constructs a new vector by selecting values from the lanes of the source vector or vectors to use.\n+/// Constructs a new SIMD vector by copying elements from selected lanes in other vectors.\n ///\n-/// When swizzling one vector, the indices of the result vector are indicated by a `const` array\n-/// of `usize`, like [`Swizzle`].\n-/// When swizzling two vectors, the indices are indicated by a `const` array of [`Which`], like\n-/// [`Swizzle2`].\n+/// When swizzling one vector, lanes are selected by a `const` array of `usize`,\n+/// like [`Swizzle`].\n+///\n+/// When swizzling two vectors, lanes are selected by a `const` array of [`Which`],\n+/// like [`Swizzle2`].\n ///\n /// # Examples\n-/// ## One source vector\n+///\n+/// With a single SIMD vector, the const array specifies lane indices in that vector:\n /// ```\n /// # #![feature(portable_simd)]\n-/// # use core::simd::{Simd, simd_swizzle};\n-/// let v = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n+/// # use core::simd::{u32x2, u32x4, simd_swizzle};\n+/// let v = u32x4::from_array([10, 11, 12, 13]);\n ///\n /// // Keeping the same size\n-/// let r = simd_swizzle!(v, [3, 0, 1, 2]);\n-/// assert_eq!(r.to_array(), [3., 0., 1., 2.]);\n+/// let r: u32x4 = simd_swizzle!(v, [3, 0, 1, 2]);\n+/// assert_eq!(r.to_array(), [13, 10, 11, 12]);\n ///\n /// // Changing the number of lanes\n-/// let r = simd_swizzle!(v, [3, 1]);\n-/// assert_eq!(r.to_array(), [3., 1.]);\n+/// let r: u32x2 = simd_swizzle!(v, [3, 1]);\n+/// assert_eq!(r.to_array(), [13, 11]);\n /// ```\n ///\n-/// ## Two source vectors\n+/// With two input SIMD vectors, the const array uses `Which` to specify the source of each index:\n /// ```\n /// # #![feature(portable_simd)]\n-/// # use core::simd::{Simd, simd_swizzle, Which};\n-/// use Which::*;\n-/// let a = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n-/// let b = Simd::<f32, 4>::from_array([4., 5., 6., 7.]);\n+/// # use core::simd::{u32x2, u32x4, simd_swizzle, Which};\n+/// use Which::{First, Second};\n+/// let a = u32x4::from_array([0, 1, 2, 3]);\n+/// let b = u32x4::from_array([4, 5, 6, 7]);\n ///\n /// // Keeping the same size\n-/// let r = simd_swizzle!(a, b, [First(0), First(1), Second(2), Second(3)]);\n-/// assert_eq!(r.to_array(), [0., 1., 6., 7.]);\n+/// let r: u32x4 = simd_swizzle!(a, b, [First(0), First(1), Second(2), Second(3)]);\n+/// assert_eq!(r.to_array(), [0, 1, 6, 7]);\n ///\n /// // Changing the number of lanes\n-/// let r = simd_swizzle!(a, b, [First(0), Second(0)]);\n-/// assert_eq!(r.to_array(), [0., 4.]);\n+/// let r: u32x2 = simd_swizzle!(a, b, [First(0), Second(0)]);\n+/// assert_eq!(r.to_array(), [0, 4]);\n /// ```\n #[allow(unused_macros)]\n pub macro simd_swizzle {\n@@ -68,12 +70,14 @@ pub macro simd_swizzle {\n     }\n }\n \n-/// An index into one of two vectors.\n+/// Specifies a lane index into one of two SIMD vectors.\n+///\n+/// This is an input type for [Swizzle2] and helper macros like [simd_swizzle].\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum Which {\n-    /// Indexes the first vector.\n+    /// Index of a lane in the first input SIMD vector.\n     First(usize),\n-    /// Indexes the second vector.\n+    /// Index of a lane in the second input SIMD vector.\n     Second(usize),\n }\n "}, {"sha": "f7989ee762af0a5f7bc669b9f15921dbfafea0a8", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc5ca0f93e751f2e748c7654c78a541c0392575/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=fcc5ca0f93e751f2e748c7654c78a541c0392575", "patch": "@@ -99,17 +99,44 @@ where\n     /// Number of lanes in this vector.\n     pub const LANES: usize = LANES;\n \n-    /// Get the number of lanes in this vector.\n+    /// Returns the number of lanes in this SIMD vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::u32x4;\n+    /// let v = u32x4::splat(0);\n+    /// assert_eq!(v.lanes(), 4);\n+    /// ```\n     pub const fn lanes(&self) -> usize {\n         LANES\n     }\n \n-    /// Construct a SIMD vector by setting all lanes to the given value.\n+    /// Constructs a new SIMD vector with all lanes set to the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::u32x4;\n+    /// let v = u32x4::splat(8);\n+    /// assert_eq!(v.as_array(), &[8, 8, 8, 8]);\n+    /// ```\n     pub const fn splat(value: T) -> Self {\n         Self([value; LANES])\n     }\n \n     /// Returns an array reference containing the entire SIMD vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::{Simd, u64x4};\n+    /// let v: u64x4 = Simd::from_array([0, 1, 2, 3]);\n+    /// assert_eq!(v.as_array(), &[0, 1, 2, 3]);\n+    /// ```\n     pub const fn as_array(&self) -> &[T; LANES] {\n         &self.0\n     }\n@@ -129,9 +156,21 @@ where\n         self.0\n     }\n \n-    /// Converts a slice to a SIMD vector containing `slice[..LANES]`\n+    /// Converts a slice to a SIMD vector containing `slice[..LANES]`.\n+    ///\n     /// # Panics\n-    /// `from_slice` will panic if the slice's `len` is less than the vector's `Simd::LANES`.\n+    ///\n+    /// Panics if the slice's length is less than the vector's `Simd::LANES`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::{Simd, u32x4};\n+    /// let source = vec![1, 2, 3, 4, 5, 6];\n+    /// let v = u32x4::from_slice(&source);\n+    /// assert_eq!(v.as_array(), &[1, 2, 3, 4]);\n+    /// ```\n     #[must_use]\n     pub const fn from_slice(slice: &[T]) -> Self {\n         assert!(\n@@ -148,6 +187,7 @@ where\n     }\n \n     /// Performs lanewise conversion of a SIMD vector's elements to another SIMD-valid type.\n+    ///\n     /// This follows the semantics of Rust's `as` conversion for casting\n     /// integers to unsigned integers (interpreting as the other type, so `-1` to `MAX`),\n     /// and from floats to integers (truncating, or saturating at the limits) for each lane,"}]}