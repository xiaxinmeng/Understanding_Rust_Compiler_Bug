{"sha": "e5789765606baebd983bd9b1c870cb8b57a0627b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1Nzg5NzY1NjA2YmFlYmQ5ODNiZDliMWM4NzBjYjhiNTdhMDYyN2I=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2018-06-15T22:47:54Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2018-07-05T16:59:52Z"}, "message": "Store scalar pair bools as i8 in memory\n\nWe represent `bool` as `i1` in a `ScalarPair`, unlike other aggregates,\nto optimize IR for checked operators and the like.  With this patch, we\nstill do so when the pair is an immediate value, but we use the `i8`\nmemory type when the value is loaded or stored as an LLVM aggregate.\n\nSo `(bool, bool)` looks like an `{ i1, i1 }` immediate, but `{ i8, i8 }`\nin memory.  When a pair is a direct function argument, `PassMode::Pair`,\nit is still passed using the immediate `i1` type, but as a return value\nit will use the `i8` memory type.  Also, `bool`-like` enum tags will now\nuse scalar pairs when possible, where they were previously excluded due\nto optimization issues.", "tree": {"sha": "865811bcbcead24fb5448ee44e53ae0a07370aeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/865811bcbcead24fb5448ee44e53ae0a07370aeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5789765606baebd983bd9b1c870cb8b57a0627b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5789765606baebd983bd9b1c870cb8b57a0627b", "html_url": "https://github.com/rust-lang/rust/commit/e5789765606baebd983bd9b1c870cb8b57a0627b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5789765606baebd983bd9b1c870cb8b57a0627b/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94eb1760551096363ec04e42367b6b195592dbd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/94eb1760551096363ec04e42367b6b195592dbd8", "html_url": "https://github.com/rust-lang/rust/commit/94eb1760551096363ec04e42367b6b195592dbd8"}], "stats": {"total": 128, "additions": 84, "deletions": 44}, "files": [{"sha": "faad32a5d994ec3402fa659295787672457ce82b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -1020,13 +1020,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let mut abi = Abi::Aggregate { sized: true };\n                 if tag.value.size(dl) == size {\n                     abi = Abi::Scalar(tag.clone());\n-                } else if !tag.is_bool() {\n-                    // HACK(nox): Blindly using ScalarPair for all tagged enums\n-                    // where applicable leads to Option<u8> being handled as {i1, i8},\n-                    // which later confuses SROA and some loop optimisations,\n-                    // ultimately leading to the repeat-trusted-len test\n-                    // failing. We make the trade-off of using ScalarPair only\n-                    // for types where the tag isn't a boolean.\n+                } else {\n+                    // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n                     for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n                         let offsets = match layout_variant.fields {"}, {"sha": "4ff31ec7d1c18c364dd925ea02e15fb7ce6725df", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -582,8 +582,8 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n-                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0));\n-                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0, true));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),"}, {"sha": "4605b5f3f1d792b53c6d52a68e099c3c52b7bafc", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -265,8 +265,8 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            (bx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bx.cx, 0)),\n-             bx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bx.cx, 1)))\n+            (bx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bx.cx, 0, true)),\n+             bx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bx.cx, 1, true)))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n@@ -396,9 +396,14 @@ pub fn from_immediate(bx: &Builder, val: ValueRef) -> ValueRef {\n \n pub fn to_immediate(bx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-        if scalar.is_bool() {\n-            return bx.trunc(val, Type::i1(bx.cx));\n-        }\n+        return to_immediate_scalar(bx, val, scalar);\n+    }\n+    val\n+}\n+\n+pub fn to_immediate_scalar(bx: &Builder, val: ValueRef, scalar: &layout::Scalar) -> ValueRef {\n+    if scalar.is_bool() {\n+        return bx.trunc(val, Type::i1(bx.cx));\n     }\n     val\n }"}, {"sha": "3069a155d1f0a76d7e30d00b6b8323d54127344e", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -128,13 +128,13 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                     bx.cx,\n                     a,\n                     a_scalar,\n-                    layout.scalar_pair_element_llvm_type(bx.cx, 0),\n+                    layout.scalar_pair_element_llvm_type(bx.cx, 0, true),\n                 );\n                 let b_llval = scalar_to_llvm(\n                     bx.cx,\n                     b,\n                     b_scalar,\n-                    layout.scalar_pair_element_llvm_type(bx.cx, 1),\n+                    layout.scalar_pair_element_llvm_type(bx.cx, 1, true),\n                 );\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n@@ -193,8 +193,8 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n             let mut llpair = C_undef(llty);\n-            llpair = bx.insert_value(llpair, a, 0);\n-            llpair = bx.insert_value(llpair, b, 1);\n+            llpair = bx.insert_value(llpair, base::from_immediate(bx, a), 0);\n+            llpair = bx.insert_value(llpair, base::from_immediate(bx, b), 1);\n             llpair\n         } else {\n             self.immediate()\n@@ -206,13 +206,14 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                                          llval: ValueRef,\n                                          layout: TyLayout<'tcx>)\n                                          -> OperandRef<'tcx> {\n-        let val = if layout.is_llvm_scalar_pair() {\n+        let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n                     llval, layout);\n \n             // Deconstruct the immediate aggregate.\n-            OperandValue::Pair(bx.extract_value(llval, 0),\n-                               bx.extract_value(llval, 1))\n+            let a_llval = base::to_immediate_scalar(bx, bx.extract_value(llval, 0), a);\n+            let b_llval = base::to_immediate_scalar(bx, bx.extract_value(llval, 1), b);\n+            OperandValue::Pair(a_llval, b_llval)\n         } else {\n             OperandValue::Immediate(llval)\n         };\n@@ -264,8 +265,8 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 *llval = bx.bitcast(*llval, field.immediate_llvm_type(bx.cx));\n             }\n             OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx, 0));\n-                *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx, 1));\n+                *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx, 0, true));\n+                *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx, 1, true));\n             }\n             OperandValue::Ref(..) => bug!()\n         }\n@@ -308,10 +309,10 @@ impl<'a, 'tcx> OperandValue {\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n-                    let mut llptr = bx.struct_gep(dest.llval, i as u64);\n+                    let llptr = bx.struct_gep(dest.llval, i as u64);\n                     // Make sure to always store i1 as i8.\n                     if common::val_ty(x) == Type::i1(bx.cx) {\n-                        llptr = bx.pointercast(llptr, Type::i8p(bx.cx));\n+                        assert_eq!(common::val_ty(llptr), Type::i8p(bx.cx));\n                     }\n                     let val = base::from_immediate(bx, x);\n                     bx.store_with_flags(val, llptr, dest.align, flags);"}, {"sha": "36dcd04b02e44847630f804c92a546081bf446df", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::PlaceTy;\n use rustc_data_structures::indexed_vec::Idx;\n use base;\n use builder::Builder;\n-use common::{CodegenCx, C_undef, C_usize, C_u8, C_u32, C_uint, C_null, C_uint_big};\n+use common::{CodegenCx, C_undef, C_usize, C_u8, C_u32, C_uint, C_null, C_uint_big, val_ty};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -127,10 +127,10 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             OperandValue::Immediate(base::to_immediate(bx, llval, self.layout))\n         } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n             let load = |i, scalar: &layout::Scalar| {\n-                let mut llptr = bx.struct_gep(self.llval, i as u64);\n+                let llptr = bx.struct_gep(self.llval, i as u64);\n                 // Make sure to always load i1 as i8.\n                 if scalar.is_bool() {\n-                    llptr = bx.pointercast(llptr, Type::i8p(bx.cx));\n+                    assert_eq!(val_ty(llptr), Type::i8p(bx.cx));\n                 }\n                 let load = bx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);"}, {"sha": "2e81fc16a58388d935024ac40d25b4ff1cb59b32", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -232,7 +232,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                 // HACK(eddyb) have to bitcast pointers\n                                 // until LLVM removes pointee types.\n                                 let lldata = bx.pointercast(lldata,\n-                                    cast.scalar_pair_element_llvm_type(bx.cx, 0));\n+                                    cast.scalar_pair_element_llvm_type(bx.cx, 0, true));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n@@ -251,7 +251,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if cast.is_llvm_scalar_pair() {\n                                 let data_cast = bx.pointercast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(bx.cx, 0));\n+                                    cast.scalar_pair_element_llvm_type(bx.cx, 0, true));\n                                 OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and"}, {"sha": "195f1c3b85aea379590ad8f2362394d79898426e", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -47,8 +47,8 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n         layout::Abi::ScalarPair(..) => {\n             return Type::struct_(cx, &[\n-                layout.scalar_pair_element_llvm_type(cx, 0),\n-                layout.scalar_pair_element_llvm_type(cx, 1),\n+                layout.scalar_pair_element_llvm_type(cx, 0, false),\n+                layout.scalar_pair_element_llvm_type(cx, 1, false),\n             ], false);\n         }\n         layout::Abi::Uninhabited |\n@@ -206,7 +206,7 @@ pub trait LayoutLlvmExt<'tcx> {\n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> Type;\n     fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                                         index: usize) -> Type;\n+                                         index: usize, immediate: bool) -> Type;\n     fn llvm_field_index(&self, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo>;\n@@ -340,7 +340,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                                         index: usize) -> Type {\n+                                         index: usize, immediate: bool) -> Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.sty {\n@@ -350,7 +350,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n             ty::TyAdt(def, _) if def.is_box() => {\n                 let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n-                return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index);\n+                return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index, immediate);\n             }\n             _ => {}\n         }\n@@ -361,14 +361,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         };\n         let scalar = [a, b][index];\n \n-        // Make sure to return the same type `immediate_llvm_type` would,\n-        // to avoid dealing with two types and the associated conversions.\n-        // This means that `(bool, bool)` is represented as `{i1, i1}`,\n-        // both in memory and as an immediate, while `bool` is typically\n-        // `i8` in memory and only `i1` when immediate. While we need to\n-        // load/store `bool` as `i8` to avoid crippling LLVM optimizations,\n-        // `i1` in a LLVM aggregate is valid and mostly equivalent to `i8`.\n-        if scalar.is_bool() {\n+        // Make sure to return the same type `immediate_llvm_type` would when\n+        // dealing with an immediate pair.  This means that `(bool, bool)` is\n+        // effectively represented as `{i8, i8}` in memory and `{i1, i1}` as an\n+        // immediate, just like `bool` is typically `i8` in memory and only `i1`\n+        // when immediate.  We need to load/store `bool` as `i8` to avoid\n+        // crippling LLVM optimizations or triggering other LLVM bugs with `i1`.\n+        if immediate && scalar.is_bool() {\n             return Type::i1(cx);\n         }\n "}, {"sha": "c027dece01414255ea136847fe7d82c519f6268d", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -149,7 +149,7 @@ pub fn enum_id_1(x: Option<Result<u16, u16>>) -> Option<Result<u16, u16>> {\n   x\n }\n \n-// CHECK: i16 @enum_id_2(i16)\n+// CHECK: { i8, i8 } @enum_id_2(i1 zeroext %x.0, i8 %x.1)\n #[no_mangle]\n pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n   x"}, {"sha": "2078a2450853f0e66f7611c4ba9d04d0d9ef6cf5", "filename": "src/test/codegen/scalar-pair-bool.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5789765606baebd983bd9b1c870cb8b57a0627b/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs?ref=e5789765606baebd983bd9b1c870cb8b57a0627b", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK: define { i8, i8 } @pair_bool_bool(i1 zeroext %pair.0, i1 zeroext %pair.1)\n+#[no_mangle]\n+pub fn pair_bool_bool(pair: (bool, bool)) -> (bool, bool) {\n+    pair\n+}\n+\n+// CHECK: define { i8, i32 } @pair_bool_i32(i1 zeroext %pair.0, i32 %pair.1)\n+#[no_mangle]\n+pub fn pair_bool_i32(pair: (bool, i32)) -> (bool, i32) {\n+    pair\n+}\n+\n+// CHECK: define { i32, i8 } @pair_i32_bool(i32 %pair.0, i1 zeroext %pair.1)\n+#[no_mangle]\n+pub fn pair_i32_bool(pair: (i32, bool)) -> (i32, bool) {\n+    pair\n+}\n+\n+// CHECK: define { i8, i8 } @pair_and_or(i1 zeroext %arg0.0, i1 zeroext %arg0.1)\n+#[no_mangle]\n+pub fn pair_and_or((a, b): (bool, bool)) -> (bool, bool) {\n+    // Make sure it can operate directly on the unpacked args\n+    // CHECK: and i1 %arg0.0, %arg0.1\n+    // CHECK: or i1 %arg0.0, %arg0.1\n+    (a && b, a || b)\n+}"}]}