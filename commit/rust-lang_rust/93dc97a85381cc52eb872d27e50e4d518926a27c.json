{"sha": "93dc97a85381cc52eb872d27e50e4d518926a27c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZGM5N2E4NTM4MWNjNTJlYjg3MmQyN2U1MGU0ZDUxODkyNmEyN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-09T09:57:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-09T09:57:17Z"}, "message": "Auto merge of #70943 - Centril:rollup-eowm2h3, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #67705 (Use unrolled loop for searching NULL in [u16] on Windows)\n - #70367 (save/restore `pessimistic_yield` when entering bodies)\n - #70822 (Don't lint for self-recursion when the function can diverge)\n - #70868 (rustc_codegen_ssa: Refactor construction of linker arguments)\n - #70896 (Implement Chain with Option fuses)\n - #70916 (Support `#[track_caller]` on functions in `extern \"Rust\" { ... }`)\n - #70918 (rustc_session: forbid lints override regardless of position)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c2eb851ca9c9012962582fddbbd6f2948a1fa19e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2eb851ca9c9012962582fddbbd6f2948a1fa19e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93dc97a85381cc52eb872d27e50e4d518926a27c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93dc97a85381cc52eb872d27e50e4d518926a27c", "html_url": "https://github.com/rust-lang/rust/commit/93dc97a85381cc52eb872d27e50e4d518926a27c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93dc97a85381cc52eb872d27e50e4d518926a27c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11f6096a9ef6ad52de2956f4d2df200de7617077", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f6096a9ef6ad52de2956f4d2df200de7617077", "html_url": "https://github.com/rust-lang/rust/commit/11f6096a9ef6ad52de2956f4d2df200de7617077"}, {"sha": "09052a6d354036a3431733eef145671292548e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/09052a6d354036a3431733eef145671292548e48", "html_url": "https://github.com/rust-lang/rust/commit/09052a6d354036a3431733eef145671292548e48"}], "stats": {"total": 1453, "additions": 892, "deletions": 561}, "files": [{"sha": "64cbbbb003585fee465012f1115e831bb775d26c", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -170,7 +170,7 @@ The order of these command line arguments is taken into account. The following a\n $ rustc lib.rs --crate-type=lib -D unused-variables -A unused-variables\n ```\n \n-You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the `unused` group, but explicitly allows the `unused-variables` lint in that group:\n+You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the `unused` group, but explicitly allows the `unused-variables` lint in that group (forbid still trumps everything regardless of ordering):\n \n ```bash\n $ rustc lib.rs --crate-type=lib -D unused -A unused-variables"}, {"sha": "2dd405ced20e1577bdbe77ea7a86927a076b0862", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 113, "deletions": 154, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -1,8 +1,7 @@\n+use crate::iter::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n use crate::ops::Try;\n use crate::usize;\n \n-use super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n-\n /// An iterator that links two iterators together, in a chain.\n ///\n /// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n@@ -14,37 +13,34 @@ use super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n-    a: A,\n-    b: B,\n-    state: ChainState,\n+    // These are \"fused\" with `Option` so we don't need separate state to track which part is\n+    // already exhausted, and we may also get niche layout for `None`. We don't use the real `Fuse`\n+    // adapter because its specialization for `FusedIterator` unconditionally descends into the\n+    // iterator, and that could be expensive to keep revisiting stuff like nested chains. It also\n+    // hurts compiler performance to add more iterator layers to `Chain`.\n+    a: Option<A>,\n+    b: Option<B>,\n }\n impl<A, B> Chain<A, B> {\n     pub(in super::super) fn new(a: A, b: B) -> Chain<A, B> {\n-        Chain { a, b, state: ChainState::Both }\n+        Chain { a: Some(a), b: Some(b) }\n     }\n }\n \n-// The iterator protocol specifies that iteration ends with the return value\n-// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n-// further calls return. The chain adaptor must account for this since it uses\n-// two subiterators.\n-//\n-//  It uses three states:\n-//\n-//  - Both: `a` and `b` are remaining\n-//  - Front: `a` remaining\n-//  - Back: `b` remaining\n-//\n-//  The fourth state (neither iterator is remaining) only occurs after Chain has\n-//  returned None once, so we don't need to store this state.\n-#[derive(Clone, Debug)]\n-enum ChainState {\n-    // both front and back iterator are remaining\n-    Both,\n-    // only front is remaining\n-    Front,\n-    // only back is remaining\n-    Back,\n+/// Fuse the iterator if the expression is `None`.\n+macro_rules! fuse {\n+    ($self:ident . $iter:ident . $($call:tt)+) => {\n+        match $self.$iter {\n+            Some(ref mut iter) => match iter.$($call)+ {\n+                None => {\n+                    $self.$iter = None;\n+                    None\n+                }\n+                item => item,\n+            },\n+            None => None,\n+        }\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -57,128 +53,101 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.a.next() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.next()\n-                }\n-            },\n-            ChainState::Front => self.a.next(),\n-            ChainState::Back => self.b.next(),\n+        match fuse!(self.a.next()) {\n+            None => fuse!(self.b.next()),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n     fn count(self) -> usize {\n-        match self.state {\n-            ChainState::Both => self.a.count() + self.b.count(),\n-            ChainState::Front => self.a.count(),\n-            ChainState::Back => self.b.count(),\n-        }\n+        let a_count = match self.a {\n+            Some(a) => a.count(),\n+            None => 0,\n+        };\n+        let b_count = match self.b {\n+            Some(b) => b.count(),\n+            None => 0,\n+        };\n+        a_count + b_count\n     }\n \n-    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.try_fold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            _ => {}\n+        if let Some(ref mut a) = self.a {\n+            acc = a.try_fold(acc, &mut f)?;\n+            self.a = None;\n         }\n-        if let ChainState::Back = self.state {\n-            accum = self.b.try_fold(accum, &mut f)?;\n+        if let Some(ref mut b) = self.b {\n+            acc = b.try_fold(acc, f)?;\n+            self.b = None;\n         }\n-        Try::from_ok(accum)\n+        Try::from_ok(acc)\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.fold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(a) = self.a {\n+            acc = a.fold(acc, &mut f);\n         }\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.fold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(b) = self.b {\n+            acc = b.fold(acc, f);\n         }\n-        accum\n+        acc\n     }\n \n     #[inline]\n     fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                for x in self.a.by_ref() {\n-                    if n == 0 {\n-                        return Some(x);\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n+        if let Some(ref mut a) = self.a {\n+            while let Some(x) = a.next() {\n+                if n == 0 {\n+                    return Some(x);\n                 }\n+                n -= 1;\n             }\n-            ChainState::Back => {}\n+            self.a = None;\n         }\n-        if let ChainState::Back = self.state { self.b.nth(n) } else { None }\n+        fuse!(self.b.nth(n))\n     }\n \n     #[inline]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match self.state {\n-            ChainState::Both => match self.a.find(&mut predicate) {\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.find(predicate)\n-                }\n-                v => v,\n-            },\n-            ChainState::Front => self.a.find(predicate),\n-            ChainState::Back => self.b.find(predicate),\n+        match fuse!(self.a.find(&mut predicate)) {\n+            None => fuse!(self.b.find(predicate)),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     fn last(self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => {\n-                // Must exhaust a before b.\n-                let a_last = self.a.last();\n-                let b_last = self.b.last();\n-                b_last.or(a_last)\n-            }\n-            ChainState::Front => self.a.last(),\n-            ChainState::Back => self.b.last(),\n-        }\n+        // Must exhaust a before b.\n+        let a_last = match self.a {\n+            Some(a) => a.last(),\n+            None => None,\n+        };\n+        let b_last = match self.b {\n+            Some(b) => b.last(),\n+            None => None,\n+        };\n+        b_last.or(a_last)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.state {\n-            ChainState::Both => {\n-                let (a_lower, a_upper) = self.a.size_hint();\n-                let (b_lower, b_upper) = self.b.size_hint();\n+        match self {\n+            Chain { a: Some(a), b: Some(b) } => {\n+                let (a_lower, a_upper) = a.size_hint();\n+                let (b_lower, b_upper) = b.size_hint();\n \n                 let lower = a_lower.saturating_add(b_lower);\n \n@@ -189,8 +158,9 @@ where\n \n                 (lower, upper)\n             }\n-            ChainState::Front => self.a.size_hint(),\n-            ChainState::Back => self.b.size_hint(),\n+            Chain { a: Some(a), b: None } => a.size_hint(),\n+            Chain { a: None, b: Some(b) } => b.size_hint(),\n+            Chain { a: None, b: None } => (0, Some(0)),\n         }\n     }\n }\n@@ -203,82 +173,71 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.b.next_back() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Front;\n-                    self.a.next_back()\n-                }\n-            },\n-            ChainState::Front => self.a.next_back(),\n-            ChainState::Back => self.b.next_back(),\n+        match fuse!(self.b.next_back()) {\n+            None => fuse!(self.a.next_back()),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     fn nth_back(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                for x in self.b.by_ref().rev() {\n-                    if n == 0 {\n-                        return Some(x);\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n+        if let Some(ref mut b) = self.b {\n+            while let Some(x) = b.next_back() {\n+                if n == 0 {\n+                    return Some(x);\n                 }\n+                n -= 1;\n             }\n-            ChainState::Front => {}\n+            self.b = None;\n         }\n-        if let ChainState::Front = self.state { self.a.nth_back(n) } else { None }\n+        fuse!(self.a.nth_back(n))\n     }\n \n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    #[inline]\n+    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        match fuse!(self.b.rfind(&mut predicate)) {\n+            None => fuse!(self.a.rfind(predicate)),\n+            item => item,\n+        }\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.try_rfold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n-                }\n-            }\n-            _ => {}\n+        if let Some(ref mut b) = self.b {\n+            acc = b.try_rfold(acc, &mut f)?;\n+            self.b = None;\n         }\n-        if let ChainState::Front = self.state {\n-            accum = self.a.try_rfold(accum, &mut f)?;\n+        if let Some(ref mut a) = self.a {\n+            acc = a.try_rfold(acc, f)?;\n+            self.a = None;\n         }\n-        Try::from_ok(accum)\n+        Try::from_ok(acc)\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.rfold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(b) = self.b {\n+            acc = b.rfold(acc, &mut f);\n         }\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.rfold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(a) = self.a {\n+            acc = a.rfold(acc, f);\n         }\n-        accum\n+        acc\n     }\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n+// Now that we \"fuse\" both sides, we *could* implement this unconditionally,\n+// but we should be cautious about committing to that in the public API.\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Chain<A, B>\n where"}, {"sha": "20e64f0c488515c5baec199c38afd8d0e0117a84", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 374, "deletions": 225, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -154,7 +154,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n-pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n+fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n     let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n \n     // If our linker looks like a batch script on Windows then to execute this\n@@ -193,6 +193,7 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n                     _ => None,\n                 };\n                 if let Some(ref a) = arch {\n+                    // FIXME: Move this to `fn linker_with_args`.\n                     let mut arg = OsString::from(\"/LIBPATH:\");\n                     arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a.to_string()));\n                     cmd.arg(&arg);\n@@ -232,7 +233,7 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n     }\n     cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n \n-    (linker.to_path_buf(), cmd)\n+    cmd\n }\n \n pub fn each_linked_rlib(\n@@ -284,11 +285,7 @@ pub fn each_linked_rlib(\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata<'a>(\n-    sess: &'a Session,\n-    metadata: &EncodedMetadata,\n-    tmpdir: &TempDir,\n-) -> PathBuf {\n+pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &TempDir) -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, &metadata.raw_data);\n \n@@ -487,95 +484,18 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     target_cpu: &str,\n ) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n-    let (linker, flavor) = linker_and_flavor(sess);\n-\n-    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n-        || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n-            *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-        });\n-\n-    // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n-\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static(Some(crate_type)) {\n-            cmd.args(args);\n-        }\n-    }\n-    cmd.args(&sess.opts.debugging_opts.pre_link_args);\n-\n-    if sess.target.target.options.is_like_fuchsia {\n-        let prefix = match sess.opts.debugging_opts.sanitizer {\n-            Some(Sanitizer::Address) => \"asan/\",\n-            _ => \"\",\n-        };\n-        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n-    }\n-\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n-        &sess.target.target.options.pre_link_objects_exe\n-    } else {\n-        &sess.target.target.options.pre_link_objects_dll\n-    };\n-    for obj in pre_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-\n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-\n-    if sess.target.target.options.is_like_emscripten {\n-        cmd.arg(\"-s\");\n-        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n-            \"DISABLE_EXCEPTION_CATCHING=1\"\n-        } else {\n-            \"DISABLE_EXCEPTION_CATCHING=0\"\n-        });\n-    }\n+    let (linker_path, flavor) = linker_and_flavor(sess);\n+    let mut cmd = linker_with_args::<B>(\n+        &linker_path,\n+        flavor,\n+        sess,\n+        crate_type,\n+        tmpdir,\n+        out_filename,\n+        codegen_results,\n+        target_cpu,\n+    );\n \n-    {\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n-        link_sanitizer_runtime(sess, crate_type, &mut *linker);\n-        link_args::<B>(\n-            &mut *linker,\n-            flavor,\n-            sess,\n-            crate_type,\n-            tmpdir,\n-            out_filename,\n-            codegen_results,\n-        );\n-        cmd = linker.finalize();\n-    }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if any_dynamic_crate {\n-        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n-            cmd.args(args);\n-        }\n-    } else {\n-        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n-            cmd.args(args);\n-        }\n-    }\n-    for obj in &sess.target.target.options.post_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-    if sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n     for &(ref k, ref v) in &sess.target.target.options.link_env {\n         cmd.env(k, v);\n     }\n@@ -597,7 +517,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = sess.time(\"run_linker\", || exec_linker(sess, &mut cmd, out_filename, tmpdir));\n+        prog = sess.time(\"run_linker\", || exec_linker(sess, &cmd, out_filename, tmpdir));\n         let output = match prog {\n             Ok(ref output) => output,\n             Err(_) => break,\n@@ -698,7 +618,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                 output.extend_from_slice(&prog.stdout);\n                 sess.struct_err(&format!(\n                     \"linking with `{}` failed: {}\",\n-                    pname.display(),\n+                    linker_path.display(),\n                     prog.status\n                 ))\n                 .note(&format!(\"{:?}\", &cmd))\n@@ -714,9 +634,12 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n             let mut linker_error = {\n                 if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n+                    sess.struct_err(&format!(\"linker `{}` not found\", linker_path.display()))\n                 } else {\n-                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n+                    sess.struct_err(&format!(\n+                        \"could not exec the linker `{}`\",\n+                        linker_path.display()\n+                    ))\n                 }\n             };\n \n@@ -787,7 +710,7 @@ fn link_sanitizer_runtime(sess: &Session, crate_type: config::CrateType, linker:\n             // PR #41352 for details).\n             let libname = format!(\"rustc{}_rt.{}\", channel, name);\n             let rpath = default_tlib.to_str().expect(\"non-utf8 component in path\");\n-            linker.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n+            linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n             linker.link_dylib(Symbol::intern(&libname));\n         }\n         \"x86_64-unknown-linux-gnu\" | \"x86_64-fuchsia\" | \"aarch64-fuchsia\" => {\n@@ -817,7 +740,7 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n-pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n+fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     fn infer_from(\n         sess: &Session,\n         linker: Option<PathBuf>,\n@@ -905,7 +828,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n /// Returns a boolean indicating whether we should preserve the object files on\n /// the filesystem for their debug information. This is often useful with\n /// split-dwarf like schemes.\n-pub fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     // If the objects don't have debuginfo there's nothing to preserve.\n     if sess.opts.debuginfo == config::DebugInfo::None {\n         return false;\n@@ -959,7 +882,7 @@ enum RlibFlavor {\n     StaticlibBase,\n }\n \n-pub fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n+fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     let lib_args: Vec<_> = all_native_libs\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n@@ -1061,7 +984,7 @@ fn get_crt_libs_path(sess: &Session) -> Option<PathBuf> {\n     }\n }\n \n-pub fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n+fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n     // prefer system {,dll}crt2.o libs, see get_crt_libs_path comment for more details\n     if sess.target.target.llvm_target.contains(\"windows-gnu\") {\n         if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n@@ -1085,9 +1008,9 @@ pub fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n     PathBuf::from(name)\n }\n \n-pub fn exec_linker(\n+fn exec_linker(\n     sess: &Session,\n-    cmd: &mut Command,\n+    cmd: &Command,\n     out_filename: &Path,\n     tmpdir: &Path,\n ) -> io::Result<Output> {\n@@ -1233,134 +1156,142 @@ pub fn exec_linker(\n     }\n }\n \n-fn link_args<'a, B: ArchiveBuilder<'a>>(\n+/// Add begin object files defined by the target spec.\n+fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n+    let pre_link_objects = if crate_type == config::CrateType::Executable {\n+        &sess.target.target.options.pre_link_objects_exe\n+    } else {\n+        &sess.target.target.options.pre_link_objects_dll\n+    };\n+    for obj in pre_link_objects {\n+        cmd.add_object(&get_object_file_path(sess, obj));\n+    }\n+\n+    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n+            cmd.add_object(&get_object_file_path(sess, obj));\n+        }\n+    }\n+}\n+\n+/// Add end object files defined by the target spec.\n+fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n+    for obj in &sess.target.target.options.post_link_objects {\n+        cmd.add_object(&get_object_file_path(sess, obj));\n+    }\n+    if sess.crt_static(Some(crate_type)) {\n+        for obj in &sess.target.target.options.post_link_objects_crt {\n+            cmd.add_object(&get_object_file_path(sess, obj));\n+        }\n+    }\n+}\n+\n+/// Add arbitrary \"pre-link\" args defined by the target spec or from command line.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_pre_link_args(\n     cmd: &mut dyn Linker,\n+    sess: &Session,\n     flavor: LinkerFlavor,\n-    sess: &'a Session,\n     crate_type: config::CrateType,\n-    tmpdir: &Path,\n-    out_filename: &Path,\n-    codegen_results: &CodegenResults,\n ) {\n-    // Linker plugins should be specified early in the list of arguments\n-    cmd.linker_plugin_lto();\n-\n-    // The default library location, we need this to find the runtime.\n-    // The location of crates will be determined as needed.\n-    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n+        if sess.crt_static(Some(crate_type)) {\n+            cmd.args(args);\n+        }\n+    }\n+    cmd.args(&sess.opts.debugging_opts.pre_link_args);\n+}\n \n-    // target descriptor\n-    let t = &sess.target.target;\n+/// Add arbitrary \"user defined\" args defined from command line and by `#[link_args]` attributes.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_user_defined_link_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    codegen_results: &CodegenResults,\n+) {\n+    cmd.args(&sess.opts.cg.link_args);\n+    cmd.args(&*codegen_results.crate_info.link_args);\n+}\n \n-    // prefer system mingw-w64 libs, see get_crt_libs_path comment for more details\n-    if cfg!(windows) && sess.target.target.llvm_target.contains(\"windows-gnu\") {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            cmd.include_path(&compiler_libs_path);\n+/// Add arbitrary \"late link\" args defined by the target spec.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_late_link_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    flavor: LinkerFlavor,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n+    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n+        || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n+            *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+        });\n+    if any_dynamic_crate {\n+        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n+            cmd.args(args);\n+        }\n+    } else {\n+        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n+            cmd.args(args);\n         }\n     }\n+}\n \n-    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+/// Add arbitrary \"post-link\" args defined by the target spec.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_post_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n+    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+}\n \n+/// Add object files containing code from the current crate.\n+fn add_local_crate_regular_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) {\n     for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         cmd.add_object(obj);\n     }\n-    cmd.output_filename(out_filename);\n+}\n \n-    if crate_type == config::CrateType::Executable && sess.target.target.options.is_like_windows {\n-        if let Some(ref s) = codegen_results.windows_subsystem {\n-            cmd.subsystem(s);\n-        }\n+/// Add object files for allocator code linked once for the whole crate tree.\n+fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) {\n+    if let Some(obj) = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n     }\n+}\n \n-    // If we're building something like a dynamic library then some platforms\n-    // need to make sure that all symbols are exported correctly from the\n-    // dynamic library.\n-    cmd.export_symbols(tmpdir, crate_type);\n-\n+/// Add object files containing metadata for the current crate.\n+fn add_local_crate_metadata_objects(\n+    cmd: &mut dyn Linker,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if crate_type == config::CrateType::Dylib || crate_type == config::CrateType::ProcMacro {\n-        let obj = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref());\n-        if let Some(obj) = obj {\n+        if let Some(obj) = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref())\n+        {\n             cmd.add_object(obj);\n         }\n     }\n+}\n \n-    let obj = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref());\n-    if let Some(obj) = obj {\n-        cmd.add_object(obj);\n-    }\n-\n-    // Try to strip as much out of the generated object by removing unused\n-    // sections if possible. See more comments in linker.rs\n-    if !sess.opts.cg.link_dead_code {\n-        let keep_metadata = crate_type == config::CrateType::Dylib;\n-        cmd.gc_sections(keep_metadata);\n-    }\n-\n-    let attr_link_args = codegen_results.crate_info.link_args.iter();\n-    let user_link_args: Vec<_> =\n-        sess.opts.cg.link_args.iter().chain(attr_link_args).cloned().collect();\n-\n-    if crate_type == config::CrateType::Executable {\n-        let mut position_independent_executable = false;\n-\n-        if t.options.position_independent_executables {\n-            if is_pic(sess)\n-                && !sess.crt_static(Some(crate_type))\n-                && !user_link_args.iter().any(|x| x == \"-static\")\n-            {\n-                position_independent_executable = true;\n-            }\n-        }\n-\n-        if position_independent_executable {\n-            cmd.position_independent_executable();\n-        } else {\n-            // recent versions of gcc can be configured to generate position\n-            // independent executables by default. We have to pass -no-pie to\n-            // explicitly turn that off. Not applicable to ld.\n-            if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n-                cmd.no_position_independent_executable();\n-            }\n-        }\n-    }\n-\n-    let relro_level = match sess.opts.debugging_opts.relro_level {\n-        Some(level) => level,\n-        None => t.options.relro_level,\n-    };\n-    match relro_level {\n-        RelroLevel::Full => {\n-            cmd.full_relro();\n-        }\n-        RelroLevel::Partial => {\n-            cmd.partial_relro();\n-        }\n-        RelroLevel::Off => {\n-            cmd.no_relro();\n-        }\n-        RelroLevel::None => {}\n-    }\n-\n-    // Pass optimization flags down to the linker.\n-    cmd.optimize();\n-\n-    // Pass debuginfo flags down to the linker.\n-    cmd.debuginfo();\n-\n-    // We want to, by default, prevent the compiler from accidentally leaking in\n-    // any system libraries, so we may explicitly ask linkers to not link to any\n-    // libraries by default. Note that this does not happen for windows because\n-    // windows pulls in some large number of libraries and I couldn't quite\n-    // figure out which subset we wanted.\n-    //\n-    // This is all naturally configurable via the standard methods as well.\n-    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) && t.options.no_default_libraries {\n-        cmd.no_default_libraries();\n-    }\n-\n+/// Link native libraries corresponding to the current crate and all libraries corresponding to\n+/// all its dependency crates.\n+/// FIXME: Consider combining this with the functions above adding object files for the local crate.\n+fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'a>>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n     // Take careful note of the ordering of the arguments we pass to the linker\n     // here. Linkers will assume that things on the left depend on things to the\n     // right. Things on the right cannot depend on things on the left. This is\n@@ -1398,22 +1329,73 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(\n     if sess.opts.debugging_opts.link_native_libraries.unwrap_or(true) {\n         add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n     }\n-    // Tell the linker what we're doing.\n+}\n+\n+/// Add sysroot and other globally set directories to the directory search list.\n+fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n+    // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n+    if cfg!(windows) && sess.target.target.llvm_target.contains(\"windows-gnu\") {\n+        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n+            cmd.include_path(&compiler_libs_path);\n+        }\n+    }\n+\n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+}\n+\n+/// Add options requesting executables to be position-independent or not position-independent.\n+fn add_position_independent_executable_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    flavor: LinkerFlavor,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n     if crate_type != config::CrateType::Executable {\n-        cmd.build_dylib(out_filename);\n+        return;\n     }\n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n-        cmd.build_static_executable();\n+\n+    if sess.target.target.options.position_independent_executables {\n+        let attr_link_args = &*codegen_results.crate_info.link_args;\n+        let mut user_defined_link_args = sess.opts.cg.link_args.iter().chain(attr_link_args);\n+        if is_pic(sess)\n+            && !sess.crt_static(Some(crate_type))\n+            && !user_defined_link_args.any(|x| x == \"-static\")\n+        {\n+            cmd.position_independent_executable();\n+            return;\n+        }\n     }\n \n-    if sess.opts.cg.profile_generate.enabled() {\n-        cmd.pgo_gen();\n+    // Recent versions of gcc can be configured to generate position\n+    // independent executables by default. We have to pass -no-pie to\n+    // explicitly turn that off. Not applicable to ld.\n+    if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n+        cmd.no_position_independent_executable();\n     }\n+}\n \n-    if sess.opts.debugging_opts.control_flow_guard != CFGuard::Disabled {\n-        cmd.control_flow_guard();\n+/// Add options making relocation sections in the produced ELF files read-only\n+/// and suppressing lazy binding.\n+fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) {\n+    match sess.opts.debugging_opts.relro_level.unwrap_or(sess.target.target.options.relro_level) {\n+        RelroLevel::Full => cmd.full_relro(),\n+        RelroLevel::Partial => cmd.partial_relro(),\n+        RelroLevel::Off => cmd.no_relro(),\n+        RelroLevel::None => {}\n     }\n+}\n \n+/// Add library search paths used at runtime by dynamic linkers.\n+fn add_rpath_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    codegen_results: &CodegenResults,\n+    out_filename: &Path,\n+) {\n     // FIXME (#2397): At some point we want to rpath our guesses as to\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n@@ -1437,10 +1419,177 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n+}\n+\n+/// Produce the linker command line containing linker path and arguments.\n+/// `NO-OPT-OUT` marks the arguments that cannot be removed from the command line\n+/// by the user without creating a custom target specification.\n+/// `OBJECT-FILES` specify whether the arguments can add object files.\n+/// `CUSTOMIZATION-POINT` means that arbitrary arguments defined by the user\n+/// or by the target spec can be inserted here.\n+/// `AUDIT-ORDER` - need to figure out whether the option is order-dependent or not.\n+fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n+    path: &Path,\n+    flavor: LinkerFlavor,\n+    sess: &'a Session,\n+    crate_type: config::CrateType,\n+    tmpdir: &Path,\n+    out_filename: &Path,\n+    codegen_results: &CodegenResults,\n+    target_cpu: &str,\n+) -> Command {\n+    let base_cmd = get_linker(sess, path, flavor);\n+    // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n+    // to the linker args construction.\n+    assert!(base_cmd.get_args().is_empty() || sess.target.target.target_vendor == \"uwp\");\n+    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_pre_link_args(cmd, sess, flavor, crate_type);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.target.target.options.is_like_fuchsia {\n+        let prefix = match sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => \"asan/\",\n+            _ => \"\",\n+        };\n+        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n+    }\n+\n+    // NO-OPT-OUT, OBJECT-FILES-YES\n+    add_pre_link_objects(cmd, sess, crate_type);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.target.target.options.is_like_emscripten {\n+        cmd.arg(\"-s\");\n+        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n+            \"DISABLE_EXCEPTION_CATCHING=1\"\n+        } else {\n+            \"DISABLE_EXCEPTION_CATCHING=0\"\n+        });\n+    }\n+\n+    // OBJECT-FILES-YES, AUDIT-ORDER\n+    link_sanitizer_runtime(sess, crate_type, cmd);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // Linker plugins should be specified early in the list of arguments\n+    // FIXME: How \"early\" exactly?\n+    cmd.linker_plugin_lto();\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // FIXME: Order-dependent, at least relatively to other args adding searh directories.\n+    add_library_search_dirs(cmd, sess);\n+\n+    // OBJECT-FILES-YES\n+    add_local_crate_regular_objects(cmd, codegen_results);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    cmd.output_filename(out_filename);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    if crate_type == config::CrateType::Executable && sess.target.target.options.is_like_windows {\n+        if let Some(ref s) = codegen_results.windows_subsystem {\n+            cmd.subsystem(s);\n+        }\n+    }\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // If we're building something like a dynamic library then some platforms\n+    // need to make sure that all symbols are exported correctly from the\n+    // dynamic library.\n+    cmd.export_symbols(tmpdir, crate_type);\n+\n+    // OBJECT-FILES-YES\n+    add_local_crate_metadata_objects(cmd, crate_type, codegen_results);\n+\n+    // OBJECT-FILES-YES\n+    add_local_crate_allocator_objects(cmd, codegen_results);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // FIXME: Order dependent, applies to the following objects. Where should it be placed?\n+    // Try to strip as much out of the generated object by removing unused\n+    // sections if possible. See more comments in linker.rs\n+    if !sess.opts.cg.link_dead_code {\n+        let keep_metadata = crate_type == config::CrateType::Dylib;\n+        cmd.gc_sections(keep_metadata);\n+    }\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    add_position_independent_executable_args(cmd, sess, flavor, crate_type, codegen_results);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    add_relro_args(cmd, sess);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // Pass optimization flags down to the linker.\n+    cmd.optimize();\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // Pass debuginfo flags down to the linker.\n+    cmd.debuginfo();\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // We want to, by default, prevent the compiler from accidentally leaking in\n+    // any system libraries, so we may explicitly ask linkers to not link to any\n+    // libraries by default. Note that this does not happen for windows because\n+    // windows pulls in some large number of libraries and I couldn't quite\n+    // figure out which subset we wanted.\n+    //\n+    // This is all naturally configurable via the standard methods as well.\n+    if !sess.opts.cg.default_linker_libraries.unwrap_or(false)\n+        && sess.target.target.options.no_default_libraries\n+    {\n+        cmd.no_default_libraries();\n+    }\n+\n+    // OBJECT-FILES-YES\n+    link_local_crate_native_libs_and_dependent_crate_libs::<B>(\n+        cmd,\n+        sess,\n+        crate_type,\n+        codegen_results,\n+        tmpdir,\n+    );\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // Tell the linker what we're doing.\n+    if crate_type != config::CrateType::Executable {\n+        cmd.build_dylib(out_filename);\n+    }\n+    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+        cmd.build_static_executable();\n+    }\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.opts.cg.profile_generate.enabled() {\n+        cmd.pgo_gen();\n+    }\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.opts.debugging_opts.control_flow_guard != CFGuard::Disabled {\n+        cmd.control_flow_guard();\n+    }\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    add_rpath_args(cmd, sess, codegen_results, out_filename);\n+\n+    // OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_user_defined_link_args(cmd, sess, codegen_results);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    cmd.finalize();\n+\n+    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_late_link_args(cmd, sess, flavor, crate_type, codegen_results);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-YES\n+    add_post_link_objects(cmd, sess, crate_type);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_post_link_args(cmd, sess, flavor);\n \n-    // Finally add all the linker arguments provided on the command line along\n-    // with any #[link_args] attributes found inside the crate\n-    cmd.args(&user_link_args);\n+    cmd.take_cmd()\n }\n \n // # Native library linking\n@@ -1454,7 +1603,7 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-pub fn add_local_native_libraries(\n+fn add_local_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n@@ -1784,7 +1933,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-pub fn add_upstream_native_libraries(\n+fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n@@ -1841,14 +1990,14 @@ pub fn add_upstream_native_libraries(\n     }\n }\n \n-pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => rustc_attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,\n     }\n }\n \n-pub fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n+fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n     match sess.lto() {\n         config::Lto::Fat => true,\n         config::Lto::Thin => {"}, {"sha": "0baa37ae9f1ab76eafb6e8fa1fdb185b8bf75c28", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -6,6 +6,7 @@ use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n+use std::mem;\n use std::path::{Path, PathBuf};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -87,6 +88,7 @@ impl LinkerInfo {\n /// used to dispatch on whether a GNU-like linker (generally `ld.exe`) or an\n /// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n+    fn cmd(&mut self) -> &mut Command;\n     fn link_dylib(&mut self, lib: Symbol);\n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n     fn link_framework(&mut self, framework: Symbol);\n@@ -111,14 +113,26 @@ pub trait Linker {\n     fn no_default_libraries(&mut self);\n     fn build_dylib(&mut self, out_filename: &Path);\n     fn build_static_executable(&mut self);\n-    fn args(&mut self, args: &[String]);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n     fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n-    // Should have been finalize(self), but we don't support self-by-value on trait objects (yet?).\n-    fn finalize(&mut self) -> Command;\n+    fn finalize(&mut self);\n+}\n+\n+impl dyn Linker + '_ {\n+    pub fn arg(&mut self, arg: impl AsRef<OsStr>) {\n+        self.cmd().arg(arg);\n+    }\n+\n+    pub fn args(&mut self, args: impl IntoIterator<Item: AsRef<OsStr>>) {\n+        self.cmd().args(args);\n+    }\n+\n+    pub fn take_cmd(&mut self) -> Command {\n+        mem::replace(self.cmd(), Command::new(\"\"))\n+    }\n }\n \n pub struct GccLinker<'a> {\n@@ -208,6 +222,9 @@ impl<'a> GccLinker<'a> {\n }\n \n impl<'a> Linker for GccLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.hint_dynamic();\n         self.cmd.arg(format!(\"-l{}\", lib));\n@@ -251,9 +268,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn build_static_executable(&mut self) {\n         self.cmd.arg(\"-static\");\n     }\n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.hint_dynamic();\n@@ -505,10 +519,8 @@ impl<'a> Linker for GccLinker<'a> {\n         self.linker_arg(&subsystem);\n     }\n \n-    fn finalize(&mut self) -> Command {\n+    fn finalize(&mut self) {\n         self.hint_dynamic(); // Reset to default before returning the composed command line.\n-\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn group_start(&mut self) {\n@@ -545,15 +557,15 @@ pub struct MsvcLinker<'a> {\n }\n \n impl<'a> Linker for MsvcLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n     fn link_rlib(&mut self, lib: &Path) {\n         self.cmd.arg(lib);\n     }\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n         self.cmd.arg(\"/DLL\");\n@@ -758,9 +770,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // MSVC doesn't need group indicators\n     fn group_start(&mut self) {}\n@@ -778,6 +788,9 @@ pub struct EmLinker<'a> {\n }\n \n impl<'a> Linker for EmLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n     fn include_path(&mut self, path: &Path) {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n@@ -837,10 +850,6 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n-\n     fn framework_path(&mut self, _path: &Path) {\n         bug!(\"frameworks are not supported on Emscripten\")\n     }\n@@ -928,9 +937,7 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // Appears not necessary on Emscripten\n     fn group_start(&mut self) {}\n@@ -992,6 +999,10 @@ impl<'a> WasmLd<'a> {\n }\n \n impl<'a> Linker for WasmLd<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1030,10 +1041,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn build_static_executable(&mut self) {}\n \n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n-\n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1098,9 +1105,7 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_position_independent_executable(&mut self) {}\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // Not needed for now with LLD\n     fn group_start(&mut self) {}\n@@ -1162,6 +1167,10 @@ pub struct PtxLinker<'a> {\n }\n \n impl<'a> Linker for PtxLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n     fn link_rlib(&mut self, path: &Path) {\n         self.cmd.arg(\"--rlib\").arg(path);\n     }\n@@ -1182,10 +1191,6 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.cmd.arg(\"--bitcode\").arg(path);\n     }\n \n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n-\n     fn optimize(&mut self) {\n         match self.sess.lto() {\n             Lto::Thin | Lto::Fat | Lto::ThinLocal => {\n@@ -1200,14 +1205,12 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.cmd.arg(\"-o\").arg(path);\n     }\n \n-    fn finalize(&mut self) -> Command {\n+    fn finalize(&mut self) {\n         // Provide the linker with fallback to internal `target-cpu`.\n         self.cmd.arg(\"--fallback-arch\").arg(match self.sess.opts.cg.target_cpu {\n             Some(ref s) => s,\n             None => &self.sess.target.target.options.cpu,\n         });\n-\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn link_dylib(&mut self, _lib: Symbol) {"}, {"sha": "8d9982131c33e0ec5ade815553c0289b1e686dcb", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -416,7 +416,6 @@ E0734: include_str!(\"./error_codes/E0734.md\"),\n E0735: include_str!(\"./error_codes/E0735.md\"),\n E0736: include_str!(\"./error_codes/E0736.md\"),\n E0737: include_str!(\"./error_codes/E0737.md\"),\n-E0738: include_str!(\"./error_codes/E0738.md\"),\n E0739: include_str!(\"./error_codes/E0739.md\"),\n E0740: include_str!(\"./error_codes/E0740.md\"),\n E0741: include_str!(\"./error_codes/E0741.md\"),\n@@ -614,4 +613,5 @@ E0751: include_str!(\"./error_codes/E0751.md\"),\n     E0722, // Malformed `#[optimize]` attribute\n     E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n+//  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n }"}, {"sha": "8f31b701e495e7d609135e2dee50035d72f7c59b", "filename": "src/librustc_error_codes/error_codes/E0738.md", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_error_codes%2Ferror_codes%2FE0738.md", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_error_codes%2Ferror_codes%2FE0738.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0738.md?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -1,11 +0,0 @@\n-`#[track_caller]` cannot be used to annotate foreign functions.\n-\n-Erroneous example:\n-\n-```compile_fail,E0738\n-#![feature(track_caller)]\n-extern \"Rust\" {\n-    #[track_caller]\n-    fn bar();\n-}\n-```"}, {"sha": "6e1a4ecf47a44e98ebb7f5cfb643aa041cf68653", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -178,11 +178,11 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def_id);\n-\n         let mut body = BodyAndCache::new(body);\n         body.ensure_predecessors();\n \n+        lints::check(tcx, &body.unwrap_read_only(), def_id);\n+\n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here.\n         // The exception is `body.user_type_annotations`, which is used unmodified"}, {"sha": "a7370c36f0b9f85b1b0efc039016b60ab68f1c36", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 132, "deletions": 95, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -1,138 +1,175 @@\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::FnKind;\n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n-use rustc_middle::mir::{self, Body, TerminatorKind};\n+use rustc_middle::mir::{BasicBlock, Body, ReadOnlyBodyAndCache, TerminatorKind, START_BLOCK};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n+use std::collections::VecDeque;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n+crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &ReadOnlyBodyAndCache<'_, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n-        check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), body, def_id);\n+        if let FnKind::Closure(_) = fn_like_node.kind() {\n+            // closures can't recur, so they don't matter.\n+            return;\n+        }\n+\n+        check_fn_for_unconditional_recursion(tcx, body, def_id);\n     }\n }\n \n fn check_fn_for_unconditional_recursion<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    fn_kind: FnKind<'_>,\n-    body: &Body<'tcx>,\n+    body: &ReadOnlyBodyAndCache<'_, 'tcx>,\n     def_id: DefId,\n ) {\n-    if let FnKind::Closure(_) = fn_kind {\n-        // closures can't recur, so they don't matter.\n-        return;\n-    }\n+    let self_calls = find_blocks_calling_self(tcx, &body, def_id);\n \n-    //FIXME(#54444) rewrite this lint to use the dataflow framework\n-\n-    // Walk through this function (say `f`) looking to see if\n-    // every possible path references itself, i.e., the function is\n-    // called recursively unconditionally. This is done by trying\n-    // to find a path from the entry node to the exit node that\n-    // *doesn't* call `f` by traversing from the entry while\n-    // pretending that calls of `f` are sinks (i.e., ignoring any\n-    // exit edges from them).\n-    //\n-    // NB. this has an edge case with non-returning statements,\n-    // like `loop {}` or `panic!()`: control flow never reaches\n-    // the exit node through these, so one can have a function\n-    // that never actually calls itself but is still picked up by\n-    // this lint:\n-    //\n-    //     fn f(cond: bool) {\n-    //         if !cond { panic!() } // could come from `assert!(cond)`\n-    //         f(false)\n-    //     }\n-    //\n-    // In general, functions of that form may be able to call\n-    // itself a finite number of times and then diverge. The lint\n-    // considers this to be an error for two reasons, (a) it is\n-    // easier to implement, and (b) it seems rare to actually want\n-    // to have behaviour like the above, rather than\n-    // e.g., accidentally recursing after an assert.\n-\n-    let basic_blocks = body.basic_blocks();\n-    let mut reachable_without_self_call_queue = vec![mir::START_BLOCK];\n-    let mut reached_exit_without_self_call = false;\n-    let mut self_call_locations = vec![];\n-    let mut visited = BitSet::new_empty(basic_blocks.len());\n+    // Stores a list of `Span`s for every basic block. Those are the spans of self-calls where we\n+    // know that one of them will definitely be reached. If the list is empty, the block either\n+    // wasn't processed yet or will not always go to a self-call.\n+    let mut results = IndexVec::from_elem_n(vec![], body.basic_blocks().len());\n \n-    let param_env = tcx.param_env(def_id);\n-    let trait_substs_count = match tcx.opt_associated_item(def_id) {\n-        Some(AssocItem { container: AssocItemContainer::TraitContainer(trait_def_id), .. }) => {\n-            tcx.generics_of(trait_def_id).count()\n-        }\n-        _ => 0,\n-    };\n-    let caller_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n+    // We start the analysis at the self calls and work backwards.\n+    let mut queue: VecDeque<_> = self_calls.iter().collect();\n \n-    while let Some(bb) = reachable_without_self_call_queue.pop() {\n-        if !visited.insert(bb) {\n-            //already done\n+    while let Some(bb) = queue.pop_front() {\n+        if !results[bb].is_empty() {\n+            // Already propagated.\n             continue;\n         }\n \n-        let block = &basic_blocks[bb];\n-\n-        if let Some(ref terminator) = block.terminator {\n-            match terminator.kind {\n-                TerminatorKind::Call { ref func, .. } => {\n-                    let func_ty = func.ty(body, tcx);\n-\n-                    if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n-                        let (call_fn_id, call_substs) = if let Some(instance) =\n-                            Instance::resolve(tcx, param_env, fn_def_id, substs)\n-                        {\n-                            (instance.def_id(), instance.substs)\n-                        } else {\n-                            (fn_def_id, substs)\n-                        };\n-\n-                        let is_self_call = call_fn_id == def_id\n-                            && &call_substs[..caller_substs.len()] == caller_substs;\n-\n-                        if is_self_call {\n-                            self_call_locations.push(terminator.source_info);\n-\n-                            //this is a self call so we shouldn't explore\n-                            //further down this path\n-                            continue;\n-                        }\n-                    }\n+        let locations = if self_calls.contains(bb) {\n+            // `bb` *is* a self-call.\n+            // We don't look at successors here because they are irrelevant here and we don't want\n+            // to lint them (eg. `f(); f()` should only lint the first call).\n+            vec![bb]\n+        } else {\n+            // If *all* successors of `bb` lead to a self-call, emit notes at all of their\n+            // locations.\n+\n+            // Determine all \"relevant\" successors. We ignore successors only reached via unwinding.\n+            let terminator = body[bb].terminator();\n+            let relevant_successors = match &terminator.kind {\n+                TerminatorKind::Call { destination: None, .. }\n+                | TerminatorKind::Yield { .. }\n+                | TerminatorKind::GeneratorDrop => None.into_iter().chain(&[]),\n+                TerminatorKind::SwitchInt { targets, .. } => None.into_iter().chain(targets),\n+                TerminatorKind::Goto { target }\n+                | TerminatorKind::Drop { target, .. }\n+                | TerminatorKind::DropAndReplace { target, .. }\n+                | TerminatorKind::Assert { target, .. }\n+                | TerminatorKind::FalseEdges { real_target: target, .. }\n+                | TerminatorKind::FalseUnwind { real_target: target, .. }\n+                | TerminatorKind::Call { destination: Some((_, target)), .. } => {\n+                    Some(target).into_iter().chain(&[])\n                 }\n-                TerminatorKind::Abort | TerminatorKind::Return => {\n-                    //found a path!\n-                    reached_exit_without_self_call = true;\n-                    break;\n+                TerminatorKind::Resume\n+                | TerminatorKind::Abort\n+                | TerminatorKind::Return\n+                | TerminatorKind::Unreachable => {\n+                    // We propagate backwards, so these should never be encountered here.\n+                    unreachable!(\"unexpected terminator {:?}\", terminator.kind)\n                 }\n-                _ => {}\n+            };\n+\n+            // If all our successors are known to lead to self-calls, then we do too.\n+            let all_are_self_calls =\n+                relevant_successors.clone().all(|&succ| !results[succ].is_empty());\n+\n+            if all_are_self_calls {\n+                // We'll definitely lead to a self-call. Merge all call locations of the successors\n+                // for linting them later.\n+                relevant_successors.flat_map(|&succ| results[succ].iter().copied()).collect()\n+            } else {\n+                // At least 1 successor does not always lead to a self-call, so we also don't.\n+                vec![]\n             }\n+        };\n \n-            for successor in terminator.successors() {\n-                reachable_without_self_call_queue.push(*successor);\n-            }\n+        if !locations.is_empty() {\n+            // This is a newly confirmed-to-always-reach-self-call block.\n+            results[bb] = locations;\n+\n+            // Propagate backwards through the CFG.\n+            debug!(\"propagate loc={:?} in {:?} -> {:?}\", results[bb], bb, body.predecessors()[bb]);\n+            queue.extend(body.predecessors()[bb].iter().copied());\n         }\n     }\n \n-    // Check the number of self calls because a function that\n-    // doesn't return (e.g., calls a `-> !` function or `loop { /*\n-    // no break */ }`) shouldn't be linted unless it actually\n-    // recurs.\n-    if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n+    debug!(\"unconditional recursion results: {:?}\", results);\n+\n+    let self_call_locations = &mut results[START_BLOCK];\n+    self_call_locations.sort();\n+    self_call_locations.dedup();\n+\n+    if !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n             db.span_label(sp, \"cannot return without recursing\");\n             // offer some help to the programmer.\n-            for location in &self_call_locations {\n-                db.span_label(location.span, \"recursive call site\");\n+            for bb in self_call_locations {\n+                let span = body.basic_blocks()[*bb].terminator().source_info.span;\n+                db.span_label(span, \"recursive call site\");\n             }\n             db.help(\"a `loop` may express intention better if this is on purpose\");\n             db.emit();\n         });\n     }\n }\n+\n+/// Finds blocks with `Call` terminators that would end up calling back into the same method.\n+fn find_blocks_calling_self<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+) -> BitSet<BasicBlock> {\n+    let param_env = tcx.param_env(def_id);\n+\n+    // If this is trait/impl method, extract the trait's substs.\n+    let trait_substs_count = match tcx.opt_associated_item(def_id) {\n+        Some(AssocItem { container: AssocItemContainer::TraitContainer(trait_def_id), .. }) => {\n+            tcx.generics_of(trait_def_id).count()\n+        }\n+        _ => 0,\n+    };\n+    let trait_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n+\n+    let mut self_calls = BitSet::new_empty(body.basic_blocks().len());\n+\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+        if let TerminatorKind::Call { func, .. } = &data.terminator().kind {\n+            let func_ty = func.ty(body, tcx);\n+\n+            if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n+                let (call_fn_id, call_substs) =\n+                    if let Some(instance) = Instance::resolve(tcx, param_env, fn_def_id, substs) {\n+                        (instance.def_id(), instance.substs)\n+                    } else {\n+                        (fn_def_id, substs)\n+                    };\n+\n+                // FIXME(#57965): Make this work across function boundaries\n+\n+                // If this is a trait fn, the substs on the trait have to match, or we might be\n+                // calling into an entirely different method (for example, a call from the default\n+                // method in the trait to `<A as Trait<B>>::method`, where `A` and/or `B` are\n+                // specific types).\n+                let is_self_call =\n+                    call_fn_id == def_id && &call_substs[..trait_substs.len()] == trait_substs;\n+\n+                if is_self_call {\n+                    self_calls.insert(bb);\n+                }\n+            }\n+        }\n+    }\n+\n+    self_calls\n+}"}, {"sha": "3f2c02f6c461bb96887a08af0097d4501c90a4d0", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -141,7 +141,7 @@ impl CheckAttrVisitor<'tcx> {\n         target: Target,\n     ) -> bool {\n         match target {\n-            Target::Fn if attr::contains_name(attrs, sym::naked) => {\n+            _ if attr::contains_name(attrs, sym::naked) => {\n                 struct_span_err!(\n                     self.tcx.sess,\n                     *attr_span,\n@@ -151,17 +151,7 @@ impl CheckAttrVisitor<'tcx> {\n                 .emit();\n                 false\n             }\n-            Target::ForeignFn => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    *attr_span,\n-                    E0738,\n-                    \"`#[track_caller]` is not supported on foreign functions\",\n-                )\n-                .emit();\n-                false\n-            }\n-            Target::Fn | Target::Method(..) => true,\n+            Target::Fn | Target::Method(..) | Target::ForeignFn => true,\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "4c02127c1066990ac3ef9867f495d94df5aba865", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -717,9 +717,17 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             self.cx.parent\n         );\n \n+        // Save all state that is specific to the outer function\n+        // body. These will be restored once down below, once we've\n+        // visited the body.\n         let outer_ec = mem::replace(&mut self.expr_and_pat_count, 0);\n         let outer_cx = self.cx;\n         let outer_ts = mem::take(&mut self.terminating_scopes);\n+        // The 'pessimistic yield' flag is set to true when we are\n+        // processing a `+=` statement and have to make pessimistic\n+        // control flow assumptions. This doesn't apply to nested\n+        // bodies within the `+=` statements. See #69307.\n+        let outer_pessimistic_yield = mem::replace(&mut self.pessimistic_yield, false);\n         self.terminating_scopes.insert(body.value.hir_id.local_id);\n \n         if let Some(root_id) = self.cx.root_id {\n@@ -771,6 +779,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         self.expr_and_pat_count = outer_ec;\n         self.cx = outer_cx;\n         self.terminating_scopes = outer_ts;\n+        self.pessimistic_yield = outer_pessimistic_yield;\n     }\n \n     fn visit_arm(&mut self, a: &'tcx Arm<'tcx>) {"}, {"sha": "4e2423bc3b11452ac5be6eaa0abf44db2724fd3b", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -1017,7 +1017,13 @@ pub fn get_cmd_lint_options(\n     let mut describe_lints = false;\n \n     for &level in &[lint::Allow, lint::Warn, lint::Deny, lint::Forbid] {\n-        for (arg_pos, lint_name) in matches.opt_strs_pos(level.as_str()) {\n+        for (passed_arg_pos, lint_name) in matches.opt_strs_pos(level.as_str()) {\n+            let arg_pos = if let lint::Forbid = level {\n+                // forbid is always specified last, so it can't be overridden\n+                usize::max_value()\n+            } else {\n+                passed_arg_pos\n+            };\n             if lint_name == \"help\" {\n                 describe_lints = true;\n             } else {"}, {"sha": "d745e87a07258258ebe442c6f1171733e7c0506c", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -81,10 +81,54 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n+pub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {\n+    let ptr = haystack.as_ptr();\n+    let mut len = haystack.len();\n+    let mut start = &haystack[..];\n+\n+    // For performance reasons unfold the loop eight times.\n+    while len >= 8 {\n+        if start[0] == needle {\n+            return Some((start.as_ptr() as usize - ptr as usize) / 2);\n+        }\n+        if start[1] == needle {\n+            return Some((start[1..].as_ptr() as usize - ptr as usize) / 2);\n+        }\n+        if start[2] == needle {\n+            return Some((start[2..].as_ptr() as usize - ptr as usize) / 2);\n+        }\n+        if start[3] == needle {\n+            return Some((start[3..].as_ptr() as usize - ptr as usize) / 2);\n+        }\n+        if start[4] == needle {\n+            return Some((start[4..].as_ptr() as usize - ptr as usize) / 2);\n+        }\n+        if start[5] == needle {\n+            return Some((start[5..].as_ptr() as usize - ptr as usize) / 2);\n+        }\n+        if start[6] == needle {\n+            return Some((start[6..].as_ptr() as usize - ptr as usize) / 2);\n+        }\n+        if start[7] == needle {\n+            return Some((start[7..].as_ptr() as usize - ptr as usize) / 2);\n+        }\n+\n+        start = &start[8..];\n+        len -= 8;\n+    }\n+\n+    for (i, c) in start.iter().enumerate() {\n+        if *c == needle {\n+            return Some((start.as_ptr() as usize - ptr as usize) / 2 + i);\n+        }\n+    }\n+    None\n+}\n+\n pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> crate::io::Result<Vec<u16>> {\n     fn inner(s: &OsStr) -> crate::io::Result<Vec<u16>> {\n         let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n-        if maybe_result.iter().any(|&u| u == 0) {\n+        if unrolled_find_u16s(0, &maybe_result).is_some() {\n             return Err(crate::io::Error::new(\n                 ErrorKind::InvalidInput,\n                 \"strings passed to WinAPI cannot contain NULs\",\n@@ -214,7 +258,7 @@ fn wide_char_to_multi_byte(\n }\n \n pub fn truncate_utf16_at_nul(v: &[u16]) -> &[u16] {\n-    match v.iter().position(|c| *c == 0) {\n+    match unrolled_find_u16s(0, v) {\n         // don't include the 0\n         Some(i) => &v[..i],\n         None => v,"}, {"sha": "fc19bc039063a32dc6a887991406cb773598d91b", "filename": "src/test/ui-fulldeps/lint-group-forbid-always-trumps-cli.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui-fulldeps%2Flint-group-forbid-always-trumps-cli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui-fulldeps%2Flint-group-forbid-always-trumps-cli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-group-forbid-always-trumps-cli.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -0,0 +1,7 @@\n+// aux-build:lint-group-plugin-test.rs\n+// compile-flags: -F unused -A unused\n+\n+fn main() {\n+    let x = 1;\n+    //~^ ERROR unused variable: `x`\n+}"}, {"sha": "6bab367b0d175334da070a2701b8d69de239c9ed", "filename": "src/test/ui-fulldeps/lint-group-forbid-always-trumps-cli.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui-fulldeps%2Flint-group-forbid-always-trumps-cli.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui-fulldeps%2Flint-group-forbid-always-trumps-cli.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-group-forbid-always-trumps-cli.stderr?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -0,0 +1,10 @@\n+error: unused variable: `x`\n+  --> $DIR/lint-group-forbid-always-trumps-cli.rs:5:9\n+   |\n+LL |     let x = 1;\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+   |\n+   = note: `-F unused-variables` implied by `-F unused`\n+\n+error: aborting due to previous error\n+"}, {"sha": "b7cdf3987f1cb3ba12c393aec35663d3a3ad02d0", "filename": "src/test/ui/async-await/issues/issue-69307-nested.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307-nested.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for #69307\n+//\n+// Having a `async { .. foo.await .. }` block appear inside of a `+=`\n+// expression was causing an ICE due to a failure to save/restore\n+// state in the AST numbering pass when entering a nested body.\n+//\n+// check-pass\n+// edition:2018\n+\n+fn block_on<F>(_: F) -> usize {\n+    0\n+}\n+\n+fn main() {}\n+\n+async fn bar() {\n+    let mut sum = 0;\n+    sum += {\n+        block_on(async {\n+            baz().await;\n+            let mut inner = 1;\n+            inner += block_on(async {\n+                baz().await;\n+                0\n+            })\n+        })\n+    };\n+}\n+\n+async fn baz() {}"}, {"sha": "4dae96ec8a6a7bbbaab976f33bcdefac215ad067", "filename": "src/test/ui/async-await/issues/issue-69307.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-69307.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for #69307\n+//\n+// Having a `async { .. foo.await .. }` block appear inside of a `+=`\n+// expression was causing an ICE due to a failure to save/restore\n+// state in the AST numbering pass when entering a nested body.\n+//\n+// check-pass\n+// edition:2018\n+\n+fn block_on<F>(_: F) -> usize {\n+    0\n+}\n+\n+fn main() {}\n+\n+async fn bar() {\n+    let mut sum = 0;\n+    sum += block_on(async {\n+        baz().await;\n+    });\n+}\n+\n+async fn baz() {}"}, {"sha": "d2a0329585b71b0d9302f8fafe51d78d5692d4b8", "filename": "src/test/ui/lint/lint-unconditional-recursion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -131,4 +131,22 @@ trait Bar {\n     }\n }\n \n+// Do not trigger on functions that may diverge instead of self-recursing (#54444)\n+\n+pub fn loops(x: bool) {\n+    if x {\n+        loops(x);\n+    } else {\n+        loop {}\n+    }\n+}\n+\n+pub fn panics(x: bool) {\n+    if x {\n+        panics(!x);\n+    } else {\n+        panic!(\"panics\");\n+    }\n+}\n+\n fn main() {}"}, {"sha": "9f6a69a51c0ceca41873815d6a28172e7ae86e52", "filename": "src/test/ui/rfc-2091-track-caller/error-extern-fn.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-extern-fn.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -1,9 +0,0 @@\n-#![feature(track_caller)]\n-#![allow(dead_code)]\n-\n-extern \"Rust\" {\n-    #[track_caller] //~ ERROR: `#[track_caller]` is not supported on foreign functions\n-    fn bar();\n-}\n-\n-fn main() {}"}, {"sha": "b03f5fbbdb20e1bf5ba06f205d61a3f2fd5d6c55", "filename": "src/test/ui/rfc-2091-track-caller/error-extern-fn.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-extern-fn.stderr?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -1,9 +0,0 @@\n-error[E0738]: `#[track_caller]` is not supported on foreign functions\n-  --> $DIR/error-extern-fn.rs:5:5\n-   |\n-LL |     #[track_caller]\n-   |     ^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0738`."}, {"sha": "f45738483333599caa3ec2e98354933dfde62561", "filename": "src/test/ui/rfc-2091-track-caller/error-with-naked.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -1,8 +1,21 @@\n #![feature(naked_functions, track_caller)]\n \n-#[track_caller]\n+#[track_caller] //~ ERROR cannot use `#[track_caller]` with `#[naked]`\n #[naked]\n fn f() {}\n-//~^^^ ERROR cannot use `#[track_caller]` with `#[naked]`\n+\n+struct S;\n+\n+impl S {\n+    #[track_caller] //~ ERROR cannot use `#[track_caller]` with `#[naked]`\n+    #[naked]\n+    fn g() {}\n+}\n+\n+extern \"Rust\" {\n+    #[track_caller] //~ ERROR cannot use `#[track_caller]` with `#[naked]`\n+    #[naked]\n+    fn h();\n+}\n \n fn main() {}"}, {"sha": "1249d1df07179cbc655ec28fd566acb6b3b1ba2a", "filename": "src/test/ui/rfc-2091-track-caller/error-with-naked.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.stderr?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -4,6 +4,18 @@ error[E0736]: cannot use `#[track_caller]` with `#[naked]`\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0736]: cannot use `#[track_caller]` with `#[naked]`\n+  --> $DIR/error-with-naked.rs:16:5\n+   |\n+LL |     #[track_caller]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error[E0736]: cannot use `#[track_caller]` with `#[naked]`\n+  --> $DIR/error-with-naked.rs:10:5\n+   |\n+LL |     #[track_caller]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0736`."}, {"sha": "23c17d743c43c217ff5db5be31d108a52c08427e", "filename": "src/test/ui/rfc-2091-track-caller/track-caller-ffi.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc97a85381cc52eb872d27e50e4d518926a27c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-ffi.rs?ref=93dc97a85381cc52eb872d27e50e4d518926a27c", "patch": "@@ -0,0 +1,50 @@\n+// run-pass\n+\n+#![feature(track_caller)]\n+\n+use std::panic::Location;\n+\n+extern \"Rust\" {\n+    #[track_caller]\n+    fn rust_track_caller_ffi_test_tracked() -> &'static Location<'static>;\n+    fn rust_track_caller_ffi_test_untracked() -> &'static Location<'static>;\n+}\n+\n+fn rust_track_caller_ffi_test_nested_tracked() -> &'static Location<'static> {\n+    unsafe { rust_track_caller_ffi_test_tracked() }\n+}\n+\n+mod provides {\n+    use std::panic::Location;\n+    #[track_caller] // UB if we did not have this!\n+    #[no_mangle]\n+    fn rust_track_caller_ffi_test_tracked() -> &'static Location<'static> {\n+        Location::caller()\n+    }\n+    #[no_mangle]\n+    fn rust_track_caller_ffi_test_untracked() -> &'static Location<'static> {\n+        Location::caller()\n+    }\n+}\n+\n+fn main() {\n+    let location = Location::caller();\n+    assert_eq!(location.file(), file!());\n+    assert_eq!(location.line(), 31);\n+    assert_eq!(location.column(), 20);\n+\n+    let tracked = unsafe { rust_track_caller_ffi_test_tracked() };\n+    assert_eq!(tracked.file(), file!());\n+    assert_eq!(tracked.line(), 36);\n+    assert_eq!(tracked.column(), 28);\n+\n+    let untracked = unsafe { rust_track_caller_ffi_test_untracked() };\n+    assert_eq!(untracked.file(), file!());\n+    assert_eq!(untracked.line(), 26);\n+    assert_eq!(untracked.column(), 9);\n+\n+    let contained = rust_track_caller_ffi_test_nested_tracked();\n+    assert_eq!(contained.file(), file!());\n+    assert_eq!(contained.line(), 14);\n+    assert_eq!(contained.column(), 14);\n+}"}]}