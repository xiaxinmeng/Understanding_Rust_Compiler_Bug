{"sha": "87ac118ba3d0c8268e043fadbd63b51e06904795", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YWMxMThiYTNkMGM4MjY4ZTA0M2ZhZGJkNjNiNTFlMDY5MDQ3OTU=", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T17:03:54Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T18:43:27Z"}, "message": "Add more links to `core::pin` to improve visual consistency.", "tree": {"sha": "733909f20a4cd0e708c70cf75096caaec00cee32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/733909f20a4cd0e708c70cf75096caaec00cee32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87ac118ba3d0c8268e043fadbd63b51e06904795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87ac118ba3d0c8268e043fadbd63b51e06904795", "html_url": "https://github.com/rust-lang/rust/commit/87ac118ba3d0c8268e043fadbd63b51e06904795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87ac118ba3d0c8268e043fadbd63b51e06904795/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceaeb249a3813a78bd81fa3890e27e8843a58262", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceaeb249a3813a78bd81fa3890e27e8843a58262", "html_url": "https://github.com/rust-lang/rust/commit/ceaeb249a3813a78bd81fa3890e27e8843a58262"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "52c1c1975cc50d7aa31bc3290f123a7571ae72f0", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/87ac118ba3d0c8268e043fadbd63b51e06904795/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ac118ba3d0c8268e043fadbd63b51e06904795/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=87ac118ba3d0c8268e043fadbd63b51e06904795", "patch": "@@ -14,12 +14,12 @@\n //! for more details.\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as <code>[Box]\\<T></code> and `&mut T` allow replacing and\n+//! and common smart-pointer types such as <code>[Box]\\<T></code> and <code>[&mut] T</code> allow replacing and\n //! moving the values they contain: you can move out of a <code>[Box]\\<T></code>, or you can use [`mem::swap`].\n //! <code>[Pin]\\<P></code> wraps a pointer type `P`, so <code>[Pin]<[Box]\\<T>></code> functions much like a regular\n //! <code>[Box]\\<T></code>: when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n-//! deallocated. Similarly, <code>[Pin]<&mut T></code> is a lot like `&mut T`. However, <code>[Pin]\\<P></code> does\n-//! not let clients actually obtain a <code>[Box]\\<T></code> or `&mut T` to pinned data, which implies that you\n+//! deallocated. Similarly, <code>[Pin]<[&mut] T></code> is a lot like <code>[&mut] T</code>. However, <code>[Pin]\\<P></code> does\n+//! not let clients actually obtain a <code>[Box]\\<T></code> or <code>[&mut] T</code> to pinned data, which implies that you\n //! cannot use operations such as [`mem::swap`]:\n //!\n //! ```\n@@ -35,12 +35,12 @@\n //! It is worth reiterating that <code>[Pin]\\<P></code> does *not* change the fact that a Rust compiler\n //! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, <code>[Pin]\\<P></code>\n //! prevents certain *values* (pointed to by pointers wrapped in <code>[Pin]\\<P></code>) from being\n-//! moved by making it impossible to call methods that require `&mut T` on them\n+//! moved by making it impossible to call methods that require <code>[&mut] T</code> on them\n //! (like [`mem::swap`]).\n //!\n //! <code>[Pin]\\<P></code> can be used to wrap any pointer type `P`, and as such it interacts with\n-//! [`Deref`] and [`DerefMut`]. A <code>[Pin]\\<P></code> where `P: Deref` should be considered\n-//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a <code>[Pin]<[Box]\\<T>></code> is\n+//! [`Deref`] and [`DerefMut`]. A <code>[Pin]\\<P></code> where <code>P: [Deref]</code> should be considered\n+//! as a \"`P`-style pointer\" to a pinned <code>P::[Target]</code> \u2013 so, a <code>[Pin]<[Box]\\<T>></code> is\n //! an owned pointer to a pinned `T`, and a <code>[Pin]<[Rc]\\<T>></code> is a reference-counted\n //! pointer to a pinned `T`.\n //! For correctness, <code>[Pin]\\<P></code> relies on the implementations of [`Deref`] and\n@@ -53,19 +53,19 @@\n //! rely on having a stable address. This includes all the basic types (like\n //! [`bool`], [`i32`], and references) as well as types consisting solely of these\n //! types. Types that do not care about pinning implement the [`Unpin`]\n-//! auto-trait, which cancels the effect of <code>[Pin]\\<P></code>. For `T: Unpin`,\n-//! <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do <code>[Pin]<&mut T></code> and\n-//! `&mut T`.\n+//! auto-trait, which cancels the effect of <code>[Pin]\\<P></code>. For <code>T: [Unpin]</code>,\n+//! <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do <code>[Pin]<[&mut] T></code> and\n+//! <code>[&mut] T</code>.\n //!\n-//! Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer\n+//! Note that pinning and [`Unpin`] only affect the pointed-to type <code>P::[Target]</code>, not the pointer\n //! type `P` itself that got wrapped in <code>[Pin]\\<P></code>. For example, whether or not <code>[Box]\\<T></code> is\n //! [`Unpin`] has no effect on the behavior of <code>[Pin]<[Box]\\<T>></code> (here, `T` is the\n //! pointed-to type).\n //!\n //! # Example: self-referential struct\n //!\n //! Before we go into more details to explain the guarantees and choices\n-//! associated with `Pin<T>`, we discuss some examples for how it might be used.\n+//! associated with <code>[Pin]\\<P></code>, we discuss some examples for how it might be used.\n //! Feel free to [skip to where the theoretical discussion continues](#drop-guarantee).\n //!\n //! ```rust\n@@ -165,18 +165,18 @@\n //! # `Drop` implementation\n //!\n //! If your type uses pinning (such as the two examples above), you have to be careful\n-//! when implementing [`Drop`]. The [`drop`] function takes `&mut self`, but this\n+//! when implementing [`Drop`]. The [`drop`] function takes <code>[&mut] self</code>, but this\n //! is called *even if your type was previously pinned*! It is as if the\n //! compiler automatically called [`Pin::get_unchecked_mut`].\n //!\n //! This can never cause a problem in safe code because implementing a type that\n //! relies on pinning requires unsafe code, but be aware that deciding to make\n //! use of pinning in your type (for example by implementing some operation on\n-//! <code>[Pin]<&Self></code> or <code>[Pin]<&mut Self></code>) has consequences for your [`Drop`]\n+//! <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your [`Drop`]\n //! implementation as well: if an element of your type could have been pinned,\n-//! you must treat [`Drop`] as implicitly taking <code>[Pin]<&mut Self></code>.\n+//! you must treat [`Drop`] as implicitly taking <code>[Pin]<[&mut] Self></code>.\n //!\n-//! For example, you could implement `Drop` as follows:\n+//! For example, you could implement [`Drop`] as follows:\n //!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n@@ -204,18 +204,18 @@\n //! # Projections and Structural Pinning\n //!\n //! When working with pinned structs, the question arises how one can access the\n-//! fields of that struct in a method that takes just <code>[Pin]<&mut Struct></code>.\n+//! fields of that struct in a method that takes just <code>[Pin]<[&mut] Struct></code>.\n //! The usual approach is to write helper methods (so called *projections*)\n-//! that turn <code>[Pin]<&mut Struct></code> into a reference to the field, but what\n-//! type should that reference have? Is it <code>[Pin]<&mut Field></code> or `&mut Field`?\n+//! that turn <code>[Pin]<[&mut] Struct></code> into a reference to the field, but what\n+//! type should that reference have? Is it <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>?\n //! The same question arises with the fields of an `enum`, and also when considering\n //! container/wrapper types such as <code>[Vec]\\<T></code>, <code>[Box]\\<T></code>, or <code>[RefCell]\\<T></code>.\n //! (This question applies to both mutable and shared references, we just\n //! use the more common case of mutable references here for illustration.)\n //!\n //! It turns out that it is actually up to the author of the data structure\n //! to decide whether the pinned projection for a particular field turns\n-//! <code>[Pin]<&mut Struct></code> into <code>[Pin]<&mut Field></code> or `&mut Field`. There are some\n+//! <code>[Pin]<[&mut] Struct></code> into <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>. There are some\n //! constraints though, and the most important constraint is *consistency*:\n //! every field can be *either* projected to a pinned reference, *or* have\n //! pinning removed as part of the projection. If both are done for the same field,\n@@ -230,12 +230,12 @@\n //! ## Pinning *is not* structural for `field`\n //!\n //! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n-//! but that is actually the easiest choice: if a <code>[Pin]<&mut Field></code> is never created,\n+//! but that is actually the easiest choice: if a <code>[Pin]<[&mut] Field></code> is never created,\n //! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n //! all you have to ensure is that you never create a pinned reference to that field.\n //!\n //! Fields without structural pinning may have a projection method that turns\n-//! <code>[Pin]<&mut Struct></code> into `&mut Field`:\n+//! <code>[Pin]<[&mut] Struct></code> into <code>[&mut] Field</code>:\n //!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n@@ -249,16 +249,16 @@\n //! }\n //! ```\n //!\n-//! You may also `impl Unpin for Struct` *even if* the type of `field`\n+//! You may also <code>impl [Unpin] for Struct</code> *even if* the type of `field`\n //! is not [`Unpin`]. What that type thinks about pinning is not relevant\n-//! when no <code>[Pin]<&mut Field></code> is ever created.\n+//! when no <code>[Pin]<[&mut] Field></code> is ever created.\n //!\n //! ## Pinning *is* structural for `field`\n //!\n //! The other option is to decide that pinning is \"structural\" for `field`,\n //! meaning that if the struct is pinned then so is the field.\n //!\n-//! This allows writing a projection that creates a <code>[Pin]<&mut Field></code>, thus\n+//! This allows writing a projection that creates a <code>[Pin]<[&mut] Field></code>, thus\n //! witnessing that the field is pinned:\n //!\n //! ```rust,no_run\n@@ -278,12 +278,12 @@\n //! 1.  The struct must only be [`Unpin`] if all the structural fields are\n //!     [`Unpin`]. This is the default, but [`Unpin`] is a safe trait, so as the author of\n //!     the struct it is your responsibility *not* to add something like\n-//!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n+//!     <code>impl\\<T> [Unpin] for Struct\\<T></code>. (Notice that adding a projection operation\n //!     requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break\n-//!     the principle that you only have to worry about any of this if you use `unsafe`.)\n+//!     the principle that you only have to worry about any of this if you use [`unsafe`].)\n //! 2.  The destructor of the struct must not move structural fields out of its argument. This\n-//!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n-//!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n+//!     is the exact point that was raised in the [previous section][drop-impl]: [`drop`] takes\n+//!     <code>[&mut] self</code>, but the struct (and hence its fields) might have been pinned before.\n //!     You have to guarantee that you do not move a field inside your [`Drop`] implementation.\n //!     In particular, as explained previously, this means that your struct must *not*\n //!     be `#[repr(packed)]`.\n@@ -299,13 +299,13 @@\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n //!     the structural fields when your type is pinned. For example, if the struct contains an\n-//!     <code>[Option]\\<T></code> and there is a `take`-like operation with type\n-//!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n-//!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n+//!     <code>[Option]\\<T></code> and there is a [`take`][Option::take]-like operation with type\n+//!     <code>fn([Pin]<[&mut] Struct\\<T>>) -> [Option]\\<T></code>,\n+//!     that operation can be used to move a `T` out of a pinned `Struct<T>` \u2013 which means\n //!     pinning cannot be structural for the field holding this data.\n //!\n //!     For a more complex example of moving data out of a pinned type, imagine if <code>[RefCell]\\<T></code>\n-//!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n+//!     had a method <code>fn get_pin_mut(self: [Pin]<[&mut] Self>) -> [Pin]<[&mut] T></code>.\n //!     Then we could do the following:\n //!     ```compile_fail\n //!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {\n@@ -316,7 +316,7 @@\n //!     }\n //!     ```\n //!     This is catastrophic, it means we can first pin the content of the <code>[RefCell]\\<T></code>\n-//!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n+//!     (using <code>[RefCell]::get_pin_mut</code>) and then move that content using the mutable\n //!     reference we got later.\n //!\n //! ## Examples\n@@ -328,15 +328,15 @@\n //! contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the\n //! contents.\n //!\n-//! A <code>[Vec]\\<T></code> without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n+//! A <code>[Vec]\\<T></code> without structural pinning could <code>impl\\<T> [Unpin] for [Vec]\\<T></code>, because the contents\n //! are never pinned and the <code>[Vec]\\<T></code> itself is fine with being moved as well.\n //! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n-//! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n-//! It makes sense to do this for pointer types, because moving the `Box<T>`\n-//! does not actually move the `T`: the <code>[Box]\\<T></code> can be freely movable (aka `Unpin`) even if\n-//! the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and <code>[Pin]<&mut T></code> are always\n+//! and thus they do not offer pinning projections. This is why <code>[Box]\\<T>: [Unpin]</code> holds for all `T`.\n+//! It makes sense to do this for pointer types, because moving the <code>[Box]\\<T></code>\n+//! does not actually move the `T`: the <code>[Box]\\<T></code> can be freely movable (aka [`Unpin`]) even if\n+//! the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and <code>[Pin]<[&mut] T></code> are always\n //! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n //! pointers themselves can be moved without moving the pinned data. For both <code>[Box]\\<T></code> and\n //! <code>[Pin]<[Box]\\<T>></code>, whether the content is pinned is entirely independent of whether the\n@@ -346,10 +346,12 @@\n //! for the nested futures, as you need to get pinned references to them to call [`poll`].\n //! But if your combinator contains any other data that does not need to be pinned,\n //! you can make those fields not structural and hence freely access them with a\n-//! mutable reference even when you just have <code>[Pin]<&mut Self></code> (such as in your own\n+//! mutable reference even when you just have <code>[Pin]<[&mut] Self></code> (such as in your own\n //! [`poll`] implementation).\n //!\n+//! [Deref]: crate::ops::Deref\n //! [`Deref`]: crate::ops::Deref\n+//! [Target]: crate::ops::Deref::Target\n //! [`DerefMut`]: crate::ops::DerefMut\n //! [`mem::swap`]: crate::mem::swap\n //! [`mem::forget`]: crate::mem::forget\n@@ -367,6 +369,9 @@\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n //! [`poll`]: crate::future::Future::poll\n+//! [&]: ../../std/primitive.reference.html\n+//! [&mut]: ../../std/primitive.reference.html\n+//! [`unsafe`]: ../../std/keyword.unsafe.html\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n "}]}