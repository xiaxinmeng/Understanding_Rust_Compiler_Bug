{"sha": "baddce5155f7358af319818b10c992790dc8c572", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZGRjZTUxNTVmNzM1OGFmMzE5ODE4YjEwYzk5Mjc5MGRjOGM1NzI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-07T22:00:43Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-10T21:12:57Z"}, "message": "expand: Move \"derive containers\" into a separate `InvocationKind` variant\n\n`InvocationKind::Attr { attr: None, .. }` meaning something entirely different from a regular attribute was confusing as hell.", "tree": {"sha": "aef68de97d5a694e68ea6e931bb908edb6ff2076", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aef68de97d5a694e68ea6e931bb908edb6ff2076"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baddce5155f7358af319818b10c992790dc8c572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baddce5155f7358af319818b10c992790dc8c572", "html_url": "https://github.com/rust-lang/rust/commit/baddce5155f7358af319818b10c992790dc8c572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baddce5155f7358af319818b10c992790dc8c572/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b003dd6d9badf0e66b6e90af2052fefef94d4a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/b003dd6d9badf0e66b6e90af2052fefef94d4a43", "html_url": "https://github.com/rust-lang/rust/commit/b003dd6d9badf0e66b6e90af2052fefef94d4a43"}], "stats": {"total": 47, "additions": 29, "deletions": 18}, "files": [{"sha": "fc1becfe309603045710389c58f79377cf783db3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/baddce5155f7358af319818b10c992790dc8c572/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baddce5155f7358af319818b10c992790dc8c572/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=baddce5155f7358af319818b10c992790dc8c572", "patch": "@@ -221,14 +221,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n         let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n-            InvocationKind::Attr { attr: None, .. } =>\n-                return Ok(None),\n-            InvocationKind::Attr { attr: Some(ref attr), ref traits, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, traits.clone(), after_derive),\n+            InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n+                (&attr.path, MacroKind::Attr, derives.clone(), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n                 (&mac.node.path, MacroKind::Bang, Vec::new(), false),\n             InvocationKind::Derive { ref path, .. } =>\n                 (path, MacroKind::Derive, Vec::new(), false),\n+            InvocationKind::DeriveContainer { .. } =>\n+                return Ok(None),\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);"}, {"sha": "7fc62e357c5c4a9b81eb4facfd5d4773c5a62e5b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/baddce5155f7358af319818b10c992790dc8c572/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baddce5155f7358af319818b10c992790dc8c572/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=baddce5155f7358af319818b10c992790dc8c572", "patch": "@@ -199,9 +199,10 @@ pub enum InvocationKind {\n         span: Span,\n     },\n     Attr {\n-        attr: Option<ast::Attribute>,\n-        traits: Vec<Path>,\n+        attr: ast::Attribute,\n         item: Annotatable,\n+        // Required for resolving derive helper attributes.\n+        derives: Vec<Path>,\n         // We temporarily report errors for attribute macros placed after derives\n         after_derive: bool,\n     },\n@@ -210,15 +211,22 @@ pub enum InvocationKind {\n         item: Annotatable,\n         item_with_markers: Annotatable,\n     },\n+    /// \"Invocation\" that contains all derives from an item,\n+    /// broken into multiple `Derive` invocations when expanded.\n+    /// FIXME: Find a way to remove it.\n+    DeriveContainer {\n+        derives: Vec<Path>,\n+        item: Annotatable,\n+    },\n }\n \n impl Invocation {\n     pub fn span(&self) -> Span {\n-        match self.kind {\n-            InvocationKind::Bang { span, .. } => span,\n-            InvocationKind::Attr { attr: Some(ref attr), .. } => attr.span,\n-            InvocationKind::Attr { attr: None, .. } => DUMMY_SP,\n-            InvocationKind::Derive { ref path, .. } => path.span,\n+        match &self.kind {\n+            InvocationKind::Bang { span, .. } => *span,\n+            InvocationKind::Attr { attr, .. } => attr.span,\n+            InvocationKind::Derive { path, .. } => path.span,\n+            InvocationKind::DeriveContainer { item, .. } => item.span(),\n         }\n     }\n }\n@@ -329,7 +337,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n                 let fragment = self.expand_invoc(invoc, &ext.kind);\n                 self.collect_invocations(fragment, &[])\n-            } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n+            } else if let InvocationKind::DeriveContainer { derives: traits, item } = invoc.kind {\n                 if !item.derive_allowed() {\n                     let attr = attr::find_by_name(item.attrs(), sym::derive)\n                         .expect(\"`derive` attribute should exist\");\n@@ -522,7 +530,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!()\n             }\n-            InvocationKind::Attr { attr: Some(attr), mut item, .. } => match ext {\n+            InvocationKind::Attr { attr, mut item, .. } => match ext {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_attr_item(span, &item);\n                     let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n@@ -578,7 +586,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!()\n             }\n-            _ => unreachable!()\n+            InvocationKind::DeriveContainer { .. } => unreachable!()\n         }\n     }\n \n@@ -805,10 +813,10 @@ struct InvocationCollector<'a, 'b> {\n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n         // Expansion info for all the collected invocations is set upon their resolution,\n-        // with exception of the \"derive container\" case which is not resolved and can get\n+        // with exception of the derive container case which is not resolved and can get\n         // its expansion info immediately.\n         let expn_info = match &kind {\n-            InvocationKind::Attr { attr: None, item, .. } => Some(ExpnInfo::default(\n+            InvocationKind::DeriveContainer { item, .. } => Some(ExpnInfo::default(\n                 ExpnKind::Macro(MacroKind::Attr, sym::derive),\n                 item.span(), self.cx.parse_sess.edition,\n             )),\n@@ -833,12 +841,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(&mut self,\n                     attr: Option<ast::Attribute>,\n-                    traits: Vec<Path>,\n+                    derives: Vec<Path>,\n                     item: Annotatable,\n                     kind: AstFragmentKind,\n                     after_derive: bool)\n                     -> AstFragment {\n-        self.collect(kind, InvocationKind::Attr { attr, traits, item, after_derive })\n+        self.collect(kind, match attr {\n+            Some(attr) => InvocationKind::Attr { attr, item, derives, after_derive },\n+            None => InvocationKind::DeriveContainer { derives, item },\n+        })\n     }\n \n     fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>, after_derive: &mut bool)"}]}