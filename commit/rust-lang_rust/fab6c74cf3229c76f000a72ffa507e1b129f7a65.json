{"sha": "fab6c74cf3229c76f000a72ffa507e1b129f7a65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYjZjNzRjZjMyMjljNzZmMDAwYTcyZmZhNTA3ZTFiMTI5ZjdhNjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T02:44:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T16:31:44Z"}, "message": "rollup merge of #18494 : nikomatsakis/issue-18453", "tree": {"sha": "9c015fea0739cd77e1049b8f92547e718e193d77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c015fea0739cd77e1049b8f92547e718e193d77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab6c74cf3229c76f000a72ffa507e1b129f7a65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab6c74cf3229c76f000a72ffa507e1b129f7a65", "html_url": "https://github.com/rust-lang/rust/commit/fab6c74cf3229c76f000a72ffa507e1b129f7a65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab6c74cf3229c76f000a72ffa507e1b129f7a65/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f4d7f248d56f06a9902edf45524dd0f7fcbd9a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4d7f248d56f06a9902edf45524dd0f7fcbd9a5", "html_url": "https://github.com/rust-lang/rust/commit/0f4d7f248d56f06a9902edf45524dd0f7fcbd9a5"}, {"sha": "6bf0dc849f1ec4fe1fd024523f9111bcb523194e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf0dc849f1ec4fe1fd024523f9111bcb523194e", "html_url": "https://github.com/rust-lang/rust/commit/6bf0dc849f1ec4fe1fd024523f9111bcb523194e"}], "stats": {"total": 75, "additions": 68, "deletions": 7}, "files": [{"sha": "7098033a533b51b04fa79176efbdc57fcf21a6a7", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fab6c74cf3229c76f000a72ffa507e1b129f7a65/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab6c74cf3229c76f000a72ffa507e1b129f7a65/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=fab6c74cf3229c76f000a72ffa507e1b129f7a65", "patch": "@@ -1104,18 +1104,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n          * Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n          * This is generally true if either:\n          * - candidate i and candidate j are equivalent; or,\n-         * - candidate i is a where clause bound and candidate j is a concrete impl,\n+         * - candidate i is a conrete impl and candidate j is a where clause bound,\n          *   and the concrete impl is applicable to the types in the where clause bound.\n          *\n-         * The last case basically occurs with blanket impls like\n-         * `impl<T> Foo for T`.  In that case, a bound like `T:Foo` is\n-         * kind of an \"false\" ambiguity -- both are applicable to any\n-         * type, but in fact coherence requires that the bound will\n-         * always be resolved to the impl anyway.\n+         * The last case refers to cases where there are blanket impls (often conditional\n+         * blanket impls) as well as a where clause. This can come down to one of two cases:\n+         *\n+         * - The impl is truly unconditional (it has no where clauses\n+         *   of its own), in which case the where clause is\n+         *   unnecessary, because coherence requires that we would\n+         *   pick that particular impl anyhow (at least so long as we\n+         *   don't have specialization).\n+         *\n+         * - The impl is conditional, in which case we may not have winnowed it out\n+         *   because we don't know if the conditions apply, but the where clause is basically\n+         *   telling us taht there is some impl, though not necessarily the one we see.\n+         *\n+         * In both cases we prefer to take the where clause, which is\n+         * essentially harmless.  See issue #18453 for more details of\n+         * a case where doing the opposite caused us harm.\n          */\n \n         match (candidate_i, candidate_j) {\n-            (&ParamCandidate(ref vt), &ImplCandidate(impl_def_id)) => {\n+            (&ImplCandidate(impl_def_id), &ParamCandidate(ref vt)) => {\n                 debug!(\"Considering whether to drop param {} in favor of impl {}\",\n                        candidate_i.repr(self.tcx()),\n                        candidate_j.repr(self.tcx()));"}, {"sha": "772310d47335f0fcce37d795806cba825001a899", "filename": "src/test/run-pass/trait-where-clause-vs-impl.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fab6c74cf3229c76f000a72ffa507e1b129f7a65/src%2Ftest%2Frun-pass%2Ftrait-where-clause-vs-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab6c74cf3229c76f000a72ffa507e1b129f7a65/src%2Ftest%2Frun-pass%2Ftrait-where-clause-vs-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-where-clause-vs-impl.rs?ref=fab6c74cf3229c76f000a72ffa507e1b129f7a65", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when there is a conditional (but blanket) impl and a\n+// where clause, we don't get confused in trait resolution.\n+//\n+// Issue #18453.\n+\n+use std::rc::Rc;\n+\n+pub trait Foo<M> {\n+    fn foo(&mut self, msg: M);\n+}\n+\n+pub trait Bar<M> {\n+    fn dummy(&self) -> M;\n+}\n+\n+impl<M, F: Bar<M>> Foo<M> for F {\n+    fn foo(&mut self, msg: M) {\n+    }\n+}\n+\n+pub struct Both<M, F> {\n+    inner: Rc<(M, F)>,\n+}\n+\n+impl<M, F: Foo<M>> Clone for Both<M, F> {\n+    fn clone(&self) -> Both<M, F> {\n+        Both { inner: self.inner.clone() }\n+    }\n+}\n+\n+fn repro1<M, F: Foo<M>>(_both: Both<M, F>) {\n+}\n+\n+fn repro2<M, F: Foo<M>>(msg: M, foo: F) {\n+    let both = Both { inner: Rc::new((msg, foo)) };\n+    repro1(both.clone()); // <--- This clone causes problem\n+}\n+\n+pub fn main() {\n+}"}]}