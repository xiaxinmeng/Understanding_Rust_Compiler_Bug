{"sha": "43423f67a0f260c41181c5b2c1d25757f6b6babe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNDIzZjY3YTBmMjYwYzQxMTgxYzViMmMxZDI1NzU3ZjZiNmJhYmU=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-09T05:15:45Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-11T01:58:57Z"}, "message": "Address review comments", "tree": {"sha": "ec7a1578b6ab42afb4b51dc9adb61fa1c2d2cf10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec7a1578b6ab42afb4b51dc9adb61fa1c2d2cf10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43423f67a0f260c41181c5b2c1d25757f6b6babe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43423f67a0f260c41181c5b2c1d25757f6b6babe", "html_url": "https://github.com/rust-lang/rust/commit/43423f67a0f260c41181c5b2c1d25757f6b6babe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43423f67a0f260c41181c5b2c1d25757f6b6babe/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abc40040be3e10bb8228d627012c92c54d8f791f", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc40040be3e10bb8228d627012c92c54d8f791f", "html_url": "https://github.com/rust-lang/rust/commit/abc40040be3e10bb8228d627012c92c54d8f791f"}], "stats": {"total": 216, "additions": 131, "deletions": 85}, "files": [{"sha": "ee577213aba14cd7e29d466e35ceced6aa80959b", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43423f67a0f260c41181c5b2c1d25757f6b6babe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43423f67a0f260c41181c5b2c1d25757f6b6babe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=43423f67a0f260c41181c5b2c1d25757f6b6babe", "patch": "@@ -415,9 +415,8 @@ pub struct TypeckResults<'tcx> {\n     /// entire variable.\n     pub closure_captures: ty::UpvarListMap,\n \n-    /// Given the closure DefId this map provides a map of\n-    /// root variables to minimum set of `Place`s (and how) that need to be tracked\n-    /// to support all captures of that closure.\n+    /// Tracks the minimum captures required for a closure;\n+    /// see `MinCaptureInformationMap` for more details.\n     pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n \n     /// Stores the type, expression, span and optional scope span of all types"}, {"sha": "0c786be0478de5f4ca651a4c13f2b8b57e444365", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/43423f67a0f260c41181c5b2c1d25757f6b6babe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43423f67a0f260c41181c5b2c1d25757f6b6babe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=43423f67a0f260c41181c5b2c1d25757f6b6babe", "patch": "@@ -763,6 +763,31 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: ty::Region<'tcx>,\n }\n \n+/// Given the closure DefId this map provides a map of root variables to minimum\n+/// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n+pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; Maps a root variable to the list of `CapturedPlace`.\n+/// Used to track the minimum set of `Place`s that need to be captured to support all\n+/// Places captured by the closure starting at a given root variable.\n+///\n+/// This provides a convenient and quick way of checking if a variable being used within\n+/// a closure is a capture of a local variable.\n+pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n+pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n+\n+/// A `Place` and the corresponding `CaptureInfo`.\n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct CapturedPlace<'tcx> {\n+    pub place: HirPlace<'tcx>,\n+    pub info: CaptureInfo<'tcx>,\n+}\n+\n+/// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n+/// for a particular capture as well as identifying the part of the source code\n+/// that triggered this capture to occur.\n #[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n pub struct CaptureInfo<'tcx> {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n@@ -788,19 +813,9 @@ pub struct CaptureInfo<'tcx> {\n     pub capture_kind: UpvarCapture<'tcx>,\n }\n \n-#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct CapturedPlace<'tcx> {\n-    pub place: HirPlace<'tcx>,\n-    pub info: CaptureInfo<'tcx>,\n-}\n-\n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n-pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n-pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n-pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n-\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),"}, {"sha": "90e021ae592a592257663aa758a1cd01d2cefeef", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 104, "deletions": 72, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/43423f67a0f260c41181c5b2c1d25757f6b6babe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43423f67a0f260c41181c5b2c1d25757f6b6babe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=43423f67a0f260c41181c5b2c1d25757f6b6babe", "patch": "@@ -46,9 +46,9 @@ use rustc_span::{Span, Symbol};\n \n /// Describe the relationship between the paths of two places\n /// eg:\n-/// - foo is ancestor of foo.bar.baz\n-/// - foo.bar.baz is an descendant of foo.bar,\n-/// - foo.bar and foo.baz are divergent\n+/// - `foo` is ancestor of `foo.bar.baz`\n+/// - `foo.bar.baz` is an descendant of `foo.bar`\n+/// - `foo.bar` and `foo.baz` are divergent\n enum PlaceAncestryRelation {\n     Ancestor,\n     Descendant,\n@@ -124,7 +124,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let local_def_id = closure_def_id.expect_local();\n \n-        let mut capture_information = FxIndexMap::<Place<'tcx>, ty::CaptureInfo<'tcx>>::default();\n+        let mut capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>> =\n+            Default::default();\n         if !self.tcx.features().capture_disjoint_fields {\n             if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n                 for (&var_hir_id, _) in upvars.iter() {\n@@ -186,7 +187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.compute_min_captures(closure_def_id, delegate);\n         self.log_closure_min_capture_info(closure_def_id, span);\n \n-        self.set_closure_captures(closure_def_id);\n+        self.min_captures_to_closure_captures_bridge(closure_def_id);\n \n         // Now that we've analyzed the closure, we know how each\n         // variable is borrowed, and we know what traits the closure\n@@ -274,8 +275,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// 2. upvar_capture_map\n     /// UpvarId(foo,c) -> MutBorrow, UpvarId(bar, c) -> ByValue\n-\n-    fn set_closure_captures(&self, closure_def_id: DefId) {\n+    fn min_captures_to_closure_captures_bridge(&self, closure_def_id: DefId) {\n         let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> = Default::default();\n         let mut upvar_capture_map = ty::UpvarCaptureMap::default();\n \n@@ -304,8 +304,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // so we create a fake capture info with no expression.\n                         let fake_capture_info =\n                             ty::CaptureInfo { expr_id: None, capture_kind: capture_kind.clone() };\n-                        self.determine_capture_info(fake_capture_info, capture_info.clone())\n-                            .capture_kind\n+                        determine_capture_info(fake_capture_info, capture_info).capture_kind\n                     } else {\n                         capture_info.capture_kind\n                     };\n@@ -329,7 +328,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Analyses the information collected by InferBorrowKind to compute the min number of\n+    /// Analyzes the information collected by `InferBorrowKind` to compute the min number of\n     /// Places (and corresponding capture kind) that we need to keep track of to support all\n     /// the required captured paths.\n     ///\n@@ -420,8 +419,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // current place is ancestor of possible_descendant\n                     PlaceAncestryRelation::Ancestor => {\n                         descendant_found = true;\n-                        updated_capture_info = self\n-                            .determine_capture_info(updated_capture_info, possible_descendant.info);\n+                        updated_capture_info =\n+                            determine_capture_info(updated_capture_info, possible_descendant.info);\n                         false\n                     }\n \n@@ -437,7 +436,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         PlaceAncestryRelation::Descendant => {\n                             ancestor_found = true;\n                             possible_ancestor.info =\n-                                self.determine_capture_info(possible_ancestor.info, capture_info);\n+                                determine_capture_info(possible_ancestor.info, capture_info);\n \n                             // Only one ancestor of the current place will be in the list.\n                             break;\n@@ -500,60 +499,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.has_attr(closure_def_id, sym::rustc_capture_analysis)\n     }\n \n-    /// Helper function to determine if we need to escalate CaptureKind from\n-    /// CaptureInfo A to B and returns the escalated CaptureInfo.\n-    /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)\n-    ///\n-    /// If both `CaptureKind`s are considered equivalent, then the CaptureInfo is selected based\n-    /// on the `CaptureInfo` containing an associated expression id.\n-    ///\n-    /// If both the CaptureKind and Expression are considered to be equivalent,\n-    /// then `CaptureInfo` A is preferred.\n-    fn determine_capture_info(\n-        &self,\n-        capture_info_a: ty::CaptureInfo<'tcx>,\n-        capture_info_b: ty::CaptureInfo<'tcx>,\n-    ) -> ty::CaptureInfo<'tcx> {\n-        // If the capture kind is equivalent then, we don't need to escalate and can compare the\n-        // expressions.\n-        let eq_capture_kind = match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n-            (ty::UpvarCapture::ByValue(_), ty::UpvarCapture::ByValue(_)) => true,\n-            (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n-                ref_a.kind == ref_b.kind\n-            }\n-            _ => false,\n-        };\n-\n-        if eq_capture_kind {\n-            match (capture_info_a.expr_id, capture_info_b.expr_id) {\n-                (Some(_), _) | (None, None) => capture_info_a,\n-                (None, Some(_)) => capture_info_b,\n-            }\n-        } else {\n-            match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n-                (ty::UpvarCapture::ByValue(_), _) => capture_info_a,\n-                (_, ty::UpvarCapture::ByValue(_)) => capture_info_b,\n-                (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n-                    match (ref_a.kind, ref_b.kind) {\n-                        // Take LHS:\n-                        (ty::UniqueImmBorrow | ty::MutBorrow, ty::ImmBorrow)\n-                        | (ty::MutBorrow, ty::UniqueImmBorrow) => capture_info_a,\n-\n-                        // Take RHS:\n-                        (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n-                        | (ty::UniqueImmBorrow, ty::MutBorrow) => capture_info_b,\n-\n-                        (ty::ImmBorrow, ty::ImmBorrow)\n-                        | (ty::UniqueImmBorrow, ty::UniqueImmBorrow)\n-                        | (ty::MutBorrow, ty::MutBorrow) => {\n-                            bug!(\"Expected unequal capture kinds\");\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn log_closure_capture_info(\n         &self,\n         closure_def_id: rustc_hir::def_id::DefId,\n@@ -617,8 +562,9 @@ struct InferBorrowKind<'a, 'tcx> {\n     // variable access that caused us to do so.\n     current_origin: Option<(Span, Symbol)>,\n \n-    /// For each Place that we access, we track the minimal kind of\n+    /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n+    ///\n     /// Consider closure where s.str1 is captured via an ImmutableBorrow and\n     /// s.str2 via a MutableBorrow\n     ///\n@@ -686,7 +632,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         };\n \n         let curr_info = self.capture_information[&place_with_id.place];\n-        let updated_info = self.fcx.determine_capture_info(curr_info, capture_info);\n+        let updated_info = determine_capture_info(curr_info, capture_info);\n \n         self.capture_information[&place_with_id.place] = updated_info;\n     }\n@@ -804,7 +750,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                 expr_id: Some(diag_expr_id),\n                 capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n             };\n-            let updated_info = self.fcx.determine_capture_info(curr_capture_info, capture_info);\n+            let updated_info = determine_capture_info(curr_capture_info, capture_info);\n             self.capture_information[&place_with_id.place] = updated_info;\n         };\n     }\n@@ -859,14 +805,14 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n \n-            debug!(\"Capturing new place {:?}\", place_with_id);\n-\n             let capture_kind =\n                 self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n \n             let expr_id = Some(diag_expr_id);\n             let capture_info = ty::CaptureInfo { expr_id, capture_kind };\n \n+            debug!(\"Capturing new place {:?}, capture_info={:?}\", place_with_id, capture_info);\n+\n             self.capture_information.insert(place_with_id.place.clone(), capture_info);\n         } else {\n             debug!(\"Not upvar: {:?}\", place_with_id);\n@@ -964,6 +910,92 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n+/// Helper function to determine if we need to escalate CaptureKind from\n+/// CaptureInfo A to B and returns the escalated CaptureInfo.\n+/// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)\n+///\n+/// If both `CaptureKind`s are considered equivalent, then the CaptureInfo is selected based\n+/// on the `CaptureInfo` containing an associated expression id.\n+///\n+/// If both the CaptureKind and Expression are considered to be equivalent,\n+/// then `CaptureInfo` A is preferred. This can be useful in cases where we want to priortize\n+/// expressions reported back to the user as part of diagnostics based on which appears earlier\n+/// in the closure. This can be acheived simply by calling\n+/// `determine_capture_info(existing_info, current_info)`. This works out because the\n+/// expressions that occur earlier in the closure body than the current expression are processed before.\n+/// Consider the following example\n+/// ```rust\n+/// let mut p: Point { x: 10, y: 10 };\n+///\n+/// let c = || {\n+///     p.x     += 10;\n+/// // ^ E1 ^\n+///     // ...\n+///     // More code\n+///     // ...\n+///     p.x += 10; // E2\n+/// // ^ E2 ^\n+/// }\n+/// ```\n+/// `CaptureKind` associated with both `E1` and `E2` will be ByRef(MutBorrow),\n+/// and both have an expression associated, however for diagnostics we prfer reporting\n+/// `E1` since it appears earlier in the closure body. When `E2` is being processed we\n+/// would've already handled `E1`, and have an existing capture_information for it.\n+/// Calling `determine_capture_info(existing_info_e1, current_info_e2)` will return\n+/// `existing_info_e1` in this case, allowing us to point to `E1` in case of diagnostics.\n+fn determine_capture_info(\n+    capture_info_a: ty::CaptureInfo<'tcx>,\n+    capture_info_b: ty::CaptureInfo<'tcx>,\n+) -> ty::CaptureInfo<'tcx> {\n+    // If the capture kind is equivalent then, we don't need to escalate and can compare the\n+    // expressions.\n+    let eq_capture_kind = match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n+        (ty::UpvarCapture::ByValue(_), ty::UpvarCapture::ByValue(_)) => {\n+            // We don't need to worry about the spans being ignored here.\n+            //\n+            // The expr_id in capture_info corresponds to the span that is stored within\n+            // ByValue(span) and therefore it gets handled with priortizing based on\n+            // expressions below.\n+            true\n+        }\n+        (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n+            ref_a.kind == ref_b.kind\n+        }\n+        (ty::UpvarCapture::ByValue(_), _) | (ty::UpvarCapture::ByRef(_), _) => false,\n+    };\n+\n+    if eq_capture_kind {\n+        match (capture_info_a.expr_id, capture_info_b.expr_id) {\n+            (Some(_), _) | (None, None) => capture_info_a,\n+            (None, Some(_)) => capture_info_b,\n+        }\n+    } else {\n+        // We select the CaptureKind which ranks higher based the following priority order:\n+        // ByValue > MutBorrow > UniqueImmBorrow > ImmBorrow\n+        match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n+            (ty::UpvarCapture::ByValue(_), _) => capture_info_a,\n+            (_, ty::UpvarCapture::ByValue(_)) => capture_info_b,\n+            (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n+                match (ref_a.kind, ref_b.kind) {\n+                    // Take LHS:\n+                    (ty::UniqueImmBorrow | ty::MutBorrow, ty::ImmBorrow)\n+                    | (ty::MutBorrow, ty::UniqueImmBorrow) => capture_info_a,\n+\n+                    // Take RHS:\n+                    (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n+                    | (ty::UniqueImmBorrow, ty::MutBorrow) => capture_info_b,\n+\n+                    (ty::ImmBorrow, ty::ImmBorrow)\n+                    | (ty::UniqueImmBorrow, ty::UniqueImmBorrow)\n+                    | (ty::MutBorrow, ty::MutBorrow) => {\n+                        bug!(\"Expected unequal capture kinds\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Determines the Ancestry relationship of Place A relative to Place B\n ///\n /// `PlaceAncestryRelation::Ancestor` implies Place A is ancestor of Place B"}]}