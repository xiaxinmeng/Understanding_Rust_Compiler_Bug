{"sha": "9348700007c6ac913df97c8e9e1ab7df6f91f130", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNDg3MDAwMDdjNmFjOTEzZGY5N2M4ZTllMWFiN2RmNmY5MWYxMzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-16T06:21:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-28T00:16:44Z"}, "message": "std: Expand the area of std::fs\n\nThis commit is an implementation of [RFC 1044][rfc] which adds additional\nsurface area to the `std::fs` module. All new APIs are `#[unstable]` behind\nassorted feature names for each one.\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/1044\n\nThe new APIs added are:\n\n* `fs::canonicalize` - bindings to `realpath` on unix and\n  `GetFinalPathNameByHandle` on windows.\n* `fs::symlink_metadata` - similar to `lstat` on unix\n* `fs::FileType` and accessor methods as `is_{file,dir,symlink}`\n* `fs::Metadata::file_type` - accessor for the raw file type\n* `fs::DirEntry::metadata` - acquisition of metadata which is free on Windows\n  but requires a syscall on unix.\n* `fs::DirEntry::file_type` - access the file type which may not require a\n  syscall on most platforms.\n* `fs::DirEntry::file_name` - access just the file name without leading\n  components.\n* `fs::PathExt::symlink_metadata` - convenience method for the top-level\n  function.\n* `fs::PathExt::canonicalize` - convenience method for the top-level\n  function.\n* `fs::PathExt::read_link` - convenience method for the top-level\n  function.\n* `fs::PathExt::read_dir` - convenience method for the top-level\n  function.\n* `std::os::raw` - type definitions for raw OS/C types available on all\n  platforms.\n* `std::os::$platform` - new modules have been added for all currently supported\n  platforms (e.g. those more specific than just `unix`).\n* `std::os::$platform::raw` - platform-specific type definitions. These modules\n  are populated with the bare essentials necessary for lowing I/O types into\n  their raw representations, and currently largely consist of the `stat`\n  definition for unix platforms.\n\nThis commit also deprecates `Metadata::{modified, accessed}` in favor of\ninspecting the raw representations via the lowering methods of `Metadata`.", "tree": {"sha": "a69d87dfe3b7e1e8c7cd9f7f48fdabdb1436c308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a69d87dfe3b7e1e8c7cd9f7f48fdabdb1436c308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9348700007c6ac913df97c8e9e1ab7df6f91f130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9348700007c6ac913df97c8e9e1ab7df6f91f130", "html_url": "https://github.com/rust-lang/rust/commit/9348700007c6ac913df97c8e9e1ab7df6f91f130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9348700007c6ac913df97c8e9e1ab7df6f91f130/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b772ce6342962792620e21623997d0d3b98164b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b772ce6342962792620e21623997d0d3b98164b7", "html_url": "https://github.com/rust-lang/rust/commit/b772ce6342962792620e21623997d0d3b98164b7"}], "stats": {"total": 3318, "additions": 2404, "deletions": 914}, "files": [{"sha": "6e8f515c7c2117474b27030295154f625aedfa29", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -40,6 +40,7 @@\n #![feature(path_ext)]\n #![feature(str_char)]\n #![feature(into_cow)]\n+#![feature(fs_canonicalize)]\n #![feature(slice_patterns)]\n #![cfg_attr(test, feature(test))]\n \n@@ -139,7 +140,6 @@ pub mod plugin;\n pub mod lint;\n \n pub mod util {\n-    pub use rustc_back::fs;\n     pub use rustc_back::sha2;\n \n     pub mod common;"}, {"sha": "099a280c4b146b31fb05d41ba48871f7ef6ea946", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -21,8 +21,10 @@ use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n \n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::rc::Rc;\n+use std::fs;\n+\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n@@ -32,7 +34,6 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit;\n-use util::fs;\n use log;\n \n pub struct CrateReader<'a> {\n@@ -322,7 +323,7 @@ impl<'a> CrateReader<'a> {\n             let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n             if let Some(locs) = self.sess.opts.externs.get(name) {\n                 let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(&l[..])).ok();\n+                    let l = fs::canonicalize(l).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n                     source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n                 });"}, {"sha": "7d8cf5b22a9016c6b9dec3ff8a61b147a6ee6ca5", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -18,7 +18,6 @@ use std::fs;\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n \n-use util::fs as myfs;\n use session::search_paths::{SearchPaths, PathKind};\n \n #[derive(Copy, Clone)]\n@@ -191,7 +190,7 @@ pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n         path.and_then(|path| {\n-            match myfs::realpath(&path) {\n+            match fs::canonicalize(&path) {\n                 Ok(canon) => Some(canon),\n                 Err(e) => panic!(\"failed to get realpath: {}\", e),\n             }"}, {"sha": "062a156637a358d1af5b286c08aad6791f02281f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -225,12 +225,12 @@ use metadata::encoder;\n use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n-use util::fs;\n use util::common;\n use rustc_back::target::Target;\n \n use std::cmp;\n use std::collections::HashMap;\n+use std::fs;\n use std::io::prelude::*;\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -430,9 +430,9 @@ impl<'a> Context<'a> {\n                                  .or_insert_with(|| (HashMap::new(), HashMap::new()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {\n-                rlibs.insert(fs::realpath(path).unwrap(), kind);\n+                rlibs.insert(fs::canonicalize(path).unwrap(), kind);\n             } else {\n-                dylibs.insert(fs::realpath(path).unwrap(), kind);\n+                dylibs.insert(fs::canonicalize(path).unwrap(), kind);\n             }\n \n             FileMatches\n@@ -660,10 +660,10 @@ impl<'a> Context<'a> {\n             // there's at most one rlib and at most one dylib.\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::realpath(&loc).unwrap(),\n+                    rlibs.insert(fs::canonicalize(&loc).unwrap(),\n                                  PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::realpath(&loc).unwrap(),\n+                    dylibs.insert(fs::canonicalize(&loc).unwrap(),\n                                   PathKind::ExternFlag);\n                 }\n             }"}, {"sha": "37e3efb4d83fe112a39c11be151adffb76fdb93a", "filename": "src/librustc_back/fs.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b772ce6342962792620e21623997d0d3b98164b7/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b772ce6342962792620e21623997d0d3b98164b7/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=b772ce6342962792620e21623997d0d3b98164b7", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io;\n-use std::path::{Path, PathBuf};\n-\n-#[cfg(windows)]\n-pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n-    Ok(original.to_path_buf())\n-}\n-\n-#[cfg(unix)]\n-pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n-    use libc;\n-    use std::ffi::{OsString, CString};\n-    use std::os::unix::prelude::*;\n-\n-    extern {\n-        fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n-                    -> *mut libc::c_char;\n-    }\n-\n-    let path = try!(CString::new(original.as_os_str().as_bytes()));\n-    let mut buf = vec![0u8; 16 * 1024];\n-    unsafe {\n-        let r = realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n-        if r.is_null() {\n-            return Err(io::Error::last_os_error())\n-        }\n-    }\n-    let p = buf.iter().position(|i| *i == 0).unwrap();\n-    buf.truncate(p);\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n-}\n-\n-#[cfg(all(not(windows), test))]\n-mod tests {\n-    use tempdir::TempDir;\n-    use std::fs::{self, File};\n-    use super::realpath;\n-\n-    #[test]\n-    fn realpath_works() {\n-        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n-        let tmpdir = realpath(tmpdir.path()).unwrap();\n-        let file = tmpdir.join(\"test\");\n-        let dir = tmpdir.join(\"test2\");\n-        let link = dir.join(\"link\");\n-        let linkdir = tmpdir.join(\"test3\");\n-\n-        File::create(&file).unwrap();\n-        fs::create_dir(&dir).unwrap();\n-        fs::soft_link(&file, &link).unwrap();\n-        fs::soft_link(&dir, &linkdir).unwrap();\n-\n-        assert_eq!(realpath(&tmpdir).unwrap(), tmpdir);\n-        assert_eq!(realpath(&file).unwrap(), file);\n-        assert_eq!(realpath(&link).unwrap(), file);\n-        assert_eq!(realpath(&linkdir).unwrap(), dir);\n-        assert_eq!(realpath(&linkdir.join(\"link\")).unwrap(), file);\n-    }\n-\n-    #[test]\n-    fn realpath_works_tricky() {\n-        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n-        let tmpdir = realpath(tmpdir.path()).unwrap();\n-\n-        let a = tmpdir.join(\"a\");\n-        let b = a.join(\"b\");\n-        let c = b.join(\"c\");\n-        let d = a.join(\"d\");\n-        let e = d.join(\"e\");\n-        let f = a.join(\"f\");\n-\n-        fs::create_dir_all(&b).unwrap();\n-        fs::create_dir_all(&d).unwrap();\n-        File::create(&f).unwrap();\n-        fs::soft_link(\"../d/e\", &c).unwrap();\n-        fs::soft_link(\"../f\", &e).unwrap();\n-\n-        assert_eq!(realpath(&c).unwrap(), f);\n-        assert_eq!(realpath(&e).unwrap(), f);\n-    }\n-}"}, {"sha": "3e55f7f8045b59b60ee38723f34655e43f987924", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -41,6 +41,7 @@\n #![feature(path_ext)]\n #![feature(step_by)]\n #![feature(libc)]\n+#![feature(fs_canonicalize)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;\n@@ -53,7 +54,6 @@ pub mod abi;\n pub mod archive;\n pub mod tempdir;\n pub mod arm;\n-pub mod fs;\n pub mod mips;\n pub mod mipsel;\n pub mod rpath;"}, {"sha": "6674d3135a0bdb671dbd621a1979dd97df196fca", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -10,8 +10,8 @@\n \n use std::collections::HashSet;\n use std::env;\n-use std::io;\n use std::path::{Path, PathBuf};\n+use std::fs;\n use syntax::ast;\n \n pub struct RPathConfig<'a> {\n@@ -20,7 +20,6 @@ pub struct RPathConfig<'a> {\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n     pub get_install_prefix_lib_path: &'a mut FnMut() -> PathBuf,\n-    pub realpath: &'a mut FnMut(&Path) -> io::Result<PathBuf>,\n }\n \n pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n@@ -95,11 +94,11 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     };\n \n     let cwd = env::current_dir().unwrap();\n-    let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n+    let mut lib = fs::canonicalize(&cwd.join(lib)).unwrap_or(cwd.join(lib));\n     lib.pop();\n     let mut output = cwd.join(&config.out_filename);\n     output.pop();\n-    let output = (config.realpath)(&output).unwrap();\n+    let output = fs::canonicalize(&output).unwrap_or(output);\n     let relative = path_relative_from(&lib, &output)\n         .expect(&format!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -231,7 +230,6 @@ mod tests {\n                 is_like_osx: true,\n                 out_filename: PathBuf::from(\"bin/rustc\"),\n                 get_install_prefix_lib_path: &mut || panic!(),\n-                realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n             let res = get_rpath_relative_to_output(config,\n                                                    Path::new(\"lib/libstd.so\"));\n@@ -243,7 +241,6 @@ mod tests {\n                 get_install_prefix_lib_path: &mut || panic!(),\n                 has_rpath: true,\n                 is_like_osx: false,\n-                realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n             let res = get_rpath_relative_to_output(config,\n                                                    Path::new(\"lib/libstd.so\"));"}, {"sha": "bc26495b76be492f9ce2a52e23824e7a7ea7700e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -32,7 +32,7 @@ use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::{self, Path, PathBuf};\n use std::process::Command;\n use std::str;\n use flate;\n@@ -916,8 +916,9 @@ fn link_args(cmd: &mut Command,\n         // stripped away as much as it could. This has not been seen to impact\n         // link times negatively.\n         //\n-        // -dead_strip can't be part of the pre_link_args because it's also used for partial\n-        // linking when using multiple codegen units (-r). So we insert it here.\n+        // -dead_strip can't be part of the pre_link_args because it's also used\n+        // for partial linking when using multiple codegen units (-r). So we\n+        // insert it here.\n         cmd.arg(\"-Wl,-dead_strip\");\n     }\n \n@@ -1043,7 +1044,6 @@ fn link_args(cmd: &mut Command,\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n             get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n-            realpath: &mut ::util::fs::realpath\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n@@ -1258,7 +1258,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 }\n             });\n         } else {\n-            cmd.arg(cratepath);\n+            cmd.arg(&fix_windows_verbatim_for_gcc(cratepath));\n         }\n     }\n \n@@ -1271,7 +1271,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // Just need to tell the linker about where the library lives and\n         // what its name is\n         if let Some(dir) = cratepath.parent() {\n-            cmd.arg(\"-L\").arg(dir);\n+            cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(dir));\n         }\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n         cmd.arg(&format!(\"-l{}\", unlib(&sess.target, filestem)));\n@@ -1325,3 +1325,29 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n         }\n     }\n }\n+\n+// Unfortunately, on windows, gcc cannot accept paths of the form `\\\\?\\C:\\...`\n+// (a verbatim path). This form of path is generally pretty rare, but the\n+// implementation of `fs::canonicalize` currently generates paths of this form,\n+// meaning that we're going to be passing quite a few of these down to gcc.\n+//\n+// For now we just strip the \"verbatim prefix\" of `\\\\?\\` from the path. This\n+// will probably lose information in some cases, but there's not a whole lot\n+// more we can do with a buggy gcc...\n+fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n+    if !cfg!(windows) {\n+        return p.to_path_buf()\n+    }\n+    let mut components = p.components();\n+    let prefix = match components.next() {\n+        Some(path::Component::Prefix(p)) => p,\n+        _ => return p.to_path_buf(),\n+    };\n+    let disk = match prefix.kind() {\n+        path::Prefix::VerbatimDisk(disk) => disk,\n+        _ => return p.to_path_buf(),\n+    };\n+    let mut base = OsString::from(format!(\"{}:\", disk as char));\n+    base.push(components.as_path());\n+    PathBuf::from(base)\n+}"}, {"sha": "b47c0c696bffa08f83d3ea50f3081d41474ce396", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 218, "deletions": 14, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -20,6 +20,7 @@\n use core::prelude::*;\n \n use fmt;\n+use ffi::OsString;\n use io::{self, Error, ErrorKind, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n use sys::fs2 as fs_imp;\n@@ -146,6 +147,11 @@ pub struct OpenOptions(fs_imp::OpenOptions);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Permissions(fs_imp::FilePermissions);\n \n+/// An structure representing a type of file with accessors for each file type.\n+#[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct FileType(fs_imp::FileType);\n+\n impl File {\n     /// Attempts to open a file in read-only mode.\n     ///\n@@ -485,6 +491,12 @@ impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n }\n \n impl Metadata {\n+    /// Returns the file type for this metadata.\n+    #[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+    pub fn file_type(&self) -> FileType {\n+        FileType(self.0.file_type())\n+    }\n+\n     /// Returns whether this metadata is for a directory.\n     ///\n     /// # Examples\n@@ -500,7 +512,7 @@ impl Metadata {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+    pub fn is_dir(&self) -> bool { self.file_type().is_dir() }\n \n     /// Returns whether this metadata is for a regular file.\n     ///\n@@ -517,7 +529,7 @@ impl Metadata {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_file(&self) -> bool { self.0.is_file() }\n+    pub fn is_file(&self) -> bool { self.file_type().is_file() }\n \n     /// Returns the size of the file, in bytes, this metadata is for.\n     ///\n@@ -562,7 +574,11 @@ impl Metadata {\n                reason = \"the return type of u64 is not quite appropriate for \\\n                          this method and may change if the standard library \\\n                          gains a type to represent a moment in time\")]\n-    pub fn accessed(&self) -> u64 { self.0.accessed() }\n+    #[deprecated(since = \"1.1.0\",\n+                 reason = \"use os::platform::fs::MetadataExt extension traits\")]\n+    pub fn accessed(&self) -> u64 {\n+        self.adjust_time(self.0.accessed())\n+    }\n \n     /// Returns the most recent modification time for a file.\n     ///\n@@ -571,7 +587,21 @@ impl Metadata {\n                reason = \"the return type of u64 is not quite appropriate for \\\n                          this method and may change if the standard library \\\n                          gains a type to represent a moment in time\")]\n-    pub fn modified(&self) -> u64 { self.0.modified() }\n+    #[deprecated(since = \"1.1.0\",\n+                 reason = \"use os::platform::fs::MetadataExt extension traits\")]\n+    pub fn modified(&self) -> u64 {\n+        self.adjust_time(self.0.modified())\n+    }\n+\n+    fn adjust_time(&self, val: u64) -> u64 {\n+        // FILETIME (what `val` represents) is in 100ns intervals and there are\n+        // 10000 intervals in a millisecond.\n+        if cfg!(windows) {val / 10000} else {val}\n+    }\n+}\n+\n+impl AsInner<fs_imp::FileAttr> for Metadata {\n+    fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }\n }\n \n impl Permissions {\n@@ -624,6 +654,18 @@ impl Permissions {\n     }\n }\n \n+#[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+impl FileType {\n+    /// Test whether this file type represents a directory.\n+    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+\n+    /// Test whether this file type represents a regular file.\n+    pub fn is_file(&self) -> bool { self.0.is_file() }\n+\n+    /// Test whether this file type represents a symbolic link.\n+    pub fn is_symlink(&self) -> bool { self.0.is_symlink() }\n+}\n+\n impl FromInner<fs_imp::FilePermissions> for Permissions {\n     fn from_inner(f: fs_imp::FilePermissions) -> Permissions {\n         Permissions(f)\n@@ -674,6 +716,47 @@ impl DirEntry {\n     /// The exact text, of course, depends on what files you have in `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn path(&self) -> PathBuf { self.0.path() }\n+\n+    /// Return the metadata for the file that this entry points at.\n+    ///\n+    /// This function will not traverse symlinks if this entry points at a\n+    /// symlink.\n+    ///\n+    /// # Platform behavior\n+    ///\n+    /// On Windows this function is cheap to call (no extra system calls\n+    /// needed), but on Unix platforms this function is the equivalent of\n+    /// calling `symlink_metadata` on the path.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn metadata(&self) -> io::Result<Metadata> {\n+        self.0.metadata().map(Metadata)\n+    }\n+\n+    /// Return the file type for the file that this entry points at.\n+    ///\n+    /// This function will not traverse symlinks if this entry points at a\n+    /// symlink.\n+    ///\n+    /// # Platform behavior\n+    ///\n+    /// On Windows and most Unix platforms this function is free (no extra\n+    /// system calls needed), but some Unix platforms may require the equivalent\n+    /// call to `symlink_metadata` to learn about the target file type.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        self.0.file_type().map(FileType)\n+    }\n+\n+    /// Returns the bare file name of this directory entry without any other\n+    /// leading path component.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn file_name(&self) -> OsString {\n+        self.0.file_name()\n+    }\n+}\n+\n+impl AsInner<fs_imp::DirEntry> for DirEntry {\n+    fn as_inner(&self) -> &fs_imp::DirEntry { &self.0 }\n }\n \n /// Removes a file from the underlying filesystem.\n@@ -731,6 +814,25 @@ pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n     fs_imp::stat(path.as_ref()).map(Metadata)\n }\n \n+/// Query the metadata about a file without following symlinks.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// #![feature(symlink_metadata)]\n+/// # fn foo() -> std::io::Result<()> {\n+/// use std::fs;\n+///\n+/// let attr = try!(fs::symlink_metadata(\"/some/file/path.txt\"));\n+/// // inspect attr ...\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"symlink_metadata\", reason = \"recently added API\")]\n+pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n+    fs_imp::lstat(path.as_ref()).map(Metadata)\n+}\n+\n /// Rename a file or directory to a new name.\n ///\n /// # Errors\n@@ -869,6 +971,13 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n     fs_imp::readlink(path.as_ref())\n }\n \n+/// Returns the canonical form of a path with all intermediate components\n+/// normalized and symbolic links resolved.\n+#[unstable(feature = \"fs_canonicalize\", reason = \"recently added API\")]\n+pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    fs_imp::canonicalize(path.as_ref())\n+}\n+\n /// Creates a new, empty directory at the provided path\n ///\n /// # Errors\n@@ -966,19 +1075,14 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     let path = path.as_ref();\n     for child in try!(read_dir(path)) {\n         let child = try!(child).path();\n-        let stat = try!(lstat(&*child));\n+        let stat = try!(symlink_metadata(&*child));\n         if stat.is_dir() {\n             try!(remove_dir_all(&*child));\n         } else {\n             try!(remove_file(&*child));\n         }\n     }\n-    return remove_dir(path);\n-\n-    #[cfg(unix)]\n-    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::lstat(path) }\n-    #[cfg(windows)]\n-    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::stat(path) }\n+    remove_dir(path)\n }\n \n /// Returns an iterator over the entries within a directory.\n@@ -1073,11 +1177,37 @@ impl Iterator for WalkDir {\n pub trait PathExt {\n     /// Gets information on the file, directory, etc at this path.\n     ///\n-    /// Consult the `fs::stat` documentation for more info.\n+    /// Consult the `fs::metadata` documentation for more info.\n     ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`.\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::metadata`.\n     fn metadata(&self) -> io::Result<Metadata>;\n \n+    /// Gets information on the file, directory, etc at this path.\n+    ///\n+    /// Consult the `fs::symlink_metadata` documentation for more info.\n+    ///\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::symlink_metadata`.\n+    fn symlink_metadata(&self) -> io::Result<Metadata>;\n+\n+    /// Returns the canonical form of a path, normalizing all components and\n+    /// eliminate all symlinks.\n+    ///\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::canonicalize`.\n+    fn canonicalize(&self) -> io::Result<PathBuf>;\n+\n+    /// Reads the symlink at this path.\n+    ///\n+    /// For more information see `fs::read_link`.\n+    fn read_link(&self) -> io::Result<PathBuf>;\n+\n+    /// Reads the directory at this path.\n+    ///\n+    /// For more information see `fs::read_dir`.\n+    fn read_dir(&self) -> io::Result<ReadDir>;\n+\n     /// Boolean value indicator whether the underlying file exists on the local\n     /// filesystem. Returns false in exactly the cases where `fs::stat` fails.\n     fn exists(&self) -> bool;\n@@ -1098,12 +1228,16 @@ pub trait PathExt {\n \n impl PathExt for Path {\n     fn metadata(&self) -> io::Result<Metadata> { metadata(self) }\n-\n+    fn symlink_metadata(&self) -> io::Result<Metadata> { symlink_metadata(self) }\n+    fn canonicalize(&self) -> io::Result<PathBuf> { canonicalize(self) }\n+    fn read_link(&self) -> io::Result<PathBuf> { read_link(self) }\n+    fn read_dir(&self) -> io::Result<ReadDir> { read_dir(self) }\n     fn exists(&self) -> bool { metadata(self).is_ok() }\n \n     fn is_file(&self) -> bool {\n         metadata(self).map(|s| s.is_file()).unwrap_or(false)\n     }\n+\n     fn is_dir(&self) -> bool {\n         metadata(self).map(|s| s.is_dir()).unwrap_or(false)\n     }\n@@ -1924,4 +2058,74 @@ mod tests {\n         let path = tmpdir.join(\"file\");\n         check!(fs::create_dir_all(&path.join(\"a/\")));\n     }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn realpath_works() {\n+        let tmpdir = tmpdir();\n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+        let file = tmpdir.join(\"test\");\n+        let dir = tmpdir.join(\"test2\");\n+        let link = dir.join(\"link\");\n+        let linkdir = tmpdir.join(\"test3\");\n+\n+        File::create(&file).unwrap();\n+        fs::create_dir(&dir).unwrap();\n+        fs::soft_link(&file, &link).unwrap();\n+        fs::soft_link(&dir, &linkdir).unwrap();\n+\n+        assert!(link.symlink_metadata().unwrap().file_type().is_symlink());\n+\n+        assert_eq!(fs::canonicalize(&tmpdir).unwrap(), tmpdir);\n+        assert_eq!(fs::canonicalize(&file).unwrap(), file);\n+        assert_eq!(fs::canonicalize(&link).unwrap(), file);\n+        assert_eq!(fs::canonicalize(&linkdir).unwrap(), dir);\n+        assert_eq!(fs::canonicalize(&linkdir.join(\"link\")).unwrap(), file);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn realpath_works_tricky() {\n+        let tmpdir = tmpdir();\n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+\n+        let a = tmpdir.join(\"a\");\n+        let b = a.join(\"b\");\n+        let c = b.join(\"c\");\n+        let d = a.join(\"d\");\n+        let e = d.join(\"e\");\n+        let f = a.join(\"f\");\n+\n+        fs::create_dir_all(&b).unwrap();\n+        fs::create_dir_all(&d).unwrap();\n+        File::create(&f).unwrap();\n+        fs::soft_link(\"../d/e\", &c).unwrap();\n+        fs::soft_link(\"../f\", &e).unwrap();\n+\n+        assert_eq!(fs::canonicalize(&c).unwrap(), f);\n+        assert_eq!(fs::canonicalize(&e).unwrap(), f);\n+    }\n+\n+    #[test]\n+    fn dir_entry_methods() {\n+        let tmpdir = tmpdir();\n+\n+        fs::create_dir_all(&tmpdir.join(\"a\")).unwrap();\n+        File::create(&tmpdir.join(\"b\")).unwrap();\n+\n+        for file in tmpdir.path().read_dir().unwrap().map(|f| f.unwrap()) {\n+            let fname = file.file_name();\n+            match fname.to_str() {\n+                Some(\"a\") => {\n+                    assert!(file.file_type().unwrap().is_dir());\n+                    assert!(file.metadata().unwrap().is_dir());\n+                }\n+                Some(\"b\") => {\n+                    assert!(file.file_type().unwrap().is_file());\n+                    assert!(file.metadata().unwrap().is_file());\n+                }\n+                f => panic!(\"unknown file name: {:?}\", f),\n+            }\n+        }\n+    }\n }"}, {"sha": "346a903c4d9a9b7f99581553a769ed64a7805fb7", "filename": "src/libstd/os/android/mod.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! OS-specific functionality\n+//! Android-specific definitions\n \n-#![stable(feature = \"os\", since = \"1.0.0\")]\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n \n-#[cfg(unix)] pub use sys::ext as unix;\n-#[cfg(windows)] pub use sys::ext as windows;\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}", "previous_filename": "src/libstd/os.rs"}, {"sha": "538ed7c4688c77f12a58ce6b85a9002fd9b14399", "filename": "src/libstd/os/android/raw.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Android-specific raw type definitions\n+\n+use os::raw::{c_uint, c_uchar, c_ulonglong, c_longlong, c_ulong};\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = u32;\n+pub type blksize_t = u32;\n+pub type dev_t = u32;\n+pub type ino_t = u32;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i32;\n+pub type time_t = i32;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: c_ulonglong,\n+    pub __pad0: [c_uchar; 4],\n+    pub __st_ino: ino_t,\n+    pub st_mode: c_uint,\n+    pub st_nlink: c_uint,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: c_ulonglong,\n+    pub __pad3: [c_uchar; 4],\n+    pub st_size: c_longlong,\n+    pub st_blksize: blksize_t,\n+    pub st_blocks: c_ulonglong,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_ulong,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_ulong,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_ulong,\n+    pub st_ino: c_ulonglong,\n+}"}, {"sha": "01ea542b3b71379dea8691638c32c7e1c960b793", "filename": "src/libstd/os/bitrig/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bitrig-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "aebc21aa71856c701a04fa38f4a4ead6cd30a05c", "filename": "src/libstd/os/bitrig/raw.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bitrig-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = i32;\n+pub type fflags_t = u32; // type not declared, but struct stat have u_int32_t\n+pub type ino_t = u64;\n+pub type mode_t = u32;\n+pub type nlink_t = u32;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_mode: mode_t,\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+}"}, {"sha": "677f8b706cdbddd120c6542115f463802fb0d690", "filename": "src/libstd/os/dragonfly/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Dragonfly-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "22c811ead43351518600ed9942d919c2a055b66e", "filename": "src/libstd/os/dragonfly/raw.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Dragonfly-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{pid_t, uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = u32;\n+pub type fflags_t = u32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_padding1: u16,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: uint32_t,\n+    pub st_lspare: int32_t,\n+    pub st_qspare1: int64_t,\n+    pub st_qspare2: int64_t,\n+}"}, {"sha": "73b6fd211371cb21415f42c57f7c4e24f233c7d8", "filename": "src/libstd/os/freebsd/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! FreeBSD-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "a810eff45d32e27fb47d8e6496a7b604625c1e68", "filename": "src/libstd/os/freebsd/raw.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! FreeBSD-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i64;\n+pub type dev_t = u32;\n+pub type fflags_t = u32;\n+pub type ino_t = u32;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub __unused: [u8; 2],\n+}"}, {"sha": "d471cf12fe63e7d60b5c8b1739a8ec401d1fe9e0", "filename": "src/libstd/os/ios/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! iOS-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "3266b3846d899aa3d957c75aa684f789cf3d3190", "filename": "src/libstd/os/ios/raw.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! iOS-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i32;\n+pub type dev_t = i32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = c_long;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_ino: ino_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: u32,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_qspare: [i64; 2],\n+}"}, {"sha": "43376a1baeb928c214051ea21ec2ead98b90d308", "filename": "src/libstd/os/linux/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Linux-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "adce5f22ebc10b919e9c87b297f191c20a98ebb4", "filename": "src/libstd/os/linux/raw.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Linux-specific raw type definitions\n+\n+pub type dev_t = u64;\n+pub type mode_t = u32;\n+\n+#[doc(inline)]\n+pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+\n+#[cfg(any(target_arch = \"x86\",\n+          target_arch = \"le32\",\n+          target_arch = \"powerpc\",\n+          target_arch = \"arm\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_short};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub __pad1: c_short,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad2: c_short,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused4: c_long,\n+        pub __unused5: c_long,\n+    }\n+}\n+\n+#[cfg(any(target_arch = \"mips\",\n+          target_arch = \"mipsel\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::c_long;\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: c_ulong,\n+        pub st_pad1: [c_long; 3],\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: c_ulong,\n+        pub st_pad2: [c_long; 2],\n+        pub st_size: off_t,\n+        pub st_pad3: c_long,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_pad5: [c_long; 14],\n+    }\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u32;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad1: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub __pad2: c_int,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i64;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u64;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_nlink: nlink_t,\n+        pub st_mode: mode_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub __pad0: c_int,\n+        pub st_rdev: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_long; 3],\n+    }\n+}"}, {"sha": "bc5ff5b25d2fa1d77bfa16d1090e674971e6feea", "filename": "src/libstd/os/macos/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MacOS-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "03fcb768c119aabafc1ad0c6da5c596666ac8478", "filename": "src/libstd/os/macos/raw.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MacOS-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i32;\n+pub type dev_t = i32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = c_long;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_ino: ino_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: u32,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_qspare: [i64; 2],\n+}"}, {"sha": "cc4b1c944e7861124462ef7c53e4239fe1c2b302", "filename": "src/libstd/os/mod.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OS-specific functionality\n+\n+#![stable(feature = \"os\", since = \"1.0.0\")]\n+#![allow(missing_docs, bad_style)]\n+\n+#[cfg(unix)]    pub use sys::ext as unix;\n+#[cfg(windows)] pub use sys::ext as windows;\n+\n+#[cfg(target_os = \"android\")]   pub mod android;\n+#[cfg(target_os = \"bitrig\")]    pub mod bitrig;\n+#[cfg(target_os = \"dragonfly\")] pub mod dragonfly;\n+#[cfg(target_os = \"freebsd\")]   pub mod freebsd;\n+#[cfg(target_os = \"ios\")]       pub mod ios;\n+#[cfg(target_os = \"linux\")]     pub mod linux;\n+#[cfg(target_os = \"macos\")]     pub mod macos;\n+#[cfg(target_os = \"nacl\")]      pub mod nacl;\n+#[cfg(target_os = \"openbsd\")]   pub mod openbsd;\n+\n+pub mod raw;"}, {"sha": "6baed03951467ac4e447b6089e74c82314bb364b", "filename": "src/libstd/os/nacl/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Nacl-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "9defa8301ea3428fba09198597482b0403563eff", "filename": "src/libstd/os/nacl/raw.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Nacl-specific raw type definitions\n+\n+pub type dev_t = u64;\n+pub type mode_t = u32;\n+\n+pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+\n+#[cfg(any(target_arch = \"x86\",\n+          target_arch = \"le32\",\n+          target_arch = \"powerpc\",\n+          target_arch = \"arm\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_short};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub __pad1: c_short,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad2: c_short,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused4: c_long,\n+        pub __unused5: c_long,\n+    }\n+}\n+\n+#[cfg(any(target_arch = \"mips\",\n+          target_arch = \"mipsel\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::c_long;\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: c_ulong,\n+        pub st_pad1: [c_long; 3],\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: c_ulong,\n+        pub st_pad2: [c_long; 2],\n+        pub st_size: off_t,\n+        pub st_pad3: c_long,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_pad5: [c_long; 14],\n+    }\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u32;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad1: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub __pad2: c_int,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i64;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u64;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_nlink: nlink_t,\n+        pub st_mode: mode_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub __pad0: c_int,\n+        pub st_rdev: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_long; 3],\n+    }\n+}"}, {"sha": "1b1a10055902bce06fbfde23b94ae3636a91b03e", "filename": "src/libstd/os/openbsd/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OpenBSD-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "632a8c336b78dc869d952437c0beab67bf083272", "filename": "src/libstd/os/openbsd/raw.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OpenBSD-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = i32;\n+pub type fflags_t = u32; // type not declared, but struct stat have u_int32_t\n+pub type ino_t = u64;\n+pub type mode_t = u32;\n+pub type nlink_t = u32;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_mode: mode_t,\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+}"}, {"sha": "44f4a1c828b54e864189b292a0bef2a6508757f6", "filename": "src/libstd/os/raw.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Raw OS-specific types for the current platform/architecture\n+\n+#![unstable(feature = \"raw_os\", reason = \"recently added API\")]\n+\n+#[cfg(target_arch = \"aarch64\")]      pub type c_char = u8;\n+#[cfg(not(target_arch = \"aarch64\"))] pub type c_char = i8;\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] pub type c_long = i32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] pub type c_ulong = u32;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] pub type c_long = i64;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] pub type c_ulong = u64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+\n+/// Type used to construct void pointers for use with C.\n+///\n+/// This type is only useful as a pointer target. Do not use it as a\n+/// return type for FFI functions which have the `void` return type in\n+/// C. Use the unit type `()` or omit the return type instead.\n+// NB: For LLVM to recognize the void pointer type and by extension\n+//     functions like malloc(), we need to have it represented as i8* in\n+//     LLVM bitcode. The enum used here ensures this and prevents misuse\n+//     of the \"raw\" type by only having private variants.. We need two\n+//     variants, because the compiler complains about the repr attribute\n+//     otherwise.\n+#[repr(u8)]\n+pub enum c_void {\n+    #[doc(hidden)] __variant1,\n+    #[doc(hidden)] __variant2,\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use any::TypeId;\n+    use libc;\n+    use mem;\n+\n+    macro_rules! ok {\n+        ($($t:ident)*) => {$(\n+            assert!(TypeId::of::<libc::$t>() == TypeId::of::<raw::$t>(),\n+                    \"{} is wrong\", stringify!($t));\n+        )*}\n+    }\n+\n+    macro_rules! ok_size {\n+        ($($t:ident)*) => {$(\n+            assert!(mem::size_of::<libc::$t>() == mem::size_of::<raw::$t>(),\n+                    \"{} is wrong\", stringify!($t));\n+        )*}\n+    }\n+\n+    #[test]\n+    fn same() {\n+        use os::raw;\n+        ok!(c_char c_schar c_uchar c_short c_ushort c_int c_uint c_long c_ulong\n+            c_longlong c_ulonglong c_float c_double);\n+    }\n+\n+    #[cfg(unix)]\n+    fn unix() {\n+        {\n+            use os::unix::raw;\n+            ok!(uid_t gid_t dev_t ino_t mode_t nlink_t off_t blksize_t blkcnt_t);\n+        }\n+        {\n+            use sys::platform::raw;\n+            ok_size!(stat);\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    fn windows() {\n+        use os::windows::raw;\n+    }\n+}"}, {"sha": "1e68eac5a67354b880b5a7e678a7ae8e67fda3ea", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -161,6 +161,8 @@ extern {\n     pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n     pub fn setgroups(ngroups: libc::c_int,\n                      ptr: *const libc::c_void) -> libc::c_int;\n+    pub fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n+                    -> *mut libc::c_char;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "66aaf26b09b72e1ff58b82002e463b7110732160", "filename": "src/libstd/sys/unix/ext.rs", "status": "removed", "additions": 0, "deletions": 337, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/b772ce6342962792620e21623997d0d3b98164b7/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b772ce6342962792620e21623997d0d3b98164b7/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=b772ce6342962792620e21623997d0d3b98164b7", "patch": "@@ -1,337 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Experimental extensions to `std` for Unix platforms.\n-//!\n-//! For now, this module is limited to extracting file descriptors,\n-//! but its functionality will grow over time.\n-//!\n-//! # Example\n-//!\n-//! ```no_run\n-//! use std::fs::File;\n-//! use std::os::unix::prelude::*;\n-//!\n-//! fn main() {\n-//!     let f = File::create(\"foo.txt\").unwrap();\n-//!     let fd = f.as_raw_fd();\n-//!\n-//!     // use fd with native unix bindings\n-//! }\n-//! ```\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-/// Unix-specific extensions to general I/O primitives\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod io {\n-    use fs;\n-    use libc;\n-    use net;\n-    use sys_common::{net2, AsInner, FromInner};\n-    use sys;\n-\n-    /// Raw file descriptors.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub type RawFd = libc::c_int;\n-\n-    /// A trait to extract the raw unix file descriptor from an underlying\n-    /// object.\n-    ///\n-    /// This is only available on unix platforms and must be imported in order\n-    /// to call the method. Windows platforms have a corresponding `AsRawHandle`\n-    /// and `AsRawSocket` set of traits.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait AsRawFd {\n-        /// Extracts the raw file descriptor.\n-        ///\n-        /// This method does **not** pass ownership of the raw file descriptor\n-        /// to the caller. The descriptor is only guarantee to be valid while\n-        /// the original object has not yet been destroyed.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_raw_fd(&self) -> RawFd;\n-    }\n-\n-    /// A trait to express the ability to construct an object from a raw file\n-    /// descriptor.\n-    #[unstable(feature = \"from_raw_os\",\n-               reason = \"recent addition to std::os::unix::io\")]\n-    pub trait FromRawFd {\n-        /// Constructs a new instances of `Self` from the given raw file\n-        /// descriptor.\n-        ///\n-        /// This function **consumes ownership** of the specified file\n-        /// descriptor. The returned object will take responsibility for closing\n-        /// it when the object goes out of scope.\n-        ///\n-        /// This function is also unsafe as the primitives currently returned\n-        /// have the contract that they are the sole owner of the file\n-        /// descriptor they are wrapping. Usage of this function could\n-        /// accidentally allow violating this contract which can cause memory\n-        /// unsafety in code that relies on it being true.\n-        unsafe fn from_raw_fd(fd: RawFd) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for fs::File {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd().raw()\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for fs::File {\n-        unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-            fs::File::from_inner(sys::fs2::File::from_inner(fd))\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for net::TcpStream {\n-        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for net::TcpListener {\n-        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for net::UdpSocket {\n-        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-    }\n-\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for net::TcpStream {\n-        unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-            let socket = sys::net::Socket::from_inner(fd);\n-            net::TcpStream::from_inner(net2::TcpStream::from_inner(socket))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for net::TcpListener {\n-        unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-            let socket = sys::net::Socket::from_inner(fd);\n-            net::TcpListener::from_inner(net2::TcpListener::from_inner(socket))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for net::UdpSocket {\n-        unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-            let socket = sys::net::Socket::from_inner(fd);\n-            net::UdpSocket::from_inner(net2::UdpSocket::from_inner(socket))\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// OsString and OsStr\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix-specific extension to the primitives in the `std::ffi` module\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod ffi {\n-    use ffi::{OsStr, OsString};\n-    use mem;\n-    use prelude::v1::*;\n-    use sys::os_str::Buf;\n-    use sys_common::{FromInner, IntoInner, AsInner};\n-\n-    /// Unix-specific extensions to `OsString`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStringExt {\n-        /// Creates an `OsString` from a byte vector.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn from_vec(vec: Vec<u8>) -> Self;\n-\n-        /// Yields the underlying byte vector of this `OsString`.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn into_vec(self) -> Vec<u8>;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStringExt for OsString {\n-        fn from_vec(vec: Vec<u8>) -> OsString {\n-            FromInner::from_inner(Buf { inner: vec })\n-        }\n-        fn into_vec(self) -> Vec<u8> {\n-            self.into_inner().inner\n-        }\n-    }\n-\n-    /// Unix-specific extensions to `OsStr`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStrExt {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn from_bytes(slice: &[u8]) -> &Self;\n-\n-        /// Gets the underlying byte view of the `OsStr` slice.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_bytes(&self) -> &[u8];\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStrExt for OsStr {\n-        fn from_bytes(slice: &[u8]) -> &OsStr {\n-            unsafe { mem::transmute(slice) }\n-        }\n-        fn as_bytes(&self) -> &[u8] {\n-            &self.as_inner().inner\n-        }\n-    }\n-}\n-\n-/// Unix-specific extensions to primitives in the `std::fs` module.\n-#[unstable(feature = \"fs_ext\",\n-           reason = \"may want a more useful mode abstraction\")]\n-pub mod fs {\n-    use sys;\n-    use sys_common::{FromInner, AsInner, AsInnerMut};\n-    use fs::{Permissions, OpenOptions};\n-    use path::Path;\n-    use convert::AsRef;\n-    use io;\n-\n-    /// Unix-specific extensions to `Permissions`\n-    pub trait PermissionsExt {\n-        fn mode(&self) -> i32;\n-        fn set_mode(&mut self, mode: i32);\n-    }\n-\n-    impl PermissionsExt for Permissions {\n-        fn mode(&self) -> i32 { self.as_inner().mode() }\n-\n-        fn set_mode(&mut self, mode: i32) {\n-            *self = FromInner::from_inner(FromInner::from_inner(mode));\n-        }\n-    }\n-\n-    /// Unix-specific extensions to `OpenOptions`\n-    pub trait OpenOptionsExt {\n-        /// Sets the mode bits that a new file will be created with.\n-        ///\n-        /// If a new file is created as part of a `File::open_opts` call then this\n-        /// specified `mode` will be used as the permission bits for the new file.\n-        fn mode(&mut self, mode: i32) -> &mut Self;\n-    }\n-\n-    impl OpenOptionsExt for OpenOptions {\n-        fn mode(&mut self, mode: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().mode(mode); self\n-        }\n-    }\n-\n-    /// Creates a new symbolic link on the filesystem.\n-    ///\n-    /// The `dst` path will be a symbolic link pointing to the `src` path.\n-    ///\n-    /// # Note\n-    ///\n-    /// On Windows, you must specify whether a symbolic link points to a file\n-    /// or directory.  Use `os::windows::fs::symlink_file` to create a\n-    /// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n-    /// symbolic link to a directory.  Additionally, the process must have\n-    /// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n-    /// symbolic link.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(fs_ext)]\n-    /// use std::os::unix::fs;\n-    ///\n-    /// # fn foo() -> std::io::Result<()> {\n-    /// try!(fs::symlink(\"a.txt\", \"b.txt\"));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n-    {\n-        sys::fs2::symlink(src.as_ref(), dst.as_ref())\n-    }\n-\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Process and Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix-specific extensions to primitives in the `std::process` module.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod process {\n-    use prelude::v1::*;\n-    use libc::{uid_t, gid_t};\n-    use process;\n-    use sys;\n-    use sys_common::{AsInnerMut, AsInner};\n-\n-    /// Unix-specific extensions to the `std::process::Command` builder\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait CommandExt {\n-        /// Sets the child process's user id. This translates to a\n-        /// `setuid` call in the child process. Failure in the `setuid`\n-        /// call will cause the spawn to fail.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn uid(&mut self, id: uid_t) -> &mut process::Command;\n-\n-        /// Similar to `uid`, but sets the group id of the child process. This has\n-        /// the same semantics as the `uid` field.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn gid(&mut self, id: gid_t) -> &mut process::Command;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl CommandExt for process::Command {\n-        fn uid(&mut self, id: uid_t) -> &mut process::Command {\n-            self.as_inner_mut().uid = Some(id);\n-            self\n-        }\n-\n-        fn gid(&mut self, id: gid_t) -> &mut process::Command {\n-            self.as_inner_mut().gid = Some(id);\n-            self\n-        }\n-    }\n-\n-    /// Unix-specific extensions to `std::process::ExitStatus`\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait ExitStatusExt {\n-        /// If the process was terminated by a signal, returns that signal.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn signal(&self) -> Option<i32>;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ExitStatusExt for process::ExitStatus {\n-        fn signal(&self) -> Option<i32> {\n-            match *self.as_inner() {\n-                sys::process2::ExitStatus::Signal(s) => Some(s),\n-                _ => None\n-            }\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Prelude\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// A prelude for conveniently writing platform-specific code.\n-///\n-/// Includes all extension traits, and some important type definitions.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod prelude {\n-    #[doc(no_inline)]\n-    pub use super::io::{RawFd, AsRawFd};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)]\n-    pub use super::fs::{PermissionsExt, OpenOptionsExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::process::{CommandExt, ExitStatusExt};\n-}"}, {"sha": "825e74cabdebb6b3c4264ad247ed90741fcf8c9a", "filename": "src/libstd/sys/unix/ext/ffi.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fffi.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extension to the primitives in the `std::ffi` module\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use ffi::{OsStr, OsString};\n+use mem;\n+use prelude::v1::*;\n+use sys::os_str::Buf;\n+use sys_common::{FromInner, IntoInner, AsInner};\n+\n+/// Unix-specific extensions to `OsString`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStringExt {\n+    /// Creates an `OsString` from a byte vector.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+\n+    /// Yields the underlying byte vector of this `OsString`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+/// Unix-specific extensions to `OsStr`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStrExt {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_bytes(slice: &[u8]) -> &Self;\n+\n+    /// Gets the underlying byte view of the `OsStr` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_bytes(&self) -> &[u8];\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStrExt for OsStr {\n+    fn from_bytes(slice: &[u8]) -> &OsStr {\n+        unsafe { mem::transmute(slice) }\n+    }\n+    fn as_bytes(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}"}, {"sha": "ad6a856d5bcca8a40f9f5a499ba9b4acc485b91c", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,191 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::fs` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use prelude::v1::*;\n+\n+use fs::{self, Permissions, OpenOptions};\n+use io;\n+use mem;\n+use os::raw::c_long;\n+use os::unix::raw;\n+use path::Path;\n+use sys::platform;\n+use sys;\n+use sys_common::{FromInner, AsInner, AsInnerMut};\n+\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_READ: raw::mode_t = 0o400;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_WRITE: raw::mode_t = 0o200;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_EXECUTE: raw::mode_t = 0o100;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_RWX: raw::mode_t = 0o700;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_READ: raw::mode_t = 0o040;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_WRITE: raw::mode_t = 0o020;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_EXECUTE: raw::mode_t = 0o010;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_RWX: raw::mode_t = 0o070;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_READ: raw::mode_t = 0o004;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_WRITE: raw::mode_t = 0o002;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_EXECUTE: raw::mode_t = 0o001;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_RWX: raw::mode_t = 0o007;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_READ: raw::mode_t = 0o444;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_WRITE: raw::mode_t = 0o222;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_EXECUTE: raw::mode_t = 0o111;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_RWX: raw::mode_t = 0o777;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const SETUID: raw::mode_t = 0o4000;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const SETGID: raw::mode_t = 0o2000;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const STICKY_BIT: raw::mode_t = 0o1000;\n+\n+/// Unix-specific extensions to `Permissions`\n+#[unstable(feature = \"fs_ext\",\n+           reason = \"may want a more useful mode abstraction\")]\n+pub trait PermissionsExt {\n+    fn mode(&self) -> raw::mode_t;\n+    fn set_mode(&mut self, mode: raw::mode_t);\n+    fn from_mode(mode: raw::mode_t) -> Self;\n+}\n+\n+impl PermissionsExt for Permissions {\n+    fn mode(&self) -> raw::mode_t { self.as_inner().mode() }\n+\n+    fn set_mode(&mut self, mode: raw::mode_t) {\n+        *self = FromInner::from_inner(FromInner::from_inner(mode));\n+    }\n+\n+    fn from_mode(mode: raw::mode_t) -> Permissions {\n+        FromInner::from_inner(FromInner::from_inner(mode))\n+    }\n+}\n+\n+/// Unix-specific extensions to `OpenOptions`\n+#[unstable(feature = \"fs_ext\",\n+           reason = \"may want a more useful mode abstraction\")]\n+pub trait OpenOptionsExt {\n+    /// Sets the mode bits that a new file will be created with.\n+    ///\n+    /// If a new file is created as part of a `File::open_opts` call then this\n+    /// specified `mode` will be used as the permission bits for the new file.\n+    fn mode(&mut self, mode: raw::mode_t) -> &mut Self;\n+}\n+\n+impl OpenOptionsExt for OpenOptions {\n+    fn mode(&mut self, mode: raw::mode_t) -> &mut OpenOptions {\n+        self.as_inner_mut().mode(mode); self\n+    }\n+}\n+\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub struct Metadata(sys::fs2::FileAttr);\n+\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub trait MetadataExt {\n+    fn as_raw(&self) -> &Metadata;\n+}\n+\n+impl MetadataExt for fs::Metadata {\n+    fn as_raw(&self) -> &Metadata {\n+        let inner: &sys::fs2::FileAttr = self.as_inner();\n+        unsafe { mem::transmute(inner) }\n+    }\n+}\n+\n+impl AsInner<platform::raw::stat> for Metadata {\n+    fn as_inner(&self) -> &platform::raw::stat { self.0.as_inner() }\n+}\n+\n+// Hm, why are there casts here to the returned type, shouldn't the types always\n+// be the same? Right you are! Turns out, however, on android at least the types\n+// in the raw `stat` structure are not the same as the types being returned. Who\n+// knew!\n+//\n+// As a result to make sure this compiles for all platforms we do the manual\n+// casts and rely on manual lowering to `stat` if the raw type is desired.\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+impl Metadata {\n+    pub fn dev(&self) -> raw::dev_t { self.0.raw().st_dev as raw::dev_t }\n+    pub fn ino(&self) -> raw::ino_t { self.0.raw().st_ino as raw::ino_t }\n+    pub fn mode(&self) -> raw::mode_t { self.0.raw().st_mode as raw::mode_t }\n+    pub fn nlink(&self) -> raw::nlink_t { self.0.raw().st_nlink as raw::nlink_t }\n+    pub fn uid(&self) -> raw::uid_t { self.0.raw().st_uid as raw::uid_t }\n+    pub fn gid(&self) -> raw::gid_t { self.0.raw().st_gid as raw::gid_t }\n+    pub fn rdev(&self) -> raw::dev_t { self.0.raw().st_rdev as raw::dev_t }\n+    pub fn size(&self) -> raw::off_t { self.0.raw().st_size as raw::off_t }\n+    pub fn atime(&self) -> raw::time_t { self.0.raw().st_atime }\n+    pub fn atime_nsec(&self) -> c_long { self.0.raw().st_atime }\n+    pub fn mtime(&self) -> raw::time_t { self.0.raw().st_mtime }\n+    pub fn mtime_nsec(&self) -> c_long { self.0.raw().st_mtime }\n+    pub fn ctime(&self) -> raw::time_t { self.0.raw().st_ctime }\n+    pub fn ctime_nsec(&self) -> c_long { self.0.raw().st_ctime }\n+\n+    pub fn blksize(&self) -> raw::blksize_t {\n+        self.0.raw().st_blksize as raw::blksize_t\n+    }\n+    pub fn blocks(&self) -> raw::blkcnt_t {\n+        self.0.raw().st_blocks as raw::blkcnt_t\n+    }\n+}\n+\n+#[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+pub trait DirEntryExt {\n+    fn ino(&self) -> raw::ino_t;\n+}\n+\n+impl DirEntryExt for fs::DirEntry {\n+    fn ino(&self) -> raw::ino_t { self.as_inner().ino() }\n+}\n+\n+/// Creates a new symbolic link on the filesystem.\n+///\n+/// The `dst` path will be a symbolic link pointing to the `src` path.\n+///\n+/// # Note\n+///\n+/// On Windows, you must specify whether a symbolic link points to a file\n+/// or directory.  Use `os::windows::fs::symlink_file` to create a\n+/// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n+/// symbolic link to a directory.  Additionally, the process must have\n+/// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n+/// symbolic link.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n+{\n+    sys::fs2::symlink(src.as_ref(), dst.as_ref())\n+}"}, {"sha": "8cb4b4907f6dcf49db2656d6c233c36b139ec9ea", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to general I/O primitives\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs;\n+use net;\n+use os::raw;\n+use sys;\n+use sys_common::{net2, AsInner, FromInner};\n+\n+/// Raw file descriptors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawFd = raw::c_int;\n+\n+/// A trait to extract the raw unix file descriptor from an underlying\n+/// object.\n+///\n+/// This is only available on unix platforms and must be imported in order\n+/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n+/// and `AsRawSocket` set of traits.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guarantee to be valid while\n+    /// the original object has not yet been destroyed.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+#[unstable(feature = \"from_raw_os\",\n+           reason = \"recent addition to std::os::unix::io\")]\n+pub trait FromRawFd {\n+    /// Constructs a new instances of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for fs::File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for fs::File {\n+    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n+        fs::File::from_inner(sys::fs2::File::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(net2::TcpStream::from_inner(socket))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(net2::TcpListener::from_inner(socket))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(net2::UdpSocket::from_inner(socket))\n+    }\n+}"}, {"sha": "6fde45a7301f91bbaa141d1a216e60098cae52f1", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental extensions to `std` for Unix platforms.\n+//!\n+//! For now, this module is limited to extracting file descriptors,\n+//! but its functionality will grow over time.\n+//!\n+//! # Example\n+//!\n+//! ```no_run\n+//! use std::fs::File;\n+//! use std::os::unix::prelude::*;\n+//!\n+//! fn main() {\n+//!     let f = File::create(\"foo.txt\").unwrap();\n+//!     let fd = f.as_raw_fd();\n+//!\n+//!     // use fd with native unix bindings\n+//! }\n+//! ```\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod io;\n+pub mod ffi;\n+pub mod fs;\n+pub mod process;\n+pub mod raw;\n+\n+/// A prelude for conveniently writing platform-specific code.\n+///\n+/// Includes all extension traits, and some important type definitions.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)]\n+    pub use super::io::{RawFd, AsRawFd};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt};\n+    #[doc(no_inline)]\n+    pub use super::fs::{DirEntryExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::process::{CommandExt, ExitStatusExt};\n+}"}, {"sha": "8c9d0a86583fb9bd44da512af2ebad68723c5407", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::process` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use os::unix::raw::{uid_t, gid_t};\n+use prelude::v1::*;\n+use process;\n+use sys;\n+use sys_common::{AsInnerMut, AsInner};\n+\n+/// Unix-specific extensions to the `std::process::Command` builder\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait CommandExt {\n+    /// Sets the child process's user id. This translates to a\n+    /// `setuid` call in the child process. Failure in the `setuid`\n+    /// call will cause the spawn to fail.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn uid(&mut self, id: uid_t) -> &mut process::Command;\n+\n+    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn gid(&mut self, id: gid_t) -> &mut process::Command;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl CommandExt for process::Command {\n+    fn uid(&mut self, id: uid_t) -> &mut process::Command {\n+        self.as_inner_mut().uid = Some(id);\n+        self\n+    }\n+\n+    fn gid(&mut self, id: gid_t) -> &mut process::Command {\n+        self.as_inner_mut().gid = Some(id);\n+        self\n+    }\n+}\n+\n+/// Unix-specific extensions to `std::process::ExitStatus`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExitStatusExt {\n+    /// If the process was terminated by a signal, returns that signal.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn signal(&self) -> Option<i32>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExitStatusExt for process::ExitStatus {\n+    fn signal(&self) -> Option<i32> {\n+        match *self.as_inner() {\n+            sys::process2::ExitStatus::Signal(s) => Some(s),\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "8fe4b90456a4c177b24e1a3a42eca35a9577c578", "filename": "src/libstd/sys/unix/ext/raw.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific primitives available on all unix platforms\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub type uid_t = u32;\n+pub type gid_t = u32;\n+pub type pid_t = i32;\n+\n+#[doc(inline)]\n+pub use sys::platform::raw::{dev_t, ino_t, mode_t, nlink_t, off_t, blksize_t};\n+#[doc(inline)]\n+pub use sys::platform::raw::{blkcnt_t, time_t};"}, {"sha": "678d8065ce7b8ae506b52aa8fabd76fea0614e0e", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 94, "deletions": 18, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -21,14 +21,15 @@ use path::{Path, PathBuf};\n use ptr;\n use sync::Arc;\n use sys::fd::FileDesc;\n+use sys::platform::raw;\n use sys::{c, cvt, cvt_r};\n-use sys_common::FromInner;\n+use sys_common::{AsInner, FromInner};\n use vec::Vec;\n \n pub struct File(FileDesc);\n \n pub struct FileAttr {\n-    stat: libc::stat,\n+    stat: raw::stat,\n }\n \n pub struct ReadDir {\n@@ -57,13 +58,10 @@ pub struct OpenOptions {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FilePermissions { mode: mode_t }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct FileType { mode: mode_t }\n+\n impl FileAttr {\n-    pub fn is_dir(&self) -> bool {\n-        (self.stat.st_mode as mode_t) & libc::S_IFMT == libc::S_IFDIR\n-    }\n-    pub fn is_file(&self) -> bool {\n-        (self.stat.st_mode as mode_t) & libc::S_IFMT == libc::S_IFREG\n-    }\n     pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { mode: (self.stat.st_mode as mode_t) & 0o777 }\n@@ -76,12 +74,35 @@ impl FileAttr {\n         self.mktime(self.stat.st_mtime as u64, self.stat.st_mtime_nsec as u64)\n     }\n \n+    pub fn file_type(&self) -> FileType {\n+        FileType { mode: self.stat.st_mode as mode_t }\n+    }\n+\n+    pub fn raw(&self) -> &raw::stat { &self.stat }\n+\n     // times are in milliseconds (currently)\n     fn mktime(&self, secs: u64, nsecs: u64) -> u64 {\n         secs * 1000 + nsecs / 1000000\n     }\n }\n \n+impl AsInner<raw::stat> for FileAttr {\n+    fn as_inner(&self) -> &raw::stat { &self.stat }\n+}\n+\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub trait MetadataExt {\n+    fn as_raw_stat(&self) -> &raw::stat;\n+}\n+\n+impl MetadataExt for ::fs::Metadata {\n+    fn as_raw_stat(&self) -> &raw::stat { &self.as_inner().stat }\n+}\n+\n+impl MetadataExt for ::os::unix::fs::Metadata {\n+    fn as_raw_stat(&self) -> &raw::stat { self.as_inner() }\n+}\n+\n impl FilePermissions {\n     pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }\n     pub fn set_readonly(&mut self, readonly: bool) {\n@@ -91,11 +112,19 @@ impl FilePermissions {\n             self.mode |= 0o222;\n         }\n     }\n-    pub fn mode(&self) -> i32 { self.mode as i32 }\n+    pub fn mode(&self) -> raw::mode_t { self.mode }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool { self.is(libc::S_IFDIR) }\n+    pub fn is_file(&self) -> bool { self.is(libc::S_IFREG) }\n+    pub fn is_symlink(&self) -> bool { self.is(libc::S_IFLNK) }\n+\n+    fn is(&self, mode: mode_t) -> bool { self.mode & libc::S_IFMT == mode }\n }\n \n-impl FromInner<i32> for FilePermissions {\n-    fn from_inner(mode: i32) -> FilePermissions {\n+impl FromInner<raw::mode_t> for FilePermissions {\n+    fn from_inner(mode: raw::mode_t) -> FilePermissions {\n         FilePermissions { mode: mode as mode_t }\n     }\n }\n@@ -147,6 +176,33 @@ impl DirEntry {\n         self.root.join(<OsStr as OsStrExt>::from_bytes(self.name_bytes()))\n     }\n \n+    pub fn file_name(&self) -> OsString {\n+        OsStr::from_bytes(self.name_bytes()).to_os_string()\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        lstat(&self.path())\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        extern {\n+            fn rust_dir_get_mode(ptr: *mut libc::dirent_t) -> c_int;\n+        }\n+        unsafe {\n+            match rust_dir_get_mode(self.dirent()) {\n+                -1 => lstat(&self.path()).map(|m| m.file_type()),\n+                n => Ok(FileType { mode: n as mode_t }),\n+            }\n+        }\n+    }\n+\n+    pub fn ino(&self) -> raw::ino_t {\n+        extern {\n+            fn rust_dir_get_ino(ptr: *mut libc::dirent_t) -> raw::ino_t;\n+        }\n+        unsafe { rust_dir_get_ino(self.dirent()) }\n+    }\n+\n     fn name_bytes(&self) -> &[u8] {\n         extern {\n             fn rust_list_dir_val(ptr: *mut libc::dirent_t) -> *const c_char;\n@@ -191,7 +247,7 @@ impl OpenOptions {\n         self.flag(libc::O_CREAT, create);\n     }\n \n-    pub fn mode(&mut self, mode: i32) {\n+    pub fn mode(&mut self, mode: raw::mode_t) {\n         self.mode = mode as mode_t;\n     }\n \n@@ -228,8 +284,10 @@ impl File {\n     pub fn into_fd(self) -> FileDesc { self.0 }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut stat: libc::stat = unsafe { mem::zeroed() };\n-        try!(cvt(unsafe { libc::fstat(self.0.raw(), &mut stat) }));\n+        let mut stat: raw::stat = unsafe { mem::zeroed() };\n+        try!(cvt(unsafe {\n+            libc::fstat(self.0.raw(), &mut stat as *mut _ as *mut _)\n+        }));\n         Ok(FileAttr { stat: stat })\n     }\n \n@@ -420,15 +478,19 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let p = try!(cstr(p));\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    try!(cvt(unsafe { libc::stat(p.as_ptr(), &mut stat) }));\n+    let mut stat: raw::stat = unsafe { mem::zeroed() };\n+    try!(cvt(unsafe {\n+        libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    }));\n     Ok(FileAttr { stat: stat })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     let p = try!(cstr(p));\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    try!(cvt(unsafe { libc::lstat(p.as_ptr(), &mut stat) }));\n+    let mut stat: raw::stat = unsafe { mem::zeroed() };\n+    try!(cvt(unsafe {\n+        libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    }));\n     Ok(FileAttr { stat: stat })\n }\n \n@@ -438,3 +500,17 @@ pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n     try!(cvt(unsafe { c::utimes(p.as_ptr(), buf.as_ptr()) }));\n     Ok(())\n }\n+\n+pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n+    let path = try!(CString::new(p.as_os_str().as_bytes()));\n+    let mut buf = vec![0u8; 16 * 1024];\n+    unsafe {\n+        let r = c::realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n+        if r.is_null() {\n+            return Err(io::Error::last_os_error())\n+        }\n+    }\n+    let p = buf.iter().position(|i| *i == 0).unwrap();\n+    buf.truncate(p);\n+    Ok(PathBuf::from(OsString::from_vec(buf)))\n+}"}, {"sha": "78b798d3bffff06f849f2f53b22b71512edc623c", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -18,6 +18,16 @@ use libc;\n use num::One;\n use ops::Neg;\n \n+#[cfg(target_os = \"android\")]   pub use os::android as platform;\n+#[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n+#[cfg(target_os = \"dragonfly\")] pub use os::dragonfly as platform;\n+#[cfg(target_os = \"freebsd\")]   pub use os::freebsd as platform;\n+#[cfg(target_os = \"ios\")]       pub use os::ios as platform;\n+#[cfg(target_os = \"linux\")]     pub use os::linux as platform;\n+#[cfg(target_os = \"macos\")]     pub use os::macos as platform;\n+#[cfg(target_os = \"nacl\")]      pub use os::nacl as platform;\n+#[cfg(target_os = \"openbsd\")]   pub use os::openbsd as platform;\n+\n pub mod backtrace;\n pub mod c;\n pub mod condvar;"}, {"sha": "dd747d202a04b7195692ee03112419e4a95def47", "filename": "src/libstd/sys/windows/ext.rs", "status": "removed", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/b772ce6342962792620e21623997d0d3b98164b7/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b772ce6342962792620e21623997d0d3b98164b7/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=b772ce6342962792620e21623997d0d3b98164b7", "patch": "@@ -1,301 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Experimental extensions to `std` for Windows.\n-//!\n-//! For now, this module is limited to extracting handles, file\n-//! descriptors, and sockets, but its functionality will grow over\n-//! time.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod io {\n-    use fs;\n-    use libc;\n-    use net;\n-    use sys_common::{net2, AsInner, FromInner};\n-    use sys;\n-\n-    /// Raw HANDLEs.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub type RawHandle = libc::HANDLE;\n-\n-    /// Raw SOCKETs.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub type RawSocket = libc::SOCKET;\n-\n-    /// Extract raw handles.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait AsRawHandle {\n-        /// Extracts the raw handle, without taking any ownership.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_raw_handle(&self) -> RawHandle;\n-    }\n-\n-    /// Construct I/O objects from raw handles.\n-    #[unstable(feature = \"from_raw_os\",\n-               reason = \"recent addition to the std::os::windows::io module\")]\n-    pub trait FromRawHandle {\n-        /// Constructs a new I/O object from the specified raw handle.\n-        ///\n-        /// This function will **consume ownership** of the handle given,\n-        /// passing responsibility for closing the handle to the returned\n-        /// object.\n-        ///\n-        /// This function is also unsafe as the primitives currently returned\n-        /// have the contract that they are the sole owner of the file\n-        /// descriptor they are wrapping. Usage of this function could\n-        /// accidentally allow violating this contract which can cause memory\n-        /// unsafety in code that relies on it being true.\n-        unsafe fn from_raw_handle(handle: RawHandle) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawHandle for fs::File {\n-        fn as_raw_handle(&self) -> RawHandle {\n-            self.as_inner().handle().raw()\n-        }\n-    }\n-\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawHandle for fs::File {\n-        unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n-            fs::File::from_inner(sys::fs2::File::from_inner(handle))\n-        }\n-    }\n-\n-    /// Extract raw sockets.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait AsRawSocket {\n-        /// Extracts the underlying raw socket from this object.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_raw_socket(&self) -> RawSocket;\n-    }\n-\n-    /// Create I/O objects from raw sockets.\n-    #[unstable(feature = \"from_raw_os\", reason = \"recent addition to module\")]\n-    pub trait FromRawSocket {\n-        /// Creates a new I/O object from the given raw socket.\n-        ///\n-        /// This function will **consume ownership** of the socket provided and\n-        /// it will be closed when the returned object goes out of scope.\n-        ///\n-        /// This function is also unsafe as the primitives currently returned\n-        /// have the contract that they are the sole owner of the file\n-        /// descriptor they are wrapping. Usage of this function could\n-        /// accidentally allow violating this contract which can cause memory\n-        /// unsafety in code that relies on it being true.\n-        unsafe fn from_raw_socket(sock: RawSocket) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawSocket for net::TcpStream {\n-        fn as_raw_socket(&self) -> RawSocket {\n-            *self.as_inner().socket().as_inner()\n-        }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawSocket for net::TcpListener {\n-        fn as_raw_socket(&self) -> RawSocket {\n-            *self.as_inner().socket().as_inner()\n-        }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawSocket for net::UdpSocket {\n-        fn as_raw_socket(&self) -> RawSocket {\n-            *self.as_inner().socket().as_inner()\n-        }\n-    }\n-\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawSocket for net::TcpStream {\n-        unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream {\n-            let sock = sys::net::Socket::from_inner(sock);\n-            net::TcpStream::from_inner(net2::TcpStream::from_inner(sock))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawSocket for net::TcpListener {\n-        unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener {\n-            let sock = sys::net::Socket::from_inner(sock);\n-            net::TcpListener::from_inner(net2::TcpListener::from_inner(sock))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawSocket for net::UdpSocket {\n-        unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket {\n-            let sock = sys::net::Socket::from_inner(sock);\n-            net::UdpSocket::from_inner(net2::UdpSocket::from_inner(sock))\n-        }\n-    }\n-}\n-\n-/// Windows-specific extensions to the primitives in the `std::ffi` module.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod ffi {\n-    use ffi::{OsString, OsStr};\n-    use sys::os_str::Buf;\n-    use sys_common::wtf8::Wtf8Buf;\n-    use sys_common::{FromInner, AsInner};\n-\n-    pub use sys_common::wtf8::EncodeWide;\n-\n-    /// Windows-specific extensions to `OsString`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStringExt {\n-        /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of\n-        /// 16-bit code units.\n-        ///\n-        /// This is lossless: calling `.encode_wide()` on the resulting string\n-        /// will always return the original code units.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn from_wide(wide: &[u16]) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStringExt for OsString {\n-        fn from_wide(wide: &[u16]) -> OsString {\n-            FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) })\n-        }\n-    }\n-\n-    /// Windows-specific extensions to `OsStr`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStrExt {\n-        /// Re-encodes an `OsStr` as a wide character sequence,\n-        /// i.e. potentially ill-formed UTF-16.\n-        ///\n-        /// This is lossless. Note that the encoding does not include a final\n-        /// null.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn encode_wide(&self) -> EncodeWide;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStrExt for OsStr {\n-        fn encode_wide(&self) -> EncodeWide {\n-            self.as_inner().inner.encode_wide()\n-        }\n-    }\n-}\n-\n-/// Windows-specific extensions for the primitives in `std::fs`\n-#[unstable(feature = \"fs_ext\", reason = \"may require more thought/methods\")]\n-pub mod fs {\n-    use fs::OpenOptions;\n-    use sys;\n-    use sys_common::AsInnerMut;\n-    use path::Path;\n-    use convert::AsRef;\n-    use io;\n-\n-    /// Windows-specific extensions to `OpenOptions`\n-    pub trait OpenOptionsExt {\n-        /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n-        /// with the specified value.\n-        fn desired_access(&mut self, access: i32) -> &mut Self;\n-\n-        /// Overrides the `dwCreationDisposition` argument to the call to\n-        /// `CreateFile` with the specified value.\n-        ///\n-        /// This will override any values of the standard `create` flags, for\n-        /// example.\n-        fn creation_disposition(&mut self, val: i32) -> &mut Self;\n-\n-        /// Overrides the `dwFlagsAndAttributes` argument to the call to\n-        /// `CreateFile` with the specified value.\n-        ///\n-        /// This will override any values of the standard flags on the\n-        /// `OpenOptions` structure.\n-        fn flags_and_attributes(&mut self, val: i32) -> &mut Self;\n-\n-        /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n-        /// the specified value.\n-        ///\n-        /// This will override any values of the standard flags on the\n-        /// `OpenOptions` structure.\n-        fn share_mode(&mut self, val: i32) -> &mut Self;\n-    }\n-\n-    impl OpenOptionsExt for OpenOptions {\n-        fn desired_access(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().desired_access(access); self\n-        }\n-        fn creation_disposition(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().creation_disposition(access); self\n-        }\n-        fn flags_and_attributes(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().flags_and_attributes(access); self\n-        }\n-        fn share_mode(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().share_mode(access); self\n-        }\n-    }\n-\n-    /// Creates a new file symbolic link on the filesystem.\n-    ///\n-    /// The `dst` path will be a file symbolic link pointing to the `src`\n-    /// path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// #![feature(fs_ext)]\n-    /// use std::os::windows::fs;\n-    ///\n-    /// # fn foo() -> std::io::Result<()> {\n-    /// try!(fs::symlink_file(\"a.txt\", \"b.txt\"));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n-                                                        -> io::Result<()>\n-    {\n-        sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), false)\n-    }\n-\n-    /// Creates a new directory symlink on the filesystem.\n-    ///\n-    /// The `dst` path will be a directory symbolic link pointing to the `src`\n-    /// path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// #![feature(fs_ext)]\n-    /// use std::os::windows::fs;\n-    ///\n-    /// # fn foo() -> std::io::Result<()> {\n-    /// try!(fs::symlink_file(\"a\", \"b\"));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>> (src: P, dst: Q)\n-                                                        -> io::Result<()>\n-    {\n-        sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), true)\n-    }\n-}\n-\n-/// A prelude for conveniently writing platform-specific code.\n-///\n-/// Includes all extension traits, and some important type definitions.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod prelude {\n-    #[doc(no_inline)]\n-    pub use super::io::{RawSocket, RawHandle, AsRawSocket, AsRawHandle};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)]\n-    pub use super::fs::OpenOptionsExt;\n-}"}, {"sha": "3fa96f4dd13e96decb436cecb58aca5d7c06d825", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows-specific extensions to the primitives in the `std::ffi` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use ffi::{OsString, OsStr};\n+use sys::os_str::Buf;\n+use sys_common::wtf8::Wtf8Buf;\n+use sys_common::{FromInner, AsInner};\n+\n+pub use sys_common::wtf8::EncodeWide;\n+\n+/// Windows-specific extensions to `OsString`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStringExt {\n+    /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of\n+    /// 16-bit code units.\n+    ///\n+    /// This is lossless: calling `.encode_wide()` on the resulting string\n+    /// will always return the original code units.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_wide(wide: &[u16]) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStringExt for OsString {\n+    fn from_wide(wide: &[u16]) -> OsString {\n+        FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) })\n+    }\n+}\n+\n+/// Windows-specific extensions to `OsStr`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStrExt {\n+    /// Re-encodes an `OsStr` as a wide character sequence,\n+    /// i.e. potentially ill-formed UTF-16.\n+    ///\n+    /// This is lossless. Note that the encoding does not include a final\n+    /// null.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn encode_wide(&self) -> EncodeWide;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStrExt for OsStr {\n+    fn encode_wide(&self) -> EncodeWide {\n+        self.as_inner().inner.encode_wide()\n+    }\n+}"}, {"sha": "23c1fcf4b3c6e1d2850a1d6bc3a730777fe5d467", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,150 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows-specific extensions for the primitives in `std::fs`\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use prelude::v1::*;\n+\n+use fs::{OpenOptions, Metadata};\n+use io;\n+use path::Path;\n+use sys;\n+use sys_common::{AsInnerMut, AsInner};\n+\n+/// Windows-specific extensions to `OpenOptions`\n+#[unstable(feature = \"fs_ext\", reason = \"may require more thought/methods\")]\n+pub trait OpenOptionsExt {\n+    /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n+    /// with the specified value.\n+    fn desired_access(&mut self, access: i32) -> &mut Self;\n+\n+    /// Overrides the `dwCreationDisposition` argument to the call to\n+    /// `CreateFile` with the specified value.\n+    ///\n+    /// This will override any values of the standard `create` flags, for\n+    /// example.\n+    fn creation_disposition(&mut self, val: i32) -> &mut Self;\n+\n+    /// Overrides the `dwFlagsAndAttributes` argument to the call to\n+    /// `CreateFile` with the specified value.\n+    ///\n+    /// This will override any values of the standard flags on the\n+    /// `OpenOptions` structure.\n+    fn flags_and_attributes(&mut self, val: i32) -> &mut Self;\n+\n+    /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n+    /// the specified value.\n+    ///\n+    /// This will override any values of the standard flags on the\n+    /// `OpenOptions` structure.\n+    fn share_mode(&mut self, val: i32) -> &mut Self;\n+}\n+\n+impl OpenOptionsExt for OpenOptions {\n+    fn desired_access(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().desired_access(access); self\n+    }\n+    fn creation_disposition(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().creation_disposition(access); self\n+    }\n+    fn flags_and_attributes(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().flags_and_attributes(access); self\n+    }\n+    fn share_mode(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().share_mode(access); self\n+    }\n+}\n+\n+/// Extension methods for `fs::Metadata` to access the raw fields contained\n+/// within.\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub trait MetadataExt {\n+    /// Returns the value of the `dwFileAttributes` field of this metadata.\n+    ///\n+    /// This field contains the file system attribute information for a file\n+    /// or directory.\n+    fn file_attributes(&self) -> u32;\n+\n+    /// Returns the value of the `ftCreationTime` field of this metadata.\n+    ///\n+    /// The returned 64-bit value represents the number of 100-nanosecond\n+    /// intervals since January 1, 1601 (UTC).\n+    fn creation_time(&self) -> u64;\n+\n+    /// Returns the value of the `ftLastAccessTime` field of this metadata.\n+    ///\n+    /// The returned 64-bit value represents the number of 100-nanosecond\n+    /// intervals since January 1, 1601 (UTC).\n+    fn last_access_time(&self) -> u64;\n+\n+    /// Returns the value of the `ftLastWriteTime` field of this metadata.\n+    ///\n+    /// The returned 64-bit value represents the number of 100-nanosecond\n+    /// intervals since January 1, 1601 (UTC).\n+    fn last_write_time(&self) -> u64;\n+\n+    /// Returns the value of the `nFileSize{High,Low}` fields of this\n+    /// metadata.\n+    ///\n+    /// The returned value does not have meaning for directories.\n+    fn file_size(&self) -> u64;\n+}\n+\n+impl MetadataExt for Metadata {\n+    fn file_attributes(&self) -> u32 { self.as_inner().attrs() }\n+    fn creation_time(&self) -> u64 { self.as_inner().created() }\n+    fn last_access_time(&self) -> u64 { self.as_inner().accessed() }\n+    fn last_write_time(&self) -> u64 { self.as_inner().modified() }\n+    fn file_size(&self) -> u64 { self.as_inner().size() }\n+}\n+\n+/// Creates a new file symbolic link on the filesystem.\n+///\n+/// The `dst` path will be a file symbolic link pointing to the `src`\n+/// path.\n+///\n+/// # Examples\n+///\n+/// ```ignore\n+/// use std::os::windows::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink_file(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n+                                                    -> io::Result<()> {\n+    sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), false)\n+}\n+\n+/// Creates a new directory symlink on the filesystem.\n+///\n+/// The `dst` path will be a directory symbolic link pointing to the `src`\n+/// path.\n+///\n+/// # Examples\n+///\n+/// ```ignore\n+/// use std::os::windows::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink_file(\"a\", \"b\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n+                                                   -> io::Result<()> {\n+    sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), true)\n+}"}, {"sha": "b88a6316eee8b9aa7691aa6a25d7f2819231b034", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs;\n+use os::windows::raw;\n+use net;\n+use sys_common::{net2, AsInner, FromInner};\n+use sys;\n+\n+/// Raw HANDLEs.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawHandle = raw::HANDLE;\n+\n+/// Raw SOCKETs.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawSocket = raw::SOCKET;\n+\n+/// Extract raw handles.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawHandle {\n+    /// Extracts the raw handle, without taking any ownership.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_handle(&self) -> RawHandle;\n+}\n+\n+/// Construct I/O objects from raw handles.\n+#[unstable(feature = \"from_raw_os\",\n+           reason = \"recent addition to the std::os::windows::io module\")]\n+pub trait FromRawHandle {\n+    /// Constructs a new I/O object from the specified raw handle.\n+    ///\n+    /// This function will **consume ownership** of the handle given,\n+    /// passing responsibility for closing the handle to the returned\n+    /// object.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_handle(handle: RawHandle) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawHandle for fs::File {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.as_inner().handle().raw() as RawHandle\n+    }\n+}\n+\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawHandle for fs::File {\n+    unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n+        let handle = handle as ::libc::HANDLE;\n+        fs::File::from_inner(sys::fs2::File::from_inner(handle))\n+    }\n+}\n+\n+/// Extract raw sockets.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawSocket {\n+    /// Extracts the underlying raw socket from this object.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_socket(&self) -> RawSocket;\n+}\n+\n+/// Create I/O objects from raw sockets.\n+#[unstable(feature = \"from_raw_os\", reason = \"recent addition to module\")]\n+pub trait FromRawSocket {\n+    /// Creates a new I/O object from the given raw socket.\n+    ///\n+    /// This function will **consume ownership** of the socket provided and\n+    /// it will be closed when the returned object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_socket(sock: RawSocket) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawSocket for net::TcpStream {\n+    fn as_raw_socket(&self) -> RawSocket {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawSocket for net::TcpListener {\n+    fn as_raw_socket(&self) -> RawSocket {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawSocket for net::UdpSocket {\n+    fn as_raw_socket(&self) -> RawSocket {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawSocket for net::TcpStream {\n+    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream {\n+        let sock = sys::net::Socket::from_inner(sock);\n+        net::TcpStream::from_inner(net2::TcpStream::from_inner(sock))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawSocket for net::TcpListener {\n+    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener {\n+        let sock = sys::net::Socket::from_inner(sock);\n+        net::TcpListener::from_inner(net2::TcpListener::from_inner(sock))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawSocket for net::UdpSocket {\n+    unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket {\n+        let sock = sys::net::Socket::from_inner(sock);\n+        net::UdpSocket::from_inner(net2::UdpSocket::from_inner(sock))\n+    }\n+}"}, {"sha": "08dfa4cc8775307c39d48a70afdd1dd76803ea5e", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental extensions to `std` for Windows.\n+//!\n+//! For now, this module is limited to extracting handles, file\n+//! descriptors, and sockets, but its functionality will grow over\n+//! time.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod ffi;\n+pub mod fs;\n+pub mod io;\n+pub mod raw;\n+\n+/// A prelude for conveniently writing platform-specific code.\n+///\n+/// Includes all extension traits, and some important type definitions.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)]\n+    pub use super::io::{RawSocket, RawHandle, AsRawSocket, AsRawHandle};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    pub use super::fs::{OpenOptionsExt, MetadataExt};\n+}"}, {"sha": "656e480ad0963df1778e9bb09816367d047f0d59", "filename": "src/libstd/sys/windows/ext/raw.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows-specific primitives\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+use os::raw;\n+\n+pub type HANDLE = *mut raw::c_void;\n+#[cfg(target_pointer_width = \"32\")]\n+pub type SOCKET = u32;\n+#[cfg(target_pointer_width = \"64\")]\n+pub type SOCKET = u64;"}, {"sha": "2c81c34d3a4a63cec3add657f5995fb1dcbf63c2", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 154, "deletions": 54, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -27,7 +27,16 @@ use sys_common::FromInner;\n use vec::Vec;\n \n pub struct File { handle: Handle }\n-pub struct FileAttr { data: c::WIN32_FILE_ATTRIBUTE_DATA }\n+\n+pub struct FileAttr {\n+    data: c::WIN32_FILE_ATTRIBUTE_DATA,\n+    is_symlink: bool,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum FileType {\n+    Dir, File, Symlink, ReparsePoint\n+}\n \n pub struct ReadDir {\n     handle: FindNextFileHandle,\n@@ -111,8 +120,31 @@ impl DirEntry {\n     }\n \n     pub fn path(&self) -> PathBuf {\n+        self.root.join(&self.file_name())\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n         let filename = super::truncate_utf16_at_nul(&self.data.cFileName);\n-        self.root.join(&<OsString as OsStringExt>::from_wide(filename))\n+        OsString::from_wide(filename)\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        Ok(FileType::new(self.data.dwFileAttributes,\n+                         self.data.dwReserved0 == c::IO_REPARSE_TAG_SYMLINK))\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        Ok(FileAttr {\n+            data: c::WIN32_FILE_ATTRIBUTE_DATA {\n+                dwFileAttributes: self.data.dwFileAttributes,\n+                ftCreationTime: self.data.ftCreationTime,\n+                ftLastAccessTime: self.data.ftLastAccessTime,\n+                ftLastWriteTime: self.data.ftLastWriteTime,\n+                nFileSizeHigh: self.data.nFileSizeHigh,\n+                nFileSizeLow: self.data.nFileSizeLow,\n+            },\n+            is_symlink: self.data.dwReserved0 == c::IO_REPARSE_TAG_SYMLINK,\n+        })\n     }\n }\n \n@@ -180,6 +212,13 @@ impl OpenOptions {\n }\n \n impl File {\n+    fn open_reparse_point(path: &Path) -> io::Result<File> {\n+        let mut opts = OpenOptions::new();\n+        opts.read(true);\n+        opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT as i32);\n+        File::open(path, &opts)\n+    }\n+\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n         let path = to_utf16(path);\n         let handle = unsafe {\n@@ -224,16 +263,21 @@ impl File {\n             let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n             try!(cvt(c::GetFileInformationByHandle(self.handle.raw(),\n                                                    &mut info)));\n-            Ok(FileAttr {\n+            let mut attr = FileAttr {\n                 data: c::WIN32_FILE_ATTRIBUTE_DATA {\n                     dwFileAttributes: info.dwFileAttributes,\n                     ftCreationTime: info.ftCreationTime,\n                     ftLastAccessTime: info.ftLastAccessTime,\n                     ftLastWriteTime: info.ftLastWriteTime,\n                     nFileSizeHigh: info.nFileSizeHigh,\n                     nFileSizeLow: info.nFileSizeLow,\n-                }\n-            })\n+                },\n+                is_symlink: false,\n+            };\n+            if attr.is_reparse_point() {\n+                attr.is_symlink = self.is_symlink();\n+            }\n+            Ok(attr)\n         }\n     }\n \n@@ -263,6 +307,41 @@ impl File {\n     }\n \n     pub fn handle(&self) -> &Handle { &self.handle }\n+\n+    fn is_symlink(&self) -> bool {\n+        self.readlink().is_ok()\n+    }\n+\n+    fn readlink(&self) -> io::Result<PathBuf> {\n+        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let mut bytes = 0;\n+\n+        unsafe {\n+            try!(cvt({\n+                c::DeviceIoControl(self.handle.raw(),\n+                                   c::FSCTL_GET_REPARSE_POINT,\n+                                   0 as *mut _,\n+                                   0,\n+                                   space.as_mut_ptr() as *mut _,\n+                                   space.len() as libc::DWORD,\n+                                   &mut bytes,\n+                                   0 as *mut _)\n+            }));\n+            let buf: *const c::REPARSE_DATA_BUFFER = space.as_ptr() as *const _;\n+            if (*buf).ReparseTag != c::IO_REPARSE_TAG_SYMLINK {\n+                return Err(io::Error::new(io::ErrorKind::Other, \"not a symlink\"))\n+            }\n+            let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n+                    &(*buf).rest as *const _ as *const _;\n+            let path_buffer = &(*info).PathBuffer as *const _ as *const u16;\n+            let subst_off = (*info).SubstituteNameOffset / 2;\n+            let subst_ptr = path_buffer.offset(subst_off as isize);\n+            let subst_len = (*info).SubstituteNameLength / 2;\n+            let subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n+\n+            Ok(PathBuf::from(OsString::from_wide(subst)))\n+        }\n+    }\n }\n \n impl FromInner<libc::HANDLE> for File {\n@@ -285,27 +364,30 @@ pub fn to_utf16(s: &Path) -> Vec<u16> {\n }\n \n impl FileAttr {\n-    pub fn is_dir(&self) -> bool {\n-        self.data.dwFileAttributes & c::FILE_ATTRIBUTE_DIRECTORY != 0\n-    }\n-    pub fn is_file(&self) -> bool {\n-        !self.is_dir()\n-    }\n     pub fn size(&self) -> u64 {\n         ((self.data.nFileSizeHigh as u64) << 32) | (self.data.nFileSizeLow as u64)\n     }\n+\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { attrs: self.data.dwFileAttributes }\n     }\n \n-    pub fn accessed(&self) -> u64 { self.to_ms(&self.data.ftLastAccessTime) }\n-    pub fn modified(&self) -> u64 { self.to_ms(&self.data.ftLastWriteTime) }\n+    pub fn attrs(&self) -> u32 { self.data.dwFileAttributes as u32 }\n+\n+    pub fn file_type(&self) -> FileType {\n+        FileType::new(self.data.dwFileAttributes, self.is_symlink)\n+    }\n+\n+    pub fn created(&self) -> u64 { self.to_u64(&self.data.ftCreationTime) }\n+    pub fn accessed(&self) -> u64 { self.to_u64(&self.data.ftLastAccessTime) }\n+    pub fn modified(&self) -> u64 { self.to_u64(&self.data.ftLastWriteTime) }\n \n-    fn to_ms(&self, ft: &libc::FILETIME) -> u64 {\n-        // FILETIME is in 100ns intervals and there are 10000 intervals in a\n-        // millisecond.\n-        let bits = (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32);\n-        bits / 10000\n+    fn to_u64(&self, ft: &libc::FILETIME) -> u64 {\n+        (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32)\n+    }\n+\n+    fn is_reparse_point(&self) -> bool {\n+        self.data.dwFileAttributes & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0\n     }\n }\n \n@@ -323,6 +405,26 @@ impl FilePermissions {\n     }\n }\n \n+impl FileType {\n+    fn new(attrs: libc::DWORD, is_symlink: bool) -> FileType {\n+        if attrs & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+            if is_symlink {\n+                FileType::Symlink\n+            } else {\n+                FileType::ReparsePoint\n+            }\n+        } else if attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0 {\n+            FileType::Dir\n+        } else {\n+            FileType::File\n+        }\n+    }\n+\n+    pub fn is_dir(&self) -> bool { *self == FileType::Dir }\n+    pub fn is_file(&self) -> bool { *self == FileType::File }\n+    pub fn is_symlink(&self) -> bool { *self == FileType::Symlink }\n+}\n+\n pub fn mkdir(p: &Path) -> io::Result<()> {\n     let p = to_utf16(p);\n     try!(cvt(unsafe {\n@@ -374,40 +476,8 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let mut opts = OpenOptions::new();\n-    opts.read(true);\n-    opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT as i32);\n-    let file = try!(File::open(p, &opts));\n-\n-    let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-    let mut bytes = 0;\n-\n-    unsafe {\n-        try!(cvt({\n-            c::DeviceIoControl(file.handle.raw(),\n-                               c::FSCTL_GET_REPARSE_POINT,\n-                               0 as *mut _,\n-                               0,\n-                               space.as_mut_ptr() as *mut _,\n-                               space.len() as libc::DWORD,\n-                               &mut bytes,\n-                               0 as *mut _)\n-        }));\n-        let buf: *const c::REPARSE_DATA_BUFFER = space.as_ptr() as *const _;\n-        if (*buf).ReparseTag != c::IO_REPARSE_TAG_SYMLINK {\n-            return Err(io::Error::new(io::ErrorKind::Other, \"not a symlink\"))\n-        }\n-        let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n-                &(*buf).rest as *const _ as *const _;\n-        let path_buffer = &(*info).PathBuffer as *const _ as *const u16;\n-        let subst_off = (*info).SubstituteNameOffset / 2;\n-        let subst_ptr = path_buffer.offset(subst_off as isize);\n-        let subst_len = (*info).SubstituteNameLength / 2;\n-        let subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n-\n-        Ok(PathBuf::from(OsString::from_wide(subst)))\n-    }\n-\n+    let file = try!(File::open_reparse_point(p));\n+    file.readlink()\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n@@ -435,12 +505,28 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = to_utf16(p);\n+    let attr = try!(lstat(p));\n+    if attr.data.dwFileAttributes & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+        let opts = OpenOptions::new();\n+        let file = try!(File::open(p, &opts));\n+        file.file_attr()\n+    } else {\n+        Ok(attr)\n+    }\n+}\n+\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    let utf16 = to_utf16(p);\n     unsafe {\n         let mut attr: FileAttr = mem::zeroed();\n-        try!(cvt(c::GetFileAttributesExW(p.as_ptr(),\n+        try!(cvt(c::GetFileAttributesExW(utf16.as_ptr(),\n                                          c::GetFileExInfoStandard,\n                                          &mut attr.data as *mut _ as *mut _)));\n+        if attr.is_reparse_point() {\n+            attr.is_symlink = File::open_reparse_point(p).map(|f| {\n+                f.is_symlink()\n+            }).unwrap_or(false);\n+        }\n         Ok(attr)\n     }\n }\n@@ -465,3 +551,17 @@ pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n     }));\n     Ok(())\n }\n+\n+pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n+    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n+\n+    let mut opts = OpenOptions::new();\n+    opts.read(true);\n+    let f = try!(File::open(p, &opts));\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n+                                  libc::VOLUME_NAME_DOS)\n+    }, |buf| {\n+        PathBuf::from(OsString::from_wide(buf))\n+    })\n+}"}, {"sha": "362439c146912dae5f05ebcd51de749e8d90e22d", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 23, "deletions": 70, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/9348700007c6ac913df97c8e9e1ab7df6f91f130/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=9348700007c6ac913df97c8e9e1ab7df6f91f130", "patch": "@@ -15,12 +15,13 @@\n #include <stdlib.h>\n \n #if !defined(__WIN32__)\n-#include <sys/time.h>\n-#include <sys/types.h>\n #include <dirent.h>\n+#include <pthread.h>\n #include <signal.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n #include <unistd.h>\n-#include <pthread.h>\n #else\n #include <windows.h>\n #include <wincrypt.h>\n@@ -41,44 +42,31 @@\n //include valgrind.h after stdint.h so that uintptr_t is defined for msys2 w64\n #include \"valgrind/valgrind.h\"\n \n-#ifdef __APPLE__\n-#if (TARGET_OS_IPHONE)\n-extern char **environ;\n-#endif\n-#endif\n-\n-#if defined(__FreeBSD__) || defined(__linux__) || defined(__ANDROID__) || \\\n-    defined(__DragonFly__) || defined(__Bitrig__) || defined(__OpenBSD__)\n-extern char **environ;\n-#endif\n-\n-#if defined(__WIN32__)\n-char**\n-rust_env_pairs() {\n-    return 0;\n-}\n-#else\n-char**\n-rust_env_pairs() {\n-#if defined(__APPLE__) && !(TARGET_OS_IPHONE)\n-    char **environ = *_NSGetEnviron();\n-#endif\n-    return environ;\n-}\n-#endif\n-\n+#ifndef _WIN32\n char*\n-#if defined(__WIN32__)\n-rust_list_dir_val(WIN32_FIND_DATA* entry_ptr) {\n-    return entry_ptr->cFileName;\n-}\n-#else\n rust_list_dir_val(struct dirent* entry_ptr) {\n     return entry_ptr->d_name;\n }\n+\n+int\n+rust_dir_get_mode(struct dirent* entry_ptr) {\n+#if defined(_DIRENT_HAVE_D_TYPE)\n+    switch (entry_ptr->d_type) {\n+        case DT_BLK: return S_IFBLK;\n+        case DT_CHR: return S_IFCHR;\n+        case DT_FIFO: return S_IFIFO;\n+        case DT_LNK: return S_IFLNK;\n+        case DT_REG: return S_IFREG;\n+        case DT_SOCK: return S_IFSOCK;\n+    }\n #endif\n+    return -1;\n+}\n \n-#ifndef _WIN32\n+ino_t\n+rust_dir_get_ino(struct dirent* entry_ptr) {\n+    return entry_ptr->d_ino;\n+}\n \n DIR*\n rust_opendir(char *dirname) {\n@@ -94,21 +82,6 @@ int\n rust_dirent_t_size() {\n     return sizeof(struct dirent);\n }\n-\n-#else\n-\n-void\n-rust_opendir() {\n-}\n-\n-void\n-rust_readdir() {\n-}\n-\n-void\n-rust_dirent_t_size() {\n-}\n-\n #endif\n \n uintptr_t\n@@ -173,26 +146,6 @@ rust_valgrind_stack_deregister(unsigned int id) {\n   VALGRIND_STACK_DEREGISTER(id);\n }\n \n-#if defined(__WIN32__)\n-\n-void\n-rust_unset_sigprocmask() {\n-    // empty stub for windows to keep linker happy\n-}\n-\n-#else\n-\n-void\n-rust_unset_sigprocmask() {\n-    // this can't be safely converted to rust code because the\n-    // representation of sigset_t is platform-dependent\n-    sigset_t sset;\n-    sigemptyset(&sset);\n-    sigprocmask(SIG_SETMASK, &sset, NULL);\n-}\n-\n-#endif\n-\n #if defined(__DragonFly__)\n #include <errno.h>\n // In DragonFly __error() is an inline function and as such"}]}