{"sha": "69322d941032202b7d5308dbe16e31b62c752cd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MzIyZDk0MTAzMjIwMmI3ZDUzMDhkYmUxNmUzMWI2MmM3NTJjZDI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-16T20:57:42Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-20T17:28:50Z"}, "message": "Allow traits to use builtin kinds as supertraits for #7083.", "tree": {"sha": "1595f456d8033e1ce595a9efe137f586ae7c0c38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1595f456d8033e1ce595a9efe137f586ae7c0c38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69322d941032202b7d5308dbe16e31b62c752cd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69322d941032202b7d5308dbe16e31b62c752cd2", "html_url": "https://github.com/rust-lang/rust/commit/69322d941032202b7d5308dbe16e31b62c752cd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69322d941032202b7d5308dbe16e31b62c752cd2/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "369f7fa169d9f97ac8185105201182781076a90d", "url": "https://api.github.com/repos/rust-lang/rust/commits/369f7fa169d9f97ac8185105201182781076a90d", "html_url": "https://github.com/rust-lang/rust/commit/369f7fa169d9f97ac8185105201182781076a90d"}], "stats": {"total": 211, "additions": 119, "deletions": 92}, "files": [{"sha": "9eb09806bc07dc0ea6e12bae27951225772564a3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=69322d941032202b7d5308dbe16e31b62c752cd2", "patch": "@@ -375,9 +375,21 @@ pub fn get_trait_def(cdata: cmd,\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n                                      tag_items_data_item_ty_param_bounds);\n     let rp = item_ty_region_param(item_doc);\n+    let mut bounds = ty::EmptyBuiltinBounds();\n+    // Collect the builtin bounds from the encoded supertraits.\n+    // FIXME(#8559): They should be encoded directly.\n+    do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+        // NB. Bypasses real supertraits. See get_supertraits() if you wanted them.\n+        let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n+        do tcx.lang_items.to_builtin_kind(trait_ref.def_id).map_move |bound| {\n+            bounds.add(bound);\n+        };\n+        true\n+    };\n     ty::TraitDef {\n         generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param: rp},\n+        bounds: bounds,\n         trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n     }\n }\n@@ -929,7 +941,13 @@ pub fn get_supertraits(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n     do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n-        results.push(@doc_trait_ref(trait_doc, tcx, cdata));\n+        // NB. Only reads the ones that *aren't* builtin-bounds. See also\n+        // get_trait_def() for collecting the builtin bounds.\n+        // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n+        let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n+        if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_none() {\n+            results.push(@trait_ref);\n+        }\n         true\n     };\n     return results;"}, {"sha": "6a999a0c2662801df8a1e1d0b31d86aa836576ec", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=69322d941032202b7d5308dbe16e31b62c752cd2", "patch": "@@ -1076,6 +1076,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        // FIXME(#8559): This should use the tcx's supertrait cache instead of\n+        // reading the AST's list, because the former has already filtered out\n+        // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n         for ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);"}, {"sha": "edea267d22686c70ed6d8e2388c7869c8463b9f9", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=69322d941032202b7d5308dbe16e31b62c752cd2", "patch": "@@ -50,8 +50,6 @@ use syntax::visit::Visitor;\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-pub static try_adding: &'static str = \"Try adding a move\";\n-\n #[deriving(Clone)]\n pub struct Context {\n     tcx: ty::ctxt,\n@@ -77,9 +75,6 @@ impl Visitor<Context> for KindAnalysisVisitor {\n     fn visit_item(&mut self, i:@item, e:Context) {\n         check_item(self, i, e);\n     }\n-    fn visit_block(&mut self, b:&Block, e:Context) {\n-        check_block(self, b, e);\n-    }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n@@ -125,46 +120,47 @@ fn check_struct_safe_for_destructor(cx: Context,\n     }\n }\n \n-fn check_block(visitor: &mut KindAnalysisVisitor,\n-               block: &Block,\n-               cx: Context) {\n-    visit::walk_block(visitor, block, cx);\n+fn check_impl_of_trait(cx: Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n+    let ast_trait_def = cx.tcx.def_map.find(&trait_ref.ref_id)\n+                            .expect(\"trait ref not in def map!\");\n+    let trait_def_id = ast_util::def_id_of_def(*ast_trait_def);\n+    let trait_def = cx.tcx.trait_defs.find(&trait_def_id)\n+                        .expect(\"trait def not in trait-defs map!\");\n+\n+    // If this trait has builtin-kind supertraits, meet them.\n+    let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n+    error!(\"checking impl with self type %?\", ty::get(self_ty).sty);\n+    do check_builtin_bounds(cx, self_ty, trait_def.bounds) |missing| {\n+        cx.tcx.sess.span_err(self_type.span,\n+            fmt!(\"the type `%s', which does not fulfill `%s`, cannot implement this \\\n+                  trait\", ty_to_str(cx.tcx, self_ty), missing.user_string(cx.tcx)));\n+        cx.tcx.sess.span_note(self_type.span,\n+            fmt!(\"types implementing this trait must fulfill `%s`\",\n+                 trait_def.bounds.user_string(cx.tcx)));\n+    }\n+\n+    // If this is a destructor, check kinds.\n+    if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n+        match self_type.node {\n+            ty_path(_, ref bounds, path_node_id) => {\n+                assert!(bounds.is_none());\n+                let struct_def = cx.tcx.def_map.get_copy(&path_node_id);\n+                let struct_did = ast_util::def_id_of_def(struct_def);\n+                check_struct_safe_for_destructor(cx, self_type.span, struct_did);\n+            }\n+            _ => {\n+                cx.tcx.sess.span_bug(self_type.span,\n+                    \"the self type for the Drop trait impl is not a path\");\n+            }\n+        }\n+    }\n }\n \n fn check_item(visitor: &mut KindAnalysisVisitor, item: @item, cx: Context) {\n-    // If this is a destructor, check kinds.\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n-                match cx.tcx.def_map.find(&trait_ref.ref_id) {\n-                    None => cx.tcx.sess.bug(\"trait ref not in def map!\"),\n-                    Some(&trait_def) => {\n-                        let trait_def_id = ast_util::def_id_of_def(trait_def);\n-                        if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n-                            // Yes, it's a destructor.\n-                            match self_type.node {\n-                                ty_path(_, ref bounds, path_node_id) => {\n-                                    assert!(bounds.is_none());\n-                                    let struct_def = cx.tcx.def_map.get_copy(\n-                                        &path_node_id);\n-                                    let struct_did =\n-                                        ast_util::def_id_of_def(struct_def);\n-                                    check_struct_safe_for_destructor(\n-                                        cx,\n-                                        self_type.span,\n-                                        struct_did);\n-                                }\n-                                _ => {\n-                                    cx.tcx.sess.span_bug(self_type.span,\n-                                                         \"the self type for \\\n-                                                          the Drop trait \\\n-                                                          impl is not a \\\n-                                                          path\");\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+                check_impl_of_trait(cx, item, trait_ref, self_type);\n             }\n             _ => {}\n         }"}, {"sha": "47e2937ca8a8a048210cf459e65c5a703ba99d4c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=69322d941032202b7d5308dbe16e31b62c752cd2", "patch": "@@ -23,6 +23,7 @@\n use driver::session::Session;\n use metadata::csearch::each_lang_item;\n use metadata::cstore::iter_crate_data;\n+use middle::ty::{BuiltinBound, BoundFreeze, BoundSend, BoundSized};\n use syntax::ast::{Crate, def_id, MetaItem};\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n@@ -158,10 +159,16 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn is_builtin_kind(&self, id: def_id) -> bool {\n-        Some(id) == self.freeze_trait() ||\n-        Some(id) == self.send_trait() ||\n-        Some(id) == self.sized_trait()\n+    pub fn to_builtin_kind(&self, id: def_id) -> Option<BuiltinBound> {\n+        if Some(id) == self.freeze_trait() {\n+            Some(BoundFreeze)\n+        } else if Some(id) == self.send_trait() {\n+            Some(BoundSend)\n+        } else if Some(id) == self.sized_trait() {\n+            Some(BoundSized)\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn freeze_trait(&self) -> Option<def_id> {"}, {"sha": "757f05c208b0e8684a8f9562eb771995a8237529", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=69322d941032202b7d5308dbe16e31b62c752cd2", "patch": "@@ -863,6 +863,7 @@ pub struct ty_param_bounds_and_ty {\n /// As `ty_param_bounds_and_ty` but for a trait ref.\n pub struct TraitDef {\n     generics: Generics,\n+    bounds: BuiltinBounds,\n     trait_ref: @ty::TraitRef,\n }\n \n@@ -3725,10 +3726,23 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n     return ret;\n }\n \n-pub fn trait_ref_is_builtin_kind(tcx: ctxt, tr: &ast::trait_ref) -> bool {\n+pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::trait_ref) -> ast::def_id {\n     let def = tcx.def_map.find(&tr.ref_id).expect(\"no def-map entry for trait\");\n-    let def_id = ast_util::def_id_of_def(*def);\n-    tcx.lang_items.is_builtin_kind(def_id)\n+    ast_util::def_id_of_def(*def)\n+}\n+\n+pub fn try_add_builtin_trait(tcx: ctxt,\n+                             trait_def_id: ast::def_id,\n+                             builtin_bounds: &mut BuiltinBounds) -> bool {\n+    //! Checks whether `trait_ref` refers to one of the builtin\n+    //! traits, like `Send`, and adds the corresponding\n+    //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n+    //! is a builtin trait.\n+\n+    match tcx.lang_items.to_builtin_kind(trait_def_id) {\n+        Some(bound) => { builtin_bounds.add(bound); true }\n+        None => false\n+    }\n }\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {"}, {"sha": "db76d75a5a58303d61e96744f360256929f55834", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=69322d941032202b7d5308dbe16e31b62c752cd2", "patch": "@@ -773,9 +773,8 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n                     ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                             ast::def_trait(trait_did) => {\n-                                if try_add_builtin_trait(tcx,\n-                                                         trait_did,\n-                                                         &mut builtin_bounds) {\n+                                if ty::try_add_builtin_trait(tcx, trait_did,\n+                                                             &mut builtin_bounds) {\n                                     loop; // success\n                                 }\n                             }\n@@ -807,26 +806,3 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n         (&None, ty::RegionTraitStore(*)) => ty::EmptyBuiltinBounds(),\n     }\n }\n-\n-pub fn try_add_builtin_trait(tcx: ty::ctxt,\n-                             trait_def_id: ast::def_id,\n-                             builtin_bounds: &mut ty::BuiltinBounds) -> bool {\n-    //! Checks whether `trait_ref` refers to one of the builtin\n-    //! traits, like `Send`, and adds the corresponding\n-    //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n-    //! is a builtin trait.\n-\n-    let li = &tcx.lang_items;\n-    if Some(trait_def_id) == li.send_trait() {\n-        builtin_bounds.add(ty::BoundSend);\n-        true\n-    } else if Some(trait_def_id) == li.freeze_trait() {\n-        builtin_bounds.add(ty::BoundFreeze);\n-        true\n-    } else if Some(trait_def_id) == li.sized_trait() {\n-        builtin_bounds.add(ty::BoundSized);\n-        true\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "a22879654e810b9d6b7b83d87ea83d41b36539b2", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69322d941032202b7d5308dbe16e31b62c752cd2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=69322d941032202b7d5308dbe16e31b62c752cd2", "patch": "@@ -398,28 +398,39 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n                           ast_trait_refs: &[ast::trait_ref],\n-                          generics: &ast::Generics)\n+                          generics: &ast::Generics) -> ty::BuiltinBounds\n {\n     let tcx = ccx.tcx;\n-    if tcx.supertraits.contains_key(&local_def(id)) { return; }\n+\n+    // Called only the first time trait_def_of_item is called.\n+    // Supertraits are ensured at the same time.\n+    assert!(!tcx.supertraits.contains_key(&local_def(id)));\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n+    let mut bounds = ty::EmptyBuiltinBounds();\n     for ast_trait_ref in ast_trait_refs.iter() {\n+        let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n+        // FIXME(#8559): Need to instantiate the trait_ref whether or not it's a\n+        // builtin trait, so that the trait's node id appears in the tcx trait_ref\n+        // map. This is only needed for metadata; see the similar fixme in encoder.rs.\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n-\n-        // FIXME(#5527) Could have same trait multiple times\n-        if ty_trait_refs.iter().any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n-            // This means a trait inherited from the same supertrait more\n-            // than once.\n-            tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n-            break;\n-        } else {\n-            ty_trait_refs.push(trait_ref);\n+        if !ty::try_add_builtin_trait(ccx.tcx, trait_def_id, &mut bounds) {\n+\n+            // FIXME(#5527) Could have same trait multiple times\n+            if ty_trait_refs.iter().any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n+                // This means a trait inherited from the same supertrait more\n+                // than once.\n+                tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n+                break;\n+            } else {\n+                ty_trait_refs.push(trait_ref);\n+            }\n         }\n     }\n     tcx.supertraits.insert(local_def(id), @ty_trait_refs);\n+    bounds\n }\n \n /**\n@@ -870,20 +881,19 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                   parent_visibility);\n         for t in opt_trait_ref.iter() {\n             // Prevent the builtin kind traits from being manually implemented.\n-            if ty::trait_ref_is_builtin_kind(ccx.tcx, t) {\n-                ccx.tcx.sess.span_err(it.span,\n+            let trait_def_id = ty::trait_ref_to_def_id(tcx, t);\n+            if tcx.lang_items.to_builtin_kind(trait_def_id).is_some() {\n+                tcx.sess.span_err(it.span,\n                     \"cannot provide an explicit implementation \\\n                      for a builtin kind\");\n             }\n \n             check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n-      ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n-          let trait_def = trait_def_of_item(ccx, it);\n-          tcx.trait_defs.insert(local_def(it.id), trait_def);\n+      ast::item_trait(ref generics, _, ref trait_methods) => {\n+          let _trait_def = trait_def_of_item(ccx, it);\n           ensure_trait_methods(ccx, it.id);\n-          ensure_supertraits(ccx, it.id, it.span, rp, *supertraits, generics);\n \n           let (_, provided_methods) =\n               split_trait_methods(*trait_methods);\n@@ -1039,13 +1049,16 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n     }\n     let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n     match it.node {\n-        ast::item_trait(ref generics, _, _) => {\n+        ast::item_trait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n             let (ty_generics, substs) = mk_item_substs(ccx, generics, rp,\n                                                        Some(self_ty));\n+            let bounds = ensure_supertraits(ccx, it.id, it.span, rp,\n+                                            *supertraits, generics);\n             let trait_ref = @ty::TraitRef {def_id: def_id,\n                                            substs: substs};\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n+                                           bounds: bounds,\n                                            trait_ref: trait_ref};\n             tcx.trait_defs.insert(def_id, trait_def);\n             return trait_def;\n@@ -1225,7 +1238,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                 TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n-                    if !astconv::try_add_builtin_trait(\n+                    if !ty::try_add_builtin_trait(\n                         ccx.tcx, trait_ref.def_id,\n                         &mut param_bounds.builtin_bounds)\n                     {"}]}