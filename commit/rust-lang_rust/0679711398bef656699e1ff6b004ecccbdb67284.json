{"sha": "0679711398bef656699e1ff6b004ecccbdb67284", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2Nzk3MTEzOThiZWY2NTY2OTllMWZmNmIwMDRlY2NjYmRiNjcyODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-02T15:40:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-02T15:40:26Z"}, "message": "Auto merge of #42938 - est31:col_number, r=eddyb\n\nOutput column number info when panicking\n\nOutputs the column number when panicking. Useful when you e.g. have code like `foo[i] = bar[k] + bar[l]` and you get a panic with index out of bounds, or when you have an expression like `a = b + c + d + e` and the addition overflows. Now you know which operation to blame!\n\nThe format is `file:line:column`, just like for compiler errors. Example output with the patch:\n\n```\nthread 'main' panicked at 'index out of bounds: the len is 5 but the index is 8', src/main.rs:3:8\n```\n\nAs some of the API between the compiler and the library landscape gets broken, this is a bit hackier than I'd originally wanted it to be.\n\n* `panic` and `panic_bounds_check` lang items got an additional column param, on stage0 I still have to use the previous version. After a SNAP this should be resolved.\n* For `#[derive(RustcDeserialze)]`, stage0 requires a fixed signature for `std::rt::begin_panic`, so we can't change it right away. What we need to do instead is to keep the signature, and add a `begin_panic_new` function that we use in later stages instead. After a SNAP we can change the `begin_panic` function and rely on it instead of `begin_panic_new`, and one SNAP later we can remove `begin_panic_new`.\n* Fortunately I didn't have to break anything about the panic hook API, I could easily extend it.\n\nNote that debuginfo remains unchanged, so RUST_BACKTRACE output won't contain any column info. See issue #42921 for discussion on including the column in debuginfo.", "tree": {"sha": "80e99dd904fb4c6548d8d6f6dceb95e77c74bdc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80e99dd904fb4c6548d8d6f6dceb95e77c74bdc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0679711398bef656699e1ff6b004ecccbdb67284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0679711398bef656699e1ff6b004ecccbdb67284", "html_url": "https://github.com/rust-lang/rust/commit/0679711398bef656699e1ff6b004ecccbdb67284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0679711398bef656699e1ff6b004ecccbdb67284/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a992167c51d30a2b21da7a20d8c3077a2ec0093", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a992167c51d30a2b21da7a20d8c3077a2ec0093", "html_url": "https://github.com/rust-lang/rust/commit/2a992167c51d30a2b21da7a20d8c3077a2ec0093"}, {"sha": "3b91f9406cd4b00ef09d19aca8203ce3539a202d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b91f9406cd4b00ef09d19aca8203ce3539a202d", "html_url": "https://github.com/rust-lang/rust/commit/3b91f9406cd4b00ef09d19aca8203ce3539a202d"}], "stats": {"total": 210, "additions": 150, "deletions": 60}, "files": [{"sha": "2d42903ad0a7d48b4bf342d50e492137d8e1e853", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -157,7 +157,7 @@ dependencies = [\n [[package]]\n name = \"cargo\"\n version = \"0.21.0\"\n-source = \"git+https://github.com/rust-lang/cargo#854bc167bbf74053f821f65cb86d506033f3d3a7\"\n+source = \"git+https://github.com/rust-lang/cargo#eb6cf012a6cc23c9c89c4009564de9fccc38b9cb\"\n replace = \"cargo 0.21.0\"\n \n [[package]]"}, {"sha": "a2368ee5f4ac53f7a45e9c4fcbaba3752038ac4e", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -143,7 +143,8 @@ pub extern fn rust_eh_unwind_resume() {\n #[no_mangle]\n pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n                                _file: &'static str,\n-                               _line: u32) -> ! {\n+                               _line: u32,\n+                               _column: u32) -> ! {\n     unsafe { intrinsics::abort() }\n }\n ```\n@@ -187,7 +188,8 @@ pub extern fn rust_eh_unwind_resume() {\n #[no_mangle]\n pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n                                _file: &'static str,\n-                               _line: u32) -> ! {\n+                               _line: u32,\n+                               _column: u32) -> ! {\n     unsafe { intrinsics::abort() }\n }\n ```"}, {"sha": "97aaaffe8bc88909ff21401664f1077a3e199d20", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -36,12 +36,12 @@\n //!   These functions are often provided by the system libc, but can also be\n //!   provided by the [rlibc crate](https://crates.io/crates/rlibc).\n //!\n-//! * `rust_begin_panic` - This function takes three arguments, a\n-//!   `fmt::Arguments`, a `&'static str`, and a `u32`. These three arguments\n+//! * `rust_begin_panic` - This function takes four arguments, a\n+//!   `fmt::Arguments`, a `&'static str`, and two `u32`'s. These four arguments\n //!   dictate the panic message, the file at which panic was invoked, and the\n-//!   line. It is up to consumers of this core library to define this panic\n-//!   function; it is only required to never return. This requires a `lang`\n-//!   attribute named `panic_fmt`.\n+//!   line and column inside the file. It is up to consumers of this core\n+//!   library to define this panic function; it is only required to never\n+//!   return. This requires a `lang` attribute named `panic_fmt`.\n //!\n //! * `rust_eh_personality` - is used by the failure mechanisms of the\n //!    compiler. This is often mapped to GCC's personality function, but crates"}, {"sha": "70820dce5f9409013daf6092959e3a1bc862fb95", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -17,16 +17,18 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     );\n     ($msg:expr) => ({\n-        static _MSG_FILE_LINE: (&'static str, &'static str, u32) = ($msg, file!(), line!());\n-        $crate::panicking::panic(&_MSG_FILE_LINE)\n+        static _MSG_FILE_LINE_COL: (&'static str, &'static str, u32, u32) =\n+            ($msg, file!(), line!(), column!());\n+        $crate::panicking::panic(&_MSG_FILE_LINE_COL)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n         // The leading _'s are to avoid dead code warnings if this is\n         // used inside a dead function. Just `#[allow(dead_code)]` is\n         // insufficient, since the user may have\n         // `#[forbid(dead_code)]` and which cannot be overridden.\n-        static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+        static _MSG_FILE_LINE_COL: (&'static str, u32, u32) =\n+            (file!(), line!(), column!());\n+        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_MSG_FILE_LINE_COL)\n     });\n }\n "}, {"sha": "f5a7e78d0faa04eae9715425f017237f0a699a13", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -17,7 +17,7 @@\n //!\n //! ```\n //! # use std::fmt;\n-//! fn panic_impl(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> !\n+//! fn panic_impl(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> !\n //! # { loop {} }\n //! ```\n //!\n@@ -39,34 +39,55 @@\n use fmt;\n \n #[cold] #[inline(never)] // this is the slow path, always\n-#[lang = \"panic\"]\n-pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n+#[cfg_attr(not(stage0), lang = \"panic\")]\n+pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n     // reduce size overhead. The format_args! macro uses str's Display trait to\n     // write expr, which calls Formatter::pad, which must accommodate string\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n+    let (expr, file, line, col) = *expr_file_line_col;\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n+}\n+\n+// FIXME: remove when SNAP\n+#[cold] #[inline(never)]\n+#[cfg(stage0)]\n+#[lang = \"panic\"]\n+pub fn panic_old(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n     let (expr, file, line) = *expr_file_line;\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line))\n+    let expr_file_line_col = (expr, file, line, 0);\n+    panic(&expr_file_line_col)\n+}\n+\n+#[cold] #[inline(never)]\n+#[cfg_attr(not(stage0), lang = \"panic_bounds_check\")]\n+fn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n+                     index: usize, len: usize) -> ! {\n+    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n+                           len, index), file_line_col)\n }\n \n+// FIXME: remove when SNAP\n #[cold] #[inline(never)]\n+#[cfg(stage0)]\n #[lang = \"panic_bounds_check\"]\n-fn panic_bounds_check(file_line: &(&'static str, u32),\n+fn panic_bounds_check_old(file_line: &(&'static str, u32),\n                      index: usize, len: usize) -> ! {\n+    let (file, line) = *file_line;\n     panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n-                           len, index), file_line)\n+                           len, index), &(file, line, 0))\n }\n \n #[cold] #[inline(never)]\n-pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n+pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n     #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n         #[unwind]\n-        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32) -> !;\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32, col: u32) -> !;\n     }\n-    let (file, line) = *file_line;\n-    unsafe { panic_impl(fmt, file, line) }\n+    let (file, line, col) = *file_line_col;\n+    unsafe { panic_impl(fmt, file, line, col) }\n }"}, {"sha": "48b166c61deb17323bd228e88f65cf10d00027af", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -28,6 +28,7 @@ use type_of;\n use type_::Type;\n \n use syntax::symbol::Symbol;\n+use syntax_pos::Pos;\n \n use std::cmp;\n \n@@ -333,6 +334,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n+                let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args, const_err) = match *msg {\n@@ -347,29 +349,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     index: index as u64\n                                 }));\n \n-                        let file_line = C_struct(bcx.ccx, &[filename, line], false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line));\n-                        let file_line = consts::addr_of(bcx.ccx,\n-                                                        file_line,\n-                                                        align,\n-                                                        \"panic_bounds_check_loc\");\n+                        let file_line_col = C_struct(bcx.ccx, &[filename, line, col], false);\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line_col));\n+                        let file_line_col = consts::addr_of(bcx.ccx,\n+                                                            file_line_col,\n+                                                            align,\n+                                                            \"panic_bounds_check_loc\");\n                         (lang_items::PanicBoundsCheckFnLangItem,\n-                         vec![file_line, index, len],\n+                         vec![file_line_col, index, len],\n                          const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = Symbol::intern(err.description()).as_str();\n                         let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line = C_struct(bcx.ccx,\n-                                                     &[msg_str, filename, line],\n+                        let msg_file_line_col = C_struct(bcx.ccx,\n+                                                     &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line));\n-                        let msg_file_line = consts::addr_of(bcx.ccx,\n-                                                            msg_file_line,\n-                                                            align,\n-                                                            \"panic_loc\");\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n+                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                                                                msg_file_line_col,\n+                                                                align,\n+                                                                \"panic_loc\");\n                         (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line],\n+                         vec![msg_file_line_col],\n                          Some(ErrKind::Math(err.clone())))\n                     }\n                 };"}, {"sha": "6eb9faacf7fbe4f392ca2609291e520ec8865c7b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -41,10 +41,10 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        $crate::rt::begin_panic($msg, {\n+        $crate::rt::begin_panic_new($msg, {\n             // static requires less code at runtime, more constant data\n-            static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-            &_FILE_LINE\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            &_FILE_LINE_COL\n         })\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n@@ -53,8 +53,8 @@ macro_rules! panic {\n             // used inside a dead function. Just `#[allow(dead_code)]` is\n             // insufficient, since the user may have\n             // `#[forbid(dead_code)]` and which cannot be overridden.\n-            static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-            &_FILE_LINE\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            &_FILE_LINE_COL\n         })\n     });\n }"}, {"sha": "494376b831ed6c87076aa525a23030bc1130641b", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -262,6 +262,7 @@ impl<'a> PanicInfo<'a> {\n pub struct Location<'a> {\n     file: &'a str,\n     line: u32,\n+    col: u32,\n }\n \n impl<'a> Location<'a> {\n@@ -308,6 +309,29 @@ impl<'a> Location<'a> {\n     pub fn line(&self) -> u32 {\n         self.line\n     }\n+\n+    /// Returns the column from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// #![feature(panic_col)]\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occured at column {}\", location.column());\n+    ///     } else {\n+    ///         println!(\"panic occured but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[unstable(feature = \"panic_col\", reason = \"recently added\", issue = \"42939\")]\n+    pub fn column(&self) -> u32 {\n+        self.col\n+    }\n }\n \n fn default_hook(info: &PanicInfo) {\n@@ -329,6 +353,7 @@ fn default_hook(info: &PanicInfo) {\n \n     let file = info.location.file;\n     let line = info.location.line;\n+    let col = info.location.col;\n \n     let msg = match info.payload.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n@@ -342,8 +367,8 @@ fn default_hook(info: &PanicInfo) {\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n     let write = |err: &mut ::io::Write| {\n-        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}\",\n-                         name, msg, file, line);\n+        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}:{}\",\n+                         name, msg, file, line, col);\n \n         #[cfg(feature = \"backtrace\")]\n         {\n@@ -467,8 +492,9 @@ pub fn panicking() -> bool {\n #[unwind]\n pub extern fn rust_begin_panic(msg: fmt::Arguments,\n                                file: &'static str,\n-                               line: u32) -> ! {\n-    begin_panic_fmt(&msg, &(file, line))\n+                               line: u32,\n+                               col: u32) -> ! {\n+    begin_panic_fmt(&msg, &(file, line, col))\n }\n \n /// The entry point for panicking with a formatted message.\n@@ -482,7 +508,7 @@ pub extern fn rust_begin_panic(msg: fmt::Arguments,\n            issue = \"0\")]\n #[inline(never)] #[cold]\n pub fn begin_panic_fmt(msg: &fmt::Arguments,\n-                       file_line: &(&'static str, u32)) -> ! {\n+                       file_line_col: &(&'static str, u32, u32)) -> ! {\n     use fmt::Write;\n \n     // We do two allocations here, unfortunately. But (a) they're\n@@ -492,7 +518,39 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments,\n \n     let mut s = String::new();\n     let _ = s.write_fmt(*msg);\n-    begin_panic(s, file_line)\n+    begin_panic_new(s, file_line_col)\n+}\n+\n+// FIXME: In PR #42938, we have added the column as info passed to the panic\n+// handling code. For this, we want to break the ABI of begin_panic.\n+// This is not possible to do directly, as the stage0 compiler is hardcoded\n+// to emit a call to begin_panic in src/libsyntax/ext/build.rs, only\n+// with the file and line number being passed, but not the colum number.\n+// By changing the compiler source, we can only affect behaviour of higher\n+// stages. We need to perform the switch over two stage0 replacements, using\n+// a temporary function begin_panic_new while performing the switch:\n+// 0. Right now, we tell stage1 onward to emit a call to begin_panic_new.\n+// 1. In the first SNAP, stage0 calls begin_panic_new with the new ABI,\n+//    begin_panic stops being used. Now we can change begin_panic to\n+//    the new ABI, and start emitting calls to begin_panic in higher\n+//    stages again, this time with the new ABI.\n+// 2. After the second SNAP, stage0 calls begin_panic with the new ABI,\n+//    and we can remove the temporary begin_panic_new function.\n+\n+/// This is the entry point of panicking for panic!() and assert!().\n+#[unstable(feature = \"libstd_sys_internals\",\n+           reason = \"used by the panic! macro\",\n+           issue = \"0\")]\n+#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+pub fn begin_panic_new<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    // Note that this should be the only allocation performed in this code path.\n+    // Currently this means that panic!() on OOM will invoke this code path,\n+    // but then again we're not really ready for panic on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this thread instead of the thread that's\n+    // panicking.\n+\n+    rust_panic_with_hook(Box::new(msg), file_line_col)\n }\n \n /// This is the entry point of panicking for panic!() and assert!().\n@@ -508,7 +566,10 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> !\n     // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n \n-    rust_panic_with_hook(Box::new(msg), file_line)\n+    let (file, line) = *file_line;\n+    let file_line_col = (file, line, 0);\n+\n+    rust_panic_with_hook(Box::new(msg), &file_line_col)\n }\n \n /// Executes the primary logic for a panic, including checking for recursive\n@@ -520,8 +581,8 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> !\n #[inline(never)]\n #[cold]\n fn rust_panic_with_hook(msg: Box<Any + Send>,\n-                        file_line: &(&'static str, u32)) -> ! {\n-    let (file, line) = *file_line;\n+                        file_line_col: &(&'static str, u32, u32)) -> ! {\n+    let (file, line, col) = *file_line_col;\n \n     let panics = update_panic_count(1);\n \n@@ -540,8 +601,9 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n         let info = PanicInfo {\n             payload: &*msg,\n             location: Location {\n-                file: file,\n-                line: line,\n+                file,\n+                line,\n+                col,\n             },\n         };\n         HOOK_LOCK.read();"}, {"sha": "2ee63527c147cfd739f93b04939abb2557103ce2", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -25,7 +25,7 @@\n \n \n // Reexport some of our utilities which are expected by other crates.\n-pub use panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n+pub use panicking::{begin_panic_new, begin_panic, begin_panic_fmt, update_panic_count};\n \n #[cfg(not(test))]\n #[lang = \"start\"]"}, {"sha": "412a34932087d52a9bbbabb4794baaeb9590b2c4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0679711398bef656699e1ff6b004ecccbdb67284/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -11,7 +11,7 @@\n use abi::Abi;\n use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Pos, Span, DUMMY_SP};\n use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n@@ -768,14 +768,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n-        let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n-        let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n+        let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);\n+        let expr_loc_tuple = self.expr_tuple(span, vec![expr_file, expr_line, expr_col]);\n+        let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n-            self.std_path(&[\"rt\", \"begin_panic\"]),\n+            self.std_path(&[\"rt\", \"begin_panic_new\"]),\n             vec![\n                 self.expr_str(span, msg),\n-                expr_file_line_ptr])\n+                expr_loc_ptr])\n     }\n \n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {"}, {"sha": "eb6cf012a6cc23c9c89c4009564de9fccc38b9cb", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=0679711398bef656699e1ff6b004ecccbdb67284", "patch": "@@ -1 +1 @@\n-Subproject commit d2d6e675fcb70cfb91c2cf2fad8cdd345c120316\n+Subproject commit eb6cf012a6cc23c9c89c4009564de9fccc38b9cb"}]}