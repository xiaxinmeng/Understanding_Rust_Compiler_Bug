{"sha": "97767238814fd4bd3ce8a3972184b29fefb4923e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NzY3MjM4ODE0ZmQ0YmQzY2U4YTM5NzIxODRiMjlmZWZiNDkyM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-05T08:51:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-05T08:51:38Z"}, "message": "Auto merge of #62800 - albins:polonius-initialization-1, r=nikomatsakis\n\nExtend Polonius fact generation for (some) move tracking\n\nThis PR will extend rustc to emit facts used for tracking moves and initialization in Polonius. It is most likely the final part of my master's thesis work.", "tree": {"sha": "22cf4bd23ddabf723ac19136de656522e1a59ff3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22cf4bd23ddabf723ac19136de656522e1a59ff3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97767238814fd4bd3ce8a3972184b29fefb4923e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97767238814fd4bd3ce8a3972184b29fefb4923e", "html_url": "https://github.com/rust-lang/rust/commit/97767238814fd4bd3ce8a3972184b29fefb4923e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97767238814fd4bd3ce8a3972184b29fefb4923e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a24f636e60a5da57ab641d800ac5952bbde98b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/a24f636e60a5da57ab641d800ac5952bbde98b65", "html_url": "https://github.com/rust-lang/rust/commit/a24f636e60a5da57ab641d800ac5952bbde98b65"}, {"sha": "28312b5b0604444b5806cfb42ea11a1be14098ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/28312b5b0604444b5806cfb42ea11a1be14098ac", "html_url": "https://github.com/rust-lang/rust/commit/28312b5b0604444b5806cfb42ea11a1be14098ac"}], "stats": {"total": 596, "additions": 323, "deletions": 273}, "files": [{"sha": "6a5d4ebc1ecdbaf2a0685e315c4ccfeb0ac6b93e", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -2324,9 +2324,9 @@ checksum = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f6b8a5defa2aef9ba4999aaa745fbc01c622ecea35964a306adc3e44be4f3b5b\"\n+checksum = \"50fa9dbfd0d3d60594da338cfe6f94028433eecae4b11b7e83fd99759227bbfe\"\n dependencies = [\n  \"datafrog\",\n  \"log\","}, {"sha": "a479fabafc014202760dc3ff67196de40ab07dd0", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -21,7 +21,7 @@ scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon = \"0.2.0\"\n rustc-rayon-core = \"0.2.0\"\n-polonius-engine  = \"0.9.0\"\n+polonius-engine  = \"0.10.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }"}, {"sha": "1c0b0b63c0bbd05ac7558512f5e1bb94b79bd966", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -15,7 +15,7 @@ either = \"1.5.0\"\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n log = \"0.4\"\n log_settings = \"0.1.1\"\n-polonius-engine  = \"0.9.0\"\n+polonius-engine  = \"0.10.0\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "4400e0c8395a205b82ffa0ac4c00212b39eb938b", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -12,7 +12,7 @@ use crate::borrow_check::location::LocationIndex;\n use polonius_engine::Output;\n \n use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::HasMoveData;\n+use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n use crate::dataflow::MaybeUninitializedPlaces;\n@@ -21,7 +21,7 @@ use either::Either;\n use std::fmt;\n use std::rc::Rc;\n \n-crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local>;\n+crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n \n // (forced to be `pub` due to its use as an associated type below.)\n crate struct Flows<'b, 'tcx> {"}, {"sha": "f0beb4d3ae32d773e4afc09aa9a6a07b02f5c589", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n-use crate::dataflow::indexes::BorrowIndex;\n+use crate::dataflow::indexes::{BorrowIndex, MovePathIndex};\n use polonius_engine::AllFacts as PoloniusAllFacts;\n use polonius_engine::Atom;\n use rustc::mir::Local;\n@@ -11,7 +11,7 @@ use std::fs::{self, File};\n use std::io::Write;\n use std::path::Path;\n \n-crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex, Local>;\n+crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n \n crate trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n@@ -58,14 +58,17 @@ impl AllFactsExt for AllFacts {\n                 cfg_edge,\n                 killed,\n                 outlives,\n-                region_live_at,\n                 invalidates,\n                 var_used,\n                 var_defined,\n                 var_drop_used,\n                 var_uses_region,\n                 var_drops_region,\n-                var_initialized_on_exit,\n+                child,\n+                path_belongs_to_var,\n+                initialized_at,\n+                moved_out_at,\n+                path_accessed_at,\n             ])\n         }\n         Ok(())\n@@ -84,6 +87,12 @@ impl Atom for LocationIndex {\n     }\n }\n \n+impl Atom for MovePathIndex {\n+    fn index(self) -> usize {\n+        Idx::index(self)\n+    }\n+}\n+\n struct FactWriter<'w> {\n     location_table: &'w LocationTable,\n     dir: &'w Path,"}, {"sha": "1ff3228afa376fc198b77732948152ac56b65b2c", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -4,14 +4,15 @@ use crate::borrow_check::nll::facts::AllFactsExt;\n use crate::borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::MoveData;\n+use crate::dataflow::move_paths::{InitLocation, MoveData, MovePathIndex, InitKind};\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Local, Body, Promoted};\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements,\n+                 Local, Location, Body, LocalKind, BasicBlock, Promoted};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n@@ -69,6 +70,85 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     universal_regions\n }\n \n+\n+// This function populates an AllFacts instance with base facts related to\n+// MovePaths and needed for the move analysis.\n+fn populate_polonius_move_facts(\n+    all_facts: &mut AllFacts,\n+    move_data: &MoveData<'_>,\n+    location_table: &LocationTable,\n+    body: &Body<'_>) {\n+    all_facts\n+        .path_belongs_to_var\n+        .extend(\n+            move_data\n+                .rev_lookup\n+                .iter_locals_enumerated()\n+                .map(|(v, &m)| (m, v)));\n+\n+    for (child, move_path) in move_data.move_paths.iter_enumerated() {\n+        all_facts\n+            .child\n+            .extend(\n+                move_path\n+                    .parents(&move_data.move_paths)\n+                    .iter()\n+                    .map(|&parent| (child, parent)));\n+    }\n+\n+    // initialized_at\n+    for init in move_data.inits.iter() {\n+\n+        match init.location {\n+            InitLocation::Statement(location) => {\n+                let block_data = &body[location.block];\n+                let is_terminator = location.statement_index == block_data.statements.len();\n+\n+                if is_terminator && init.kind == InitKind::NonPanicPathOnly {\n+                    // We are at the terminator of an init that has a panic path,\n+                    // and where the init should not happen on panic\n+\n+                    for &successor in block_data.terminator().successors() {\n+                        if body[successor].is_cleanup {\n+                            continue;\n+                        }\n+\n+                        // The initialization happened in (or rather, when arriving at)\n+                        // the successors, but not in the unwind block.\n+                        let first_statement = Location { block: successor, statement_index: 0};\n+                        all_facts\n+                            .initialized_at\n+                            .push((init.path, location_table.start_index(first_statement)));\n+                    }\n+\n+                } else {\n+                    // In all other cases, the initialization just happens at the\n+                    // midpoint, like any other effect.\n+                    all_facts.initialized_at.push((init.path, location_table.mid_index(location)));\n+                }\n+            },\n+            // Arguments are initialized on function entry\n+            InitLocation::Argument(local) => {\n+                assert!(body.local_kind(local) == LocalKind::Arg);\n+                let fn_entry = Location {block: BasicBlock::from_u32(0u32), statement_index: 0 };\n+                all_facts.initialized_at.push((init.path, location_table.start_index(fn_entry)));\n+\n+            }\n+        }\n+    }\n+\n+\n+    // moved_out_at\n+    // deinitialisation is assumed to always happen!\n+    all_facts\n+        .moved_out_at\n+        .extend(\n+            move_data\n+                .moves\n+                .iter()\n+                .map(|mo| (mo.path, location_table.mid_index(mo.source))));\n+}\n+\n /// Computes the (non-lexical) regions from the input MIR.\n ///\n /// This may result in errors being reported.\n@@ -87,7 +167,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     errors_buffer: &mut Vec<Diagnostic>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n-    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex, Local>>>,\n+    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>>>,\n     Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     let mut all_facts = if AllFacts::enabled(infcx.tcx) {\n@@ -123,6 +203,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n+        populate_polonius_move_facts(all_facts, move_data, location_table, body);\n     }\n \n     // Create the region inference context, taking ownership of the"}, {"sha": "049d83bb22f1bc9cf48a56606bca4fdfb93adc02", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Body};\n+use rustc::mir::{Body, Local, Location};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::vec_linked_list as vll;\n \n@@ -72,16 +72,10 @@ impl LocalUseMap {\n \n         let mut locals_with_use_data: IndexVec<Local, bool> =\n             IndexVec::from_elem_n(false, body.local_decls.len());\n-        live_locals\n-            .iter()\n-            .for_each(|&local| locals_with_use_data[local] = true);\n-\n-        LocalUseMapBuild {\n-            local_use_map: &mut local_use_map,\n-            elements,\n-            locals_with_use_data,\n-        }\n-        .visit_body(body);\n+        live_locals.iter().for_each(|&local| locals_with_use_data[local] = true);\n+\n+        LocalUseMapBuild { local_use_map: &mut local_use_map, elements, locals_with_use_data }\n+            .visit_body(body);\n \n         local_use_map\n     }\n@@ -151,10 +145,8 @@ impl LocalUseMapBuild<'_> {\n         location: Location,\n     ) {\n         let point_index = elements.point_from_location(location);\n-        let appearance_index = appearances.push(Appearance {\n-            point_index,\n-            next: *first_appearance,\n-        });\n+        let appearance_index =\n+            appearances.push(Appearance { point_index, next: *first_appearance });\n         *first_appearance = Some(appearance_index);\n     }\n }"}, {"sha": "3f2ec1ba970173910e7ac85ffbc574afad7952fc", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -58,9 +58,9 @@ pub(super) fn generate<'tcx>(\n     };\n \n     if !live_locals.is_empty() {\n-        trace::trace(typeck, body, elements, flow_inits, move_data, live_locals, location_table);\n+        trace::trace(typeck, body, elements, flow_inits, move_data, live_locals);\n \n-        polonius::populate_var_liveness_facts(typeck, body, location_table);\n+        polonius::populate_access_facts(typeck, body, location_table, move_data);\n     }\n }\n "}, {"sha": "d61464b3f387d52d84f904a0592994d419f03326", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -1,22 +1,28 @@\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n+use crate::dataflow::indexes::MovePathIndex;\n+use crate::dataflow::move_paths::{LookupResult, MoveData};\n use crate::util::liveness::{categorize, DefUse};\n-use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Body, Local, Location};\n+use rustc::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n+use rustc::mir::{Body, Local, Location, Place};\n use rustc::ty::subst::Kind;\n use rustc::ty::Ty;\n \n use super::TypeChecker;\n \n type VarPointRelations = Vec<(Local, LocationIndex)>;\n+type MovePathPointRelations = Vec<(MovePathIndex, LocationIndex)>;\n \n-struct LivenessPointFactsExtractor<'me> {\n+struct UseFactsExtractor<'me> {\n     var_defined: &'me mut VarPointRelations,\n     var_used: &'me mut VarPointRelations,\n     location_table: &'me LocationTable,\n+    var_drop_used: &'me mut VarPointRelations,\n+    move_data: &'me MoveData<'me>,\n+    path_accessed_at: &'me mut MovePathPointRelations,\n }\n \n // A Visitor to walk through the MIR and extract point-wise facts\n-impl LivenessPointFactsExtractor<'_> {\n+impl UseFactsExtractor<'_> {\n     fn location_to_index(&self, location: Location) -> LocationIndex {\n         self.location_table.mid_index(location)\n     }\n@@ -30,15 +36,50 @@ impl LivenessPointFactsExtractor<'_> {\n         debug!(\"LivenessFactsExtractor::insert_use()\");\n         self.var_used.push((local, self.location_to_index(location)));\n     }\n+\n+    fn insert_drop_use(&mut self, local: Local, location: Location) {\n+        debug!(\"LivenessFactsExtractor::insert_drop_use()\");\n+        self.var_drop_used.push((local, self.location_to_index(location)));\n+    }\n+\n+    fn insert_path_access(&mut self, path: MovePathIndex, location: Location) {\n+        debug!(\"LivenessFactsExtractor::insert_path_access({:?}, {:?})\", path, location);\n+        self.path_accessed_at.push((path, self.location_to_index(location)));\n+    }\n+\n+    fn place_to_mpi(&self, place: &Place<'_>) -> Option<MovePathIndex> {\n+        match self.move_data.rev_lookup.find(place.as_ref()) {\n+            LookupResult::Exact(mpi) => Some(mpi),\n+            LookupResult::Parent(mmpi) => mmpi,\n+        }\n+    }\n }\n \n-impl Visitor<'tcx> for LivenessPointFactsExtractor<'_> {\n+impl Visitor<'tcx> for UseFactsExtractor<'_> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n         match categorize(context) {\n             Some(DefUse::Def) => self.insert_def(local, location),\n             Some(DefUse::Use) => self.insert_use(local, location),\n+            Some(DefUse::Drop) => self.insert_drop_use(local, location),\n+            _ => (),\n+        }\n+    }\n+\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, location: Location) {\n+        self.super_place(place, context, location);\n+        match context {\n+            PlaceContext::NonMutatingUse(_) => {\n+                if let Some(mpi) = self.place_to_mpi(place) {\n+                    self.insert_path_access(mpi, location);\n+                }\n+            }\n+\n+            PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n+                if let Some(mpi) = self.place_to_mpi(place) {\n+                    self.insert_path_access(mpi, location);\n+                }\n+            }\n             _ => (),\n-            // NOTE: Drop handling is now done in trace()\n         }\n     }\n }\n@@ -54,23 +95,27 @@ fn add_var_uses_regions(typeck: &mut TypeChecker<'_, 'tcx>, local: Local, ty: Ty\n     });\n }\n \n-pub(super) fn populate_var_liveness_facts(\n+pub(super) fn populate_access_facts(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     location_table: &LocationTable,\n+    move_data: &MoveData<'_>,\n ) {\n     debug!(\"populate_var_liveness_facts()\");\n \n     if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n-        LivenessPointFactsExtractor {\n+        UseFactsExtractor {\n             var_defined: &mut facts.var_defined,\n             var_used: &mut facts.var_used,\n+            var_drop_used: &mut facts.var_drop_used,\n+            path_accessed_at: &mut facts.path_accessed_at,\n             location_table,\n+            move_data,\n         }\n-        .visit_body(mir);\n+        .visit_body(body);\n     }\n \n-    for (local, local_decl) in mir.local_decls.iter_enumerated() {\n+    for (local, local_decl) in body.local_decls.iter_enumerated() {\n         add_var_uses_regions(typeck, local, local_decl.ty);\n     }\n }"}, {"sha": "9b55881cb1b10162a4e24b3d7657748b043e90b5", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 98, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -1,4 +1,3 @@\n-use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n use crate::borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n use crate::borrow_check::nll::type_check::liveness::polonius;\n@@ -38,7 +37,6 @@ pub(super) fn trace(\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     live_locals: Vec<Local>,\n-    location_table: &LocationTable,\n ) {\n     debug!(\"trace()\");\n \n@@ -52,7 +50,6 @@ pub(super) fn trace(\n         local_use_map,\n         move_data,\n         drop_data: FxHashMap::default(),\n-        location_table,\n     };\n \n     LivenessResults::new(cx).compute_for_all_locals(live_locals);\n@@ -82,9 +79,6 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     /// Index indicating where each variable is assigned, used, or\n     /// dropped.\n     local_use_map: &'me LocalUseMap,\n-\n-    /// Maps between a MIR Location and a LocationIndex\n-    location_table: &'me LocationTable,\n }\n \n struct DropData<'tcx> {\n@@ -131,12 +125,6 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         for local in live_locals {\n             self.reset_local_state();\n             self.add_defs_for(local);\n-\n-            // FIXME: this is temporary until we can generate our own initialization\n-            if self.cx.typeck.borrowck_context.all_facts.is_some() {\n-                self.add_polonius_var_initialized_on_exit_for(local)\n-            }\n-\n             self.compute_use_live_points_for(local);\n             self.compute_drop_live_points_for(local);\n \n@@ -157,63 +145,6 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n     }\n \n-    // WARNING: panics if self.cx.typeck.borrowck_context.all_facts != None\n-    //\n-    // FIXME: this analysis (the initialization tracking) should be\n-    // done in Polonius, but isn't yet.\n-    fn add_polonius_var_initialized_on_exit_for(&mut self, local: Local) {\n-        let move_path = self.cx.move_data.rev_lookup.find_local(local);\n-        let facts = self.cx.typeck.borrowck_context.all_facts.as_mut().unwrap();\n-        for block in self.cx.body.basic_blocks().indices() {\n-            debug!(\"polonius: generating initialization facts for {:?} in {:?}\", local, block);\n-\n-            // iterate through the block, applying the effects of each statement\n-            // up to and including location, and populate `var_initialized_on_exit`\n-            self.cx.flow_inits.reset_to_entry_of(block);\n-            let start_location = Location { block, statement_index: 0 };\n-            self.cx.flow_inits.apply_local_effect(start_location);\n-\n-            for statement_index in 0..self.cx.body[block].statements.len() {\n-                let current_location = Location { block, statement_index };\n-\n-                self.cx.flow_inits.reconstruct_statement_effect(current_location);\n-\n-                // statement has not yet taken effect:\n-                if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                    facts\n-                        .var_initialized_on_exit\n-                        .push((local, self.cx.location_table.start_index(current_location)));\n-                }\n-\n-                // statement has now taken effect\n-                self.cx.flow_inits.apply_local_effect(current_location);\n-\n-                if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                    facts\n-                        .var_initialized_on_exit\n-                        .push((local, self.cx.location_table.mid_index(current_location)));\n-                }\n-            }\n-\n-            let terminator_location = self.cx.body.terminator_loc(block);\n-\n-            if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                facts\n-                    .var_initialized_on_exit\n-                    .push((local, self.cx.location_table.start_index(terminator_location)));\n-            }\n-\n-            // apply the effects of the terminator and push it if needed\n-            self.cx.flow_inits.reset_to_exit_of(block);\n-\n-            if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                facts\n-                    .var_initialized_on_exit\n-                    .push((local, self.cx.location_table.mid_index(terminator_location)));\n-            }\n-        }\n-    }\n-\n     /// Clear the value of fields that are \"per local variable\".\n     fn reset_local_state(&mut self) {\n         self.defs.clear();\n@@ -273,11 +204,6 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             debug_assert_eq!(self.cx.body.terminator_loc(location.block), location,);\n \n             if self.cx.initialized_at_terminator(location.block, mpi) {\n-                // FIXME: this analysis (the initialization tracking) should be\n-                // done in Polonius, but isn't yet.\n-                if let Some(facts) = self.cx.typeck.borrowck_context.all_facts {\n-                    facts.var_drop_used.push((local, self.cx.location_table.mid_index(location)));\n-                }\n                 if self.drop_live_at.insert(drop_point) {\n                     self.drop_locations.push(location);\n                     self.stack.push(drop_point);\n@@ -468,13 +394,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n-        Self::make_all_regions_live(\n-            self.elements,\n-            &mut self.typeck,\n-            value,\n-            live_at,\n-            self.location_table,\n-        )\n+        Self::make_all_regions_live(self.elements, &mut self.typeck, value, live_at)\n     }\n \n     /// Some variable with type `live_ty` is \"drop live\" at `location`\n@@ -525,13 +445,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         // All things in the `outlives` array may be touched by\n         // the destructor and must be live at this point.\n         for &kind in &drop_data.dropck_result.kinds {\n-            Self::make_all_regions_live(\n-                self.elements,\n-                &mut self.typeck,\n-                kind,\n-                live_at,\n-                self.location_table,\n-            );\n+            Self::make_all_regions_live(self.elements, &mut self.typeck, kind, live_at);\n \n             polonius::add_var_drops_regions(&mut self.typeck, dropped_local, &kind);\n         }\n@@ -542,7 +456,6 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         typeck: &mut TypeChecker<'_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n         live_at: &HybridBitSet<PointIndex>,\n-        location_table: &LocationTable,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!(\n@@ -559,15 +472,6 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n                 .constraints\n                 .liveness_constraints\n                 .add_elements(live_region_vid, live_at);\n-\n-            // FIXME: remove this when we can generate our own region-live-at reliably\n-            if let Some(facts) = typeck.borrowck_context.all_facts {\n-                for point in live_at.iter() {\n-                    let loc = elements.to_location(point);\n-                    facts.region_live_at.push((live_region_vid, location_table.start_index(loc)));\n-                    facts.region_live_at.push((live_region_vid, location_table.mid_index(loc)));\n-                }\n-            }\n         });\n     }\n "}, {"sha": "d97f3b7417286806ca73f824fdacffb39988b660", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -11,7 +11,7 @@\n //! `a[x]` would still overlap them both. But that is not this\n //! representation does today.)\n \n-use rustc::mir::{Local, PlaceElem, Operand, ProjectionElem};\n+use rustc::mir::{Local, Operand, PlaceElem, ProjectionElem};\n use rustc::ty::Ty;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -26,36 +26,36 @@ pub trait Lift {\n }\n impl<'tcx> Lift for Operand<'tcx> {\n     type Abstract = AbstractOperand;\n-    fn lift(&self) -> Self::Abstract { AbstractOperand }\n+    fn lift(&self) -> Self::Abstract {\n+        AbstractOperand\n+    }\n }\n impl Lift for Local {\n     type Abstract = AbstractOperand;\n-    fn lift(&self) -> Self::Abstract { AbstractOperand }\n+    fn lift(&self) -> Self::Abstract {\n+        AbstractOperand\n+    }\n }\n impl<'tcx> Lift for Ty<'tcx> {\n     type Abstract = AbstractType;\n-    fn lift(&self) -> Self::Abstract { AbstractType }\n+    fn lift(&self) -> Self::Abstract {\n+        AbstractType\n+    }\n }\n impl<'tcx> Lift for PlaceElem<'tcx> {\n     type Abstract = AbstractElem;\n     fn lift(&self) -> Self::Abstract {\n         match *self {\n-            ProjectionElem::Deref =>\n-                ProjectionElem::Deref,\n-            ProjectionElem::Field(ref f, ty) =>\n-                ProjectionElem::Field(f.clone(), ty.lift()),\n-            ProjectionElem::Index(ref i) =>\n-                ProjectionElem::Index(i.lift()),\n-            ProjectionElem::Subslice {from, to} =>\n-                ProjectionElem::Subslice { from: from, to: to },\n-            ProjectionElem::ConstantIndex {offset,min_length,from_end} =>\n-                ProjectionElem::ConstantIndex {\n-                    offset,\n-                    min_length,\n-                    from_end,\n-                },\n-            ProjectionElem::Downcast(a, u) =>\n-                ProjectionElem::Downcast(a, u.clone()),\n+            ProjectionElem::Deref => ProjectionElem::Deref,\n+            ProjectionElem::Field(ref f, ty) => ProjectionElem::Field(f.clone(), ty.lift()),\n+            ProjectionElem::Index(ref i) => ProjectionElem::Index(i.lift()),\n+            ProjectionElem::Subslice { from, to } => {\n+                ProjectionElem::Subslice { from: from, to: to }\n+            }\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end }\n+            }\n+            ProjectionElem::Downcast(a, u) => ProjectionElem::Downcast(a, u.clone()),\n         }\n     }\n }"}, {"sha": "81451c2500c471bd1f9ca7bb7c9993a8f2fa420c", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 102, "deletions": 98, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -1,16 +1,18 @@\n-use rustc::ty::{self, TyCtxt};\n-use rustc::mir::*;\n use rustc::mir::tcx::RvalueInitializationState;\n-use rustc_data_structures::indexed_vec::{IndexVec};\n-use smallvec::{SmallVec, smallvec};\n+use rustc::mir::*;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use smallvec::{smallvec, SmallVec};\n \n use std::collections::hash_map::Entry;\n use std::mem;\n \n use super::abs_domain::Lift;\n-use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, MoveOut, MoveOutIndex};\n-use super::{MoveError, InitIndex, Init, InitLocation, LookupResult, InitKind};\n use super::IllegalMoveOriginKind::*;\n+use super::{Init, InitIndex, InitKind, InitLocation, LookupResult, MoveError};\n+use super::{\n+    LocationMap, MoveData, MoveOut, MoveOutIndex, MovePath, MovePathIndex, MovePathLookup,\n+};\n \n struct MoveDataBuilder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n@@ -33,43 +35,42 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(body),\n                 rev_lookup: MovePathLookup {\n-                    locals: body.local_decls.indices().map(|i| {\n-                        Self::new_move_path(\n-                            &mut move_paths,\n-                            &mut path_map,\n-                            &mut init_path_map,\n-                            None,\n-                            Place::from(i),\n-                        )\n-                    }).collect(),\n+                    locals: body\n+                        .local_decls\n+                        .indices()\n+                        .map(|i| {\n+                            Self::new_move_path(\n+                                &mut move_paths,\n+                                &mut path_map,\n+                                &mut init_path_map,\n+                                None,\n+                                Place::from(i),\n+                            )\n+                        })\n+                        .collect(),\n                     projections: Default::default(),\n                 },\n                 move_paths,\n                 path_map,\n                 inits: IndexVec::new(),\n                 init_loc_map: LocationMap::new(body),\n                 init_path_map,\n-            }\n+            },\n         }\n     }\n \n-    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n-                     path_map: &mut IndexVec<MovePathIndex, SmallVec<[MoveOutIndex; 4]>>,\n-                     init_path_map: &mut IndexVec<MovePathIndex, SmallVec<[InitIndex; 4]>>,\n-                     parent: Option<MovePathIndex>,\n-                     place: Place<'tcx>)\n-                     -> MovePathIndex\n-    {\n-        let move_path = move_paths.push(MovePath {\n-            next_sibling: None,\n-            first_child: None,\n-            parent,\n-            place,\n-        });\n+    fn new_move_path(\n+        move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n+        path_map: &mut IndexVec<MovePathIndex, SmallVec<[MoveOutIndex; 4]>>,\n+        init_path_map: &mut IndexVec<MovePathIndex, SmallVec<[InitIndex; 4]>>,\n+        parent: Option<MovePathIndex>,\n+        place: Place<'tcx>,\n+    ) -> MovePathIndex {\n+        let move_path =\n+            move_paths.push(MovePath { next_sibling: None, first_child: None, parent, place });\n \n         if let Some(parent) = parent {\n-            let next_sibling =\n-                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n+            let next_sibling = mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n             move_paths[move_path].next_sibling = next_sibling;\n         }\n \n@@ -91,9 +92,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// problematic for borrowck.\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, place: &Place<'tcx>)\n-                     -> Result<MovePathIndex, MoveError<'tcx>>\n-    {\n+    fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n         place.iterate(|place_base, place_projection| {\n             let mut base = match place_base {\n@@ -108,39 +107,46 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 let tcx = self.builder.tcx;\n                 let place_ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n                 match place_ty.sty {\n-                    ty::Ref(..) | ty::RawPtr(..) =>\n+                    ty::Ref(..) | ty::RawPtr(..) => {\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n                             BorrowedContent {\n                                 target_place: Place {\n                                     base: place_base.clone(),\n                                     projection: Some(Box::new(proj.clone())),\n-                                }\n-                            })),\n-                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                        return Err(MoveError::cannot_move_out_of(self.loc,\n-                                                                 InteriorOfTypeWithDestructor {\n-                            container_ty: place_ty\n-                        })),\n+                                },\n+                            },\n+                        ));\n+                    }\n+                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() => {\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            InteriorOfTypeWithDestructor { container_ty: place_ty },\n+                        ));\n+                    }\n                     // move out of union - always move the entire union\n-                    ty::Adt(adt, _) if adt.is_union() =>\n-                        return Err(MoveError::UnionMove { path: base }),\n-                    ty::Slice(_) =>\n+                    ty::Adt(adt, _) if adt.is_union() => {\n+                        return Err(MoveError::UnionMove { path: base });\n+                    }\n+                    ty::Slice(_) => {\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n                             InteriorOfSliceOrArray {\n-                                ty: place_ty, is_index: match proj.elem {\n+                                ty: place_ty,\n+                                is_index: match proj.elem {\n                                     ProjectionElem::Index(..) => true,\n-                                    _ => false\n+                                    _ => false,\n                                 },\n-                            })),\n+                            },\n+                        ));\n+                    }\n                     ty::Array(..) => match proj.elem {\n-                        ProjectionElem::Index(..) =>\n+                        ProjectionElem::Index(..) => {\n                             return Err(MoveError::cannot_move_out_of(\n                                 self.loc,\n-                                InteriorOfSliceOrArray {\n-                                    ty: place_ty, is_index: true\n-                                })),\n+                                InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n+                            ));\n+                        }\n                         _ => {\n                             // FIXME: still badly broken\n                         }\n@@ -186,7 +192,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn finalize(\n-        self\n+        self,\n     ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         debug!(\"{}\", {\n             debug!(\"moves for {:?}:\", self.body.span);\n@@ -200,11 +206,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             \"done dumping moves\"\n         });\n \n-        if !self.errors.is_empty() {\n-            Err((self.data, self.errors))\n-        } else {\n-            Ok(self.data)\n-        }\n+        if !self.errors.is_empty() { Err((self.data, self.errors)) } else { Ok(self.data) }\n     }\n }\n \n@@ -222,10 +224,7 @@ pub(super) fn gather_moves<'tcx>(\n             builder.gather_statement(source, stmt);\n         }\n \n-        let terminator_loc = Location {\n-            block: bb,\n-            statement_index: block.statements.len()\n-        };\n+        let terminator_loc = Location { block: bb, statement_index: block.statements.len() };\n         builder.gather_terminator(terminator_loc, block.terminator());\n     }\n \n@@ -238,11 +237,12 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             let path = self.data.rev_lookup.locals[arg];\n \n             let init = self.data.inits.push(Init {\n-                path, kind: InitKind::Deep, location: InitLocation::Argument(arg),\n+                path,\n+                kind: InitKind::Deep,\n+                location: InitLocation::Argument(arg),\n             });\n \n-            debug!(\"gather_args: adding init {:?} of {:?} for argument {:?}\",\n-                init, path, arg);\n+            debug!(\"gather_args: adding init {:?} of {:?} for argument {:?}\", init, path, arg);\n \n             self.data.init_path_map[path].push(init);\n         }\n@@ -297,26 +297,26 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             StatementKind::StorageDead(local) => {\n                 self.gather_move(&Place::from(local));\n             }\n-            StatementKind::SetDiscriminant{ .. } => {\n-                span_bug!(stmt.source_info.span,\n-                          \"SetDiscriminant should not exist during borrowck\");\n+            StatementKind::SetDiscriminant { .. } => {\n+                span_bug!(\n+                    stmt.source_info.span,\n+                    \"SetDiscriminant should not exist during borrowck\"\n+                );\n             }\n-            StatementKind::Retag { .. } |\n-            StatementKind::AscribeUserType(..) |\n-            StatementKind::Nop => {}\n+            StatementKind::Retag { .. }\n+            | StatementKind::AscribeUserType(..)\n+            | StatementKind::Nop => {}\n         }\n     }\n \n     fn gather_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n         match *rvalue {\n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::Cast(_, ref operand, _) |\n-            Rvalue::UnaryOp(_, ref operand) => {\n-                self.gather_operand(operand)\n-            }\n-            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n-            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n+            Rvalue::Use(ref operand)\n+            | Rvalue::Repeat(ref operand, _)\n+            | Rvalue::Cast(_, ref operand, _)\n+            | Rvalue::UnaryOp(_, ref operand) => self.gather_operand(operand),\n+            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs)\n+            | Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n                 self.gather_operand(lhs);\n                 self.gather_operand(rhs);\n             }\n@@ -325,11 +325,11 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     self.gather_operand(operand);\n                 }\n             }\n-            Rvalue::Ref(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n+            Rvalue::Ref(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::NullaryOp(NullOp::SizeOf, _)\n+            | Rvalue::NullaryOp(NullOp::Box, _) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always\n                 // completely initialize their place.\n@@ -346,13 +346,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n     fn gather_terminator(&mut self, term: &Terminator<'tcx>) {\n         match term.kind {\n-            TerminatorKind::Goto { target: _ } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::Abort |\n-            TerminatorKind::GeneratorDrop |\n-            TerminatorKind::FalseEdges { .. } |\n-            TerminatorKind::FalseUnwind { .. } |\n-            TerminatorKind::Unreachable => { }\n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::Unreachable => {}\n \n             TerminatorKind::Return => {\n                 self.gather_move(&Place::RETURN_PLACE);\n@@ -399,9 +399,9 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n     fn gather_operand(&mut self, operand: &Operand<'tcx>) {\n         match *operand {\n-            Operand::Constant(..) |\n-            Operand::Copy(..) => {} // not-a-move\n-            Operand::Move(ref place) => { // a move\n+            Operand::Constant(..) | Operand::Copy(..) => {} // not-a-move\n+            Operand::Move(ref place) => {\n+                // a move\n                 self.gather_move(place);\n             }\n         }\n@@ -419,8 +419,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         };\n         let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n \n-        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n-               self.loc, place, move_out, path);\n+        debug!(\n+            \"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n+            self.loc, place, move_out, path\n+        );\n \n         self.builder.data.path_map[path].push(move_out);\n         self.builder.data.loc_map[self.loc].push(move_out);\n@@ -452,8 +454,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 kind,\n             });\n \n-            debug!(\"gather_init({:?}, {:?}): adding init {:?} of {:?}\",\n-               self.loc, place, init, path);\n+            debug!(\n+                \"gather_init({:?}, {:?}): adding init {:?} of {:?}\",\n+                self.loc, place, init, path\n+            );\n \n             self.builder.data.init_path_map[path].push(init);\n             self.builder.data.init_loc_map[self.loc].push(init);"}, {"sha": "5028e9650918c5d55a3e01ca0fc2ea53f07dbe47", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97767238814fd4bd3ce8a3972184b29fefb4923e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=97767238814fd4bd3ce8a3972184b29fefb4923e", "patch": "@@ -1,9 +1,10 @@\n-use rustc::ty::{Ty, TyCtxt};\n+use core::slice::Iter;\n use rustc::mir::*;\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::{Enumerated, Idx, IndexVec};\n use smallvec::SmallVec;\n-use syntax_pos::{Span};\n+use syntax_pos::Span;\n \n use std::fmt;\n use std::ops::{Index, IndexMut};\n@@ -137,12 +138,17 @@ impl<T> IndexMut<Location> for LocationMap<T> {\n     }\n }\n \n-impl<T> LocationMap<T> where T: Default + Clone {\n+impl<T> LocationMap<T>\n+where\n+    T: Default + Clone,\n+{\n     fn new(body: &Body<'_>) -> Self {\n         LocationMap {\n-            map: body.basic_blocks().iter().map(|block| {\n-                vec![T::default(); block.statements.len()+1]\n-            }).collect()\n+            map: body\n+                .basic_blocks()\n+                .iter()\n+                .map(|block| vec![T::default(); block.statements.len() + 1])\n+                .collect(),\n         }\n     }\n }\n@@ -178,7 +184,6 @@ pub struct Init {\n     pub kind: InitKind,\n }\n \n-\n /// Initializations can be from an argument or from a statement. Arguments\n /// do not have locations, in those cases the `Local` is kept..\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -224,15 +229,15 @@ pub struct MovePathLookup {\n     /// subsequent search so that it is solely relative to that\n     /// base-place). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FxHashMap<(MovePathIndex, AbstractElem), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem), MovePathIndex>,\n }\n \n mod builder;\n \n #[derive(Copy, Clone, Debug)]\n pub enum LookupResult {\n     Exact(MovePathIndex),\n-    Parent(Option<MovePathIndex>)\n+    Parent(Option<MovePathIndex>),\n }\n \n impl MovePathLookup {\n@@ -262,6 +267,12 @@ impl MovePathLookup {\n     pub fn find_local(&self, local: Local) -> MovePathIndex {\n         self.locals[local]\n     }\n+\n+    /// An enumerated iterator of `local`s and their associated\n+    /// `MovePathIndex`es.\n+    pub fn iter_locals_enumerated(&self) -> Enumerated<Local, Iter<'_, MovePathIndex>> {\n+        self.locals.iter_enumerated()\n+    }\n }\n \n #[derive(Debug)]\n@@ -289,7 +300,7 @@ pub(crate) enum IllegalMoveOriginKind<'tcx> {\n     InteriorOfTypeWithDestructor { container_ty: Ty<'tcx> },\n \n     /// Illegal move due to attempt to move out of a slice or array.\n-    InteriorOfSliceOrArray { ty: Ty<'tcx>, is_index: bool, },\n+    InteriorOfSliceOrArray { ty: Ty<'tcx>, is_index: bool },\n }\n \n #[derive(Debug)]\n@@ -318,11 +329,15 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place {\n-                base: PlaceBase::Local(l),\n-                projection: None,\n-            } = path.place { return Some(l); }\n-            if let Some(parent) = path.parent { mpi = parent; continue } else { return None }\n+            if let Place { base: PlaceBase::Local(l), projection: None } = path.place {\n+                return Some(l);\n+            }\n+            if let Some(parent) = path.parent {\n+                mpi = parent;\n+                continue;\n+            } else {\n+                return None;\n+            }\n         }\n     }\n }"}]}