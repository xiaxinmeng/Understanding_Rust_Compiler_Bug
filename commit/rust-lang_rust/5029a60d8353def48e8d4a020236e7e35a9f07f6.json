{"sha": "5029a60d8353def48e8d4a020236e7e35a9f07f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMjlhNjBkODM1M2RlZjQ4ZThkNGEwMjAyMzZlN2UzNWE5ZjA3ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-14T16:36:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-14T16:36:52Z"}, "message": "Auto merge of #33568 - nrc:save-json-2, r=pnkfelix\n\nsave-analysis: JSON mk2\n\ncc @aochagavia\n\nr? @pnkfelix", "tree": {"sha": "bcea115af83e18a18b1379e1d4d359a0abcd380f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcea115af83e18a18b1379e1d4d359a0abcd380f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5029a60d8353def48e8d4a020236e7e35a9f07f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5029a60d8353def48e8d4a020236e7e35a9f07f6", "html_url": "https://github.com/rust-lang/rust/commit/5029a60d8353def48e8d4a020236e7e35a9f07f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5029a60d8353def48e8d4a020236e7e35a9f07f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f6eb14b28eab9824492f9f82f5f25ad56dda30a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6eb14b28eab9824492f9f82f5f25ad56dda30a", "html_url": "https://github.com/rust-lang/rust/commit/5f6eb14b28eab9824492f9f82f5f25ad56dda30a"}, {"sha": "6d6986b87a23ca3fcc62636808ce625fc228bcc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d6986b87a23ca3fcc62636808ce625fc228bcc0", "html_url": "https://github.com/rust-lang/rust/commit/6d6986b87a23ca3fcc62636808ce625fc228bcc0"}], "stats": {"total": 619, "additions": 536, "deletions": 83}, "files": [{"sha": "e7cc534c5b55537d45dce95db500d26e160e6625", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -331,7 +331,7 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n         self.record(\"type_ref\", data.span, values);\n     }\n \n-    fn typedef(&mut self, data: TypedefData) {\n+    fn typedef(&mut self, data: TypeDefData) {\n         let id = data.id.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),"}, {"sha": "2275a1c5c65f2720714d9a5861602d7bbdfc4bc3", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -62,7 +62,7 @@ pub enum Data {\n     /// Data for a tuple variant.\n     TupleVariantData(TupleVariantData),\n     /// Data for a typedef.\n-    TypeDefData(TypedefData),\n+    TypeDefData(TypeDefData),\n     /// Data for a reference to a type or trait.\n     TypeRefData(TypeRefData),\n     /// Data for a use statement.\n@@ -97,6 +97,7 @@ pub struct ExternalCrateData {\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct EnumData {\n     pub id: NodeId,\n+    pub name: String,\n     pub value: String,\n     pub qualname: String,\n     pub span: Span,\n@@ -131,6 +132,7 @@ pub struct FunctionData {\n     pub declaration: Option<DefId>,\n     pub span: Span,\n     pub scope: NodeId,\n+    pub value: String,\n }\n \n /// Data about a function call.\n@@ -205,9 +207,11 @@ pub struct MethodCallData {\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct MethodData {\n     pub id: NodeId,\n+    pub name: String,\n     pub qualname: String,\n     pub span: Span,\n     pub scope: NodeId,\n+    pub value: String,\n }\n \n /// Data for modules.\n@@ -233,6 +237,7 @@ pub struct ModRefData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructData {\n     pub span: Span,\n+    pub name: String,\n     pub id: NodeId,\n     pub ctor_id: NodeId,\n     pub qualname: String,\n@@ -243,6 +248,7 @@ pub struct StructData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructVariantData {\n     pub span: Span,\n+    pub name: String,\n     pub id: NodeId,\n     pub qualname: String,\n     pub type_value: String,\n@@ -254,6 +260,7 @@ pub struct StructVariantData {\n pub struct TraitData {\n     pub span: Span,\n     pub id: NodeId,\n+    pub name: String,\n     pub qualname: String,\n     pub scope: NodeId,\n     pub value: String\n@@ -272,8 +279,9 @@ pub struct TupleVariantData {\n \n /// Data for a typedef.\n #[derive(Debug, RustcEncodable)]\n-pub struct TypedefData {\n+pub struct TypeDefData {\n     pub id: NodeId,\n+    pub name: String,\n     pub span: Span,\n     pub qualname: String,\n     pub value: String,"}, {"sha": "18241b394cc17474986d0b9df95d53daa4d7b5dd", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -30,7 +30,7 @@ pub trait Dump {\n     fn trait_data(&mut self, TraitData) {}\n     fn tuple_variant(&mut self, TupleVariantData) {}\n     fn type_ref(&mut self, TypeRefData) {}\n-    fn typedef(&mut self, TypedefData) {}\n+    fn typedef(&mut self, TypeDefData) {}\n     fn use_data(&mut self, UseData) {}\n     fn use_glob(&mut self, UseGlobData) {}\n     fn variable(&mut self, VariableData) {}"}, {"sha": "4d79ddfe8cbe30773d94043ab9975e8299202c43", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 71, "deletions": 21, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -39,7 +39,7 @@ use syntax::ast::{self, NodeId, PatKind};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{path_to_string, ty_to_string};\n+use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n use syntax::ptr::P;\n \n use super::{escape, generated_code, SaveContext, PathCollector};\n@@ -388,18 +388,23 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         if let Some(method_data) = self.save_ctxt.get_method_data(id, name, span) {\n \n+            let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.function(method_data.clone().lower(self.tcx));\n+                    let mut data = method_data.clone();\n+                    data.value = sig_str;\n+                    self.dumper.function(data.lower(self.tcx));\n                 }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n             } else {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n                     self.dumper.method(MethodData {\n                         id: method_data.id,\n+                        name: method_data.name,\n                         span: method_data.span,\n                         scope: method_data.scope,\n                         qualname: method_data.qualname.clone(),\n+                        value: sig_str,\n                     }.lower(self.tcx));\n                 }\n             }\n@@ -455,16 +460,18 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let param_sub_spans = self.span.spans_for_ty_params(full_span,\n                                                             (generics.ty_params.len() as isize));\n         for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans) {\n+            let name = escape(self.span.snippet(param_ss));\n             // Append $id to name to make sure each one is unique\n-            let name = format!(\"{}::{}${}\",\n-                               prefix,\n-                               escape(self.span.snippet(param_ss)),\n-                               id);\n+            let qualname = format!(\"{}::{}${}\",\n+                                   prefix,\n+                                   name,\n+                                   id);\n             if !self.span.filter_generated(Some(param_ss), full_span) {\n-                self.dumper.typedef(TypedefData {\n+                self.dumper.typedef(TypeDefData {\n                     span: param_ss,\n+                    name: name,\n                     id: param.id,\n-                    qualname: name,\n+                    qualname: qualname,\n                     value: String::new()\n                 }.lower(self.tcx));\n             }\n@@ -536,18 +543,33 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.visit_expr(expr);\n     }\n \n+    // FIXME tuple structs should generate tuple-specific data.\n     fn process_struct(&mut self,\n                       item: &ast::Item,\n                       def: &ast::VariantData,\n                       ty_params: &ast::Generics) {\n+        let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-        let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n+        let val = if let ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) =\n+                    item.node {\n+            let fields_str = fields.iter()\n+                                   .enumerate()\n+                                   .map(|(i, f)| f.ident.map(|i| i.to_string())\n+                                                  .unwrap_or(i.to_string()))\n+                                   .collect::<Vec<_>>()\n+                                   .join(\", \");\n+            format!(\"{} {{ {} }}\", name, fields_str)\n+        } else {\n+            String::new()\n+        };\n+\n         if !self.span.filter_generated(sub_span, item.span) {\n             self.dumper.struct_data(StructData {\n                 span: sub_span.expect(\"No span found for struct\"),\n                 id: item.id,\n+                name: name,\n                 ctor_id: def.id(),\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n@@ -580,33 +602,49 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n \n         for variant in &enum_definition.variants {\n-            let name = &variant.node.name.name.as_str();\n+            let name = variant.node.name.name.to_string();\n             let mut qualname = enum_data.qualname.clone();\n             qualname.push_str(\"::\");\n-            qualname.push_str(name);\n-            let val = self.span.snippet(variant.span);\n+            qualname.push_str(&name);\n \n             match variant.node.data {\n-                ast::VariantData::Struct(..) => {\n+                ast::VariantData::Struct(ref fields, _) => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n+                    let fields_str = fields.iter()\n+                                           .enumerate()\n+                                           .map(|(i, f)| f.ident.map(|i| i.to_string())\n+                                                          .unwrap_or(i.to_string()))\n+                                           .collect::<Vec<_>>()\n+                                           .join(\", \");\n+                    let val = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n                         self.dumper.struct_variant(StructVariantData {\n                             span: sub_span.expect(\"No span found for struct variant\"),\n                             id: variant.node.data.id(),\n+                            name: name,\n                             qualname: qualname,\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n                             scope: enum_data.scope\n                         }.lower(self.tcx));\n                     }\n                 }\n-                _ => {\n+                ref v => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n+                    let mut val = format!(\"{}::{}\", enum_data.name, name);\n+                    if let &ast::VariantData::Tuple(ref fields, _) = v {\n+                        val.push('(');\n+                        val.push_str(&fields.iter()\n+                                            .map(|f| ty_to_string(&f.ty))\n+                                            .collect::<Vec<_>>()\n+                                            .join(\", \"));\n+                        val.push(')');\n+                    }\n                     if !self.span.filter_generated(sub_span, variant.span) {\n                         self.dumper.tuple_variant(TupleVariantData {\n                             span: sub_span.expect(\"No span found for tuple variant\"),\n                             id: variant.node.data.id(),\n-                            name: name.to_string(),\n+                            name: name,\n                             qualname: qualname,\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n@@ -672,13 +710,22 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                      generics: &ast::Generics,\n                      trait_refs: &ast::TyParamBounds,\n                      methods: &[ast::TraitItem]) {\n+        let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-        let val = self.span.snippet(item.span);\n+        let mut val = name.clone();\n+        if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n+            val.push_str(&generics_to_string(generics));\n+        }\n+        if !trait_refs.is_empty() {\n+            val.push_str(\": \");\n+            val.push_str(&bounds_to_string(trait_refs));\n+        }\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         if !self.span.filter_generated(sub_span, item.span) {\n             self.dumper.trait_data(TraitData {\n                 span: sub_span.expect(\"No span found for trait\"),\n                 id: item.id,\n+                name: name,\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n                 value: val\n@@ -908,13 +955,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.visit_pat(&p);\n \n         for &(id, ref p, immut, _) in &collector.collected_paths {\n-            let value = if immut == ast::Mutability::Immutable {\n+            let mut value = if immut == ast::Mutability::Immutable {\n                 value.to_string()\n             } else {\n                 \"<mutable>\".to_string()\n             };\n             let types = self.tcx.node_types();\n             let typ = types.get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n+            value.push_str(\": \");\n+            value.push_str(&typ);\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);\n@@ -1107,8 +1156,9 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 if !self.span.filter_generated(sub_span, item.span) {\n-                    self.dumper.typedef(TypedefData {\n+                    self.dumper.typedef(TypeDefData {\n                         span: sub_span.expect(\"No span found for typedef\"),\n+                        name: item.ident.to_string(),\n                         id: item.id,\n                         qualname: qualname.clone(),\n                         value: value\n@@ -1275,13 +1325,13 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n-                let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n+                let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);\n                 visit::walk_block(self, block);\n             }\n             ast::ExprKind::IfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n-                let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n+                let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);\n                 visit::walk_block(self, block);\n@@ -1371,7 +1421,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n \n     fn visit_local(&mut self, l: &ast::Local) {\n         self.process_macro_use(l.span, l.id);\n-        let value = self.span.snippet(l.span);\n+        let value = l.init.as_ref().map(|i| self.span.snippet(i.span)).unwrap_or(String::new());\n         self.process_var_decl(&l.pat, value);\n \n         // Just walk the initialiser and type (don't want to walk the pattern again)."}, {"sha": "dc51c41f296f20dd00b6eee37b684199ba072735", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -86,6 +86,7 @@ impl Lower for data::CratePreludeData {\n pub struct EnumData {\n     pub id: DefId,\n     pub value: String,\n+    pub name: String,\n     pub qualname: String,\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -97,6 +98,7 @@ impl Lower for data::EnumData {\n     fn lower(self, tcx: TyCtxt) -> EnumData {\n         EnumData {\n             id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n             value: self.value,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n@@ -160,6 +162,7 @@ pub struct FunctionData {\n     pub declaration: Option<DefId>,\n     pub span: SpanData,\n     pub scope: DefId,\n+    pub value: String,\n }\n \n impl Lower for data::FunctionData {\n@@ -173,6 +176,7 @@ impl Lower for data::FunctionData {\n             declaration: self.declaration,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n+            value: self.value,\n         }\n     }\n }\n@@ -268,7 +272,6 @@ pub struct MacroUseData {\n     // we use the callee span to reference the associated macro definition.\n     pub callee_span: SpanData,\n     pub scope: DefId,\n-    pub imported: bool,\n }\n \n impl Lower for data::MacroUseData {\n@@ -281,7 +284,6 @@ impl Lower for data::MacroUseData {\n             qualname: self.qualname,\n             callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n-            imported: self.imported,\n         }\n     }\n }\n@@ -312,9 +314,11 @@ impl Lower for data::MethodCallData {\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct MethodData {\n     pub id: DefId,\n+    pub name: String,\n     pub qualname: String,\n     pub span: SpanData,\n     pub scope: DefId,\n+    pub value: String,\n }\n \n impl Lower for data::MethodData {\n@@ -323,9 +327,11 @@ impl Lower for data::MethodData {\n     fn lower(self, tcx: TyCtxt) -> MethodData {\n         MethodData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             scope: make_def_id(self.scope, &tcx.map),\n             id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n+            value: self.value,\n         }\n     }\n }\n@@ -381,6 +387,7 @@ impl Lower for data::ModRefData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructData {\n     pub span: SpanData,\n+    pub name: String,\n     pub id: DefId,\n     pub ctor_id: DefId,\n     pub qualname: String,\n@@ -394,6 +401,7 @@ impl Lower for data::StructData {\n     fn lower(self, tcx: TyCtxt) -> StructData {\n         StructData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             id: make_def_id(self.id, &tcx.map),\n             ctor_id: make_def_id(self.ctor_id, &tcx.map),\n             qualname: self.qualname,\n@@ -406,6 +414,7 @@ impl Lower for data::StructData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructVariantData {\n     pub span: SpanData,\n+    pub name: String,\n     pub id: DefId,\n     pub qualname: String,\n     pub type_value: String,\n@@ -419,6 +428,7 @@ impl Lower for data::StructVariantData {\n     fn lower(self, tcx: TyCtxt) -> StructVariantData {\n         StructVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n             type_value: self.type_value,\n@@ -431,6 +441,7 @@ impl Lower for data::StructVariantData {\n #[derive(Debug, RustcEncodable)]\n pub struct TraitData {\n     pub span: SpanData,\n+    pub name: String,\n     pub id: DefId,\n     pub qualname: String,\n     pub scope: DefId,\n@@ -443,6 +454,7 @@ impl Lower for data::TraitData {\n     fn lower(self, tcx: TyCtxt) -> TraitData {\n         TraitData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n             id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -480,19 +492,21 @@ impl Lower for data::TupleVariantData {\n \n /// Data for a typedef.\n #[derive(Debug, RustcEncodable)]\n-pub struct TypedefData {\n+pub struct TypeDefData {\n     pub id: DefId,\n+    pub name: String,\n     pub span: SpanData,\n     pub qualname: String,\n     pub value: String,\n }\n \n-impl Lower for data::TypedefData {\n-    type Target = TypedefData;\n+impl Lower for data::TypeDefData {\n+    type Target = TypeDefData;\n \n-    fn lower(self, tcx: TyCtxt) -> TypedefData {\n-        TypedefData {\n+    fn lower(self, tcx: TyCtxt) -> TypeDefData {\n+        TypeDefData {\n             id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             qualname: self.qualname,\n             value: self.value,"}, {"sha": "610a9ac2ad6ca18127d2b4b1aec303b526c33568", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 385, "deletions": 41, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -10,73 +10,417 @@\n \n use std::io::Write;\n \n+use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use super::external_data::*;\n use super::dump::Dump;\n \n pub struct JsonDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n-    first: bool,\n+    result: Analysis,\n }\n \n impl<'b, W: Write> JsonDumper<'b, W> {\n     pub fn new(writer: &'b mut W) -> JsonDumper<'b, W> {\n-        if let Err(_) = write!(writer, \"[\") {\n-            error!(\"Error writing output\");\n-        }\n-        JsonDumper { output: writer, first: true }\n+        JsonDumper { output: writer, result: Analysis::new() }\n     }\n }\n \n impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n     fn drop(&mut self) {\n-        if let Err(_) = write!(self.output, \"]\") {\n+        if let Err(_) = write!(self.output, \"{}\", as_json(&self.result)) {\n             error!(\"Error writing output\");\n         }\n     }\n }\n \n macro_rules! impl_fn {\n-    ($fn_name: ident, $data_type: ident) => {\n+    ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n-            if self.first {\n-                self.first = false;\n-            } else {\n-                if let Err(_) = write!(self.output, \",\") {\n-                    error!(\"Error writing output\");\n-                }\n-            }\n-            if let Err(_) = write!(self.output, \"{}\", as_json(&data)) {\n-                error!(\"Error writing output '{}'\", as_json(&data));\n-            }\n+            self.result.$bucket.push(From::from(data));\n         }\n     }\n }\n \n impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n-    impl_fn!(crate_prelude, CratePreludeData);\n-    impl_fn!(enum_data, EnumData);\n-    impl_fn!(extern_crate, ExternCrateData);\n-    impl_fn!(impl_data, ImplData);\n-    impl_fn!(inheritance, InheritanceData);\n-    impl_fn!(function, FunctionData);\n-    impl_fn!(function_ref, FunctionRefData);\n-    impl_fn!(function_call, FunctionCallData);\n-    impl_fn!(method, MethodData);\n-    impl_fn!(method_call, MethodCallData);\n-    impl_fn!(macro_data, MacroData);\n-    impl_fn!(macro_use, MacroUseData);\n-    impl_fn!(mod_data, ModData);\n-    impl_fn!(mod_ref, ModRefData);\n-    impl_fn!(struct_data, StructData);\n-    impl_fn!(struct_variant, StructVariantData);\n-    impl_fn!(trait_data, TraitData);\n-    impl_fn!(tuple_variant, TupleVariantData);\n-    impl_fn!(type_ref, TypeRefData);\n-    impl_fn!(typedef, TypedefData);\n-    impl_fn!(use_data, UseData);\n-    impl_fn!(use_glob, UseGlobData);\n-    impl_fn!(variable, VariableData);\n-    impl_fn!(variable_ref, VariableRefData);\n+    fn crate_prelude(&mut self, data: CratePreludeData) {\n+        self.result.prelude = Some(data)\n+    }\n+\n+    impl_fn!(extern_crate, ExternCrateData, imports);\n+    impl_fn!(use_data, UseData, imports);\n+    impl_fn!(use_glob, UseGlobData, imports);\n+\n+    impl_fn!(enum_data, EnumData, defs);\n+    impl_fn!(tuple_variant, TupleVariantData, defs);\n+    impl_fn!(struct_variant, StructVariantData, defs);\n+    impl_fn!(struct_data, StructData, defs);\n+    impl_fn!(trait_data, TraitData, defs);\n+    impl_fn!(function, FunctionData, defs);\n+    impl_fn!(method, MethodData, defs);\n+    impl_fn!(macro_data, MacroData, defs);\n+    impl_fn!(mod_data, ModData, defs);\n+    impl_fn!(typedef, TypeDefData, defs);\n+    impl_fn!(variable, VariableData, defs);\n+\n+    impl_fn!(function_ref, FunctionRefData, refs);\n+    impl_fn!(function_call, FunctionCallData, refs);\n+    impl_fn!(method_call, MethodCallData, refs);\n+    impl_fn!(mod_ref, ModRefData, refs);\n+    impl_fn!(type_ref, TypeRefData, refs);\n+    impl_fn!(variable_ref, VariableRefData, refs);\n+\n+    impl_fn!(macro_use, MacroUseData, macro_refs);\n+\n+    // FIXME store this instead of throwing it away.\n+    fn impl_data(&mut self, _data: ImplData) {}\n+    fn inheritance(&mut self, _data: InheritanceData) {}\n+}\n+\n+// FIXME do we want to change ExternalData to this mode? It will break DXR.\n+// FIXME methods. The defs have information about possible overriding and the\n+// refs have decl information (e.g., a trait method where we know the required\n+// method, but not the supplied method). In both cases, we are currently\n+// ignoring it.\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Analysis {\n+    prelude: Option<CratePreludeData>,\n+    imports: Vec<Import>,\n+    defs: Vec<Def>,\n+    refs: Vec<Ref>,\n+    macro_refs: Vec<MacroRef>,\n+}\n+\n+impl Analysis {\n+    fn new() -> Analysis {\n+        Analysis {\n+            prelude: None,\n+            imports: vec![],\n+            defs: vec![],\n+            refs: vec![],\n+            macro_refs: vec![],\n+        }\n+    }\n+}\n+\n+// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n+// we use our own Id which is the same, but without the newtype.\n+#[derive(Debug, RustcEncodable)]\n+struct Id {\n+    krate: u32,\n+    index: u32,\n+}\n+\n+impl From<DefId> for Id {\n+    fn from(id: DefId) -> Id {\n+        Id {\n+            krate: id.krate,\n+            index: id.index.as_u32(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Import {\n+    kind: ImportKind,\n+    id: Id,\n+    span: SpanData,\n+    name: String,\n+    value: String,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum ImportKind {\n+    ExternCrate,\n+    Use,\n+    GlobUse,\n+}\n+\n+impl From<ExternCrateData> for Import {\n+    fn from(data: ExternCrateData) -> Import {\n+        Import {\n+            kind: ImportKind::ExternCrate,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            value: String::new(),\n+        }\n+    }\n+}\n+impl From<UseData> for Import {\n+    fn from(data: UseData) -> Import {\n+        Import {\n+            kind: ImportKind::Use,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            value: String::new(),\n+        }\n+    }\n+}\n+impl From<UseGlobData> for Import {\n+    fn from(data: UseGlobData) -> Import {\n+        Import {\n+            kind: ImportKind::GlobUse,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: \"*\".to_owned(),\n+            value: data.names.join(\", \"),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Def {\n+    kind: DefKind,\n+    id: Id,\n+    span: SpanData,\n+    name: String,\n+    qualname: String,\n+    value: String,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum DefKind {\n+    // value = variant names\n+    Enum,\n+    // value = enum name + variant name + types\n+    Tuple,\n+    // value = [enum name +] name + fields\n+    Struct,\n+    // value = signature\n+    Trait,\n+    // value = type + generics\n+    Function,\n+    // No id, no value.\n+    Macro,\n+    // value = file_name\n+    Mod,\n+    // value = aliased type\n+    Type,\n+    // value = type and init expression\n+    Variable,\n+}\n+\n+impl From<EnumData> for Def {\n+    fn from(data: EnumData) -> Def {\n+        Def {\n+            kind: DefKind::Enum,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+\n+impl From<TupleVariantData> for Def {\n+    fn from(data: TupleVariantData) -> Def {\n+        Def {\n+            kind: DefKind::Tuple,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<StructVariantData> for Def {\n+    fn from(data: StructVariantData) -> Def {\n+        Def {\n+            kind: DefKind::Struct,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<StructData> for Def {\n+    fn from(data: StructData) -> Def {\n+        Def {\n+            kind: DefKind::Struct,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<TraitData> for Def {\n+    fn from(data: TraitData) -> Def {\n+        Def {\n+            kind: DefKind::Trait,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<FunctionData> for Def {\n+    fn from(data: FunctionData) -> Def {\n+        Def {\n+            kind: DefKind::Function,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<MethodData> for Def {\n+    fn from(data: MethodData) -> Def {\n+        Def {\n+            kind: DefKind::Function,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<MacroData> for Def {\n+    fn from(data: MacroData) -> Def {\n+        Def {\n+            kind: DefKind::Macro,\n+            id: From::from(null_def_id()),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: String::new(),\n+        }\n+    }\n+}\n+impl From<ModData> for Def {\n+    fn from(data:ModData) -> Def {\n+        Def {\n+            kind: DefKind::Mod,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.filename,\n+        }\n+    }\n+}\n+impl From<TypeDefData> for Def {\n+    fn from(data: TypeDefData) -> Def {\n+        Def {\n+            kind: DefKind::Type,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+impl From<VariableData> for Def {\n+    fn from(data: VariableData) -> Def {\n+        Def {\n+            kind: DefKind::Variable,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum RefKind {\n+    Function,\n+    Mod,\n+    Type,\n+    Variable,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Ref {\n+    kind: RefKind,\n+    span: SpanData,\n+    ref_id: Id,\n+}\n+\n+impl From<FunctionRefData> for Ref {\n+    fn from(data: FunctionRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Function,\n+            span: data.span,\n+            ref_id: From::from(data.ref_id),\n+        }\n+    }\n+}\n+impl From<FunctionCallData> for Ref {\n+    fn from(data: FunctionCallData) -> Ref {\n+        Ref {\n+            kind: RefKind::Function,\n+            span: data.span,\n+            ref_id: From::from(data.ref_id),\n+        }\n+    }\n+}\n+impl From<MethodCallData> for Ref {\n+    fn from(data: MethodCallData) -> Ref {\n+        Ref {\n+            kind: RefKind::Function,\n+            span: data.span,\n+            ref_id: From::from(data.ref_id.or(data.decl_id).unwrap_or(null_def_id())),\n+        }\n+    }\n+}\n+impl From<ModRefData> for Ref {\n+    fn from(data: ModRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Mod,\n+            span: data.span,\n+            ref_id: From::from(data.ref_id.unwrap_or(null_def_id())),\n+        }\n+    }\n+}\n+impl From<TypeRefData> for Ref {\n+    fn from(data: TypeRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Type,\n+            span: data.span,\n+            ref_id: From::from(data.ref_id.unwrap_or(null_def_id())),\n+        }\n+    }\n+}\n+impl From<VariableRefData> for Ref {\n+    fn from(data: VariableRefData) -> Ref {\n+        Ref {\n+            kind: RefKind::Variable,\n+            span: data.span,\n+            ref_id: From::from(data.ref_id),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct MacroRef {\n+    span: SpanData,\n+    qualname: String,\n+    callee_span: SpanData,\n+}\n+\n+impl From<MacroUseData> for MacroRef {\n+    fn from(data: MacroUseData) -> MacroRef {\n+        MacroRef {\n+            span: data.span,\n+            qualname: data.qualname,\n+            callee_span: data.callee_span,\n+        }\n+    }\n }"}, {"sha": "8c00a5699939824f2f1882c94d1ef66ada74d37b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -52,7 +52,7 @@ use syntax::ast::{self, NodeId, PatKind};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::ty_to_string;\n+use syntax::print::pprust::{ty_to_string, arg_to_string};\n \n pub use self::csv_dumper::CsvDumper;\n pub use self::json_dumper::JsonDumper;\n@@ -122,18 +122,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n-            ast::ItemKind::Fn(..) => {\n+            ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n                 let name = self.tcx.node_path_str(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n                 filter!(self.span_utils, sub_span, item.span, None);\n+\n+\n                 Some(Data::FunctionData(FunctionData {\n                     id: item.id,\n                     name: name,\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n+                    value: make_signature(decl, generics),\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, mt, ref expr) => {\n@@ -190,16 +193,22 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     filename: filename,\n                 }))\n             }\n-            ast::ItemKind::Enum(..) => {\n-                let enum_name = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let val = self.span_utils.snippet(item.span);\n+            ast::ItemKind::Enum(ref def, _) => {\n+                let name = item.ident.to_string();\n+                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n                 filter!(self.span_utils, sub_span, item.span, None);\n+                let variants_str = def.variants.iter()\n+                                      .map(|v| v.node.name.to_string())\n+                                      .collect::<Vec<_>>()\n+                                      .join(\", \");\n+                let val = format!(\"{}::{{{}}}\", name, variants_str);\n                 Some(Data::EnumData(EnumData {\n                     id: item.id,\n+                    name: name,\n                     value: val,\n                     span: sub_span.unwrap(),\n-                    qualname: enum_name,\n+                    qualname: qualname,\n                     scope: self.enclosing_scope(item.id),\n                 }))\n             }\n@@ -353,6 +362,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             declaration: decl_id,\n             span: sub_span.unwrap(),\n             scope: self.enclosing_scope(id),\n+            // FIXME you get better data here by using the visitor.\n+            value: String::new(),\n         })\n     }\n \n@@ -637,6 +648,35 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n }\n \n+fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n+    let mut sig = String::new();\n+    if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n+        sig.push('<');\n+        sig.push_str(&generics.lifetimes.iter()\n+                              .map(|l| l.lifetime.name.to_string())\n+                              .collect::<Vec<_>>()\n+                              .join(\", \"));\n+        if !generics.lifetimes.is_empty() {\n+            sig.push_str(\", \");\n+        }\n+        sig.push_str(&generics.ty_params.iter()\n+                              .map(|l| l.ident.to_string())\n+                              .collect::<Vec<_>>()\n+                              .join(\", \"));\n+        sig.push_str(\"> \");\n+    }\n+    sig.push('(');\n+    sig.push_str(&decl.inputs.iter().map(arg_to_string).collect::<Vec<_>>().join(\", \"));\n+    sig.push(')');\n+    match decl.output {\n+        ast::FunctionRetTy::None(_) => sig.push_str(\" -> !\"),\n+        ast::FunctionRetTy::Default(_) => {}\n+        ast::FunctionRetTy::Ty(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n+    }\n+\n+    sig\n+}\n+\n // An AST visitor for collecting paths from patterns.\n struct PathCollector {\n     // The Row field identifies the kind of pattern."}, {"sha": "e9f3472c4a10ca4edc8b8bd87d5e5ea97aae0cc5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029a60d8353def48e8d4a020236e7e35a9f07f6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5029a60d8353def48e8d4a020236e7e35a9f07f6", "patch": "@@ -2030,10 +2030,7 @@ pub enum ItemKind {\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     Struct(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    Trait(Unsafety,\n-              Generics,\n-              TyParamBounds,\n-              Vec<TraitItem>),\n+    Trait(Unsafety, Generics, TyParamBounds, Vec<TraitItem>),\n \n     // Default trait implementations\n     ///"}]}