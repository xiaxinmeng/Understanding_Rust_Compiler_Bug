{"sha": "a187d6412bbcf52f2e0cdcb271b3e453520c2840", "node_id": "C_kwDOAAsO6NoAKGExODdkNjQxMmJiY2Y1MmYyZTBjZGNiMjcxYjNlNDUzNTIwYzI4NDA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-28T01:03:50Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:48:26Z"}, "message": "Merge different parent walking loops in `dereference.rs`\n\n`needless_borrow` will now walk further to find the target type.", "tree": {"sha": "50cc49143699eaf18105f62677923df71883178a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50cc49143699eaf18105f62677923df71883178a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a187d6412bbcf52f2e0cdcb271b3e453520c2840", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a187d6412bbcf52f2e0cdcb271b3e453520c2840", "html_url": "https://github.com/rust-lang/rust/commit/a187d6412bbcf52f2e0cdcb271b3e453520c2840", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a187d6412bbcf52f2e0cdcb271b3e453520c2840/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee532c02223059a5f6105b9ce423556032f1b487", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee532c02223059a5f6105b9ce423556032f1b487", "html_url": "https://github.com/rust-lang/rust/commit/ee532c02223059a5f6105b9ce423556032f1b487"}], "stats": {"total": 469, "additions": 240, "deletions": 229}, "files": [{"sha": "bb0b04b6366d46f5589f1dde936f99fa41e4f602", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 201, "deletions": 224, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/a187d6412bbcf52f2e0cdcb271b3e453520c2840/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a187d6412bbcf52f2e0cdcb271b3e453520c2840/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=a187d6412bbcf52f2e0cdcb271b3e453520c2840", "patch": "@@ -2,15 +2,13 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, variant_of_res};\n-use clippy_utils::{\n-    get_parent_expr, get_parent_node, is_lint_allowed, path_to_local, peel_hir_ty_refs, walk_to_expr_usage,\n-};\n+use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir::{\n-    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Destination, Expr, ExprKind, FnRetTy, GenericArg, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n+    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Expr, ExprKind, FnRetTy, GenericArg, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n     TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n@@ -268,8 +266,9 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         ));\n                     },\n                     RefOp::AddrOf => {\n+                        let (stability, adjustments) = walk_parents(cx, expr);\n                         // Find the number of times the borrow is auto-derefed.\n-                        let mut iter = find_adjustments(cx.tcx, typeck, expr).iter();\n+                        let mut iter = adjustments.iter();\n                         let mut deref_count = 0usize;\n                         let next_adjust = loop {\n                             match iter.next() {\n@@ -316,8 +315,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n-                            if matches!(mutability, AutoBorrowMutability::Mut { .. })\n-                                && !is_auto_reborrow_position(parent)\n+                            if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !stability.is_reborrow_stable()\n                             {\n                                 (3, 0, deref_msg)\n                             } else {\n@@ -341,7 +339,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     hir_id: expr.hir_id,\n                                 },\n                             ));\n-                        } else if is_stable_auto_deref_position(cx, expr) {\n+                        } else if stability.is_deref_stable() {\n                             self.state = Some((\n                                 State::Borrow,\n                                 StateData {\n@@ -614,164 +612,139 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n     }\n }\n \n-/// Checks if the given expression is in a position which can be auto-reborrowed.\n-/// Note: This is only correct assuming auto-deref is already occurring.\n-fn is_auto_reborrow_position(parent: Option<Node<'_>>) -> bool {\n-    match parent {\n-        Some(Node::Expr(parent)) => matches!(parent.kind, ExprKind::MethodCall(..) | ExprKind::Call(..)),\n-        Some(Node::Local(_)) => true,\n-        _ => false,\n-    }\n+/// How stable the result of auto-deref is.\n+#[derive(Clone, Copy)]\n+enum AutoDerefStability {\n+    /// Auto-deref will always choose the same type.\n+    Deref,\n+    /// Auto-deref will always reborrow a reference.\n+    Reborrow,\n+    /// Auto-deref will not occur, or it may select a different type.\n+    None,\n }\n+impl AutoDerefStability {\n+    fn is_deref_stable(self) -> bool {\n+        matches!(self, Self::Deref)\n+    }\n \n-/// Checks if the given expression is a position which can auto-borrow.\n-fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n-    if let Some(Node::Expr(parent)) = parent {\n-        match parent.kind {\n-            // ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n-            ExprKind::Field(..) => true,\n-            ExprKind::Call(f, _) => f.hir_id == child_id,\n-            _ => false,\n-        }\n-    } else {\n-        false\n+    fn is_reborrow_stable(self) -> bool {\n+        matches!(self, Self::Deref | Self::Reborrow)\n     }\n }\n \n-/// Adjustments are sometimes made in the parent block rather than the expression itself.\n-fn find_adjustments<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    typeck: &'tcx TypeckResults<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n-) -> &'tcx [Adjustment<'tcx>] {\n-    let map = tcx.hir();\n-    let mut iter = map.parent_iter(expr.hir_id);\n-    let mut prev = expr;\n-\n-    loop {\n-        match typeck.expr_adjustments(prev) {\n-            [] => (),\n-            a => break a,\n-        };\n+/// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n+/// is, and which adjustments will be applied to it. Note this will not consider auto-borrow\n+/// locations as those follow different rules.\n+fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (AutoDerefStability, &'tcx [Adjustment<'tcx>]) {\n+    let mut adjustments = [].as_slice();\n+    let stability = walk_to_expr_usage(cx, e, &mut |node, child_id| {\n+        // LocalTableInContext returns the wrong lifetime, so go use `expr_adjustments` instead.\n+        if adjustments.is_empty() && let Node::Expr(e) = cx.tcx.hir().get(child_id) {\n+            adjustments = cx.typeck_results().expr_adjustments(e);\n+        }\n+        match node {\n+            Node::Local(Local { ty: Some(ty), .. }) => Some(binding_ty_auto_deref_stability(ty)),\n+            Node::Item(&Item {\n+                kind: ItemKind::Static(..) | ItemKind::Const(..),\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Const(..),\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Const(..),\n+                ..\n+            }) => Some(AutoDerefStability::Deref),\n \n-        match iter.next().map(|(_, x)| x) {\n-            Some(Node::Block(_)) => {\n-                if let Some((_, Node::Expr(e))) = iter.next() {\n-                    prev = e;\n-                } else {\n-                    // This shouldn't happen. Blocks are always contained in an expression.\n-                    break &[];\n-                }\n-            },\n-            Some(Node::Expr(&Expr {\n-                kind: ExprKind::Break(Destination { target_id: Ok(id), .. }, _),\n+            Node::Item(&Item {\n+                kind: ItemKind::Fn(..),\n+                def_id,\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Fn(..),\n+                def_id,\n                 ..\n-            })) => {\n-                if let Some(Node::Expr(e)) = map.find(id) {\n-                    prev = e;\n-                    iter = map.parent_iter(id);\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Fn(..),\n+                def_id,\n+                ..\n+            }) => {\n+                let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n+                Some(if output.has_placeholders() || output.has_opaque_types() {\n+                    AutoDerefStability::Reborrow\n                 } else {\n-                    // This shouldn't happen. The destination should exist.\n-                    break &[];\n-                }\n+                    AutoDerefStability::Deref\n+                })\n             },\n-            _ => break &[],\n-        }\n-    }\n-}\n-\n-// Checks if the expression for the given id occurs in a position which auto dereferencing applies.\n-// Note that the target type must not be inferred in a way that may cause auto-deref to select a\n-// different type, nor may the position be the result of a macro expansion.\n-//\n-// e.g. the following should not linted\n-// macro_rules! foo { ($e:expr) => { let x: &str = $e; }}\n-// foo!(&*String::new());\n-// fn foo<T>(_: &T) {}\n-// foo(&*String::new())\n-fn is_stable_auto_deref_position<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n-    walk_to_expr_usage(cx, e, |node, child_id| match node {\n-        Node::Local(&Local { ty: Some(ty), .. }) => Some(is_binding_ty_auto_deref_stable(ty)),\n-        Node::Item(&Item {\n-            kind: ItemKind::Static(..) | ItemKind::Const(..),\n-            ..\n-        })\n-        | Node::TraitItem(&TraitItem {\n-            kind: TraitItemKind::Const(..),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Const(..),\n-            ..\n-        }) => Some(true),\n \n-        Node::Item(&Item {\n-            kind: ItemKind::Fn(..),\n-            def_id,\n-            ..\n-        })\n-        | Node::TraitItem(&TraitItem {\n-            kind: TraitItemKind::Fn(..),\n-            def_id,\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Fn(..),\n-            def_id,\n-            ..\n-        }) => {\n-            let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n-            Some(!(output.has_placeholders() || output.has_opaque_types()))\n-        },\n-\n-        Node::Expr(e) => match e.kind {\n-            ExprKind::Ret(_) => {\n-                let output = cx\n-                    .tcx\n-                    .fn_sig(cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()))\n-                    .skip_binder()\n-                    .output();\n-                Some(!(output.has_placeholders() || output.has_opaque_types()))\n-            },\n-            ExprKind::Call(func, args) => Some(\n-                args.iter()\n+            Node::Expr(e) => match e.kind {\n+                ExprKind::Ret(_) => {\n+                    let output = cx\n+                        .tcx\n+                        .fn_sig(cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()))\n+                        .skip_binder()\n+                        .output();\n+                    Some(if output.has_placeholders() || output.has_opaque_types() {\n+                        AutoDerefStability::Reborrow\n+                    } else {\n+                        AutoDerefStability::Deref\n+                    })\n+                },\n+                ExprKind::Call(func, args) => args\n+                    .iter()\n                     .position(|arg| arg.hir_id == child_id)\n                     .zip(expr_sig(cx, func))\n                     .and_then(|(i, sig)| sig.input_with_hir(i))\n-                    .map_or(false, |(hir_ty, ty)| match hir_ty {\n+                    .map(|(hir_ty, ty)| match hir_ty {\n                         // Type inference for closures can depend on how they're called. Only go by the explicit\n                         // types here.\n-                        Some(ty) => is_binding_ty_auto_deref_stable(ty),\n-                        None => is_param_auto_deref_stable(ty.skip_binder()),\n+                        Some(ty) => binding_ty_auto_deref_stability(ty),\n+                        None => param_auto_deref_stability(ty.skip_binder()),\n                     }),\n-            ),\n-            ExprKind::MethodCall(_, [_, args @ ..], _) => {\n-                let id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n-                Some(args.iter().position(|arg| arg.hir_id == child_id).map_or(false, |i| {\n-                    let arg = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n-                    is_param_auto_deref_stable(arg)\n-                }))\n-            },\n-            ExprKind::Struct(path, fields, _) => {\n-                let variant = variant_of_res(cx, cx.qpath_res(path, e.hir_id));\n-                Some(\n+                ExprKind::MethodCall(_, [_, args @ ..], _) => {\n+                    let id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n+                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n+                        let arg = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n+                        param_auto_deref_stability(arg)\n+                    })\n+                },\n+                ExprKind::MethodCall(..) => Some(AutoDerefStability::Reborrow),\n+                ExprKind::Struct(path, fields, _) => {\n+                    let variant = variant_of_res(cx, cx.qpath_res(path, e.hir_id));\n                     fields\n                         .iter()\n                         .find(|f| f.expr.hir_id == child_id)\n                         .zip(variant)\n                         .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n-                        .map_or(false, |field| is_param_auto_deref_stable(cx.tcx.type_of(field.did))),\n-                )\n+                        .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did)))\n+                },\n+                _ => None,\n             },\n             _ => None,\n-        },\n-        _ => None,\n+        }\n     })\n-    .unwrap_or(false)\n+    .unwrap_or(AutoDerefStability::None);\n+    (stability, adjustments)\n+}\n+\n+/// Checks if the given expression is a position which can auto-borrow.\n+fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n+    if let Some(Node::Expr(parent)) = parent {\n+        match parent.kind {\n+            // ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n+            ExprKind::Field(..) => true,\n+            ExprKind::Call(f, _) => f.hir_id == child_id,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n }\n \n-// Checks whether auto-dereferencing any type into a binding of the given type will definitely\n-// produce the same result.\n+// Checks the stability of auto-deref when assigned to a binding with the given explicit type.\n //\n // e.g.\n // let x = Box::new(Box::new(0u32));\n@@ -780,44 +753,49 @@ fn is_stable_auto_deref_position<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>\n //\n // Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n // switching to auto-dereferencing.\n-fn is_binding_ty_auto_deref_stable(ty: &hir::Ty<'_>) -> bool {\n-    let (ty, count) = peel_hir_ty_refs(ty);\n-    if count != 1 {\n-        return false;\n-    }\n+fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> AutoDerefStability {\n+    let TyKind::Rptr(_, ty) = &ty.kind else {\n+        return AutoDerefStability::None;\n+    };\n+    let mut ty = ty;\n \n-    match &ty.kind {\n-        TyKind::Rptr(_, ty) => is_binding_ty_auto_deref_stable(ty.ty),\n-        &TyKind::Path(\n-            QPath::TypeRelative(_, path)\n-            | QPath::Resolved(\n-                _,\n-                Path {\n-                    segments: [.., path], ..\n-                },\n-            ),\n-        ) => {\n-            if let Some(args) = path.args {\n-                args.args.iter().all(|arg| {\n-                    if let GenericArg::Type(ty) = arg {\n-                        !ty_contains_infer(ty)\n-                    } else {\n-                        true\n-                    }\n-                })\n-            } else {\n-                true\n-            }\n-        },\n-        TyKind::Slice(_)\n-        | TyKind::Array(..)\n-        | TyKind::BareFn(_)\n-        | TyKind::Never\n-        | TyKind::Tup(_)\n-        | TyKind::Ptr(_)\n-        | TyKind::TraitObject(..)\n-        | TyKind::Path(_) => true,\n-        TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::Err => false,\n+    loop {\n+        break match ty.ty.kind {\n+            TyKind::Rptr(_, ref ref_ty) => {\n+                ty = ref_ty;\n+                continue;\n+            },\n+            TyKind::Path(\n+                QPath::TypeRelative(_, path)\n+                | QPath::Resolved(\n+                    _,\n+                    Path {\n+                        segments: [.., path], ..\n+                    },\n+                ),\n+            ) => {\n+                if let Some(args) = path.args\n+                    && args.args.iter().any(|arg| match arg {\n+                        GenericArg::Infer(_) => true,\n+                        GenericArg::Type(ty) => ty_contains_infer(ty),\n+                        _ => false,\n+                    })\n+                {\n+                    AutoDerefStability::Reborrow\n+                } else {\n+                    AutoDerefStability::Deref\n+                }\n+            },\n+            TyKind::Slice(_)\n+            | TyKind::Array(..)\n+            | TyKind::BareFn(_)\n+            | TyKind::Never\n+            | TyKind::Tup(_)\n+            | TyKind::Ptr(_)\n+            | TyKind::TraitObject(..)\n+            | TyKind::Path(_) => AutoDerefStability::Deref,\n+            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::Err => AutoDerefStability::Reborrow,\n+        };\n     }\n }\n \n@@ -846,59 +824,58 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n                     segments: [.., path], ..\n                 },\n             ),\n-        ) => {\n-            if let Some(args) = path.args {\n-                args.args.iter().any(|arg| {\n-                    if let GenericArg::Type(ty) = arg {\n-                        ty_contains_infer(ty)\n-                    } else {\n-                        false\n-                    }\n-                })\n-            } else {\n-                false\n-            }\n-        },\n+        ) => path.args.map_or(false, |args| {\n+            args.args.iter().any(|arg| match arg {\n+                GenericArg::Infer(_) => true,\n+                GenericArg::Type(ty) => ty_contains_infer(ty),\n+                _ => false,\n+            })\n+        }),\n         TyKind::Path(_) | TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(_) | TyKind::Err => true,\n         TyKind::Never | TyKind::TraitObject(..) => false,\n     }\n }\n \n // Checks whether a type is stable when switching to auto dereferencing,\n-fn is_param_auto_deref_stable(ty: Ty<'_>) -> bool {\n-    let (ty, count) = peel_mid_ty_refs(ty);\n-    if count != 1 {\n-        return false;\n-    }\n+fn param_auto_deref_stability(ty: Ty<'_>) -> AutoDerefStability {\n+    let ty::Ref(_, mut ty, _) = *ty.kind() else {\n+        return AutoDerefStability::None;\n+    };\n \n-    match ty.kind() {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Foreign(_)\n-        | ty::Str\n-        | ty::Array(..)\n-        | ty::Slice(..)\n-        | ty::RawPtr(..)\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Closure(..)\n-        | ty::Generator(..)\n-        | ty::GeneratorWitness(..)\n-        | ty::Never\n-        | ty::Tuple(_)\n-        | ty::Ref(..)\n-        | ty::Projection(_) => true,\n-        ty::Infer(_)\n-        | ty::Error(_)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Opaque(..)\n-        | ty::Placeholder(_)\n-        | ty::Dynamic(..) => false,\n-        ty::Adt(..) => !(ty.has_placeholders() || ty.has_param_types_or_consts()),\n+    loop {\n+        break match *ty.kind() {\n+            ty::Ref(_, ref_ty, _) => {\n+                ty = ref_ty;\n+                continue;\n+            },\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Projection(_) => AutoDerefStability::Deref,\n+            ty::Infer(_)\n+            | ty::Error(_)\n+            | ty::Param(_)\n+            | ty::Bound(..)\n+            | ty::Opaque(..)\n+            | ty::Placeholder(_)\n+            | ty::Dynamic(..) => AutoDerefStability::Reborrow,\n+            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => AutoDerefStability::Reborrow,\n+            ty::Adt(..) => AutoDerefStability::Deref,\n+        };\n     }\n }\n "}, {"sha": "f48f2ae58dc1c6ba002ffb48ab77d98aaed226d5", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a187d6412bbcf52f2e0cdcb271b3e453520c2840/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a187d6412bbcf52f2e0cdcb271b3e453520c2840/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=a187d6412bbcf52f2e0cdcb271b3e453520c2840", "patch": "@@ -62,7 +62,18 @@ fn main() {\n         0 => &mut x,\n         _ => &mut *x,\n     };\n-\n+    let y: &mut i32 = match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => x,\n+        _ => &mut *x,\n+    };\n+    fn ref_mut_i32(_: &mut i32) {}\n+    ref_mut_i32(match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => x,\n+        _ => &mut *x,\n+    });\n+    // use 'x' after to make sure it's still usable in the fixed code.\n     *x = 5;\n \n     let s = String::new();"}, {"sha": "63515a82158961c0dcecd642c0103b608446b5c0", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a187d6412bbcf52f2e0cdcb271b3e453520c2840/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a187d6412bbcf52f2e0cdcb271b3e453520c2840/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=a187d6412bbcf52f2e0cdcb271b3e453520c2840", "patch": "@@ -62,7 +62,18 @@ fn main() {\n         0 => &mut x,\n         _ => &mut *x,\n     };\n-\n+    let y: &mut i32 = match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => &mut x,\n+        _ => &mut *x,\n+    };\n+    fn ref_mut_i32(_: &mut i32) {}\n+    ref_mut_i32(match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => &mut x,\n+        _ => &mut *x,\n+    });\n+    // use 'x' after to make sure it's still usable in the fixed code.\n     *x = 5;\n \n     let s = String::new();"}, {"sha": "cd23d9fd072a36b33fe4237e820571a9eeae1b70", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a187d6412bbcf52f2e0cdcb271b3e453520c2840/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a187d6412bbcf52f2e0cdcb271b3e453520c2840/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=a187d6412bbcf52f2e0cdcb271b3e453520c2840", "patch": "@@ -84,17 +84,29 @@ error: this expression creates a reference which is immediately dereferenced by\n LL |     let y: &mut i32 = &mut &mut x;\n    |                       ^^^^^^^^^^^ help: change this to: `x`\n \n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:67:14\n+   |\n+LL |         0 => &mut x,\n+   |              ^^^^^^ help: change this to: `x`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:73:14\n+   |\n+LL |         0 => &mut x,\n+   |              ^^^^^^ help: change this to: `x`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:74:13\n+  --> $DIR/needless_borrow.rs:85:13\n    |\n LL |     let _ = (&x).0;\n    |             ^^^^ help: change this to: `x`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:76:22\n+  --> $DIR/needless_borrow.rs:87:22\n    |\n LL |     let _ = unsafe { (&*x).0 };\n    |                      ^^^^^ help: change this to: `(*x)`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 18 previous errors\n "}]}