{"sha": "a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MTJmYmQ1MGJkN2E1NzlkNGE0NmQ0MjZlOWY4YjFjNjI3ZDRiYzQ=", "commit": {"author": {"name": "Surya Midatala", "email": "surya.midatala@protonmail.com", "date": "2020-08-23T10:23:16Z"}, "committer": {"name": "Surya Midatala", "email": "surya.midatala@protonmail.com", "date": "2020-08-26T16:13:46Z"}, "message": "Move to intra-doc links for wasi/ext/fs.rs, os_str_bytes.rs, primitive_docs.rs & poison.rs", "tree": {"sha": "e1537011b6f2dd5bb3648df6805b0598cbe88e8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1537011b6f2dd5bb3648df6805b0598cbe88e8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "html_url": "https://github.com/rust-lang/rust/commit/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/comments", "author": {"login": "kofls", "id": 12569767, "node_id": "MDQ6VXNlcjEyNTY5NzY3", "avatar_url": "https://avatars.githubusercontent.com/u/12569767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kofls", "html_url": "https://github.com/kofls", "followers_url": "https://api.github.com/users/kofls/followers", "following_url": "https://api.github.com/users/kofls/following{/other_user}", "gists_url": "https://api.github.com/users/kofls/gists{/gist_id}", "starred_url": "https://api.github.com/users/kofls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kofls/subscriptions", "organizations_url": "https://api.github.com/users/kofls/orgs", "repos_url": "https://api.github.com/users/kofls/repos", "events_url": "https://api.github.com/users/kofls/events{/privacy}", "received_events_url": "https://api.github.com/users/kofls/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kofls", "id": 12569767, "node_id": "MDQ6VXNlcjEyNTY5NzY3", "avatar_url": "https://avatars.githubusercontent.com/u/12569767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kofls", "html_url": "https://github.com/kofls", "followers_url": "https://api.github.com/users/kofls/followers", "following_url": "https://api.github.com/users/kofls/following{/other_user}", "gists_url": "https://api.github.com/users/kofls/gists{/gist_id}", "starred_url": "https://api.github.com/users/kofls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kofls/subscriptions", "organizations_url": "https://api.github.com/users/kofls/orgs", "repos_url": "https://api.github.com/users/kofls/repos", "events_url": "https://api.github.com/users/kofls/events{/privacy}", "received_events_url": "https://api.github.com/users/kofls/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ead62235a50e43b08a103d403d6fbfbc2b48352", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ead62235a50e43b08a103d403d6fbfbc2b48352", "html_url": "https://github.com/rust-lang/rust/commit/6ead62235a50e43b08a103d403d6fbfbc2b48352"}], "stats": {"total": 243, "additions": 75, "deletions": 168}, "files": [{"sha": "392c89a6ecf6386a16930fb56cee93e7685affb6", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 63, "deletions": 115, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "patch": "@@ -20,10 +20,9 @@\n /// assert!(!bool_val);\n /// ```\n ///\n-/// [`assert!`]: macro.assert.html\n-/// [`BitAnd`]: ops/trait.BitAnd.html\n-/// [`BitOr`]: ops/trait.BitOr.html\n-/// [`Not`]: ops/trait.Not.html\n+/// [`BitAnd`]: ops::BitAnd\n+/// [`BitOr`]: ops::BitOr\n+/// [`Not`]: ops::Not\n ///\n /// # Examples\n ///\n@@ -46,7 +45,7 @@\n /// }\n /// ```\n ///\n-/// Also, since `bool` implements the [`Copy`](marker/trait.Copy.html) trait, we don't\n+/// Also, since `bool` implements the [`Copy`] trait, we don't\n /// have to worry about the move semantics (just like the integer and float primitives).\n ///\n /// Now an example of `bool` cast to integer type:\n@@ -100,8 +99,7 @@ mod prim_bool {}\n /// at all we know it can never produce a value which isn't a [`u32`]. This illustrates another\n /// behaviour of the `!` type - expressions with type `!` will coerce into any other type.\n ///\n-/// [`u32`]: primitive.str.html\n-/// [`exit`]: process/fn.exit.html\n+/// [`exit`]: crate::process::exit\n ///\n /// # `!` and generics\n ///\n@@ -185,14 +183,12 @@ mod prim_bool {}\n /// ever stops, it means that an error occurred. We don't even have to wrap the loop in an `Ok`\n /// because `!` coerces to `Result<!, ConnectionError>` automatically.\n ///\n-/// [`String::from_str`]: str/trait.FromStr.html#tymethod.from_str\n-/// [`Result<String, !>`]: result/enum.Result.html\n-/// [`Result<T, !>`]: result/enum.Result.html\n-/// [`Result<!, E>`]: result/enum.Result.html\n-/// [`Ok`]: result/enum.Result.html#variant.Ok\n-/// [`String`]: string/struct.String.html\n-/// [`Err`]: result/enum.Result.html#variant.Err\n-/// [`FromStr`]: str/trait.FromStr.html\n+/// [`String::from_str`]: str::FromStr::from_str\n+/// [`Result<String, !>`]: Result\n+/// [`Result<T, !>`]: Result\n+/// [`Result<!, E>`]: Result\n+/// [`String`]: string::String\n+/// [`FromStr`]: str::FromStr\n ///\n /// # `!` and traits\n ///\n@@ -233,11 +229,9 @@ mod prim_bool {}\n /// `impl` for this which simply panics, but the same is true for any type (we could `impl\n /// Default` for (eg.) [`File`] by just making [`default()`] panic.)\n ///\n-/// [`fmt::Result`]: fmt/type.Result.html\n-/// [`File`]: fs/struct.File.html\n-/// [`Debug`]: fmt/trait.Debug.html\n-/// [`Default`]: default/trait.Default.html\n-/// [`default()`]: default/trait.Default.html#tymethod.default\n+/// [`File`]: fs::File\n+/// [`Debug`]: fmt::Debug\n+/// [`default()`]: Default::default\n ///\n #[unstable(feature = \"never_type\", issue = \"35121\")]\n mod prim_never {}\n@@ -360,7 +354,7 @@ mod prim_unit {}\n //\n /// Raw, unsafe pointers, `*const T`, and `*mut T`.\n ///\n-/// *[See also the `std::ptr` module](ptr/index.html).*\n+/// *[See also the `std::ptr` module][`crate::ptr`].*\n ///\n /// Working with raw pointers in Rust is uncommon, typically limited to a few patterns.\n /// Raw pointers can be unaligned or [`null`]. However, when a raw pointer is\n@@ -439,13 +433,13 @@ mod prim_unit {}\n /// but C APIs hand out a lot of pointers generally, so are a common source\n /// of raw pointers in Rust.\n ///\n-/// [`null`]: ../std/ptr/fn.null.html\n-/// [`null_mut`]: ../std/ptr/fn.null_mut.html\n+/// [`null`]: ptr::null\n+/// [`null_mut`]: ptr::null_mut\n /// [`is_null`]: ../std/primitive.pointer.html#method.is_null\n /// [`offset`]: ../std/primitive.pointer.html#method.offset\n-/// [`into_raw`]: ../std/boxed/struct.Box.html#method.into_raw\n-/// [`drop`]: ../std/mem/fn.drop.html\n-/// [`write`]: ../std/ptr/fn.write.html\n+/// [`into_raw`]: Box::into_raw\n+/// [`drop`]: mem::drop\n+/// [`write`]: ptr::write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_pointer {}\n \n@@ -458,32 +452,32 @@ mod prim_pointer {}\n ///\n /// * A list with each element, i.e., `[x, y, z]`.\n /// * A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.\n-///   The type of `x` must be [`Copy`][copy].\n+///   The type of `x` must be [`Copy`].\n ///\n /// Arrays of *any* size implement the following traits if the element type allows it:\n ///\n-/// - [`Debug`][debug]\n-/// - [`IntoIterator`][intoiterator] (implemented for `&[T; N]` and `&mut [T; N]`)\n-/// - [`PartialEq`][partialeq], [`PartialOrd`][partialord], [`Eq`][eq], [`Ord`][ord]\n-/// - [`Hash`][hash]\n-/// - [`AsRef`][asref], [`AsMut`][asmut]\n-/// - [`Borrow`][borrow], [`BorrowMut`][borrowmut]\n+/// - [`Debug`]\n+/// - [`IntoIterator`] (implemented for `&[T; N]` and `&mut [T; N]`)\n+/// - [`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`]\n+/// - [`Hash`]\n+/// - [`AsRef`], [`AsMut`]\n+/// - [`Borrow`], [`BorrowMut`]\n ///\n-/// Arrays of sizes from 0 to 32 (inclusive) implement [`Default`][default] trait\n+/// Arrays of sizes from 0 to 32 (inclusive) implement [`Default`] trait\n /// if the element type allows it. As a stopgap, trait implementations are\n /// statically generated up to size 32.\n ///\n-/// Arrays of *any* size are [`Copy`][copy] if the element type is [`Copy`][copy]\n-/// and [`Clone`][clone] if the element type is [`Clone`][clone]. This works\n-/// because [`Copy`][copy] and [`Clone`][clone] traits are specially known\n+/// Arrays of *any* size are [`Copy`] if the element type is [`Copy`]\n+/// and [`Clone`] if the element type is [`Clone`]. This works\n+/// because [`Copy`] and [`Clone`] traits are specially known\n /// to the compiler.\n ///\n /// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n /// an array. Indeed, this provides most of the API for working with arrays.\n /// Slices have a dynamic size and do not coerce to arrays.\n ///\n /// You can move elements out of an array with a slice pattern. If you want\n-/// one element, see [`mem::replace`][replace].\n+/// one element, see [`mem::replace`].\n ///\n /// # Examples\n ///\n@@ -535,22 +529,10 @@ mod prim_pointer {}\n /// ```\n ///\n /// [slice]: primitive.slice.html\n-/// [copy]: marker/trait.Copy.html\n-/// [clone]: clone/trait.Clone.html\n-/// [debug]: fmt/trait.Debug.html\n-/// [intoiterator]: iter/trait.IntoIterator.html\n-/// [partialeq]: cmp/trait.PartialEq.html\n-/// [partialord]: cmp/trait.PartialOrd.html\n-/// [eq]: cmp/trait.Eq.html\n-/// [ord]: cmp/trait.Ord.html\n-/// [hash]: hash/trait.Hash.html\n-/// [asref]: convert/trait.AsRef.html\n-/// [asmut]: convert/trait.AsMut.html\n-/// [borrow]: borrow/trait.Borrow.html\n-/// [borrowmut]: borrow/trait.BorrowMut.html\n-/// [default]: default/trait.Default.html\n-/// [replace]: mem/fn.replace.html\n-/// [`IntoIterator`]: iter/trait.IntoIterator.html\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n+/// [`Borrow`]: borrow::Borrow\n+/// [`BorrowMut`]: borrow::BorrowMut\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_array {}\n@@ -563,7 +545,7 @@ mod prim_array {}\n /// means that elements are laid out so that every element is the same\n /// distance from its neighbors.\n ///\n-/// *[See also the `std::slice` module](slice/index.html).*\n+/// *[See also the `std::slice` module][`crate::slice`].*\n ///\n /// Slices are a view into a block of memory represented as a pointer and a\n /// length.\n@@ -608,7 +590,7 @@ mod prim_slice {}\n //\n /// String slices.\n ///\n-/// *[See also the `std::str` module](str/index.html).*\n+/// *[See also the `std::str` module][`crate::str`].*\n ///\n /// The `str` type, also called a 'string slice', is the most primitive string\n /// type. It is usually seen in its borrowed form, `&str`. It is also the type\n@@ -729,15 +711,8 @@ mod prim_str {}\n /// * [`Default`]\n /// * [`Hash`]\n ///\n-/// [`Clone`]: clone/trait.Clone.html\n-/// [`Copy`]: marker/trait.Copy.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-/// [`Eq`]: cmp/trait.Eq.html\n-/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n-/// [`Ord`]: cmp/trait.Ord.html\n-/// [`Debug`]: fmt/trait.Debug.html\n-/// [`Default`]: default/trait.Default.html\n-/// [`Hash`]: hash/trait.Hash.html\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n ///\n /// Due to a temporary restriction in Rust's type system, these traits are only\n /// implemented on tuples of arity 12 or less. In the future, this may change.\n@@ -810,7 +785,7 @@ mod prim_tuple {}\n ///\n /// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///\n-/// *[See also the `std::f32::consts` module](f32/consts/index.html).*\n+/// *[See also the `std::f32::consts` module][`crate::f32::consts`].*\n ///\n /// [wikipedia]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -819,12 +794,12 @@ mod prim_f32 {}\n #[doc(primitive = \"f64\")]\n /// A 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).\n ///\n-/// This type is very similar to [`f32`](primitive.f32.html), but has increased\n+/// This type is very similar to [`f32`], but has increased\n /// precision by using twice as many bits. Please see [the documentation for\n-/// `f32`](primitive.f32.html) or [Wikipedia on double precision\n+/// `f32`] or [Wikipedia on double precision\n /// values][wikipedia] for more information.\n ///\n-/// *[See also the `std::f64::consts` module](f64/consts/index.html).*\n+/// *[See also the `std::f64::consts` module][`crate::f64::consts`].*\n ///\n /// [wikipedia]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -945,9 +920,6 @@ mod prim_usize {}\n /// implicit reference-pointer coercion and raw pointer equality via [`ptr::eq`], while\n /// [`PartialEq`] compares values.\n ///\n-/// [`ptr::eq`]: ptr/fn.eq.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-///\n /// ```\n /// use std::ptr;\n ///\n@@ -979,11 +951,9 @@ mod prim_usize {}\n /// * [`Borrow`]\n /// * [`Pointer`]\n ///\n-/// [`Copy`]: marker/trait.Copy.html\n-/// [`Clone`]: clone/trait.Clone.html\n-/// [`Deref`]: ops/trait.Deref.html\n-/// [`Borrow`]: borrow/trait.Borrow.html\n-/// [`Pointer`]: fmt/trait.Pointer.html\n+/// [`Deref`]: ops::Deref\n+/// [`Borrow`]: borrow::Borrow\n+/// [`Pointer`]: fmt::Pointer\n ///\n /// `&mut T` references get all of the above except `Copy` and `Clone` (to prevent creating\n /// multiple simultaneous mutable borrows), plus the following, regardless of the type of its\n@@ -992,8 +962,8 @@ mod prim_usize {}\n /// * [`DerefMut`]\n /// * [`BorrowMut`]\n ///\n-/// [`DerefMut`]: ops/trait.DerefMut.html\n-/// [`BorrowMut`]: borrow/trait.BorrowMut.html\n+/// [`DerefMut`]: ops::DerefMut\n+/// [`BorrowMut`]: borrow::BorrowMut\n ///\n /// The following traits are implemented on `&T` references if the underlying `T` also implements\n /// that trait:\n@@ -1008,18 +978,10 @@ mod prim_usize {}\n /// * [`Hash`]\n /// * [`ToSocketAddrs`]\n ///\n-/// [`std::fmt`]: fmt/index.html\n-/// [`fmt::Write`]: fmt/trait.Write.html\n-/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n-/// [`Ord`]: cmp/trait.Ord.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-/// [`Eq`]: cmp/trait.Eq.html\n-/// [`AsRef`]: convert/trait.AsRef.html\n-/// [`Fn`]: ops/trait.Fn.html\n-/// [`FnMut`]: ops/trait.FnMut.html\n-/// [`FnOnce`]: ops/trait.FnOnce.html\n-/// [`Hash`]: hash/trait.Hash.html\n-/// [`ToSocketAddrs`]: net/trait.ToSocketAddrs.html\n+/// [`std::fmt`]: fmt\n+/// ['Pointer`]: fmt::Pointer\n+/// [`Hash`]: hash::Hash\n+/// [`ToSocketAddrs`]: net::ToSocketAddrs\n ///\n /// `&mut T` references get all of the above except `ToSocketAddrs`, plus the following, if `T`\n /// implements that trait:\n@@ -1038,17 +1000,11 @@ mod prim_usize {}\n /// * [`Seek`]\n /// * [`BufRead`]\n ///\n-/// [`AsMut`]: convert/trait.AsMut.html\n-/// [`Iterator`]: iter/trait.Iterator.html\n-/// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-/// [`ExactSizeIterator`]: iter/trait.ExactSizeIterator.html\n-/// [`FusedIterator`]: iter/trait.FusedIterator.html\n-/// [`TrustedLen`]: iter/trait.TrustedLen.html\n-/// [`Send`]: marker/trait.Send.html\n-/// [`io::Write`]: io/trait.Write.html\n-/// [`Read`]: io/trait.Read.html\n-/// [`Seek`]: io/trait.Seek.html\n-/// [`BufRead`]: io/trait.BufRead.html\n+/// [`FusedIterator`]: iter::FusedIterator\n+/// [`TrustedLen`]: iter::TrustedLen\n+/// [`Seek`]: io::Seek\n+/// [`BufRead`]: io::BufRead\n+/// [`Read`]: io::Read\n ///\n /// Note that due to method call deref coercion, simply calling a trait method will act like they\n /// work on references as well as they do on owned values! The implementations described here are\n@@ -1063,9 +1019,9 @@ mod prim_ref {}\n ///\n /// *See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].*\n ///\n-/// [`Fn`]: ops/trait.Fn.html\n-/// [`FnMut`]: ops/trait.FnMut.html\n-/// [`FnOnce`]: ops/trait.FnOnce.html\n+/// [`Fn`]: ops::Fn\n+/// [`FnMut`]: ops::FnMut\n+/// [`FnOnce`]: ops::FnOnce\n ///\n /// Function pointers are pointers that point to *code*, not data. They can be called\n /// just like functions. Like references, function pointers are, among other things, assumed to\n@@ -1177,14 +1133,8 @@ mod prim_ref {}\n /// * [`Pointer`]\n /// * [`Debug`]\n ///\n-/// [`Clone`]: clone/trait.Clone.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-/// [`Eq`]: cmp/trait.Eq.html\n-/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n-/// [`Ord`]: cmp/trait.Ord.html\n-/// [`Hash`]: hash/trait.Hash.html\n-/// [`Pointer`]: fmt/trait.Pointer.html\n-/// [`Debug`]: fmt/trait.Debug.html\n+/// [`Hash`]: hash::Hash\n+/// [`Pointer`]: fmt::Pointer\n ///\n /// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n /// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n@@ -1193,7 +1143,5 @@ mod prim_ref {}\n /// In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe*\n /// function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`]. This works because these traits\n /// are specially known to the compiler.\n-///\n-/// [`Copy`]: marker/trait.Copy.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_fn {}"}, {"sha": "501ad8ee7d6b3c390afc75128232db04752c973f", "filename": "library/std/src/sys/wasi/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "patch": "@@ -9,8 +9,6 @@ use crate::sys::fs::osstr2str;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n \n /// WASI-specific extensions to [`File`].\n-///\n-/// [`File`]: ../../../../std/fs/struct.File.html\n pub trait FileExt {\n     /// Reads a number of bytes starting from a given offset.\n     ///\n@@ -23,8 +21,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::read`], it is not an error to return with a\n     /// short read.\n-    ///\n-    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n         let bufs = &mut [IoSliceMut::new(buf)];\n         self.read_vectored_at(bufs, offset)\n@@ -41,8 +37,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::read_vectored`], it is not an error to\n     /// return with a short read.\n-    ///\n-    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read_vectored\n     fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize>;\n \n     /// Reads the exact number of byte required to fill `buf` from the given offset.\n@@ -54,8 +48,7 @@ pub trait FileExt {\n     ///\n     /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n     ///\n-    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n-    /// [`read_at`]: #tymethod.read_at\n+    /// [`read_at`]: FileExt::read_at\n     ///\n     /// # Errors\n     ///\n@@ -73,9 +66,6 @@ pub trait FileExt {\n     /// If this function returns an error, it is unspecified how many bytes it\n     /// has read, but it will never read more than would be necessary to\n     /// completely fill the buffer.\n-    ///\n-    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n     #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n     fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n@@ -111,8 +101,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::write`], it is not an error to return a\n     /// short write.\n-    ///\n-    /// [`File::write`]: ../../../../std/fs/struct.File.html#write.v\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n         let bufs = &[IoSlice::new(buf)];\n         self.write_vectored_at(bufs, offset)\n@@ -132,8 +120,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::write_vectored`], it is not an error to return a\n     /// short write.\n-    ///\n-    /// [`File::write`]: ../../../../std/fs/struct.File.html#method.write_vectored\n     fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize>;\n \n     /// Attempts to write an entire buffer starting from a given offset.\n@@ -155,8 +141,7 @@ pub trait FileExt {\n     /// This function will return the first error of\n     /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n     ///\n-    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`write_at`]: #tymethod.write_at\n+    /// [`write_at`]: FileExt::write_at\n     #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n     fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n@@ -289,8 +274,6 @@ impl FileExt for fs::File {\n }\n \n /// WASI-specific extensions to [`fs::OpenOptions`].\n-///\n-/// [`fs::OpenOptions`]: ../../../../std/fs/struct.OpenOptions.html\n pub trait OpenOptionsExt {\n     /// Pass custom `dirflags` argument to `path_open`.\n     ///\n@@ -406,8 +389,6 @@ impl OpenOptionsExt for OpenOptions {\n }\n \n /// WASI-specific extensions to [`fs::Metadata`].\n-///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n pub trait MetadataExt {\n     /// Returns the `st_dev` field of the internal `filestat_t`\n     fn dev(&self) -> u64;\n@@ -448,8 +429,6 @@ impl MetadataExt for fs::Metadata {\n ///\n /// Adds support for special WASI file types such as block/character devices,\n /// pipes, and sockets.\n-///\n-/// [`FileType`]: ../../../../std/fs/struct.FileType.html\n pub trait FileTypeExt {\n     /// Returns `true` if this file type is a block device.\n     fn is_block_device(&self) -> bool;\n@@ -477,8 +456,6 @@ impl FileTypeExt for fs::FileType {\n }\n \n /// WASI-specific extension methods for [`fs::DirEntry`].\n-///\n-/// [`fs::DirEntry`]: ../../../../std/fs/struct.DirEntry.html\n pub trait DirEntryExt {\n     /// Returns the underlying `d_ino` field of the `dirent_t`\n     fn ino(&self) -> u64;"}, {"sha": "323165cda6bd5387f7cdf2bd9f4f1d8adff42070", "filename": "library/std/src/sys_common/os_str_bytes.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fos_str_bytes.rs?ref=a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "patch": "@@ -232,23 +232,17 @@ impl Slice {\n }\n \n /// Platform-specific extensions to [`OsString`].\n-///\n-/// [`OsString`]: ../../../../std/ffi/struct.OsString.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait OsStringExt {\n     /// Creates an [`OsString`] from a byte vector.\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsString`]: ../../../ffi/struct.OsString.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_vec(vec: Vec<u8>) -> Self;\n \n     /// Yields the underlying byte vector of this [`OsString`].\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsString`]: ../../../ffi/struct.OsString.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_vec(self) -> Vec<u8>;\n }\n@@ -264,23 +258,17 @@ impl OsStringExt for OsString {\n }\n \n /// Platform-specific extensions to [`OsStr`].\n-///\n-/// [`OsStr`]: ../../../../std/ffi/struct.OsStr.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait OsStrExt {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Creates an [`OsStr`] from a byte slice.\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n     fn from_bytes(slice: &[u8]) -> &Self;\n \n     /// Gets the underlying byte view of the [`OsStr`] slice.\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8];\n }"}, {"sha": "24ccc7fc118840d2e3185f991c0d30b7c6c38652", "filename": "library/std/src/sys_common/poison.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4/library%2Fstd%2Fsrc%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fpoison.rs?ref=a712fbd50bd7a579d4a46d426e9f8b1c627d4bc4", "patch": "@@ -78,8 +78,8 @@ pub struct Guard {\n /// };\n /// ```\n ///\n-/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n-/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n+/// [`Mutex`]: crate::sync::Mutex\n+/// [`RwLock`]: crate::sync::RwLock\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PoisonError<T> {\n     guard: T,\n@@ -89,12 +89,11 @@ pub struct PoisonError<T> {\n /// can occur while trying to acquire a lock, from the [`try_lock`] method on a\n /// [`Mutex`] or the [`try_read`] and [`try_write`] methods on an [`RwLock`].\n ///\n-/// [`Mutex`]: struct.Mutex.html\n-/// [`RwLock`]: struct.RwLock.html\n-/// [`TryLockResult`]: type.TryLockResult.html\n-/// [`try_lock`]: struct.Mutex.html#method.try_lock\n-/// [`try_read`]: struct.RwLock.html#method.try_read\n-/// [`try_write`]: struct.RwLock.html#method.try_write\n+/// [`Mutex`]: crate::sync::Mutex\n+/// [`RwLock`]: crate::sync::RwLock\n+/// [`try_lock`]: crate::sync::Mutex::try_lock\n+/// [`try_read`]: crate::sync::RwLock::try_read\n+/// [`try_write`]: crate::sync::RwLock::try_write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another thread failed while holding\n@@ -115,9 +114,7 @@ pub enum TryLockError<T> {\n /// the associated guard, and it can be acquired through the [`into_inner`]\n /// method.\n ///\n-/// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-/// [`into_inner`]: ../../std/sync/struct.PoisonError.html#method.into_inner\n+/// [`into_inner`]: PoisonError::into_inner\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n \n@@ -126,9 +123,6 @@ pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n /// For more information, see [`LockResult`]. A `TryLockResult` doesn't\n /// necessarily hold the associated guard in the [`Err`] type as the lock may not\n /// have been acquired for other reasons.\n-///\n-/// [`LockResult`]: ../../std/sync/type.LockResult.html\n-/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n@@ -159,8 +153,8 @@ impl<T> PoisonError<T> {\n     ///\n     /// This is generally created by methods like [`Mutex::lock`] or [`RwLock::read`].\n     ///\n-    /// [`Mutex::lock`]: ../../std/sync/struct.Mutex.html#method.lock\n-    /// [`RwLock::read`]: ../../std/sync/struct.RwLock.html#method.read\n+    /// [`Mutex::lock`]:  crate::sync::Mutex::lock\n+    /// [`RwLock::read`]: crate::sync::RwLock::read\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn new(guard: T) -> PoisonError<T> {\n         PoisonError { guard }"}]}