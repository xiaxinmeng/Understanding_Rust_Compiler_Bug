{"sha": "abbdec3be6cfce1175d0dc6737a2999cf43b530d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYmRlYzNiZTZjZmNlMTE3NWQwZGM2NzM3YTI5OTljZjQzYjUzMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-12T23:04:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-12T23:04:55Z"}, "message": "Auto merge of #77792 - matthewjasper:instrument-trait-selection, r=oli-obk\n\nUse tracing spans in rustc_trait_selection\n\nSpans are very helpful when debugging this code. It's also hot enough to make a good benchmark.\n\nr? `@oli-obk`", "tree": {"sha": "f711996c9174eed55a5fda730e49570c38d6665b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f711996c9174eed55a5fda730e49570c38d6665b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abbdec3be6cfce1175d0dc6737a2999cf43b530d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abbdec3be6cfce1175d0dc6737a2999cf43b530d", "html_url": "https://github.com/rust-lang/rust/commit/abbdec3be6cfce1175d0dc6737a2999cf43b530d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abbdec3be6cfce1175d0dc6737a2999cf43b530d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dae8cdcc8fa879cea6a4bbbfa5b32e97be4c306", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dae8cdcc8fa879cea6a4bbbfa5b32e97be4c306", "html_url": "https://github.com/rust-lang/rust/commit/8dae8cdcc8fa879cea6a4bbbfa5b32e97be4c306"}, {"sha": "b8d2560dca40edf5584c8e23b81c3e89d19d68dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8d2560dca40edf5584c8e23b81c3e89d19d68dc", "html_url": "https://github.com/rust-lang/rust/commit/b8d2560dca40edf5584c8e23b81c3e89d19d68dc"}], "stats": {"total": 456, "additions": 166, "deletions": 290}, "files": [{"sha": "97dd180b27b042542f77e09db271bb015822a431", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=abbdec3be6cfce1175d0dc6737a2999cf43b530d", "patch": "@@ -120,7 +120,8 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n         &mut self,\n         selcx: &mut SelectionContext<'a, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n-        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n+        let span = debug_span!(\"select\", obligation_forest_size = ?self.predicates.len());\n+        let _enter = span.enter();\n \n         let mut errors = Vec::new();\n \n@@ -173,7 +174,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         projection_ty: ty::ProjectionTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n     ) -> Ty<'tcx> {\n-        debug!(\"normalize_projection_type(projection_ty={:?})\", projection_ty);\n+        debug!(?projection_ty, \"normalize_projection_type\");\n \n         debug_assert!(!projection_ty.has_escaping_bound_vars());\n \n@@ -191,7 +192,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         );\n         self.register_predicate_obligations(infcx, obligations);\n \n-        debug!(\"normalize_projection_type: result={:?}\", normalized_ty);\n+        debug!(?normalized_ty);\n \n         normalized_ty\n     }\n@@ -205,7 +206,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_vars_if_possible(&obligation);\n \n-        debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n+        debug!(?obligation, \"register_predicate_obligation\");\n \n         assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n@@ -342,7 +343,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n \n-        debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n+        debug!(?obligation, ?obligation.cause, \"process_obligation\");\n \n         let infcx = self.selcx.infcx();\n \n@@ -509,7 +510,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n \n                 ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                    debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n+                    debug!(?c1, ?c2, \"equating consts\");\n                     if self.selcx.tcx().features().const_evaluatable_checked {\n                         // FIXME: we probably should only try to unify abstract constants\n                         // if the constants depend on generic parameters.\n@@ -601,6 +602,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, obligation, stalled_on))]\n     fn process_trait_obligation(\n         &mut self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -613,26 +615,20 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n             // FIXME: consider caching errors too.\n             if infcx.predicate_must_hold_considering_regions(obligation) {\n                 debug!(\n-                    \"selecting trait `{:?}` at depth {} evaluated to holds\",\n-                    obligation.predicate, obligation.recursion_depth\n+                    \"selecting trait at depth {} evaluated to holds\",\n+                    obligation.recursion_depth\n                 );\n                 return ProcessResult::Changed(vec![]);\n             }\n         }\n \n         match self.selcx.select(&trait_obligation) {\n             Ok(Some(impl_source)) => {\n-                debug!(\n-                    \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n-                    trait_obligation.predicate, obligation.recursion_depth\n-                );\n+                debug!(\"selecting trait at depth {} yielded Ok(Some)\", obligation.recursion_depth);\n                 ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))\n             }\n             Ok(None) => {\n-                debug!(\n-                    \"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n-                    trait_obligation.predicate, obligation.recursion_depth\n-                );\n+                debug!(\"selecting trait at depth {} yielded Ok(None)\", obligation.recursion_depth);\n \n                 // This is a bit subtle: for the most part, the\n                 // only reason we can fail to make progress on\n@@ -652,10 +648,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ProcessResult::Unchanged\n             }\n             Err(selection_err) => {\n-                info!(\n-                    \"selecting trait `{:?}` at depth {} yielded Err\",\n-                    trait_obligation.predicate, obligation.recursion_depth\n-                );\n+                info!(\"selecting trait at depth {} yielded Err\", obligation.recursion_depth);\n \n                 ProcessResult::Error(CodeSelectionError(selection_err))\n             }"}, {"sha": "8dbf7ec51c6dbd356e74a70b41820e53155ade3e", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 43, "deletions": 102, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=abbdec3be6cfce1175d0dc6737a2999cf43b530d", "patch": "@@ -157,15 +157,14 @@ impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n ///    the given obligations. If the projection cannot be normalized because\n ///    the required trait bound doesn't hold this returned with `obligations`\n ///    being a predicate that cannot be proven.\n+#[instrument(level = \"debug\", skip(selcx))]\n pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>,\n ) -> Result<\n     Result<Option<Vec<PredicateObligation<'tcx>>>, InProgress>,\n     MismatchedProjectionTypes<'tcx>,\n > {\n-    debug!(\"poly_project_and_unify_type(obligation={:?})\", obligation);\n-\n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|_snapshot| {\n         let placeholder_predicate =\n@@ -191,7 +190,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n     Result<Option<Vec<PredicateObligation<'tcx>>>, InProgress>,\n     MismatchedProjectionTypes<'tcx>,\n > {\n-    debug!(\"project_and_unify_type(obligation={:?})\", obligation);\n+    debug!(?obligation, \"project_and_unify_type\");\n \n     let mut obligations = vec![];\n     let normalized_ty = match opt_normalize_projection_type(\n@@ -207,10 +206,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n         Err(InProgress) => return Ok(Err(InProgress)),\n     };\n \n-    debug!(\n-        \"project_and_unify_type: normalized_ty={:?} obligations={:?}\",\n-        normalized_ty, obligations\n-    );\n+    debug!(?normalized_ty, ?obligations, \"project_and_unify_type result\");\n \n     let infcx = selcx.infcx();\n     match infcx\n@@ -275,6 +271,7 @@ where\n     Normalized { value, obligations }\n }\n \n+#[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -286,16 +283,10 @@ pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n where\n     T: TypeFoldable<'tcx>,\n {\n-    debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n     let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);\n     let result = ensure_sufficient_stack(|| normalizer.fold(value));\n-    debug!(\n-        \"normalize_with_depth: depth={} result={:?} with {} obligations\",\n-        depth,\n-        result,\n-        normalizer.obligations.len()\n-    );\n-    debug!(\"normalize_with_depth: depth={} obligations={:?}\", depth, normalizer.obligations);\n+    debug!(?result, obligations.len = normalizer.obligations.len());\n+    debug!(?normalizer.obligations,);\n     result\n }\n \n@@ -396,12 +387,11 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     &mut self.obligations,\n                 );\n                 debug!(\n-                    \"AssocTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n-                     now with {} obligations\",\n-                    self.depth,\n-                    ty,\n-                    normalized_ty,\n-                    self.obligations.len()\n+                    ?self.depth,\n+                    ?ty,\n+                    ?normalized_ty,\n+                    obligations.len = ?self.obligations.len(),\n+                    \"AssocTypeNormalizer: normalized type\"\n                 );\n                 normalized_ty\n             }\n@@ -473,6 +463,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n /// often immediately appended to another obligations vector. So now this\n /// function takes an obligations vector and appends to it directly, which is\n /// slightly uglier but avoids the need for an extra short-lived allocation.\n+#[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -486,13 +477,6 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n     let cache_key = ProjectionCacheKey::new(projection_ty);\n \n-    debug!(\n-        \"opt_normalize_projection_type(\\\n-         projection_ty={:?}, \\\n-         depth={})\",\n-        projection_ty, depth\n-    );\n-\n     // FIXME(#20304) For now, I am caching here, which is good, but it\n     // means we don't capture the type variables that are created in\n     // the case of ambiguity. Which means we may create a large stream\n@@ -508,10 +492,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // If we found ambiguity the last time, that means we will continue\n             // to do so until some type in the key changes (and we know it\n             // hasn't, because we just fully resolved it).\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found cache entry: ambiguous\"\n-            );\n+            debug!(\"found cache entry: ambiguous\");\n             return Ok(None);\n         }\n         Err(ProjectionCacheEntry::InProgress) => {\n@@ -529,10 +510,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // with `A::B`, which can trigger a recursive\n             // normalization.\n \n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found cache entry: in-progress\"\n-            );\n+            debug!(\"found cache entry: in-progress\");\n \n             return Err(InProgress);\n         }\n@@ -548,11 +526,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // discarded as duplicated). But when doing trait\n             // evaluation this is not the case, and dropping the trait\n             // evaluations can causes ICEs (e.g., #43132).\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found normalized ty `{:?}`\",\n-                ty\n-            );\n+            debug!(?ty, \"found normalized ty\");\n \n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n@@ -565,10 +539,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             return Ok(Some(ty.value));\n         }\n         Err(ProjectionCacheEntry::Error) => {\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found error\"\n-            );\n+            debug!(\"opt_normalize_projection_type: found error\");\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n             return Ok(Some(result.value));\n@@ -586,13 +557,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 projected_ty={:?} \\\n-                 depth={} \\\n-                 projected_obligations={:?}\",\n-                projected_ty, depth, projected_obligations\n-            );\n+            debug!(?projected_ty, ?depth, ?projected_obligations);\n \n             let result = if projected_ty.has_projections() {\n                 let mut normalizer = AssocTypeNormalizer::new(\n@@ -604,11 +569,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 );\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n-                debug!(\n-                    \"opt_normalize_projection_type: \\\n-                     normalized_ty={:?} depth={}\",\n-                    normalized_ty, depth\n-                );\n+                debug!(?normalized_ty, ?depth);\n \n                 Normalized { value: normalized_ty, obligations: projected_obligations }\n             } else {\n@@ -621,21 +582,14 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             Ok(Some(result.value))\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 projected_ty={:?} no progress\",\n-                projected_ty\n-            );\n+            debug!(?projected_ty, \"opt_normalize_projection_type: no progress\");\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n             infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n             // No need to extend `obligations`.\n             Ok(Some(result.value))\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 too many candidates\"\n-            );\n+            debug!(\"opt_normalize_projection_type: too many candidates\");\n             infcx.inner.borrow_mut().projection_cache().ambiguous(cache_key);\n             Ok(None)\n         }\n@@ -755,15 +709,12 @@ impl<'tcx> Progress<'tcx> {\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n         debug!(\n-            \"with_addl_obligations: self.obligations.len={} obligations.len={}\",\n-            self.obligations.len(),\n-            obligations.len()\n+            self.obligations.len = ?self.obligations.len(),\n+            obligations.len = obligations.len(),\n+            \"with_addl_obligations\"\n         );\n \n-        debug!(\n-            \"with_addl_obligations: self.obligations={:?} obligations={:?}\",\n-            self.obligations, obligations\n-        );\n+        debug!(?self.obligations, ?obligations, \"with_addl_obligations\");\n \n         self.obligations.append(&mut obligations);\n         self\n@@ -778,7 +729,7 @@ fn project_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n ) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n-    debug!(\"project(obligation={:?})\", obligation);\n+    debug!(?obligation, \"project_type\");\n \n     if !selcx.tcx().sess.recursion_limit().value_within_limit(obligation.recursion_depth) {\n         debug!(\"project: overflow!\");\n@@ -787,7 +738,7 @@ fn project_type<'cx, 'tcx>(\n \n     let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());\n \n-    debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n+    debug!(?obligation_trait_ref);\n \n     if obligation_trait_ref.references_error() {\n         return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n@@ -951,10 +902,11 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     potentially_unnormalized_candidates: bool,\n ) {\n-    debug!(\"assemble_candidates_from_predicates(obligation={:?})\", obligation);\n+    debug!(?obligation, \"assemble_candidates_from_predicates\");\n+\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n-        debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n+        debug!(?predicate);\n         if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n             let data = ty::Binder::bind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n@@ -969,11 +921,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n                     )\n                 });\n \n-            debug!(\n-                \"assemble_candidates_from_predicates: candidate={:?} \\\n-                 is_match={} same_def_id={}\",\n-                data, is_match, same_def_id\n-            );\n+            debug!(?data, ?is_match, ?same_def_id);\n \n             if is_match {\n                 candidate_set.push_candidate(ctor(data));\n@@ -997,6 +945,8 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n+    debug!(\"assemble_candidates_from_impls\");\n+\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n@@ -1009,7 +959,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 return Err(());\n             }\n             Err(e) => {\n-                debug!(\"assemble_candidates_from_impls: selection error {:?}\", e);\n+                debug!(error = ?e, \"selection error\");\n                 candidate_set.mark_error(e);\n                 return Err(());\n             }\n@@ -1020,7 +970,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n             | super::ImplSource::Generator(_)\n             | super::ImplSource::FnPointer(_)\n             | super::ImplSource::TraitAlias(_) => {\n-                debug!(\"assemble_candidates_from_impls: impl_source={:?}\", impl_source);\n+                debug!(?impl_source);\n                 true\n             }\n             super::ImplSource::UserDefined(impl_data) => {\n@@ -1066,10 +1016,9 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                         !poly_trait_ref.still_further_specializable()\n                     } else {\n                         debug!(\n-                            \"assemble_candidates_from_impls: not eligible due to default: \\\n-                             assoc_ty={} predicate={}\",\n-                            selcx.tcx().def_path_str(node_item.item.def_id),\n-                            obligation.predicate,\n+                            assoc_ty = ?selcx.tcx().def_path_str(node_item.item.def_id),\n+                            ?obligation.predicate,\n+                            \"assemble_candidates_from_impls: not eligible due to default\",\n                         );\n                         false\n                     }\n@@ -1176,8 +1125,7 @@ fn confirm_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>,\n ) -> Progress<'tcx> {\n-    debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\", candidate, obligation);\n-\n+    debug!(?obligation, ?candidate, \"confirm_candidate\");\n     let mut progress = match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection)\n         | ProjectionTyCandidate::Object(poly_projection) => {\n@@ -1220,9 +1168,8 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n         | super::ImplSource::Builtin(..)\n-        | super::ImplSource::TraitAlias(..) =>\n-        // we don't create Select candidates with this kind of resolution\n-        {\n+        | super::ImplSource::TraitAlias(..) => {\n+            // we don't create Select candidates with this kind of resolution\n             span_bug!(\n                 obligation.cause.span,\n                 \"Cannot project an associated type from `{:?}`\",\n@@ -1246,10 +1193,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         &gen_sig,\n     );\n \n-    debug!(\n-        \"confirm_generator_candidate: obligation={:?},gen_sig={:?},obligations={:?}\",\n-        obligation, gen_sig, obligations\n-    );\n+    debug!(?obligation, ?gen_sig, ?obligations, \"confirm_generator_candidate\");\n \n     let tcx = selcx.tcx();\n \n@@ -1339,10 +1283,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n         &closure_sig,\n     );\n \n-    debug!(\n-        \"confirm_closure_candidate: obligation={:?},closure_sig={:?},obligations={:?}\",\n-        obligation, closure_sig, obligations\n-    );\n+    debug!(?obligation, ?closure_sig, ?obligations, \"confirm_closure_candidate\");\n \n     confirm_callable_candidate(selcx, obligation, closure_sig, util::TupleArgumentsFlag::No)\n         .with_addl_obligations(impl_source.nested)\n@@ -1357,7 +1298,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n-    debug!(\"confirm_callable_candidate({:?},{:?})\", obligation, fn_sig);\n+    debug!(?obligation, ?fn_sig, \"confirm_callable_candidate\");\n \n     let fn_once_def_id = tcx.require_lang_item(LangItem::FnOnce, None);\n     let fn_once_output_def_id = tcx.require_lang_item(LangItem::FnOnceOutput, None);"}, {"sha": "fdf1641c9867633c649704ef1a843a22ec43c390", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=abbdec3be6cfce1175d0dc6737a2999cf43b530d", "patch": "@@ -22,6 +22,7 @@ use super::SelectionCandidate::{self, *};\n use super::{EvaluatedCandidate, SelectionCandidateSet, SelectionContext, TraitObligationStack};\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn candidate_from_obligation<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n@@ -35,16 +36,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // this is because we want the unbound variables to be\n         // replaced with fresh types starting from index 0.\n         let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n-        debug!(\n-            \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n-            cache_fresh_trait_pred, stack\n-        );\n+        debug!(?cache_fresh_trait_pred);\n         debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n \n         if let Some(c) =\n             self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n         {\n-            debug!(\"CACHE HIT: SELECT({:?})={:?}\", cache_fresh_trait_pred, c);\n+            debug!(candidate = ?c, \"CACHE HIT\");\n             return c;\n         }\n \n@@ -57,7 +55,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let (candidate, dep_node) =\n             self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n \n-        debug!(\"CACHE MISS: SELECT({:?})={:?}\", cache_fresh_trait_pred, candidate);\n+        debug!(?candidate, \"CACHE MISS\");\n         self.insert_candidate_cache(\n             stack.obligation.param_env,\n             cache_fresh_trait_pred,\n@@ -103,7 +101,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         } else {\n                             IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n                         };\n-                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n+                        debug!(?cause, \"evaluate_stack: pushing cause\");\n                         self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n                     }\n                 }\n@@ -120,7 +118,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = candidate_set.vec;\n \n-        debug!(\"assembled {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n+        debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n \n         // At this point, we know that each of the entries in the\n         // candidate set is *individually* applicable. Now we have to\n@@ -163,7 +161,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .flat_map(Result::transpose)\n             .collect::<Result<Vec<_>, _>>()?;\n \n-        debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n+        debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n \n         let needs_infer = stack.obligation.predicate.has_infer_types_or_consts();\n \n@@ -181,10 +179,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     )\n                 });\n                 if is_dup {\n-                    debug!(\"Dropping candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n+                    debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                     candidates.swap_remove(i);\n                 } else {\n-                    debug!(\"Retaining candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n+                    debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n                     i += 1;\n \n                     // If there are *STILL* multiple candidates, give up\n@@ -257,7 +255,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let lang_items = self.tcx().lang_items();\n \n         if lang_items.copy_trait() == Some(def_id) {\n-            debug!(\"obligation self ty is {:?}\", obligation.predicate.skip_binder().self_ty());\n+            debug!(obligation_self_ty = ?obligation.predicate.skip_binder().self_ty());\n \n             // User-defined copy impls are permitted, but only for\n             // structs and enums.\n@@ -308,7 +306,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n+        debug!(?obligation, \"assemble_candidates_from_projected_tys\");\n \n         // Before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n@@ -341,7 +339,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         stack: &TraitObligationStack<'o, 'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        debug!(\"assemble_candidates_from_caller_bounds({:?})\", stack.obligation);\n+        debug!(?stack.obligation, \"assemble_candidates_from_caller_bounds\");\n \n         let all_bounds = stack\n             .obligation\n@@ -383,10 +381,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let self_ty = obligation.self_ty().skip_binder();\n         match self_ty.kind() {\n             ty::Generator(..) => {\n-                debug!(\n-                    \"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n-                    self_ty, obligation\n-                );\n+                debug!(?self_ty, ?obligation, \"assemble_generator_candidates\",);\n \n                 candidates.vec.push(GeneratorCandidate);\n             }\n@@ -423,10 +418,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // type/region parameters\n         match *obligation.self_ty().skip_binder().kind() {\n             ty::Closure(_, closure_substs) => {\n-                debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\", kind, obligation);\n+                debug!(?kind, ?obligation, \"assemble_unboxed_candidates\");\n                 match self.infcx.closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n-                        debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n+                        debug!(?closure_kind, \"assemble_unboxed_candidates\");\n                         if closure_kind.extends(kind) {\n                             candidates.vec.push(ClosureCandidate);\n                         }\n@@ -503,7 +498,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n+        debug!(?obligation, \"assemble_candidates_from_impls\");\n \n         // Essentially any user-written impl will match with an error type,\n         // so creating `ImplCandidates` isn't useful. However, we might\n@@ -537,7 +532,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<(), SelectionError<'tcx>> {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = obligation.self_ty().skip_binder();\n-        debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n+        debug!(?self_ty, \"assemble_candidates_from_auto_impls\");\n \n         let def_id = obligation.predicate.def_id();\n \n@@ -604,8 +599,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n         debug!(\n-            \"assemble_candidates_from_object_ty(self_ty={:?})\",\n-            obligation.self_ty().skip_binder()\n+            self_ty = ?obligation.self_ty().skip_binder(),\n+            \"assemble_candidates_from_object_ty\",\n         );\n \n         self.infcx.probe(|_snapshot| {\n@@ -645,7 +640,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 _ => return,\n             };\n \n-            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\", poly_trait_ref);\n+            debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the\n@@ -697,7 +692,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n         let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n \n-        debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\", source, target);\n+        debug!(?source, ?target, \"assemble_candidates_for_unsizing\");\n \n         let may_apply = match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n@@ -758,7 +753,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<(), SelectionError<'tcx>> {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = obligation.self_ty().skip_binder();\n-        debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n+        debug!(?self_ty, \"assemble_candidates_for_trait_alias\");\n \n         let def_id = obligation.predicate.def_id();\n \n@@ -778,7 +773,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<(), SelectionError<'tcx>> {\n         match conditions {\n             BuiltinImplConditions::Where(nested) => {\n-                debug!(\"builtin_bound: nested={:?}\", nested);\n+                debug!(?nested, \"builtin_bound\");\n                 candidates\n                     .vec\n                     .push(BuiltinCandidate { has_nested: !nested.skip_binder().is_empty() });"}, {"sha": "37d619d594215bb2a0efe6a809c4001de91683c6", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 21, "deletions": 38, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=abbdec3be6cfce1175d0dc6737a2999cf43b530d", "patch": "@@ -42,13 +42,12 @@ use super::SelectionContext;\n use std::iter;\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn confirm_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidate: SelectionCandidate<'tcx>,\n     ) -> Result<Selection<'tcx>, SelectionError<'tcx>> {\n-        debug!(\"confirm_candidate({:?}, {:?})\", obligation, candidate);\n-\n         match candidate {\n             BuiltinCandidate { has_nested } => {\n                 let data = self.confirm_builtin_candidate(obligation, has_nested);\n@@ -191,7 +190,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         param: ty::PolyTraitRef<'tcx>,\n     ) -> Vec<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_param_candidate({:?},{:?})\", obligation, param);\n+        debug!(?obligation, ?param, \"confirm_param_candidate\");\n \n         // During evaluation, we already checked that this\n         // where-clause trait-ref could be unified with the obligation\n@@ -214,7 +213,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         has_nested: bool,\n     ) -> ImplSourceBuiltinData<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_builtin_candidate({:?}, {:?})\", obligation, has_nested);\n+        debug!(?obligation, ?has_nested, \"confirm_builtin_candidate\");\n \n         let lang_items = self.tcx().lang_items();\n         let obligations = if has_nested {\n@@ -247,7 +246,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             vec![]\n         };\n \n-        debug!(\"confirm_builtin_candidate: obligations={:?}\", obligations);\n+        debug!(?obligations);\n \n         ImplSourceBuiltinData { nested: obligations }\n     }\n@@ -262,7 +261,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_def_id: DefId,\n     ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_auto_impl_candidate({:?}, {:?})\", obligation, trait_def_id);\n+        debug!(?obligation, ?trait_def_id, \"confirm_auto_impl_candidate\");\n \n         let types = obligation.predicate.map_bound(|inner| {\n             let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n@@ -278,7 +277,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         trait_def_id: DefId,\n         nested: ty::Binder<Vec<Ty<'tcx>>>,\n     ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n-        debug!(\"vtable_auto_impl: nested={:?}\", nested);\n+        debug!(?nested, \"vtable_auto_impl\");\n         ensure_sufficient_stack(|| {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n             let mut obligations = self.collect_predicates_for_types(\n@@ -308,7 +307,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // predicate as usual.  It won't have any effect since auto traits are coinductive.\n             obligations.extend(trait_obligations);\n \n-            debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n+            debug!(?obligations, \"vtable_auto_impl\");\n \n             ImplSourceAutoImplData { trait_def_id, nested: obligations }\n         })\n@@ -319,13 +318,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         impl_def_id: DefId,\n     ) -> ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_impl_candidate({:?},{:?})\", obligation, impl_def_id);\n+        debug!(?obligation, ?impl_def_id, \"confirm_impl_candidate\");\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n         self.infcx.commit_unconditionally(|_| {\n             let substs = self.rematch_impl(impl_def_id, obligation);\n-            debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n+            debug!(?substs, \"impl substs\");\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             ensure_sufficient_stack(|| {\n                 self.vtable_impl(\n@@ -347,10 +346,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\n-            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n-            impl_def_id, substs, recursion_depth,\n-        );\n+        debug!(?impl_def_id, ?substs, ?recursion_depth, \"vtable_impl\");\n \n         let mut impl_obligations = self.impl_or_trait_obligations(\n             cause,\n@@ -360,10 +356,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             &substs.value,\n         );\n \n-        debug!(\n-            \"vtable_impl: impl_def_id={:?} impl_obligations={:?}\",\n-            impl_def_id, impl_obligations\n-        );\n+        debug!(?impl_obligations, \"vtable_impl\");\n \n         // Because of RFC447, the impl-trait-ref and obligations\n         // are sufficient to determine the impl substs, without\n@@ -379,8 +372,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(?obligation, \"confirm_object_candidate\");\n         let tcx = self.tcx();\n-        debug!(\"confirm_object_candidate({:?})\", obligation);\n \n         let trait_predicate =\n             self.infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n@@ -507,7 +500,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         }\n \n-        debug!(\"confirm_object_candidate: nested: {:?}\", nested);\n+        debug!(?nested, \"object nested obligations\");\n         ImplSourceObjectData { upcast_trait_ref, vtable_base, nested }\n     }\n \n@@ -516,7 +509,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n+        debug!(?obligation, \"confirm_fn_pointer_candidate\");\n \n         // Okay to skip binder; it is reintroduced below.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n@@ -554,7 +547,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         alias_def_id: DefId,\n     ) -> ImplSourceTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_trait_alias_candidate({:?}, {:?})\", obligation, alias_def_id);\n+        debug!(?obligation, ?alias_def_id, \"confirm_trait_alias_candidate\");\n \n         self.infcx.commit_unconditionally(|_| {\n             let predicate =\n@@ -571,10 +564,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 &substs,\n             );\n \n-            debug!(\n-                \"confirm_trait_alias_candidate: trait_def_id={:?} trait_obligations={:?}\",\n-                trait_def_id, trait_obligations\n-            );\n+            debug!(?trait_def_id, ?trait_obligations, \"trait alias obligations\");\n \n             ImplSourceTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n         })\n@@ -594,7 +584,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n \n-        debug!(\"confirm_generator_candidate({:?},{:?},{:?})\", obligation, generator_def_id, substs);\n+        debug!(?obligation, ?generator_def_id, ?substs, \"confirm_generator_candidate\");\n \n         let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n         let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n@@ -607,11 +597,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             )\n         });\n \n-        debug!(\n-            \"confirm_generator_candidate(generator_def_id={:?}, \\\n-             trait_ref={:?}, obligations={:?})\",\n-            generator_def_id, trait_ref, obligations\n-        );\n+        debug!(?trait_ref, ?obligations, \"generator candidate obligations\");\n \n         obligations.extend(self.confirm_poly_trait_refs(\n             obligation.cause.clone(),\n@@ -627,7 +613,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        debug!(\"confirm_closure_candidate({:?})\", obligation);\n+        debug!(?obligation, \"confirm_closure_candidate\");\n \n         let kind = self\n             .tcx()\n@@ -654,10 +640,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             )\n         });\n \n-        debug!(\n-            \"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n-            closure_def_id, trait_ref, obligations\n-        );\n+        debug!(?closure_def_id, ?trait_ref, ?obligations, \"confirm closure candidate obligations\");\n \n         obligations.extend(self.confirm_poly_trait_refs(\n             obligation.cause.clone(),\n@@ -731,7 +714,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n         let target = self.infcx.shallow_resolve(target);\n \n-        debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\", source, target);\n+        debug!(?source, ?target, \"confirm_builtin_unsize_candidate\");\n \n         let mut nested = vec![];\n         match (source.kind(), target.kind()) {"}, {"sha": "57b680b0e539f7d8236d2a5a5b43b60cdc1f9fde", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 66, "deletions": 102, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abbdec3be6cfce1175d0dc6737a2999cf43b530d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=abbdec3be6cfce1175d0dc6737a2999cf43b530d", "patch": "@@ -236,7 +236,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         infcx: &'cx InferCtxt<'cx, 'tcx>,\n         allow_negative_impls: bool,\n     ) -> SelectionContext<'cx, 'tcx> {\n-        debug!(\"with_negative({:?})\", allow_negative_impls);\n+        debug!(?allow_negative_impls, \"with_negative\");\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n@@ -251,7 +251,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         infcx: &'cx InferCtxt<'cx, 'tcx>,\n         query_mode: TraitQueryMode,\n     ) -> SelectionContext<'cx, 'tcx> {\n-        debug!(\"with_query_mode({:?})\", query_mode);\n+        debug!(?query_mode, \"with_query_mode\");\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n@@ -311,11 +311,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Attempts to satisfy the obligation. If successful, this will affect the surrounding\n     /// type environment by performing unification.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn select(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, Selection<'tcx>> {\n-        debug!(\"select({:?})\", obligation);\n         debug_assert!(!obligation.predicate.has_escaping_bound_vars());\n \n         let pec = &ProvisionalEvaluationCache::default();\n@@ -344,7 +344,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n             Err(e) => Err(e),\n             Ok(candidate) => {\n-                debug!(\"select: candidate = {:?}\", candidate);\n+                debug!(?candidate);\n                 Ok(Some(candidate))\n             }\n         }\n@@ -362,7 +362,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n     pub fn predicate_may_hold_fatal(&mut self, obligation: &PredicateObligation<'tcx>) -> bool {\n-        debug!(\"predicate_may_hold_fatal({:?})\", obligation);\n+        debug!(?obligation, \"predicate_may_hold_fatal\");\n \n         // This fatal query is a stopgap that should only be used in standard mode,\n         // where we do not expect overflow to be propagated.\n@@ -419,10 +419,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n         let mut result = EvaluatedToOk;\n-        debug!(\"evaluate_predicates_recursively({:?})\", predicates);\n+        debug!(?predicates, \"evaluate_predicates_recursively\");\n         for obligation in predicates {\n             let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n-            debug!(\"evaluate_predicate_recursively({:?}) = {:?}\", obligation, eval);\n             if let EvaluatedToErr = eval {\n                 // fast-path - EvaluatedToErr is the top of the lattice,\n                 // so we don't need to look on the other predicates.\n@@ -434,17 +433,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(result)\n     }\n \n+    #[instrument(\n+        level = \"debug\",\n+        skip(self, previous_stack),\n+        fields(previous_stack = ?previous_stack.head())\n+    )]\n     fn evaluate_predicate_recursively<'o>(\n         &mut self,\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        debug!(\n-            \"evaluate_predicate_recursively(obligation={:?}, previous_stack={:?})\",\n-            obligation,\n-            previous_stack.head()\n-        );\n-\n         // `previous_stack` stores a `TraitObligation`, while `obligation` is\n         // a `PredicateObligation`. These are distinct types, so we can't\n         // use any `Option` combinator method that would force them to be\n@@ -454,7 +452,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        ensure_sufficient_stack(|| {\n+        let result = ensure_sufficient_stack(|| {\n             match obligation.predicate.skip_binders() {\n                 ty::PredicateAtom::Trait(t, _) => {\n                     let t = ty::Binder::bind(t);\n@@ -561,10 +559,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                    debug!(\n-                        \"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\",\n-                        c1, c2\n-                    );\n+                    debug!(?c1, ?c2, \"evaluate_predicate_recursively: equating consts\");\n \n                     let evaluate = |c: &'tcx ty::Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(def, substs, promoted) = c.val {\n@@ -610,15 +605,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n             }\n-        })\n+        });\n+\n+        debug!(?result);\n+\n+        result\n     }\n \n     fn evaluate_trait_predicate_recursively<'o>(\n         &mut self,\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         mut obligation: TraitObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        debug!(\"evaluate_trait_predicate_recursively({:?})\", obligation);\n+        debug!(?obligation, \"evaluate_trait_predicate_recursively\");\n \n         if !self.intercrate\n             && obligation.is_global()\n@@ -627,19 +626,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // If a param env has no global bounds, global obligations do not\n             // depend on its particular value in order to work, so we can clear\n             // out the param env and get better caching.\n-            debug!(\"evaluate_trait_predicate_recursively({:?}) - in global\", obligation);\n+            debug!(\"evaluate_trait_predicate_recursively - in global\");\n             obligation.param_env = obligation.param_env.without_caller_bounds();\n         }\n \n         let stack = self.push_stack(previous_stack, &obligation);\n         let fresh_trait_ref = stack.fresh_trait_ref;\n+\n+        debug!(?fresh_trait_ref);\n+\n         if let Some(result) = self.check_evaluation_cache(obligation.param_env, fresh_trait_ref) {\n-            debug!(\"CACHE HIT: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            debug!(?result, \"CACHE HIT\");\n             return Ok(result);\n         }\n \n         if let Some(result) = stack.cache().get_provisional(fresh_trait_ref) {\n-            debug!(\"PROVISIONAL CACHE HIT: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            debug!(?result, \"PROVISIONAL CACHE HIT\");\n             stack.update_reached_depth(stack.cache().current_reached_depth());\n             return Ok(result);\n         }\n@@ -662,7 +664,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let reached_depth = stack.reached_depth.get();\n         if reached_depth >= stack.depth {\n-            debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            debug!(?result, \"CACHE MISS\");\n             self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n \n             stack.cache().on_completion(stack.depth, |fresh_trait_ref, provisional_result| {\n@@ -674,7 +676,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 );\n             });\n         } else {\n-            debug!(\"PROVISIONAL: {:?}={:?}\", fresh_trait_ref, result);\n+            debug!(?result, \"PROVISIONAL\");\n             debug!(\n                 \"evaluate_trait_predicate_recursively: caching provisionally because {:?} \\\n                  is a cycle participant (at depth {}, reached depth {})\",\n@@ -719,10 +721,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .map(|stack| stack.depth)\n         {\n-            debug!(\n-                \"evaluate_stack({:?}) --> recursive at depth {}\",\n-                stack.fresh_trait_ref, cycle_depth,\n-            );\n+            debug!(\"evaluate_stack --> recursive at depth {}\", cycle_depth);\n \n             // If we have a stack like `A B C D E A`, where the top of\n             // the stack is the final `A`, then this will iterate over\n@@ -742,10 +741,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let cycle =\n                 cycle.map(|stack| stack.obligation.predicate.without_const().to_predicate(tcx));\n             if self.coinductive_match(cycle) {\n-                debug!(\"evaluate_stack({:?}) --> recursive, coinductive\", stack.fresh_trait_ref);\n+                debug!(\"evaluate_stack --> recursive, coinductive\");\n                 Some(EvaluatedToOk)\n             } else {\n-                debug!(\"evaluate_stack({:?}) --> recursive, inductive\", stack.fresh_trait_ref);\n+                debug!(\"evaluate_stack --> recursive, inductive\");\n                 Some(EvaluatedToRecur)\n             }\n         } else {\n@@ -786,10 +785,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // This check was an imperfect workaround for a bug in the old\n         // intercrate mode; it should be removed when that goes away.\n         if unbound_input_types && self.intercrate {\n-            debug!(\n-                \"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n-                stack.fresh_trait_ref\n-            );\n+            debug!(\"evaluate_stack --> unbound argument, intercrate -->  ambiguous\",);\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n             if self.intercrate_ambiguity_causes.is_some() {\n                 debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n@@ -807,7 +803,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 },\n                             });\n \n-                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n+                        debug!(?cause, \"evaluate_stack: pushing cause\");\n                         self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n                     }\n                 }\n@@ -824,10 +820,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     )\n             })\n         {\n-            debug!(\n-                \"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n-                stack.fresh_trait_ref\n-            );\n+            debug!(\"evaluate_stack --> unbound argument, recursive --> giving up\",);\n             return Ok(EvaluatedToUnknown);\n         }\n \n@@ -860,27 +853,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::PredicateAtom::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n-        debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n+        debug!(?predicate, ?result, \"coinductive_predicate\");\n         result\n     }\n \n     /// Further evaluates `candidate` to decide whether all type parameters match and whether nested\n     /// obligations are met. Returns whether `candidate` remains viable after this further\n     /// scrutiny.\n+    #[instrument(\n+        level = \"debug\",\n+        skip(self, stack),\n+        fields(depth = stack.obligation.recursion_depth)\n+    )]\n     fn evaluate_candidate<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n         candidate: &SelectionCandidate<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        debug!(\n-            \"evaluate_candidate: depth={} candidate={:?}\",\n-            stack.obligation.recursion_depth, candidate\n-        );\n         let result = self.evaluation_probe(|this| {\n             let candidate = (*candidate).clone();\n             match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => {\n-                    debug!(\"evaluate_candidate: selection = {:?}\", selection);\n+                    debug!(?selection);\n                     this.evaluate_predicates_recursively(\n                         stack.list(),\n                         selection.nested_obligations().into_iter(),\n@@ -889,10 +883,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(..) => Ok(EvaluatedToErr),\n             }\n         })?;\n-        debug!(\n-            \"evaluate_candidate: depth={} result={:?}\",\n-            stack.obligation.recursion_depth, result\n-        );\n+        debug!(?result);\n         Ok(result)\n     }\n \n@@ -925,10 +916,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         if self.can_use_global_caches(param_env) {\n             if !trait_ref.needs_infer() {\n-                debug!(\n-                    \"insert_evaluation_cache(trait_ref={:?}, candidate={:?}) global\",\n-                    trait_ref, result,\n-                );\n+                debug!(?trait_ref, ?result, \"insert_evaluation_cache global\");\n                 // This may overwrite the cache with the same value\n                 // FIXME: Due to #50507 this overwrites the different values\n                 // This should be changed to use HashMapExt::insert_same\n@@ -938,7 +926,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         }\n \n-        debug!(\"insert_evaluation_cache(trait_ref={:?}, candidate={:?})\", trait_ref, result,);\n+        debug!(?trait_ref, ?result, \"insert_evaluation_cache\");\n         self.infcx.evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n     }\n \n@@ -1127,11 +1115,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let trait_ref = cache_fresh_trait_pred.skip_binder().trait_ref;\n \n         if !self.can_cache_candidate(&candidate) {\n-            debug!(\n-                \"insert_candidate_cache(trait_ref={:?}, candidate={:?} -\\\n-                 candidate is not cacheable\",\n-                trait_ref, candidate\n-            );\n+            debug!(?trait_ref, ?candidate, \"insert_candidate_cache - candidate is not cacheable\");\n             return;\n         }\n \n@@ -1140,21 +1124,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // Don't cache overflow globally; we only produce this in certain modes.\n             } else if !trait_ref.needs_infer() {\n                 if !candidate.needs_infer() {\n-                    debug!(\n-                        \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) global\",\n-                        trait_ref, candidate,\n-                    );\n+                    debug!(?trait_ref, ?candidate, \"insert_candidate_cache global\");\n                     // This may overwrite the cache with the same value.\n                     tcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n                     return;\n                 }\n             }\n         }\n \n-        debug!(\n-            \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) local\",\n-            trait_ref, candidate,\n-        );\n+        debug!(?trait_ref, ?candidate, \"insert_candidate_cache local\");\n         self.infcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n     }\n \n@@ -1172,9 +1150,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let placeholder_trait_predicate =\n             self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!(\n-            \"match_projection_obligation_against_definition_bounds: \\\n-             placeholder_trait_predicate={:?}\",\n-            placeholder_trait_predicate,\n+            ?placeholder_trait_predicate,\n+            \"match_projection_obligation_against_definition_bounds\"\n         );\n \n         let tcx = self.infcx.tcx;\n@@ -1225,11 +1202,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .collect();\n \n-        debug!(\n-            \"match_projection_obligation_against_definition_bounds: \\\n-             matching_bounds={:?}\",\n-            matching_bounds\n-        );\n+        debug!(?matching_bounds, \"match_projection_obligation_against_definition_bounds\");\n         matching_bounds\n     }\n \n@@ -1816,6 +1789,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n+        debug!(?impl_def_id, ?obligation, \"match_impl\");\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n@@ -1844,11 +1818,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 )\n             });\n \n-        debug!(\n-            \"match_impl(impl_def_id={:?}, obligation={:?}, \\\n-             impl_trait_ref={:?}, placeholder_obligation_trait_ref={:?})\",\n-            impl_def_id, obligation, impl_trait_ref, placeholder_obligation_trait_ref\n-        );\n+        debug!(?impl_trait_ref, ?placeholder_obligation_trait_ref);\n \n         let InferOk { obligations, .. } = self\n             .infcx\n@@ -1864,7 +1834,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n+        debug!(?impl_substs, \"match_impl: success\");\n         Ok(Normalized { value: impl_substs, obligations: nested_obligations })\n     }\n \n@@ -1926,10 +1896,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n-        debug!(\n-            \"match_poly_trait_ref: obligation={:?} poly_trait_ref={:?}\",\n-            obligation, poly_trait_ref\n-        );\n+        debug!(?obligation, ?poly_trait_ref, \"match_poly_trait_ref\");\n \n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n@@ -1976,10 +1943,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> ty::PolyTraitRef<'tcx> {\n-        debug!(\"closure_trait_ref_unnormalized(obligation={:?}, substs={:?})\", obligation, substs);\n+        debug!(?obligation, ?substs, \"closure_trait_ref_unnormalized\");\n         let closure_sig = substs.as_closure().sig();\n \n-        debug!(\"closure_trait_ref_unnormalized: closure_sig = {:?}\", closure_sig);\n+        debug!(?closure_sig);\n \n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an unboxed closure type and hence is\n@@ -2030,7 +1997,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         def_id: DefId,           // of impl or trait\n         substs: SubstsRef<'tcx>, // for impl or trait\n     ) -> Vec<PredicateObligation<'tcx>> {\n-        debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n+        debug!(?def_id, \"impl_or_trait_obligations\");\n         let tcx = self.tcx();\n \n         // To allow for one-pass evaluation of the nested obligation,\n@@ -2152,10 +2119,10 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n             self.depth,\n             reached_depth,\n         );\n-        debug!(\"update_reached_depth(reached_depth={})\", reached_depth);\n+        debug!(reached_depth, \"update_reached_depth\");\n         let mut p = self;\n         while reached_depth < p.depth {\n-            debug!(\"update_reached_depth: marking {:?} as cycle participant\", p.fresh_trait_ref);\n+            debug!(?p.fresh_trait_ref, \"update_reached_depth: marking as cycle participant\");\n             p.reached_depth.set(p.reached_depth.get().min(reached_depth));\n             p = p.previous.head.unwrap();\n         }\n@@ -2282,10 +2249,10 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     /// `self.current_reached_depth()` and above.\n     fn get_provisional(&self, fresh_trait_ref: ty::PolyTraitRef<'tcx>) -> Option<EvaluationResult> {\n         debug!(\n-            \"get_provisional(fresh_trait_ref={:?}) = {:#?} with reached-depth {}\",\n-            fresh_trait_ref,\n+            ?fresh_trait_ref,\n+            reached_depth = ?self.reached_depth.get(),\n+            \"get_provisional = {:#?}\",\n             self.map.borrow().get(&fresh_trait_ref),\n-            self.reached_depth.get(),\n         );\n         Some(self.map.borrow().get(&fresh_trait_ref)?.result)\n     }\n@@ -2308,14 +2275,11 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n         result: EvaluationResult,\n     ) {\n-        debug!(\n-            \"insert_provisional(from_dfn={}, reached_depth={}, fresh_trait_ref={:?}, result={:?})\",\n-            from_dfn, reached_depth, fresh_trait_ref, result,\n-        );\n+        debug!(?from_dfn, ?reached_depth, ?fresh_trait_ref, ?result, \"insert_provisional\");\n         let r_d = self.reached_depth.get();\n         self.reached_depth.set(r_d.min(reached_depth));\n \n-        debug!(\"insert_provisional: reached_depth={:?}\", self.reached_depth.get());\n+        debug!(reached_depth = self.reached_depth.get());\n \n         self.map.borrow_mut().insert(fresh_trait_ref, ProvisionalEvaluation { from_dfn, result });\n     }\n@@ -2329,7 +2293,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     /// these provisional entries must either depend on it or some\n     /// ancestor of it.\n     fn on_failure(&self, dfn: usize) {\n-        debug!(\"on_failure(dfn={:?})\", dfn,);\n+        debug!(?dfn, \"on_failure\");\n         self.map.borrow_mut().retain(|key, eval| {\n             if !eval.from_dfn >= dfn {\n                 debug!(\"on_failure: removing {:?}\", key);\n@@ -2350,15 +2314,15 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         depth: usize,\n         mut op: impl FnMut(ty::PolyTraitRef<'tcx>, EvaluationResult),\n     ) {\n-        debug!(\"on_completion(depth={}, reached_depth={})\", depth, self.reached_depth.get(),);\n+        debug!(?depth, reached_depth = ?self.reached_depth.get(), \"on_completion\");\n \n         if self.reached_depth.get() < depth {\n             debug!(\"on_completion: did not yet reach depth to complete\");\n             return;\n         }\n \n         for (fresh_trait_ref, eval) in self.map.borrow_mut().drain() {\n-            debug!(\"on_completion: fresh_trait_ref={:?} eval={:?}\", fresh_trait_ref, eval,);\n+            debug!(?fresh_trait_ref, ?eval, \"on_completion\");\n \n             op(fresh_trait_ref, eval.result);\n         }"}]}