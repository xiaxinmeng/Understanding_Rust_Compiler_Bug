{"sha": "b2764a6641be5caef3d62dfb80c836e4976194f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNzY0YTY2NDFiZTVjYWVmM2Q2MmRmYjgwYzgzNmU0OTc2MTk0ZjM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-09T17:24:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-09T17:24:09Z"}, "message": "Future proof completion scores", "tree": {"sha": "eed8266943c9c2e7d172b598077fbf1514068e0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eed8266943c9c2e7d172b598077fbf1514068e0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2764a6641be5caef3d62dfb80c836e4976194f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2764a6641be5caef3d62dfb80c836e4976194f3", "html_url": "https://github.com/rust-lang/rust/commit/b2764a6641be5caef3d62dfb80c836e4976194f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2764a6641be5caef3d62dfb80c836e4976194f3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73b9937e4eea2633005e7d2814cb7990e5f20e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/73b9937e4eea2633005e7d2814cb7990e5f20e8f", "html_url": "https://github.com/rust-lang/rust/commit/73b9937e4eea2633005e7d2814cb7990e5f20e8f"}], "stats": {"total": 168, "additions": 96, "deletions": 72}, "files": [{"sha": "14afec603cda41fc3f3de1044290436de9341131", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=b2764a6641be5caef3d62dfb80c836e4976194f3", "patch": "@@ -63,8 +63,14 @@ pub struct CompletionItem {\n     /// after completion.\n     trigger_call_info: bool,\n \n-    /// Score is useful to pre select or display in better order completion items\n-    score: Option<CompletionScore>,\n+    /// We use this to sort completion. Relevance records facts like \"do the\n+    /// types align precisely?\". We can't sort by relevances directly, they are\n+    /// only partially ordered.\n+    ///\n+    /// Note that Relevance ignores fuzzy match score. We compute Relevance for\n+    /// all possible items, and then separately build an ordered completion list\n+    /// based on relevance and fuzzy matching with the already typed identifier.\n+    relevance: Relevance,\n \n     /// Indicates that a reference or mutable reference to this variable is a\n     /// possible match.\n@@ -101,8 +107,8 @@ impl fmt::Debug for CompletionItem {\n         if self.deprecated {\n             s.field(\"deprecated\", &true);\n         }\n-        if let Some(score) = &self.score {\n-            s.field(\"score\", score);\n+        if self.relevance.is_relevant() {\n+            s.field(\"relevance\", &self.relevance);\n         }\n         if let Some(mutability) = &self.ref_match {\n             s.field(\"ref_match\", &format!(\"&{}\", mutability.as_keyword_for_ref()));\n@@ -122,6 +128,36 @@ pub enum CompletionScore {\n     TypeAndNameMatch,\n }\n \n+#[derive(Debug, Clone, Copy, Ord, PartialOrd, Eq, PartialEq, Default)]\n+pub struct Relevance {\n+    /// This is set in cases like these:\n+    ///\n+    /// ```\n+    /// fn f(spam: String) {}\n+    /// fn main {\n+    ///     let spam = 92;\n+    ///     f($0) // name of local matches the name of param\n+    /// }\n+    /// ```\n+    pub exact_name_match: bool,\n+    /// This is set in cases like these:\n+    ///\n+    /// ```\n+    /// fn f(spam: String) {}\n+    /// fn main {\n+    ///     let foo = String::new();\n+    ///     f($0) // type of local matches the type of param\n+    /// }\n+    /// ```\n+    pub exact_type_match: bool,\n+}\n+\n+impl Relevance {\n+    pub fn is_relevant(&self) -> bool {\n+        self != &Relevance::default()\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum CompletionItemKind {\n     SymbolKind(SymbolKind),\n@@ -213,7 +249,7 @@ impl CompletionItem {\n             text_edit: None,\n             deprecated: false,\n             trigger_call_info: None,\n-            score: None,\n+            relevance: Relevance::default(),\n             ref_match: None,\n             import_to_add: None,\n         }\n@@ -256,8 +292,8 @@ impl CompletionItem {\n         self.deprecated\n     }\n \n-    pub fn score(&self) -> Option<CompletionScore> {\n-        self.score\n+    pub fn relevance(&self) -> Relevance {\n+        self.relevance\n     }\n \n     pub fn trigger_call_info(&self) -> bool {\n@@ -313,7 +349,7 @@ pub(crate) struct Builder {\n     text_edit: Option<TextEdit>,\n     deprecated: bool,\n     trigger_call_info: Option<bool>,\n-    score: Option<CompletionScore>,\n+    relevance: Relevance,\n     ref_match: Option<Mutability>,\n }\n \n@@ -360,7 +396,7 @@ impl Builder {\n             completion_kind: self.completion_kind,\n             deprecated: self.deprecated,\n             trigger_call_info: self.trigger_call_info.unwrap_or(false),\n-            score: self.score,\n+            relevance: self.relevance,\n             ref_match: self.ref_match,\n             import_to_add: self.import_to_add,\n         }\n@@ -421,8 +457,8 @@ impl Builder {\n         self.deprecated = deprecated;\n         self\n     }\n-    pub(crate) fn set_score(mut self, score: CompletionScore) -> Builder {\n-        self.score = Some(score);\n+    pub(crate) fn set_relevance(mut self, relevance: Relevance) -> Builder {\n+        self.relevance = relevance;\n         self\n     }\n     pub(crate) fn trigger_call_info(mut self) -> Builder {"}, {"sha": "d46f521a02afb6361617d8f8d960af37978fce03", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=b2764a6641be5caef3d62dfb80c836e4976194f3", "patch": "@@ -23,7 +23,10 @@ use crate::{completions::Completions, context::CompletionContext, item::Completi\n \n pub use crate::{\n     config::CompletionConfig,\n-    item::{CompletionItem, CompletionItemKind, CompletionScore, ImportEdit, InsertTextFormat},\n+    item::{\n+        CompletionItem, CompletionItemKind, CompletionScore, ImportEdit, InsertTextFormat,\n+        Relevance,\n+    },\n };\n \n //FIXME: split the following feature into fine-grained features."}, {"sha": "8c8b149a17935be32de9e0897485731f737fd2d6", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 41, "deletions": 58, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=b2764a6641be5caef3d62dfb80c836e4976194f3", "patch": "@@ -20,8 +20,8 @@ use ide_db::{\n use syntax::TextRange;\n \n use crate::{\n-    item::ImportEdit, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n-    CompletionScore,\n+    item::{ImportEdit, Relevance},\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n };\n \n use crate::render::{enum_variant::render_variant, function::render_fn, macro_::render_macro};\n@@ -117,7 +117,7 @@ impl<'a> RenderContext<'a> {\n         node.docs(self.db())\n     }\n \n-    fn active_name_and_type(&self) -> Option<(String, Type)> {\n+    fn expected_name_and_type(&self) -> Option<(String, Type)> {\n         if let Some(record_field) = &self.completion.record_field_syntax {\n             cov_mark::hit!(record_field_type_match);\n             let (struct_field, _local) = self.completion.sema.resolve_record_field(record_field)?;\n@@ -155,8 +155,8 @@ impl<'a> Render<'a> {\n         .set_documentation(field.docs(self.ctx.db()))\n         .set_deprecated(is_deprecated);\n \n-        if let Some(score) = compute_score(&self.ctx, &ty, &name.to_string()) {\n-            item = item.set_score(score);\n+        if let Some(relevance) = compute_relevance(&self.ctx, &ty, &name.to_string()) {\n+            item = item.set_relevance(relevance);\n         }\n \n         item.build()\n@@ -247,18 +247,15 @@ impl<'a> Render<'a> {\n         };\n \n         if let ScopeDef::Local(local) = resolution {\n-            if let Some((active_name, active_type)) = self.ctx.active_name_and_type() {\n-                let ty = local.ty(self.ctx.db());\n-                if let Some(score) =\n-                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n-                {\n-                    item = item.set_score(score);\n-                }\n-\n-                if let Some(ty_without_ref) = active_type.remove_ref() {\n+            let ty = local.ty(self.ctx.db());\n+            if let Some(relevance) = compute_relevance(&self.ctx, &ty, &local_name) {\n+                item = item.set_relevance(relevance)\n+            }\n+            if let Some((_expected_name, expected_type)) = self.ctx.expected_name_and_type() {\n+                if let Some(ty_without_ref) = expected_type.remove_ref() {\n                     if ty_without_ref == ty {\n                         cov_mark::hit!(suggest_ref);\n-                        let mutability = if active_type.is_mutable_reference() {\n+                        let mutability = if expected_type.is_mutable_reference() {\n                             Mutability::Mut\n                         } else {\n                             Mutability::Shared\n@@ -326,33 +323,14 @@ impl<'a> Render<'a> {\n     }\n }\n \n-fn compute_score_from_active(\n-    active_type: &Type,\n-    active_name: &str,\n-    ty: &Type,\n-    name: &str,\n-) -> Option<CompletionScore> {\n-    // Compute score\n-    // For the same type\n-    if active_type != ty {\n-        return None;\n-    }\n-\n-    let mut res = CompletionScore::TypeMatch;\n-\n-    // If same type + same name then go top position\n-    if active_name == name {\n-        res = CompletionScore::TypeAndNameMatch\n-    }\n-\n+fn compute_relevance(ctx: &RenderContext, ty: &Type, name: &str) -> Option<Relevance> {\n+    let (expected_name, expected_type) = ctx.expected_name_and_type()?;\n+    let mut res = Relevance::default();\n+    res.exact_type_match = ty == &expected_type;\n+    res.exact_name_match = name == &expected_name;\n     Some(res)\n }\n \n-fn compute_score(ctx: &RenderContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n-    let (active_name, active_type) = ctx.active_name_and_type()?;\n-    compute_score_from_active(&active_type, &active_name, ty, name)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::cmp::Reverse;\n@@ -361,32 +339,33 @@ mod tests {\n \n     use crate::{\n         test_utils::{check_edit, do_completion, get_all_items, TEST_CONFIG},\n-        CompletionKind, CompletionScore,\n+        CompletionKind, Relevance,\n     };\n \n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = do_completion(ra_fixture, CompletionKind::Reference);\n         expect.assert_debug_eq(&actual);\n     }\n \n-    fn check_scores(ra_fixture: &str, expect: Expect) {\n-        fn display_score(score: Option<CompletionScore>) -> &'static str {\n-            match score {\n-                Some(CompletionScore::TypeMatch) => \"[type]\",\n-                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n-                None => \"[]\".into(),\n+    fn check_relevance(ra_fixture: &str, expect: Expect) {\n+        fn display_relevance(relevance: Relevance) -> &'static str {\n+            match relevance {\n+                Relevance { exact_type_match: true, exact_name_match: true } => \"[type+name]\",\n+                Relevance { exact_type_match: true, exact_name_match: false } => \"[type]\",\n+                Relevance { exact_type_match: false, exact_name_match: true } => \"[name]\",\n+                Relevance { exact_type_match: false, exact_name_match: false } => \"[]\",\n             }\n         }\n \n         let mut completions = get_all_items(TEST_CONFIG, ra_fixture);\n-        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n+        completions.sort_by_key(|it| (Reverse(it.relevance()), it.label().to_string()));\n         let actual = completions\n             .into_iter()\n             .filter(|it| it.completion_kind == CompletionKind::Reference)\n             .map(|it| {\n                 let tag = it.kind().unwrap().tag();\n-                let score = display_score(it.score());\n-                format!(\"{} {} {}\\n\", tag, it.label(), score)\n+                let relevance = display_relevance(it.relevance());\n+                format!(\"{} {} {}\\n\", tag, it.label(), relevance)\n             })\n             .collect::<String>();\n         expect.assert_eq(&actual);\n@@ -849,9 +828,9 @@ fn foo(xs: Vec<i128>)\n     }\n \n     #[test]\n-    fn active_param_score() {\n+    fn active_param_relevance() {\n         cov_mark::check!(active_param_type_match);\n-        check_scores(\n+        check_relevance(\n             r#\"\n struct S { foo: i64, bar: u32, baz: u32 }\n fn test(bar: u32) { }\n@@ -866,9 +845,9 @@ fn foo(s: S) { test(s.$0) }\n     }\n \n     #[test]\n-    fn record_field_scores() {\n+    fn record_field_relevances() {\n         cov_mark::check!(record_field_type_match);\n-        check_scores(\n+        check_relevance(\n             r#\"\n struct A { foo: i64, bar: u32, baz: u32 }\n struct B { x: (), y: f32, bar: u32 }\n@@ -883,8 +862,8 @@ fn foo(a: A) { B { bar: a.$0 }; }\n     }\n \n     #[test]\n-    fn record_field_and_call_scores() {\n-        check_scores(\n+    fn record_field_and_call_relevances() {\n+        check_relevance(\n             r#\"\n struct A { foo: i64, bar: u32, baz: u32 }\n struct B { x: (), y: f32, bar: u32 }\n@@ -897,7 +876,7 @@ fn foo(a: A) { B { bar: f(a.$0) }; }\n                 fd baz []\n             \"#]],\n         );\n-        check_scores(\n+        check_relevance(\n             r#\"\n struct A { foo: i64, bar: u32, baz: u32 }\n struct B { x: (), y: f32, bar: u32 }\n@@ -914,7 +893,7 @@ fn foo(a: A) { f(B { bar: a.$0 }); }\n \n     #[test]\n     fn prioritize_exact_ref_match() {\n-        check_scores(\n+        check_relevance(\n             r#\"\n struct WorldSnapshot { _f: () };\n fn go(world: &WorldSnapshot) { go(w$0) }\n@@ -929,7 +908,7 @@ fn go(world: &WorldSnapshot) { go(w$0) }\n \n     #[test]\n     fn too_many_arguments() {\n-        check_scores(\n+        check_relevance(\n             r#\"\n struct Foo;\n fn f(foo: &Foo) { f(foo, w$0) }\n@@ -997,6 +976,10 @@ fn main() {\n                             Local,\n                         ),\n                         detail: \"S\",\n+                        relevance: Relevance {\n+                            exact_name_match: true,\n+                            exact_type_match: false,\n+                        },\n                         ref_match: \"&mut \",\n                     },\n                 ]"}, {"sha": "a9846fa7055952844fa48ef55380f137886bc26f", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2764a6641be5caef3d62dfb80c836e4976194f3/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=b2764a6641be5caef3d62dfb80c836e4976194f3", "patch": "@@ -213,7 +213,7 @@ pub(crate) fn completion_item(\n         ..Default::default()\n     };\n \n-    if item.score().is_some() {\n+    if item.relevance().is_relevant() {\n         lsp_item.preselect = Some(true);\n         // HACK: sort preselect items first\n         lsp_item.sort_text = Some(format!(\" {}\", item.label()));\n@@ -1106,7 +1106,9 @@ mod tests {\n             [\n                 (\n                     \"&arg\",\n-                    None,\n+                    Some(\n+                        \" arg\",\n+                    ),\n                 ),\n                 (\n                     \"arg\","}]}