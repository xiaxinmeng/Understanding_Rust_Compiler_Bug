{"sha": "478b2988c0715ae90018dd0930de06a507ecedf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OGIyOTg4YzA3MTVhZTkwMDE4ZGQwOTMwZGUwNmE1MDdlY2VkZjc=", "commit": {"author": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-17T17:22:57Z"}, "committer": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-17T17:22:57Z"}, "message": "Add Destructure Tuple", "tree": {"sha": "915bca8cc77746a0ad4710cd3df74bce79d49227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/915bca8cc77746a0ad4710cd3df74bce79d49227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/478b2988c0715ae90018dd0930de06a507ecedf7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEJTdsK5zmAD3L8AFljIMXU7iI9loFAmEb8HEACgkQjIMXU7iI\n9lpdxQ//aYqPnUNbMcANVVEDqeNR4xx683X99uG4QcmC8gUwvgDmEJjQQTUH6lX4\nn/imflEOkbrN2OxFpSrHrtrTMygEHAkMM5lziNm9gO8tOtK0SxAm1z4Z62bhBIzT\nX5FAYVE+vKtOLuBdwPIUelW56KZEvAehSOUxiOQdLNvuB/vtl3jdUZw12zKlUMb3\nJ7VX3e1QFJocO76HYogFyU/skvWB+8hRCFrEp62xpAOPtylmog6fAvrHaASwK+EQ\nN3Km2IHTeqyLp2NxZp8IqE5ANDKpY19AxSfEZUfFVMDd/s562fTeFq4QrwVBLs21\nt1759EcxipwjqCEm38AfZbiO5m54y73+Tt+jSagFnqzsJZgZ6y7lE4Wzm1PlwKlJ\neIOdonoTiQdvKz5z2lBFxZNXw263rSo1Weg5U9MONv4WFOvb3MpiVDIY5bVXm7yh\n5uyoJajfhXCM3pBtGeA12OGaoqSUzarBykHgCYTL6umYAzIVAZ+19Kn0N5M/Ur91\n43HD1SgkTy+70sCHKNPP9nALm/bl+D0DlBIFv6Fn2plgJCV1kY65Q+Ccy5Rizu60\ntfIiFXOddZolScrd9YtvJ8RzIYvZNt/UuiDoE2wcw3w+Pm72WYrvZtMXUhmO6qjM\nDgvVmnPAQdTuHFzGUuI4uHnwA0oghw8poU6Q7BZGPy96OI+p/SM=\n=v8WI\n-----END PGP SIGNATURE-----", "payload": "tree 915bca8cc77746a0ad4710cd3df74bce79d49227\nparent d1ba9931368c657d4739f0f238c322ace4b3e6ec\nauthor BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629220977 +0200\ncommitter BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629220977 +0200\n\nAdd Destructure Tuple\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/478b2988c0715ae90018dd0930de06a507ecedf7", "html_url": "https://github.com/rust-lang/rust/commit/478b2988c0715ae90018dd0930de06a507ecedf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/478b2988c0715ae90018dd0930de06a507ecedf7/comments", "author": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ba9931368c657d4739f0f238c322ace4b3e6ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ba9931368c657d4739f0f238c322ace4b3e6ec", "html_url": "https://github.com/rust-lang/rust/commit/d1ba9931368c657d4739f0f238c322ace4b3e6ec"}], "stats": {"total": 896, "additions": 896, "deletions": 0}, "files": [{"sha": "4cc0ece3f40cbdf5214edb24fcd3966126947d19", "filename": "crates/ide_assists/src/handlers/destructure_tuple_binding.rs", "status": "added", "additions": 894, "deletions": 0, "changes": 894, "blob_url": "https://github.com/rust-lang/rust/blob/478b2988c0715ae90018dd0930de06a507ecedf7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478b2988c0715ae90018dd0930de06a507ecedf7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=478b2988c0715ae90018dd0930de06a507ecedf7", "patch": "@@ -0,0 +1,894 @@\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    defs::Definition,\n+    search::{FileReference, SearchScope, UsageSearchResult},\n+};\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, AstNode, FieldExpr, IdentPat, NameOwner},\n+    SyntaxNode, TextRange,\n+};\n+\n+use crate::assist_context::{AssistBuilder, AssistContext, Assists};\n+\n+// Assist: destructure_tuple_binding\n+//\n+// Destructures a tuple binding into its items.\n+//\n+// ```\n+// fn main() {\n+//     let $0t = (1,2);\n+//     let v = t.0;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let (_0, _1) = (1,2);\n+//     let v = _0;\n+// }\n+// ```\n+\n+pub(crate) fn destructure_tuple_binding(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    // find variable pattern under cursor\n+    let ident_pat = ctx.find_node_at_offset::<ast::IdentPat>()?;\n+    let data = collect_data(ident_pat, ctx)?;\n+\n+    acc.add(\n+        AssistId(\"destructure_tuple\", AssistKind::RefactorRewrite),\n+        \"Destructure tuple\",\n+        data.range,\n+        |builder| {\n+            edit_tuple_assignment(&data, builder, ctx);\n+            edit_tuple_usages(&data, builder, ctx);\n+        },\n+    );\n+\n+    Some(())\n+}\n+\n+fn collect_data(ident_pat: IdentPat, ctx: &AssistContext) -> Option<TupleData> {\n+    if ident_pat.at_token().is_some() {\n+        // cannot destructure pattern with sub-pattern:\n+        // Only IdentPat can have sub-pattern,\n+        // but not TuplePat (`(a,b)`)\n+        cov_mark::hit!(destructure_tuple_subpattern);\n+        return None;\n+    }\n+\n+    let ty = ctx.sema.type_of_pat(&ident_pat.clone().into())?;\n+    // might be reference\n+    let ty = ty.strip_references();\n+    // must be tuple\n+    let field_types = ty.tuple_fields(ctx.db());\n+    if field_types.is_empty() {\n+        cov_mark::hit!(destructure_tuple_no_tuple);\n+        return None;\n+    }\n+\n+    let name = ident_pat.name()?.to_string();\n+    let range = ident_pat.syntax().text_range();\n+\n+    let usages = ctx.sema.to_def(&ident_pat).map(|def| {\n+        Definition::Local(def)\n+            .usages(&ctx.sema)\n+            .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+            .all()\n+    });\n+\n+    let field_names = (0..field_types.len())\n+        .map(|i| generate_name(i, &name, &ident_pat, &usages, ctx))\n+        .collect_vec();\n+\n+    Some(TupleData { range, field_names, usages })\n+}\n+\n+fn generate_name(\n+    index: usize,\n+    _tuple_name: &str,\n+    _ident_pat: &IdentPat,\n+    _usages: &Option<UsageSearchResult>,\n+    _ctx: &AssistContext,\n+) -> String {\n+    //TODO: detect if name already used\n+    format!(\"_{}\", index)\n+}\n+\n+struct TupleData {\n+    // ident_pat: IdentPat,\n+    // name: String,\n+    range: TextRange,\n+    field_names: Vec<String>,\n+    // field_types: Vec<Type>,\n+    usages: Option<UsageSearchResult>,\n+}\n+fn edit_tuple_assignment(data: &TupleData, builder: &mut AssistBuilder, ctx: &AssistContext) {\n+    let new_tuple = {\n+        let fields = data\n+            .field_names\n+            .iter()\n+            .map(|name| ast::Pat::from(ast::make::ident_pat(false, false, ast::make::name(name))));\n+        ast::make::tuple_pat(fields)\n+    };\n+\n+    match ctx.config.snippet_cap {\n+        Some(cap) => {\n+            // No support for placeholders in Code Actions, except for special rust analyzer handling which supports only first `$0`\n+            //  -> place cursor on first variable\n+            let mut snip = new_tuple.to_string();\n+            snip.insert_str(1, \"$0\");\n+            builder.replace_snippet(cap, data.range, snip);\n+        }\n+        None => builder.replace(data.range, new_tuple.to_string()),\n+    };\n+}\n+\n+fn edit_tuple_usages(\n+    data: &TupleData,\n+    builder: &mut AssistBuilder,\n+    ctx: &AssistContext,\n+) {\n+    if let Some(usages) = data.usages.as_ref() {\n+        for (file_id, refs) in usages.iter() {\n+            builder.edit_file(*file_id);\n+    \n+            for r in refs {\n+                edit_tuple_usage(r, data, builder, ctx);\n+            }\n+        }\n+    }\n+}\n+fn edit_tuple_usage(\n+    usage: &FileReference,\n+    data: &TupleData,\n+    builder: &mut AssistBuilder,\n+    _ctx: &AssistContext,\n+) {\n+    match detect_tuple_index(usage.name.syntax(), data) {\n+        Some((expr, idx)) => {\n+            // index field access\n+            let text = &data.field_names[idx];\n+            let range = expr.syntax().text_range();\n+            builder.replace(range, text);\n+        }\n+        None => {\n+            // no index access -> make invalid -> requires handling by user\n+            // -> put usage in block comment\n+            builder.insert(usage.range.start(), \"/*\");\n+            builder.insert(usage.range.end(), \"*/\");\n+        }\n+    }\n+}\n+\n+fn detect_tuple_index(usage: &SyntaxNode, data: &TupleData) -> Option<(FieldExpr, usize)> {\n+    // usage is IDENT\n+    // IDENT\n+    //  NAME_REF\n+    //   PATH_SEGMENT\n+    //    PATH\n+    //     PATH_EXPR\n+    //      PAREN_EXRP*\n+    //       FIELD_EXPR\n+    let node = usage\n+        .ancestors()\n+        .skip_while(|s| !ast::PathExpr::can_cast(s.kind()))\n+        .skip(1) // PATH_EXPR\n+        .find(|s| !ast::ParenExpr::can_cast(s.kind()))?;    // skip parentheses\n+\n+    if let Some(field_expr) = ast::FieldExpr::cast(node) {\n+        let idx = field_expr.name_ref()?.as_tuple_field()?;\n+        if idx < data.field_names.len() {\n+            Some((field_expr, idx))\n+        } else {\n+            // tuple index out of range\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn dont_trigger_on_unit() {\n+        cov_mark::check!(destructure_tuple_no_tuple);\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+let $0v = ();\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn dont_trigger_on_number() {\n+        cov_mark::check!(destructure_tuple_no_tuple);\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+let $0v = 32;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn destructure_3_tuple() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn destructure_2_tuple() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn replace_indices() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+    let v1 = tup.0;\n+    let v2 = tup.1;\n+    let v3 = tup.2;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let v1 = _0;\n+    let v2 = _1;\n+    let v3 = _2;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_usage_in_parentheses() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+    let a = (tup).1;\n+    let b = ((tup)).1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let a = _1;\n+    let b = _1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn handle_function_call() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2);\n+    let v = tup.into();\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    let v = /*tup*/.into();\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn handle_invalid_index() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2);\n+    let v = tup.3;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    let v = /*tup*/.3;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_replace_variable_with_same_name_as_tuple() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let tup = (1,2);\n+    let v = tup.1;\n+    let $0tup = (1,2,3);\n+    let v = tup.1;\n+    let tup = (1,2,3);\n+    let v = tup.1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let tup = (1,2);\n+    let v = tup.1;\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let v = _1;\n+    let tup = (1,2,3);\n+    let v = tup.1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn keep_function_call_in_tuple_item() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0t = (\"3.14\", 0);\n+    let pi: f32 = t.0.parse().unwrap();\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (\"3.14\", 0);\n+    let pi: f32 = _0.parse().unwrap();\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn keep_type() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0t: (usize, i32) = (1,2);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1): (usize, i32) = (1,2);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn destructure_reference() {\n+        //Note: `v` has different types:\n+        // * in 1st: `i32`\n+        // * in 2nd: `&i32`\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let $0t = &t;\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let ($0_0, _1) = &t;\n+    let v = _0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn destructure_multiple_reference() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let $0t = &&t;\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let ($0_0, _1) = &&t;\n+    let v = _0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn keep_reference() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn foo(t: &(usize, usize)) -> usize {\n+    match t {\n+        &$0t => t.0\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn foo(t: &(usize, usize)) -> usize {\n+    match t {\n+        &($0_0, _1) => _0\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_for_non_tuple_reference() {\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let v = 42;\n+    let $0v = &42;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_on_static_tuple() {\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+static $0TUP: (usize, usize) = (1,2);\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_on_wildcard() {\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0_ = (1,2);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_in_struct() {\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+struct S {\n+    $0tup: (usize, usize),\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_in_struct_creation() {\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+struct S {\n+    tup: (usize, usize),\n+}\n+fn main() {\n+    let s = S {\n+        $0tup: (1,2),\n+    };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_on_tuple_struct() {\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+struct S(usize, usize);\n+fn main() {\n+    let $0s = S(1,2);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_trigger_when_subpattern_exists() {\n+        // sub-pattern is only allowed with IdentPat (name), not other patterns (like TuplePat)\n+        cov_mark::check!(destructure_tuple_subpattern);\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+fn sum(t: (usize, usize)) -> usize {\n+    match t {\n+        $0t @ (1..=3,1..=3) => t.0 + t.1,\n+        _ => 0,\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_subpattern() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let t1 @ (_, $0t2) = (1, (2,3));\n+    let v = t1.0 + t2.0 + t2.1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let t1 @ (_, ($0_0, _1)) = (1, (2,3));\n+    let v = t1.0 + _0 + _1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_nested_tuple() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let ($0tup, v) = ((1,2),3);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let (($0_0, _1), v) = ((1,2),3);\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_closure() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0tup = (1,2,3);\n+    let f = |v| v + tup.1;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1, _2) = (1,2,3);\n+    let f = |v| v + _1;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_closure_args() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let f = |$0t| t.0 + t.1;\n+    let v = f((1,2));\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let f = |($0_0, _1)| _0 + _1;\n+    let v = f((1,2));\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_function_args() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn f($0t: (usize, usize)) {\n+    let v = t.0;\n+}\n+            \"#,\n+            r#\"\n+fn f(($0_0, _1): (usize, usize)) {\n+    let v = _0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_if_let() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn f(t: (usize, usize)) {\n+    if let $0t = t {\n+        let v = t.0;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn f(t: (usize, usize)) {\n+    if let ($0_0, _1) = t {\n+        let v = _0;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn in_if_let_option() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+//- minicore: option\n+fn f(o: Option<(usize, usize)>) {\n+    if let Some($0t) = o {\n+        let v = t.0;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn f(o: Option<(usize, usize)>) {\n+    if let Some(($0_0, _1)) = o {\n+        let v = _0;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+\n+    #[test]\n+    fn in_match() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    match (1,2) {\n+        $0t => t.1,\n+    };\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    match (1,2) {\n+        ($0_0, _1) => _1,\n+    };\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn in_match_option() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+//- minicore: option\n+fn main() {\n+    match Some((1,2)) {\n+        Some($0t) => t.1,\n+        _ => 0,\n+    };\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    match Some((1,2)) {\n+        Some(($0_0, _1)) => _1,\n+        _ => 0,\n+    };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn in_for() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+//- minicore: iterators\n+fn main() {\n+    for $0t in core::iter::repeat((1,2))  {\n+        let v = t.1;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    for ($0_0, _1) in core::iter::repeat((1,2))  {\n+        let v = _1;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+    #[test]\n+    fn in_for_nested() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+//- minicore: iterators\n+fn main() {\n+    for (a, $0b) in core::iter::repeat((1,(2,3)))  {\n+        let v = b.1;\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    for (a, ($0_0, _1)) in core::iter::repeat((1,(2,3)))  {\n+        let v = _1;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_on_tuple_usage() {\n+        //Improvement: might be reasonable to allow & implement\n+        check_assist_not_applicable(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let t = (1,2);\n+    let v = $0t.0;\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_all() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0t = (1,2);\n+    let v = t.1;\n+    let s = (t.0 + t.1) / 2;\n+    let f = |v| v + t.0;\n+    let r = f(t.1);\n+    let e = t == (9,0);\n+    let m =\n+      match t {\n+        (_,2) if t.0 > 2 => 1,\n+        _ => 0,\n+      };\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    let v = _1;\n+    let s = (_0 + _1) / 2;\n+    let f = |v| v + _0;\n+    let r = f(_1);\n+    let e = /*t*/ == (9,0);\n+    let m =\n+      match /*t*/ {\n+        (_,2) if _0 > 2 => 1,\n+        _ => 0,\n+      };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn non_trivial_tuple_assignment() {\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main {\n+    let $0t = \n+        if 1 > 2 {\n+            (1,2)\n+        } else {\n+            (5,6)\n+        };\n+    let v1 = t.0;\n+    let v2 =\n+        if t.0 > t.1 {\n+            t.0 - t.1\n+        } else {\n+            t.1 - t.0\n+        };\n+}\n+            \"#,\n+            r#\"\n+fn main {\n+    let ($0_0, _1) = \n+        if 1 > 2 {\n+            (1,2)\n+        } else {\n+            (5,6)\n+        };\n+    let v1 = _0;\n+    let v2 =\n+        if _0 > _1 {\n+            _0 - _1\n+        } else {\n+            _1 - _0\n+        };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    // -----------------------\n+    #[test]\n+    #[ignore]\n+    fn replace_in_macro_call() {\n+        // doesn't work: cannot find usage in `println!`\n+        // Note: Just `t` works, but not `t.0`\n+        check_assist(\n+            destructure_tuple_binding,\n+            r#\"\n+fn main() {\n+    let $0t = (1,2);\n+    println!(\"{}\", t.0);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let ($0_0, _1) = (1,2);\n+    println!(\"{}\", _0);\n+}\n+            \"#,\n+        )\n+    }\n+}"}, {"sha": "7c074a4f63210a7ecc4729c69d3593f8a4429861", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478b2988c0715ae90018dd0930de06a507ecedf7/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478b2988c0715ae90018dd0930de06a507ecedf7/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=478b2988c0715ae90018dd0930de06a507ecedf7", "patch": "@@ -62,6 +62,7 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_tuple_struct_to_named_struct;\n     mod convert_to_guarded_return;\n+    mod destructure_tuple_binding;\n     mod expand_glob_import;\n     mod extract_function;\n     mod extract_struct_from_enum_variant;\n@@ -134,6 +135,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n+            destructure_tuple_binding::destructure_tuple_binding,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_type_alias::extract_type_alias,"}]}