{"sha": "d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OWFlYWY2NjJjNjM3YjQ1NGU4YzdhNWRkYmQ2OWI0OTc4ZWMyMTE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-06T12:54:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-26T08:11:58Z"}, "message": "Implement `..` in tuple (struct) patterns", "tree": {"sha": "45d5b4b43bac7f04ea48136ffb02048278dcfb3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45d5b4b43bac7f04ea48136ffb02048278dcfb3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "html_url": "https://github.com/rust-lang/rust/commit/d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5759a3417fa395d439f4283825504dd4f78dc87", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5759a3417fa395d439f4283825504dd4f78dc87", "html_url": "https://github.com/rust-lang/rust/commit/d5759a3417fa395d439f4283825504dd4f78dc87"}], "stats": {"total": 1035, "additions": 736, "deletions": 299}, "files": [{"sha": "810138e5a2983a0620adf6e635453ada53411d22", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -2433,6 +2433,8 @@ The currently implemented features of the reference compiler are:\n * - `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n                              (e.g. `extern \"vectorcall\" func fn_();`)\n \n+* - `dotdot_in_tuple_patterns` - Allows `..` in tuple (struct) patterns.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "af47617ea92fda64456e8551e0d74591e7103159", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -100,7 +100,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             PatKind::Ident(_, _, None) |\n-            PatKind::TupleStruct(_, None) |\n             PatKind::Path(..) |\n             PatKind::QPath(..) |\n             PatKind::Lit(..) |\n@@ -116,8 +115,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n-            PatKind::TupleStruct(_, Some(ref subpats)) |\n-            PatKind::Tup(ref subpats) => {\n+            PatKind::TupleStruct(_, ref subpats, _) |\n+            PatKind::Tuple(ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }"}, {"sha": "9cba790c54b86f7b7262f4b1fa8cb043f3c23646", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -923,9 +923,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                              sub.map(|x| folder.fold_pat(x)))\n                 }\n                 PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-                PatKind::TupleStruct(pth, pats) => {\n+                PatKind::TupleStruct(pth, pats, ddpos) => {\n                     PatKind::TupleStruct(folder.fold_path(pth),\n-                            pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+                            pats.move_map(|x| folder.fold_pat(x)), ddpos)\n                 }\n                 PatKind::Path(pth) => {\n                     PatKind::Path(folder.fold_path(pth))\n@@ -948,7 +948,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                     });\n                     PatKind::Struct(pth, fs, etc)\n                 }\n-                PatKind::Tup(elts) => PatKind::Tup(elts.move_map(|x| folder.fold_pat(x))),\n+                PatKind::Tuple(elts, ddpos) => {\n+                    PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n+                }\n                 PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n                 PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n                 PatKind::Range(e1, e2) => {"}, {"sha": "69e38c9646c92a5d19c58180e9820ffa7cd836b9", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -454,11 +454,9 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref opt_children) => {\n+        PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n-            if let Some(ref children) = *opt_children {\n-                walk_list!(visitor, visit_pat, children);\n-            }\n+            walk_list!(visitor, visit_pat, children);\n         }\n         PatKind::Path(ref path) => {\n             visitor.visit_path(path, pattern.id);\n@@ -474,7 +472,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatKind::Tup(ref tuple_elements) => {\n+        PatKind::Tuple(ref tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatKind::Box(ref subpattern) |"}, {"sha": "71153a459bd6b0b6719512727f664a1e44b71265", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -872,10 +872,10 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref pth, ref pats) => {\n+                PatKind::TupleStruct(ref pth, ref pats, ddpos) => {\n                     hir::PatKind::TupleStruct(self.lower_path(pth),\n-                                 pats.as_ref()\n-                                     .map(|pats| pats.iter().map(|x| self.lower_pat(x)).collect()))\n+                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                              ddpos)\n                 }\n                 PatKind::Path(ref pth) => {\n                     hir::PatKind::Path(self.lower_path(pth))\n@@ -903,8 +903,8 @@ impl<'a> LoweringContext<'a> {\n                                    .collect();\n                     hir::PatKind::Struct(pth, fs, etc)\n                 }\n-                PatKind::Tup(ref elts) => {\n-                    hir::PatKind::Tup(elts.iter().map(|x| self.lower_pat(x)).collect())\n+                PatKind::Tuple(ref elts, ddpos) => {\n+                    hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n                 }\n                 PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n                 PatKind::Ref(ref inner, mutbl) => {\n@@ -1857,7 +1857,7 @@ impl<'a> LoweringContext<'a> {\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(path)\n         } else {\n-            hir::PatKind::TupleStruct(path, Some(subpats))\n+            hir::PatKind::TupleStruct(path, subpats, None)\n         };\n         let pat = self.pat(span, pt);\n         self.resolver.record_resolution(pat.id, def);"}, {"sha": "961885d1b86d66fb46e3f00f10af637ae5780f69", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -470,7 +470,7 @@ impl Pat {\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| field.node.pat.walk_(it))\n             }\n-            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk_(it))\n             }\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n@@ -485,7 +485,6 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n             PatKind::Ident(_, _, _) |\n-            PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n             PatKind::QPath(_, _) => {\n                 true\n@@ -539,9 +538,10 @@ pub enum PatKind {\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n \n-    /// A tuple struct/variant pattern `Variant(x, y, z)`.\n-    /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    TupleStruct(Path, Option<HirVec<P<Pat>>>),\n+    /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n+    /// If the `..` pattern fragment presents, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    TupleStruct(Path, HirVec<P<Pat>>, Option<usize>),\n \n     /// A path pattern.\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n@@ -553,8 +553,10 @@ pub enum PatKind {\n     /// PatKind::Path, and the resolver will have to sort that out.\n     QPath(QSelf, Path),\n \n-    /// A tuple pattern `(a, b)`\n-    Tup(HirVec<P<Pat>>),\n+    /// A tuple pattern `(a, b)`.\n+    /// If the `..` pattern fragment presents, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    Tuple(HirVec<P<Pat>>, Option<usize>),\n     /// A `box` pattern\n     Box(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`"}, {"sha": "f41c4b0840d58ac84d1863e09009c3c3c19639e5", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -21,6 +21,28 @@ use std::cell::RefCell;\n \n pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n \n+#[derive(Clone, Copy)]\n+pub struct AjustPos {\n+    gap_pos: usize,\n+    gap_len: usize,\n+}\n+\n+impl FnOnce<(usize,)> for AjustPos {\n+    type Output = usize;\n+    extern \"rust-call\" fn call_once(self, (i,): (usize,)) -> usize {\n+        if i < self.gap_pos { i } else { i + self.gap_len }\n+    }\n+}\n+\n+// Returns a functional object used to adjust tuple pattern indexes. Example: for 5-tuple and\n+// pattern (a, b, .., c) expected_len is 5, actual_len is 3 and gap_pos is Some(2).\n+pub fn pat_adjust_pos(expected_len: usize, actual_len: usize, gap_pos: Option<usize>) -> AjustPos {\n+    AjustPos {\n+        gap_pos: if let Some(gap_pos) = gap_pos { gap_pos } else { expected_len },\n+        gap_len: expected_len - actual_len,\n+    }\n+}\n+\n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {"}, {"sha": "d105a72b986fd518f7a0356b7f3e4f36fcbe04b2", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -1736,16 +1736,23 @@ impl<'a> State<'a> {\n                     None => (),\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref args_) => {\n+            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n                 self.print_path(path, true, 0)?;\n-                match *args_ {\n-                    None => word(&mut self.s, \"(..)\")?,\n-                    Some(ref args) => {\n-                        self.popen()?;\n-                        self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p))?;\n-                        self.pclose()?;\n+                self.popen()?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n+                } else {\n+                    try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p)));\n                 }\n+                try!(self.pclose());\n             }\n             PatKind::Path(ref path) => {\n                 self.print_path(path, true, 0)?;\n@@ -1778,11 +1785,23 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 word(&mut self.s, \"}\")?;\n             }\n-            PatKind::Tup(ref elts) => {\n+            PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n-                self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n-                if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n+                    }\n+                } else {\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n+                    if elts.len() == 1 {\n+                        word(&mut self.s, \",\")?;\n+                    }\n                 }\n                 self.pclose()?;\n             }"}, {"sha": "4ecad7f93a5a44288e504111c79fbbf67d4e4157", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -29,6 +29,7 @@\n #![feature(collections)]\n #![feature(const_fn)]\n #![feature(enumset)]\n+#![feature(fn_traits)]\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n@@ -38,6 +39,7 @@\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n+#![feature(unboxed_closures)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "b0add5a23dc4638fa14017093f61ae489c11e3ad", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -1127,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     // will visit the substructure recursively.\n                 }\n \n-                PatKind::Wild | PatKind::Tup(..) | PatKind::Box(..) |\n+                PatKind::Wild | PatKind::Tuple(..) | PatKind::Box(..) |\n                 PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n                 PatKind::Vec(..) => {\n                     // Similarly, each of these cases does not"}, {"sha": "da3df7ad3e9adefd97565f8f3a1dc1cbbb8c85ec", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -80,6 +80,7 @@ use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n \n use hir::{MutImmutable, MutMutable, PatKind};\n+use hir::pat_util::pat_adjust_pos;\n use hir;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -1225,31 +1226,40 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // _\n           }\n \n-          PatKind::TupleStruct(_, None) => {\n-            // variant(..)\n-          }\n-          PatKind::TupleStruct(_, Some(ref subpats)) => {\n+          PatKind::TupleStruct(_, ref subpats, ddpos) => {\n             match opt_def {\n-                Some(Def::Variant(..)) => {\n+                Some(Def::Variant(enum_def, def_id)) => {\n                     // variant(x, y, z)\n+                    let variant = self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id);\n+                    let adjust = pat_adjust_pos(variant.fields.len(), subpats.len(), ddpos);\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n+                                InteriorField(PositionalField(adjust(i))));\n \n                         self.cat_pattern_(subcmt, &subpat, op)?;\n                     }\n                 }\n                 Some(Def::Struct(..)) => {\n+                    let expected_len = match self.pat_ty(&pat) {\n+                        Ok(&ty::TyS{sty: ty::TyStruct(adt_def, _), ..}) => {\n+                            adt_def.struct_variant().fields.len()\n+                        }\n+                        ref ty => {\n+                            span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n+                        }\n+                    };\n+\n+                    let adjust = pat_adjust_pos(expected_len, subpats.len(), ddpos);\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n+                                InteriorField(PositionalField(adjust(i))));\n                         self.cat_pattern_(cmt_field, &subpat, op)?;\n                     }\n                 }\n@@ -1284,14 +1294,19 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Tup(ref subpats) => {\n+          PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n+            let expected_len = match self.pat_ty(&pat) {\n+                Ok(&ty::TyS{sty: ty::TyTuple(ref tys), ..}) => tys.len(),\n+                ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n+            };\n+            let adjust = pat_adjust_pos(expected_len, subpats.len(), ddpos);\n             for (i, subpat) in subpats.iter().enumerate() {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n-                        InteriorField(PositionalField(i)));\n+                        InteriorField(PositionalField(adjust(i))));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }"}, {"sha": "6b2c2dfcd72b48375c57d501c9d89015db6610cb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -970,8 +970,8 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            PatKind::TupleStruct(_, Some(ref subpats)) |\n-            PatKind::Tup(ref subpats) => {\n+            PatKind::TupleStruct(_, ref subpats, _) |\n+            PatKind::Tuple(ref subpats, _) => {\n                 subpats.iter().any(|p| is_binding_pat(&p))\n             }\n "}, {"sha": "50b6d661fa8b3d6aef069a6c579eb4974d4abef1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -33,6 +33,7 @@ use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n use hir;\n use hir::{Item, Generics, StructField, Variant, PatKind};\n use hir::intravisit::{self, Visitor};\n+use hir::pat_util::pat_adjust_pos;\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -614,10 +615,10 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     };\n     match pat.node {\n         // Foo(a, b, c)\n-        // A Variant(..) pattern `PatKind::TupleStruct(_, None)` doesn't have to be recursed into.\n-        PatKind::TupleStruct(_, Some(ref pat_fields)) => {\n-            for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n-                maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n+        PatKind::TupleStruct(_, ref pat_fields, ddpos) => {\n+            let adjust = pat_adjust_pos(v.fields.len(), pat_fields.len(), ddpos);\n+            for (i, field) in pat_fields.iter().enumerate() {\n+                maybe_do_stability_check(tcx, v.fields[adjust(i)].did, field.span, cb)\n             }\n         }\n         // Foo { a, b, c }"}, {"sha": "f98734f21add5187bb68b0118953a379c22971f0", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -374,7 +374,7 @@ fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n         PatKind::Ident(_, _, None) => pat_is_binding(dm, p),\n         PatKind::Ident(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n         PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n-        PatKind::Tup(ref v) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n+        PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n         _ => false\n     }\n }\n@@ -398,7 +398,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witnesses[0].node {\n-                        PatKind::TupleStruct(_, Some(ref pats)) => match &pats[..] {\n+                        PatKind::TupleStruct(_, ref pats, _) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => bug!(),\n                         },\n@@ -559,7 +559,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n-        ty::TyTuple(_) => PatKind::Tup(pats.collect()),\n+        ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = ctor.variant_for_adt(adt);\n@@ -580,7 +580,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n                 }\n                 VariantKind::Tuple => {\n-                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n                 VariantKind::Unit => {\n                     PatKind::Path(def_to_path(cx.tcx, v.did))\n@@ -832,7 +832,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     vec!(Slice(before.len() + after.len()))\n                 }\n             },\n-        PatKind::Box(_) | PatKind::Tup(_) | PatKind::Ref(..) =>\n+        PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n             vec!(Single),\n         PatKind::Wild =>\n             vec!(),\n@@ -914,18 +914,23 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        PatKind::TupleStruct(_, ref args) => {\n+        PatKind::TupleStruct(_, ref args, ddpos) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => {\n-                    Some(match args {\n-                        &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => vec![DUMMY_WILD_PAT; arity],\n-                    })\n+                    match ddpos {\n+                        Some(ddpos) => {\n+                            let mut pats = args[..ddpos].iter().map(|p| &**p).collect(): Vec<_>;\n+                            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n+                            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+                            Some(pats)\n+                        }\n+                        None => Some(args.iter().map(|p| &**p).collect())\n+                    }\n                 }\n                 _ => None\n             }\n@@ -952,7 +957,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        PatKind::Tup(ref args) =>\n+        PatKind::Tuple(ref args, Some(ddpos)) => {\n+            let mut pats = args[..ddpos].iter().map(|p| &**p).collect(): Vec<_>;\n+            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n+            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+            Some(pats)\n+        }\n+        PatKind::Tuple(ref args, None) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n         PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>"}, {"sha": "b727b778fcd791495897af9f77d0829fd29a9e1b", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -271,10 +271,9 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            PatKind::Tup(try!(exprs.iter()\n-                                  .map(|expr| const_expr_to_pat(tcx, &expr,\n-                                                                pat_id, span))\n-                                  .collect())),\n+            PatKind::Tuple(try!(exprs.iter()\n+                                     .map(|expr| const_expr_to_pat(tcx, &expr, pat_id, span))\n+                                     .collect()), None),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -295,7 +294,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 .map(|expr| const_expr_to_pat(tcx, &**expr,\n                                                               pat_id, span))\n                                 .collect());\n-            PatKind::TupleStruct(path, Some(pats))\n+            PatKind::TupleStruct(path, pats, None)\n         }\n \n         hir::ExprStruct(ref path, ref fields, None) => {"}, {"sha": "2c796690df4355a0eb98495bc653d89f8405163f", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -31,6 +31,7 @@\n #![feature(question_mark)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(type_ascription)]\n \n #[macro_use] extern crate syntax;\n #[macro_use] extern crate log;"}, {"sha": "494d8a5c0356dcdc1453e06bff41fd91707c40a6", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -13,7 +13,7 @@ use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n-use rustc::hir::pat_util::{pat_is_resolved_const, pat_is_binding};\n+use rustc::hir::pat_util::{pat_adjust_pos, pat_is_resolved_const, pat_is_binding};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n@@ -148,17 +148,24 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Tup(ref subpatterns) => {\n-                let subpatterns =\n-                    subpatterns.iter()\n-                               .enumerate()\n-                               .map(|(i, subpattern)| FieldPattern {\n-                                   field: Field::new(i),\n-                                   pattern: self.to_pattern(subpattern),\n-                               })\n-                               .collect();\n+            PatKind::Tuple(ref subpatterns, ddpos) => {\n+                match self.cx.tcx.node_id_to_type(pat.id).sty {\n+                    ty::TyTuple(ref tys) => {\n+                        let adjust = pat_adjust_pos(tys.len(), subpatterns.len(), ddpos);\n+                        let subpatterns =\n+                            subpatterns.iter()\n+                                       .enumerate()\n+                                       .map(|(i, subpattern)| FieldPattern {\n+                                            field: Field::new(adjust(i)),\n+                                            pattern: self.to_pattern(subpattern),\n+                                       })\n+                                       .collect();\n+\n+                        PatternKind::Leaf { subpatterns: subpatterns }\n+                    }\n \n-                PatternKind::Leaf { subpatterns: subpatterns }\n+                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n+                }\n             }\n \n             PatKind::Ident(bm, ref ident, ref sub)\n@@ -208,13 +215,21 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 self.variant_or_leaf(pat, vec![])\n             }\n \n-            PatKind::TupleStruct(_, ref opt_subpatterns) => {\n+            PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n+                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n+                let adt_def = match pat_ty.sty {\n+                    ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n+                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to struct or enum\"),\n+                };\n+                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+                let variant_def = adt_def.variant_of_def(def);\n+\n+                let adjust = pat_adjust_pos(variant_def.fields.len(), subpatterns.len(), ddpos);\n                 let subpatterns =\n-                    opt_subpatterns.iter()\n-                                   .flat_map(|v| v.iter())\n+                        subpatterns.iter()\n                                    .enumerate()\n                                    .map(|(i, field)| FieldPattern {\n-                                       field: Field::new(i),\n+                                       field: Field::new(adjust(i)),\n                                        pattern: self.to_pattern(field),\n                                    })\n                                    .collect();"}, {"sha": "953bcf457b8031d892a9670205f20d577767bba3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -31,7 +31,7 @@ use std::mem::replace;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::{self, Visitor};\n-\n+use rustc::hir::pat_util::pat_adjust_pos;\n use rustc::dep_graph::DepNode;\n use rustc::lint;\n use rustc::hir::def::{self, Def};\n@@ -488,25 +488,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     self.check_field(pattern.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n-\n-            // Patterns which bind no fields are allowable (the path is check\n-            // elsewhere).\n-            PatKind::TupleStruct(_, Some(ref fields)) => {\n+            PatKind::TupleStruct(_, ref fields, ddpos) => {\n                 match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(def, _) => {\n+                        let adjust = pat_adjust_pos(def.struct_variant().fields.len(),\n+                                                    fields.len(), ddpos);\n                         for (i, field) in fields.iter().enumerate() {\n                             if let PatKind::Wild = field.node {\n                                 continue\n                             }\n-                            self.check_field(field.span, def, &def.struct_variant().fields[i]);\n+                            self.check_field(field.span, def,\n+                                             &def.struct_variant().fields[adjust(i)]);\n                         }\n                     }\n                     ty::TyEnum(..) => {\n                         // enum fields have no privacy at this time\n                     }\n                     _ => {}\n                 }\n-\n             }\n             _ => {}\n         }"}, {"sha": "e0aa46eda183acd82c62c36dd14377225b5c90db", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -2360,7 +2360,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                PatKind::TupleStruct(ref path, _) | PatKind::Path(ref path) => {\n+                PatKind::TupleStruct(ref path, _, _) | PatKind::Path(ref path) => {\n                     // This must be an enum variant, struct or const.\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             None,"}, {"sha": "7b0ae100f058ff124ebee42269a5c6c99f832c08", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -696,7 +696,7 @@ impl<'v> Visitor<'v> for PathCollector {\n                 self.collected_paths.push((p.id, path.clone(),\n                                            ast::Mutability::Mutable, recorder::TypeRef));\n             }\n-            PatKind::TupleStruct(ref path, _) |\n+            PatKind::TupleStruct(ref path, _, _) |\n             PatKind::Path(ref path) |\n             PatKind::QPath(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(),"}, {"sha": "9b168301f73256e96ffde9a38c1022855733cb34", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -792,7 +792,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n-            PatKind::Tup(_) => true,\n+            PatKind::Tuple(..) => true,\n             PatKind::Struct(..) | PatKind::TupleStruct(..) |\n             PatKind::Path(..) | PatKind::Ident(_, _, None) => {\n                 match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n@@ -1833,7 +1833,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n             }\n         }\n-        PatKind::TupleStruct(_, ref sub_pats) => {\n+        PatKind::TupleStruct(_, ref sub_pats, ddpos) => {\n             let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(Def::Variant(enum_id, var_id)) => {\n@@ -1843,35 +1843,36 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     &repr,\n                                                     Disr::from(vinfo.disr_val),\n                                                     val);\n-                    if let Some(ref sub_pat) = *sub_pats {\n-                        for (i, &argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(\n-                                bcx,\n-                                &sub_pat[i],\n-                                MatchInput::from_val(argval),\n-                                cleanup_scope);\n-                        }\n+                    let adjust = pat_adjust_pos(vinfo.fields.len(), sub_pats.len(), ddpos);\n+                    for (i, subpat) in sub_pats.iter().enumerate() {\n+                        bcx = bind_irrefutable_pat(\n+                            bcx,\n+                            subpat,\n+                            MatchInput::from_val(args.vals[adjust(i)]),\n+                            cleanup_scope);\n                     }\n                 }\n                 Some(Def::Struct(..)) => {\n-                    match *sub_pats {\n-                        None => {\n-                            // This is a unit-like struct. Nothing to do here.\n+                    let expected_len = match *ccx.tcx().pat_ty(&pat) {\n+                        ty::TyS{sty: ty::TyStruct(adt_def, _), ..} => {\n+                            adt_def.struct_variant().fields.len()\n                         }\n-                        Some(ref elems) => {\n-                            // This is the tuple struct case.\n-                            let repr = adt::represent_node(bcx, pat.id);\n-                            let val = adt::MaybeSizedValue::sized(val.val);\n-                            for (i, elem) in elems.iter().enumerate() {\n-                                let fldptr = adt::trans_field_ptr(bcx, &repr,\n-                                                                  val, Disr(0), i);\n-                                bcx = bind_irrefutable_pat(\n-                                    bcx,\n-                                    &elem,\n-                                    MatchInput::from_val(fldptr),\n-                                    cleanup_scope);\n-                            }\n+                        ref ty => {\n+                            span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n                         }\n+                    };\n+\n+                    let adjust = pat_adjust_pos(expected_len, sub_pats.len(), ddpos);\n+                    let repr = adt::represent_node(bcx, pat.id);\n+                    let val = adt::MaybeSizedValue::sized(val.val);\n+                    for (i, elem) in sub_pats.iter().enumerate() {\n+                        let fldptr = adt::trans_field_ptr(bcx, &repr,\n+                                                          val, Disr(0), adjust(i));\n+                        bcx = bind_irrefutable_pat(\n+                            bcx,\n+                            &elem,\n+                            MatchInput::from_val(fldptr),\n+                            cleanup_scope);\n                     }\n                 }\n                 _ => {\n@@ -1919,16 +1920,22 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            cleanup_scope);\n             }\n         }\n-        PatKind::Tup(ref elems) => {\n-            let repr = adt::represent_node(bcx, pat.id);\n-            let val = adt::MaybeSizedValue::sized(val.val);\n-            for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n-                bcx = bind_irrefutable_pat(\n-                    bcx,\n-                    &elem,\n-                    MatchInput::from_val(fldptr),\n-                    cleanup_scope);\n+        PatKind::Tuple(ref elems, ddpos) => {\n+            match tcx.node_id_to_type(pat.id).sty {\n+                ty::TyTuple(ref tys) => {\n+                    let adjust = pat_adjust_pos(tys.len(), elems.len(), ddpos);\n+                    let repr = adt::represent_node(bcx, pat.id);\n+                    let val = adt::MaybeSizedValue::sized(val.val);\n+                    for (i, elem) in elems.iter().enumerate() {\n+                        let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), adjust(i));\n+                        bcx = bind_irrefutable_pat(\n+                            bcx,\n+                            &elem,\n+                            MatchInput::from_val(fldptr),\n+                            cleanup_scope);\n+                    }\n+                }\n+                ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n             }\n         }\n         PatKind::Box(ref inner) => {"}, {"sha": "aec43e69e5182bfe166829dc95fab4819a9e82dc", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -318,13 +318,11 @@ fn walk_pattern(cx: &CrateContext,\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n \n-        PatKind::TupleStruct(_, ref sub_pats_opt) => {\n+        PatKind::TupleStruct(_, ref sub_pats, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-            if let Some(ref sub_pats) = *sub_pats_opt {\n-                for p in sub_pats {\n-                    walk_pattern(cx, &p, scope_stack, scope_map);\n-                }\n+            for p in sub_pats {\n+                walk_pattern(cx, &p, scope_stack, scope_map);\n             }\n         }\n \n@@ -343,7 +341,7 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        PatKind::Tup(ref sub_pats) => {\n+        PatKind::Tuple(ref sub_pats, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in sub_pats {"}, {"sha": "ce4ac4e815c78a19fbdc0c8515c5c5eacbe3daba", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -11,7 +11,7 @@\n use hir::def::{self, Def};\n use rustc::infer::{self, InferOk, TypeOrigin};\n use hir::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n-use hir::pat_util::pat_is_resolved_const;\n+use hir::pat_util::{pat_adjust_pos, pat_is_resolved_const};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation};\n@@ -213,13 +213,13 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n             PatKind::Ident(_, ref path, _) => {\n                 let path = hir::Path::from_name(path.span, path.node);\n-                self.check_pat_enum(pat, &path, Some(&[]), expected, false);\n+                self.check_pat_enum(pat, &path, &[], None, expected, false);\n             }\n-            PatKind::TupleStruct(ref path, ref subpats) => {\n-                self.check_pat_enum(pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n+            PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n+                self.check_pat_enum(pat, path, &subpats, ddpos, expected, true);\n             }\n             PatKind::Path(ref path) => {\n-                self.check_pat_enum(pat, path, Some(&[]), expected, false);\n+                self.check_pat_enum(pat, path, &[], None, expected, false);\n             }\n             PatKind::QPath(ref qself, ref path) => {\n                 let self_ty = self.to_ty(&qself.ty);\n@@ -260,14 +260,24 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Struct(ref path, ref fields, etc) => {\n                 self.check_pat_struct(pat, path, fields, etc, expected);\n             }\n-            PatKind::Tup(ref elements) => {\n-                let element_tys: Vec<_> =\n-                    (0..elements.len()).map(|_| self.next_ty_var()).collect();\n+            PatKind::Tuple(ref elements, ddpos) => {\n+                let mut expected_len = elements.len();\n+                if ddpos.is_some() {\n+                    // Require known type only when `..` is present\n+                    if let ty::TyTuple(ref tys) =\n+                            self.structurally_resolved_type(pat.span, expected).sty {\n+                        expected_len = tys.len();\n+                    }\n+                }\n+                let max_len = cmp::max(expected_len, elements.len());\n+\n+                let element_tys = (0 .. max_len).map(|_| self.next_ty_var()).collect(): Vec<_>;\n                 let pat_ty = tcx.mk_tup(element_tys.clone());\n                 self.write_ty(pat.id, pat_ty);\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n-                for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n-                    self.check_pat(&element_pat, element_ty);\n+                let adjust = pat_adjust_pos(expected_len, elements.len(), ddpos);\n+                for i in 0 .. elements.len() {\n+                    self.check_pat(&elements[i], &element_tys[adjust(i)]);\n                 }\n             }\n             PatKind::Box(ref inner) => {\n@@ -615,7 +625,8 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n     fn check_pat_enum(&self,\n                       pat: &hir::Pat,\n                       path: &hir::Path,\n-                      subpats: Option<&'gcx [P<hir::Pat>]>,\n+                      subpats: &'gcx [P<hir::Pat>],\n+                      ddpos: Option<usize>,\n                       expected: Ty<'tcx>,\n                       is_tuple_struct_pat: bool)\n     {\n@@ -628,12 +639,9 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 self.write_error(pat.id);\n \n-                if let Some(subpats) = subpats {\n-                    for pat in subpats {\n-                        self.check_pat(&pat, tcx.types.err);\n-                    }\n+                for pat in subpats {\n+                    self.check_pat(&pat, tcx.types.err);\n                 }\n-\n                 return;\n             }\n         };\n@@ -670,15 +678,12 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n         };\n         self.instantiate_path(segments, path_scheme, &ctor_predicates,\n                               opt_ty, def, pat.span, pat.id);\n-\n         let report_bad_struct_kind = |is_warning| {\n             bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n             if is_warning { return; }\n             self.write_error(pat.id);\n-            if let Some(subpats) = subpats {\n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err);\n             }\n         };\n \n@@ -715,42 +720,37 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         match (is_tuple_struct_pat, variant.kind()) {\n-            (true, ty::VariantKind::Unit) => {\n+            (true, ty::VariantKind::Unit) if subpats.is_empty() && ddpos.is_some() => {\n                 // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n                 // is allowed for backward compatibility.\n                 report_bad_struct_kind(true);\n             }\n+            (true, ty::VariantKind::Unit) |\n+            (false, ty::VariantKind::Tuple) |\n             (_, ty::VariantKind::Struct) => {\n                 report_bad_struct_kind(false);\n                 return\n             }\n             _ => {}\n         }\n \n-        if let Some(subpats) = subpats {\n-            if subpats.len() == variant.fields.len() {\n-                for (subpat, field) in subpats.iter().zip(&variant.fields) {\n-                    let field_ty = self.field_ty(subpat.span, field, expected_substs);\n-                    self.check_pat(&subpat, field_ty);\n-                }\n-            } else if variant.fields.is_empty() {\n-                span_err!(tcx.sess, pat.span, E0024,\n-                          \"this pattern has {} field{}, but the corresponding {} has no fields\",\n-                          subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n-\n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n-            } else {\n-                span_err!(tcx.sess, pat.span, E0023,\n-                          \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                          subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n-                          kind_name,\n-                          variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n-\n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n+        let adjust = pat_adjust_pos(variant.fields.len(), subpats.len(), ddpos);\n+        if subpats.len() == variant.fields.len() ||\n+                subpats.len() < variant.fields.len() && ddpos.is_some() {\n+            for (i, subpat) in subpats.iter().enumerate() {\n+                let field_ty = self.field_ty(subpat.span,\n+                                    &variant.fields[adjust(i)], expected_substs);\n+                self.check_pat(&subpat, field_ty);\n+            }\n+        } else {\n+            span_err!(tcx.sess, pat.span, E0023,\n+                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n+                      kind_name,\n+                      variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n+\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err);\n             }\n         }\n     }"}, {"sha": "77ff818aa881a8252ae0ad0576d84bb417dadec8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -62,31 +62,6 @@ Check how many fields the enum was declared with and ensure that your pattern\n uses the same number.\n \"##,\n \n-E0024: r##\"\n-This error indicates that a pattern attempted to extract the fields of an enum\n-variant with no fields. Here's a tiny example of this error:\n-\n-```compile_fail\n-// This enum has two variants.\n-enum Number {\n-    // This variant has no fields.\n-    Zero,\n-    // This variant has one field.\n-    One(u32)\n-}\n-\n-// Assuming x is a Number we can pattern match on its contents.\n-match x {\n-    Number::Zero(inside) => {},\n-    Number::One(inside) => {},\n-}\n-```\n-\n-The pattern match `Zero(inside)` is incorrect because the `Zero` variant\n-contains no fields, yet the `inside` name attempts to bind the first field of\n-the enum.\n-\"##,\n-\n E0025: r##\"\n Each field of a struct can only be bound once in a pattern. Erroneous code\n example:"}, {"sha": "282b7582393ece3c8372cfac2c1b024118c68a2b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -77,11 +77,12 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(iter_arith)]\n+#![feature(question_mark)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![feature(type_ascription)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "4831ee9a2e041a5e6950d350b4e74cf7070bd604", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -2579,7 +2579,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Ident(_, ref p, _) => p.node.to_string(),\n-        PatKind::TupleStruct(ref p, _) | PatKind::Path(ref p) => path_to_string(p),\n+        PatKind::TupleStruct(ref p, _, _) | PatKind::Path(ref p) => path_to_string(p),\n         PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n                                 which is not allowed in function arguments\"),\n         PatKind::Struct(ref name, ref fields, etc) => {\n@@ -2590,7 +2590,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n                 if etc { \", ...\" } else { \"\" }\n             )\n         },\n-        PatKind::Tup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n+        PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n         PatKind::Box(ref p) => name_from_pat(&**p),\n         PatKind::Ref(ref p, _) => name_from_pat(&**p),"}, {"sha": "6eb588767c4538515b70556993ac2c3c993cee30", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -567,7 +567,7 @@ impl Pat {\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| field.node.pat.walk(it))\n             }\n-            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk(it))\n             }\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n@@ -582,7 +582,6 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n             PatKind::Ident(_, _, _) |\n-            PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n             PatKind::QPath(_, _) |\n             PatKind::Mac(_) => {\n@@ -631,9 +630,10 @@ pub enum PatKind {\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(Path, Vec<Spanned<FieldPat>>, bool),\n \n-    /// A tuple struct/variant pattern `Variant(x, y, z)`.\n-    /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    TupleStruct(Path, Option<Vec<P<Pat>>>),\n+    /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n+    /// If the `..` pattern fragment presents, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    TupleStruct(Path, Vec<P<Pat>>, Option<usize>),\n \n     /// A path pattern.\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n@@ -645,8 +645,10 @@ pub enum PatKind {\n     /// PatKind::Path, and the resolver will have to sort that out.\n     QPath(QSelf, Path),\n \n-    /// A tuple pattern `(a, b)`\n-    Tup(Vec<P<Pat>>),\n+    /// A tuple pattern `(a, b)`.\n+    /// If the `..` pattern fragment presents, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    Tuple(Vec<P<Pat>>, Option<usize>),\n     /// A `box` pattern\n     Box(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`"}, {"sha": "3a1cdae9bfbd0387abd344874388217b072946f7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -832,7 +832,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = if subpats.is_empty() {\n             PatKind::Path(path)\n         } else {\n-            PatKind::TupleStruct(path, Some(subpats))\n+            PatKind::TupleStruct(path, subpats, None)\n         };\n         self.pat(span, pat)\n     }\n@@ -842,7 +842,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat(span, pat)\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        self.pat(span, PatKind::Tup(pats))\n+        self.pat(span, PatKind::Tuple(pats, None))\n     }\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "b5bab09c70e0cdef560967553409931d3d633278", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -274,7 +274,10 @@ declare_features! (\n     (active, drop_types_in_const, \"1.9.0\", Some(33156)),\n \n     // Allows cfg(target_has_atomic = \"...\").\n-    (active, cfg_target_has_atomic, \"1.9.0\", Some(32976))\n+    (active, cfg_target_has_atomic, \"1.9.0\", Some(32976)),\n+\n+    // Allows `..` in tuple (struct) patterns\n+    (active, dotdot_in_tuple_patterns, \"1.10.0\", Some(33627))\n );\n \n declare_features! (\n@@ -315,7 +318,6 @@ declare_features! (\n     // Allows `#[deprecated]` attribute\n     (accepted, deprecated, \"1.9.0\", Some(29935))\n );\n-\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n #[derive(PartialEq, Copy, Clone, Debug)]\n@@ -1021,6 +1023,24 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");\n             }\n+            PatKind::Tuple(_, ddpos)\n+                    if ddpos.is_some() => {\n+                gate_feature_post!(&self, dotdot_in_tuple_patterns,\n+                                  pattern.span,\n+                                  \"`..` in tuple patterns is experimental\");\n+            }\n+            PatKind::TupleStruct(_, ref fields, ddpos)\n+                    if ddpos.is_some() && !fields.is_empty() => {\n+                gate_feature_post!(&self, dotdot_in_tuple_patterns,\n+                                  pattern.span,\n+                                  \"`..` in tuple struct patterns is experimental\");\n+            }\n+            PatKind::TupleStruct(_, ref fields, ddpos)\n+                    if ddpos.is_none() && fields.is_empty() => {\n+                self.context.span_handler.struct_span_err(pattern.span,\n+                                                          \"nullary enum variants are written with \\\n+                                                           no trailing `( )`\").emit();\n+            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)"}, {"sha": "c9d23427657a57eb54fb40875f9f93f2d01a9531", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -1115,9 +1115,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                         sub.map(|x| folder.fold_pat(x)))\n             }\n             PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-            PatKind::TupleStruct(pth, pats) => {\n+            PatKind::TupleStruct(pth, pats, ddpos) => {\n                 PatKind::TupleStruct(folder.fold_path(pth),\n-                        pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+                        pats.move_map(|x| folder.fold_pat(x)), ddpos)\n             }\n             PatKind::Path(pth) => {\n                 PatKind::Path(folder.fold_path(pth))\n@@ -1138,7 +1138,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 });\n                 PatKind::Struct(pth, fs, etc)\n             }\n-            PatKind::Tup(elts) => PatKind::Tup(elts.move_map(|x| folder.fold_pat(x))),\n+            PatKind::Tuple(elts, ddpos) => {\n+                PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n+            }\n             PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n             PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n             PatKind::Range(e1, e2) => {"}, {"sha": "a4f12769b5c09bd1815352fd31cd2405c0367412", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -954,25 +954,6 @@ impl<'a> Parser<'a> {\n         Ok(result)\n     }\n \n-    /// Parse a sequence parameter of enum variant. For consistency purposes,\n-    /// these should not be empty.\n-    pub fn parse_enum_variant_seq<T, F>(&mut self,\n-                                        bra: &token::Token,\n-                                        ket: &token::Token,\n-                                        sep: SeqSep,\n-                                        f: F)\n-                                        -> PResult<'a, Vec<T>> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n-    {\n-        let result = self.parse_unspanned_seq(bra, ket, sep, f)?;\n-        if result.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n-            \"nullary enum variants are written with no trailing `( )`\");\n-        }\n-        Ok(result)\n-    }\n-\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     pub fn parse_seq<T, F>(&mut self,\n@@ -3433,21 +3414,29 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n-    fn parse_pat_tuple_elements(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n+    fn parse_pat_tuple_elements(&mut self, unary_needs_comma: bool)\n+                                -> PResult<'a, (Vec<P<Pat>>, Option<usize>)> {\n         let mut fields = vec![];\n-        if !self.check(&token::CloseDelim(token::Paren)) {\n-            fields.push(self.parse_pat()?);\n-            if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n-                while self.eat(&token::Comma) &&\n-                      !self.check(&token::CloseDelim(token::Paren)) {\n+        let mut ddpos = None;\n+\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            if ddpos.is_none() && self.eat(&token::DotDot) {\n+                ddpos = Some(fields.len());\n+                if self.eat(&token::Comma) {\n+                    // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n                     fields.push(self.parse_pat()?);\n                 }\n+            } else {\n+                fields.push(self.parse_pat()?);\n             }\n-            if fields.len() == 1 {\n+\n+            if !self.check(&token::CloseDelim(token::Paren)) ||\n+                    (unary_needs_comma && fields.len() == 1 && ddpos.is_none()) {\n                 self.expect(&token::Comma)?;\n             }\n         }\n-        Ok(fields)\n+\n+        Ok((fields, ddpos))\n     }\n \n     fn parse_pat_vec_elements(\n@@ -3626,9 +3615,9 @@ impl<'a> Parser<'a> {\n           token::OpenDelim(token::Paren) => {\n             // Parse (pat,pat,pat,...) as tuple pattern\n             self.bump();\n-            let fields = self.parse_pat_tuple_elements()?;\n+            let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n             self.expect(&token::CloseDelim(token::Paren))?;\n-            pat = PatKind::Tup(fields);\n+            pat = PatKind::Tuple(fields, ddpos);\n           }\n           token::OpenDelim(token::Bracket) => {\n             // Parse [pat,pat,...] as slice pattern\n@@ -3713,20 +3702,10 @@ impl<'a> Parser<'a> {\n                             return Err(self.fatal(\"unexpected `(` after qualified path\"));\n                         }\n                         // Parse tuple struct or enum pattern\n-                        if self.look_ahead(1, |t| *t == token::DotDot) {\n-                            // This is a \"top constructor only\" pat\n-                            self.bump();\n-                            self.bump();\n-                            self.expect(&token::CloseDelim(token::Paren))?;\n-                            pat = PatKind::TupleStruct(path, None);\n-                        } else {\n-                            let args = self.parse_enum_variant_seq(\n-                                &token::OpenDelim(token::Paren),\n-                                &token::CloseDelim(token::Paren),\n-                                SeqSep::trailing_allowed(token::Comma),\n-                                |p| p.parse_pat())?;\n-                            pat = PatKind::TupleStruct(path, Some(args));\n-                        }\n+                        self.bump();\n+                        let (fields, ddpos) = self.parse_pat_tuple_elements(false)?;\n+                        self.expect(&token::CloseDelim(token::Paren))?;\n+                        pat = PatKind::TupleStruct(path, fields, ddpos)\n                       }\n                       _ => {\n                         pat = match qself {"}, {"sha": "6c3f3e28727c707d3dec969a288ab6003f3967d5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -2472,17 +2472,23 @@ impl<'a> State<'a> {\n                     None => ()\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref args_) => {\n+            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n                 self.print_path(path, true, 0)?;\n-                match *args_ {\n-                    None => word(&mut self.s, \"(..)\")?,\n-                    Some(ref args) => {\n-                        self.popen()?;\n-                        self.commasep(Inconsistent, &args[..],\n-                                          |s, p| s.print_pat(&p))?;\n-                        self.pclose()?;\n+                self.popen()?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n+                } else {\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n                 }\n+                self.pclose()?;\n             }\n             PatKind::Path(ref path) => {\n                 self.print_path(path, true, 0)?;\n@@ -2513,13 +2519,23 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 word(&mut self.s, \"}\")?;\n             }\n-            PatKind::Tup(ref elts) => {\n+            PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n-                self.commasep(Inconsistent,\n-                                   &elts[..],\n-                                   |s, p| s.print_pat(&p))?;\n-                if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n+                    }\n+                } else {\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n+                    if elts.len() == 1 {\n+                        word(&mut self.s, \",\")?;\n+                    }\n                 }\n                 self.pclose()?;\n             }"}, {"sha": "d41d170c084d50a1715cb64c3f34989e6188f85a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -423,11 +423,9 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref opt_children) => {\n+        PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n-            if let Some(ref children) = *opt_children {\n-                walk_list!(visitor, visit_pat, children);\n-            }\n+            walk_list!(visitor, visit_pat, children);\n         }\n         PatKind::Path(ref path) => {\n             visitor.visit_path(path, pattern.id);\n@@ -443,7 +441,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatKind::Tup(ref tuple_elements) => {\n+        PatKind::Tuple(ref tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatKind::Box(ref subpattern) |"}, {"sha": "8d74154655fcee4b9006a78b57786493f18aceef", "filename": "src/test/compile-fail/issue-32004.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -18,12 +18,12 @@ struct S;\n fn main() {\n     match Foo::Baz {\n         Foo::Bar => {}\n-        //~^ ERROR this pattern has 0 fields, but the corresponding variant\n+        //~^ ERROR `Foo::Bar` does not name a tuple variant or a tuple struct\n         _ => {}\n     }\n \n     match S {\n         S(()) => {}\n-        //~^ ERROR this pattern has 1 field, but the corresponding struct\n+        //~^ ERROR `S` does not name a tuple variant or a tuple struct\n     }\n }"}, {"sha": "a4ba93ea1733311c7ccac7f0e4516c7f4510da1a", "filename": "src/test/compile-fail/match-pattern-field-mismatch-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -20,7 +20,7 @@ fn main() {\n           color::rgb(_, _, _) => { }\n           color::cmyk(_, _, _, _) => { }\n           color::no_color(_) => { }\n-          //~^ ERROR this pattern has 1 field, but the corresponding variant has no fields\n+          //~^ ERROR `color::no_color` does not name a tuple variant or a tuple struct\n         }\n     }\n }"}, {"sha": "0d50a30dd0526b07f4495dd806180d537d785002", "filename": "src/test/compile-fail/pat-tuple-bad-type.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpat-tuple-bad-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpat-tuple-bad-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-tuple-bad-type.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn main() {\n+    let x;\n+\n+    match x {\n+        (..) => {} //~ ERROR the type of this value must be known in this context\n+        _ => {}\n+    }\n+\n+    match 0u8 {\n+        (..) => {} //~ ERROR mismatched types\n+        _ => {}\n+    }\n+\n+    x = 10;\n+}"}, {"sha": "55ca05bdef381f605f18ef926b7d3b64ce161444", "filename": "src/test/compile-fail/pat-tuple-feature-gate.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpat-tuple-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpat-tuple-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-tuple-feature-gate.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match 0 {\n+        (..) => {} //~ ERROR `..` in tuple patterns is experimental\n+        (pat, ..) => {} //~ ERROR `..` in tuple patterns is experimental\n+        S(pat, ..) => {} //~ ERROR `..` in tuple struct patterns is experimental\n+    }\n+}"}, {"sha": "034ef4a72e21c5d5896e77829a7838a0902ea663", "filename": "src/test/compile-fail/pat-tuple-overfield.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+struct S(u8, u8, u8);\n+\n+fn main() {\n+    match (1, 2, 3) {\n+        (1, 2, 3, 4) => {} //~ ERROR mismatched types\n+        (1, 2, .., 3, 4) => {} //~ ERROR mismatched types\n+        _ => {}\n+    }\n+    match S(1, 2, 3) {\n+        S(1, 2, 3, 4) => {}\n+        //~^ ERROR this pattern has 4 fields, but the corresponding struct has 3 fields\n+        S(1, 2, .., 3, 4) => {}\n+        //~^ ERROR this pattern has 4 fields, but the corresponding struct has 3 fields\n+        _ => {}\n+    }\n+}"}, {"sha": "507012e8c5c06803a7c3a2426678c08516fa3758", "filename": "src/test/compile-fail/pattern-error-continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -25,7 +25,7 @@ fn f(_c: char) {}\n fn main() {\n     match A::B(1, 2) {\n         A::B(_, _, _) => (), //~ ERROR this pattern has 3 fields, but\n-        A::D(_) => (),       //~ ERROR this pattern has 1 field, but\n+        A::D(_) => (),       //~ ERROR `A::D` does not name a tuple variant or a tuple struct\n         _ => ()\n     }\n     match 'c' {"}, {"sha": "fb78e558a951a7c6cbac3968b5f0a3dfaeb9f669", "filename": "src/test/parse-fail/pat-lt-bracket-6.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -9,6 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let Test(&desc[..]) = x; //~ error: expected one of `,` or `@`, found `[`\n-    //~^ ERROR expected one of `:`, `;`, `=`, or `@`, found `[`\n+    let Test(&desc[..]) = x; //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n }"}, {"sha": "d75589d8889e3381613a6f55a755dac09fb896c2", "filename": "src/test/parse-fail/pat-lt-bracket-7.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -9,6 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    for thing(x[]) in foo {} //~ error: expected one of `,` or `@`, found `[`\n-    //~^ ERROR expected one of `@` or `in`, found `[`\n+    for thing(x[]) in foo {} //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n }"}, {"sha": "945d0740654e8b82f3d744fc59c27c6a7cf6e15b", "filename": "src/test/parse-fail/pat-tuple-1.rs", "status": "renamed", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-1.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -8,15 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Number {\n-    Zero,\n-    One(u32)\n-}\n+// compile-flags: -Z parse-only\n \n fn main() {\n-    let x = Number::Zero;\n-    match x {\n-        Number::Zero(inside) => {}, //~ ERROR E0024\n-        Number::One(inside) => {},\n+    match 0 {\n+        (, ..) => {} //~ ERROR expected pattern, found `,`\n     }\n }", "previous_filename": "src/test/compile-fail/E0024.rs"}, {"sha": "ad52fa578700747983f67ef43593eafc67462e2c", "filename": "src/test/parse-fail/pat-tuple-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (pat, ..,) => {} //~ ERROR expected pattern, found `)`\n+    }\n+}"}, {"sha": "95e44ae134c075aba8cb7e9f4872d7ea15975321", "filename": "src/test/parse-fail/pat-tuple-3.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-3.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (.., pat, ..) => {} //~ ERROR expected pattern, found `..`\n+    }\n+}"}, {"sha": "f4c3afa07f106b37589a7b143d72102033c32898", "filename": "src/test/parse-fail/pat-tuple-4.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-4.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (.. pat) => {} //~ ERROR expected one of `)` or `,`, found `pat`\n+    }\n+}"}, {"sha": "145d1f9d8ec763c850f7ed23cfcbe8d187074bf9", "filename": "src/test/parse-fail/pat-tuple-5.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-5.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (pat ..) => {} //~ ERROR expected one of `)`, `,`, or `@`, found `..`\n+    }\n+}"}, {"sha": "3252d92fe1b50649d2c33fa002e55de548a402e3", "filename": "src/test/parse-fail/pat-tuple-6.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Fparse-fail%2Fpat-tuple-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-6.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (pat) => {} //~ ERROR expected one of `,` or `@`, found `)`\n+    }\n+}"}, {"sha": "ccea068f715a050438179e6488458b60cd1a6ca2", "filename": "src/test/run-pass/pat-tuple.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Frun-pass%2Fpat-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69aeaf662c637b454e8c7a5ddbd69b4978ec211/src%2Ftest%2Frun-pass%2Fpat-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple.rs?ref=d69aeaf662c637b454e8c7a5ddbd69b4978ec211", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn b() {\n+    let x = (1, 2, 3);\n+    match x {\n+        (a, b, ..) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+        }\n+    }\n+    match x {\n+        (.., b, c) => {\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        (a, .., c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        (a, b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+}\n+\n+fn bs() {\n+    struct S(u8, u8, u8);\n+\n+    let x = S(1, 2, 3);\n+    match x {\n+        S(a, b, ..) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+        }\n+    }\n+    match x {\n+        S(.., b, c) => {\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        S(a, .., c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        S(a, b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+}\n+\n+fn c() {\n+    let x = (1,);\n+    match x {\n+        (2, ..) => panic!(),\n+        (..) => ()\n+    }\n+}\n+\n+fn cs() {\n+    struct S(u8);\n+\n+    let x = S(1);\n+    match x {\n+        S(2, ..) => panic!(),\n+        S(..) => ()\n+    }\n+}\n+\n+fn d() {\n+    let x = (1, 2, 3);\n+    let branch = match x {\n+        (1, 1, ..) => 0,\n+        (1, 2, 3, ..) => 1,\n+        (1, 2, ..) => 2,\n+        _ => 3\n+    };\n+    assert_eq!(branch, 1);\n+}\n+\n+fn ds() {\n+    struct S(u8, u8, u8);\n+\n+    let x = S(1, 2, 3);\n+    let branch = match x {\n+        S(1, 1, ..) => 0,\n+        S(1, 2, 3, ..) => 1,\n+        S(1, 2, ..) => 2,\n+        _ => 3\n+    };\n+    assert_eq!(branch, 1);\n+}\n+\n+fn f() {\n+    let x = (1, 2, 3);\n+    match x {\n+        (1, 2, 4) => unreachable!(),\n+        (0, 2, 3, ..) => unreachable!(),\n+        (0, .., 3) => unreachable!(),\n+        (0, ..) => unreachable!(),\n+        (1, 2, 3) => (),\n+        (_, _, _) => unreachable!(),\n+    }\n+    match x {\n+        (..) => (),\n+    }\n+    match x {\n+        (_, _, _, ..) => (),\n+    }\n+    match x {\n+        (a, b, c) => {\n+            assert_eq!(1, a);\n+            assert_eq!(2, b);\n+            assert_eq!(3, c);\n+        }\n+    }\n+}\n+\n+fn fs() {\n+    struct S(u8, u8, u8);\n+\n+    let x = S(1, 2, 3);\n+    match x {\n+        S(1, 2, 4) => unreachable!(),\n+        S(0, 2, 3, ..) => unreachable!(),\n+        S(0, .., 3) => unreachable!(),\n+        S(0, ..) => unreachable!(),\n+        S(1, 2, 3) => (),\n+        S(_, _, _) => unreachable!(),\n+    }\n+    match x {\n+        S(..) => (),\n+    }\n+    match x {\n+        S(_, _, _, ..) => (),\n+    }\n+    match x {\n+        S(a, b, c) => {\n+            assert_eq!(1, a);\n+            assert_eq!(2, b);\n+            assert_eq!(3, c);\n+        }\n+    }\n+}\n+\n+fn g() {\n+    struct S;\n+    struct Z;\n+    struct W;\n+    let x = (S, Z, W);\n+    match x { (S, ..) => {} }\n+    match x { (.., W) => {} }\n+    match x { (S, .., W) => {} }\n+    match x { (.., Z, _) => {} }\n+}\n+\n+fn gs() {\n+    struct SS(S, Z, W);\n+\n+    struct S;\n+    struct Z;\n+    struct W;\n+    let x = SS(S, Z, W);\n+    match x { SS(S, ..) => {} }\n+    match x { SS(.., W) => {} }\n+    match x { SS(S, .., W) => {} }\n+    match x { SS(.., Z, _) => {} }\n+}\n+\n+fn main() {\n+    b();\n+    bs();\n+    c();\n+    cs();\n+    d();\n+    ds();\n+    f();\n+    fs();\n+    g();\n+    gs();\n+}"}]}