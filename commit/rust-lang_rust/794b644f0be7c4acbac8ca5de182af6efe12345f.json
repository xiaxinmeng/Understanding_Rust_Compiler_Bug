{"sha": "794b644f0be7c4acbac8ca5de182af6efe12345f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NGI2NDRmMGJlN2M0YWNiYWM4Y2E1ZGUxODJhZjZlZmUxMjM0NWY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-05T17:52:54Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-11T21:34:01Z"}, "message": "review comments", "tree": {"sha": "a16079ed407e0e9256c7da44fcaccef003d49883", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a16079ed407e0e9256c7da44fcaccef003d49883"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/794b644f0be7c4acbac8ca5de182af6efe12345f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/794b644f0be7c4acbac8ca5de182af6efe12345f", "html_url": "https://github.com/rust-lang/rust/commit/794b644f0be7c4acbac8ca5de182af6efe12345f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/794b644f0be7c4acbac8ca5de182af6efe12345f/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c998aa8bb463f21fd164e2c701f891f5d5660d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c998aa8bb463f21fd164e2c701f891f5d5660d0", "html_url": "https://github.com/rust-lang/rust/commit/2c998aa8bb463f21fd164e2c701f891f5d5660d0"}], "stats": {"total": 178, "additions": 86, "deletions": 92}, "files": [{"sha": "9ada88098a5b508047ba12c0e921d0506f192266", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/794b644f0be7c4acbac8ca5de182af6efe12345f/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794b644f0be7c4acbac8ca5de182af6efe12345f/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=794b644f0be7c4acbac8ca5de182af6efe12345f", "patch": "@@ -17,6 +17,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n #![feature(str_strip)]\n+#![feature(option_zip)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "fef7adf02246b252ad02131d2064cbbaaa0a37b1", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/794b644f0be7c4acbac8ca5de182af6efe12345f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794b644f0be7c4acbac8ca5de182af6efe12345f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=794b644f0be7c4acbac8ca5de182af6efe12345f", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // which is somewhat confusing.\n                             self.suggest_restricting_param_bound(\n                                 &mut err,\n-                                &trait_ref,\n+                                trait_ref,\n                                 obligation.cause.body_id,\n                             );\n                         } else {"}, {"sha": "b3209ddc7fef5a0a12c13ae84699843fb37eeb7d", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 84, "deletions": 91, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/794b644f0be7c4acbac8ca5de182af6efe12345f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794b644f0be7c4acbac8ca5de182af6efe12345f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=794b644f0be7c4acbac8ca5de182af6efe12345f", "patch": "@@ -27,7 +27,7 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     );\n \n@@ -168,111 +168,104 @@ fn suggest_restriction(\n     err: &mut DiagnosticBuilder<'_>,\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n-    trait_ref: &ty::PolyTraitRef<'_>,\n+    trait_ref: ty::PolyTraitRef<'_>,\n ) {\n     let span = generics.where_clause.span_for_predicates_or_empty_place();\n-    if !span.from_expansion() && span.desugaring_kind().is_none() {\n-        // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n-        if let Some((name, fn_sig)) = fn_sig.and_then(|sig| {\n-            projection.and_then(|p| {\n-                // Shenanigans to get the `Trait` from the `impl Trait`.\n-                match p.self_ty().kind {\n-                    ty::Param(param) => {\n-                        // `fn foo(t: impl Trait)`\n-                        //                 ^^^^^ get this string\n-                        param\n-                            .name\n-                            .as_str()\n-                            .strip_prefix(\"impl\")\n-                            .map(|s| (s.trim_start().to_string(), sig))\n-                    }\n-                    _ => None,\n-                }\n-            })\n-        }) {\n-            // We know we have an `impl Trait` that doesn't satisfy a required projection.\n-\n-            // Find all of the ocurrences of `impl Trait` for `Trait` in the function arguments'\n-            // types. There should be at least one, but there might be *more* than one. In that\n-            // case we could just ignore it and try to identify which one needs the restriction,\n-            // but instead we choose to suggest replacing all instances of `impl Trait` with `T`\n-            // where `T: Trait`.\n-            let mut ty_spans = vec![];\n-            let impl_name = format!(\"impl {}\", name);\n-            for input in fn_sig.decl.inputs {\n-                if let hir::TyKind::Path(hir::QPath::Resolved(\n-                    None,\n-                    hir::Path { segments: [segment], .. },\n-                )) = input.kind\n-                {\n-                    if segment.ident.as_str() == impl_name.as_str() {\n-                        // `fn foo(t: impl Trait)`\n-                        //            ^^^^^^^^^^ get this to suggest\n-                        //                       `T` instead\n+    if span.from_expansion() || span.desugaring_kind().is_some() {\n+        return;\n+    }\n+    // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n+    if let Some((name, fn_sig)) =\n+        fn_sig.zip(projection).and_then(|(sig, p)| match p.self_ty().kind {\n+            // Shenanigans to get the `Trait` from the `impl Trait`.\n+            ty::Param(param) => {\n+                // `fn foo(t: impl Trait)`\n+                //                 ^^^^^ get this string\n+                param.name.as_str().strip_prefix(\"impl\").map(|s| (s.trim_start().to_string(), sig))\n+            }\n+            _ => None,\n+        })\n+    {\n+        // We know we have an `impl Trait` that doesn't satisfy a required projection.\n+\n+        // Find all of the ocurrences of `impl Trait` for `Trait` in the function arguments'\n+        // types. There should be at least one, but there might be *more* than one. In that\n+        // case we could just ignore it and try to identify which one needs the restriction,\n+        // but instead we choose to suggest replacing all instances of `impl Trait` with `T`\n+        // where `T: Trait`.\n+        let mut ty_spans = vec![];\n+        let impl_name = format!(\"impl {}\", name);\n+        for input in fn_sig.decl.inputs {\n+            if let hir::TyKind::Path(hir::QPath::Resolved(\n+                None,\n+                hir::Path { segments: [segment], .. },\n+            )) = input.kind\n+            {\n+                if segment.ident.as_str() == impl_name.as_str() {\n+                    // `fn foo(t: impl Trait)`\n+                    //            ^^^^^^^^^^ get this to suggest\n+                    //                       `T` instead\n \n-                        // There might be more than one `impl Trait`.\n-                        ty_spans.push(input.span);\n-                    }\n+                    // There might be more than one `impl Trait`.\n+                    ty_spans.push(input.span);\n                 }\n             }\n+        }\n \n-            // The type param `T: Trait` we will suggest to introduce.\n-            let type_param = format!(\"{}: {}\", \"T\", name);\n-\n-            // FIXME: modify the `trait_ref` instead of string shenanigans.\n-            // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-            let pred = trait_ref.without_const().to_predicate().to_string();\n-            let pred = pred.replace(&impl_name, \"T\");\n-            let mut sugg = vec![\n-                match generics\n-                    .params\n-                    .iter()\n-                    .filter(|p| match p.kind {\n-                        hir::GenericParamKind::Type {\n-                            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                            ..\n-                        } => false,\n-                        _ => true,\n-                    })\n-                    .last()\n-                {\n-                    // `fn foo(t: impl Trait)`\n-                    //        ^ suggest `<T: Trait>` here\n-                    None => (generics.span, format!(\"<{}>\", type_param)),\n-                    // `fn foo<A>(t: impl Trait)`\n-                    //        ^^^ suggest `<A, T: Trait>` here\n-                    Some(param) => (param.span.shrink_to_hi(), format!(\", {}\", type_param)),\n-                },\n+        // The type param `T: Trait` we will suggest to introduce.\n+        let type_param = format!(\"{}: {}\", \"T\", name);\n+\n+        // FIXME: modify the `trait_ref` instead of string shenanigans.\n+        // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n+        let pred = trait_ref.without_const().to_predicate().to_string();\n+        let pred = pred.replace(&impl_name, \"T\");\n+        let mut sugg = vec![\n+            match generics\n+                .params\n+                .iter()\n+                .filter(|p| match p.kind {\n+                    hir::GenericParamKind::Type {\n+                        synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                        ..\n+                    } => false,\n+                    _ => true,\n+                })\n+                .last()\n+            {\n                 // `fn foo(t: impl Trait)`\n-                //                       ^ suggest `where <T as Trait>::A: Bound`\n-                predicate_constraint(generics, pred),\n-            ];\n-            sugg.extend(ty_spans.into_iter().map(|s| (s, \"T\".to_string())));\n-\n-            // Suggest `fn foo<T: Trait>(t: T) where <T as Trait>::A: Bound`.\n-            err.multipart_suggestion(\n-                \"introduce a type parameter with a trait bound instead of using \\\n+                //        ^ suggest `<T: Trait>` here\n+                None => (generics.span, format!(\"<{}>\", type_param)),\n+                // `fn foo<A>(t: impl Trait)`\n+                //        ^^^ suggest `<A, T: Trait>` here\n+                Some(param) => (param.span.shrink_to_hi(), format!(\", {}\", type_param)),\n+            },\n+            // `fn foo(t: impl Trait)`\n+            //                       ^ suggest `where <T as Trait>::A: Bound`\n+            predicate_constraint(generics, pred),\n+        ];\n+        sugg.extend(ty_spans.into_iter().map(|s| (s, \"T\".to_string())));\n+\n+        // Suggest `fn foo<T: Trait>(t: T) where <T as Trait>::A: Bound`.\n+        err.multipart_suggestion(\n+            \"introduce a type parameter with a trait bound instead of using \\\n                     `impl Trait`\",\n-                sugg,\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            // Trivial case: `T` needs an extra bound: `T: Bound`.\n-            let (sp, s) = predicate_constraint(\n-                generics,\n-                trait_ref.without_const().to_predicate().to_string(),\n-            );\n-            let appl = Applicability::MachineApplicable;\n-            err.span_suggestion(sp, &format!(\"consider further restricting {}\", msg), s, appl);\n-        }\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    } else {\n+        // Trivial case: `T` needs an extra bound: `T: Bound`.\n+        let (sp, s) =\n+            predicate_constraint(generics, trait_ref.without_const().to_predicate().to_string());\n+        let appl = Applicability::MachineApplicable;\n+        err.span_suggestion(sp, &format!(\"consider further restricting {}\", msg), s, appl);\n     }\n }\n \n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     ) {\n         let self_ty = trait_ref.self_ty();"}]}