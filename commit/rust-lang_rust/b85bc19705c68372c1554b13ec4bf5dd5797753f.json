{"sha": "b85bc19705c68372c1554b13ec4bf5dd5797753f", "node_id": "C_kwDOAAsO6NoAKGI4NWJjMTk3MDVjNjgzNzJjMTU1NGIxM2VjNGJmNWRkNTc5Nzc1M2Y", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-03-17T15:02:24Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-03-17T15:02:24Z"}, "message": "move `compute_goal` and `evaluate_x` methods to inner module", "tree": {"sha": "53571831d76181c48631f77786f28fec8463bb76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53571831d76181c48631f77786f28fec8463bb76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b85bc19705c68372c1554b13ec4bf5dd5797753f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b85bc19705c68372c1554b13ec4bf5dd5797753f", "html_url": "https://github.com/rust-lang/rust/commit/b85bc19705c68372c1554b13ec4bf5dd5797753f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b85bc19705c68372c1554b13ec4bf5dd5797753f/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9df35a5050e49b17bae559a074cb30798f8ca6da", "url": "https://api.github.com/repos/rust-lang/rust/commits/9df35a5050e49b17bae559a074cb30798f8ca6da", "html_url": "https://github.com/rust-lang/rust/commit/9df35a5050e49b17bae559a074cb30798f8ca6da"}], "stats": {"total": 544, "additions": 272, "deletions": 272}, "files": [{"sha": "9541292235795a2d8a4b7e9b72adeefe217fbe79", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 269, "deletions": 1, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/b85bc19705c68372c1554b13ec4bf5dd5797753f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bc19705c68372c1554b13ec4bf5dd5797753f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=b85bc19705c68372c1554b13ec4bf5dd5797753f", "patch": "@@ -2,8 +2,11 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{\n+    DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n+};\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::{\n@@ -13,6 +16,7 @@ use rustc_middle::ty::{\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n+use super::search_graph::{self, OverflowHandler};\n use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n@@ -57,6 +61,270 @@ impl NestedGoals<'_> {\n     }\n }\n \n+pub trait InferCtxtEvalExt<'tcx> {\n+    /// Evaluates a goal from **outside** of the trait solver.\n+    ///\n+    /// Using this while inside of the solver is wrong as it uses a new\n+    /// search graph which would break cycle detection.\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution>;\n+}\n+\n+impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+\n+        let mut ecx = EvalCtxt {\n+            search_graph: &mut search_graph,\n+            infcx: self,\n+            // Only relevant when canonicalizing the response.\n+            max_input_universe: ty::UniverseIndex::ROOT,\n+            var_values: CanonicalVarValues::dummy(),\n+            nested_goals: NestedGoals::new(),\n+        };\n+        let result = ecx.evaluate_goal(IsNormalizesToHack::No, goal);\n+\n+        assert!(\n+            ecx.nested_goals.is_empty(),\n+            \"root `EvalCtxt` should not have any goals added to it\"\n+        );\n+\n+        assert!(search_graph.is_empty());\n+        result\n+    }\n+}\n+\n+impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    /// The entry point of the solver.\n+    ///\n+    /// This function deals with (coinductive) cycles, overflow, and caching\n+    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n+    /// logic of the solver.\n+    ///\n+    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n+    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n+    /// outside of it.\n+    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n+    fn evaluate_canonical_goal(\n+        tcx: TyCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        // Deal with overflow, caching, and coinduction.\n+        //\n+        // The actual solver logic happens in `ecx.compute_goal`.\n+        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n+            let (ref infcx, goal, var_values) =\n+                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let mut ecx = EvalCtxt {\n+                infcx,\n+                var_values,\n+                max_input_universe: canonical_goal.max_universe,\n+                search_graph,\n+                nested_goals: NestedGoals::new(),\n+            };\n+            ecx.compute_goal(goal)\n+        })\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        is_normalizes_to_hack: IsNormalizesToHack,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+        let canonical_response =\n+            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+\n+        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let certainty = self.instantiate_and_apply_query_response(\n+            goal.param_env,\n+            orig_values,\n+            canonical_response,\n+        )?;\n+\n+        // Check that rerunning this query with its inference constraints applied\n+        // doesn't result in new inference constraints and has the same result.\n+        //\n+        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n+        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n+        // could constrain `U` to `u32` which would cause this check to result in a\n+        // solver cycle.\n+        if cfg!(debug_assertions)\n+            && has_changed\n+            && is_normalizes_to_hack == IsNormalizesToHack::No\n+            && !self.search_graph.in_cycle()\n+        {\n+            debug!(\"rerunning goal to check result is stable\");\n+            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+            let canonical_response =\n+                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+            if !canonical_response.value.var_values.is_identity() {\n+                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+            }\n+            assert_eq!(certainty, canonical_response.value.certainty);\n+        }\n+\n+        Ok((has_changed, certainty))\n+    }\n+\n+    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n+        let Goal { param_env, predicate } = goal;\n+        let kind = predicate.kind();\n+        if let Some(kind) = kind.no_bound_vars() {\n+            match kind {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    self.compute_trait_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    self.compute_projection_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n+                }\n+                ty::PredicateKind::Subtype(predicate) => {\n+                    self.compute_subtype_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Coerce(predicate) => {\n+                    self.compute_coerce_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n+                    .compute_closure_kind_goal(Goal {\n+                        param_env,\n+                        predicate: (def_id, substs, kind),\n+                    }),\n+                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                    self.compute_object_safe_goal(trait_def_id)\n+                }\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n+                }\n+                ty::PredicateKind::Ambiguous => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                }\n+                // FIXME: implement these predicates :)\n+                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n+                }\n+                ty::PredicateKind::AliasEq(lhs, rhs) => {\n+                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n+                }\n+            }\n+        } else {\n+            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n+            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n+            self.add_goal(goal);\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n+    }\n+\n+    // Recursively evaluates all the goals added to this `EvalCtxt` to completion, returning\n+    // the certainty of all the goals.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(super) fn try_evaluate_added_goals(&mut self) -> Result<Certainty, NoSolution> {\n+        let mut goals = core::mem::replace(&mut self.nested_goals, NestedGoals::new());\n+        let mut new_goals = NestedGoals::new();\n+\n+        let response = self.repeat_while_none(\n+            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n+            |this| {\n+                let mut has_changed = Err(Certainty::Yes);\n+\n+                if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n+                    let (_, certainty) = match this.evaluate_goal(\n+                        IsNormalizesToHack::Yes,\n+                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    ) {\n+                        Ok(r) => r,\n+                        Err(NoSolution) => return Some(Err(NoSolution)),\n+                    };\n+\n+                    if goal.predicate.projection_ty\n+                        != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n+                    {\n+                        has_changed = Ok(())\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            let goal = this.resolve_vars_if_possible(goal);\n+\n+                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n+                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n+                            // regardless of the rhs.\n+                            //\n+                            // However it is important not to unconditionally replace the rhs with a new infer var\n+                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n+                            // and never propagate any constraints on the new var back to the original var.\n+                            let term = this\n+                                .term_is_fully_unconstrained(goal)\n+                                .then_some(goal.predicate.term)\n+                                .unwrap_or_else(|| {\n+                                    this.next_term_infer_of_kind(goal.predicate.term)\n+                                });\n+                            let projection_pred = ty::ProjectionPredicate {\n+                                term,\n+                                projection_ty: goal.predicate.projection_ty,\n+                            };\n+                            new_goals.normalizes_to_hack_goal =\n+                                Some(goal.with(this.tcx(), projection_pred));\n+\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                for nested_goal in goals.goals.drain(..) {\n+                    let (changed, certainty) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                            Ok(result) => result,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+\n+                    if changed {\n+                        has_changed = Ok(());\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            new_goals.goals.push(nested_goal);\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                core::mem::swap(&mut new_goals, &mut goals);\n+                match has_changed {\n+                    Ok(()) => None,\n+                    Err(certainty) => Some(Ok(certainty)),\n+                }\n+            },\n+        );\n+\n+        self.nested_goals = goals;\n+        response\n+    }\n+}\n+\n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn probe<T>(&mut self, f: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> T) -> T {\n         let mut ecx = EvalCtxt {"}, {"sha": "606c2eaa510518b07595dbd6460773efcc155236", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 3, "deletions": 271, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/b85bc19705c68372c1554b13ec4bf5dd5797753f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bc19705c68372c1554b13ec4bf5dd5797753f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=b85bc19705c68372c1554b13ec4bf5dd5797753f", "patch": "@@ -15,23 +15,19 @@\n \n // FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n \n-use std::mem;\n-\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n-    Goal, MaybeCause, QueryResult, Response,\n+    Goal, QueryResult, Response,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n-use rustc_span::DUMMY_SP;\n \n-use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n@@ -42,11 +38,9 @@ mod project_goals;\n mod search_graph;\n mod trait_goals;\n \n-pub use eval_ctxt::EvalCtxt;\n+pub use eval_ctxt::{EvalCtxt, InferCtxtEvalExt};\n pub use fulfill::FulfillmentCtxt;\n \n-use self::eval_ctxt::{IsNormalizesToHack, NestedGoals};\n-\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -59,180 +53,7 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     }\n }\n \n-pub trait InferCtxtEvalExt<'tcx> {\n-    /// Evaluates a goal from **outside** of the trait solver.\n-    ///\n-    /// Using this while inside of the solver is wrong as it uses a new\n-    /// search graph which would break cycle detection.\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution>;\n-}\n-\n-impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n-\n-        let mut ecx = EvalCtxt {\n-            search_graph: &mut search_graph,\n-            infcx: self,\n-            // Only relevant when canonicalizing the response.\n-            max_input_universe: ty::UniverseIndex::ROOT,\n-            var_values: CanonicalVarValues::dummy(),\n-            nested_goals: NestedGoals::new(),\n-        };\n-        let result = ecx.evaluate_goal(IsNormalizesToHack::No, goal);\n-\n-        assert!(\n-            ecx.nested_goals.is_empty(),\n-            \"root `EvalCtxt` should not have any goals added to it\"\n-        );\n-\n-        assert!(search_graph.is_empty());\n-        result\n-    }\n-}\n-\n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n-    /// The entry point of the solver.\n-    ///\n-    /// This function deals with (coinductive) cycles, overflow, and caching\n-    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n-    /// logic of the solver.\n-    ///\n-    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n-    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n-    /// outside of it.\n-    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n-    fn evaluate_canonical_goal(\n-        tcx: TyCtxt<'tcx>,\n-        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        // Deal with overflow, caching, and coinduction.\n-        //\n-        // The actual solver logic happens in `ecx.compute_goal`.\n-        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n-            let (ref infcx, goal, var_values) =\n-                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx = EvalCtxt {\n-                infcx,\n-                var_values,\n-                max_input_universe: canonical_goal.max_universe,\n-                search_graph,\n-                nested_goals: NestedGoals::new(),\n-            };\n-            ecx.compute_goal(goal)\n-        })\n-    }\n-\n-    /// Recursively evaluates `goal`, returning whether any inference vars have\n-    /// been constrained and the certainty of the result.\n-    fn evaluate_goal(\n-        &mut self,\n-        is_normalizes_to_hack: IsNormalizesToHack,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-        let canonical_response =\n-            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-\n-        let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty = self.instantiate_and_apply_query_response(\n-            goal.param_env,\n-            orig_values,\n-            canonical_response,\n-        )?;\n-\n-        // Check that rerunning this query with its inference constraints applied\n-        // doesn't result in new inference constraints and has the same result.\n-        //\n-        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n-        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n-        // could constrain `U` to `u32` which would cause this check to result in a\n-        // solver cycle.\n-        if cfg!(debug_assertions)\n-            && has_changed\n-            && is_normalizes_to_hack == IsNormalizesToHack::No\n-            && !self.search_graph.in_cycle()\n-        {\n-            debug!(\"rerunning goal to check result is stable\");\n-            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-            let canonical_response =\n-                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n-            }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n-        }\n-\n-        Ok((has_changed, certainty))\n-    }\n-\n-    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n-        let Goal { param_env, predicate } = goal;\n-        let kind = predicate.kind();\n-        if let Some(kind) = kind.no_bound_vars() {\n-            match kind {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n-                    self.compute_trait_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n-                    self.compute_projection_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n-                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n-                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n-                }\n-                ty::PredicateKind::Subtype(predicate) => {\n-                    self.compute_subtype_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Coerce(predicate) => {\n-                    self.compute_coerce_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n-                    .compute_closure_kind_goal(Goal {\n-                        param_env,\n-                        predicate: (def_id, substs, kind),\n-                    }),\n-                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                    self.compute_object_safe_goal(trait_def_id)\n-                }\n-                ty::PredicateKind::WellFormed(arg) => {\n-                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n-                }\n-                ty::PredicateKind::Ambiguous => {\n-                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n-                }\n-                // FIXME: implement these predicates :)\n-                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n-                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                }\n-                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n-                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n-                }\n-                ty::PredicateKind::AliasEq(lhs, rhs) => {\n-                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n-                }\n-            }\n-        } else {\n-            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n-            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n-            self.add_goal(goal);\n-            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-        }\n-    }\n-\n     #[instrument(level = \"debug\", skip(self))]\n     fn compute_type_outlives_goal(\n         &mut self,\n@@ -424,95 +245,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n-    // Recursively evaluates all the goals added to this `EvalCtxt` to completion, returning\n-    // the certainty of all the goals.\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn try_evaluate_added_goals(&mut self) -> Result<Certainty, NoSolution> {\n-        let mut goals = core::mem::replace(&mut self.nested_goals, NestedGoals::new());\n-        let mut new_goals = NestedGoals::new();\n-\n-        let response = self.repeat_while_none(\n-            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n-            |this| {\n-                let mut has_changed = Err(Certainty::Yes);\n-\n-                if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty) = match this.evaluate_goal(\n-                        IsNormalizesToHack::Yes,\n-                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n-                    ) {\n-                        Ok(r) => r,\n-                        Err(NoSolution) => return Some(Err(NoSolution)),\n-                    };\n-\n-                    if goal.predicate.projection_ty\n-                        != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n-                    {\n-                        has_changed = Ok(())\n-                    }\n-\n-                    match certainty {\n-                        Certainty::Yes => {}\n-                        Certainty::Maybe(_) => {\n-                            let goal = this.resolve_vars_if_possible(goal);\n-\n-                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n-                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n-                            // regardless of the rhs.\n-                            //\n-                            // However it is important not to unconditionally replace the rhs with a new infer var\n-                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n-                            // and never propagate any constraints on the new var back to the original var.\n-                            let term = this\n-                                .term_is_fully_unconstrained(goal)\n-                                .then_some(goal.predicate.term)\n-                                .unwrap_or_else(|| {\n-                                    this.next_term_infer_of_kind(goal.predicate.term)\n-                                });\n-                            let projection_pred = ty::ProjectionPredicate {\n-                                term,\n-                                projection_ty: goal.predicate.projection_ty,\n-                            };\n-                            new_goals.normalizes_to_hack_goal =\n-                                Some(goal.with(this.tcx(), projection_pred));\n-\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n-                        }\n-                    }\n-                }\n-\n-                for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty) =\n-                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n-                            Ok(result) => result,\n-                            Err(NoSolution) => return Some(Err(NoSolution)),\n-                        };\n-\n-                    if changed {\n-                        has_changed = Ok(());\n-                    }\n-\n-                    match certainty {\n-                        Certainty::Yes => {}\n-                        Certainty::Maybe(_) => {\n-                            new_goals.goals.push(nested_goal);\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n-                        }\n-                    }\n-                }\n-\n-                mem::swap(&mut new_goals, &mut goals);\n-                match has_changed {\n-                    Ok(()) => None,\n-                    Err(certainty) => Some(Ok(certainty)),\n-                }\n-            },\n-        );\n-\n-        self.nested_goals = goals;\n-        response\n-    }\n-\n     fn try_merge_responses(\n         &mut self,\n         responses: impl Iterator<Item = QueryResult<'tcx>>,"}]}