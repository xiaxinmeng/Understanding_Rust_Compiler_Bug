{"sha": "c0348746c35ae83d2f1eb4e00ca8b27ff8d235be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMzQ4NzQ2YzM1YWU4M2QyZjFlYjRlMDBjYThiMjdmZjhkMjM1YmU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-06-25T19:53:34Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-02T13:50:39Z"}, "message": "rustc_save_analysis: avoid using TypeckTables::empty for SaveContext.", "tree": {"sha": "77a4e981b71924a3196eff58487f5cf7938aad8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77a4e981b71924a3196eff58487f5cf7938aad8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be", "html_url": "https://github.com/rust-lang/rust/commit/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780d6cb1408717f968a21d627cc34c8ffa7f6fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/780d6cb1408717f968a21d627cc34c8ffa7f6fe8", "html_url": "https://github.com/rust-lang/rust/commit/780d6cb1408717f968a21d627cc34c8ffa7f6fe8"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "38be97fc8d9eb2186c814464d1f90655c0f486a1", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c0348746c35ae83d2f1eb4e00ca8b27ff8d235be", "patch": "@@ -109,15 +109,15 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         F: FnOnce(&mut Self),\n     {\n         let tables = if self.tcx.has_typeck_tables(item_def_id) {\n-            self.tcx.typeck_tables_of(item_def_id)\n+            Some(self.tcx.typeck_tables_of(item_def_id))\n         } else {\n-            self.save_ctxt.empty_tables\n+            None\n         };\n \n-        let old_tables = self.save_ctxt.tables;\n-        self.save_ctxt.tables = tables;\n+        let old_maybe_typeck_tables = self.save_ctxt.maybe_typeck_tables;\n+        self.save_ctxt.maybe_typeck_tables = tables;\n         f(self);\n-        self.save_ctxt.tables = old_tables;\n+        self.save_ctxt.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn span_from_span(&self, span: Span) -> SpanData {\n@@ -226,7 +226,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n \n             for (hir_id, ident, ..) in collector.collected_idents {\n-                let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n+                let typ = match self.save_ctxt.tables().node_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -859,7 +859,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         match p.kind {\n             hir::PatKind::Struct(ref _path, fields, _) => {\n                 // FIXME do something with _path?\n-                let adt = match self.save_ctxt.tables.node_type_opt(p.hir_id) {\n+                let adt = match self.save_ctxt.tables().node_type_opt(p.hir_id) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n                         intravisit::walk_pat(self, p);\n@@ -900,7 +900,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 Res::Local(hir_id) => {\n                     let typ = self\n                         .save_ctxt\n-                        .tables\n+                        .tables()\n                         .node_type_opt(hir_id)\n                         .map(|t| t.to_string())\n                         .unwrap_or_default();\n@@ -1393,7 +1393,7 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n         match ex.kind {\n             hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n-                let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n+                let adt = match self.save_ctxt.tables().expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n                         intravisit::walk_expr(self, ex);"}, {"sha": "1ac91289a8623fb16c0de41feef992f743dc620b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0348746c35ae83d2f1eb4e00ca8b27ff8d235be/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c0348746c35ae83d2f1eb4e00ca8b27ff8d235be", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n mod dump_visitor;\n@@ -47,12 +48,9 @@ use rls_data::{\n \n use log::{debug, error, info};\n \n-pub struct SaveContext<'l, 'tcx> {\n+pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'l ty::TypeckTables<'tcx>,\n-    /// Used as a fallback when nesting the typeck tables during item processing\n-    /// (if these are not available for that item, e.g. don't own a body)\n-    empty_tables: &'l ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     access_levels: &'l AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n     config: Config,\n@@ -67,6 +65,14 @@ pub enum Data {\n }\n \n impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`SaveContext::tables` called outside of body\")\n+    }\n+\n     fn span_from_span(&self, span: Span) -> SpanData {\n         use rls_span::{Column, Row};\n \n@@ -518,13 +524,13 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n-        let ty = self.tables.expr_ty_adjusted_opt(expr)?;\n+        let ty = self.tables().expr_ty_adjusted_opt(expr)?;\n         if matches!(ty.kind, ty::Error(_)) {\n             return None;\n         }\n         match expr.kind {\n             hir::ExprKind::Field(ref sub_ex, ident) => {\n-                match self.tables.expr_ty_adjusted(&sub_ex).kind {\n+                match self.tables().expr_ty_adjusted(&sub_ex).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         filter!(self.span_utils, ident.span);\n@@ -569,7 +575,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }\n             }\n             hir::ExprKind::MethodCall(ref seg, ..) => {\n-                let method_id = match self.tables.type_dependent_def_id(expr.hir_id) {\n+                let method_id = match self.tables().type_dependent_def_id(expr.hir_id) {\n                     Some(id) => id,\n                     None => {\n                         debug!(\"could not resolve method id for {:?}\", expr);\n@@ -618,7 +624,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             },\n \n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Struct(ref qpath, ..), .. }) => {\n-                self.tables.qpath_res(qpath, hir_id)\n+                self.tables().qpath_res(qpath, hir_id)\n             }\n \n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Path(ref qpath), .. })\n@@ -629,9 +635,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     | hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             })\n-            | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => {\n-                self.tables.qpath_res(qpath, hir_id)\n-            }\n+            | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => match qpath {\n+                hir::QPath::Resolved(_, path) => path.res,\n+                hir::QPath::TypeRelative(..) => self\n+                    .maybe_typeck_tables\n+                    .map_or(Res::Err, |tables| tables.qpath_res(qpath, hir_id)),\n+            },\n \n             Node::Binding(&hir::Pat {\n                 kind: hir::PatKind::Binding(_, canonical_id, ..), ..\n@@ -1001,8 +1010,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n \n         let save_ctxt = SaveContext {\n             tcx,\n-            tables: &ty::TypeckTables::empty(None),\n-            empty_tables: &ty::TypeckTables::empty(None),\n+            maybe_typeck_tables: None,\n             access_levels: &access_levels,\n             span_utils: SpanUtils::new(&tcx.sess),\n             config: find_config(config),"}]}