{"sha": "e1ff91f439bc09f566da211c6449821b4e949279", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZmY5MWY0MzliYzA5ZjU2NmRhMjExYzY0NDk4MjFiNGU5NDkyNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-12T11:05:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-12T11:05:56Z"}, "message": "Auto merge of #83813 - cbeuw:remap-std, r=michaelwoerister\n\nFix `--remap-path-prefix` not correctly remapping `rust-src` component paths and unify handling of path mapping with virtualized paths\n\nThis PR fixes #73167 (\"Binaries end up containing path to the rust-src component despite `--remap-path-prefix`\") by preventing real local filesystem paths from reaching compilation output if the path is supposed to be remapped.\n\n`RealFileName::Named` introduced in #72767 is now renamed as `LocalPath`, because this variant wraps a (most likely) valid local filesystem path.\n\n`RealFileName::Devirtualized` is renamed as `Remapped` to be used for remapped path from a real path via `--remap-path-prefix` argument, as well as real path inferred from a virtualized (during compiler bootstrapping) `/rustc/...` path. The `local_path` field is now an `Option<PathBuf>`, as it will be set to `None` before serialisation, so it never reaches any build output. Attempting to serialise a non-`None` `local_path` will cause an assertion faliure.\n\nWhen a path is remapped, a `RealFileName::Remapped` variant is created. The original path is preserved in `local_path` field and the remapped path is saved in `virtual_name` field. Previously, the `local_path` is directly modified which goes against its purpose of \"suitable for reading from the file system on the local host\".\n\n`rustc_span::SourceFile`'s fields `unmapped_path` (introduced by #44940) and `name_was_remapped` (introduced by #41508 when `--remap-path-prefix` feature originally added) are removed, as these two pieces of information can be inferred from the `name` field: if it's anything other than a `FileName::Real(_)`, or if it is a `FileName::Real(RealFileName::LocalPath(_))`, then clearly `name_was_remapped` would've been false and `unmapped_path` would've been `None`. If it is a `FileName::Real(RealFileName::Remapped{local_path, virtual_name})`, then `name_was_remapped` would've been true and `unmapped_path` would've been `Some(local_path)`.\n\ncc `@eddyb` who implemented `/rustc/...` path devirtualisation", "tree": {"sha": "caf30c76d01ab56c1307a6a10d8f73cd8b925b7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caf30c76d01ab56c1307a6a10d8f73cd8b925b7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1ff91f439bc09f566da211c6449821b4e949279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1ff91f439bc09f566da211c6449821b4e949279", "html_url": "https://github.com/rust-lang/rust/commit/e1ff91f439bc09f566da211c6449821b4e949279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1ff91f439bc09f566da211c6449821b4e949279/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd", "html_url": "https://github.com/rust-lang/rust/commit/ac923d94f86a6f7c881ecbedcd0a68d7986a35bd"}, {"sha": "37dbe868c92b16211ef2a670f9c9f457515f857b", "url": "https://api.github.com/repos/rust-lang/rust/commits/37dbe868c92b16211ef2a670f9c9f457515f857b", "html_url": "https://github.com/rust-lang/rust/commit/37dbe868c92b16211ef2a670f9c9f457515f857b"}], "stats": {"total": 707, "additions": 442, "deletions": 265}, "files": [{"sha": "ccb9f15b0f50585effc0e1918fd6d718a18abcbc", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -61,7 +61,9 @@ pub fn expand_file(\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n     let loc = cx.source_map().lookup_char_pos(topmost.lo());\n-    base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name.to_string())))\n+    base::MacEager::expr(\n+        cx.expr_str(topmost, Symbol::intern(&loc.file.name.prefer_remapped().to_string_lossy())),\n+    )\n }\n \n pub fn expand_stringify("}, {"sha": "c12d6d0f1414306a13c698059eb544493129766a", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -334,7 +334,9 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         let const_loc = self.tcx.const_caller_location((\n-            rustc_span::symbol::Symbol::intern(&caller.file.name.to_string()),\n+            rustc_span::symbol::Symbol::intern(\n+                &caller.file.name.prefer_remapped().to_string_lossy(),\n+            ),\n             caller.line as u32,\n             caller.col_display as u32 + 1,\n         ));"}, {"sha": "9eb067706309e12cebc5a06146d24e433da1f6e0", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -66,7 +66,7 @@ fn line_program_add_file(\n ) -> FileId {\n     match &file.name {\n         FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.stable_name());\n+            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n             let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n             let file_name = osstr_as_utf8_bytes(file_name);\n \n@@ -87,7 +87,7 @@ fn line_program_add_file(\n         filename => {\n             let dir_id = line_program.default_directory();\n             let dummy_file_name = LineString::new(\n-                filename.to_string().into_bytes(),\n+                filename.prefer_remapped().to_string().into_bytes(),\n                 line_program.encoding(),\n                 line_strings,\n             );"}, {"sha": "61e54a76f29ba514956cb25c6066ef6182190e79", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> DebugContext<'tcx> {\n         // FIXME: how to get version when building out of tree?\n         // Normally this would use option_env!(\"CFG_VERSION\").\n         let producer = format!(\"cg_clif (rustc {})\", \"unknown version\");\n-        let comp_dir = tcx.sess.working_dir.0.to_string_lossy().into_owned();\n+        let comp_dir = tcx.sess.working_dir.to_string_lossy(false).into_owned();\n         let (name, file_info) = match tcx.sess.local_crate_source_file.clone() {\n             Some(path) => {\n                 let name = path.to_string_lossy().into_owned();"}, {"sha": "5cf831475d4645c77be7b90f3f73c4596ea54523", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -760,12 +760,12 @@ fn hex_encode(data: &[u8]) -> String {\n }\n \n pub fn file_metadata(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll DIFile {\n-    debug!(\"file_metadata: file_name: {}\", source_file.name);\n+    debug!(\"file_metadata: file_name: {:?}\", source_file.name);\n \n     let hash = Some(&source_file.src_hash);\n-    let file_name = Some(source_file.name.to_string());\n+    let file_name = Some(source_file.name.prefer_remapped().to_string());\n     let directory = if source_file.is_real_file() && !source_file.is_imported() {\n-        Some(cx.sess().working_dir.0.to_string_lossy().to_string())\n+        Some(cx.sess().working_dir.to_string_lossy(false).to_string())\n     } else {\n         // If the path comes from an upstream crate we assume it has been made\n         // independent of the compiler's working directory one way or another.\n@@ -993,7 +993,7 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n-    let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n+    let work_dir = tcx.sess.working_dir.to_string_lossy(false);\n     let flags = \"\\0\";\n     let out_dir = &tcx.output_filenames(LOCAL_CRATE).out_directory;\n     let split_name = if tcx.sess.target_can_use_split_dwarf() {"}, {"sha": "72e9163b88e21195bfce3cab152f423bbcf86222", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1144,7 +1144,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = tcx.const_caller_location((\n-                Symbol::intern(&caller.file.name.to_string()),\n+                Symbol::intern(&caller.file.name.prefer_remapped().to_string_lossy()),\n                 caller.line as u32,\n                 caller.col_display as u32 + 1,\n             ));"}, {"sha": "577baec21f064f232d96a83914619cdac7ce4004", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -126,7 +126,8 @@ impl AnnotateSnippetEmitterWriter {\n             }\n             // owned: line source, line index, annotations\n             type Owned = (String, usize, Vec<crate::snippet::Annotation>);\n-            let origin = primary_lo.file.name.to_string();\n+            let filename = primary_lo.file.name.prefer_local();\n+            let origin = filename.to_string_lossy();\n             let annotated_files: Vec<Owned> = annotated_files\n                 .into_iter()\n                 .flat_map(|annotated_file| {"}, {"sha": "c4c15136cf82ddf5e3ff6f9e09cccbb98839adc9", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1324,7 +1324,7 @@ impl EmitterWriter {\n                         buffer_msg_line_offset,\n                         &format!(\n                             \"{}:{}:{}\",\n-                            loc.file.name,\n+                            loc.file.name.prefer_local(),\n                             sm.doctest_offset_line(&loc.file.name, loc.line),\n                             loc.col.0 + 1,\n                         ),\n@@ -1338,7 +1338,7 @@ impl EmitterWriter {\n                         0,\n                         &format!(\n                             \"{}:{}:{}: \",\n-                            loc.file.name,\n+                            loc.file.name.prefer_local(),\n                             sm.doctest_offset_line(&loc.file.name, loc.line),\n                             loc.col.0 + 1,\n                         ),\n@@ -1362,12 +1362,12 @@ impl EmitterWriter {\n                     };\n                     format!(\n                         \"{}:{}{}\",\n-                        annotated_file.file.name,\n+                        annotated_file.file.name.prefer_local(),\n                         sm.doctest_offset_line(&annotated_file.file.name, first_line.line_index),\n                         col\n                     )\n                 } else {\n-                    annotated_file.file.name.to_string()\n+                    format!(\"{}\", annotated_file.file.name.prefer_local())\n                 };\n                 buffer.append(buffer_msg_line_offset + 1, &loc, Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {"}, {"sha": "5d175a3ade9a2438671595d829616d563c3d4499", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -468,7 +468,7 @@ impl DiagnosticSpan {\n         });\n \n         DiagnosticSpan {\n-            file_name: start.file.name.to_string(),\n+            file_name: start.file.name.prefer_local().to_string(),\n             byte_start: start.file.original_relative_byte_pos(span.lo()).0,\n             byte_end: start.file.original_relative_byte_pos(span.hi()).0,\n             line_start: start.line,"}, {"sha": "e1c218c640851fb2442b7bc6bb876a8ba0fa1450", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1084,13 +1084,18 @@ impl<'a> ExtCtxt<'a> {\n         // after macro expansion (that is, they are unhygienic).\n         if !path.is_absolute() {\n             let callsite = span.source_callsite();\n-            let mut result = match self.source_map().span_to_unmapped_path(callsite) {\n-                FileName::Real(name) => name.into_local_path(),\n+            let mut result = match self.source_map().span_to_filename(callsite) {\n+                FileName::Real(name) => name\n+                    .into_local_path()\n+                    .expect(\"attempting to resolve a file path in an external file\"),\n                 FileName::DocTest(path, _) => path,\n                 other => {\n                     return Err(self.struct_span_err(\n                         span,\n-                        &format!(\"cannot resolve relative path in non-file source `{}`\", other),\n+                        &format!(\n+                            \"cannot resolve relative path in non-file source `{}`\",\n+                            other.prefer_local()\n+                        ),\n                     ));\n                 }\n             };"}, {"sha": "f5c6bb3db654202ee1f7db9856107f58ba85fc17", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -361,9 +361,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // FIXME: Avoid visiting the crate as a `Mod` item,\n     // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let file_path = match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-            FileName::Real(name) => name.into_local_path(),\n-            other => PathBuf::from(other.to_string()),\n+        let file_path = match self.cx.source_map().span_to_filename(krate.span) {\n+            FileName::Real(name) => name\n+                .into_local_path()\n+                .expect(\"attempting to resolve a file path in an external file\"),\n+            other => PathBuf::from(other.prefer_local().to_string()),\n         };\n         let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n         self.cx.root_path = dir_path.clone();"}, {"sha": "7bf6502c976ca6d69fd49aa978ee6df9f0ae0406", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -638,10 +638,11 @@ impl server::SourceFile for Rustc<'_> {\n         match file.name {\n             FileName::Real(ref name) => name\n                 .local_path()\n+                .expect(\"attempting to get a file path in an imported file in `proc_macro::SourceFile::path`\")\n                 .to_str()\n                 .expect(\"non-UTF8 file path in `proc_macro::SourceFile::path`\")\n                 .to_string(),\n-            _ => file.name.to_string(),\n+            _ => file.name.prefer_local().to_string(),\n         }\n     }\n     fn is_real(&mut self, file: &Self::SourceFile) -> bool {\n@@ -785,7 +786,7 @@ fn ident_name_compatibility_hack(\n         if let ExpnKind::Macro { name: macro_name, .. } = orig_span.ctxt().outer_expn_data().kind {\n             let source_map = rustc.sess.source_map();\n             let filename = source_map.span_to_filename(orig_span);\n-            if let FileName::Real(RealFileName::Named(path)) = filename {\n+            if let FileName::Real(RealFileName::LocalPath(path)) = filename {\n                 let matches_prefix = |prefix, filename| {\n                     // Check for a path that ends with 'prefix*/src/<filename>'\n                     let mut iter = path.components().rev();\n@@ -848,7 +849,7 @@ fn ident_name_compatibility_hack(\n                 if macro_name == sym::tuple_from_req && matches_prefix(\"actix-web\", \"extract.rs\") {\n                     let snippet = source_map.span_to_snippet(orig_span);\n                     if snippet.as_deref() == Ok(\"$T\") {\n-                        if let FileName::Real(RealFileName::Named(macro_path)) =\n+                        if let FileName::Real(RealFileName::LocalPath(macro_path)) =\n                             source_map.span_to_filename(rustc.def_site)\n                         {\n                             if macro_path.to_string_lossy().contains(\"pin-project-internal-0.\") {"}, {"sha": "680f6af63f26c6528bdf9dacb62f58ac88de2c5a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1604,13 +1604,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             match (&terr, expected == found) {\n                 (TypeError::Sorts(values), extra) => {\n                     let sort_string = |ty: Ty<'tcx>| match (extra, ty.kind()) {\n-                        (true, ty::Opaque(def_id, _)) => format!(\n-                            \" (opaque type at {})\",\n-                            self.tcx\n+                        (true, ty::Opaque(def_id, _)) => {\n+                            let pos = self\n+                                .tcx\n                                 .sess\n                                 .source_map()\n-                                .mk_substr_filename(self.tcx.def_span(*def_id)),\n-                        ),\n+                                .lookup_char_pos(self.tcx.def_span(*def_id).lo());\n+                            format!(\n+                                \" (opaque type at <{}:{}:{}>)\",\n+                                pos.file.name.prefer_local(),\n+                                pos.line,\n+                                pos.col.to_usize() + 1,\n+                            )\n+                        }\n                         (true, _) => format!(\" ({})\", ty.sort_string(self.tcx)),\n                         (false, _) => \"\".to_string(),\n                     };"}, {"sha": "9005325f0b42d60d9921f6200363841fcc16f9a4", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -35,7 +35,6 @@ use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::Session;\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{FileName, RealFileName};\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n use tracing::{info, warn};\n@@ -531,10 +530,10 @@ fn output_conflicts_with_dir(output_paths: &[PathBuf]) -> Option<PathBuf> {\n     check_output(output_paths, check)\n }\n \n-fn escape_dep_filename(filename: &FileName) -> String {\n+fn escape_dep_filename(filename: &String) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4\n-    filename.to_string().replace(\" \", \"\\\\ \")\n+    filename.replace(\" \", \"\\\\ \")\n }\n \n // Makefile comments only need escaping newlines and `\\`.\n@@ -574,7 +573,7 @@ fn write_out_deps(\n             .iter()\n             .filter(|fmap| fmap.is_real_file())\n             .filter(|fmap| !fmap.is_imported())\n-            .map(|fmap| escape_dep_filename(&fmap.unmapped_path.as_ref().unwrap_or(&fmap.name)))\n+            .map(|fmap| escape_dep_filename(&fmap.name.prefer_local().to_string()))\n             .collect();\n \n         if let Some(ref backend) = sess.opts.debugging_opts.codegen_backend {\n@@ -586,16 +585,13 @@ fn write_out_deps(\n                 for cnum in resolver.cstore().crates_untracked() {\n                     let source = resolver.cstore().crate_source_untracked(cnum);\n                     if let Some((path, _)) = source.dylib {\n-                        let file_name = FileName::Real(RealFileName::Named(path));\n-                        files.push(escape_dep_filename(&file_name));\n+                        files.push(escape_dep_filename(&path.display().to_string()));\n                     }\n                     if let Some((path, _)) = source.rlib {\n-                        let file_name = FileName::Real(RealFileName::Named(path));\n-                        files.push(escape_dep_filename(&file_name));\n+                        files.push(escape_dep_filename(&path.display().to_string()));\n                     }\n                     if let Some((path, _)) = source.rmeta {\n-                        let file_name = FileName::Real(RealFileName::Named(path));\n-                        files.push(escape_dep_filename(&file_name));\n+                        files.push(escape_dep_filename(&path.display().to_string()));\n                     }\n                 }\n             });"}, {"sha": "17dc6fd1d52ee6a1c36e74933f4e47e1db692c6e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -724,6 +724,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(profile_emit, Some(PathBuf::from(\"abc\")));\n     tracked!(relax_elf_relocations, Some(true));\n     tracked!(relro_level, Some(RelroLevel::Full));\n+    tracked!(simulate_remapped_rust_src_base, Some(PathBuf::from(\"/rustc/abc\")));\n     tracked!(report_delayed_bugs, true);\n     tracked!(sanitizer, SanitizerSet::ADDRESS);\n     tracked!(sanitizer_memory_track_origins, 2);"}, {"sha": "e2e523fad66c06cc6a8ca020cf4e640a86678149", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1651,9 +1651,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             if let Some(virtual_dir) = virtual_rust_source_base_dir {\n                 if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n                     if let rustc_span::FileName::Real(old_name) = name {\n-                        if let rustc_span::RealFileName::Named(one_path) = old_name {\n-                            if let Ok(rest) = one_path.strip_prefix(virtual_dir) {\n-                                let virtual_name = one_path.clone();\n+                        if let rustc_span::RealFileName::Remapped { local_path: _, virtual_name } =\n+                            old_name\n+                        {\n+                            if let Ok(rest) = virtual_name.strip_prefix(virtual_dir) {\n+                                let virtual_name = virtual_name.clone();\n \n                                 // The std library crates are in\n                                 // `$sysroot/lib/rustlib/src/rust/library`, whereas other crates\n@@ -1689,8 +1691,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                     virtual_name.display(),\n                                     new_path.display(),\n                                 );\n-                                let new_name = rustc_span::RealFileName::Devirtualized {\n-                                    local_path: new_path,\n+                                let new_name = rustc_span::RealFileName::Remapped {\n+                                    local_path: Some(new_path),\n                                     virtual_name,\n                                 };\n                                 *old_name = new_name;\n@@ -1710,7 +1712,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     // containing the information we need.\n                     let rustc_span::SourceFile {\n                         mut name,\n-                        name_was_remapped,\n                         src_hash,\n                         start_pos,\n                         end_pos,\n@@ -1722,11 +1723,34 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         ..\n                     } = source_file_to_import;\n \n+                    // If this file is under $sysroot/lib/rustlib/src/ but has not been remapped\n+                    // during rust bootstrapping by `remap-debuginfo = true`, and the user\n+                    // wish to simulate that behaviour by -Z simulate-remapped-rust-src-base,\n+                    // then we change `name` to a similar state as if the rust was bootstrapped\n+                    // with `remap-debuginfo = true`.\n+                    // This is useful for testing so that tests about the effects of\n+                    // `try_to_translate_virtual_to_real` don't have to worry about how the\n+                    // compiler is bootstrapped.\n+                    if let Some(virtual_dir) =\n+                        &sess.opts.debugging_opts.simulate_remapped_rust_src_base\n+                    {\n+                        if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n+                            if let rustc_span::FileName::Real(ref mut old_name) = name {\n+                                if let rustc_span::RealFileName::LocalPath(local) = old_name {\n+                                    if let Ok(rest) = local.strip_prefix(real_dir) {\n+                                        *old_name = rustc_span::RealFileName::Remapped {\n+                                            local_path: None,\n+                                            virtual_name: virtual_dir.join(rest),\n+                                        };\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n                     // If this file's path has been remapped to `/rustc/$hash`,\n                     // we might be able to reverse that (also see comments above,\n                     // on `try_to_translate_virtual_to_real`).\n-                    // FIXME(eddyb) we could check `name_was_remapped` here,\n-                    // but in practice it seems to be always `false`.\n                     try_to_translate_virtual_to_real(&mut name);\n \n                     let source_length = (end_pos - start_pos).to_usize();\n@@ -1751,7 +1775,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                     let local_version = sess.source_map().new_imported_source_file(\n                         name,\n-                        name_was_remapped,\n                         src_hash,\n                         name_hash,\n                         source_length,"}, {"sha": "19c713665c7825bc7e38b07748955501bb94d28f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -28,9 +28,12 @@ use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n-use rustc_span::hygiene::{ExpnDataEncodeMode, HygieneEncodeContext, MacroKind};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n+use rustc_span::{\n+    hygiene::{ExpnDataEncodeMode, HygieneEncodeContext, MacroKind},\n+    RealFileName,\n+};\n use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n@@ -466,7 +469,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n-        let (working_dir, _cwd_remapped) = self.tcx.sess.working_dir.clone();\n         // By replacing the `Option` with `None`, we ensure that we can't\n         // accidentally serialize any more `Span`s after the source map encoding\n         // is done.\n@@ -485,18 +487,41 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .map(|(_, source_file)| {\n                 let mut adapted = match source_file.name {\n-                    // This path of this SourceFile has been modified by\n-                    // path-remapping, so we use it verbatim (and avoid\n-                    // cloning the whole map in the process).\n-                    _ if source_file.name_was_remapped => source_file.clone(),\n-\n-                    // Otherwise expand all paths to absolute paths because\n-                    // any relative paths are potentially relative to a\n-                    // wrong directory.\n-                    FileName::Real(ref name) => {\n-                        let name = name.stable_name();\n+                    FileName::Real(ref realname) => {\n                         let mut adapted = (**source_file).clone();\n-                        adapted.name = Path::new(&working_dir).join(name).into();\n+                        adapted.name = FileName::Real(match realname {\n+                            RealFileName::LocalPath(path_to_file) => {\n+                                // Prepend path of working directory onto potentially\n+                                // relative paths, because they could become relative\n+                                // to a wrong directory.\n+                                let working_dir = &self.tcx.sess.working_dir;\n+                                match working_dir {\n+                                    RealFileName::LocalPath(absolute) => {\n+                                        // If working_dir has not been remapped, then we emit a\n+                                        // LocalPath variant as it's likely to be a valid path\n+                                        RealFileName::LocalPath(\n+                                            Path::new(absolute).join(path_to_file),\n+                                        )\n+                                    }\n+                                    RealFileName::Remapped { local_path: _, virtual_name } => {\n+                                        // If working_dir has been remapped, then we emit\n+                                        // Remapped variant as the expanded path won't be valid\n+                                        RealFileName::Remapped {\n+                                            local_path: None,\n+                                            virtual_name: Path::new(virtual_name)\n+                                                .join(path_to_file),\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            RealFileName::Remapped { local_path: _, virtual_name } => {\n+                                RealFileName::Remapped {\n+                                    // We do not want any local path to be exported into metadata\n+                                    local_path: None,\n+                                    virtual_name: virtual_name.clone(),\n+                                }\n+                            }\n+                        });\n                         adapted.name_hash = {\n                             let mut hasher: StableHasher = StableHasher::new();\n                             adapted.name.hash(&mut hasher);"}, {"sha": "342cc9a7397b7cbb44231448b883b3f2fbba2787", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                     span,\n                     \"inconsistent DepNode at `{:?}` for `{}`: \\\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n-                    self.source_map.span_to_string(span),\n+                    self.source_map.span_to_diagnostic_string(span),\n                     node_str,\n                     self.definitions\n                         .def_path(self.current_dep_node_owner)"}, {"sha": "2d8f661ef59e92d233000ff1dd2358221fb242c1", "filename": "compiler/rustc_middle/src/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -61,8 +61,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n         let SourceFile {\n             name: _, // We hash the smaller name_hash instead of this\n             name_hash,\n-            name_was_remapped,\n-            unmapped_path: _,\n             cnum,\n             // Do not hash the source as it is not encoded\n             src: _,\n@@ -77,7 +75,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n         } = *self;\n \n         (name_hash as u64).hash_stable(hcx, hasher);\n-        name_was_remapped.hash_stable(hcx, hasher);\n \n         src_hash.hash_stable(hcx, hasher);\n "}, {"sha": "1cc7f235d7d21dec958528c4f1fa3a6b4689ecb6", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -2374,7 +2374,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                 )\n                             } else {\n                                 let span = tcx.hir().span(hir_id);\n-                                format!(\"[closure@{}]\", tcx.sess.source_map().span_to_string(span))\n+                                format!(\n+                                    \"[closure@{}]\",\n+                                    tcx.sess.source_map().span_to_diagnostic_string(span)\n+                                )\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n "}, {"sha": "cfb9cfd86f978ad4efb99d501216cd3b70ef1e66", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -667,7 +667,12 @@ pub trait PrettyPrinter<'tcx>:\n                     if let Some(did) = did.as_local() {\n                         let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n                         let span = self.tcx().hir().span(hir_id);\n-                        p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n+                        p!(write(\n+                            \"@{}\",\n+                            // This may end up in stderr diagnostics but it may also be emitted\n+                            // into MIR. Hence we use the remapped path if available\n+                            self.tcx().sess.source_map().span_to_embeddable_string(span)\n+                        ));\n                     } else {\n                         p!(write(\"@\"), print_def_path(did, substs));\n                     }\n@@ -702,7 +707,12 @@ pub trait PrettyPrinter<'tcx>:\n                             p!(\"@\", print_def_path(did.to_def_id(), substs));\n                         } else {\n                             let span = self.tcx().hir().span(hir_id);\n-                            p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n+                            p!(write(\n+                                \"@{}\",\n+                                // This may end up in stderr diagnostics but it may also be emitted\n+                                // into MIR. Hence we use the remapped path if available\n+                                self.tcx().sess.source_map().span_to_embeddable_string(span)\n+                            ));\n                         }\n                     } else {\n                         p!(write(\"@\"), print_def_path(did, substs));\n@@ -1407,7 +1417,13 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 if !self.empty_path {\n                     write!(self, \"::\")?;\n                 }\n-                write!(self, \"<impl at {}>\", self.tcx.sess.source_map().span_to_string(span))?;\n+                write!(\n+                    self,\n+                    \"<impl at {}>\",\n+                    // This may end up in stderr diagnostics but it may also be emitted\n+                    // into MIR. Hence we use the remapped path if available\n+                    self.tcx.sess.source_map().span_to_embeddable_string(span)\n+                )?;\n                 self.empty_path = false;\n \n                 return Ok(self);"}, {"sha": "5892ef37ebacb56df38b1306bfae5f16a7bc3eed", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -76,7 +76,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for constraint in &constraints {\n             let OutlivesConstraint { sup, sub, locations, category } = constraint;\n             let (name, arg) = match locations {\n-                Locations::All(span) => (\"All\", tcx.sess.source_map().span_to_string(*span)),\n+                Locations::All(span) => {\n+                    (\"All\", tcx.sess.source_map().span_to_embeddable_string(*span))\n+                }\n                 Locations::Single(loc) => (\"Single\", format!(\"{:?}\", loc)),\n             };\n             with_msg(&format!(\"{:?}: {:?} due to {:?} at {}({})\", sup, sub, category, name, arg))?;"}, {"sha": "e9dd7a3fe68f1cbfbee51a981154a9c50c86a379", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -263,7 +263,13 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n             }\n             if !self.span.is_dummy() {\n                 let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n-                write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n+                write!(\n+                    f,\n+                    \" at {}:{}:{}\",\n+                    lo.file.name.prefer_local(),\n+                    lo.line,\n+                    lo.col.to_usize() + 1\n+                )?;\n             }\n             Ok(())\n         })"}, {"sha": "2b996cf62a3d39166877d449973c9cf7399ad09c", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -106,7 +106,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         (\n-            Symbol::intern(&caller.file.name.to_string()),\n+            Symbol::intern(&caller.file.name.prefer_remapped().to_string_lossy()),\n             u32::try_from(caller.line).unwrap(),\n             u32::try_from(caller.col_display).unwrap().checked_add(1).unwrap(),\n         )"}, {"sha": "918d6ee4b0ccd51a34a92a757b62ffabcc54c770", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -169,8 +169,8 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         debug!(\n             \"instrumenting {:?}, fn sig span: {}, body span: {}\",\n             def_id,\n-            source_map.span_to_string(fn_sig_span),\n-            source_map.span_to_string(body_span)\n+            source_map.span_to_diagnostic_string(fn_sig_span),\n+            source_map.span_to_diagnostic_string(body_span)\n         );\n \n         let mut graphviz_data = debug::GraphvizData::new();\n@@ -311,7 +311,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let tcx = self.tcx;\n         let source_map = tcx.sess.source_map();\n         let body_span = self.body_span;\n-        let file_name = Symbol::intern(&self.source_file.name.to_string());\n+        let file_name = Symbol::intern(&self.source_file.name.prefer_remapped().to_string_lossy());\n \n         let mut bcb_counters = IndexVec::from_elem_n(None, self.basic_coverage_blocks.num_nodes());\n         for covspan in coverage_spans {\n@@ -332,8 +332,8 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 \"Calling make_code_region(file_name={}, source_file={:?}, span={}, body_span={})\",\n                 file_name,\n                 self.source_file,\n-                source_map.span_to_string(span),\n-                source_map.span_to_string(body_span)\n+                source_map.span_to_diagnostic_string(span),\n+                source_map.span_to_diagnostic_string(body_span)\n             );\n \n             inject_statement("}, {"sha": "955e85c944a5d4594e955844c3f0198a410f8df5", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -445,7 +445,10 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n             ty::Tuple(tys) if tys.is_empty() => {}\n             _ => {\n                 self.push(\"mir::Constant\");\n-                self.push(&format!(\"+ span: {}\", self.tcx.sess.source_map().span_to_string(*span)));\n+                self.push(&format!(\n+                    \"+ span: {}\",\n+                    self.tcx.sess.source_map().span_to_embeddable_string(*span)\n+                ));\n                 if let Some(user_ty) = user_ty {\n                     self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n                 }\n@@ -516,7 +519,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n }\n \n fn comment(tcx: TyCtxt<'_>, SourceInfo { span, scope }: SourceInfo) -> String {\n-    format!(\"scope {} at {}\", scope.index(), tcx.sess.source_map().span_to_string(span))\n+    format!(\"scope {} at {}\", scope.index(), tcx.sess.source_map().span_to_embeddable_string(span))\n }\n \n /// Prints local variables in a scope tree.\n@@ -617,7 +620,7 @@ fn write_scope_tree(\n                 \"{0:1$} // at {2}\",\n                 indented_header,\n                 ALIGN,\n-                tcx.sess.source_map().span_to_string(span),\n+                tcx.sess.source_map().span_to_embeddable_string(span),\n             )?;\n         } else {\n             writeln!(w, \"{}\", indented_header)?;\n@@ -1004,7 +1007,7 @@ fn write_user_type_annotations(\n             \"| {:?}: {:?} at {}\",\n             index.index(),\n             annotation.user_ty,\n-            tcx.sess.source_map().span_to_string(annotation.span)\n+            tcx.sess.source_map().span_to_embeddable_string(annotation.span)\n         )?;\n     }\n     if !body.user_type_annotations.is_empty() {"}, {"sha": "2103f2f093407b3e49290d1eb39d4cc835e47163", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -628,7 +628,7 @@ fn tooltip<'tcx>(\n ) -> String {\n     let source_map = tcx.sess.source_map();\n     let mut text = Vec::new();\n-    text.push(format!(\"{}: {}:\", spanview_id, &source_map.span_to_string(span)));\n+    text.push(format!(\"{}: {}:\", spanview_id, &source_map.span_to_embeddable_string(span)));\n     for statement in statements {\n         let source_range = source_range_no_file(tcx, &statement.source_info.span);\n         text.push(format!("}, {"sha": "077b19fa959596c1fba44713a6c075f3fbba95e8", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -188,8 +188,10 @@ pub fn maybe_file_to_stream(\n     override_span: Option<Span>,\n ) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n     let src = source_file.src.as_ref().unwrap_or_else(|| {\n-        sess.span_diagnostic\n-            .bug(&format!(\"cannot lex `source_file` without source: {}\", source_file.name));\n+        sess.span_diagnostic.bug(&format!(\n+            \"cannot lex `source_file` without source: {}\",\n+            source_file.name.prefer_local()\n+        ));\n     });\n \n     let (token_trees, unmatched_braces) ="}, {"sha": "4ceefa17bcf3d01ca84a39feac2fe722d330fb9d", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -132,9 +132,9 @@ enum LiveNodeKind {\n fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n     let sm = tcx.sess.source_map();\n     match lnk {\n-        UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_string(s)),\n-        ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_string(s)),\n-        VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_string(s)),\n+        UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_diagnostic_string(s)),\n+        ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_diagnostic_string(s)),\n+        VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_diagnostic_string(s)),\n         ClosureNode => \"Closure node\".to_owned(),\n         ExitNode => \"Exit node\".to_owned(),\n     }"}, {"sha": "c133f1a041719b73d0fbb8d29f5d31d967132ef5", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -717,7 +717,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         debug!(\n             \"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n             owner_id,\n-            self.tcx.sess.source_map().span_to_string(body.value.span),\n+            self.tcx.sess.source_map().span_to_diagnostic_string(body.value.span),\n             body_id,\n             self.cx.parent\n         );"}, {"sha": "efa5d7e7b113902721426d9a0e0c24442bd247b8", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -3451,7 +3451,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n         debug!(\n             node = ?self.tcx.hir().node_to_string(lifetime_ref.hir_id),\n-            span = ?self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n+            span = ?self.tcx.sess.source_map().span_to_diagnostic_string(lifetime_ref.span)\n         );\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n "}, {"sha": "54b6a1215858153f3924214e466085eff3817aae", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -190,7 +190,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n \n         let data = CompilationOptions {\n-            directory: self.tcx.sess.working_dir.0.clone(),\n+            directory: self.tcx.sess.working_dir.remapped_path_if_available().into(),\n             program,\n             arguments,\n             output: self.save_ctxt.compilation_output(crate_name),\n@@ -1112,7 +1112,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 name: String::new(),\n                 qualname,\n                 span,\n-                value: filename.to_string(),\n+                value: filename.prefer_remapped().to_string(),\n                 children,\n                 parent: None,\n                 decl_id: None,"}, {"sha": "bcd125ae01dde062e578821165469a37a3597127", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -80,7 +80,7 @@ impl<'tcx> SaveContext<'tcx> {\n         let end = sm.lookup_char_pos(span.hi());\n \n         SpanData {\n-            file_name: start.file.name.to_string().into(),\n+            file_name: start.file.name.prefer_remapped().to_string().into(),\n             byte_start: span.lo().0,\n             byte_end: span.hi().0,\n             line_start: Row::new_one_indexed(start.line as u32),\n@@ -290,7 +290,7 @@ impl<'tcx> SaveContext<'tcx> {\n                     name: item.ident.to_string(),\n                     qualname,\n                     span: self.span_from_span(item.ident.span),\n-                    value: filename.to_string(),\n+                    value: filename.prefer_remapped().to_string(),\n                     parent: None,\n                     children: m\n                         .item_ids"}, {"sha": "1947b04f441c30025dad52f7152a5ad43fc17a09", "filename": "compiler/rustc_save_analysis/src/span_utils.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -16,8 +16,7 @@ impl<'a> SpanUtils<'a> {\n \n     pub fn make_filename_string(&self, file: &SourceFile) -> String {\n         match &file.name {\n-            FileName::Real(name) if !file.name_was_remapped => {\n-                let path = name.local_path();\n+            FileName::Real(RealFileName::LocalPath(path)) => {\n                 if path.is_absolute() {\n                     self.sess\n                         .source_map()\n@@ -27,12 +26,15 @@ impl<'a> SpanUtils<'a> {\n                         .display()\n                         .to_string()\n                 } else {\n-                    self.sess.working_dir.0.join(&path).display().to_string()\n+                    self.sess\n+                        .working_dir\n+                        .remapped_path_if_available()\n+                        .join(&path)\n+                        .display()\n+                        .to_string()\n                 }\n             }\n-            // If the file name is already remapped, we assume the user\n-            // configured it the way they wanted to, so use that directly\n-            filename => filename.to_string(),\n+            filename => filename.prefer_remapped().to_string(),\n         }\n     }\n "}, {"sha": "d2145b2865b179469167b6c2932ab6e59ae02a6e", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -1201,6 +1201,9 @@ options! {\n         \"whether ELF relocations can be relaxed\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n         \"choose which RELRO level to use\"),\n+    simulate_remapped_rust_src_base: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"simulate the effect of remap-debuginfo = true at bootstrapping by remapping path \\\n+        to rust's source base directory. only meant for testing purposes\"),\n     report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n         \"immediately print bugs registered with `delay_span_bug` (default: no)\"),\n     sanitizer: SanitizerSet = (SanitizerSet::empty(), parse_sanitizers, [TRACKED],"}, {"sha": "1348b02b8780fa4975f934db61b2bb47781fe04e", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -23,8 +23,8 @@ use rustc_errors::registry::Registry;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_lint_defs::FutureBreakage;\n pub use rustc_span::crate_disambiguator::CrateDisambiguator;\n-use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n+use rustc_span::{edition::Edition, RealFileName};\n use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n@@ -125,9 +125,8 @@ pub struct Session {\n     /// The name of the root source file of the crate, in the local file system.\n     /// `None` means that there is no source file.\n     pub local_crate_source_file: Option<PathBuf>,\n-    /// The directory the compiler has been executed in plus a flag indicating\n-    /// if the value stored here has been affected by path remapping.\n-    pub working_dir: (PathBuf, bool),\n+    /// The directory the compiler has been executed in\n+    pub working_dir: RealFileName,\n \n     /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n     /// (sub)diagnostics that have been set once, but should not be set again,\n@@ -1356,7 +1355,12 @@ pub fn build_session(\n     let working_dir = env::current_dir().unwrap_or_else(|e| {\n         parse_sess.span_diagnostic.fatal(&format!(\"Current directory is invalid: {}\", e)).raise()\n     });\n-    let working_dir = file_path_mapping.map_prefix(working_dir);\n+    let (path, remapped) = file_path_mapping.map_prefix(working_dir.clone());\n+    let working_dir = if remapped {\n+        RealFileName::Remapped { local_path: Some(working_dir), virtual_name: path }\n+    } else {\n+        RealFileName::LocalPath(path)\n+    };\n \n     let cgu_reuse_tracker = if sopts.debugging_opts.query_dep_graph {\n         CguReuseTracker::new()"}, {"sha": "0301b3645913ae3005f8cbc1a94d421a70e3c2fd", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 121, "deletions": 55, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -114,52 +114,112 @@ pub fn with_default_session_globals<R>(f: impl FnOnce() -> R) -> R {\n // deserialization.\n scoped_tls::scoped_thread_local!(pub static SESSION_GLOBALS: SessionGlobals);\n \n-// FIXME: Perhaps this should not implement Rustc{Decodable, Encodable}\n-//\n // FIXME: We should use this enum or something like it to get rid of the\n // use of magic `/rust/1.x/...` paths across the board.\n-#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash)]\n-#[derive(HashStable_Generic, Decodable, Encodable)]\n+#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd)]\n+#[derive(HashStable_Generic, Decodable)]\n pub enum RealFileName {\n-    Named(PathBuf),\n-    /// For de-virtualized paths (namely paths into libstd that have been mapped\n-    /// to the appropriate spot on the local host's file system),\n-    Devirtualized {\n-        /// `local_path` is the (host-dependent) local path to the file.\n-        local_path: PathBuf,\n+    LocalPath(PathBuf),\n+    /// For remapped paths (namely paths into libstd that have been mapped\n+    /// to the appropriate spot on the local host's file system, and local file\n+    /// system paths that have been remapped with `FilePathMapping`),\n+    Remapped {\n+        /// `local_path` is the (host-dependent) local path to the file. This is\n+        /// None if the file was imported from another crate\n+        local_path: Option<PathBuf>,\n         /// `virtual_name` is the stable path rustc will store internally within\n         /// build artifacts.\n         virtual_name: PathBuf,\n     },\n }\n \n+impl Hash for RealFileName {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        // To prevent #70924 from happening again we should only hash the\n+        // remapped (virtualized) path if that exists. This is because\n+        // virtualized paths to sysroot crates (/rust/$hash or /rust/$version)\n+        // remain stable even if the corresponding local_path changes\n+        self.remapped_path_if_available().hash(state)\n+    }\n+}\n+\n+// This is functionally identical to #[derive(Encodable)], with the exception of\n+// an added assert statement\n+impl<S: Encoder> Encodable<S> for RealFileName {\n+    fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {\n+        encoder.emit_enum(\"RealFileName\", |encoder| match *self {\n+            RealFileName::LocalPath(ref local_path) => {\n+                encoder.emit_enum_variant(\"LocalPath\", 0, 1, |encoder| {\n+                    Ok({\n+                        encoder.emit_enum_variant_arg(0, |encoder| local_path.encode(encoder))?;\n+                    })\n+                })\n+            }\n+\n+            RealFileName::Remapped { ref local_path, ref virtual_name } => encoder\n+                .emit_enum_variant(\"Remapped\", 1, 2, |encoder| {\n+                    // For privacy and build reproducibility, we must not embed host-dependant path in artifacts\n+                    // if they have been remapped by --remap-path-prefix\n+                    assert!(local_path.is_none());\n+                    Ok({\n+                        encoder.emit_enum_variant_arg(0, |encoder| local_path.encode(encoder))?;\n+                        encoder.emit_enum_variant_arg(1, |encoder| virtual_name.encode(encoder))?;\n+                    })\n+                }),\n+        })\n+    }\n+}\n+\n impl RealFileName {\n-    /// Returns the path suitable for reading from the file system on the local host.\n-    /// Avoid embedding this in build artifacts; see `stable_name()` for that.\n-    pub fn local_path(&self) -> &Path {\n+    /// Returns the path suitable for reading from the file system on the local host,\n+    /// if this information exists.\n+    /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.\n+    pub fn local_path(&self) -> Option<&Path> {\n         match self {\n-            RealFileName::Named(p)\n-            | RealFileName::Devirtualized { local_path: p, virtual_name: _ } => &p,\n+            RealFileName::LocalPath(p) => Some(p),\n+            RealFileName::Remapped { local_path: p, virtual_name: _ } => {\n+                p.as_ref().map(PathBuf::as_path)\n+            }\n         }\n     }\n \n-    /// Returns the path suitable for reading from the file system on the local host.\n-    /// Avoid embedding this in build artifacts; see `stable_name()` for that.\n-    pub fn into_local_path(self) -> PathBuf {\n+    /// Returns the path suitable for reading from the file system on the local host,\n+    /// if this information exists.\n+    /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.\n+    pub fn into_local_path(self) -> Option<PathBuf> {\n         match self {\n-            RealFileName::Named(p)\n-            | RealFileName::Devirtualized { local_path: p, virtual_name: _ } => p,\n+            RealFileName::LocalPath(p) => Some(p),\n+            RealFileName::Remapped { local_path: p, virtual_name: _ } => p,\n         }\n     }\n \n-    /// Returns the path suitable for embedding into build artifacts. Note that\n-    /// a virtualized path will not correspond to a valid file system path; see\n-    /// `local_path()` for something that is more likely to return paths into the\n-    /// local host file system.\n-    pub fn stable_name(&self) -> &Path {\n+    /// Returns the path suitable for embedding into build artifacts. This would still\n+    /// be a local path if it has not been remapped. A remapped path will not correspond\n+    /// to a valid file system path: see `local_path_if_available()` for something that\n+    /// is more likely to return paths into the local host file system.\n+    pub fn remapped_path_if_available(&self) -> &Path {\n         match self {\n-            RealFileName::Named(p)\n-            | RealFileName::Devirtualized { local_path: _, virtual_name: p } => &p,\n+            RealFileName::LocalPath(p)\n+            | RealFileName::Remapped { local_path: _, virtual_name: p } => &p,\n+        }\n+    }\n+\n+    /// Returns the path suitable for reading from the file system on the local host,\n+    /// if this information exists. Otherwise returns the remapped name.\n+    /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.\n+    pub fn local_path_if_available(&self) -> &Path {\n+        match self {\n+            RealFileName::LocalPath(path)\n+            | RealFileName::Remapped { local_path: None, virtual_name: path }\n+            | RealFileName::Remapped { local_path: Some(path), virtual_name: _ } => path,\n+        }\n+    }\n+\n+    pub fn to_string_lossy(&self, prefer_local: bool) -> Cow<'_, str> {\n+        if prefer_local {\n+            self.local_path_if_available().to_string_lossy()\n+        } else {\n+            self.remapped_path_if_available().to_string_lossy()\n         }\n     }\n }\n@@ -188,16 +248,24 @@ pub enum FileName {\n     InlineAsm(u64),\n }\n \n-impl std::fmt::Display for FileName {\n+impl From<PathBuf> for FileName {\n+    fn from(p: PathBuf) -> Self {\n+        assert!(!p.to_string_lossy().ends_with('>'));\n+        FileName::Real(RealFileName::LocalPath(p))\n+    }\n+}\n+\n+pub struct FileNameDisplay<'a> {\n+    inner: &'a FileName,\n+    prefer_local: bool,\n+}\n+\n+impl fmt::Display for FileNameDisplay<'_> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         use FileName::*;\n-        match *self {\n-            Real(RealFileName::Named(ref path)) => write!(fmt, \"{}\", path.display()),\n-            // FIXME: might be nice to display both components of Devirtualized.\n-            // But for now (to backport fix for issue #70924), best to not\n-            // perturb diagnostics so its obvious test suite still works.\n-            Real(RealFileName::Devirtualized { ref local_path, virtual_name: _ }) => {\n-                write!(fmt, \"{}\", local_path.display())\n+        match *self.inner {\n+            Real(ref name) => {\n+                write!(fmt, \"{}\", name.to_string_lossy(self.prefer_local))\n             }\n             QuoteExpansion(_) => write!(fmt, \"<quote expansion>\"),\n             MacroExpansion(_) => write!(fmt, \"<macro expansion>\"),\n@@ -212,10 +280,12 @@ impl std::fmt::Display for FileName {\n     }\n }\n \n-impl From<PathBuf> for FileName {\n-    fn from(p: PathBuf) -> Self {\n-        assert!(!p.to_string_lossy().ends_with('>'));\n-        FileName::Real(RealFileName::Named(p))\n+impl FileNameDisplay<'_> {\n+    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n+        match self.inner {\n+            FileName::Real(ref inner) => inner.to_string_lossy(self.prefer_local),\n+            _ => Cow::from(format!(\"{}\", self)),\n+        }\n     }\n }\n \n@@ -236,6 +306,16 @@ impl FileName {\n         }\n     }\n \n+    pub fn prefer_remapped(&self) -> FileNameDisplay<'_> {\n+        FileNameDisplay { inner: self, prefer_local: false }\n+    }\n+\n+    // This may include transient local filesystem information.\n+    // Must not be embedded in build outputs.\n+    pub fn prefer_local(&self) -> FileNameDisplay<'_> {\n+        FileNameDisplay { inner: self, prefer_local: true }\n+    }\n+\n     pub fn macro_expansion_source_code(src: &str) -> FileName {\n         let mut hasher = StableHasher::new();\n         src.hash(&mut hasher);\n@@ -796,7 +876,7 @@ pub fn debug_with_source_map(\n     f: &mut fmt::Formatter<'_>,\n     source_map: &SourceMap,\n ) -> fmt::Result {\n-    write!(f, \"{} ({:?})\", source_map.span_to_string(span), span.ctxt())\n+    write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(span), span.ctxt())\n }\n \n pub fn default_span_debug(span: Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -1128,11 +1208,6 @@ pub struct SourceFile {\n     /// originate from files has names between angle brackets by convention\n     /// (e.g., `<anon>`).\n     pub name: FileName,\n-    /// `true` if the `name` field above has been modified by `--remap-path-prefix`.\n-    pub name_was_remapped: bool,\n-    /// The unmapped path of the file that the source came from.\n-    /// Set to `None` if the `SourceFile` was imported from an external crate.\n-    pub unmapped_path: Option<FileName>,\n     /// The complete source code.\n     pub src: Option<Lrc<String>>,\n     /// The source code's hash.\n@@ -1162,7 +1237,6 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"SourceFile\", 8, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n             s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n             s.emit_struct_field(\"start_pos\", 3, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", 4, |s| self.end_pos.encode(s))?;\n@@ -1237,8 +1311,6 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n     fn decode(d: &mut D) -> Result<SourceFile, D::Error> {\n         d.read_struct(\"SourceFile\", 8, |d| {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n-            let name_was_remapped: bool =\n-                d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n             let src_hash: SourceFileHash =\n                 d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n             let start_pos: BytePos =\n@@ -1282,8 +1354,6 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n             let cnum: CrateNum = d.read_struct_field(\"cnum\", 10, |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n-                name_was_remapped,\n-                unmapped_path: None,\n                 start_pos,\n                 end_pos,\n                 src: None,\n@@ -1304,15 +1374,13 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n \n impl fmt::Debug for SourceFile {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"SourceFile({})\", self.name)\n+        write!(fmt, \"SourceFile({:?})\", self.name)\n     }\n }\n \n impl SourceFile {\n     pub fn new(\n         name: FileName,\n-        name_was_remapped: bool,\n-        unmapped_path: FileName,\n         mut src: String,\n         start_pos: BytePos,\n         hash_kind: SourceFileHashAlgorithm,\n@@ -1334,8 +1402,6 @@ impl SourceFile {\n \n         SourceFile {\n             name,\n-            name_was_remapped,\n-            unmapped_path: Some(unmapped_path),\n             src: Some(Lrc::new(src)),\n             src_hash,\n             external_src: Lock::new(ExternalSource::Unneeded),"}, {"sha": "0dadd4192004f638d4d9a6c43b46a08e09fa6b68", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 43, "deletions": 69, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -15,11 +15,11 @@ pub use crate::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{AtomicU32, Lrc, MappedReadGuard, ReadGuard, RwLock};\n-use std::cmp;\n-use std::convert::TryFrom;\n use std::hash::Hash;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::Ordering;\n+use std::{clone::Clone, cmp};\n+use std::{convert::TryFrom, unreachable};\n \n use std::fs;\n use std::io;\n@@ -127,30 +127,13 @@ pub struct StableSourceFileId(u128);\n // StableSourceFileId, perhaps built atop source_file.name_hash.\n impl StableSourceFileId {\n     pub fn new(source_file: &SourceFile) -> StableSourceFileId {\n-        StableSourceFileId::new_from_pieces(\n-            &source_file.name,\n-            source_file.name_was_remapped,\n-            source_file.unmapped_path.as_ref(),\n-        )\n+        StableSourceFileId::new_from_name(&source_file.name)\n     }\n \n-    fn new_from_pieces(\n-        name: &FileName,\n-        name_was_remapped: bool,\n-        unmapped_path: Option<&FileName>,\n-    ) -> StableSourceFileId {\n+    fn new_from_name(name: &FileName) -> StableSourceFileId {\n         let mut hasher = StableHasher::new();\n \n-        if let FileName::Real(real_name) = name {\n-            // rust-lang/rust#70924: Use the stable (virtualized) name when\n-            // available. (We do not want artifacts from transient file system\n-            // paths for libstd to leak into our build artifacts.)\n-            real_name.stable_name().hash(&mut hasher)\n-        } else {\n-            name.hash(&mut hasher);\n-        }\n-        name_was_remapped.hash(&mut hasher);\n-        unmapped_path.hash(&mut hasher);\n+        name.hash(&mut hasher);\n \n         StableSourceFileId(hasher.finish())\n     }\n@@ -283,35 +266,15 @@ impl SourceMap {\n \n     fn try_new_source_file(\n         &self,\n-        mut filename: FileName,\n+        filename: FileName,\n         src: String,\n     ) -> Result<Lrc<SourceFile>, OffsetOverflowError> {\n-        // The path is used to determine the directory for loading submodules and\n-        // include files, so it must be before remapping.\n         // Note that filename may not be a valid path, eg it may be `<anon>` etc,\n         // but this is okay because the directory determined by `path.pop()` will\n         // be empty, so the working directory will be used.\n-        let unmapped_path = filename.clone();\n-\n-        let was_remapped;\n-        if let FileName::Real(real_filename) = &mut filename {\n-            match real_filename {\n-                RealFileName::Named(path_to_be_remapped)\n-                | RealFileName::Devirtualized {\n-                    local_path: path_to_be_remapped,\n-                    virtual_name: _,\n-                } => {\n-                    let mapped = self.path_mapping.map_prefix(path_to_be_remapped.clone());\n-                    was_remapped = mapped.1;\n-                    *path_to_be_remapped = mapped.0;\n-                }\n-            }\n-        } else {\n-            was_remapped = false;\n-        }\n+        let (filename, _) = self.path_mapping.map_filename_prefix(&filename);\n \n-        let file_id =\n-            StableSourceFileId::new_from_pieces(&filename, was_remapped, Some(&unmapped_path));\n+        let file_id = StableSourceFileId::new_from_name(&filename);\n \n         let lrc_sf = match self.source_file_by_stable_id(file_id) {\n             Some(lrc_sf) => lrc_sf,\n@@ -320,8 +283,6 @@ impl SourceMap {\n \n                 let source_file = Lrc::new(SourceFile::new(\n                     filename,\n-                    was_remapped,\n-                    unmapped_path,\n                     src,\n                     Pos::from_usize(start_pos),\n                     self.hash_kind,\n@@ -345,7 +306,6 @@ impl SourceMap {\n     pub fn new_imported_source_file(\n         &self,\n         filename: FileName,\n-        name_was_remapped: bool,\n         src_hash: SourceFileHash,\n         name_hash: u128,\n         source_len: usize,\n@@ -382,8 +342,6 @@ impl SourceMap {\n \n         let source_file = Lrc::new(SourceFile {\n             name: filename,\n-            name_was_remapped,\n-            unmapped_path: None,\n             src: None,\n             src_hash,\n             external_src: Lock::new(ExternalSource::Foreign {\n@@ -411,11 +369,6 @@ impl SourceMap {\n         source_file\n     }\n \n-    pub fn mk_substr_filename(&self, sp: Span) -> String {\n-        let pos = self.lookup_char_pos(sp.lo());\n-        format!(\"<{}:{}:{}>\", pos.file.name, pos.line, pos.col.to_usize() + 1)\n-    }\n-\n     // If there is a doctest offset, applies it to the line.\n     pub fn doctest_offset_line(&self, file: &FileName, orig: usize) -> usize {\n         match file {\n@@ -453,7 +406,7 @@ impl SourceMap {\n         }\n     }\n \n-    pub fn span_to_string(&self, sp: Span) -> String {\n+    fn span_to_string(&self, sp: Span, prefer_local: bool) -> String {\n         if self.files.borrow().source_files.is_empty() && sp.is_dummy() {\n             return \"no-location\".to_string();\n         }\n@@ -462,24 +415,28 @@ impl SourceMap {\n         let hi = self.lookup_char_pos(sp.hi());\n         format!(\n             \"{}:{}:{}: {}:{}\",\n-            lo.file.name,\n+            if prefer_local { lo.file.name.prefer_local() } else { lo.file.name.prefer_remapped() },\n             lo.line,\n             lo.col.to_usize() + 1,\n             hi.line,\n             hi.col.to_usize() + 1,\n         )\n     }\n \n-    pub fn span_to_filename(&self, sp: Span) -> FileName {\n-        self.lookup_char_pos(sp.lo()).file.name.clone()\n+    /// Format the span location suitable for embedding in build artifacts\n+    pub fn span_to_embeddable_string(&self, sp: Span) -> String {\n+        self.span_to_string(sp, false)\n+    }\n+\n+    /// Format the span location to be printed in diagnostics. Must not be emitted\n+    /// to build artifacts as this may leak local file paths. Use span_to_embeddable_string\n+    /// for string suitable for embedding.\n+    pub fn span_to_diagnostic_string(&self, sp: Span) -> String {\n+        self.span_to_string(sp, true)\n     }\n \n-    pub fn span_to_unmapped_path(&self, sp: Span) -> FileName {\n-        self.lookup_char_pos(sp.lo())\n-            .file\n-            .unmapped_path\n-            .clone()\n-            .expect(\"`SourceMap::span_to_unmapped_path` called for imported `SourceFile`?\")\n+    pub fn span_to_filename(&self, sp: Span) -> FileName {\n+        self.lookup_char_pos(sp.lo()).file.name.clone()\n     }\n \n     pub fn is_multiline(&self, sp: Span) -> bool {\n@@ -1001,7 +958,13 @@ impl SourceMap {\n     }\n     pub fn ensure_source_file_source_present(&self, source_file: Lrc<SourceFile>) -> bool {\n         source_file.add_external_src(|| match source_file.name {\n-            FileName::Real(ref name) => self.file_loader.read_file(name.local_path()).ok(),\n+            FileName::Real(ref name) => {\n+                if let Some(local_path) = name.local_path() {\n+                    self.file_loader.read_file(local_path).ok()\n+                } else {\n+                    None\n+                }\n+            }\n             _ => None,\n         })\n     }\n@@ -1046,9 +1009,20 @@ impl FilePathMapping {\n     fn map_filename_prefix(&self, file: &FileName) -> (FileName, bool) {\n         match file {\n             FileName::Real(realfile) => {\n-                let path = realfile.local_path();\n-                let (path, mapped) = self.map_prefix(path.to_path_buf());\n-                (FileName::Real(RealFileName::Named(path)), mapped)\n+                if let RealFileName::LocalPath(local_path) = realfile {\n+                    let (mapped_path, mapped) = self.map_prefix(local_path.to_path_buf());\n+                    let realfile = if mapped {\n+                        RealFileName::Remapped {\n+                            local_path: Some(local_path.clone()),\n+                            virtual_name: mapped_path,\n+                        }\n+                    } else {\n+                        realfile.clone()\n+                    };\n+                    (FileName::Real(realfile), mapped)\n+                } else {\n+                    unreachable!(\"attempted to remap an already remapped filename\");\n+                }\n             }\n             other => (other.clone(), false),\n         }"}, {"sha": "f13979941abee7ded0399227f2ee1222a8591227", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -193,7 +193,7 @@ fn t8() {\n fn t9() {\n     let sm = init_source_map();\n     let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n-    let sstr = sm.span_to_string(span);\n+    let sstr = sm.span_to_diagnostic_string(span);\n \n     assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n }\n@@ -229,7 +229,6 @@ fn t10() {\n \n     let SourceFile {\n         name,\n-        name_was_remapped,\n         src_hash,\n         start_pos,\n         end_pos,\n@@ -243,7 +242,6 @@ fn t10() {\n \n     let imported_src_file = sm.new_imported_source_file(\n         name,\n-        name_was_remapped,\n         src_hash,\n         name_hash,\n         (end_pos - start_pos).to_usize(),"}, {"sha": "7d802636bfac2eae9b785f83345f77375679cc3a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -164,7 +164,7 @@ impl ExternalCrate {\n \n     crate fn src_root(&self, tcx: TyCtxt<'_>) -> PathBuf {\n         match self.src(tcx) {\n-            FileName::Real(ref p) => match p.local_path().parent() {\n+            FileName::Real(ref p) => match p.local_path_if_available().parent() {\n                 Some(p) => p.to_path_buf(),\n                 None => PathBuf::new(),\n             },"}, {"sha": "3a4d39e1d7f72c9662be328a89fa00b6ffecbcdd", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -839,7 +839,7 @@ impl Collector {\n         if !item_path.is_empty() {\n             item_path.push(' ');\n         }\n-        format!(\"{} - {}(line {})\", filename, item_path, line)\n+        format!(\"{} - {}(line {})\", filename.prefer_local(), item_path, line)\n     }\n \n     crate fn set_position(&mut self, position: Span) {\n@@ -851,8 +851,10 @@ impl Collector {\n             let filename = source_map.span_to_filename(self.position);\n             if let FileName::Real(ref filename) = filename {\n                 if let Ok(cur_dir) = env::current_dir() {\n-                    if let Ok(path) = filename.local_path().strip_prefix(&cur_dir) {\n-                        return path.to_owned().into();\n+                    if let Some(local_path) = filename.local_path() {\n+                        if let Ok(path) = local_path.strip_prefix(&cur_dir) {\n+                            return path.to_owned().into();\n+                        }\n                     }\n                 }\n             }\n@@ -882,16 +884,22 @@ impl Tester for Collector {\n             self.compiling_test_count.fetch_add(1, Ordering::SeqCst);\n         }\n \n-        // FIXME(#44940): if doctests ever support path remapping, then this filename\n-        // needs to be the result of `SourceMap::span_to_unmapped_path`.\n         let path = match &filename {\n-            FileName::Real(path) => path.local_path().to_path_buf(),\n+            FileName::Real(path) => {\n+                if let Some(local_path) = path.local_path() {\n+                    local_path.to_path_buf()\n+                } else {\n+                    // Somehow we got the filename from the metadata of another crate, should never happen\n+                    unreachable!(\"doctest from a different crate\");\n+                }\n+            }\n             _ => PathBuf::from(r\"doctest.rs\"),\n         };\n \n         // For example `module/file.rs` would become `module_file_rs`\n         let file = filename\n-            .to_string()\n+            .prefer_local()\n+            .to_string_lossy()\n             .chars()\n             .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })\n             .collect::<String>();"}, {"sha": "8fd5d8b6b85b8730f7f2d81cc5e7dfd3bd34838a", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -293,7 +293,7 @@ impl<'tcx> Context<'tcx> {\n \n         // We can safely ignore synthetic `SourceFile`s.\n         let file = match item.span(self.tcx()).filename(self.sess()) {\n-            FileName::Real(ref path) => path.local_path().to_path_buf(),\n+            FileName::Real(ref path) => path.local_path_if_available().to_path_buf(),\n             _ => return None,\n         };\n         let file = &file;\n@@ -380,7 +380,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         } = options;\n \n         let src_root = match krate.src {\n-            FileName::Real(ref p) => match p.local_path().parent() {\n+            FileName::Real(ref p) => match p.local_path_if_available().parent() {\n                 Some(p) => p.to_path_buf(),\n                 None => PathBuf::new(),\n             },"}, {"sha": "5e2a94fe6845ff3026e12f7462702398ada8b53d", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -56,7 +56,11 @@ impl DocFolder for SourceCollector<'_, '_> {\n                 Err(e) => {\n                     self.scx.tcx.sess.span_err(\n                         item.span(self.scx.tcx).inner(),\n-                        &format!(\"failed to render source code for `{}`: {}\", filename, e),\n+                        &format!(\n+                            \"failed to render source code for `{}`: {}\",\n+                            filename.prefer_local(),\n+                            e\n+                        ),\n                     );\n                     false\n                 }\n@@ -76,7 +80,13 @@ impl SourceCollector<'_, 'tcx> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n         let p = match *filename {\n-            FileName::Real(ref file) => file.local_path().to_path_buf(),\n+            FileName::Real(ref file) => {\n+                if let Some(local_path) = file.local_path() {\n+                    local_path.to_path_buf()\n+                } else {\n+                    unreachable!(\"only the current crate should have sources emitted\");\n+                }\n+            }\n             _ => return Ok(()),\n         };\n         if self.scx.local_sources.contains_key(&*p) {\n@@ -113,7 +123,7 @@ impl SourceCollector<'_, 'tcx> {\n         href.push_str(&fname.to_string_lossy());\n \n         let title = format!(\"{} - source\", src_fname.to_string_lossy());\n-        let desc = format!(\"Source of the Rust file `{}`.\", filename);\n+        let desc = format!(\"Source of the Rust file `{}`.\", filename.prefer_remapped());\n         let page = layout::Page {\n             title: &title,\n             css_class: \"source\","}, {"sha": "e0e5db3b5634b67b0d89a9dbc8df60d2dddf93eb", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -64,18 +64,17 @@ impl JsonRenderer<'_> {\n     fn convert_span(&self, span: clean::Span) -> Option<Span> {\n         match span.filename(self.sess()) {\n             rustc_span::FileName::Real(name) => {\n-                let hi = span.hi(self.sess());\n-                let lo = span.lo(self.sess());\n-                Some(Span {\n-                    filename: match name {\n-                        rustc_span::RealFileName::Named(path) => path,\n-                        rustc_span::RealFileName::Devirtualized { local_path, virtual_name: _ } => {\n-                            local_path\n-                        }\n-                    },\n-                    begin: (lo.line, lo.col.to_usize()),\n-                    end: (hi.line, hi.col.to_usize()),\n-                })\n+                if let Some(local_path) = name.into_local_path() {\n+                    let hi = span.hi(self.sess());\n+                    let lo = span.lo(self.sess());\n+                    Some(Span {\n+                        filename: local_path,\n+                        begin: (lo.line, lo.col.to_usize()),\n+                        end: (hi.line, hi.col.to_usize()),\n+                    })\n+                } else {\n+                    None\n+                }\n             }\n             _ => None,\n         }"}, {"sha": "26a22f5b304945ccb2d426538c43b855821ad799", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n             &self\n                 .items\n                 .iter()\n-                .map(|(k, v)| (k.to_string(), v))\n+                .map(|(k, v)| (k.prefer_local().to_string(), v))\n                 .collect::<BTreeMap<String, &ItemCount>>(),\n         )\n         .expect(\"failed to convert JSON data to string\")\n@@ -159,7 +159,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n         for (file, &count) in &self.items {\n             if let Some(percentage) = count.percentage() {\n                 print_table_record(\n-                    &limit_filename_len(file.to_string()),\n+                    &limit_filename_len(file.prefer_local().to_string_lossy().into()),\n                     count,\n                     percentage,\n                     count.examples_percentage().unwrap_or(0.),\n@@ -225,7 +225,7 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                 // unless the user had an explicit `allow`\n                 let should_have_docs =\n                     level != lint::Level::Allow || matches!(source, LintLevelSource::Default);\n-                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, filename);\n+                debug!(\"counting {:?} {:?} in {:?}\", i.type_(), i.name, filename);\n                 self.items.entry(filename).or_default().count_item(\n                     has_docs,\n                     has_doc_example,"}, {"sha": "b66abc6bedf0f33437a98f6d7b2cc87ca83c57e5", "filename": "src/test/codegen/remap_path_prefix/issue-73167-remap-std.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fissue-73167-remap-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fissue-73167-remap-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fissue-73167-remap-std.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -0,0 +1,15 @@\n+// ignore-windows\n+\n+// compile-flags: -g  -C no-prepopulate-passes -Z simulate-remapped-rust-src-base=/rustc/xyz\n+\n+// Here we check that importing std will not cause real path to std source files\n+// to leak. If rustc was compiled with remap-debuginfo = true, this should be\n+// true automatically. If paths to std library hasn't been remapped, we use the\n+// above simulate-remapped-rust-src-base option to do it temporarily\n+\n+// CHECK: !DIFile(filename: \"{{/rustc/.*/library/std/src/panic.rs}}\"\n+fn main() {\n+    std::thread::spawn(|| {\n+        println!(\"hello\");\n+    });\n+}"}, {"sha": "314bf11e2d66616edc9f9636310fb5f483e221a8", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -47,7 +47,7 @@ pub struct MacroRefData {\n \n impl MacroRefData {\n     pub fn new(name: String, callee: Span, cx: &LateContext<'_>) -> Self {\n-        let mut path = cx.sess().source_map().span_to_filename(callee).to_string();\n+        let mut path = cx.sess().source_map().span_to_filename(callee).prefer_local().to_string();\n \n         // std lib paths are <::std::module::file type>\n         // so remove brackets, space and type.\n@@ -96,8 +96,7 @@ impl MacroUseImports {\n         let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n         if let Some(callee) = span.source_callee() {\n             if !self.collected.contains(&call_site) {\n-                self.mac_refs\n-                    .push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n+                self.mac_refs.push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n                 self.collected.insert(call_site);\n             }\n         }\n@@ -175,7 +174,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                                 .push((*item).to_string());\n                             check_dup.push((*item).to_string());\n                         }\n-                    },\n+                    }\n                     [root, rest @ ..] => {\n                         if rest.iter().all(|item| !check_dup.contains(&(*item).to_string())) {\n                             let filtered = rest\n@@ -199,7 +198,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                                 .push(rest.join(\"::\"));\n                             check_dup.extend(rest.iter().map(ToString::to_string));\n                         }\n-                    },\n+                    }\n                 }\n             }\n         }"}, {"sha": "f4e16483d8c3a65083b738164a12e3b0cb47012e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ff91f439bc09f566da211c6449821b4e949279/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e1ff91f439bc09f566da211c6449821b4e949279", "patch": "@@ -3650,6 +3650,12 @@ impl<'test> TestCx<'test> {\n             .join(\"library\");\n         normalize_path(&src_dir, \"$SRC_DIR\");\n \n+        if let Some(virtual_rust_source_base_dir) =\n+            option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\").map(PathBuf::from)\n+        {\n+            normalize_path(&virtual_rust_source_base_dir.join(\"library\"), \"$SRC_DIR\");\n+        }\n+\n         // Paths into the build directory\n         let test_build_dir = &self.config.build_base;\n         let parent_build_dir = test_build_dir.parent().unwrap().parent().unwrap().parent().unwrap();"}]}