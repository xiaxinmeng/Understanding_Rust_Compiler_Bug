{"sha": "470c5191f553eb86a3a849e88d642dbd09a32e25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MGM1MTkxZjU1M2ViODZhM2E4NDllODhkNjQyZGJkMDlhMzJlMjU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-06-29T15:51:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-29T15:51:21Z"}, "message": "Rollup merge of #34446 - jseyfried:refactor_decorators, r=nrc\n\nTreat `MultiDecorator`s as a special case of `MultiModifier`s\n\nThis deals with #32950 by using @durka's [option 1](https://github.com/rust-lang/rust/pull/33769#issuecomment-221774136).\nr? @nrc", "tree": {"sha": "6ca676f213157c9e8c017bc641a130c9e762d161", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ca676f213157c9e8c017bc641a130c9e762d161"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/470c5191f553eb86a3a849e88d642dbd09a32e25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/470c5191f553eb86a3a849e88d642dbd09a32e25", "html_url": "https://github.com/rust-lang/rust/commit/470c5191f553eb86a3a849e88d642dbd09a32e25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/470c5191f553eb86a3a849e88d642dbd09a32e25/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f74d0fb568936b75120094b25a5638c1fc49c51e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74d0fb568936b75120094b25a5638c1fc49c51e", "html_url": "https://github.com/rust-lang/rust/commit/f74d0fb568936b75120094b25a5638c1fc49c51e"}, {"sha": "a595ffaac5045eb8950785f050f9e0b76cc4f3eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a595ffaac5045eb8950785f050f9e0b76cc4f3eb", "html_url": "https://github.com/rust-lang/rust/commit/a595ffaac5045eb8950785f050f9e0b76cc4f3eb"}], "stats": {"total": 141, "additions": 53, "deletions": 88}, "files": [{"sha": "a10d8900140175244d4f64b108de19091a9a537d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 33, "deletions": 78, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/470c5191f553eb86a3a849e88d642dbd09a32e25/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470c5191f553eb86a3a849e88d642dbd09a32e25/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=470c5191f553eb86a3a849e88d642dbd09a32e25", "patch": "@@ -691,7 +691,7 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n }\n \n fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n-    let new_items: SmallVector<Annotatable> = match a {\n+    match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n                 it.and_then(|it| match it.node {\n@@ -728,63 +728,6 @@ fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector\n             expand_impl_item(ii.unwrap(), fld).into_iter().\n                 map(|ii| Annotatable::ImplItem(P(ii))).collect()\n         }\n-    };\n-\n-    new_items.into_iter().flat_map(|a| decorate(a, fld)).collect()\n-}\n-\n-fn decorate(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n-    let mut decorator_items = SmallVector::zero();\n-    let mut new_attrs = Vec::new();\n-    expand_decorators(a.clone(), fld, &mut decorator_items, &mut new_attrs);\n-\n-    let mut new_items = SmallVector::one(a.fold_attrs(new_attrs));\n-    new_items.push_all(decorator_items);\n-    new_items\n-}\n-\n-fn expand_decorators(a: Annotatable,\n-                     fld: &mut MacroExpander,\n-                     decorator_items: &mut SmallVector<Annotatable>,\n-                     new_attrs: &mut Vec<ast::Attribute>)\n-{\n-    for attr in a.attrs() {\n-        let mname = intern(&attr.name());\n-        match fld.cx.syntax_env.find(mname) {\n-            Some(rc) => match *rc {\n-                MultiDecorator(ref dec) => {\n-                    attr::mark_used(&attr);\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(mname),\n-                            span: Some(attr.span),\n-                            // attributes can do whatever they like,\n-                            // for now.\n-                            allow_internal_unstable: true,\n-                        }\n-                    });\n-\n-                    let mut items: SmallVector<Annotatable> = SmallVector::zero();\n-                    dec.expand(fld.cx,\n-                               attr.span,\n-                               &attr.node.value,\n-                               &a,\n-                               &mut |ann| items.push(ann));\n-\n-                    for item in items {\n-                        for configured_item in item.fold_with(&mut fld.strip_unconfigured()) {\n-                            decorator_items.extend(expand_annotatable(configured_item, fld));\n-                        }\n-                    }\n-\n-                    fld.cx.bt_pop();\n-                }\n-                _ => new_attrs.push((*attr).clone()),\n-            },\n-            _ => new_attrs.push((*attr).clone()),\n-        }\n     }\n }\n \n@@ -793,9 +736,12 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n     item = item.map_attrs(|mut attrs| {\n         for i in 0..attrs.len() {\n             if let Some(extension) = fld.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                if let MultiModifier(..) = *extension {\n-                    multi_modifier = Some((attrs.remove(i), extension));\n-                    break;\n+                match *extension {\n+                    MultiModifier(..) | MultiDecorator(..) => {\n+                        multi_modifier = Some((attrs.remove(i), extension));\n+                        break;\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n@@ -804,23 +750,32 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n \n     match multi_modifier {\n         None => expand_multi_modified(item, fld),\n-        Some((attr, extension)) => match *extension {\n-            MultiModifier(ref mac) => {\n-                attr::mark_used(&attr);\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: attr.span,\n-                    callee: NameAndSpan {\n-                        format: MacroAttribute(intern(&attr.name())),\n-                        span: Some(attr.span),\n-                        // attributes can do whatever they like, for now\n-                        allow_internal_unstable: true,\n-                    }\n-                });\n-                let modified = mac.expand(fld.cx, attr.span, &attr.node.value, item);\n-                fld.cx.bt_pop();\n-                modified.into_iter().flat_map(|it| expand_annotatable(it, fld)).collect()\n-            }\n-            _ => unreachable!(),\n+        Some((attr, extension)) => {\n+            attr::mark_used(&attr);\n+            fld.cx.bt_push(ExpnInfo {\n+                call_site: attr.span,\n+                callee: NameAndSpan {\n+                    format: MacroAttribute(intern(&attr.name())),\n+                    span: Some(attr.span),\n+                    // attributes can do whatever they like, for now\n+                    allow_internal_unstable: true,\n+                }\n+            });\n+\n+            let modified = match *extension {\n+                MultiModifier(ref mac) => mac.expand(fld.cx, attr.span, &attr.node.value, item),\n+                MultiDecorator(ref mac) => {\n+                    let mut items = Vec::new();\n+                    mac.expand(fld.cx, attr.span, &attr.node.value, &item,\n+                               &mut |item| items.push(item));\n+                    items.push(item);\n+                    items\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            fld.cx.bt_pop();\n+            modified.into_iter().flat_map(|it| expand_annotatable(it, fld)).collect()\n         }\n     }\n }"}, {"sha": "e01f4ed1f9bd233a932762ebf3cd110078703805", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/470c5191f553eb86a3a849e88d642dbd09a32e25/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470c5191f553eb86a3a849e88d642dbd09a32e25/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=470c5191f553eb86a3a849e88d642dbd09a32e25", "patch": "@@ -345,15 +345,18 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n /// This method helps to extract all the type parameters referenced from a\n /// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n /// is not global and starts with `T`, or a `TyQPath`.\n-fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast::Ty>> {\n+fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name], span: Span, cx: &ExtCtxt)\n+                        -> Vec<P<ast::Ty>> {\n     use syntax::visit;\n \n-    struct Visitor<'a> {\n+    struct Visitor<'a, 'b: 'a> {\n+        cx: &'a ExtCtxt<'b>,\n+        span: Span,\n         ty_param_names: &'a [ast::Name],\n         types: Vec<P<ast::Ty>>,\n     }\n \n-    impl<'a> visit::Visitor for Visitor<'a> {\n+    impl<'a, 'b> visit::Visitor for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &ast::Ty) {\n             match ty.node {\n                 ast::TyKind::Path(_, ref path) if !path.global => {\n@@ -371,11 +374,18 @@ fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast\n \n             visit::walk_ty(self, ty)\n         }\n+\n+        fn visit_mac(&mut self, mac: &ast::Mac) {\n+            let span = Span { expn_id: self.span.expn_id, ..mac.span };\n+            self.cx.span_err(span, \"`derive` cannot be used on items with type macros\");\n+        }\n     }\n \n     let mut visitor = Visitor {\n         ty_param_names: ty_param_names,\n         types: Vec::new(),\n+        span: span,\n+        cx: cx,\n     };\n \n     visit::Visitor::visit_ty(&mut visitor, ty);\n@@ -556,7 +566,7 @@ impl<'a> TraitDef<'a> {\n \n             let mut processed_field_types = HashSet::new();\n             for field_ty in field_tys {\n-                let tys = find_type_parameters(&field_ty, &ty_param_names);\n+                let tys = find_type_parameters(&field_ty, &ty_param_names, self.span, cx);\n \n                 for ty in tys {\n                     // if we have already handled this type, skip it"}, {"sha": "e8ca1c1fa98ff4a99c755f274b3a7d3aa2c8f799", "filename": "src/test/compile-fail/issue-32950.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/470c5191f553eb86a3a849e88d642dbd09a32e25/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470c5191f553eb86a3a849e88d642dbd09a32e25/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs?ref=470c5191f553eb86a3a849e88d642dbd09a32e25", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros, concat_idents, rustc_attrs)]\n-#![allow(unused)]\n+#![feature(type_macros, concat_idents)]\n \n-#[derive(Debug)] struct FooBar;\n-#[derive(Debug)] struct Baz<T>(T, concat_idents!(Foo, Bar));\n+#[derive(Debug)] //~ NOTE in this expansion\n+struct Baz<T>(\n+    concat_idents!(Foo, Bar) //~ ERROR `derive` cannot be used on items with type macros\n+);\n \n-#[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+fn main() {}"}]}