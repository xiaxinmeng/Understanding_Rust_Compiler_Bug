{"sha": "ea87f126bdf8de4acc4f74c14ac0ae10d95a2472", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhODdmMTI2YmRmOGRlNGFjYzRmNzRjMTRhYzBhZTEwZDk1YTI0NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-18T20:06:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-18T20:06:30Z"}, "message": "auto merge of #14275 : kballard/rust/bytes-return-static, r=huonw\n\nChange `bytes!()` to return\r\n\r\n    {\r\n        static BYTES: &'static [u8] = &[...];\r\n        BYTES\r\n    }\r\n\r\nThis gives it the `'static` lifetime, whereas before it had an rvalue\r\nlifetime. Until recently this would have prevented assigning `bytes!()`\r\nto a static, as in\r\n\r\n    static FOO: &'static [u8] = bytes!(1,2,3);\r\n\r\nbut #14183 fixed it so blocks are now allowed in constant expressions\r\n(with restrictions).\r\n\r\nFixes #11641.", "tree": {"sha": "98c8d99c9429a56f99e739be540b5cff5fe8ddbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c8d99c9429a56f99e739be540b5cff5fe8ddbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472", "html_url": "https://github.com/rust-lang/rust/commit/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63287eef27b1a23a1fc24a7b4453eb7bd8ec1f11", "url": "https://api.github.com/repos/rust-lang/rust/commits/63287eef27b1a23a1fc24a7b4453eb7bd8ec1f11", "html_url": "https://github.com/rust-lang/rust/commit/63287eef27b1a23a1fc24a7b4453eb7bd8ec1f11"}, {"sha": "bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "html_url": "https://github.com/rust-lang/rust/commit/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10"}], "stats": {"total": 54, "additions": 48, "deletions": 6}, "files": [{"sha": "b2088d2bc82f636fbe008f80533d3174daf027f0", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=ea87f126bdf8de4acc4f74c14ac0ae10d95a2472", "patch": "@@ -25,6 +25,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(e) => e,\n     };\n     let mut bytes = Vec::new();\n+    let mut err = false;\n \n     for expr in exprs.iter() {\n         match expr.node {\n@@ -40,7 +41,8 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 // u8 literal, push to vector expression\n                 ast::LitUint(v, ast::TyU8) => {\n                     if v > 0xFF {\n-                        cx.span_err(expr.span, \"too large u8 literal in bytes!\")\n+                        cx.span_err(expr.span, \"too large u8 literal in bytes!\");\n+                        err = true;\n                     } else {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     }\n@@ -49,9 +51,11 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 // integer literal, push to vector expression\n                 ast::LitIntUnsuffixed(v) => {\n                     if v > 0xFF {\n-                        cx.span_err(expr.span, \"too large integer literal in bytes!\")\n+                        cx.span_err(expr.span, \"too large integer literal in bytes!\");\n+                        err = true;\n                     } else if v < 0 {\n-                        cx.span_err(expr.span, \"negative integer literal in bytes!\")\n+                        cx.span_err(expr.span, \"negative integer literal in bytes!\");\n+                        err = true;\n                     } else {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     }\n@@ -62,17 +66,34 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     if v.is_ascii() {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     } else {\n-                        cx.span_err(expr.span, \"non-ascii char literal in bytes!\")\n+                        cx.span_err(expr.span, \"non-ascii char literal in bytes!\");\n+                        err = true;\n                     }\n                 }\n \n-                _ => cx.span_err(expr.span, \"unsupported literal in bytes!\")\n+                _ => {\n+                    cx.span_err(expr.span, \"unsupported literal in bytes!\");\n+                    err = true;\n+                }\n             },\n \n-            _ => cx.span_err(expr.span, \"non-literal in bytes!\")\n+            _ => {\n+                cx.span_err(expr.span, \"non-literal in bytes!\");\n+                err = true;\n+            }\n         }\n     }\n \n+    // For some reason using quote_expr!() here aborts if we threw an error.\n+    // I'm assuming that the end of the recursive parse tricks the compiler\n+    // into thinking this is a good time to stop. But we'd rather keep going.\n+    if err {\n+        // Since the compiler will stop after the macro expansion phase anyway, we\n+        // don't need type info, so we can just return a DummyResult\n+        return DummyResult::expr(sp);\n+    }\n+\n     let e = cx.expr_vec_slice(sp, bytes);\n+    let e = quote_expr!(cx, { static BYTES: &'static [u8] = $e; BYTES});\n     MacExpr::new(e)\n }"}, {"sha": "7f4bbda8e30d818422fdad3bc95141e857ecb5de", "filename": "src/test/run-pass/bytes-macro-static.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea87f126bdf8de4acc4f74c14ac0ae10d95a2472/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs?ref=ea87f126bdf8de4acc4f74c14ac0ae10d95a2472", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static FOO: &'static [u8] = bytes!(\"hello, world\");\n+\n+pub fn main() {\n+    let b = match true {\n+        true => bytes!(\"test\"),\n+        false => unreachable!()\n+    };\n+\n+    assert_eq!(b, \"test\".as_bytes());\n+    assert_eq!(FOO, \"hello, world\".as_bytes());\n+}"}]}