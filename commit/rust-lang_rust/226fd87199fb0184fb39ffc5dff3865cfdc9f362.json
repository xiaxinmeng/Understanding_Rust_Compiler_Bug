{"sha": "226fd87199fb0184fb39ffc5dff3865cfdc9f362", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNmZkODcxOTlmYjAxODRmYjM5ZmZjNWRmZjM4NjVjZmRjOWYzNjI=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-23T17:22:14Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-23T17:22:33Z"}, "message": "Make a bunch more of the iteration functions/methods marked pure. Closes #3253.", "tree": {"sha": "df254c129decd2b0487f6a768e12cfec72f09984", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df254c129decd2b0487f6a768e12cfec72f09984"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226fd87199fb0184fb39ffc5dff3865cfdc9f362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226fd87199fb0184fb39ffc5dff3865cfdc9f362", "html_url": "https://github.com/rust-lang/rust/commit/226fd87199fb0184fb39ffc5dff3865cfdc9f362", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226fd87199fb0184fb39ffc5dff3865cfdc9f362/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f0a9775bae31169153d36dfa586e899c90921d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f0a9775bae31169153d36dfa586e899c90921d5", "html_url": "https://github.com/rust-lang/rust/commit/0f0a9775bae31169153d36dfa586e899c90921d5"}], "stats": {"total": 250, "additions": 138, "deletions": 112}, "files": [{"sha": "7ae91aebed59b40f8d822fa206dc9a9a353fef2a", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -4,7 +4,7 @@ import ptr::addr_of;\n \n export init_op;\n export capacity;\n-export build_sized, build;\n+export build_sized, build, build_sized_opt;\n export map;\n export from_fn, from_elem;\n export unsafe;\n@@ -78,6 +78,24 @@ pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n+/**\n+ * Builds a vector by calling a provided function with an argument\n+ * function that pushes an element to the back of a vector.\n+ * This version takes an initial size for the vector.\n+ *\n+ * # Arguments\n+ *\n+ * * size - An option, maybe containing initial size of the vector to reserve\n+ * * builder - A function that will construct the vector. It recieves\n+ *             as an argument a function that will push an element\n+ *             onto the vector being constructed.\n+ */\n+#[inline(always)]\n+pure fn build_sized_opt<A>(size: option<uint>,\n+                           builder: fn(push: pure fn(+A))) -> @[A] {\n+    build_sized(size.get_default(4), builder)\n+}\n+\n // Appending\n #[inline(always)]\n pure fn append<T: copy>(lhs: @[T], rhs: &[const T]) -> @[T] {"}, {"sha": "2f7ae426517a53d44675d014b52d214b3af25704", "filename": "src/libcore/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -8,7 +8,7 @@ import Path = path::Path;\n import tuple::{TupleOps, ExtendedTupleOps};\n import str::{StrSlice, UniqueStr};\n import vec::{ConstVector, CopyableVector, ImmutableVector};\n-import vec::{ImmutableCopyableVector, IterTraitExtensions};\n+import vec::{ImmutableCopyableVector};\n import iter::{BaseIter, ExtendedIter, CopyableIter, Times, TimesIx};\n import num::Num;\n import ptr::Ptr;"}, {"sha": "cce13589bd5a7ac4c6f409177b1fe41912ad3960", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -95,7 +95,7 @@ impl T: iter::Times {\n         will execute the given function exactly x times. If we assume that \\\n         `x` is an int, this is functionally equivalent to \\\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n-    fn times(it: fn() -> bool) {\n+    pure fn times(it: fn() -> bool) {\n         if self < 0 {\n             fail fmt!{\"The .times method expects a nonnegative number, \\\n                        but found %?\", self};\n@@ -111,7 +111,7 @@ impl T: iter::Times {\n impl T: iter::TimesIx {\n     #[inline(always)]\n     /// Like `times`, but provides an index\n-    fn timesi(it: fn(uint) -> bool) {\n+    pure fn timesi(it: fn(uint) -> bool) {\n         let slf = self as uint;\n         if slf < 0u {\n             fail fmt!{\"The .timesi method expects a nonnegative number, \\"}, {"sha": "80ec6ce6feefd0e4775e84997e97f9c466240e9f", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -6,43 +6,39 @@ import inst::{IMPL_T, EACH, SIZE_HINT};\n export extensions;\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n-    fn each(blk: fn(A) -> bool) { EACH(self, blk) }\n-    fn size_hint() -> option<uint> { SIZE_HINT(self) }\n+    pure fn each(blk: fn(A) -> bool) { EACH(self, blk) }\n+    pure fn size_hint() -> option<uint> { SIZE_HINT(self) }\n }\n \n impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n-    fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n-    fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n-    fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n-    fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n+    pure fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n+    pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n+    pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n+    pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    fn contains(x: A) -> bool { iter::contains(self, x) }\n-    fn count(x: A) -> uint { iter::count(self, x) }\n-    fn position(f: fn(A) -> bool) -> option<uint> {\n+    pure fn contains(x: A) -> bool { iter::contains(self, x) }\n+    pure fn count(x: A) -> uint { iter::count(self, x) }\n+    pure fn position(f: fn(A) -> bool) -> option<uint> {\n         iter::position(self, f)\n     }\n }\n \n impl<A: copy> IMPL_T<A>: iter::CopyableIter<A> {\n-    fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    fn map_to_vec<B>(op: fn(A) -> B) -> ~[B] { iter::map_to_vec(self, op) }\n-    fn to_vec() -> ~[A] { iter::to_vec(self) }\n+    pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    pure fn to_vec() -> ~[A] { iter::to_vec(self) }\n \n     // FIXME--bug in resolve prevents this from working (#2611)\n     // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> ~[B] {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n-    fn min() -> A { iter::min(self) }\n-    fn max() -> A { iter::max(self) }\n-\n-    fn find(p: fn(A) -> bool) -> option<A> {\n-        for self.each |i| {\n-            if p(i) { return some(i) }\n-        }\n-        return none;\n-    }\n+    pure fn min() -> A { iter::min(self) }\n+    pure fn max() -> A { iter::max(self) }\n+    pure fn find(p: fn(A) -> bool) -> option<A> { iter::find(self, p) }\n }"}, {"sha": "47ac9e7aa374adb047aad72a3b36d0d4d10db489", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -29,6 +29,6 @@ pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     }\n }\n \n-fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n     some(self.len())\n }"}, {"sha": "045c52aa4fd4b07f605dc80294ca8a1cc78625ea", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -6,10 +6,10 @@ type IMPL_T<A> = dvec::DVec<A>;\n  *\n  * Attempts to access this dvec during iteration will fail.\n  */\n-fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n-    self.swap(|v| { vec::each(v, f); v })\n+pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+    unsafe { self.swap(|v| { vec::each(v, f); v }) }\n }\n \n-fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n     some(self.len())\n }"}, {"sha": "d0a502813db5160ad4dbb9105fd5c7388ce459c4", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -7,7 +7,7 @@ pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     }\n }\n \n-fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n     match self {\n       none => some(0u),\n       some(_) => some(1u)"}, {"sha": "b5b56756e11e9be683453c94016787c96718c918", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -1,107 +1,106 @@\n trait BaseIter<A> {\n-    fn each(blk: fn(A) -> bool);\n-    fn size_hint() -> option<uint>;\n+    pure fn each(blk: fn(A) -> bool);\n+    pure fn size_hint() -> option<uint>;\n }\n \n trait ExtendedIter<A> {\n-    fn eachi(blk: fn(uint, A) -> bool);\n-    fn all(blk: fn(A) -> bool) -> bool;\n-    fn any(blk: fn(A) -> bool) -> bool;\n-    fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B;\n-    fn contains(x: A) -> bool;\n-    fn count(x: A) -> uint;\n-    fn position(f: fn(A) -> bool) -> option<uint>;\n+    pure fn eachi(blk: fn(uint, A) -> bool);\n+    pure fn all(blk: fn(A) -> bool) -> bool;\n+    pure fn any(blk: fn(A) -> bool) -> bool;\n+    pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B;\n+    pure fn contains(x: A) -> bool;\n+    pure fn count(x: A) -> uint;\n+    pure fn position(f: fn(A) -> bool) -> option<uint>;\n }\n \n trait Times {\n-    fn times(it: fn() -> bool);\n+    pure fn times(it: fn() -> bool);\n }\n trait TimesIx{\n-    fn timesi(it: fn(uint) -> bool);\n+    pure fn timesi(it: fn(uint) -> bool);\n }\n \n trait CopyableIter<A:copy> {\n-    fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n-    fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n-    fn to_vec() -> ~[A];\n-    fn min() -> A;\n-    fn max() -> A;\n-    fn find(p: fn(A) -> bool) -> option<A>;\n+    pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n+    pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n+    pure fn to_vec() -> ~[A];\n+    pure fn min() -> A;\n+    pure fn max() -> A;\n+    pure fn find(p: fn(A) -> bool) -> option<A>;\n }\n \n-fn eachi<A,IA:BaseIter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n+pure fn eachi<A,IA:BaseIter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n     let mut i = 0u;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n         i += 1u;\n     }\n }\n \n-fn all<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+pure fn all<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n         if !blk(a) { return false; }\n     }\n     return true;\n }\n \n-fn any<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+pure fn any<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n         if blk(a) { return true; }\n     }\n     return false;\n }\n \n-fn filter_to_vec<A:copy,IA:BaseIter<A>>(self: IA,\n+pure fn filter_to_vec<A:copy,IA:BaseIter<A>>(self: IA,\n                                          prd: fn(A) -> bool) -> ~[A] {\n-    let mut result = ~[];\n-    self.size_hint().iter(|hint| vec::reserve(result, hint));\n-    for self.each |a| {\n-        if prd(a) { vec::push(result, a); }\n+    do vec::build_sized_opt(self.size_hint()) |push| {\n+        for self.each |a| {\n+            if prd(a) { push(a); }\n+        }\n     }\n-    return result;\n }\n \n-fn map_to_vec<A:copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n-    let mut result = ~[];\n-    self.size_hint().iter(|hint| vec::reserve(result, hint));\n-    for self.each |a| {\n-        vec::push(result, op(a));\n+pure fn map_to_vec<A:copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B)\n+    -> ~[B] {\n+    do vec::build_sized_opt(self.size_hint()) |push| {\n+        for self.each |a| {\n+            push(op(a));\n+        }\n     }\n-    return result;\n }\n \n-fn flat_map_to_vec<A:copy,B:copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n+pure fn flat_map_to_vec<A:copy,B:copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n     self: IA, op: fn(A) -> IB) -> ~[B] {\n \n-    let mut result = ~[];\n-    for self.each |a| {\n-        for op(a).each |b| {\n-            vec::push(result, b);\n+    do vec::build |push| {\n+        for self.each |a| {\n+            for op(a).each |b| {\n+                push(b);\n+            }\n         }\n     }\n-    return result;\n }\n \n-fn foldl<A,B,IA:BaseIter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n+pure fn foldl<A,B,IA:BaseIter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     let mut b <- b0;\n     for self.each |a| {\n         b = blk(b, a);\n     }\n     return b;\n }\n \n-fn to_vec<A:copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n+pure fn to_vec<A:copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(r, ~[a]))\n }\n \n-fn contains<A,IA:BaseIter<A>>(self: IA, x: A) -> bool {\n+pure fn contains<A,IA:BaseIter<A>>(self: IA, x: A) -> bool {\n     for self.each |a| {\n         if a == x { return true; }\n     }\n     return false;\n }\n \n-fn count<A,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n+pure fn count<A,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n     do foldl(self, 0u) |count, value| {\n         if value == x {\n             count + 1u\n@@ -111,7 +110,7 @@ fn count<A,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n     }\n }\n \n-fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n+pure fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n         -> option<uint> {\n     let mut i = 0;\n     for self.each |a| {\n@@ -125,15 +124,15 @@ fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n // iter interface, such as would provide \"reach\" in addition to \"each\". as is,\n // it would have to be implemented with foldr, which is too inefficient.\n \n-fn repeat(times: uint, blk: fn() -> bool) {\n+pure fn repeat(times: uint, blk: fn() -> bool) {\n     let mut i = 0u;\n     while i < times {\n         if !blk() { break }\n         i += 1u;\n     }\n }\n \n-fn min<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n+pure fn min<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         match a {\n           some(a_) if a_ < b => {\n@@ -149,7 +148,7 @@ fn min<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n     }\n }\n \n-fn max<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n+pure fn max<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         match a {\n           some(a_) if a_ > b => {\n@@ -165,6 +164,14 @@ fn max<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n     }\n }\n \n+pure fn find<A: copy,IA:BaseIter<A>>(self: IA,\n+                                     p: fn(A) -> bool) -> option<A> {\n+    for self.each |i| {\n+        if p(i) { return some(i) }\n+    }\n+    return none;\n+}\n+\n /*\n #[test]\n fn test_enumerate() {"}, {"sha": "95e4edbba5ce4b1e40d6ee08aa6b2de8b70b937b", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -87,7 +87,7 @@ impl T: iter::Times {\n         will execute the given function exactly x times. If we assume that \\\n         `x` is an int, this is functionally equivalent to \\\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n-    fn times(it: fn() -> bool) {\n+    pure fn times(it: fn() -> bool) {\n         let mut i = self;\n         while i > 0 {\n             if !it() { break }\n@@ -99,7 +99,7 @@ impl T: iter::Times {\n impl T: iter::TimesIx {\n     #[inline(always)]\n     /// Like `times`, but with an index, `eachi`-style.\n-    fn timesi(it: fn(uint) -> bool) {\n+    pure fn timesi(it: fn(uint) -> bool) {\n         let slf = self as uint;\n         let mut i = 0u;\n         while i < slf {"}, {"sha": "2c36e6bb5a0532aa5d22e8579b831286fbf8248b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226fd87199fb0184fb39ffc5dff3865cfdc9f362/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=226fd87199fb0184fb39ffc5dff3865cfdc9f362", "patch": "@@ -18,7 +18,7 @@ export len;\n export from_fn;\n export from_elem;\n export from_slice;\n-export build, build_sized;\n+export build, build_sized, build_sized_opt;\n export to_mut;\n export from_mut;\n export head;\n@@ -259,6 +259,24 @@ pure fn build<A>(builder: fn(push: pure fn(+A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n+/**\n+ * Builds a vector by calling a provided function with an argument\n+ * function that pushes an element to the back of a vector.\n+ * This version takes an initial size for the vector.\n+ *\n+ * # Arguments\n+ *\n+ * * size - An option, maybe containing initial size of the vector to reserve\n+ * * builder - A function that will construct the vector. It recieves\n+ *             as an argument a function that will push an element\n+ *             onto the vector being constructed.\n+ */\n+#[inline(always)]\n+pure fn build_sized_opt<A>(size: option<uint>,\n+                           builder: fn(push: pure fn(+A))) -> ~[A] {\n+    build_sized(size.get_default(4), builder)\n+}\n+\n /// Produces a mut vector from an immutable vector.\n pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n     unsafe { ::unsafe::transmute(v) }\n@@ -1505,7 +1523,6 @@ impl<T> &[T]: ImmutableVector<T> {\n \n trait ImmutableCopyableVector<T> {\n     pure fn filter(f: fn(T) -> bool) -> ~[T];\n-    pure fn find(f: fn(T) -> bool) -> option<T>;\n     pure fn rfind(f: fn(T) -> bool) -> option<T>;\n }\n \n@@ -1520,15 +1537,6 @@ impl<T: copy> &[T]: ImmutableCopyableVector<T> {\n      */\n     #[inline]\n     pure fn filter(f: fn(T) -> bool) -> ~[T] { filter(self, f) }\n-    /**\n-     * Search for the first element that matches a given predicate\n-     *\n-     * Apply function `f` to each element of `v`, starting from the first.\n-     * When function `f` returns true then an option containing the element\n-     * is returned. If `f` matches no elements then none is returned.\n-     */\n-    #[inline]\n-    pure fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n     /**\n      * Search for the last element that matches a given predicate\n      *\n@@ -1756,44 +1764,41 @@ mod u8 {\n // required in the slice.\n \n impl<A> &[A]: iter::BaseIter<A> {\n-    fn each(blk: fn(A) -> bool) { each(self, blk) }\n-    fn size_hint() -> option<uint> { some(len(self)) }\n+    pure fn each(blk: fn(A) -> bool) { each(self, blk) }\n+    pure fn size_hint() -> option<uint> { some(len(self)) }\n }\n \n impl<A> &[A]: iter::ExtendedIter<A> {\n-    fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n-    fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n-    fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n-    fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n+    pure fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n+    pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n+    pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n+    pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    fn contains(x: A) -> bool { iter::contains(self, x) }\n-    fn count(x: A) -> uint { iter::count(self, x) }\n-    fn position(f: fn(A) -> bool) -> option<uint> { iter::position(self, f) }\n-}\n-\n-trait IterTraitExtensions<A> {\n-    fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n-    fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n-    fn to_vec() -> ~[A];\n-    fn min() -> A;\n-    fn max() -> A;\n+    pure fn contains(x: A) -> bool { iter::contains(self, x) }\n+    pure fn count(x: A) -> uint { iter::count(self, x) }\n+    pure fn position(f: fn(A) -> bool) -> option<uint> {\n+        iter::position(self, f)\n+    }\n }\n \n-impl<A: copy> &[A]: IterTraitExtensions<A> {\n-    fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n+impl<A: copy> &[A]: iter::CopyableIter<A> {\n+    pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    fn map_to_vec<B>(op: fn(A) -> B) -> ~[B] { iter::map_to_vec(self, op) }\n-    fn to_vec() -> ~[A] { iter::to_vec(self) }\n+    pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    pure fn to_vec() -> ~[A] { iter::to_vec(self) }\n \n     // FIXME--bug in resolve prevents this from working (#2611)\n     // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> ~[B] {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n-    fn min() -> A { iter::min(self) }\n-    fn max() -> A { iter::max(self) }\n+    pure fn min() -> A { iter::min(self) }\n+    pure fn max() -> A { iter::max(self) }\n+    pure fn find(p: fn(A) -> bool) -> option<A> { iter::find(self, p) }\n }\n // ___________________________________________________________________________\n "}]}