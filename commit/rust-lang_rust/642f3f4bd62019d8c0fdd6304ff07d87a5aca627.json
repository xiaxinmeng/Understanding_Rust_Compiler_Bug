{"sha": "642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MmYzZjRiZDYyMDE5ZDhjMGZkZDYzMDRmZjA3ZDg3YTVhY2E2Mjc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-02T18:13:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-02T18:13:38Z"}, "message": "Merge #3798\n\n3798: Simplify r=Veetaha a=Veetaha\n\nbear with me\n\nCo-authored-by: veetaha <veetaha2@gmail.com>", "tree": {"sha": "41d140d0b9e2e53a347ab936f2f4e4716b606ea3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41d140d0b9e2e53a347ab936f2f4e4716b606ea3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehitSCRBK7hj4Ov3rIwAAdHIIAJvVkq7LZAbCUYFIcSoTeNKS\n5aIyM/rdwyWcaPexCPHd+qLD/+HjZfCg0S91hjA1svNxf58zcF35ckZ03ZgPJ6yr\nmu4MoTrlVjh2y6kgl7gX5IPXemLQXap2bk6mPg3hjMgBSFlNLu51g3JGZA9vl8h2\nJ21b6T6LehnfJjL+Vu3GoPbNVErFzpEIEQIQ03VemXEgnCygWFZZHTmXeaxzoh/y\nMoA7cEa9iAvrlesKWdKaQSAHfq84JNLxbyrKBDCHcpemKVyNg7uK8vWTX+FaurAG\nIH37MS3uC0yQMwTUqInXnu594tI3gsdhp1NrVH5R9wLrwUMn3Del3UlK071HAq0=\n=Kgwi\n-----END PGP SIGNATURE-----\n", "payload": "tree 41d140d0b9e2e53a347ab936f2f4e4716b606ea3\nparent 09b8ee30bab7040ec983968aaca90814029f4dc0\nparent c0cf60dca2a178ae66180a3d60b65dfec7243931\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585851218 +0000\ncommitter GitHub <noreply@github.com> 1585851218 +0000\n\nMerge #3798\n\n3798: Simplify r=Veetaha a=Veetaha\n\nbear with me\n\nCo-authored-by: veetaha <veetaha2@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "html_url": "https://github.com/rust-lang/rust/commit/642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09b8ee30bab7040ec983968aaca90814029f4dc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/09b8ee30bab7040ec983968aaca90814029f4dc0", "html_url": "https://github.com/rust-lang/rust/commit/09b8ee30bab7040ec983968aaca90814029f4dc0"}, {"sha": "c0cf60dca2a178ae66180a3d60b65dfec7243931", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0cf60dca2a178ae66180a3d60b65dfec7243931", "html_url": "https://github.com/rust-lang/rust/commit/c0cf60dca2a178ae66180a3d60b65dfec7243931"}], "stats": {"total": 214, "additions": 94, "deletions": 120}, "files": [{"sha": "0ab64a1e0523db2088881088c5af267f8e8822e5", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 54, "deletions": 75, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "patch": "@@ -62,16 +62,16 @@ pub struct PackageRoot {\n     /// Is a member of the current workspace\n     is_member: bool,\n }\n-\n impl PackageRoot {\n-    pub fn new(path: PathBuf, is_member: bool) -> PackageRoot {\n-        PackageRoot { path, is_member }\n+    pub fn new_member(path: PathBuf) -> PackageRoot {\n+        Self { path, is_member: true }\n     }\n-\n-    pub fn path(&self) -> &PathBuf {\n+    pub fn new_non_member(path: PathBuf) -> PackageRoot {\n+        Self { path, is_member: false }\n+    }\n+    pub fn path(&self) -> &Path {\n         &self.path\n     }\n-\n     pub fn is_member(&self) -> bool {\n         self.is_member\n     }\n@@ -130,70 +130,45 @@ impl ProjectWorkspace {\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n         match self {\n             ProjectWorkspace::Json { project } => {\n-                let mut roots = Vec::with_capacity(project.roots.len());\n-                for root in &project.roots {\n-                    roots.push(PackageRoot::new(root.path.clone(), true));\n-                }\n-                roots\n-            }\n-            ProjectWorkspace::Cargo { cargo, sysroot } => {\n-                let mut roots = Vec::with_capacity(cargo.packages().len() + sysroot.crates().len());\n-                for pkg in cargo.packages() {\n-                    let root = cargo[pkg].root().to_path_buf();\n-                    let member = cargo[pkg].is_member;\n-                    roots.push(PackageRoot::new(root, member));\n-                }\n-                for krate in sysroot.crates() {\n-                    roots.push(PackageRoot::new(sysroot[krate].root_dir().to_path_buf(), false))\n-                }\n-                roots\n+                project.roots.iter().map(|r| PackageRoot::new_member(r.path.clone())).collect()\n             }\n+            ProjectWorkspace::Cargo { cargo, sysroot } => cargo\n+                .packages()\n+                .map(|pkg| PackageRoot {\n+                    path: cargo[pkg].root().to_path_buf(),\n+                    is_member: cargo[pkg].is_member,\n+                })\n+                .chain(sysroot.crates().map(|krate| {\n+                    PackageRoot::new_non_member(sysroot[krate].root_dir().to_path_buf())\n+                }))\n+                .collect(),\n         }\n     }\n \n     pub fn out_dirs(&self) -> Vec<PathBuf> {\n         match self {\n             ProjectWorkspace::Json { project } => {\n-                let mut out_dirs = Vec::with_capacity(project.crates.len());\n-                for krate in &project.crates {\n-                    if let Some(out_dir) = &krate.out_dir {\n-                        out_dirs.push(out_dir.to_path_buf());\n-                    }\n-                }\n-                out_dirs\n+                project.crates.iter().filter_map(|krate| krate.out_dir.as_ref()).cloned().collect()\n             }\n-            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => {\n-                let mut out_dirs = Vec::with_capacity(cargo.packages().len());\n-                for pkg in cargo.packages() {\n-                    if let Some(out_dir) = &cargo[pkg].out_dir {\n-                        out_dirs.push(out_dir.to_path_buf());\n-                    }\n-                }\n-                out_dirs\n+            ProjectWorkspace::Cargo { cargo, sysroot: _ } => {\n+                cargo.packages().filter_map(|pkg| cargo[pkg].out_dir.as_ref()).cloned().collect()\n             }\n         }\n     }\n \n     pub fn proc_macro_dylib_paths(&self) -> Vec<PathBuf> {\n         match self {\n-            ProjectWorkspace::Json { project } => {\n-                let mut proc_macro_dylib_paths = Vec::with_capacity(project.crates.len());\n-                for krate in &project.crates {\n-                    if let Some(out_dir) = &krate.proc_macro_dylib_path {\n-                        proc_macro_dylib_paths.push(out_dir.to_path_buf());\n-                    }\n-                }\n-                proc_macro_dylib_paths\n-            }\n-            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => {\n-                let mut proc_macro_dylib_paths = Vec::with_capacity(cargo.packages().len());\n-                for pkg in cargo.packages() {\n-                    if let Some(dylib_path) = &cargo[pkg].proc_macro_dylib_path {\n-                        proc_macro_dylib_paths.push(dylib_path.to_path_buf());\n-                    }\n-                }\n-                proc_macro_dylib_paths\n-            }\n+            ProjectWorkspace::Json { project } => project\n+                .crates\n+                .iter()\n+                .filter_map(|krate| krate.proc_macro_dylib_path.as_ref())\n+                .cloned()\n+                .collect(),\n+            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => cargo\n+                .packages()\n+                .filter_map(|pkg| cargo[pkg].proc_macro_dylib_path.as_ref())\n+                .cloned()\n+                .collect(),\n         }\n     }\n \n@@ -216,10 +191,12 @@ impl ProjectWorkspace {\n         let mut crate_graph = CrateGraph::default();\n         match self {\n             ProjectWorkspace::Json { project } => {\n-                let mut crates = FxHashMap::default();\n-                for (id, krate) in project.crates.iter().enumerate() {\n-                    let crate_id = json_project::CrateId(id);\n-                    if let Some(file_id) = load(&krate.root_module) {\n+                let crates: FxHashMap<_, _> = project\n+                    .crates\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(seq_index, krate)| {\n+                        let file_id = load(&krate.root_module)?;\n                         let edition = match krate.edition {\n                             json_project::Edition::Edition2015 => Edition::Edition2015,\n                             json_project::Edition::Edition2018 => Edition::Edition2018,\n@@ -249,8 +226,8 @@ impl ProjectWorkspace {\n                             .clone()\n                             .map(|it| proc_macro_client.by_dylib_path(&it));\n                         // FIXME: No crate name in json definition such that we cannot add OUT_DIR to env\n-                        crates.insert(\n-                            crate_id,\n+                        Some((\n+                            json_project::CrateId(seq_index),\n                             crate_graph.add_crate_root(\n                                 file_id,\n                                 edition,\n@@ -261,9 +238,9 @@ impl ProjectWorkspace {\n                                 extern_source,\n                                 proc_macro.unwrap_or_default(),\n                             ),\n-                        );\n-                    }\n-                }\n+                        ))\n+                    })\n+                    .collect();\n \n                 for (id, krate) in project.crates.iter().enumerate() {\n                     for dep in &krate.deps {\n@@ -287,9 +264,11 @@ impl ProjectWorkspace {\n                 }\n             }\n             ProjectWorkspace::Cargo { cargo, sysroot } => {\n-                let mut sysroot_crates = FxHashMap::default();\n-                for krate in sysroot.crates() {\n-                    if let Some(file_id) = load(&sysroot[krate].root) {\n+                let sysroot_crates: FxHashMap<_, _> = sysroot\n+                    .crates()\n+                    .filter_map(|krate| {\n+                        let file_id = load(&sysroot[krate].root)?;\n+\n                         // Crates from sysroot have `cfg(test)` disabled\n                         let cfg_options = {\n                             let mut opts = default_cfg_options.clone();\n@@ -300,22 +279,22 @@ impl ProjectWorkspace {\n                         let env = Env::default();\n                         let extern_source = ExternSource::default();\n                         let proc_macro = vec![];\n+                        let crate_name = CrateName::new(&sysroot[krate].name)\n+                            .expect(\"Sysroot crate names should not contain dashes\");\n \n                         let crate_id = crate_graph.add_crate_root(\n                             file_id,\n                             Edition::Edition2018,\n-                            Some(\n-                                CrateName::new(&sysroot[krate].name)\n-                                    .expect(\"Sysroot crate names should not contain dashes\"),\n-                            ),\n+                            Some(crate_name),\n                             cfg_options,\n                             env,\n                             extern_source,\n                             proc_macro,\n                         );\n-                        sysroot_crates.insert(krate, crate_id);\n-                    }\n-                }\n+                        Some((krate, crate_id))\n+                    })\n+                    .collect();\n+\n                 for from in sysroot.crates() {\n                     for &to in sysroot[from].deps.iter() {\n                         let name = &sysroot[to].name;"}, {"sha": "69133e4e42188fbb5c88ac54fc77b071a6f3559b", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "patch": "@@ -36,8 +36,7 @@ pub(crate) fn load_cargo(\n     extern_dirs.extend(ws.out_dirs());\n \n     let mut project_roots = ws.to_roots();\n-    project_roots\n-        .extend(extern_dirs.iter().map(|path| PackageRoot::new(path.to_path_buf(), false)));\n+    project_roots.extend(extern_dirs.iter().cloned().map(PackageRoot::new_non_member));\n \n     let (sender, receiver) = unbounded();\n     let sender = Box::new(move |t| sender.send(t).unwrap());\n@@ -46,7 +45,7 @@ pub(crate) fn load_cargo(\n             .iter()\n             .map(|pkg_root| {\n                 RootEntry::new(\n-                    pkg_root.path().clone(),\n+                    pkg_root.path().to_owned(),\n                     RustPackageFilterBuilder::default()\n                         .set_member(pkg_root.is_member())\n                         .into_vfs_filter(),\n@@ -58,12 +57,12 @@ pub(crate) fn load_cargo(\n     );\n \n     let source_roots = roots\n-        .iter()\n-        .map(|&vfs_root| {\n+        .into_iter()\n+        .map(|vfs_root| {\n             let source_root_id = vfs_root_to_id(vfs_root);\n             let project_root = project_roots\n                 .iter()\n-                .find(|it| it.path() == &vfs.root2path(vfs_root))\n+                .find(|it| it.path() == vfs.root2path(vfs_root))\n                 .unwrap()\n                 .clone();\n             (source_root_id, project_root)"}, {"sha": "8d142919628c20e0a4387359ae3c7048fcb9f1d0", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "patch": "@@ -23,6 +23,7 @@ use lsp_types::{\n use ra_flycheck::{url_from_path_with_drive_lowercasing, CheckTask};\n use ra_ide::{Canceled, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n+use ra_project_model::{PackageRoot, ProjectWorkspace};\n use ra_vfs::{VfsFile, VfsTask, Watch};\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashSet;\n@@ -131,8 +132,8 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n             let registration_options = req::DidChangeWatchedFilesRegistrationOptions {\n                 watchers: workspaces\n                     .iter()\n-                    .flat_map(|ws| ws.to_roots())\n-                    .filter(|root| root.is_member())\n+                    .flat_map(ProjectWorkspace::to_roots)\n+                    .filter(PackageRoot::is_member)\n                     .map(|root| format!(\"{}/**/*.rs\", root.path().display()))\n                     .map(|glob_pattern| req::FileSystemWatcher { glob_pattern, kind: None })\n                     .collect(),"}, {"sha": "2c76418be09a950f2adbd1e2e15938e5c95a1783", "filename": "crates/rust-analyzer/src/main_loop/subscriptions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "patch": "@@ -17,6 +17,6 @@ impl Subscriptions {\n         self.subs.remove(&file_id);\n     }\n     pub(crate) fn subscriptions(&self) -> Vec<FileId> {\n-        self.subs.iter().cloned().collect()\n+        self.subs.iter().copied().collect()\n     }\n }"}, {"sha": "ff37a70080dc2e3ed9e86509f729790305c57b19", "filename": "crates/rust-analyzer/src/vfs_glob.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fvfs_glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fvfs_glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fvfs_glob.rs?ref=642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "patch": "@@ -29,10 +29,14 @@ impl RustPackageFilterBuilder {\n         self.is_member = is_member;\n         self\n     }\n-    pub fn exclude(mut self, glob: Glob) -> RustPackageFilterBuilder {\n-        self.exclude.add(glob);\n+\n+    pub fn exclude(mut self, globs: impl IntoIterator<Item = Glob>) -> RustPackageFilterBuilder {\n+        for glob in globs.into_iter() {\n+            self.exclude.add(glob);\n+        }\n         self\n     }\n+\n     pub fn into_vfs_filter(self) -> Box<dyn Filter> {\n         let RustPackageFilterBuilder { is_member, mut exclude } = self;\n         for &glob in ALWAYS_IGNORED {\n@@ -87,7 +91,7 @@ fn test_globs() {\n \n     let filter = RustPackageFilterBuilder::default()\n         .set_member(true)\n-        .exclude(Glob::new(\"src/llvm-project/**\").unwrap())\n+        .exclude(std::iter::once(Glob::new(\"src/llvm-project/**\").unwrap()))\n         .into_vfs_filter();\n \n     assert!(!filter.include_dir(RelativePath::new(\"src/llvm-project/clang\")));"}, {"sha": "365f57d8c71e9e9b743b66e7033eaa6fd90b14c7", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/642f3f4bd62019d8c0fdd6304ff07d87a5aca627/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "patch": "@@ -87,44 +87,35 @@ impl WorldState {\n     ) -> WorldState {\n         let mut change = AnalysisChange::new();\n \n-        let mut roots = Vec::new();\n-        roots.extend(folder_roots.iter().map(|path| {\n-            let mut filter = RustPackageFilterBuilder::default().set_member(true);\n-            for glob in exclude_globs.iter() {\n-                filter = filter.exclude(glob.clone());\n-            }\n-            RootEntry::new(path.clone(), filter.into_vfs_filter())\n-        }));\n-        for ws in workspaces.iter() {\n-            roots.extend(ws.to_roots().into_iter().map(|pkg_root| {\n-                let mut filter =\n-                    RustPackageFilterBuilder::default().set_member(pkg_root.is_member());\n-                for glob in exclude_globs.iter() {\n-                    filter = filter.exclude(glob.clone());\n-                }\n-                RootEntry::new(pkg_root.path().clone(), filter.into_vfs_filter())\n-            }));\n-        }\n-\n-        let mut extern_dirs = FxHashSet::default();\n-        for ws in workspaces.iter() {\n-            extern_dirs.extend(ws.out_dirs());\n-        }\n-\n-        let mut extern_source_roots = FxHashMap::default();\n-\n-        roots.extend(extern_dirs.iter().map(|path| {\n-            let mut filter = RustPackageFilterBuilder::default().set_member(false);\n-            for glob in exclude_globs.iter() {\n-                filter = filter.exclude(glob.clone());\n-            }\n-            RootEntry::new(PathBuf::from(&path), filter.into_vfs_filter())\n-        }));\n+        let extern_dirs: FxHashSet<_> =\n+            workspaces.iter().flat_map(ProjectWorkspace::out_dirs).collect();\n+\n+        let roots: Vec<_> = {\n+            let create_filter = |is_member| {\n+                RustPackageFilterBuilder::default()\n+                    .set_member(is_member)\n+                    .exclude(exclude_globs.iter().cloned())\n+                    .into_vfs_filter()\n+            };\n+            folder_roots\n+                .iter()\n+                .map(|path| RootEntry::new(path.clone(), create_filter(true)))\n+                .chain(workspaces.iter().flat_map(ProjectWorkspace::to_roots).map(|pkg_root| {\n+                    RootEntry::new(pkg_root.path().to_owned(), create_filter(pkg_root.is_member()))\n+                }))\n+                .chain(\n+                    extern_dirs\n+                        .iter()\n+                        .map(|path| RootEntry::new(path.to_owned(), create_filter(false))),\n+                )\n+                .collect()\n+        };\n \n         let (task_sender, task_receiver) = unbounded();\n         let task_sender = Box::new(move |t| task_sender.send(t).unwrap());\n         let (mut vfs, vfs_roots) = Vfs::new(roots, task_sender, watch);\n \n+        let mut extern_source_roots = FxHashMap::default();\n         for r in vfs_roots {\n             let vfs_root_path = vfs.root2path(r);\n             let is_local = folder_roots.iter().any(|it| vfs_root_path.starts_with(it));"}]}